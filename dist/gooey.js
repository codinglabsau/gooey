var l1 = Object.defineProperty;
var vv = (e) => {
  throw TypeError(e);
};
var i1 = (e, t, n) => t in e ? l1(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Vt = (e, t, n) => i1(e, typeof t != "symbol" ? t + "" : t, n), u1 = (e, t, n) => t.has(e) || vv("Cannot " + n);
var qr = (e, t, n) => (u1(e, t, "read from private field"), n ? n.call(e) : t.get(e)), mv = (e, t, n) => t.has(e) ? vv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n);
import * as Wo from "vue";
import { computed as E, ref as O, shallowRef as Zt, watch as ce, getCurrentScope as As, onScopeDispose as Is, shallowReadonly as Fo, unref as l, defineComponent as b, createBlock as C, openBlock as g, normalizeProps as ne, guardReactiveProps as oe, withCtx as y, renderSlot as w, mergeProps as A, withModifiers as We, nextTick as he, onMounted as be, toRefs as Be, createVNode as N, watchEffect as Me, normalizeStyle as vt, createCommentVNode as Pe, getCurrentInstance as ct, toRef as Fn, camelize as or, withKeys as Qe, toHandlers as d1, resolveDynamicComponent as mt, withDirectives as br, vShow as Xc, createTextVNode as Re, watchSyncEffect as ug, toDisplayString as Ve, isRef as ht, onBeforeMount as dg, onUnmounted as Ze, createElementBlock as U, Fragment as Fe, renderList as $t, useSlots as Jc, Teleport as Co, h as Bt, onBeforeUnmount as ka, inject as vn, provide as Mn, toHandlerKey as cg, onBeforeUpdate as c1, onUpdated as f1, reactive as Qt, readonly as Oa, markRaw as fg, createElementVNode as ye, vModelSelect as p1, Comment as Zc, cloneVNode as pg, toRaw as v1, mergeDefaults as ji, watchPostEffect as Qc, effectScope as Wi, customRef as Ki, normalizeClass as ae, toValue as me, withMemo as m1, isVNode as Uo, createApp as Ud, warn as vg, vModelText as mg, mergeModels as hv, useModel as h1, useAttrs as g1 } from "vue";
const TU = {
  darkMode: ["class"],
  safelist: ["dark"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))"
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))"
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))"
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))"
        }
      },
      borderRadius: {
        xl: "calc(var(--radius) + 4px)",
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" }
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }
        },
        "collapsible-down": {
          from: { height: "0" },
          to: { height: "var(--radix-collapsible-content-height)" }
        },
        "collapsible-up": {
          from: { height: "var(--radix-collapsible-content-height)" },
          to: { height: "0" }
        }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "collapsible-down": "collapsible-down 0.2s ease-in-out",
        "collapsible-up": "collapsible-up 0.2s ease-in-out"
      }
    }
  },
  plugins: []
};
function Yo(e, t) {
  return e - t * Math.floor(e / t);
}
const hg = 1721426;
function uo(e, t, n, a) {
  t = Rs(e, t);
  let o = t - 1, r = -2;
  return n <= 2 ? r = 0 : Ga(t) && (r = -1), hg - 1 + 365 * o + Math.floor(o / 4) - Math.floor(o / 100) + Math.floor(o / 400) + Math.floor((367 * n - 362) / 12 + r + a);
}
function Ga(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function Rs(e, t) {
  return e === "BC" ? 1 - t : t;
}
function Gi(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const y1 = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class Hn {
  fromJulianDay(t) {
    let n = t, a = n - hg, o = Math.floor(a / 146097), r = Yo(a, 146097), s = Math.floor(r / 36524), i = Yo(r, 36524), u = Math.floor(i / 1461), d = Yo(i, 1461), c = Math.floor(d / 365), f = o * 400 + s * 100 + u * 4 + c + (s !== 4 && c !== 4 ? 1 : 0), [p, v] = Gi(f), m = n - uo(p, v, 1, 1), h = 2;
    n < uo(p, v, 3, 1) ? h = 0 : Ga(v) && (h = 1);
    let _ = Math.floor(((m + h) * 12 + 373) / 367), x = n - uo(p, v, _, 1) + 1;
    return new kt(p, v, _, x);
  }
  toJulianDay(t) {
    return uo(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return y1[Ga(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return Ga(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const b1 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function Dt(e, t) {
  return t = cn(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function ef(e, t) {
  return t = cn(t, e.calendar), e = jd(e), t = jd(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function ja(e, t) {
  return tf(e.calendar, t.calendar) && Dt(e, t);
}
function gv(e, t) {
  return tf(e.calendar, t.calendar) && ef(e, t);
}
function tf(e, t) {
  var n, a, o, r;
  return (r = (o = (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && o !== void 0 ? o : (a = t.isEqual) === null || a === void 0 ? void 0 : a.call(t, e)) !== null && r !== void 0 ? r : e.identifier === t.identifier;
}
function gg(e, t) {
  return Dt(e, bg(t));
}
function yg(e, t, n) {
  let a = e.calendar.toJulianDay(e), o = C1(t), r = Math.ceil(a + 1 - o) % 7;
  return r < 0 && (r += 7), r;
}
function _1(e) {
  return ya(Date.now(), e);
}
function bg(e) {
  return B1(_1(e));
}
function _g(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function w1(e, t) {
  return yv(e) - yv(t);
}
function yv(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let ed = null;
function _r() {
  return ed == null && (ed = new Intl.DateTimeFormat().resolvedOptions().timeZone), ed;
}
function jd(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function bv(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
const _v = /* @__PURE__ */ new Map(), td = /* @__PURE__ */ new Map();
function x1(e) {
  if (Intl.Locale) {
    let n = _v.get(e);
    return n || (n = new Intl.Locale(e).maximize().region, n && _v.set(e, n)), n;
  }
  let t = e.split("-")[1];
  return t === "u" ? void 0 : t;
}
function C1(e) {
  let t = td.get(e);
  if (!t) {
    if (Intl.Locale) {
      let a = new Intl.Locale(e);
      if ("getWeekInfo" in a && (t = a.getWeekInfo(), t))
        return td.set(e, t), t.firstDay;
    }
    let n = x1(e);
    if (e.includes("-fw-")) {
      let a = e.split("-fw-")[1].split("-")[0];
      a === "mon" ? t = {
        firstDay: 1
      } : a === "tue" ? t = {
        firstDay: 2
      } : a === "wed" ? t = {
        firstDay: 3
      } : a === "thu" ? t = {
        firstDay: 4
      } : a === "fri" ? t = {
        firstDay: 5
      } : a === "sat" ? t = {
        firstDay: 6
      } : t = {
        firstDay: 0
      };
    } else e.includes("-ca-iso8601") ? t = {
      firstDay: 1
    } : t = {
      firstDay: n && b1[n] || 0
    };
    td.set(e, t);
  }
  return t.firstDay;
}
function rr(e) {
  e = cn(e, new Hn());
  let t = Rs(e.era, e.year);
  return wg(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function wg(e, t, n, a, o, r, s) {
  let i = /* @__PURE__ */ new Date();
  return i.setUTCHours(a, o, r, s), i.setUTCFullYear(e, t - 1, n), i.getTime();
}
function Wd(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === _r()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: n, month: a, day: o, hour: r, minute: s, second: i } = xg(e, t);
  return wg(n, a, o, r, s, i, 0) - Math.floor(e / 1e3) * 1e3;
}
const wv = /* @__PURE__ */ new Map();
function xg(e, t) {
  let n = wv.get(t);
  n || (n = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), wv.set(t, n));
  let a = n.formatToParts(new Date(e)), o = {};
  for (let r of a) r.type !== "literal" && (o[r.type] = r.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: o.era === "BC" || o.era === "B" ? -o.year + 1 : +o.year,
    month: +o.month,
    day: +o.day,
    hour: o.hour === "24" ? 0 : +o.hour,
    minute: +o.minute,
    second: +o.second
  };
}
const xv = 864e5;
function S1(e, t, n, a) {
  return (n === a ? [
    n
  ] : [
    n,
    a
  ]).filter((r) => $1(e, t, r));
}
function $1(e, t, n) {
  let a = xg(n, t);
  return e.year === a.year && e.month === a.month && e.day === a.day && e.hour === a.hour && e.minute === a.minute && e.second === a.second;
}
function ha(e, t, n = "compatible") {
  let a = sr(e);
  if (t === "UTC") return rr(a);
  if (t === _r() && n === "compatible") {
    a = cn(a, new Hn());
    let u = /* @__PURE__ */ new Date(), d = Rs(a.era, a.year);
    return u.setFullYear(d, a.month - 1, a.day), u.setHours(a.hour, a.minute, a.second, a.millisecond), u.getTime();
  }
  let o = rr(a), r = Wd(o - xv, t), s = Wd(o + xv, t), i = S1(a, t, o - r, o - s);
  if (i.length === 1) return i[0];
  if (i.length > 1) switch (n) {
    case "compatible":
    case "earlier":
      return i[0];
    case "later":
      return i[i.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (n) {
    case "earlier":
      return Math.min(o - r, o - s);
    case "compatible":
    case "later":
      return Math.max(o - r, o - s);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function Cg(e, t, n = "compatible") {
  return new Date(ha(e, t, n));
}
function ya(e, t) {
  let n = Wd(e, t), a = new Date(e + n), o = a.getUTCFullYear(), r = a.getUTCMonth() + 1, s = a.getUTCDate(), i = a.getUTCHours(), u = a.getUTCMinutes(), d = a.getUTCSeconds(), c = a.getUTCMilliseconds();
  return new ir(o < 1 ? "BC" : "AD", o < 1 ? -o + 1 : o, r, s, t, n, i, u, d, c);
}
function B1(e) {
  return new kt(e.calendar, e.era, e.year, e.month, e.day);
}
function sr(e, t) {
  let n = 0, a = 0, o = 0, r = 0;
  if ("timeZone" in e) ({ hour: n, minute: a, second: o, millisecond: r } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: n, minute: a, second: o, millisecond: r } = t), new lr(e.calendar, e.era, e.year, e.month, e.day, n, a, o, r);
}
function cn(e, t) {
  if (tf(e.calendar, t)) return e;
  let n = t.fromJulianDay(e.calendar.toJulianDay(e)), a = e.copy();
  return a.calendar = t, a.era = n.era, a.year = n.year, a.month = n.month, a.day = n.day, yo(a), a;
}
function P1(e, t, n) {
  if (e instanceof ir)
    return e.timeZone === t ? e : D1(e, t);
  let a = ha(e, t, n);
  return ya(a, t);
}
function E1(e) {
  let t = rr(e) - e.offset;
  return new Date(t);
}
function D1(e, t) {
  let n = rr(e) - e.offset;
  return cn(ya(n, t), e.calendar);
}
const Fr = 36e5;
function Yi(e, t) {
  let n = e.copy(), a = "hour" in n ? T1(n, t) : 0;
  Kd(n, t.years || 0), n.calendar.balanceYearMonth && n.calendar.balanceYearMonth(n, e), n.month += t.months || 0, Gd(n), Sg(n), n.day += (t.weeks || 0) * 7, n.day += t.days || 0, n.day += a, M1(n), n.calendar.balanceDate && n.calendar.balanceDate(n), n.year < 1 && (n.year = 1, n.month = 1, n.day = 1);
  let o = n.calendar.getYearsInEra(n);
  if (n.year > o) {
    var r, s;
    let u = (r = (s = n.calendar).isInverseEra) === null || r === void 0 ? void 0 : r.call(s, n);
    n.year = o, n.month = u ? 1 : n.calendar.getMonthsInYear(n), n.day = u ? 1 : n.calendar.getDaysInMonth(n);
  }
  n.month < 1 && (n.month = 1, n.day = 1);
  let i = n.calendar.getMonthsInYear(n);
  return n.month > i && (n.month = i, n.day = n.calendar.getDaysInMonth(n)), n.day = Math.max(1, Math.min(n.calendar.getDaysInMonth(n), n.day)), n;
}
function Kd(e, t) {
  var n, a;
  !((n = (a = e.calendar).isInverseEra) === null || n === void 0) && n.call(a, e) && (t = -t), e.year += t;
}
function Gd(e) {
  for (; e.month < 1; )
    Kd(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, Kd(e, 1);
}
function M1(e) {
  for (; e.day < 1; )
    e.month--, Gd(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, Gd(e);
}
function Sg(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function yo(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), Sg(e);
}
function $g(e) {
  let t = {};
  for (let n in e) typeof e[n] == "number" && (t[n] = -e[n]);
  return t;
}
function Bg(e, t) {
  return Yi(e, $g(t));
}
function nf(e, t) {
  let n = e.copy();
  return t.era != null && (n.era = t.era), t.year != null && (n.year = t.year), t.month != null && (n.month = t.month), t.day != null && (n.day = t.day), yo(n), n;
}
function ei(e, t) {
  let n = e.copy();
  return t.hour != null && (n.hour = t.hour), t.minute != null && (n.minute = t.minute), t.second != null && (n.second = t.second), t.millisecond != null && (n.millisecond = t.millisecond), O1(n), n;
}
function k1(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = ll(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = ll(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = ll(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = ll(e.hour, 24), t;
}
function O1(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function ll(e, t) {
  let n = e % t;
  return n < 0 && (n += t), n;
}
function T1(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, k1(e);
}
function af(e, t, n, a) {
  let o = e.copy();
  switch (t) {
    case "era": {
      let i = e.calendar.getEras(), u = i.indexOf(e.era);
      if (u < 0) throw new Error("Invalid era: " + e.era);
      u = ba(u, n, 0, i.length - 1, a == null ? void 0 : a.round), o.era = i[u], yo(o);
      break;
    }
    case "year":
      var r, s;
      !((r = (s = o.calendar).isInverseEra) === null || r === void 0) && r.call(s, o) && (n = -n), o.year = ba(e.year, n, -1 / 0, 9999, a == null ? void 0 : a.round), o.year === -1 / 0 && (o.year = 1), o.calendar.balanceYearMonth && o.calendar.balanceYearMonth(o, e);
      break;
    case "month":
      o.month = ba(e.month, n, 1, e.calendar.getMonthsInYear(e), a == null ? void 0 : a.round);
      break;
    case "day":
      o.day = ba(e.day, n, 1, e.calendar.getDaysInMonth(e), a == null ? void 0 : a.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(o), yo(o), o;
}
function Pg(e, t, n, a) {
  let o = e.copy();
  switch (t) {
    case "hour": {
      let r = e.hour, s = 0, i = 23;
      if ((a == null ? void 0 : a.hourCycle) === 12) {
        let u = r >= 12;
        s = u ? 12 : 0, i = u ? 23 : 11;
      }
      o.hour = ba(r, n, s, i, a == null ? void 0 : a.round);
      break;
    }
    case "minute":
      o.minute = ba(e.minute, n, 0, 59, a == null ? void 0 : a.round);
      break;
    case "second":
      o.second = ba(e.second, n, 0, 59, a == null ? void 0 : a.round);
      break;
    case "millisecond":
      o.millisecond = ba(e.millisecond, n, 0, 999, a == null ? void 0 : a.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return o;
}
function ba(e, t, n, a, o = !1) {
  if (o) {
    e += Math.sign(t), e < n && (e = a);
    let r = Math.abs(t);
    t > 0 ? e = Math.ceil(e / r) * r : e = Math.floor(e / r) * r, e > a && (e = n);
  } else
    e += t, e < n ? e = a - (n - e - 1) : e > a && (e = n + (e - a - 1));
  return e;
}
function Eg(e, t) {
  let n;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let o = Yi(sr(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    n = ha(o, e.timeZone);
  } else
    n = rr(e) - e.offset;
  n += t.milliseconds || 0, n += (t.seconds || 0) * 1e3, n += (t.minutes || 0) * 6e4, n += (t.hours || 0) * 36e5;
  let a = ya(n, e.timeZone);
  return cn(a, e.calendar);
}
function A1(e, t) {
  return Eg(e, $g(t));
}
function I1(e, t, n, a) {
  switch (t) {
    case "hour": {
      let o = 0, r = 23;
      if ((a == null ? void 0 : a.hourCycle) === 12) {
        let m = e.hour >= 12;
        o = m ? 12 : 0, r = m ? 23 : 11;
      }
      let s = sr(e), i = cn(ei(s, {
        hour: o
      }), new Hn()), u = [
        ha(i, e.timeZone, "earlier"),
        ha(i, e.timeZone, "later")
      ].filter((m) => ya(m, e.timeZone).day === i.day)[0], d = cn(ei(s, {
        hour: r
      }), new Hn()), c = [
        ha(d, e.timeZone, "earlier"),
        ha(d, e.timeZone, "later")
      ].filter((m) => ya(m, e.timeZone).day === d.day).pop(), f = rr(e) - e.offset, p = Math.floor(f / Fr), v = f % Fr;
      return f = ba(p, n, Math.floor(u / Fr), Math.floor(c / Fr), a == null ? void 0 : a.round) * Fr + v, cn(ya(f, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return Pg(e, t, n, a);
    case "era":
    case "year":
    case "month":
    case "day": {
      let o = af(sr(e), t, n, a), r = ha(o, e.timeZone);
      return cn(ya(r, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function R1(e, t, n) {
  let a = sr(e), o = ei(nf(a, t), t);
  if (o.compare(a) === 0) return e;
  let r = ha(o, e.timeZone, n);
  return cn(ya(r, e.timeZone), e.calendar);
}
function q1(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function Dg(e) {
  let t = cn(e, new Hn()), n;
  return t.era === "BC" ? n = t.year === 1 ? "0000" : "-" + String(Math.abs(1 - t.year)).padStart(6, "00") : n = String(t.year).padStart(4, "0"), `${n}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function Mg(e) {
  return `${Dg(e)}T${q1(e)}`;
}
function F1(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let n = Math.floor(e / 36e5), a = Math.floor(e % 36e5 / 6e4), o = Math.floor(e % 36e5 % 6e4 / 1e3), r = `${t}${String(n).padStart(2, "0")}:${String(a).padStart(2, "0")}`;
  return o !== 0 && (r += `:${String(o).padStart(2, "0")}`), r;
}
function V1(e) {
  return `${Mg(e)}${F1(e.offset)}[${e.timeZone}]`;
}
function N1(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function of(e, t, n) {
  N1(e, t), t.set(e, n);
}
function rf(e) {
  let t = typeof e[0] == "object" ? e.shift() : new Hn(), n;
  if (typeof e[0] == "string") n = e.shift();
  else {
    let s = t.getEras();
    n = s[s.length - 1];
  }
  let a = e.shift(), o = e.shift(), r = e.shift();
  return [
    t,
    n,
    a,
    o,
    r
  ];
}
var L1 = /* @__PURE__ */ new WeakMap();
class kt {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new kt(this.calendar, this.era, this.year, this.month, this.day) : new kt(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return Yi(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return Bg(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return nf(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return af(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return Cg(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Dg(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return _g(this, t);
  }
  constructor(...t) {
    of(this, L1, {
      writable: !0,
      value: void 0
    });
    let [n, a, o, r, s] = rf(t);
    this.calendar = n, this.era = a, this.year = o, this.month = r, this.day = s, yo(this);
  }
}
var z1 = /* @__PURE__ */ new WeakMap();
class lr {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new lr(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new lr(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return Yi(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return Bg(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return nf(ei(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return af(this, t, n, a);
      default:
        return Pg(this, t, n, a);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, n) {
    return Cg(this, t, n);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Mg(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let n = _g(this, t);
    return n === 0 ? w1(this, sr(t)) : n;
  }
  constructor(...t) {
    of(this, z1, {
      writable: !0,
      value: void 0
    });
    let [n, a, o, r, s] = rf(t);
    this.calendar = n, this.era = a, this.year = o, this.month = r, this.day = s, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, yo(this);
  }
}
var H1 = /* @__PURE__ */ new WeakMap();
class ir {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new ir(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new ir(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return Eg(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return A1(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, n) {
    return R1(this, t, n);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return I1(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return E1(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return V1(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - P1(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    of(this, H1, {
      writable: !0,
      value: void 0
    });
    let [n, a, o, r, s] = rf(t), i = t.shift(), u = t.shift();
    this.calendar = n, this.era = a, this.year = o, this.month = r, this.day = s, this.timeZone = i, this.offset = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, yo(this);
  }
}
const Xo = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], U1 = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], Rl = [
  1867,
  1911,
  1925,
  1988,
  2018
], Ua = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function Cv(e) {
  const t = Xo.findIndex(([n, a, o]) => e.year < n || e.year === n && e.month < a || e.year === n && e.month === a && e.day < o);
  return t === -1 ? Xo.length - 1 : t === 0 ? 0 : t - 1;
}
function nd(e) {
  let t = Rl[Ua.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new kt(e.year + t, e.month, e.day);
}
class j1 extends Hn {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = Cv(n);
    return new kt(this, Ua[a], n.year - Rl[a], n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(nd(t));
  }
  balanceDate(t) {
    let n = nd(t), a = Cv(n);
    Ua[a] !== t.era && (t.era = Ua[a], t.year = n.year - Rl[a]), this.constrainDate(t);
  }
  constrainDate(t) {
    let n = Ua.indexOf(t.era), a = U1[n];
    if (a != null) {
      let [o, r, s] = a, i = o - Rl[n];
      t.year = Math.max(1, Math.min(i, t.year)), t.year === i && (t.month = Math.min(r, t.month), t.month === r && (t.day = Math.min(s, t.day)));
    }
    if (t.year === 1 && n >= 0) {
      let [, o, r] = Xo[n];
      t.month = Math.max(o, t.month), t.month === o && (t.day = Math.max(r, t.day));
    }
  }
  getEras() {
    return Ua;
  }
  getYearsInEra(t) {
    let n = Ua.indexOf(t.era), a = Xo[n], o = Xo[n + 1];
    if (o == null)
      return 9999 - a[0] + 1;
    let r = o[0] - a[0];
    return (t.month < o[1] || t.month === o[1] && t.day < o[2]) && r++, r;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(nd(t));
  }
  getMinimumMonthInYear(t) {
    let n = Sv(t);
    return n ? n[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let n = Sv(t);
    return n && t.month === n[1] ? n[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function Sv(e) {
  if (e.year === 1) {
    let t = Ua.indexOf(e.era);
    return Xo[t];
  }
}
const kg = -543;
class W1 extends Hn {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = Rs(n.era, n.year);
    return new kt(this, a - kg, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay($v(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth($v(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function $v(e) {
  let [t, n] = Gi(e.year + kg);
  return new kt(t, n, e.month, e.day);
}
const ti = 1911;
function Og(e) {
  return e.era === "minguo" ? e.year + ti : 1 - e.year + ti;
}
function Bv(e) {
  let t = e - ti;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class K1 extends Hn {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = Rs(n.era, n.year), [o, r] = Bv(a);
    return new kt(this, o, r, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Pv(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [n, a] = Bv(Og(t));
    t.era = n, t.year = a;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Pv(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - ti;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function Pv(e) {
  let [t, n] = Gi(Og(e));
  return new kt(t, n, e.month, e.day);
}
const Ev = 1948320, Dv = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class G1 {
  fromJulianDay(t) {
    let n = t - Ev, a = 1 + Math.floor((33 * n + 3) / 12053), o = 365 * (a - 1) + Math.floor((8 * a + 21) / 33), r = n - o, s = r < 216 ? Math.floor(r / 31) : Math.floor((r - 6) / 30), i = r - Dv[s] + 1;
    return new kt(this, a, s + 1, i);
  }
  toJulianDay(t) {
    let n = Ev - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return n += Dv[t.month - 1], n += t.day, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || Yo(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const ad = 78, Mv = 80;
class Y1 extends Hn {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = n.year - ad, o = t - uo(n.era, n.year, 1, 1), r;
    o < Mv ? (a--, r = Ga(n.year - 1) ? 31 : 30, o += r + 155 + 90 + 10) : (r = Ga(n.year) ? 31 : 30, o -= Mv);
    let s, i;
    if (o < r)
      s = 1, i = o + 1;
    else {
      let u = o - r;
      u < 155 ? (s = Math.floor(u / 31) + 2, i = u % 31 + 1) : (u -= 155, s = Math.floor(u / 30) + 7, i = u % 30 + 1);
    }
    return new kt(this, a, s, i);
  }
  toJulianDay(t) {
    let n = t.year + ad, [a, o] = Gi(n), r, s;
    return Ga(o) ? (r = 31, s = uo(a, o, 3, 21)) : (r = 30, s = uo(a, o, 3, 22)), t.month === 1 ? s + t.day - 1 : (s += r + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (s += (t.month - 7) * 30), s += t.day - 1, s);
  }
  getDaysInMonth(t) {
    return t.month === 1 && Ga(t.year + ad) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const ni = 1948440, kv = 1948439, En = 1300, Vo = 1600, X1 = 460322;
function ai(e, t, n, a) {
  return a + Math.ceil(29.5 * (n - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function Tg(e, t, n) {
  let a = Math.floor((30 * (n - t) + 10646) / 10631), o = Math.min(12, Math.ceil((n - (29 + ai(t, a, 1, 1))) / 29.5) + 1), r = n - ai(t, a, o, 1) + 1;
  return new kt(e, a, o, r);
}
function Ov(e) {
  return (14 + 11 * e) % 30 < 11;
}
class sf {
  fromJulianDay(t) {
    return Tg(this, ni, t);
  }
  toJulianDay(t) {
    return ai(ni, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = 29 + t.month % 2;
    return t.month === 12 && Ov(t.year) && n++, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return Ov(t.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class J1 extends sf {
  fromJulianDay(t) {
    return Tg(this, kv, t);
  }
  toJulianDay(t) {
    return ai(kv, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const Z1 = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let Yd, Jo;
function ql(e) {
  return X1 + Jo[e - En];
}
function Yr(e, t) {
  let n = e - En, a = 1 << 11 - (t - 1);
  return Yd[n] & a ? 30 : 29;
}
function Tv(e, t) {
  let n = ql(e);
  for (let a = 1; a < t; a++) n += Yr(e, a);
  return n;
}
function Av(e) {
  return Jo[e + 1 - En] - Jo[e - En];
}
class Q1 extends sf {
  fromJulianDay(t) {
    let n = t - ni, a = ql(En), o = ql(Vo);
    if (n < a || n > o) return super.fromJulianDay(t);
    {
      let r = En - 1, s = 1, i = 1;
      for (; i > 0; ) {
        r++, i = n - ql(r) + 1;
        let u = Av(r);
        if (i === u) {
          s = 12;
          break;
        } else if (i < u) {
          let d = Yr(r, s);
          for (s = 1; i > d; )
            i -= d, s++, d = Yr(r, s);
          break;
        }
      }
      return new kt(this, r, s, n - Tv(r, s) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < En || t.year > Vo ? super.toJulianDay(t) : ni + Tv(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < En || t.year > Vo ? super.getDaysInMonth(t) : Yr(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < En || t.year > Vo ? super.getDaysInYear(t) : Av(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", Yd || (Yd = new Uint16Array(Uint8Array.from(atob(Z1), (t) => t.charCodeAt(0)).buffer)), !Jo) {
      Jo = new Uint32Array(Vo - En + 1);
      let t = 0;
      for (let n = En; n <= Vo; n++) {
        Jo[n - En] = t;
        for (let a = 1; a <= 12; a++) t += Yr(n, a);
      }
    }
  }
}
const Iv = 347997, Ag = 1080, Ig = 24 * Ag, ex = 29, tx = 12 * Ag + 793, nx = ex * Ig + tx;
function io(e) {
  return Yo(e * 7 + 1, 19) < 7;
}
function Fl(e) {
  let t = Math.floor((235 * e - 234) / 19), n = 12084 + 13753 * t, a = t * 29 + Math.floor(n / 25920);
  return Yo(3 * (a + 1), 7) < 3 && (a += 1), a;
}
function ax(e) {
  let t = Fl(e - 1), n = Fl(e);
  return Fl(e + 1) - n === 356 ? 2 : n - t === 382 ? 1 : 0;
}
function os(e) {
  return Fl(e) + ax(e);
}
function Rg(e) {
  return os(e + 1) - os(e);
}
function ox(e) {
  let t = Rg(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    case 354:
      return 1;
    case 355:
      return 2;
  }
}
function il(e, t) {
  if (t >= 6 && !io(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let n = ox(e);
  return t === 2 ? n === 2 ? 30 : 29 : t === 3 ? n === 0 ? 29 : 30 : t === 6 ? io(e) ? 30 : 0 : 30;
}
class rx {
  fromJulianDay(t) {
    let n = t - Iv, a = n * Ig / nx, o = Math.floor((19 * a + 234) / 235) + 1, r = os(o), s = Math.floor(n - r);
    for (; s < 1; )
      o--, r = os(o), s = Math.floor(n - r);
    let i = 1, u = 0;
    for (; u < s; )
      u += il(o, i), i++;
    i--, u -= il(o, i);
    let d = s - u;
    return new kt(this, o, i, d);
  }
  toJulianDay(t) {
    let n = os(t.year);
    for (let a = 1; a < t.month; a++) n += il(t.year, a);
    return n + t.day + Iv;
  }
  getDaysInMonth(t) {
    return il(t.year, t.month);
  }
  getMonthsInYear(t) {
    return io(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return Rg(t.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, n) {
    n.year !== t.year && (io(n.year) && !io(t.year) && n.month > 6 ? t.month-- : !io(n.year) && io(t.year) && n.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const Xd = 1723856, Rv = 1824665, Jd = 5500;
function oi(e, t, n, a) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (n - 1) + a - 1;
}
function lf(e, t) {
  let n = Math.floor(4 * (t - e) / 1461), a = 1 + Math.floor((t - oi(e, n, 1, 1)) / 30), o = t + 1 - oi(e, n, a, 1);
  return [
    n,
    a,
    o
  ];
}
function qg(e) {
  return Math.floor(e % 4 / 3);
}
function Fg(e, t) {
  return t % 13 !== 0 ? 30 : qg(e) + 5;
}
class uf {
  fromJulianDay(t) {
    let [n, a, o] = lf(Xd, t), r = "AM";
    return n <= 0 && (r = "AA", n += Jd), new kt(this, r, n, a, o);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "AA" && (n -= Jd), oi(Xd, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    return Fg(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + qg(t.year);
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class sx extends uf {
  fromJulianDay(t) {
    let [n, a, o] = lf(Xd, t);
    return n += Jd, new kt(this, "AA", n, a, o);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class lx extends uf {
  fromJulianDay(t) {
    let [n, a, o] = lf(Rv, t), r = "CE";
    return n <= 0 && (r = "BCE", n = 1 - n), new kt(this, r, n, a, o);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), oi(Rv, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Fg(n, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function ix(e) {
  switch (e) {
    case "buddhist":
      return new W1();
    case "ethiopic":
      return new uf();
    case "ethioaa":
      return new sx();
    case "coptic":
      return new lx();
    case "hebrew":
      return new rx();
    case "indian":
      return new Y1();
    case "islamic-civil":
      return new sf();
    case "islamic-tbla":
      return new J1();
    case "islamic-umalqura":
      return new Q1();
    case "japanese":
      return new j1();
    case "persian":
      return new G1();
    case "roc":
      return new K1();
    case "gregory":
    default:
      return new Hn();
  }
}
let od = /* @__PURE__ */ new Map();
class va {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)} – ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.formatter.formatToParts(t), o = this.formatter.formatToParts(n);
    return [
      ...a.map((r) => ({
        ...r,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...o.map((r) => ({
        ...r,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return cx() && (this.resolvedHourCycle || (this.resolvedHourCycle = fx(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, n = {}) {
    this.formatter = Vg(t, n), this.options = n;
  }
}
const ux = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function Vg(e, t = {}) {
  if (typeof t.hour12 == "boolean" && dx()) {
    t = {
      ...t
    };
    let o = ux[String(t.hour12)][e.split("-")[0]], r = t.hour12 ? "h12" : "h23";
    t.hourCycle = o ?? r, delete t.hour12;
  }
  let n = e + (t ? Object.entries(t).sort((o, r) => o[0] < r[0] ? -1 : 1).join() : "");
  if (od.has(n)) return od.get(n);
  let a = new Intl.DateTimeFormat(e, t);
  return od.set(n, a), a;
}
let rd = null;
function dx() {
  return rd == null && (rd = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), rd;
}
let sd = null;
function cx() {
  return sd == null && (sd = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), sd;
}
function fx(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = Vg(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), a = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((r) => r.type === "hour").value, 10), o = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((r) => r.type === "hour").value, 10);
  if (a === 0 && o === 23) return "h23";
  if (a === 24 && o === 23) return "h24";
  if (a === 0 && o === 11) return "h11";
  if (a === 12 && o === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
const px = ["top", "right", "bottom", "left"], Ja = Math.min, _n = Math.max, ri = Math.round, ul = Math.floor, ta = (e) => ({
  x: e,
  y: e
}), vx = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, mx = {
  start: "end",
  end: "start"
};
function Zd(e, t, n) {
  return _n(e, Ja(t, n));
}
function $a(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ba(e) {
  return e.split("-")[0];
}
function wr(e) {
  return e.split("-")[1];
}
function df(e) {
  return e === "x" ? "y" : "x";
}
function cf(e) {
  return e === "y" ? "height" : "width";
}
const hx = /* @__PURE__ */ new Set(["top", "bottom"]);
function ea(e) {
  return hx.has(Ba(e)) ? "y" : "x";
}
function ff(e) {
  return df(ea(e));
}
function gx(e, t, n) {
  n === void 0 && (n = !1);
  const a = wr(e), o = ff(e), r = cf(o);
  let s = o === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (s = si(s)), [s, si(s)];
}
function yx(e) {
  const t = si(e);
  return [Qd(e), t, Qd(t)];
}
function Qd(e) {
  return e.replace(/start|end/g, (t) => mx[t]);
}
const qv = ["left", "right"], Fv = ["right", "left"], bx = ["top", "bottom"], _x = ["bottom", "top"];
function wx(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? Fv : qv : t ? qv : Fv;
    case "left":
    case "right":
      return t ? bx : _x;
    default:
      return [];
  }
}
function xx(e, t, n, a) {
  const o = wr(e);
  let r = wx(Ba(e), n === "start", a);
  return o && (r = r.map((s) => s + "-" + o), t && (r = r.concat(r.map(Qd)))), r;
}
function si(e) {
  return e.replace(/left|right|bottom|top/g, (t) => vx[t]);
}
function Cx(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Ng(e) {
  return typeof e != "number" ? Cx(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function li(e) {
  const {
    x: t,
    y: n,
    width: a,
    height: o
  } = e;
  return {
    width: a,
    height: o,
    top: n,
    left: t,
    right: t + a,
    bottom: n + o,
    x: t,
    y: n
  };
}
function Vv(e, t, n) {
  let {
    reference: a,
    floating: o
  } = e;
  const r = ea(t), s = ff(t), i = cf(s), u = Ba(t), d = r === "y", c = a.x + a.width / 2 - o.width / 2, f = a.y + a.height / 2 - o.height / 2, p = a[i] / 2 - o[i] / 2;
  let v;
  switch (u) {
    case "top":
      v = {
        x: c,
        y: a.y - o.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: a.y + a.height
      };
      break;
    case "right":
      v = {
        x: a.x + a.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: a.x - o.width,
        y: f
      };
      break;
    default:
      v = {
        x: a.x,
        y: a.y
      };
  }
  switch (wr(t)) {
    case "start":
      v[s] -= p * (n && d ? -1 : 1);
      break;
    case "end":
      v[s] += p * (n && d ? -1 : 1);
      break;
  }
  return v;
}
const Sx = async (e, t, n) => {
  const {
    placement: a = "bottom",
    strategy: o = "absolute",
    middleware: r = [],
    platform: s
  } = n, i = r.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: c,
    y: f
  } = Vv(d, a, u), p = a, v = {}, m = 0;
  for (let h = 0; h < i.length; h++) {
    const {
      name: _,
      fn: x
    } = i[h], {
      x: S,
      y: $,
      data: D,
      reset: B
    } = await x({
      x: c,
      y: f,
      initialPlacement: a,
      placement: p,
      strategy: o,
      middlewareData: v,
      rects: d,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = S ?? c, f = $ ?? f, v = {
      ...v,
      [_]: {
        ...v[_],
        ...D
      }
    }, B && m <= 50 && (m++, typeof B == "object" && (B.placement && (p = B.placement), B.rects && (d = B.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : B.rects), {
      x: c,
      y: f
    } = Vv(d, p, u)), h = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: o,
    middlewareData: v
  };
};
async function vs(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: a,
    y: o,
    platform: r,
    rects: s,
    elements: i,
    strategy: u
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: v = 0
  } = $a(t, e), m = Ng(v), _ = i[p ? f === "floating" ? "reference" : "floating" : f], x = li(await r.getClippingRect({
    element: (n = await (r.isElement == null ? void 0 : r.isElement(_))) == null || n ? _ : _.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(i.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: u
  })), S = f === "floating" ? {
    x: a,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, $ = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(i.floating)), D = await (r.isElement == null ? void 0 : r.isElement($)) ? await (r.getScale == null ? void 0 : r.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, B = li(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: S,
    offsetParent: $,
    strategy: u
  }) : S);
  return {
    top: (x.top - B.top + m.top) / D.y,
    bottom: (B.bottom - x.bottom + m.bottom) / D.y,
    left: (x.left - B.left + m.left) / D.x,
    right: (B.right - x.right + m.right) / D.x
  };
}
const $x = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: a,
      placement: o,
      rects: r,
      platform: s,
      elements: i,
      middlewareData: u
    } = t, {
      element: d,
      padding: c = 0
    } = $a(e, t) || {};
    if (d == null)
      return {};
    const f = Ng(c), p = {
      x: n,
      y: a
    }, v = ff(o), m = cf(v), h = await s.getDimensions(d), _ = v === "y", x = _ ? "top" : "left", S = _ ? "bottom" : "right", $ = _ ? "clientHeight" : "clientWidth", D = r.reference[m] + r.reference[v] - p[v] - r.floating[m], B = p[v] - r.reference[v], k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d));
    let M = k ? k[$] : 0;
    (!M || !await (s.isElement == null ? void 0 : s.isElement(k))) && (M = i.floating[$] || r.floating[m]);
    const I = D / 2 - B / 2, T = M / 2 - h[m] / 2 - 1, P = Ja(f[x], T), q = Ja(f[S], T), R = P, Q = M - h[m] - q, ee = M / 2 - h[m] / 2 + I, K = Zd(R, ee, Q), W = !u.arrow && wr(o) != null && ee !== K && r.reference[m] / 2 - (ee < R ? P : q) - h[m] / 2 < 0, j = W ? ee < R ? ee - R : ee - Q : 0;
    return {
      [v]: p[v] + j,
      data: {
        [v]: K,
        centerOffset: ee - K - j,
        ...W && {
          alignmentOffset: j
        }
      },
      reset: W
    };
  }
}), Bx = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: o,
        middlewareData: r,
        rects: s,
        initialPlacement: i,
        platform: u,
        elements: d
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: h = !0,
        ..._
      } = $a(e, t);
      if ((n = r.arrow) != null && n.alignmentOffset)
        return {};
      const x = Ba(o), S = ea(i), $ = Ba(i) === i, D = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)), B = p || ($ || !h ? [si(i)] : yx(i)), k = m !== "none";
      !p && k && B.push(...xx(i, h, m, D));
      const M = [i, ...B], I = await vs(t, _), T = [];
      let P = ((a = r.flip) == null ? void 0 : a.overflows) || [];
      if (c && T.push(I[x]), f) {
        const ee = gx(o, s, D);
        T.push(I[ee[0]], I[ee[1]]);
      }
      if (P = [...P, {
        placement: o,
        overflows: T
      }], !T.every((ee) => ee <= 0)) {
        var q, R;
        const ee = (((q = r.flip) == null ? void 0 : q.index) || 0) + 1, K = M[ee];
        if (K && (!(f === "alignment" ? S !== ea(K) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        P.every((J) => ea(J.placement) === S ? J.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ee,
              overflows: P
            },
            reset: {
              placement: K
            }
          };
        let W = (R = P.filter((j) => j.overflows[0] <= 0).sort((j, J) => j.overflows[1] - J.overflows[1])[0]) == null ? void 0 : R.placement;
        if (!W)
          switch (v) {
            case "bestFit": {
              var Q;
              const j = (Q = P.filter((J) => {
                if (k) {
                  const z = ea(J.placement);
                  return z === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  z === "y";
                }
                return !0;
              }).map((J) => [J.placement, J.overflows.filter((z) => z > 0).reduce((z, Y) => z + Y, 0)]).sort((J, z) => J[1] - z[1])[0]) == null ? void 0 : Q[0];
              j && (W = j);
              break;
            }
            case "initialPlacement":
              W = i;
              break;
          }
        if (o !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
};
function Nv(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Lv(e) {
  return px.some((t) => e[t] >= 0);
}
const Px = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: a = "referenceHidden",
        ...o
      } = $a(e, t);
      switch (a) {
        case "referenceHidden": {
          const r = await vs(t, {
            ...o,
            elementContext: "reference"
          }), s = Nv(r, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Lv(s)
            }
          };
        }
        case "escaped": {
          const r = await vs(t, {
            ...o,
            altBoundary: !0
          }), s = Nv(r, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Lv(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, Lg = /* @__PURE__ */ new Set(["left", "top"]);
async function Ex(e, t) {
  const {
    placement: n,
    platform: a,
    elements: o
  } = e, r = await (a.isRTL == null ? void 0 : a.isRTL(o.floating)), s = Ba(n), i = wr(n), u = ea(n) === "y", d = Lg.has(s) ? -1 : 1, c = r && u ? -1 : 1, f = $a(t, e);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return i && typeof m == "number" && (v = i === "end" ? m * -1 : m), u ? {
    x: v * c,
    y: p * d
  } : {
    x: p * d,
    y: v * c
  };
}
const Dx = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, a;
      const {
        x: o,
        y: r,
        placement: s,
        middlewareData: i
      } = t, u = await Ex(t, e);
      return s === ((n = i.offset) == null ? void 0 : n.placement) && (a = i.arrow) != null && a.alignmentOffset ? {} : {
        x: o + u.x,
        y: r + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, Mx = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: a,
        placement: o
      } = t, {
        mainAxis: r = !0,
        crossAxis: s = !1,
        limiter: i = {
          fn: (_) => {
            let {
              x,
              y: S
            } = _;
            return {
              x,
              y: S
            };
          }
        },
        ...u
      } = $a(e, t), d = {
        x: n,
        y: a
      }, c = await vs(t, u), f = ea(Ba(o)), p = df(f);
      let v = d[p], m = d[f];
      if (r) {
        const _ = p === "y" ? "top" : "left", x = p === "y" ? "bottom" : "right", S = v + c[_], $ = v - c[x];
        v = Zd(S, v, $);
      }
      if (s) {
        const _ = f === "y" ? "top" : "left", x = f === "y" ? "bottom" : "right", S = m + c[_], $ = m - c[x];
        m = Zd(S, m, $);
      }
      const h = i.fn({
        ...t,
        [p]: v,
        [f]: m
      });
      return {
        ...h,
        data: {
          x: h.x - n,
          y: h.y - a,
          enabled: {
            [p]: r,
            [f]: s
          }
        }
      };
    }
  };
}, kx = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: a,
        placement: o,
        rects: r,
        middlewareData: s
      } = t, {
        offset: i = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = $a(e, t), c = {
        x: n,
        y: a
      }, f = ea(o), p = df(f);
      let v = c[p], m = c[f];
      const h = $a(i, t), _ = typeof h == "number" ? {
        mainAxis: h,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...h
      };
      if (u) {
        const $ = p === "y" ? "height" : "width", D = r.reference[p] - r.floating[$] + _.mainAxis, B = r.reference[p] + r.reference[$] - _.mainAxis;
        v < D ? v = D : v > B && (v = B);
      }
      if (d) {
        var x, S;
        const $ = p === "y" ? "width" : "height", D = Lg.has(Ba(o)), B = r.reference[f] - r.floating[$] + (D && ((x = s.offset) == null ? void 0 : x[f]) || 0) + (D ? 0 : _.crossAxis), k = r.reference[f] + r.reference[$] + (D ? 0 : ((S = s.offset) == null ? void 0 : S[f]) || 0) - (D ? _.crossAxis : 0);
        m < B ? m = B : m > k && (m = k);
      }
      return {
        [p]: v,
        [f]: m
      };
    }
  };
}, Ox = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: o,
        rects: r,
        platform: s,
        elements: i
      } = t, {
        apply: u = () => {
        },
        ...d
      } = $a(e, t), c = await vs(t, d), f = Ba(o), p = wr(o), v = ea(o) === "y", {
        width: m,
        height: h
      } = r.floating;
      let _, x;
      f === "top" || f === "bottom" ? (_ = f, x = p === (await (s.isRTL == null ? void 0 : s.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (x = f, _ = p === "end" ? "top" : "bottom");
      const S = h - c.top - c.bottom, $ = m - c.left - c.right, D = Ja(h - c[_], S), B = Ja(m - c[x], $), k = !t.middlewareData.shift;
      let M = D, I = B;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (I = $), (a = t.middlewareData.shift) != null && a.enabled.y && (M = S), k && !p) {
        const P = _n(c.left, 0), q = _n(c.right, 0), R = _n(c.top, 0), Q = _n(c.bottom, 0);
        v ? I = m - 2 * (P !== 0 || q !== 0 ? P + q : _n(c.left, c.right)) : M = h - 2 * (R !== 0 || Q !== 0 ? R + Q : _n(c.top, c.bottom));
      }
      await u({
        ...t,
        availableWidth: I,
        availableHeight: M
      });
      const T = await s.getDimensions(i.floating);
      return m !== T.width || h !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Xi() {
  return typeof window < "u";
}
function So(e) {
  return pf(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function xn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function la(e) {
  var t;
  return (t = (pf(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function pf(e) {
  return Xi() ? e instanceof Node || e instanceof xn(e).Node : !1;
}
function Un(e) {
  return Xi() ? e instanceof Element || e instanceof xn(e).Element : !1;
}
function oa(e) {
  return Xi() ? e instanceof HTMLElement || e instanceof xn(e).HTMLElement : !1;
}
function zv(e) {
  return !Xi() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof xn(e).ShadowRoot;
}
const Tx = /* @__PURE__ */ new Set(["inline", "contents"]);
function qs(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: a,
    display: o
  } = jn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !Tx.has(o);
}
const Ax = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Ix(e) {
  return Ax.has(So(e));
}
const Rx = [":popover-open", ":modal"];
function Ji(e) {
  return Rx.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const qx = ["transform", "translate", "scale", "rotate", "perspective"], Fx = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Vx = ["paint", "layout", "strict", "content"];
function vf(e) {
  const t = mf(), n = Un(e) ? jn(e) : e;
  return qx.some((a) => n[a] ? n[a] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Fx.some((a) => (n.willChange || "").includes(a)) || Vx.some((a) => (n.contain || "").includes(a));
}
function Nx(e) {
  let t = Za(e);
  for (; oa(t) && !ur(t); ) {
    if (vf(t))
      return t;
    if (Ji(t))
      return null;
    t = Za(t);
  }
  return null;
}
function mf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const Lx = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function ur(e) {
  return Lx.has(So(e));
}
function jn(e) {
  return xn(e).getComputedStyle(e);
}
function Zi(e) {
  return Un(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Za(e) {
  if (So(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    zv(e) && e.host || // Fallback.
    la(e)
  );
  return zv(t) ? t.host : t;
}
function zg(e) {
  const t = Za(e);
  return ur(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : oa(t) && qs(t) ? t : zg(t);
}
function ms(e, t, n) {
  var a;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = zg(e), r = o === ((a = e.ownerDocument) == null ? void 0 : a.body), s = xn(o);
  if (r) {
    const i = ec(s);
    return t.concat(s, s.visualViewport || [], qs(o) ? o : [], i && n ? ms(i) : []);
  }
  return t.concat(o, ms(o, [], n));
}
function ec(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Hg(e) {
  const t = jn(e);
  let n = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const o = oa(e), r = o ? e.offsetWidth : n, s = o ? e.offsetHeight : a, i = ri(n) !== r || ri(a) !== s;
  return i && (n = r, a = s), {
    width: n,
    height: a,
    $: i
  };
}
function hf(e) {
  return Un(e) ? e : e.contextElement;
}
function Zo(e) {
  const t = hf(e);
  if (!oa(t))
    return ta(1);
  const n = t.getBoundingClientRect(), {
    width: a,
    height: o,
    $: r
  } = Hg(t);
  let s = (r ? ri(n.width) : n.width) / a, i = (r ? ri(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: s,
    y: i
  };
}
const zx = /* @__PURE__ */ ta(0);
function Ug(e) {
  const t = xn(e);
  return !mf() || !t.visualViewport ? zx : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Hx(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== xn(e) ? !1 : t;
}
function bo(e, t, n, a) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), r = hf(e);
  let s = ta(1);
  t && (a ? Un(a) && (s = Zo(a)) : s = Zo(e));
  const i = Hx(r, n, a) ? Ug(r) : ta(0);
  let u = (o.left + i.x) / s.x, d = (o.top + i.y) / s.y, c = o.width / s.x, f = o.height / s.y;
  if (r) {
    const p = xn(r), v = a && Un(a) ? xn(a) : a;
    let m = p, h = ec(m);
    for (; h && a && v !== m; ) {
      const _ = Zo(h), x = h.getBoundingClientRect(), S = jn(h), $ = x.left + (h.clientLeft + parseFloat(S.paddingLeft)) * _.x, D = x.top + (h.clientTop + parseFloat(S.paddingTop)) * _.y;
      u *= _.x, d *= _.y, c *= _.x, f *= _.y, u += $, d += D, m = xn(h), h = ec(m);
    }
  }
  return li({
    width: c,
    height: f,
    x: u,
    y: d
  });
}
function Qi(e, t) {
  const n = Zi(e).scrollLeft;
  return t ? t.left + n : bo(la(e)).left + n;
}
function jg(e, t) {
  const n = e.getBoundingClientRect(), a = n.left + t.scrollLeft - Qi(e, n), o = n.top + t.scrollTop;
  return {
    x: a,
    y: o
  };
}
function Ux(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: a,
    strategy: o
  } = e;
  const r = o === "fixed", s = la(a), i = t ? Ji(t.floating) : !1;
  if (a === s || i && r)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = ta(1);
  const c = ta(0), f = oa(a);
  if ((f || !f && !r) && ((So(a) !== "body" || qs(s)) && (u = Zi(a)), oa(a))) {
    const v = bo(a);
    d = Zo(a), c.x = v.x + a.clientLeft, c.y = v.y + a.clientTop;
  }
  const p = s && !f && !r ? jg(s, u) : ta(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - u.scrollLeft * d.x + c.x + p.x,
    y: n.y * d.y - u.scrollTop * d.y + c.y + p.y
  };
}
function jx(e) {
  return Array.from(e.getClientRects());
}
function Wx(e) {
  const t = la(e), n = Zi(e), a = e.ownerDocument.body, o = _n(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), r = _n(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let s = -n.scrollLeft + Qi(e);
  const i = -n.scrollTop;
  return jn(a).direction === "rtl" && (s += _n(t.clientWidth, a.clientWidth) - o), {
    width: o,
    height: r,
    x: s,
    y: i
  };
}
const Hv = 25;
function Kx(e, t) {
  const n = xn(e), a = la(e), o = n.visualViewport;
  let r = a.clientWidth, s = a.clientHeight, i = 0, u = 0;
  if (o) {
    r = o.width, s = o.height;
    const c = mf();
    (!c || c && t === "fixed") && (i = o.offsetLeft, u = o.offsetTop);
  }
  const d = Qi(a);
  if (d <= 0) {
    const c = a.ownerDocument, f = c.body, p = getComputedStyle(f), v = c.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0, m = Math.abs(a.clientWidth - f.clientWidth - v);
    m <= Hv && (r -= m);
  } else d <= Hv && (r += d);
  return {
    width: r,
    height: s,
    x: i,
    y: u
  };
}
const Gx = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Yx(e, t) {
  const n = bo(e, !0, t === "fixed"), a = n.top + e.clientTop, o = n.left + e.clientLeft, r = oa(e) ? Zo(e) : ta(1), s = e.clientWidth * r.x, i = e.clientHeight * r.y, u = o * r.x, d = a * r.y;
  return {
    width: s,
    height: i,
    x: u,
    y: d
  };
}
function Uv(e, t, n) {
  let a;
  if (t === "viewport")
    a = Kx(e, n);
  else if (t === "document")
    a = Wx(la(e));
  else if (Un(t))
    a = Yx(t, n);
  else {
    const o = Ug(e);
    a = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return li(a);
}
function Wg(e, t) {
  const n = Za(e);
  return n === t || !Un(n) || ur(n) ? !1 : jn(n).position === "fixed" || Wg(n, t);
}
function Xx(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let a = ms(e, [], !1).filter((i) => Un(i) && So(i) !== "body"), o = null;
  const r = jn(e).position === "fixed";
  let s = r ? Za(e) : e;
  for (; Un(s) && !ur(s); ) {
    const i = jn(s), u = vf(s);
    !u && i.position === "fixed" && (o = null), (r ? !u && !o : !u && i.position === "static" && !!o && Gx.has(o.position) || qs(s) && !u && Wg(e, s)) ? a = a.filter((c) => c !== s) : o = i, s = Za(s);
  }
  return t.set(e, a), a;
}
function Jx(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: a,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? Ji(t) ? [] : Xx(t, this._c) : [].concat(n), a], i = s[0], u = s.reduce((d, c) => {
    const f = Uv(t, c, o);
    return d.top = _n(f.top, d.top), d.right = Ja(f.right, d.right), d.bottom = Ja(f.bottom, d.bottom), d.left = _n(f.left, d.left), d;
  }, Uv(t, i, o));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function Zx(e) {
  const {
    width: t,
    height: n
  } = Hg(e);
  return {
    width: t,
    height: n
  };
}
function Qx(e, t, n) {
  const a = oa(t), o = la(t), r = n === "fixed", s = bo(e, !0, r, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = ta(0);
  function d() {
    u.x = Qi(o);
  }
  if (a || !a && !r)
    if ((So(t) !== "body" || qs(o)) && (i = Zi(t)), a) {
      const v = bo(t, !0, r, t);
      u.x = v.x + t.clientLeft, u.y = v.y + t.clientTop;
    } else o && d();
  r && !a && o && d();
  const c = o && !a && !r ? jg(o, i) : ta(0), f = s.left + i.scrollLeft - u.x - c.x, p = s.top + i.scrollTop - u.y - c.y;
  return {
    x: f,
    y: p,
    width: s.width,
    height: s.height
  };
}
function ld(e) {
  return jn(e).position === "static";
}
function jv(e, t) {
  if (!oa(e) || jn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return la(e) === n && (n = n.ownerDocument.body), n;
}
function Kg(e, t) {
  const n = xn(e);
  if (Ji(e))
    return n;
  if (!oa(e)) {
    let o = Za(e);
    for (; o && !ur(o); ) {
      if (Un(o) && !ld(o))
        return o;
      o = Za(o);
    }
    return n;
  }
  let a = jv(e, t);
  for (; a && Ix(a) && ld(a); )
    a = jv(a, t);
  return a && ur(a) && ld(a) && !vf(a) ? n : a || Nx(e) || n;
}
const eC = async function(e) {
  const t = this.getOffsetParent || Kg, n = this.getDimensions, a = await n(e.floating);
  return {
    reference: Qx(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function tC(e) {
  return jn(e).direction === "rtl";
}
const nC = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Ux,
  getDocumentElement: la,
  getClippingRect: Jx,
  getOffsetParent: Kg,
  getElementRects: eC,
  getClientRects: jx,
  getDimensions: Zx,
  getScale: Zo,
  isElement: Un,
  isRTL: tC
};
function Gg(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function aC(e, t) {
  let n = null, a;
  const o = la(e);
  function r() {
    var i;
    clearTimeout(a), (i = n) == null || i.disconnect(), n = null;
  }
  function s(i, u) {
    i === void 0 && (i = !1), u === void 0 && (u = 1), r();
    const d = e.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: v
    } = d;
    if (i || t(), !p || !v)
      return;
    const m = ul(f), h = ul(o.clientWidth - (c + p)), _ = ul(o.clientHeight - (f + v)), x = ul(c), $ = {
      rootMargin: -m + "px " + -h + "px " + -_ + "px " + -x + "px",
      threshold: _n(0, Ja(1, u)) || 1
    };
    let D = !0;
    function B(k) {
      const M = k[0].intersectionRatio;
      if (M !== u) {
        if (!D)
          return s();
        M ? s(!1, M) : a = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      M === 1 && !Gg(d, e.getBoundingClientRect()) && s(), D = !1;
    }
    try {
      n = new IntersectionObserver(B, {
        ...$,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(B, $);
    }
    n.observe(e);
  }
  return s(!0), r;
}
function Yg(e, t, n, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: r = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = a, d = hf(e), c = o || r ? [...d ? ms(d) : [], ...ms(t)] : [];
  c.forEach((x) => {
    o && x.addEventListener("scroll", n, {
      passive: !0
    }), r && x.addEventListener("resize", n);
  });
  const f = d && i ? aC(d, n) : null;
  let p = -1, v = null;
  s && (v = new ResizeObserver((x) => {
    let [S] = x;
    S && S.target === d && v && (v.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var $;
      ($ = v) == null || $.observe(t);
    })), n();
  }), d && !u && v.observe(d), v.observe(t));
  let m, h = u ? bo(e) : null;
  u && _();
  function _() {
    const x = bo(e);
    h && !Gg(h, x) && n(), h = x, m = requestAnimationFrame(_);
  }
  return n(), () => {
    var x;
    c.forEach((S) => {
      o && S.removeEventListener("scroll", n), r && S.removeEventListener("resize", n);
    }), f == null || f(), (x = v) == null || x.disconnect(), v = null, u && cancelAnimationFrame(m);
  };
}
const Xg = Dx, Jg = Mx, ii = Bx, Zg = Ox, Qg = Px, oC = $x, ey = kx, rC = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), o = {
    platform: nC,
    ...n
  }, r = {
    ...o.platform,
    _c: a
  };
  return Sx(e, t, {
    ...o,
    platform: r
  });
};
function sC(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function tc(e) {
  if (sC(e)) {
    const t = e.$el;
    return pf(t) && So(t) === "#comment" ? null : t;
  }
  return e;
}
function jo(e) {
  return typeof e == "function" ? e() : l(e);
}
function ty(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = tc(jo(e.element));
      return n == null ? {} : oC({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
function ny(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Wv(e, t) {
  const n = ny(e);
  return Math.round(t * n) / n;
}
function ay(e, t, n) {
  n === void 0 && (n = {});
  const a = n.whileElementsMounted, o = E(() => {
    var M;
    return (M = jo(n.open)) != null ? M : !0;
  }), r = E(() => jo(n.middleware)), s = E(() => {
    var M;
    return (M = jo(n.placement)) != null ? M : "bottom";
  }), i = E(() => {
    var M;
    return (M = jo(n.strategy)) != null ? M : "absolute";
  }), u = E(() => {
    var M;
    return (M = jo(n.transform)) != null ? M : !0;
  }), d = E(() => tc(e.value)), c = E(() => tc(t.value)), f = O(0), p = O(0), v = O(i.value), m = O(s.value), h = Zt({}), _ = O(!1), x = E(() => {
    const M = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return M;
    const I = Wv(c.value, f.value), T = Wv(c.value, p.value);
    return u.value ? {
      ...M,
      transform: "translate(" + I + "px, " + T + "px)",
      ...ny(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: I + "px",
      top: T + "px"
    };
  });
  let S;
  function $() {
    if (d.value == null || c.value == null)
      return;
    const M = o.value;
    rC(d.value, c.value, {
      middleware: r.value,
      placement: s.value,
      strategy: i.value
    }).then((I) => {
      f.value = I.x, p.value = I.y, v.value = I.strategy, m.value = I.placement, h.value = I.middlewareData, _.value = M !== !1;
    });
  }
  function D() {
    typeof S == "function" && (S(), S = void 0);
  }
  function B() {
    if (D(), a === void 0) {
      $();
      return;
    }
    if (d.value != null && c.value != null) {
      S = a(d.value, c.value, $);
      return;
    }
  }
  function k() {
    o.value || (_.value = !1);
  }
  return ce([r, s, i, o], $, {
    flush: "sync"
  }), ce([d, c], B, {
    flush: "sync"
  }), ce(o, k, {
    flush: "sync"
  }), As() && Is(D), {
    x: Fo(f),
    y: Fo(p),
    strategy: Fo(v),
    placement: Fo(m),
    middlewareData: Fo(h),
    isPositioned: Fo(_),
    floatingStyles: x,
    update: $
  };
}
let id = /* @__PURE__ */ new Map(), nc = !1;
try {
  nc = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let ui = !1;
try {
  ui = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const oy = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
class ry {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let n = "";
    if (!nc && this.options.signDisplay != null ? n = iC(this.numberFormatter, this.options.signDisplay, t) : n = this.numberFormatter.format(t), this.options.style === "unit" && !ui) {
      var a;
      let { unit: o, unitDisplay: r = "short", locale: s } = this.resolvedOptions();
      if (!o) return n;
      let i = (a = oy[o]) === null || a === void 0 ? void 0 : a[r];
      n += i[s] || i.default;
    }
    return n;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, n) {
    if (typeof this.numberFormatter.formatRange == "function") return this.numberFormatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)} – ${this.format(n)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.numberFormatter.formatRangeToParts == "function") return this.numberFormatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.numberFormatter.formatToParts(t), o = this.numberFormatter.formatToParts(n);
    return [
      ...a.map((r) => ({
        ...r,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...o.map((r) => ({
        ...r,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !nc && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !ui && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, n = {}) {
    this.numberFormatter = lC(t, n), this.options = n;
  }
}
function lC(e, t = {}) {
  let { numberingSystem: n } = t;
  if (n && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${n}`), t.style === "unit" && !ui) {
    var a;
    let { unit: s, unitDisplay: i = "short" } = t;
    if (!s) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((a = oy[s]) === null || a === void 0) && a[i])) throw new Error(`Unsupported unit ${s} with unitDisplay = ${i}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let o = e + (t ? Object.entries(t).sort((s, i) => s[0] < i[0] ? -1 : 1).join() : "");
  if (id.has(o)) return id.get(o);
  let r = new Intl.NumberFormat(e, t);
  return id.set(o, r), r;
}
function iC(e, t, n) {
  if (t === "auto") return e.format(n);
  if (t === "never") return e.format(Math.abs(n));
  {
    let a = !1;
    if (t === "always" ? a = n > 0 || Object.is(n, 0) : t === "exceptZero" && (Object.is(n, -0) || Object.is(n, 0) ? n = Math.abs(n) : a = n > 0), a) {
      let o = e.format(-n), r = e.format(n), s = o.replace(r, "").replace(/\u200e|\u061C/, "");
      return [
        ...s
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), o.replace(r, "!!!").replace(s, "+").replace("!!!", r);
    } else return e.format(n);
  }
}
const uC = new RegExp("^.*\\(.*\\).*$"), dC = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
class sy {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return ud(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, n, a) {
    return ud(this.locale, this.options, t).isValidPartialNumber(t, n, a);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return ud(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, n = {}) {
    this.locale = t, this.options = n;
  }
}
const Kv = /* @__PURE__ */ new Map();
function ud(e, t, n) {
  let a = Gv(e, t);
  if (!e.includes("-nu-") && !a.isValidPartialNumber(n)) {
    for (let o of dC) if (o !== a.options.numberingSystem) {
      let r = Gv(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + o, t);
      if (r.isValidPartialNumber(n)) return r;
    }
  }
  return a;
}
function Gv(e, t) {
  let n = e + (t ? Object.entries(t).sort((o, r) => o[0] < r[0] ? -1 : 1).join() : ""), a = Kv.get(n);
  return a || (a = new cC(e, t), Kv.set(n, a)), a;
}
class cC {
  parse(t) {
    let n = this.sanitize(t);
    if (this.symbols.group && (n = No(n, this.symbols.group, "")), this.symbols.decimal && (n = n.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (n = n.replace(this.symbols.minusSign, "-")), n = n.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let s = n.indexOf("-");
      n = n.replace("-", ""), n = n.replace("+", "");
      let i = n.indexOf(".");
      i === -1 && (i = n.length), n = n.replace(".", ""), i - 2 === 0 ? n = `0.${n}` : i - 2 === -1 ? n = `0.0${n}` : i - 2 === -2 ? n = "0.00" : n = `${n.slice(0, i - 2)}.${n.slice(i - 2)}`, s > -1 && (n = `-${n}`);
    }
    let a = n ? +n : NaN;
    if (isNaN(a)) return NaN;
    if (this.options.style === "percent") {
      var o, r;
      let s = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((o = this.options.minimumFractionDigits) !== null && o !== void 0 ? o : 0) + 2, 20),
        maximumFractionDigits: Math.min(((r = this.options.maximumFractionDigits) !== null && r !== void 0 ? r : 0) + 2, 20)
      };
      return new sy(this.locale, s).parse(new ry(this.locale, s).format(a));
    }
    return this.options.currencySign === "accounting" && uC.test(t) && (a = -1 * a), a;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("،", this.symbols.decimal)), this.symbols.group && (t = No(t, ".", this.symbols.group))), this.symbols.group === "’" && t.includes("'") && (t = No(t, "'", this.symbols.group)), this.options.locale === "fr-FR" && this.symbols.group && (t = No(t, " ", this.symbols.group), t = No(t, /\u00A0/g, this.symbols.group)), t;
  }
  isValidPartialNumber(t, n = -1 / 0, a = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && n < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && a > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = No(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, n = {}) {
    this.locale = t, n.roundingIncrement !== 1 && n.roundingIncrement != null && (n.maximumFractionDigits == null && n.minimumFractionDigits == null ? (n.maximumFractionDigits = 0, n.minimumFractionDigits = 0) : n.maximumFractionDigits == null ? n.maximumFractionDigits = n.minimumFractionDigits : n.minimumFractionDigits == null && (n.minimumFractionDigits = n.maximumFractionDigits)), this.formatter = new Intl.NumberFormat(t, n), this.options = this.formatter.resolvedOptions(), this.symbols = pC(t, this.formatter, this.options, n);
    var a, o;
    this.options.style === "percent" && (((a = this.options.minimumFractionDigits) !== null && a !== void 0 ? a : 0) > 18 || ((o = this.options.maximumFractionDigits) !== null && o !== void 0 ? o : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const Yv = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), fC = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function pC(e, t, n, a) {
  var o, r, s, i;
  let u = new Intl.NumberFormat(e, {
    ...n,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  }), d = u.formatToParts(-10000.111), c = u.formatToParts(10000.111), f = fC.map((P) => u.formatToParts(P));
  var p;
  let v = (p = (o = d.find((P) => P.type === "minusSign")) === null || o === void 0 ? void 0 : o.value) !== null && p !== void 0 ? p : "-", m = (r = c.find((P) => P.type === "plusSign")) === null || r === void 0 ? void 0 : r.value;
  !m && ((a == null ? void 0 : a.signDisplay) === "exceptZero" || (a == null ? void 0 : a.signDisplay) === "always") && (m = "+");
  let _ = (s = new Intl.NumberFormat(e, {
    ...n,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((P) => P.type === "decimal")) === null || s === void 0 ? void 0 : s.value, x = (i = d.find((P) => P.type === "group")) === null || i === void 0 ? void 0 : i.value, S = d.filter((P) => !Yv.has(P.type)).map((P) => Xv(P.value)), $ = f.flatMap((P) => P.filter((q) => !Yv.has(q.type)).map((q) => Xv(q.value))), D = [
    .../* @__PURE__ */ new Set([
      ...S,
      ...$
    ])
  ].sort((P, q) => q.length - P.length), B = D.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${D.join("|")}|[\\p{White_Space}]`, "gu"), k = [
    ...new Intl.NumberFormat(n.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), M = new Map(k.map((P, q) => [
    P,
    q
  ])), I = new RegExp(`[${k.join("")}]`, "g");
  return {
    minusSign: v,
    plusSign: m,
    decimal: _,
    group: x,
    literals: B,
    numeral: I,
    index: (P) => String(M.get(P))
  };
}
function No(e, t, n) {
  return e.replaceAll ? e.replaceAll(t, n) : e.split(t).join(n);
}
function Xv(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Ye(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(o) => {
    const r = vn(a, o);
    if (r || r === null)
      return r;
    throw new Error(
      `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(
        ", "
      )}` : `\`${e}\``}`
    );
  }, (o) => (Mn(a, o), o)];
}
function gf(e, t, n) {
  const a = n.originalEvent.target, o = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(o);
}
function di(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e));
}
function vC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var mC = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var a, o, r;
    if (Array.isArray(t)) {
      if (a = t.length, a != n.length) return !1;
      for (o = a; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (r = Object.keys(t), a = r.length, a !== Object.keys(n).length) return !1;
    for (o = a; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, r[o])) return !1;
    for (o = a; o-- !== 0; ) {
      var s = r[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const co = /* @__PURE__ */ vC(mC);
function Qo(e) {
  return e == null;
}
function hC(e, t) {
  var n;
  const a = Zt();
  return Me(() => {
    a.value = e();
  }, {
    ...t,
    flush: (n = void 0) != null ? n : "sync"
  }), Oa(a);
}
function $o(e) {
  return As() ? (Is(e), !0) : !1;
}
function gC() {
  const e = /* @__PURE__ */ new Set(), t = (n) => {
    e.delete(n);
  };
  return {
    on: (n) => {
      e.add(n);
      const a = () => t(n);
      return $o(a), {
        off: a
      };
    },
    off: t,
    trigger: (...n) => Promise.all(Array.from(e).map((a) => a(...n)))
  };
}
function yC(e) {
  let t = !1, n;
  const a = Wi(!0);
  return (...o) => (t || (n = a.run(() => e(...o)), t = !0), n);
}
function ly(e) {
  let t = 0, n, a;
  const o = () => {
    t -= 1, a && t <= 0 && (a.stop(), n = void 0, a = void 0);
  };
  return (...r) => (t += 1, n || (a = Wi(!0), n = a.run(() => e(...r))), $o(o), n);
}
function Sa(e) {
  return typeof e == "function" ? e() : l(e);
}
const ia = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const bC = (e) => typeof e < "u", _C = (e) => e != null, wC = Object.prototype.toString, xC = (e) => wC.call(e) === "[object Object]", iy = () => {
}, Jv = /* @__PURE__ */ CC();
function CC() {
  var e, t;
  return ia && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function SC(e) {
  return ct();
}
function uy(e, t = 1e4) {
  return Ki((n, a) => {
    let o = Sa(e), r;
    const s = () => setTimeout(() => {
      o = Sa(e), a();
    }, Sa(t));
    return $o(() => {
      clearTimeout(r);
    }), {
      get() {
        return n(), o;
      },
      set(i) {
        o = i, a(), clearTimeout(r), r = s();
      }
    };
  });
}
function $C(e, t) {
  SC() && ka(e, t);
}
function yf(e, t, n = {}) {
  const {
    immediate: a = !0
  } = n, o = O(!1);
  let r = null;
  function s() {
    r && (clearTimeout(r), r = null);
  }
  function i() {
    o.value = !1, s();
  }
  function u(...d) {
    s(), o.value = !0, r = setTimeout(() => {
      o.value = !1, r = null, e(...d);
    }, Sa(t));
  }
  return a && (o.value = !0, ia && u()), $o(i), {
    isPending: Oa(o),
    start: u,
    stop: i
  };
}
function BC(e = 1e3, t = {}) {
  const {
    controls: n = !1,
    callback: a
  } = t, o = yf(
    a ?? iy,
    e,
    t
  ), r = E(() => !o.isPending.value);
  return n ? {
    ready: r,
    ...o
  } : r;
}
function kn(e) {
  var t;
  const n = Sa(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const Fs = ia ? window : void 0;
function dr(...e) {
  let t, n, a, o;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, a, o] = e, t = Fs) : [t, n, a, o] = e, !t)
    return iy;
  Array.isArray(n) || (n = [n]), Array.isArray(a) || (a = [a]);
  const r = [], s = () => {
    r.forEach((c) => c()), r.length = 0;
  }, i = (c, f, p, v) => (c.addEventListener(f, p, v), () => c.removeEventListener(f, p, v)), u = ce(
    () => [kn(t), Sa(o)],
    ([c, f]) => {
      if (s(), !c)
        return;
      const p = xC(f) ? { ...f } : f;
      r.push(
        ...n.flatMap((v) => a.map((m) => i(c, v, m, p)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    u(), s();
  };
  return $o(d), d;
}
function PC(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function bf(...e) {
  let t, n, a = {};
  e.length === 3 ? (t = e[0], n = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], a = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: o = Fs,
    eventName: r = "keydown",
    passive: s = !1,
    dedupe: i = !1
  } = a, u = PC(t);
  return dr(o, r, (d) => {
    d.repeat && Sa(i) || u(d) && n(d);
  }, s);
}
function _f() {
  const e = O(!1), t = ct();
  return t && be(() => {
    e.value = !0;
  }, t), e;
}
function EC(e) {
  const t = _f();
  return E(() => (t.value, !!e()));
}
function DC(e, t, n = {}) {
  const { window: a = Fs, ...o } = n;
  let r;
  const s = EC(() => a && "MutationObserver" in a), i = () => {
    r && (r.disconnect(), r = void 0);
  }, u = E(() => {
    const p = Sa(e), v = (Array.isArray(p) ? p : [p]).map(kn).filter(_C);
    return new Set(v);
  }), d = ce(
    () => u.value,
    (p) => {
      i(), s.value && p.size && (r = new MutationObserver(t), p.forEach((v) => r.observe(v, o)));
    },
    { immediate: !0, flush: "post" }
  ), c = () => r == null ? void 0 : r.takeRecords(), f = () => {
    i(), d();
  };
  return $o(f), {
    isSupported: s,
    stop: f,
    takeRecords: c
  };
}
function dy(e, t = {}) {
  const {
    immediate: n = !0,
    fpsLimit: a = void 0,
    window: o = Fs
  } = t, r = O(!1), s = a ? 1e3 / a : null;
  let i = 0, u = null;
  function d(p) {
    if (!r.value || !o)
      return;
    i || (i = p);
    const v = p - i;
    if (s && v < s) {
      u = o.requestAnimationFrame(d);
      return;
    }
    i = p, e({ delta: v, timestamp: p }), u = o.requestAnimationFrame(d);
  }
  function c() {
    !r.value && o && (r.value = !0, i = 0, u = o.requestAnimationFrame(d));
  }
  function f() {
    r.value = !1, u != null && o && (o.cancelAnimationFrame(u), u = null);
  }
  return n && c(), $o(f), {
    isActive: Oa(r),
    pause: f,
    resume: c
  };
}
function MC(e) {
  return JSON.parse(JSON.stringify(e));
}
function pt(e, t, n, a = {}) {
  var o, r, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = ct(), m = n || (v == null ? void 0 : v.emit) || ((o = v == null ? void 0 : v.$emit) == null ? void 0 : o.bind(v)) || ((s = (r = v == null ? void 0 : v.proxy) == null ? void 0 : r.$emit) == null ? void 0 : s.bind(v == null ? void 0 : v.proxy));
  let h = d;
  t || (t = "modelValue"), h = h || `update:${t.toString()}`;
  const _ = ($) => i ? typeof i == "function" ? i($) : MC($) : $, x = () => bC(e[t]) ? _(e[t]) : f, S = ($) => {
    p ? p($) && m(h, $) : m(h, $);
  };
  if (u) {
    const $ = x(), D = O($);
    let B = !1;
    return ce(
      () => e[t],
      (k) => {
        B || (B = !0, D.value = _(k), he(() => B = !1));
      }
    ), ce(
      D,
      (k) => {
        !B && (k !== e[t] || c) && S(k);
      },
      { deep: c }
    ), D;
  } else
    return E({
      get() {
        return x();
      },
      set($) {
        S($);
      }
    });
}
function eu(e) {
  return e ? e.flatMap((t) => t.type === Fe ? eu(t.children) : [t]) : [];
}
function It() {
  let e = document.activeElement;
  if (e == null)
    return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; )
    e = e.shadowRoot.activeElement;
  return e;
}
const kC = ["INPUT", "TEXTAREA"];
function cy(e, t, n, a = {}) {
  if (!t || a.enableIgnoredElement && kC.includes(t.nodeName))
    return null;
  const {
    arrowKeyOptions: o = "both",
    attributeName: r = "[data-radix-vue-collection-item]",
    itemsArray: s = [],
    loop: i = !0,
    dir: u = "ltr",
    preventScroll: d = !0,
    focus: c = !1
  } = a, [f, p, v, m, h, _] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ], x = v || m, S = f || p;
  if (!h && !_ && (!x && !S || o === "vertical" && S || o === "horizontal" && x))
    return null;
  const $ = n ? Array.from(n.querySelectorAll(r)) : s;
  if (!$.length)
    return null;
  d && e.preventDefault();
  let D = null;
  return S || x ? D = fy($, t, {
    goForward: x ? m : u === "ltr" ? f : p,
    loop: i
  }) : h ? D = $.at(0) || null : _ && (D = $.at(-1) || null), c && (D == null || D.focus()), D;
}
function fy(e, t, n, a = e.length) {
  if (--a === 0)
    return null;
  const o = e.indexOf(t), r = n.goForward ? o + 1 : o - 1;
  if (!n.loop && (r < 0 || r >= e.length))
    return null;
  const s = (r + e.length) % e.length, i = e[s];
  return i ? i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false" ? fy(
    e,
    i,
    n,
    a
  ) : i : null;
}
function dd(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function ac(e, t, n = ".", a) {
  if (!dd(t))
    return ac(e, {}, n);
  const o = Object.assign({}, t);
  for (const r in e) {
    if (r === "__proto__" || r === "constructor")
      continue;
    const s = e[r];
    s != null && (Array.isArray(s) && Array.isArray(o[r]) ? o[r] = [...s, ...o[r]] : dd(s) && dd(o[r]) ? o[r] = ac(
      s,
      o[r],
      (n ? `${n}.` : "") + r.toString()
    ) : o[r] = s);
  }
  return o;
}
function OC(e) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((n, a) => ac(n, a, ""), {})
  );
}
const TC = OC(), [tu] = Ye("ConfigProvider");
let AC = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", IC = (e = 21) => {
  let t = "", n = e;
  for (; n--; )
    t += AC[Math.random() * 64 | 0];
  return t;
};
const RC = ly(() => {
  const e = O(/* @__PURE__ */ new Map()), t = O(), n = E(() => {
    for (const s of e.value.values())
      if (s)
        return !0;
    return !1;
  }), a = tu({
    scrollBody: O(!0)
  });
  let o = null;
  const r = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", Jv && (o == null || o()), t.value = void 0;
  };
  return ce(n, (s, i) => {
    var u;
    if (!ia)
      return;
    if (!s) {
      i && r();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const d = window.innerWidth - document.documentElement.clientWidth, c = { padding: d, margin: 0 }, f = (u = a.scrollBody) != null && u.value ? typeof a.scrollBody.value == "object" ? TC({
      padding: a.scrollBody.value.padding === !0 ? d : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? d : a.scrollBody.value.margin
    }, c) : c : { padding: 0, margin: 0 };
    d > 0 && (document.body.style.paddingRight = typeof f.padding == "number" ? `${f.padding}px` : String(f.padding), document.body.style.marginRight = typeof f.margin == "number" ? `${f.margin}px` : String(f.margin), document.body.style.setProperty("--scrollbar-width", `${d}px`), document.body.style.overflow = "hidden"), Jv && (o = dr(
      document,
      "touchmove",
      (p) => qC(p),
      { passive: !1 }
    )), he(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, { immediate: !0, flush: "sync" }), e;
});
function Vs(e) {
  const t = IC(6), n = RC();
  n.value.set(t, e ?? !1);
  const a = E({
    get: () => n.value.get(t) ?? !1,
    set: (o) => n.value.set(t, o)
  });
  return $C(() => {
    n.value.delete(t);
  }), a;
}
function py(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : py(n);
  }
}
function qC(e) {
  const t = e || window.event, n = t.target;
  return n instanceof Element && py(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);
}
const FC = "data-radix-vue-collection-item";
function xr(e, t = FC) {
  const n = Symbol();
  return { createCollection: (a) => {
    const o = O([]);
    function r() {
      const s = kn(a);
      return s ? o.value = Array.from(
        s.querySelectorAll(`[${t}]:not([data-disabled])`)
      ) : o.value = [];
    }
    return c1(() => {
      o.value = [];
    }), be(r), f1(r), ce(() => a == null ? void 0 : a.value, r, { immediate: !0 }), Mn(n, o), o;
  }, injectCollection: () => vn(n, O([])) };
}
function to(e) {
  const t = tu({
    dir: O("ltr")
  });
  return E(() => {
    var n;
    return (e == null ? void 0 : e.value) || ((n = t.dir) == null ? void 0 : n.value) || "ltr";
  });
}
function no(e) {
  const t = ct(), n = t == null ? void 0 : t.type.emits, a = {};
  return n != null && n.length || console.warn(
    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`
  ), n == null || n.forEach((o) => {
    a[cg(or(o))] = (...r) => e(o, ...r);
  }), a;
}
let cd = 0;
function wf() {
  Me((e) => {
    if (!ia)
      return;
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      t[0] ?? Zv()
    ), document.body.insertAdjacentElement(
      "beforeend",
      t[1] ?? Zv()
    ), cd++, e(() => {
      cd === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((n) => n.remove()), cd--;
    });
  });
}
function Zv() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
function nu(e) {
  return E(() => {
    var t;
    return Sa(e) ? !!((t = kn(e)) != null && t.closest("form")) : !0;
  });
}
function Rt(e) {
  const t = ct(), n = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((o, r) => {
    const s = (t == null ? void 0 : t.type.props[r]).default;
    return s !== void 0 && (o[r] = s), o;
  }, {}), a = Fn(e);
  return E(() => {
    const o = {}, r = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(r).forEach((s) => {
      o[or(s)] = r[s];
    }), Object.keys({ ...n, ...o }).reduce((s, i) => (a.value[i] !== void 0 && (s[i] = a.value[i]), s), {});
  });
}
function Le(e, t) {
  const n = Rt(e), a = t ? no(t) : {};
  return E(() => ({
    ...n.value,
    ...a
  }));
}
function fe() {
  const e = ct(), t = O(), n = E(() => {
    var s, i;
    return ["#text", "#comment"].includes((s = t.value) == null ? void 0 : s.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : kn(t);
  }), a = Object.assign({}, e.exposed), o = {};
  for (const s in e.props)
    Object.defineProperty(o, s, {
      enumerable: !0,
      configurable: !0,
      get: () => e.props[s]
    });
  if (Object.keys(a).length > 0)
    for (const s in a)
      Object.defineProperty(o, s, {
        enumerable: !0,
        configurable: !0,
        get: () => a[s]
      });
  Object.defineProperty(o, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = o;
  function r(s) {
    t.value = s, s && (Object.defineProperty(o, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s instanceof Element ? s : s.$el
    }), e.exposed = o);
  }
  return { forwardRef: r, currentRef: t, currentElement: n };
}
function VC(e, t) {
  const n = uy(!1, 300), a = O(null), o = gC();
  function r() {
    a.value = null, n.value = !1;
  }
  function s(i, u) {
    const d = i.currentTarget, c = { x: i.clientX, y: i.clientY }, f = NC(c, d.getBoundingClientRect()), p = LC(c, f), v = zC(u.getBoundingClientRect()), m = UC([...p, ...v]);
    a.value = m, n.value = !0;
  }
  return Me((i) => {
    if (e.value && t.value) {
      const u = (c) => s(c, t.value), d = (c) => s(c, e.value);
      e.value.addEventListener("pointerleave", u), t.value.addEventListener("pointerleave", d), i(() => {
        var c, f;
        (c = e.value) == null || c.removeEventListener("pointerleave", u), (f = t.value) == null || f.removeEventListener("pointerleave", d);
      });
    }
  }), Me((i) => {
    var u;
    if (a.value) {
      const d = (c) => {
        var f, p;
        if (!a.value)
          return;
        const v = c.target, m = { x: c.clientX, y: c.clientY }, h = ((f = e.value) == null ? void 0 : f.contains(v)) || ((p = t.value) == null ? void 0 : p.contains(v)), _ = !HC(m, a.value), x = !!v.closest("[data-grace-area-trigger]");
        h ? r() : (_ || x) && (r(), o.trigger());
      };
      (u = e.value) == null || u.ownerDocument.addEventListener("pointermove", d), i(() => {
        var c;
        return (c = e.value) == null ? void 0 : c.ownerDocument.removeEventListener("pointermove", d);
      });
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: o.on
  };
}
function NC(e, t) {
  const n = Math.abs(t.top - e.y), a = Math.abs(t.bottom - e.y), o = Math.abs(t.right - e.x), r = Math.abs(t.left - e.x);
  switch (Math.min(n, a, o, r)) {
    case r:
      return "left";
    case o:
      return "right";
    case n:
      return "top";
    case a:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function LC(e, t, n = 5) {
  const a = [];
  switch (t) {
    case "top":
      a.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      a.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      a.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      a.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return a;
}
function zC(e) {
  const { top: t, right: n, bottom: a, left: o } = e;
  return [
    { x: o, y: t },
    { x: n, y: t },
    { x: n, y: a },
    { x: o, y: a }
  ];
}
function HC(e, t) {
  const { x: n, y: a } = e;
  let o = !1;
  for (let r = 0, s = t.length - 1; r < t.length; s = r++) {
    const i = t[r].x, u = t[r].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (o = !o);
  }
  return o;
}
function UC(e) {
  const t = e.slice();
  return t.sort((n, a) => n.x < a.x ? -1 : n.x > a.x ? 1 : n.y < a.y ? -1 : n.y > a.y ? 1 : 0), jC(t);
}
function jC(e) {
  if (e.length <= 1)
    return e.slice();
  const t = [];
  for (let a = 0; a < e.length; a++) {
    const o = e[a];
    for (; t.length >= 2; ) {
      const r = t[t.length - 1], s = t[t.length - 2];
      if ((r.x - s.x) * (o.y - s.y) >= (r.y - s.y) * (o.x - s.x))
        t.pop();
      else break;
    }
    t.push(o);
  }
  t.pop();
  const n = [];
  for (let a = e.length - 1; a >= 0; a--) {
    const o = e[a];
    for (; n.length >= 2; ) {
      const r = n[n.length - 1], s = n[n.length - 2];
      if ((r.x - s.x) * (o.y - s.y) >= (r.y - s.y) * (o.x - s.x))
        n.pop();
      else break;
    }
    n.push(o);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var WC = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Lo = /* @__PURE__ */ new WeakMap(), dl = /* @__PURE__ */ new WeakMap(), cl = {}, fd = 0, vy = function(e) {
  return e && (e.host || vy(e.parentNode));
}, KC = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var a = vy(n);
    return a && e.contains(a) ? a : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, GC = function(e, t, n, a) {
  var o = KC(t, Array.isArray(e) ? e : [e]);
  cl[n] || (cl[n] = /* @__PURE__ */ new WeakMap());
  var r = cl[n], s = [], i = /* @__PURE__ */ new Set(), u = new Set(o), d = function(f) {
    !f || i.has(f) || (i.add(f), d(f.parentNode));
  };
  o.forEach(d);
  var c = function(f) {
    !f || u.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (i.has(p))
        c(p);
      else
        try {
          var v = p.getAttribute(a), m = v !== null && v !== "false", h = (Lo.get(p) || 0) + 1, _ = (r.get(p) || 0) + 1;
          Lo.set(p, h), r.set(p, _), s.push(p), h === 1 && m && dl.set(p, !0), _ === 1 && p.setAttribute(n, "true"), m || p.setAttribute(a, "true");
        } catch (x) {
          console.error("aria-hidden: cannot operate on ", p, x);
        }
    });
  };
  return c(t), i.clear(), fd++, function() {
    s.forEach(function(f) {
      var p = Lo.get(f) - 1, v = r.get(f) - 1;
      Lo.set(f, p), r.set(f, v), p || (dl.has(f) || f.removeAttribute(a), dl.delete(f)), v || f.removeAttribute(n);
    }), fd--, fd || (Lo = /* @__PURE__ */ new WeakMap(), Lo = /* @__PURE__ */ new WeakMap(), dl = /* @__PURE__ */ new WeakMap(), cl = {});
  };
}, YC = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), o = WC(e);
  return o ? (a.push.apply(a, Array.from(o.querySelectorAll("[aria-live]"))), GC(a, o, n, "aria-hidden")) : function() {
    return null;
  };
};
function Ns(e) {
  let t;
  ce(() => kn(e), (n) => {
    n ? t = YC(n) : t && t();
  }), Ze(() => {
    t && t();
  });
}
let XC = 0;
function Ot(e, t = "radix") {
  const n = tu({ useId: void 0 });
  return Wo.useId ? `${t}-${Wo.useId()}` : n.useId ? `${t}-${n.useId()}` : `${t}-${++XC}`;
}
function my(e) {
  const t = O(), n = E(() => {
    var o;
    return ((o = t.value) == null ? void 0 : o.width) ?? 0;
  }), a = E(() => {
    var o;
    return ((o = t.value) == null ? void 0 : o.height) ?? 0;
  });
  return be(() => {
    const o = kn(e);
    if (o) {
      t.value = { width: o.offsetWidth, height: o.offsetHeight };
      const r = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length)
          return;
        const i = s[0];
        let u, d;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          u = f.inlineSize, d = f.blockSize;
        } else
          u = o.offsetWidth, d = o.offsetHeight;
        t.value = { width: u, height: d };
      });
      return r.observe(o, { box: "border-box" }), () => r.unobserve(o);
    } else
      t.value = void 0;
  }), {
    width: n,
    height: a
  };
}
function JC(e, t) {
  const n = O(e);
  function a(o) {
    return t[n.value][o] ?? n.value;
  }
  return {
    state: n,
    dispatch: (o) => {
      n.value = a(o);
    }
  };
}
const ZC = "data-item-text";
function xf(e) {
  const t = uy("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (n, a) => {
      if (!(e != null && e.value) && !a)
        return;
      t.value = t.value + n;
      const o = (e == null ? void 0 : e.value) ?? a, r = It(), s = o.map((f) => {
        var p;
        return {
          ref: f,
          textValue: ((p = (f.querySelector(`[${ZC}]`) ?? f).textContent) == null ? void 0 : p.trim()) ?? ""
        };
      }), i = s.find((f) => f.ref === r), u = s.map((f) => f.textValue), d = eS(u, t.value, i == null ? void 0 : i.textValue), c = s.find((f) => f.textValue === d);
      return c && c.ref.focus(), c == null ? void 0 : c.ref;
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function QC(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
function eS(e, t, n) {
  const a = t.length > 1 && Array.from(t).every((i) => i === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let r = QC(e, Math.max(o, 0));
  a.length === 1 && (r = r.filter((i) => i !== n));
  const s = r.find(
    (i) => i.toLowerCase().startsWith(a.toLowerCase())
  );
  return s !== n ? s : void 0;
}
const Cf = b({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: t, slots: n }) {
    return () => {
      var a, o;
      if (!n.default)
        return null;
      const r = eu(n.default()), s = r.findIndex((c) => c.type !== Zc);
      if (s === -1)
        return r;
      const i = r[s];
      (a = i.props) == null || delete a.ref;
      const u = i.props ? A(t, i.props) : t;
      t.class && (o = i.props) != null && o.class && delete i.props.class;
      const d = pg(i, u);
      for (const c in u)
        c.startsWith("on") && (d.props || (d.props = {}), d.props[c] = u[c]);
      return r.length === 1 ? d : (r[s] = d, r);
    };
  }
}), Se = b({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: t, slots: n }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && ["area", "img", "input"].includes(a) ? () => Bt(a, t) : a !== "template" ? () => Bt(e.as, t, { default: n.default }) : () => Bt(Cf, t, { default: n.default });
  }
});
function hy() {
  const e = O(), t = E(() => {
    var n, a;
    return ["#text", "#comment"].includes((n = e.value) == null ? void 0 : n.$el.nodeName) ? (a = e.value) == null ? void 0 : a.$el.nextElementSibling : kn(e);
  });
  return {
    primitiveElement: e,
    currentElement: t
  };
}
const [gy, tS] = Ye("CollapsibleRoot"), nS = /* @__PURE__ */ b({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = pt(a, "open", n, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), r = pt(a, "disabled");
    return tS({
      contentId: "",
      disabled: r,
      open: o,
      onOpenToggle: () => {
        o.value = !o.value;
      }
    }), t({ open: o }), fe(), (s, i) => (g(), C(l(Se), {
      as: s.as,
      "as-child": a.asChild,
      "data-state": l(o) ? "open" : "closed",
      "data-disabled": l(r) ? "" : void 0
    }, {
      default: y(() => [
        w(s.$slots, "default", { open: l(o) })
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state", "data-disabled"]));
  }
}), aS = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    fe();
    const n = gy();
    return (a, o) => {
      var r, s;
      return g(), C(l(Se), {
        type: a.as === "button" ? "button" : void 0,
        as: a.as,
        "as-child": t.asChild,
        "aria-controls": l(n).contentId,
        "aria-expanded": l(n).open.value,
        "data-state": l(n).open.value ? "open" : "closed",
        "data-disabled": (r = l(n).disabled) != null && r.value ? "" : void 0,
        disabled: (s = l(n).disabled) == null ? void 0 : s.value,
        onClick: l(n).onOpenToggle
      }, {
        default: y(() => [
          w(a.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});
function oS(e, t) {
  var n;
  const a = O({}), o = O("none"), r = O(e), s = e.value ? "mounted" : "unmounted";
  let i;
  const u = ((n = t.value) == null ? void 0 : n.ownerDocument.defaultView) ?? Fs, { state: d, dispatch: c } = JC(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  }), f = (_) => {
    var x;
    if (ia) {
      const S = new CustomEvent(_, { bubbles: !1, cancelable: !1 });
      (x = t.value) == null || x.dispatchEvent(S);
    }
  };
  ce(
    e,
    async (_, x) => {
      var S;
      const $ = x !== _;
      if (await he(), $) {
        const D = o.value, B = fl(t.value);
        _ ? (c("MOUNT"), f("enter"), B === "none" && f("after-enter")) : B === "none" || ((S = a.value) == null ? void 0 : S.display) === "none" ? (c("UNMOUNT"), f("leave"), f("after-leave")) : x && D !== B ? (c("ANIMATION_OUT"), f("leave")) : (c("UNMOUNT"), f("after-leave"));
      }
    },
    { immediate: !0 }
  );
  const p = (_) => {
    const x = fl(t.value), S = x.includes(
      _.animationName
    ), $ = d.value === "mounted" ? "enter" : "leave";
    if (_.target === t.value && S && (f(`after-${$}`), c("ANIMATION_END"), !r.value)) {
      const D = t.value.style.animationFillMode;
      t.value.style.animationFillMode = "forwards", i = u == null ? void 0 : u.setTimeout(() => {
        var B;
        ((B = t.value) == null ? void 0 : B.style.animationFillMode) === "forwards" && (t.value.style.animationFillMode = D);
      });
    }
    _.target === t.value && x === "none" && c("ANIMATION_END");
  }, v = (_) => {
    _.target === t.value && (o.value = fl(t.value));
  }, m = ce(
    t,
    (_, x) => {
      _ ? (a.value = getComputedStyle(_), _.addEventListener("animationstart", v), _.addEventListener("animationcancel", p), _.addEventListener("animationend", p)) : (c("ANIMATION_END"), i !== void 0 && (u == null || u.clearTimeout(i)), x == null || x.removeEventListener("animationstart", v), x == null || x.removeEventListener("animationcancel", p), x == null || x.removeEventListener("animationend", p));
    },
    { immediate: !0 }
  ), h = ce(d, () => {
    const _ = fl(t.value);
    o.value = d.value === "mounted" ? _ : "none";
  });
  return Ze(() => {
    m(), h();
  }), {
    isPresent: E(
      () => ["mounted", "unmountSuspended"].includes(d.value)
    )
  };
}
function fl(e) {
  return e && getComputedStyle(e).animationName || "none";
}
const On = b({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(e, { slots: t, expose: n }) {
    var a;
    const { present: o, forceMount: r } = Be(e), s = O(), { isPresent: i } = oS(o, s);
    n({ present: i });
    let u = t.default({ present: i });
    u = eu(u || []);
    const d = ct();
    if (u && (u == null ? void 0 : u.length) > 1) {
      const c = (a = d == null ? void 0 : d.parent) != null && a.type.name ? `<${d.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((f) => `  - ${f}`).join(`
`)
        ].join(`
`)
      );
    }
    return () => r.value || o.value || i.value ? Bt(t.default({ present: i })[0], {
      ref: (c) => {
        const f = kn(c);
        return typeof (f == null ? void 0 : f.hasAttribute) > "u" || (f != null && f.hasAttribute("data-radix-popper-content-wrapper") ? s.value = f.firstElementChild : s.value = f), f;
      }
    }) : null;
  }
}), rS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = gy();
    n.contentId || (n.contentId = Ot(void 0, "radix-vue-collapsible-content"));
    const a = O(), { forwardRef: o, currentElement: r } = fe(), s = O(0), i = O(0), u = E(() => n.open.value), d = O(u.value), c = O();
    return ce(
      () => {
        var f;
        return [u.value, (f = a.value) == null ? void 0 : f.present];
      },
      async () => {
        await he();
        const f = r.value;
        if (!f)
          return;
        c.value = c.value || {
          transitionDuration: f.style.transitionDuration,
          animationName: f.style.animationName
        }, f.style.transitionDuration = "0s", f.style.animationName = "none";
        const p = f.getBoundingClientRect();
        i.value = p.height, s.value = p.width, d.value || (f.style.transitionDuration = c.value.transitionDuration, f.style.animationName = c.value.animationName);
      },
      {
        immediate: !0
      }
    ), be(() => {
      requestAnimationFrame(() => {
        d.value = !1;
      });
    }), (f, p) => (g(), C(l(On), {
      ref_key: "presentRef",
      ref: a,
      present: f.forceMount || l(n).open.value,
      "force-mount": !0
    }, {
      default: y(() => {
        var v, m;
        return [
          N(l(Se), A(f.$attrs, {
            id: l(n).contentId,
            ref: l(o),
            "as-child": t.asChild,
            as: f.as,
            "data-state": l(n).open.value ? "open" : "closed",
            "data-disabled": (v = l(n).disabled) != null && v.value ? "" : void 0,
            hidden: !((m = a.value) != null && m.present),
            style: {
              "--radix-collapsible-content-height": `${i.value}px`,
              "--radix-collapsible-content-width": `${s.value}px`
            }
          }), {
            default: y(() => {
              var h;
              return [
                (h = a.value) != null && h.present ? w(f.$slots, "default", { key: 0 }) : Pe("", !0)
              ];
            }),
            _: 3
          }, 16, ["id", "as-child", "as", "data-state", "data-disabled", "hidden", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
});
function yy({ type: e, defaultValue: t, modelValue: n }) {
  const a = n || t;
  if (Qo(e) && Qo(n) && Qo(t))
    throw new Error("Either the `type` or the `value` or `default-value` prop must be defined.");
  if (n !== void 0 && t !== void 0 && typeof n != typeof t)
    throw new Error(
      `Invalid prop \`value\` of value \`${n}\` supplied, should be the same type as the \`defaultValue\` prop, which is \`${t}\`. The \`value\` prop must be:
  ${e === "single" ? "- a string" : e === "multiple" ? "- an array of strings" : `- a string
- an array of strings`}
  - \`undefined\``
    );
  const o = n !== void 0 || t !== void 0;
  if (e && o) {
    const r = Array.isArray(n) || Array.isArray(t), s = n !== void 0 ? "modelValue" : "defaultValue", i = s === "modelValue" ? typeof n : typeof t;
    if (e === "single" && r)
      return console.error(`Invalid prop \`${s}\` of type ${i} supplied with type \`single\`. The \`modelValue\` prop must be a string or \`undefined\`.
    You can remove the \`type\` prop to let the component infer the type from the ${s} prop.`), "multiple";
    if (e === "multiple" && !r)
      return console.error(`Invalid prop \`${s}\` of type ${i} supplied with type \`multiple\`. The \`modelValue\` prop must be an array of strings or \`undefined\`.
    You can remove the \`type\` prop to let the component infer the type from the ${s} prop.`), "single";
  }
  return o ? Array.isArray(a) ? "multiple" : "single" : e;
}
function sS({ type: e, defaultValue: t, modelValue: n }) {
  return e || yy({ type: e, defaultValue: t, modelValue: n });
}
function lS({ type: e, defaultValue: t }) {
  return t !== void 0 ? t : e === "single" ? void 0 : [];
}
function iS(e, t) {
  const n = O(sS(e)), a = pt(e, "modelValue", t, {
    defaultValue: lS(e),
    passive: e.modelValue === void 0,
    deep: !0
  });
  ce(
    () => [e.type, e.modelValue, e.defaultValue],
    () => {
      const s = yy(e);
      n.value !== s && (n.value = s);
    },
    { immediate: !0 }
  );
  function o(s) {
    if (n.value === "single")
      a.value = s === a.value ? void 0 : s;
    else {
      const i = [...a.value || []];
      if (i.includes(s)) {
        const u = i.findIndex((d) => d === s);
        i.splice(u, 1);
      } else
        i.push(s);
      a.value = i;
    }
  }
  const r = E(() => n.value === "single");
  return {
    modelValue: a,
    type: n,
    changeModelValue: o,
    isSingle: r
  };
}
const [au, uS] = Ye("AccordionRoot"), dS = /* @__PURE__ */ b({
  __name: "AccordionRoot",
  props: {
    collapsible: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dir: {},
    orientation: { default: "vertical" },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: o, disabled: r } = Be(n), s = to(o), { modelValue: i, changeModelValue: u, isSingle: d } = iS(n, a), { forwardRef: c, currentElement: f } = fe();
    return uS({
      disabled: r,
      direction: s,
      orientation: n.orientation,
      parentElement: f,
      isSingle: d,
      collapsible: n.collapsible,
      modelValue: i,
      changeModelValue: u
    }), (p, v) => (g(), C(l(Se), {
      ref: l(c),
      "as-child": p.asChild,
      as: p.as
    }, {
      default: y(() => [
        w(p.$slots, "default", { modelValue: l(i) })
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), [Sf, cS] = Ye("AccordionItem"), fS = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e, { expose: t }) {
    const n = e, a = au(), o = E(
      () => a.isSingle.value ? n.value === a.modelValue.value : Array.isArray(a.modelValue.value) && a.modelValue.value.includes(n.value)
    ), r = E(() => a.disabled.value || n.disabled), s = E(() => r.value ? "" : void 0), i = E(
      () => o.value ? "open" : "closed"
      /* Closed */
    );
    t({ open: o, dataDisabled: s });
    const { currentRef: u, currentElement: d } = fe();
    cS({
      open: o,
      dataState: i,
      disabled: r,
      dataDisabled: s,
      triggerId: "",
      currentRef: u,
      currentElement: d,
      value: E(() => n.value)
    });
    function c(f) {
      var p;
      const v = f.target;
      if (Array.from(((p = a.parentElement.value) == null ? void 0 : p.querySelectorAll("[data-radix-vue-collection-item]")) ?? []).findIndex((m) => m === v) === -1)
        return null;
      cy(
        f,
        d.value,
        a.parentElement.value,
        {
          arrowKeyOptions: a.orientation,
          dir: a.direction.value,
          focus: !0
        }
      );
    }
    return (f, p) => (g(), C(l(nS), {
      "data-orientation": l(a).orientation,
      "data-disabled": s.value,
      "data-state": i.value,
      disabled: r.value,
      open: o.value,
      as: n.as,
      "as-child": n.asChild,
      onKeydown: Qe(c, ["up", "down", "left", "right", "home", "end"])
    }, {
      default: y(() => [
        w(f.$slots, "default", { open: o.value })
      ]),
      _: 3
    }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as", "as-child"]));
  }
}), pS = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = au(), a = Sf();
    return fe(), (o, r) => (g(), C(l(rS), {
      role: "region",
      hidden: !l(a).open.value,
      "as-child": t.asChild,
      "force-mount": t.forceMount,
      "aria-labelledby": l(a).triggerId,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      style: { "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", "--radix-accordion-content-height": "var(--radix-collapsible-content-height)" }
    }, {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["hidden", "as-child", "force-mount", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]));
  }
}), vS = /* @__PURE__ */ b({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "h3" }
  },
  setup(e) {
    const t = e, n = au(), a = Sf();
    return fe(), (o, r) => (g(), C(l(Se), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value
    }, {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]));
  }
}), mS = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = au(), a = Sf();
    a.triggerId || (a.triggerId = Ot(void 0, "radix-vue-accordion-trigger"));
    function o() {
      const r = n.isSingle.value && a.open.value && !n.collapsible;
      a.disabled.value || r || n.changeModelValue(a.value.value);
    }
    return (r, s) => (g(), C(l(aS), {
      id: l(a).triggerId,
      ref: l(a).currentRef,
      "data-radix-vue-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-disabled": l(a).disabled.value || void 0,
      "aria-expanded": l(a).open.value || !1,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      disabled: l(a).disabled.value,
      onClick: o
    }, {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "as", "as-child", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]));
  }
}), [ua, hS] = Ye("DialogRoot"), $f = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: !1 },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = pt(n, "open", t, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = O(), r = O(), { modal: s } = Be(n);
    return hS({
      open: a,
      modal: s,
      openModal: () => {
        a.value = !0;
      },
      onOpenChange: (i) => {
        a.value = i;
      },
      onOpenToggle: () => {
        a.value = !a.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: o,
      contentElement: r
    }), (i, u) => w(i.$slots, "default", { open: l(a) });
  }
}), Bf = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = ua(), { forwardRef: a, currentElement: o } = fe();
    return n.contentId || (n.contentId = Ot(void 0, "radix-vue-dialog-content")), be(() => {
      n.triggerElement.value = o.value;
    }), (r, s) => (g(), C(l(Se), A(t, {
      ref: l(a),
      type: r.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": l(n).open.value || !1,
      "aria-controls": l(n).open.value ? l(n).contentId : void 0,
      "data-state": l(n).open.value ? "open" : "closed",
      onClick: l(n).onOpenToggle
    }), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]));
  }
}), Cr = /* @__PURE__ */ b({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = _f();
    return (n, a) => l(t) || n.forceMount ? (g(), C(Co, {
      key: 0,
      to: n.to,
      disabled: n.disabled
    }, [
      w(n.$slots, "default")
    ], 8, ["to", "disabled"])) : Pe("", !0);
  }
}), Pf = /* @__PURE__ */ b({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Cr), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gS = "dismissableLayer.pointerDownOutside", yS = "dismissableLayer.focusOutside";
function by(e, t) {
  const n = t.closest(
    "[data-dismissable-layer]"
  ), a = e.dataset.dismissableLayer === "" ? e : e.querySelector(
    "[data-dismissable-layer]"
  ), o = Array.from(
    e.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return !!(n && a === n || o.indexOf(a) < o.indexOf(n));
}
function bS(e, t) {
  var n;
  const a = ((n = t == null ? void 0 : t.value) == null ? void 0 : n.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = O(!1), r = O(() => {
  });
  return Me((s) => {
    if (!ia)
      return;
    const i = async (d) => {
      const c = d.target;
      if (t != null && t.value) {
        if (by(t.value, c)) {
          o.value = !1;
          return;
        }
        if (d.target && !o.value) {
          let f = function() {
            gf(
              gS,
              e,
              p
            );
          };
          const p = { originalEvent: d };
          d.pointerType === "touch" ? (a.removeEventListener("click", r.value), r.value = f, a.addEventListener("click", r.value, {
            once: !0
          })) : f();
        } else
          a.removeEventListener("click", r.value);
        o.value = !1;
      }
    }, u = window.setTimeout(() => {
      a.addEventListener("pointerdown", i);
    }, 0);
    s(() => {
      window.clearTimeout(u), a.removeEventListener("pointerdown", i), a.removeEventListener("click", r.value);
    });
  }), {
    onPointerDownCapture: () => o.value = !0
  };
}
function _S(e, t) {
  var n;
  const a = ((n = t == null ? void 0 : t.value) == null ? void 0 : n.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = O(!1);
  return Me((r) => {
    if (!ia)
      return;
    const s = async (i) => {
      t != null && t.value && (await he(), !(!t.value || by(t.value, i.target)) && i.target && !o.value && gf(
        yS,
        e,
        { originalEvent: i }
      ));
    };
    a.addEventListener("focusin", s), r(() => a.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => o.value = !0,
    onBlurCapture: () => o.value = !1
  };
}
const In = Qt({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Sr = /* @__PURE__ */ b({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = fe(), s = E(
      () => {
        var m;
        return ((m = r.value) == null ? void 0 : m.ownerDocument) ?? globalThis.document;
      }
    ), i = E(() => In.layersRoot), u = E(() => r.value ? Array.from(i.value).indexOf(r.value) : -1), d = E(() => In.layersWithOutsidePointerEventsDisabled.size > 0), c = E(() => {
      const m = Array.from(i.value), [h] = [...In.layersWithOutsidePointerEventsDisabled].slice(-1), _ = m.indexOf(h);
      return u.value >= _;
    }), f = bS(async (m) => {
      const h = [...In.branches].some(
        (_) => _ == null ? void 0 : _.contains(m.target)
      );
      !c.value || h || (a("pointerDownOutside", m), a("interactOutside", m), await he(), m.defaultPrevented || a("dismiss"));
    }, r), p = _S((m) => {
      [...In.branches].some(
        (h) => h == null ? void 0 : h.contains(m.target)
      ) || (a("focusOutside", m), a("interactOutside", m), m.defaultPrevented || a("dismiss"));
    }, r);
    bf("Escape", (m) => {
      u.value === i.value.size - 1 && (a("escapeKeyDown", m), m.defaultPrevented || a("dismiss"));
    });
    let v;
    return Me((m) => {
      r.value && (n.disableOutsidePointerEvents && (In.layersWithOutsidePointerEventsDisabled.size === 0 && (v = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), In.layersWithOutsidePointerEventsDisabled.add(r.value)), i.value.add(r.value), m(() => {
        n.disableOutsidePointerEvents && In.layersWithOutsidePointerEventsDisabled.size === 1 && (s.value.body.style.pointerEvents = v);
      }));
    }), Me((m) => {
      m(() => {
        r.value && (i.value.delete(r.value), In.layersWithOutsidePointerEventsDisabled.delete(r.value));
      });
    }), (m, h) => (g(), C(l(Se), {
      ref: l(o),
      "as-child": m.asChild,
      as: m.as,
      "data-dismissable-layer": "",
      style: vt({
        pointerEvents: d.value ? c.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: l(p).onFocusCapture,
      onBlurCapture: l(p).onBlurCapture,
      onPointerdownCapture: l(f).onPointerDownCapture
    }, {
      default: y(() => [
        w(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
}), wS = /* @__PURE__ */ b({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = fe();
    return be(() => {
      In.branches.add(a.value);
    }), Ze(() => {
      In.branches.delete(a.value);
    }), (o, r) => (g(), C(l(Se), A({ ref: l(n) }, t), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pd = "focusScope.autoFocusOnMount", vd = "focusScope.autoFocusOnUnmount", Qv = { bubbles: !1, cancelable: !0 };
function Vl(e, { select: t = !1 } = {}) {
  const n = It();
  for (const a of e)
    if (za(a, { select: t }), It() !== n)
      return !0;
}
function xS(e) {
  const t = Ef(e), n = em(t, e), a = em(t.reverse(), e);
  return [n, a];
}
function Ef(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (a) => {
      const o = a.tagName === "INPUT" && a.type === "hidden";
      return a.disabled || a.hidden || o ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function em(e, t) {
  for (const n of e)
    if (!CS(n, { upTo: t }))
      return n;
}
function CS(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t !== void 0 && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}
function SS(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function za(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = It();
    e.focus({ preventScroll: !0 }), e !== n && SS(e) && t && e.select();
  }
}
const $S = yC(() => O([]));
function BS() {
  const e = $S();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && (n == null || n.pause()), e.value = tm(e.value, t), e.value.unshift(t);
    },
    remove(t) {
      var n;
      e.value = tm(e.value, t), (n = e.value[0]) == null || n.resume();
    }
  };
}
function tm(e, t) {
  const n = [...e], a = n.indexOf(t);
  return a !== -1 && n.splice(a, 1), n;
}
function PS(e) {
  return e.filter((t) => t.tagName !== "A");
}
const ou = /* @__PURE__ */ b({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: !1 },
    trapped: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, { currentRef: o, currentElement: r } = fe(), s = O(null), i = BS(), u = Qt({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Me((c) => {
      if (!ia)
        return;
      const f = r.value;
      if (!n.trapped)
        return;
      function p(_) {
        if (u.paused || !f)
          return;
        const x = _.target;
        f.contains(x) ? s.value = x : za(s.value, { select: !0 });
      }
      function v(_) {
        if (u.paused || !f)
          return;
        const x = _.relatedTarget;
        x !== null && (f.contains(x) || za(s.value, { select: !0 }));
      }
      function m(_) {
        f.contains(s.value) || za(f);
      }
      document.addEventListener("focusin", p), document.addEventListener("focusout", v);
      const h = new MutationObserver(m);
      f && h.observe(f, { childList: !0, subtree: !0 }), c(() => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", v), h.disconnect();
      });
    }), Me(async (c) => {
      const f = r.value;
      if (await he(), !f)
        return;
      i.add(u);
      const p = It();
      if (!f.contains(p)) {
        const v = new CustomEvent(pd, Qv);
        f.addEventListener(pd, (m) => a("mountAutoFocus", m)), f.dispatchEvent(v), v.defaultPrevented || (Vl(PS(Ef(f)), {
          select: !0
        }), It() === p && za(f));
      }
      c(() => {
        f.removeEventListener(pd, (h) => a("mountAutoFocus", h));
        const v = new CustomEvent(vd, Qv), m = (h) => {
          a("unmountAutoFocus", h);
        };
        f.addEventListener(vd, m), f.dispatchEvent(v), setTimeout(() => {
          v.defaultPrevented || za(p ?? document.body, { select: !0 }), f.removeEventListener(vd, m), i.remove(u);
        }, 0);
      });
    });
    function d(c) {
      if (!n.loop && !n.trapped || u.paused)
        return;
      const f = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, p = It();
      if (f && p) {
        const v = c.currentTarget, [m, h] = xS(v);
        m && h ? !c.shiftKey && p === h ? (c.preventDefault(), n.loop && za(m, { select: !0 })) : c.shiftKey && p === m && (c.preventDefault(), n.loop && za(h, { select: !0 })) : p === v && c.preventDefault();
      }
    }
    return (c, f) => (g(), C(l(Se), {
      ref_key: "currentRef",
      ref: o,
      tabindex: "-1",
      "as-child": c.asChild,
      as: c.as,
      onKeydown: d
    }, {
      default: y(() => [
        w(c.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), ES = "menu.itemSelect", oc = ["Enter", " "], DS = ["ArrowDown", "PageUp", "Home"], _y = ["ArrowUp", "PageDown", "End"], MS = [...DS, ..._y], kS = {
  ltr: [...oc, "ArrowRight"],
  rtl: [...oc, "ArrowLeft"]
}, OS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function Df(e) {
  return e ? "open" : "closed";
}
function ci(e) {
  return e === "indeterminate";
}
function Mf(e) {
  return ci(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function rc(e) {
  const t = It();
  for (const n of e)
    if (n === t || (n.focus(), It() !== t))
      return;
}
function TS(e, t) {
  const { x: n, y: a } = e;
  let o = !1;
  for (let r = 0, s = t.length - 1; r < t.length; s = r++) {
    const i = t[r].x, u = t[r].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (o = !o);
  }
  return o;
}
function AS(e, t) {
  if (!t)
    return !1;
  const n = { x: e.clientX, y: e.clientY };
  return TS(n, t);
}
function hs(e) {
  return e.pointerType === "mouse";
}
const IS = "DialogTitle", RS = "DialogContent";
function qS({
  titleName: e = IS,
  contentName: t = RS,
  componentLink: n = "dialog.html#title",
  titleId: a,
  descriptionId: o,
  contentElement: r
}) {
  const s = `Warning: \`${t}\` requires a \`${e}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.radix-vue.com/components/${n}`, i = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${t}.`;
  be(() => {
    var u;
    document.getElementById(a) || console.warn(s);
    const d = (u = r.value) == null ? void 0 : u.getAttribute("aria-describedby");
    o && d && (document.getElementById(o) || console.warn(i));
  });
}
const wy = /* @__PURE__ */ b({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ua(), { forwardRef: r, currentElement: s } = fe();
    return o.titleId || (o.titleId = Ot(void 0, "radix-vue-dialog-title")), o.descriptionId || (o.descriptionId = Ot(void 0, "radix-vue-dialog-description")), be(() => {
      o.contentElement = s, It() !== document.body && (o.triggerElement.value = It());
    }), process.env.NODE_ENV !== "production" && qS({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: o.titleId,
      descriptionId: o.descriptionId,
      contentElement: s
    }), (i, u) => (g(), C(l(ou), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [
        N(l(Sr), A({
          id: l(o).contentId,
          ref: l(r),
          as: i.as,
          "as-child": i.asChild,
          "disable-outside-pointer-events": i.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": l(o).descriptionId,
          "aria-labelledby": l(o).titleId,
          "data-state": l(Df)(l(o).open.value)
        }, i.$attrs, {
          onDismiss: u[0] || (u[0] = (d) => l(o).onOpenChange(!1)),
          onEscapeKeyDown: u[1] || (u[1] = (d) => a("escapeKeyDown", d)),
          onFocusOutside: u[2] || (u[2] = (d) => a("focusOutside", d)),
          onInteractOutside: u[3] || (u[3] = (d) => a("interactOutside", d)),
          onPointerDownOutside: u[4] || (u[4] = (d) => a("pointerDownOutside", d))
        }), {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), FS = /* @__PURE__ */ b({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ua(), r = no(a), { forwardRef: s, currentElement: i } = fe();
    return Ns(i), (u, d) => (g(), C(wy, A({ ...n, ...l(r) }, {
      ref: l(s),
      "trap-focus": l(o).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        var f;
        c.defaultPrevented || (c.preventDefault(), (f = l(o).triggerElement.value) == null || f.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0;
        (f.button === 2 || p) && c.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (c) => {
        c.preventDefault();
      })
    }), {
      default: y(() => [
        w(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), VS = /* @__PURE__ */ b({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = no(t);
    fe();
    const o = ua(), r = O(!1), s = O(!1);
    return (i, u) => (g(), C(wy, A({ ...n, ...l(a) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        var c;
        d.defaultPrevented || (r.value || (c = l(o).triggerElement.value) == null || c.focus(), d.preventDefault()), r.value = !1, s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        var c;
        d.defaultPrevented || (r.value = !0, d.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const f = d.target;
        (c = l(o).triggerElement.value) != null && c.contains(f) && d.preventDefault(), d.detail.originalEvent.type === "focusin" && s.value && d.preventDefault();
      })
    }), {
      default: y(() => [
        w(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ru = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ua(), r = no(a), { forwardRef: s } = fe();
    return (i, u) => (g(), C(l(On), {
      present: i.forceMount || l(o).open.value
    }, {
      default: y(() => [
        l(o).modal.value ? (g(), C(FS, A({
          key: 0,
          ref: l(s)
        }, { ...n, ...l(r), ...i.$attrs }), {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (g(), C(VS, A({
          key: 1,
          ref: l(s)
        }, { ...n, ...l(r), ...i.$attrs }), {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), NS = /* @__PURE__ */ b({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = ua();
    return Vs(!0), fe(), (n, a) => (g(), C(l(Se), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": l(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state"]));
  }
}), su = /* @__PURE__ */ b({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = ua(), { forwardRef: n } = fe();
    return (a, o) => {
      var r;
      return (r = l(t)) != null && r.modal.value ? (g(), C(l(On), {
        key: 0,
        present: a.forceMount || l(t).open.value
      }, {
        default: y(() => [
          N(NS, A(a.$attrs, {
            ref: l(n),
            as: a.as,
            "as-child": a.asChild
          }), {
            default: y(() => [
              w(a.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["present"])) : Pe("", !0);
    };
  }
}), Bo = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    fe();
    const n = ua();
    return (a, o) => (g(), C(l(Se), A(t, {
      type: a.as === "button" ? "button" : void 0,
      onClick: o[0] || (o[0] = (r) => l(n).onOpenChange(!1))
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), kf = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(e) {
    const t = e, n = ua();
    return fe(), (a, o) => (g(), C(l(Se), A(t, {
      id: l(n).titleId
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), Of = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(e) {
    const t = e;
    fe();
    const n = ua();
    return (a, o) => (g(), C(l(Se), A(t, {
      id: l(n).descriptionId
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), LS = /* @__PURE__ */ b({
  __name: "AlertDialogRoot",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = Le(e, t);
    return fe(), (a, o) => (g(), C(l($f), A(l(n), { modal: !0 }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zS = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(Bf), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), HS = /* @__PURE__ */ b({
  __name: "AlertDialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Cr), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [US, jS] = Ye("AlertDialogContent"), WS = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = no(t);
    fe();
    const o = O();
    return jS({
      onCancelElementChange: (r) => {
        o.value = r;
      }
    }), (r, s) => (g(), C(l(ru), A({ ...n, ...l(a) }, {
      role: "alertdialog",
      onPointerDownOutside: s[0] || (s[0] = We(() => {
      }, ["prevent"])),
      onInteractOutside: s[1] || (s[1] = We(() => {
      }, ["prevent"])),
      onOpenAutoFocus: s[2] || (s[2] = () => {
        he(() => {
          var i;
          (i = o.value) == null || i.focus({
            preventScroll: !0
          });
        });
      })
    }), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), KS = /* @__PURE__ */ b({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(su), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), GS = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = US(), { forwardRef: a, currentElement: o } = fe();
    return be(() => {
      n.onCancelElementChange(o.value);
    }), (r, s) => (g(), C(l(Bo), A(t, { ref: l(a) }), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), YS = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(kf), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), XS = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(Of), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), JS = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(Bo), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [xy, ZS] = Ye("AvatarRoot"), QS = /* @__PURE__ */ b({
  __name: "AvatarRoot",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    return fe(), ZS({
      imageLoadingStatus: O("loading")
    }), (t, n) => (g(), C(l(Se), {
      "as-child": t.asChild,
      as: t.as
    }, {
      default: y(() => [
        w(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
});
function e$(e, t) {
  const n = O("idle"), a = O(!1), o = (r) => () => {
    a.value && (n.value = r);
  };
  return be(() => {
    a.value = !0, ce([() => e.value, () => t == null ? void 0 : t.value], ([r, s]) => {
      if (!r)
        n.value = "error";
      else {
        const i = new window.Image();
        n.value = "loading", i.onload = o("loaded"), i.onerror = o("error"), i.src = r, s && (i.referrerPolicy = s);
      }
    }, { immediate: !0 });
  }), Ze(() => {
    a.value = !1;
  }), n;
}
const t$ = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {},
    referrerPolicy: {},
    asChild: { type: Boolean },
    as: { default: "img" }
  },
  emits: ["loadingStatusChange"],
  setup(e, { emit: t }) {
    const n = e, a = t, { src: o, referrerPolicy: r } = Be(n);
    fe();
    const s = xy(), i = e$(o, r);
    return ce(
      i,
      (u) => {
        a("loadingStatusChange", u), u !== "idle" && (s.imageLoadingStatus.value = u);
      },
      { immediate: !0 }
    ), (u, d) => br((g(), C(l(Se), {
      role: "img",
      "as-child": u.asChild,
      as: u.as,
      src: l(o),
      "referrer-policy": l(r)
    }, {
      default: y(() => [
        w(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "src", "referrer-policy"])), [
      [Xc, l(i) === "loaded"]
    ]);
  }
}), n$ = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: { default: 0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, n = xy();
    fe();
    const a = O(!1);
    let o;
    return ce(n.imageLoadingStatus, (r) => {
      r === "loading" && (a.value = !1, t.delayMs ? o = setTimeout(() => {
        a.value = !0, clearTimeout(o);
      }, t.delayMs) : a.value = !0);
    }, { immediate: !0 }), (r, s) => a.value && l(n).imageLoadingStatus.value !== "loaded" ? (g(), C(l(Se), {
      key: 0,
      "as-child": r.asChild,
      as: r.as
    }, {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"])) : Pe("", !0);
  }
}), [Cy, a$] = Ye("PopperRoot"), $r = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = O();
    return a$({
      anchor: t,
      onAnchorChange: (n) => t.value = n
    }), (n, a) => w(n.$slots, "default");
  }
}), Ls = /* @__PURE__ */ b({
  __name: "PopperAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = fe(), o = Cy();
    return Me(() => {
      o.onAnchorChange(t.element ?? a.value);
    }), (r, s) => (g(), C(l(Se), {
      ref: l(n),
      as: r.as,
      "as-child": r.asChild
    }, {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function o$(e) {
  return e !== null;
}
function r$(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      var n, a, o;
      const { placement: r, rects: s, middlewareData: i } = t, u = ((n = i.arrow) == null ? void 0 : n.centerOffset) !== 0, d = u ? 0 : e.arrowWidth, c = u ? 0 : e.arrowHeight, [f, p] = sc(r), v = { start: "0%", center: "50%", end: "100%" }[p], m = (((a = i.arrow) == null ? void 0 : a.x) ?? 0) + d / 2, h = (((o = i.arrow) == null ? void 0 : o.y) ?? 0) + c / 2;
      let _ = "", x = "";
      return f === "bottom" ? (_ = u ? v : `${m}px`, x = `${-c}px`) : f === "top" ? (_ = u ? v : `${m}px`, x = `${s.floating.height + c}px`) : f === "right" ? (_ = `${-c}px`, x = u ? v : `${h}px`) : f === "left" && (_ = `${s.floating.width + c}px`, x = u ? v : `${h}px`), { data: { x: _, y: x } };
    }
  };
}
function sc(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
const Sy = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [AU, s$] = Ye("PopperContent"), cr = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ ji({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...Sy
  }),
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Cy(), { forwardRef: r, currentElement: s } = fe(), i = O(), u = O(), { width: d, height: c } = my(u), f = E(
      () => n.side + (n.align !== "center" ? `-${n.align}` : "")
    ), p = E(() => typeof n.collisionPadding == "number" ? n.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...n.collisionPadding }), v = E(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = E(() => ({
      padding: p.value,
      boundary: v.value.filter(o$),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: v.value.length > 0
    })), h = hC(() => [
      Xg({
        mainAxis: n.sideOffset + c.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && ii({
        ...m.value
      }),
      n.avoidCollisions && Jg({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? ey() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && ii({
        ...m.value
      }),
      Zg({
        ...m.value,
        apply: ({ elements: P, rects: q, availableWidth: R, availableHeight: Q }) => {
          const { width: ee, height: K } = q.reference, W = P.floating.style;
          W.setProperty(
            "--radix-popper-available-width",
            `${R}px`
          ), W.setProperty(
            "--radix-popper-available-height",
            `${Q}px`
          ), W.setProperty(
            "--radix-popper-anchor-width",
            `${ee}px`
          ), W.setProperty(
            "--radix-popper-anchor-height",
            `${K}px`
          );
        }
      }),
      u.value && ty({ element: u.value, padding: n.arrowPadding }),
      r$({
        arrowWidth: d.value,
        arrowHeight: c.value
      }),
      n.hideWhenDetached && Qg({ strategy: "referenceHidden", ...m.value })
    ]), { floatingStyles: _, placement: x, isPositioned: S, middlewareData: $ } = ay(
      o.anchor,
      i,
      {
        strategy: "fixed",
        placement: f,
        whileElementsMounted: (...P) => Yg(...P, {
          animationFrame: n.updatePositionStrategy === "always"
        }),
        middleware: h
      }
    ), D = E(
      () => sc(x.value)[0]
    ), B = E(
      () => sc(x.value)[1]
    );
    Qc(() => {
      S.value && a("placed");
    });
    const k = E(
      () => {
        var P;
        return ((P = $.value.arrow) == null ? void 0 : P.centerOffset) !== 0;
      }
    ), M = O("");
    Me(() => {
      s.value && (M.value = window.getComputedStyle(s.value).zIndex);
    });
    const I = E(() => {
      var P;
      return ((P = $.value.arrow) == null ? void 0 : P.x) ?? 0;
    }), T = E(() => {
      var P;
      return ((P = $.value.arrow) == null ? void 0 : P.y) ?? 0;
    });
    return s$({
      placedSide: D,
      onArrowChange: (P) => u.value = P,
      arrowX: I,
      arrowY: T,
      shouldHideArrow: k
    }), (P, q) => {
      var R, Q, ee;
      return g(), U("div", {
        ref_key: "floatingRef",
        ref: i,
        "data-radix-popper-content-wrapper": "",
        style: vt({
          ...l(_),
          transform: l(S) ? l(_).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: M.value,
          "--radix-popper-transform-origin": [
            (R = l($).transformOrigin) == null ? void 0 : R.x,
            (Q = l($).transformOrigin) == null ? void 0 : Q.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((ee = l($).hide) == null ? void 0 : ee.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [
        N(l(Se), A({ ref: l(r) }, P.$attrs, {
          "as-child": n.asChild,
          as: P.as,
          "data-side": D.value,
          "data-align": B.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: l(S) ? void 0 : "none"
          }
        }), {
          default: y(() => [
            w(P.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
}), zs = /* @__PURE__ */ b({
  __name: "VisuallyHidden",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    return fe(), (t, n) => (g(), C(l(Se), {
      as: t.as,
      "as-child": t.asChild,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: "1px",
        display: "inline-block",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }
    }, {
      default: y(() => [
        w(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), l$ = /* @__PURE__ */ b({
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {},
    required: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(e) {
    const t = e, n = E(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" ? [{ name: t.name, value: t.value }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((a, o) => typeof a == "object" ? Object.entries(a).map(([r, s]) => ({ name: `[${o}][${t.name}][${r}]`, value: s })) : { name: `[${t.name}][${o}]`, value: a }) : t.value !== null && typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([a, o]) => ({ name: `[${t.name}][${a}]`, value: o })) : []);
    return (a, o) => (g(!0), U(Fe, null, $t(n.value, (r) => (g(), C(zs, {
      key: r.name,
      as: "input",
      type: "hidden",
      hidden: "",
      readonly: "",
      name: r.name,
      value: r.value,
      required: a.required,
      disabled: a.disabled
    }, null, 8, ["name", "value", "required", "disabled"]))), 128));
  }
}), i$ = "data-radix-vue-collection-item", [Tf, u$] = Ye("CollectionProvider");
function Af(e = i$) {
  const t = O(/* @__PURE__ */ new Map()), n = O(), a = u$({
    collectionRef: n,
    itemMap: t,
    attrName: e
  }), { getItems: o } = Rf(a), r = E(() => Array.from(a.itemMap.value.values())), s = E(() => a.itemMap.value.size);
  return { getItems: o, reactiveItems: r, itemMapSize: s };
}
const If = b({
  name: "CollectionSlot",
  setup(e, { slots: t }) {
    const n = Tf(), { primitiveElement: a, currentElement: o } = hy();
    return ce(o, () => {
      n.collectionRef.value = o.value;
    }), () => Bt(Cf, { ref: a }, t);
  }
}), lu = b({
  name: "CollectionItem",
  inheritAttrs: !1,
  props: {
    value: {
      // It accepts any value
      validator: () => !0
    }
  },
  setup(e, { slots: t, attrs: n }) {
    const a = Tf(), { primitiveElement: o, currentElement: r } = hy();
    return Me((s) => {
      if (r.value) {
        const i = fg(r.value);
        a.itemMap.value.set(i, { ref: r.value, value: e.value }), s(() => a.itemMap.value.delete(i));
      }
    }), () => Bt(Cf, { ...n, [a.attrName]: "", ref: o }, t);
  }
});
function Rf(e) {
  const t = e ?? Tf();
  return { getItems: () => {
    const n = t.collectionRef.value;
    if (!n)
      return [];
    const a = Array.from(n.querySelectorAll(`[${t.attrName}]`));
    return Array.from(t.itemMap.value.values()).sort(
      (o, r) => a.indexOf(o.ref) - a.indexOf(r.ref)
    );
  } };
}
const [Br, d$] = Ye("ComboboxRoot"), c$ = /* @__PURE__ */ b({
  __name: "ComboboxRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    searchTerm: {},
    selectedValue: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    name: {},
    dir: {},
    filterFunction: {},
    displayValue: {},
    resetSearchTermOnBlur: { type: Boolean, default: !0 },
    resetSearchTermOnSelect: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:open", "update:searchTerm", "update:selectedValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { multiple: o, disabled: r, dir: s } = Be(n), i = to(s), u = pt(n, "searchTerm", a, {
      // @ts-expect-error ignore the type error here
      defaultValue: "",
      passive: n.searchTerm === void 0
    }), d = pt(n, "modelValue", a, {
      // @ts-expect-error ignore the type error here
      defaultValue: n.defaultValue ?? o.value ? [] : void 0,
      passive: n.modelValue === void 0,
      deep: !0
    }), c = pt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), f = pt(n, "selectedValue", a, {
      defaultValue: void 0,
      passive: n.selectedValue === void 0
    });
    async function p(z) {
      var Y, Z;
      c.value = z, await he(), z ? (d.value && (Array.isArray(d.value) && o.value ? f.value = (Y = $().find((pe) => {
        var $e, Ce;
        return ((Ce = ($e = pe.ref) == null ? void 0 : $e.dataset) == null ? void 0 : Ce.state) === "checked";
      })) == null ? void 0 : Y.value : f.value = d.value), await he(), (Z = h.value) == null || Z.focus(), Q()) : (m.value = !1, n.resetSearchTermOnBlur && I("blur"));
    }
    function v(z) {
      if (Array.isArray(d.value) && o.value) {
        const Y = d.value.findIndex((pe) => co(pe, z)), Z = [...d.value];
        Y === -1 ? Z.push(z) : Z.splice(Y, 1), d.value = Z;
      } else
        d.value = z, p(!1);
    }
    const m = O(!1), h = O(), _ = O(), { forwardRef: x, currentElement: S } = fe(), { getItems: $, reactiveItems: D, itemMapSize: B } = Af("data-radix-vue-combobox-item"), k = O([]);
    ce(() => B.value, () => {
      k.value = $().map((z) => z.value);
    }, {
      immediate: !0,
      flush: "post"
    });
    const M = E(() => {
      if (m.value) {
        if (n.filterFunction)
          return n.filterFunction(k.value, u.value);
        const z = k.value.filter((Y) => typeof Y == "string");
        if (z.length)
          return z.filter((Y) => {
            var Z;
            return Y.toLowerCase().includes((Z = u.value) == null ? void 0 : Z.toLowerCase());
          });
      }
      return k.value;
    });
    function I(z) {
      const Y = z === "blur" || z === "select" && n.resetSearchTermOnSelect;
      !o.value && d.value && !Array.isArray(d.value) ? n.displayValue ? u.value = n.displayValue(d.value) : typeof d.value != "object" ? u.value = d.value.toString() : Y && (u.value = "") : Y && (u.value = "");
    }
    const T = E(() => M.value.findIndex((z) => co(z, f.value))), P = E(() => {
      var z;
      return (z = D.value.find((Y) => co(Y.value, f.value))) == null ? void 0 : z.ref;
    }), q = E(() => JSON.stringify(d.value));
    ce(q, async () => {
      await he(), await he(), I("select");
    }, {
      // If searchTerm is provided with value during initialization, we don't reset it immediately
      immediate: !n.searchTerm
    }), ce(() => [M.value.length, u.value.length], async ([z, Y], [Z, pe]) => {
      await he(), await he(), z && (pe > Y || T.value === -1) && (f.value = M.value[0]);
    });
    const R = nu(S);
    function Q() {
      var z;
      P.value instanceof Element && ((z = P.value) == null || z.scrollIntoView({ block: "nearest" }));
    }
    function ee() {
      P.value instanceof Element && P.value.focus && P.value.focus();
    }
    const K = O(!1);
    function W() {
      K.value = !0;
    }
    function j() {
      requestAnimationFrame(() => {
        K.value = !1;
      });
    }
    async function J(z) {
      var Y;
      M.value.length && f.value && P.value instanceof Element && (z.preventDefault(), z.stopPropagation(), K.value || (Y = P.value) == null || Y.click());
    }
    return d$({
      searchTerm: u,
      modelValue: d,
      // @ts-expect-error ignoring
      onValueChange: v,
      isUserInputted: m,
      multiple: o,
      disabled: r,
      open: c,
      onOpenChange: p,
      filteredOptions: M,
      contentId: "",
      inputElement: h,
      selectedElement: P,
      onInputElementChange: (z) => h.value = z,
      onInputNavigation: async (z) => {
        const Y = T.value;
        Y === 0 && z === "up" || Y === M.value.length - 1 && z === "down" || (Y === -1 && M.value.length || z === "home" ? f.value = M.value[0] : z === "end" ? f.value = M.value[M.value.length - 1] : f.value = M.value[z === "up" ? Y - 1 : Y + 1], await he(), Q(), ee(), he(() => {
          var Z;
          return (Z = h.value) == null ? void 0 : Z.focus({ preventScroll: !0 });
        }));
      },
      onInputEnter: J,
      onCompositionEnd: j,
      onCompositionStart: W,
      selectedValue: f,
      onSelectedValueChange: (z) => f.value = z,
      parentElement: S,
      contentElement: _,
      onContentElementChange: (z) => _.value = z
    }), (z, Y) => (g(), C(l($r), null, {
      default: y(() => [
        N(l(Se), A({
          ref: l(x),
          style: {
            pointerEvents: l(c) ? "auto" : void 0
          },
          as: z.as,
          "as-child": z.asChild,
          dir: l(i)
        }, z.$attrs), {
          default: y(() => [
            w(z.$slots, "default", {
              open: l(c),
              modelValue: l(d)
            }),
            l(R) && n.name ? (g(), C(l(l$), {
              key: 0,
              name: n.name,
              value: l(d)
            }, null, 8, ["name", "value"])) : Pe("", !0)
          ]),
          _: 3
        }, 16, ["style", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
}), f$ = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    type: { default: "text" },
    disabled: { type: Boolean },
    autoFocus: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(e) {
    const t = e, n = Br(), { forwardRef: a, currentElement: o } = fe();
    be(() => {
      const c = o.value.nodeName === "INPUT" ? o.value : o.value.querySelector("input");
      c && (n.onInputElementChange(c), setTimeout(() => {
        t.autoFocus && (c == null || c.focus());
      }, 1));
    });
    const r = E(() => t.disabled || n.disabled.value || !1), s = O();
    ug(() => {
      var c;
      return s.value = (c = n.selectedElement.value) == null ? void 0 : c.id;
    });
    function i(c) {
      n.open.value ? n.onInputNavigation(c.key === "ArrowUp" ? "up" : "down") : n.onOpenChange(!0);
    }
    function u(c) {
      n.open.value && n.onInputNavigation(c.key === "Home" ? "home" : "end");
    }
    function d(c) {
      var f;
      n.searchTerm.value = (f = c.target) == null ? void 0 : f.value, n.open.value || n.onOpenChange(!0), n.isUserInputted.value = !0;
    }
    return (c, f) => (g(), C(l(Se), {
      ref: l(a),
      as: c.as,
      "as-child": c.asChild,
      type: c.type,
      disabled: r.value,
      value: l(n).searchTerm.value,
      "aria-expanded": l(n).open.value,
      "aria-controls": l(n).contentId,
      "aria-disabled": r.value ?? void 0,
      "aria-activedescendant": s.value,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "false",
      onInput: d,
      onKeydown: [
        Qe(We(i, ["prevent"]), ["down", "up"]),
        Qe(l(n).onInputEnter, ["enter"]),
        Qe(We(u, ["prevent"]), ["home", "end"])
      ],
      onCompositionstart: l(n).onCompositionStart,
      onCompositionend: l(n).onCompositionEnd
    }, {
      default: y(() => [
        w(c.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "type", "disabled", "value", "aria-expanded", "aria-controls", "aria-disabled", "aria-activedescendant", "onKeydown", "onCompositionstart", "onCompositionend"]));
  }
}), [$y, p$] = Ye("ComboboxGroup"), v$ = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { currentRef: n, currentElement: a } = fe(), o = Ot(void 0, "radix-vue-combobox-group"), r = Br(), s = O(!1);
    function i() {
      if (!a.value)
        return;
      const u = a.value.querySelectorAll("[data-radix-vue-combobox-item]:not([data-hidden])");
      s.value = !!u.length;
    }
    return DC(a, () => {
      he(() => {
        i();
      });
    }, { childList: !0 }), ce(() => r.searchTerm.value, () => {
      he(() => {
        i();
      });
    }, { immediate: !0 }), p$({
      id: o
    }), (u, d) => br((g(), C(l(Se), A(t, {
      ref_key: "currentRef",
      ref: n,
      role: "group",
      "aria-labelledby": l(o)
    }), {
      default: y(() => [
        w(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"])), [
      [Xc, s.value]
    ]);
  }
}), m$ = /* @__PURE__ */ b({
  __name: "ComboboxLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    fe();
    const n = $y({ id: "" });
    return (a, o) => (g(), C(l(Se), A(t, {
      id: l(n).id
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), [IU, h$] = Ye("ComboboxContent"), g$ = /* @__PURE__ */ b({
  __name: "ComboboxContentImpl",
  props: {
    position: { default: "inline" },
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean, default: !0 },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, { position: o } = Be(n), r = Br();
    Vs(n.bodyLock);
    const { forwardRef: s, currentElement: i } = fe();
    Ns(r.parentElement);
    const u = E(() => n.position === "popper" ? n : {}), d = Rt(u.value);
    function c(p) {
      r.onSelectedValueChange("");
    }
    be(() => {
      r.onContentElementChange(i.value);
    });
    const f = {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
      "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
      "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
    };
    return h$({ position: o }), (p, v) => (g(), C(l(If), null, {
      default: y(() => [
        p.dismissable ? (g(), C(l(Sr), {
          key: 0,
          "as-child": "",
          "disable-outside-pointer-events": p.disableOutsidePointerEvents,
          onDismiss: v[0] || (v[0] = (m) => l(r).onOpenChange(!1)),
          onFocusOutside: v[1] || (v[1] = (m) => {
            var h;
            (h = l(r).parentElement.value) != null && h.contains(m.target) && m.preventDefault(), a("focusOutside", m);
          }),
          onInteractOutside: v[2] || (v[2] = (m) => a("interactOutside", m)),
          onEscapeKeyDown: v[3] || (v[3] = (m) => a("escapeKeyDown", m)),
          onPointerDownOutside: v[4] || (v[4] = (m) => {
            var h;
            (h = l(r).parentElement.value) != null && h.contains(m.target) && m.preventDefault(), a("pointerDownOutside", m);
          })
        }, {
          default: y(() => [
            (g(), C(mt(l(o) === "popper" ? l(cr) : l(Se)), A({ ...p.$attrs, ...l(d) }, {
              id: l(r).contentId,
              ref: l(s),
              role: "listbox",
              "data-state": l(r).open.value ? "open" : "closed",
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none",
                ...l(o) === "popper" ? f : {}
              },
              onPointerleave: c
            }), {
              default: y(() => [
                w(p.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"]))
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])) : (g(), C(mt(l(o) === "popper" ? l(cr) : l(Se)), A({ key: 1 }, { ...p.$attrs, ...u.value }, {
          id: l(r).contentId,
          ref: l(s),
          role: "listbox",
          "data-state": l(r).open.value ? "open" : "closed",
          style: {
            // flex layout so we can place the scroll buttons properly
            display: "flex",
            flexDirection: "column",
            // reset the outline by default as the content MAY get focused
            outline: "none",
            ...l(o) === "popper" ? f : {}
          },
          onPointerleave: c
        }), {
          default: y(() => [
            w(p.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "data-state", "style"]))
      ]),
      _: 3
    }));
  }
}), y$ = /* @__PURE__ */ b({
  __name: "ComboboxContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = Le(e, t), { forwardRef: a } = fe(), o = Br();
    return o.contentId || (o.contentId = Ot(void 0, "radix-vue-combobox-content")), (r, s) => (g(), C(l(On), {
      present: r.forceMount || l(o).open.value
    }, {
      default: y(() => [
        N(g$, A({ ...l(n), ...r.$attrs }, { ref: l(a) }), {
          default: y(() => [
            w(r.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), b$ = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    fe();
    const n = Br(), a = E(() => n.filteredOptions.value.length === 0);
    return (o, r) => a.value ? (g(), C(l(Se), ne(A({ key: 0 }, t)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          Re("No options")
        ])
      ]),
      _: 3
    }, 16)) : Pe("", !0);
  }
});
function _$(e) {
  const t = tu({
    nonce: O()
  });
  return E(() => {
    var n;
    return (e == null ? void 0 : e.value) || ((n = t.nonce) == null ? void 0 : n.value);
  });
}
const [RU, w$] = Ye("ComboboxItem"), x$ = "combobox.select", C$ = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: o } = Be(n), r = Br();
    $y({ id: "", options: O([]) });
    const { forwardRef: s } = fe(), i = E(
      () => {
        var h, _;
        return r.multiple.value && Array.isArray(r.modelValue.value) ? (h = r.modelValue.value) == null ? void 0 : h.some((x) => co(x, n.value)) : co((_ = r.modelValue) == null ? void 0 : _.value, n.value);
      }
    ), u = E(() => co(r.selectedValue.value, n.value)), d = Ot(void 0, "radix-vue-combobox-item"), c = Ot(void 0, "radix-vue-combobox-option"), f = E(() => r.isUserInputted.value ? r.searchTerm.value === "" || !!r.filteredOptions.value.find((h) => co(h, n.value)) : !0);
    async function p(h) {
      a("select", h), !(h != null && h.defaultPrevented) && !o.value && h && r.onValueChange(n.value);
    }
    function v(h) {
      if (!h)
        return;
      const _ = { originalEvent: h, value: n.value };
      gf(x$, p, _);
    }
    async function m(h) {
      await he(), !h.defaultPrevented && r.onSelectedValueChange(n.value);
    }
    if (n.value === "")
      throw new Error(
        "A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder."
      );
    return w$({
      isSelected: i
    }), (h, _) => (g(), C(l(lu), { value: h.value }, {
      default: y(() => [
        br(N(l(Se), {
          id: l(c),
          ref: l(s),
          role: "option",
          tabindex: "-1",
          "aria-labelledby": l(d),
          "data-highlighted": u.value ? "" : void 0,
          "aria-selected": i.value,
          "data-state": i.value ? "checked" : "unchecked",
          "aria-disabled": l(o) || void 0,
          "data-disabled": l(o) ? "" : void 0,
          as: h.as,
          "as-child": h.asChild,
          "data-hidden": f.value ? void 0 : !0,
          onClick: v,
          onPointermove: m
        }, {
          default: y(() => [
            w(h.$slots, "default", {}, () => [
              Re(Ve(h.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["id", "aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "as", "as-child", "data-hidden"]), [
          [Xc, f.value]
        ])
      ]),
      _: 3
    }, 8, ["value"]));
  }
}), S$ = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(Se), A(t, { "aria-hidden": "true" }), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), By = /* @__PURE__ */ b({
  __name: "MenuAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Ls), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function $$() {
  const e = O(!1);
  return be(() => {
    dr("keydown", () => {
      e.value = !0;
    }, { capture: !0, passive: !0 }), dr(["pointerdown", "pointermove"], () => {
      e.value = !1;
    }, { capture: !0, passive: !0 });
  }), e;
}
const B$ = ly($$), [Po, Py] = Ye(["MenuRoot", "MenuSub"], "MenuContext"), [Hs, P$] = Ye("MenuRoot"), E$ = /* @__PURE__ */ b({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: !1 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: o, dir: r } = Be(n), s = to(r), i = pt(n, "open", a), u = O(), d = B$();
    return Py({
      open: i,
      onOpenChange: (c) => {
        i.value = c;
      },
      content: u,
      onContentChange: (c) => {
        u.value = c;
      }
    }), P$({
      onClose: () => {
        i.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: s,
      modal: o
    }), (c, f) => (g(), C(l($r), null, {
      default: y(() => [
        w(c.$slots, "default")
      ]),
      _: 3
    }));
  }
}), D$ = "rovingFocusGroup.onEntryFocus", M$ = { bubbles: !1, cancelable: !0 }, k$ = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function O$(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function T$(e, t, n) {
  const a = O$(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return k$[a];
}
function Ey(e, t = !1) {
  const n = It();
  for (const a of e)
    if (a === n || (a.focus({ preventScroll: t }), It() !== n))
      return;
}
function A$(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
const [I$, R$] = Ye("RovingFocusGroup"), Dy = /* @__PURE__ */ b({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !1 },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    preventScrollOnEntryFocus: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { loop: r, orientation: s, dir: i } = Be(a), u = to(i), d = pt(a, "currentTabStopId", o, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), c = O(!1), f = O(!1), p = O(0), { getItems: v } = Af();
    function m(_) {
      const x = !f.value;
      if (_.currentTarget && _.target === _.currentTarget && x && !c.value) {
        const S = new CustomEvent(D$, M$);
        if (_.currentTarget.dispatchEvent(S), o("entryFocus", S), !S.defaultPrevented) {
          const $ = v().map((M) => M.ref).filter((M) => M.dataset.disabled !== ""), D = $.find((M) => M.getAttribute("data-active") === "true"), B = $.find(
            (M) => M.id === d.value
          ), k = [D, B, ...$].filter(
            Boolean
          );
          Ey(k, a.preventScrollOnEntryFocus);
        }
      }
      f.value = !1;
    }
    function h() {
      setTimeout(() => {
        f.value = !1;
      }, 1);
    }
    return t({
      getItems: v
    }), R$({
      loop: r,
      dir: u,
      orientation: s,
      currentTabStopId: d,
      onItemFocus: (_) => {
        d.value = _;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        p.value++;
      },
      onFocusableItemRemove: () => {
        p.value--;
      }
    }), (_, x) => (g(), C(l(If), null, {
      default: y(() => [
        N(l(Se), {
          tabindex: c.value || p.value === 0 ? -1 : 0,
          "data-orientation": l(s),
          as: _.as,
          "as-child": _.asChild,
          dir: l(u),
          style: { outline: "none" },
          onMousedown: x[0] || (x[0] = (S) => f.value = !0),
          onMouseup: h,
          onFocus: m,
          onBlur: x[1] || (x[1] = (S) => c.value = !1)
        }, {
          default: y(() => [
            w(_.$slots, "default")
          ]),
          _: 3
        }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
}), q$ = /* @__PURE__ */ b({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: !0 },
    active: { type: Boolean, default: !0 },
    allowShiftKey: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, n = I$(), a = E(() => t.tabStopId || Ot()), o = E(
      () => n.currentTabStopId.value === a.value
    ), { getItems: r } = Rf();
    be(() => {
      t.focusable && n.onFocusableItemAdd();
    }), Ze(() => {
      t.focusable && n.onFocusableItemRemove();
    });
    function s(i) {
      if (i.key === "Tab" && i.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (i.target !== i.currentTarget)
        return;
      const u = T$(
        i,
        n.orientation.value,
        n.dir.value
      );
      if (u !== void 0) {
        if (i.metaKey || i.ctrlKey || i.altKey || !t.allowShiftKey && i.shiftKey)
          return;
        i.preventDefault();
        let d = [...r().map((c) => c.ref).filter((c) => c.dataset.disabled !== "")];
        if (u === "last")
          d.reverse();
        else if (u === "prev" || u === "next") {
          u === "prev" && d.reverse();
          const c = d.indexOf(
            i.currentTarget
          );
          d = n.loop.value ? A$(d, c + 1) : d.slice(c + 1);
        }
        he(() => Ey(d));
      }
    }
    return (i, u) => (g(), C(l(lu), null, {
      default: y(() => [
        N(l(Se), {
          tabindex: o.value ? 0 : -1,
          "data-orientation": l(n).orientation.value,
          "data-active": i.active,
          "data-disabled": i.focusable ? void 0 : "",
          as: i.as,
          "as-child": i.asChild,
          onMousedown: u[0] || (u[0] = (d) => {
            i.focusable ? l(n).onItemFocus(a.value) : d.preventDefault();
          }),
          onFocus: u[1] || (u[1] = (d) => l(n).onItemFocus(a.value)),
          onKeydown: s
        }, {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), [qf, F$] = Ye("MenuContent"), Ff = /* @__PURE__ */ b({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ ji({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...Sy
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus", "dismiss"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Po(), r = Hs(), { trapFocus: s, disableOutsidePointerEvents: i, loop: u } = Be(n);
    wf(), Vs(i.value);
    const d = O(""), c = O(0), f = O(0), p = O(null), v = O("right"), m = O(0), h = O(null), { createCollection: _ } = xr(), { forwardRef: x, currentElement: S } = fe(), $ = _(S);
    ce(S, (P) => {
      o.onContentChange(P);
    });
    const { handleTypeaheadSearch: D } = xf($);
    Ze(() => {
      window.clearTimeout(c.value);
    });
    function B(P) {
      var q, R;
      return v.value === ((q = p.value) == null ? void 0 : q.side) && AS(P, (R = p.value) == null ? void 0 : R.area);
    }
    async function k(P) {
      var q;
      a("openAutoFocus", P), !P.defaultPrevented && (P.preventDefault(), (q = S.value) == null || q.focus({
        preventScroll: !0
      }));
    }
    function M(P) {
      if (P.defaultPrevented)
        return;
      const q = P.target.closest("[data-radix-menu-content]") === P.currentTarget, R = P.ctrlKey || P.altKey || P.metaKey, Q = P.key.length === 1, ee = cy(
        P,
        It(),
        S.value,
        {
          loop: u.value,
          arrowKeyOptions: "vertical",
          dir: r == null ? void 0 : r.dir.value,
          focus: !0,
          attributeName: "[data-radix-vue-collection-item]:not([data-disabled])"
        }
      );
      if (ee)
        return ee == null ? void 0 : ee.focus();
      if (P.code === "Space" || (q && (P.key === "Tab" && P.preventDefault(), !R && Q && D(P.key)), P.target !== S.value) || !MS.includes(P.key))
        return;
      P.preventDefault();
      const K = $.value;
      _y.includes(P.key) && K.reverse(), rc(K);
    }
    function I(P) {
      var q, R;
      (R = (q = P == null ? void 0 : P.currentTarget) == null ? void 0 : q.contains) != null && R.call(q, P.target) || (window.clearTimeout(c.value), d.value = "");
    }
    function T(P) {
      var q;
      if (!hs(P))
        return;
      const R = P.target, Q = m.value !== P.clientX;
      if ((q = P == null ? void 0 : P.currentTarget) != null && q.contains(R) && Q) {
        const ee = P.clientX > m.value ? "right" : "left";
        v.value = ee, m.value = P.clientX;
      }
    }
    return F$({
      onItemEnter: (P) => !!B(P),
      onItemLeave: (P) => {
        var q;
        B(P) || ((q = S.value) == null || q.focus(), h.value = null);
      },
      onTriggerLeave: (P) => !!B(P),
      searchRef: d,
      pointerGraceTimerRef: f,
      onPointerGraceIntentChange: (P) => {
        p.value = P;
      }
    }), (P, q) => (g(), C(l(ou), {
      "as-child": "",
      trapped: l(s),
      onMountAutoFocus: k,
      onUnmountAutoFocus: q[7] || (q[7] = (R) => a("closeAutoFocus", R))
    }, {
      default: y(() => [
        N(l(Sr), {
          "as-child": "",
          "disable-outside-pointer-events": l(i),
          onEscapeKeyDown: q[2] || (q[2] = (R) => a("escapeKeyDown", R)),
          onPointerDownOutside: q[3] || (q[3] = (R) => a("pointerDownOutside", R)),
          onFocusOutside: q[4] || (q[4] = (R) => a("focusOutside", R)),
          onInteractOutside: q[5] || (q[5] = (R) => a("interactOutside", R)),
          onDismiss: q[6] || (q[6] = (R) => a("dismiss"))
        }, {
          default: y(() => [
            N(l(Dy), {
              "current-tab-stop-id": h.value,
              "onUpdate:currentTabStopId": q[0] || (q[0] = (R) => h.value = R),
              "as-child": "",
              orientation: "vertical",
              dir: l(r).dir.value,
              loop: l(u),
              onEntryFocus: q[1] || (q[1] = (R) => {
                a("entryFocus", R), l(r).isUsingKeyboardRef.value || R.preventDefault();
              })
            }, {
              default: y(() => [
                N(l(cr), {
                  ref: l(x),
                  role: "menu",
                  as: P.as,
                  "as-child": P.asChild,
                  "aria-orientation": "vertical",
                  "data-radix-menu-content": "",
                  "data-state": l(Df)(l(o).open.value),
                  dir: l(r).dir.value,
                  side: P.side,
                  "side-offset": P.sideOffset,
                  align: P.align,
                  "align-offset": P.alignOffset,
                  "avoid-collisions": P.avoidCollisions,
                  "collision-boundary": P.collisionBoundary,
                  "collision-padding": P.collisionPadding,
                  "arrow-padding": P.arrowPadding,
                  "prioritize-position": P.prioritizePosition,
                  sticky: P.sticky,
                  "hide-when-detached": P.hideWhenDetached,
                  onKeydown: M,
                  onBlur: I,
                  onPointermove: T
                }, {
                  default: y(() => [
                    w(P.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "prioritize-position", "sticky", "hide-when-detached"])
              ]),
              _: 3
            }, 8, ["current-tab-stop-id", "dir", "loop"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), My = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = qf(), { forwardRef: a } = fe(), o = O(!1);
    async function r(i) {
      if (!i.defaultPrevented && hs(i)) {
        if (t.disabled)
          n.onItemLeave(i);
        else if (!n.onItemEnter(i)) {
          const u = i.currentTarget;
          u == null || u.focus({ preventScroll: !0 });
        }
      }
    }
    async function s(i) {
      await he(), !i.defaultPrevented && hs(i) && n.onItemLeave(i);
    }
    return (i, u) => (g(), C(l(lu), {
      value: { textValue: i.textValue }
    }, {
      default: y(() => [
        N(l(Se), A({
          ref: l(a),
          role: "menuitem",
          tabindex: "-1"
        }, i.$attrs, {
          as: i.as,
          "as-child": i.asChild,
          "data-radix-vue-collection-item": "",
          "aria-disabled": i.disabled || void 0,
          "data-disabled": i.disabled ? "" : void 0,
          "data-highlighted": o.value ? "" : void 0,
          onPointermove: r,
          onPointerleave: s,
          onFocus: u[0] || (u[0] = async (d) => {
            await he(), !(d.defaultPrevented || i.disabled) && (o.value = !0);
          }),
          onBlur: u[1] || (u[1] = async (d) => {
            await he(), !d.defaultPrevented && (o.value = !1);
          })
        }), {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"])
      ]),
      _: 3
    }, 8, ["value"]));
  }
}), Vf = /* @__PURE__ */ b({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = fe(), s = Hs(), i = qf(), u = O(!1);
    async function d() {
      const c = r.value;
      if (!n.disabled && c) {
        const f = new CustomEvent(ES, {
          bubbles: !0,
          cancelable: !0
        });
        a("select", f), await he(), f.defaultPrevented ? u.value = !1 : s.onClose();
      }
    }
    return (c, f) => (g(), C(My, A(n, {
      ref: l(o),
      onClick: d,
      onPointerdown: f[0] || (f[0] = () => {
        u.value = !0;
      }),
      onPointerup: f[1] || (f[1] = async (p) => {
        var v;
        await he(), !p.defaultPrevented && (u.value || (v = p.currentTarget) == null || v.click());
      }),
      onKeydown: f[2] || (f[2] = async (p) => {
        const v = l(i).searchRef.value !== "";
        c.disabled || v && p.key === " " || l(oc).includes(p.key) && (p.currentTarget.click(), p.preventDefault());
      })
    }), {
      default: y(() => [
        w(c.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [V$, ky] = Ye(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
), N$ = /* @__PURE__ */ b({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = V$({
      checked: O(!1)
    });
    return (n, a) => (g(), C(l(On), {
      present: n.forceMount || l(ci)(l(t).checked.value) || l(t).checked.value === !0
    }, {
      default: y(() => [
        N(l(Se), {
          as: n.as,
          "as-child": n.asChild,
          "data-state": l(Mf)(l(t).checked.value)
        }, {
          default: y(() => [
            w(n.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), L$ = /* @__PURE__ */ b({
  __name: "MenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String], default: !1 },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = pt(n, "checked", a);
    return ky({ checked: o }), (r, s) => (g(), C(Vf, A({ role: "menuitemcheckbox" }, n, {
      "aria-checked": l(ci)(l(o)) ? "mixed" : l(o),
      "data-state": l(Mf)(l(o)),
      onSelect: s[0] || (s[0] = async (i) => {
        a("select", i), l(ci)(l(o)) ? o.value = !0 : o.value = !l(o);
      })
    }), {
      default: y(() => [
        w(r.$slots, "default", { checked: l(o) })
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), z$ = /* @__PURE__ */ b({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Le(n, a), r = Po(), { forwardRef: s, currentElement: i } = fe();
    return Ns(i), (u, d) => (g(), C(Ff, A(l(o), {
      ref: l(s),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": l(r).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (c) => l(r).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = We((c) => a("focusOutside", c), ["prevent"]))
    }), {
      default: y(() => [
        w(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), H$ = /* @__PURE__ */ b({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = Le(e, t), a = Po();
    return (o, r) => (g(), C(Ff, A(l(n), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: r[0] || (r[0] = (s) => l(a).onOpenChange(!1))
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), U$ = /* @__PURE__ */ b({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = Le(e, t), a = Po(), o = Hs();
    return (r, s) => (g(), C(l(On), {
      present: r.forceMount || l(a).open.value
    }, {
      default: y(() => [
        l(o).modal.value ? (g(), C(z$, ne(A({ key: 0 }, { ...r.$attrs, ...l(n) })), {
          default: y(() => [
            w(r.$slots, "default")
          ]),
          _: 3
        }, 16)) : (g(), C(H$, ne(A({ key: 1 }, { ...r.$attrs, ...l(n) })), {
          default: y(() => [
            w(r.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Oy = /* @__PURE__ */ b({
  __name: "MenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), A({ role: "group" }, t), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), j$ = /* @__PURE__ */ b({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), W$ = /* @__PURE__ */ b({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Cr), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [K$, G$] = Ye("MenuRadioGroup"), Y$ = /* @__PURE__ */ b({
  __name: "MenuRadioGroup",
  props: {
    modelValue: { default: "" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = pt(n, "modelValue", t);
    return G$({
      modelValue: a,
      onValueChange: (o) => {
        a.value = o;
      }
    }), (o, r) => (g(), C(Oy, ne(oe(n)), {
      default: y(() => [
        w(o.$slots, "default", { modelValue: l(a) })
      ]),
      _: 3
    }, 16));
  }
}), X$ = /* @__PURE__ */ b({
  __name: "MenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { value: o } = Be(n), r = K$(), s = E(
      () => r.modelValue.value === (o == null ? void 0 : o.value)
    );
    return ky({ checked: s }), (i, u) => (g(), C(Vf, A({ role: "menuitemradio" }, n, {
      "aria-checked": s.value,
      "data-state": l(Mf)(s.value),
      onSelect: u[0] || (u[0] = async (d) => {
        a("select", d), l(r).onValueChange(l(o));
      })
    }), {
      default: y(() => [
        w(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), J$ = /* @__PURE__ */ b({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), A(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Ty, Z$] = Ye("MenuSub"), Q$ = /* @__PURE__ */ b({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = pt(n, "open", t, {
      defaultValue: !1,
      passive: n.open === void 0
    }), o = Po(), r = O(), s = O();
    return Me((i) => {
      (o == null ? void 0 : o.open.value) === !1 && (a.value = !1), i(() => a.value = !1);
    }), Py({
      open: a,
      onOpenChange: (i) => {
        a.value = i;
      },
      content: s,
      onContentChange: (i) => {
        s.value = i;
      }
    }), Z$({
      triggerId: "",
      contentId: "",
      trigger: r,
      onTriggerChange: (i) => {
        r.value = i;
      }
    }), (i, u) => (g(), C(l($r), null, {
      default: y(() => [
        w(i.$slots, "default")
      ]),
      _: 3
    }));
  }
}), eB = /* @__PURE__ */ b({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = Le(e, t), a = Po(), o = Hs(), r = Ty(), { forwardRef: s, currentElement: i } = fe();
    return r.contentId || (r.contentId = Ot(void 0, "radix-vue-menu-sub-content")), (u, d) => (g(), C(l(On), {
      present: u.forceMount || l(a).open.value
    }, {
      default: y(() => [
        N(Ff, A(l(n), {
          id: l(r).contentId,
          ref: l(s),
          "aria-labelledby": l(r).triggerId,
          align: "start",
          side: l(o).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": !1,
          "disable-outside-scroll": !1,
          "trap-focus": !1,
          onOpenAutoFocus: d[0] || (d[0] = We((c) => {
            var f;
            l(o).isUsingKeyboardRef.value && ((f = l(i)) == null || f.focus());
          }, ["prevent"])),
          onCloseAutoFocus: d[1] || (d[1] = We(() => {
          }, ["prevent"])),
          onFocusOutside: d[2] || (d[2] = (c) => {
            c.defaultPrevented || c.target !== l(r).trigger.value && l(a).onOpenChange(!1);
          }),
          onEscapeKeyDown: d[3] || (d[3] = (c) => {
            l(o).onClose(), c.preventDefault();
          }),
          onKeydown: d[4] || (d[4] = (c) => {
            var f, p;
            const v = (f = c.currentTarget) == null ? void 0 : f.contains(c.target), m = l(OS)[l(o).dir.value].includes(c.key);
            v && m && (l(a).onOpenChange(!1), (p = l(r).trigger.value) == null || p.focus(), c.preventDefault());
          })
        }), {
          default: y(() => [
            w(u.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-labelledby", "side"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), tB = /* @__PURE__ */ b({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = Po(), a = Hs(), o = Ty(), r = qf(), s = O(null);
    o.triggerId || (o.triggerId = Ot(void 0, "radix-vue-menu-sub-trigger"));
    function i() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    Ze(() => {
      i();
    });
    function u(f) {
      !hs(f) || r.onItemEnter(f) || !t.disabled && !n.open.value && !s.value && (r.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), i();
      }, 100));
    }
    async function d(f) {
      var p, v;
      if (!hs(f))
        return;
      i();
      const m = (p = n.content.value) == null ? void 0 : p.getBoundingClientRect();
      if (m != null && m.width) {
        const h = (v = n.content.value) == null ? void 0 : v.dataset.side, _ = h === "right", x = _ ? -5 : 5, S = m[_ ? "left" : "right"], $ = m[_ ? "right" : "left"];
        r.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: f.clientX + x, y: f.clientY },
            { x: S, y: m.top },
            { x: $, y: m.top },
            { x: $, y: m.bottom },
            { x: S, y: m.bottom }
          ],
          side: h
        }), window.clearTimeout(r.pointerGraceTimerRef.value), r.pointerGraceTimerRef.value = window.setTimeout(
          () => r.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (r.onTriggerLeave(f))
          return;
        r.onPointerGraceIntentChange(null);
      }
    }
    async function c(f) {
      var p;
      const v = r.searchRef.value !== "";
      t.disabled || v && f.key === " " || kS[a.dir.value].includes(f.key) && (n.onOpenChange(!0), await he(), (p = n.content.value) == null || p.focus(), f.preventDefault());
    }
    return (f, p) => (g(), C(By, { "as-child": "" }, {
      default: y(() => [
        N(My, A(t, {
          id: l(o).triggerId,
          ref: (v) => {
            var m;
            (m = l(o)) == null || m.onTriggerChange(v == null ? void 0 : v.$el);
          },
          "aria-haspopup": "menu",
          "aria-expanded": l(n).open.value,
          "aria-controls": l(o).contentId,
          "data-state": l(Df)(l(n).open.value),
          onClick: p[0] || (p[0] = async (v) => {
            t.disabled || v.defaultPrevented || (v.currentTarget.focus(), l(n).open.value || l(n).onOpenChange(!0));
          }),
          onPointermove: u,
          onPointerleave: d,
          onKeydown: c
        }), {
          default: y(() => [
            w(f.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-expanded", "aria-controls", "data-state"])
      ]),
      _: 3
    }));
  }
}), [Ay, nB] = Ye("DropdownMenuRoot"), aB = /* @__PURE__ */ b({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    fe();
    const o = pt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), r = O(), { modal: s, dir: i } = Be(n), u = to(i);
    return nB({
      open: o,
      onOpenChange: (d) => {
        o.value = d;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      triggerId: "",
      triggerElement: r,
      contentId: "",
      modal: s,
      dir: u
    }), (d, c) => (g(), C(l(E$), {
      open: l(o),
      "onUpdate:open": c[0] || (c[0] = (f) => ht(o) ? o.value = f : null),
      dir: l(u),
      modal: l(s)
    }, {
      default: y(() => [
        w(d.$slots, "default", { open: l(o) })
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), oB = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = Ay(), { forwardRef: a, currentElement: o } = fe();
    return be(() => {
      n.triggerElement = o;
    }), n.triggerId || (n.triggerId = Ot(void 0, "radix-vue-dropdown-menu-trigger")), (r, s) => (g(), C(l(By), { "as-child": "" }, {
      default: y(() => [
        N(l(Se), {
          id: l(n).triggerId,
          ref: l(a),
          type: r.as === "button" ? "button" : void 0,
          "as-child": t.asChild,
          as: r.as,
          "aria-haspopup": "menu",
          "aria-expanded": l(n).open.value,
          "aria-controls": l(n).open.value ? l(n).contentId : void 0,
          "data-disabled": r.disabled ? "" : void 0,
          disabled: r.disabled,
          "data-state": l(n).open.value ? "open" : "closed",
          onClick: s[0] || (s[0] = async (i) => {
            var u;
            !r.disabled && i.button === 0 && i.ctrlKey === !1 && ((u = l(n)) == null || u.onOpenToggle(), await he(), l(n).open.value && i.preventDefault());
          }),
          onKeydown: s[1] || (s[1] = Qe(
            (i) => {
              r.disabled || (["Enter", " "].includes(i.key) && l(n).onOpenToggle(), i.key === "ArrowDown" && l(n).onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(i.key) && i.preventDefault());
            },
            ["enter", "space", "arrow-down"]
          ))
        }, {
          default: y(() => [
            w(r.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), rB = /* @__PURE__ */ b({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(W$), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sB = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = Le(e, t);
    fe();
    const a = Ay(), o = O(!1);
    function r(s) {
      s.defaultPrevented || (o.value || setTimeout(() => {
        var i;
        (i = a.triggerElement.value) == null || i.focus();
      }, 0), o.value = !1, s.preventDefault());
    }
    return a.contentId || (a.contentId = Ot(void 0, "radix-vue-dropdown-menu-content")), (s, i) => {
      var u;
      return g(), C(l(U$), A(l(n), {
        id: l(a).contentId,
        "aria-labelledby": (u = l(a)) == null ? void 0 : u.triggerId,
        style: {
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        },
        onCloseAutoFocus: r,
        onInteractOutside: i[0] || (i[0] = (d) => {
          var c;
          if (d.defaultPrevented) return;
          const f = d.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, v = f.button === 2 || p;
          (!l(a).modal.value || v) && (o.value = !0), (c = l(a).triggerElement.value) != null && c.contains(d.target) && d.preventDefault();
        })
      }), {
        default: y(() => [
          w(s.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
}), lB = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = no(t);
    return fe(), (o, r) => (g(), C(l(Vf), ne(oe({ ...n, ...l(a) })), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), iB = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(Oy), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), uB = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(J$), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dB = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(e, { emit: t }) {
    const n = e, a = no(t);
    return fe(), (o, r) => (g(), C(l(L$), ne(oe({ ...n, ...l(a) })), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Iy = /* @__PURE__ */ b({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(N$), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cB = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(j$), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fB = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = no(t);
    return fe(), (o, r) => (g(), C(l(Y$), ne(oe({ ...n, ...l(a) })), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pB = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = Le(e, t);
    return fe(), (a, o) => (g(), C(l(X$), ne(oe(l(n))), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vB = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = pt(n, "open", t, {
      passive: n.open === void 0,
      defaultValue: n.defaultOpen ?? !1
    });
    return fe(), (o, r) => (g(), C(l(Q$), {
      open: l(a),
      "onUpdate:open": r[0] || (r[0] = (s) => ht(a) ? a.value = s : null)
    }, {
      default: y(() => [
        w(o.$slots, "default", { open: l(a) })
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), mB = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = Le(e, t);
    return fe(), (a, o) => (g(), C(l(eB), A(l(n), { style: {
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hB = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(tB), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Pr, gB] = Ye("PopoverRoot"), yB = /* @__PURE__ */ b({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: o } = Be(n), r = pt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = O(), i = O(!1);
    return gB({
      contentId: "",
      modal: o,
      open: r,
      onOpenChange: (u) => {
        r.value = u;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      triggerElement: s,
      hasCustomAnchor: i
    }), (u, d) => (g(), C(l($r), null, {
      default: y(() => [
        w(u.$slots, "default", { open: l(r) })
      ]),
      _: 3
    }));
  }
}), bB = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = Pr(), { forwardRef: a, currentElement: o } = fe();
    return be(() => {
      n.triggerElement.value = o.value;
    }), (r, s) => (g(), C(mt(l(n).hasCustomAnchor.value ? l(Se) : l(Ls)), { "as-child": "" }, {
      default: y(() => [
        N(l(Se), {
          ref: l(a),
          type: r.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": l(n).open.value,
          "aria-controls": l(n).contentId,
          "data-state": l(n).open.value ? "open" : "closed",
          as: r.as,
          "as-child": t.asChild,
          onClick: l(n).onOpenToggle
        }, {
          default: y(() => [
            w(r.$slots, "default")
          ]),
          _: 3
        }, 8, ["type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
      ]),
      _: 3
    }));
  }
}), _B = /* @__PURE__ */ b({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Cr), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ry = /* @__PURE__ */ b({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Rt(n), { forwardRef: r } = fe(), s = Pr();
    return wf(), (i, u) => (g(), C(l(ou), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [
        N(l(Sr), {
          "as-child": "",
          "disable-outside-pointer-events": i.disableOutsidePointerEvents,
          onPointerDownOutside: u[0] || (u[0] = (d) => a("pointerDownOutside", d)),
          onInteractOutside: u[1] || (u[1] = (d) => a("interactOutside", d)),
          onEscapeKeyDown: u[2] || (u[2] = (d) => a("escapeKeyDown", d)),
          onFocusOutside: u[3] || (u[3] = (d) => a("focusOutside", d)),
          onDismiss: u[4] || (u[4] = (d) => l(s).onOpenChange(!1))
        }, {
          default: y(() => [
            N(l(cr), A(l(o), {
              id: l(s).contentId,
              ref: l(r),
              "data-state": l(s).open.value ? "open" : "closed",
              role: "dialog",
              style: {
                "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
              }
            }), {
              default: y(() => [
                w(i.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), wB = /* @__PURE__ */ b({
  __name: "PopoverContentModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Pr(), r = O(!1);
    Vs(!0);
    const s = Le(n, a), { forwardRef: i, currentElement: u } = fe();
    return Ns(u), (d, c) => (g(), C(Ry, A(l(s), {
      ref: l(i),
      "trap-focus": l(o).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: c[0] || (c[0] = We(
        (f) => {
          var p;
          a("closeAutoFocus", f), r.value || (p = l(o).triggerElement.value) == null || p.focus();
        },
        ["prevent"]
      )),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        a("pointerDownOutside", f);
        const p = f.detail.originalEvent, v = p.button === 0 && p.ctrlKey === !0, m = p.button === 2 || v;
        r.value = m;
      }),
      onFocusOutside: c[2] || (c[2] = We(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [
        w(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), xB = /* @__PURE__ */ b({
  __name: "PopoverContentNonModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Pr(), r = O(!1), s = O(!1), i = Le(n, a);
    return (u, d) => (g(), C(Ry, A(l(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        var f;
        a("closeAutoFocus", c), c.defaultPrevented || (r.value || (f = l(o).triggerElement.value) == null || f.focus(), c.preventDefault()), r.value = !1, s.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = async (c) => {
        var f;
        a("interactOutside", c), c.defaultPrevented || (r.value = !0, c.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const p = c.target;
        (f = l(o).triggerElement.value) != null && f.contains(p) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && s.value && c.preventDefault();
      })
    }), {
      default: y(() => [
        w(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), CB = /* @__PURE__ */ b({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Pr(), r = Le(n, a), { forwardRef: s } = fe();
    return o.contentId || (o.contentId = Ot(void 0, "radix-vue-popover-content")), (i, u) => (g(), C(l(On), {
      present: i.forceMount || l(o).open.value
    }, {
      default: y(() => [
        l(o).modal.value ? (g(), C(wB, A({ key: 0 }, l(r), { ref: l(s) }), {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (g(), C(xB, A({ key: 1 }, l(r), { ref: l(s) }), {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), qU = /* @__PURE__ */ b({
  __name: "PopoverAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    fe();
    const n = Pr();
    return dg(() => {
      n.hasCustomAnchor.value = !0;
    }), Ze(() => {
      n.hasCustomAnchor.value = !1;
    }), (a, o) => (g(), C(l(Ls), ne(oe(t)), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gs = 100, [SB, $B] = Ye("ProgressRoot"), Nf = (e) => typeof e == "number";
function BB(e, t) {
  return Qo(e) || Nf(e) && !Number.isNaN(e) && e <= t && e >= 0 ? e : (console.error(`Invalid prop \`value\` of value \`${e}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${gs} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function PB(e) {
  return Nf(e) && !Number.isNaN(e) && e > 0 ? e : (console.error(
    `Invalid prop \`max\` of value \`${e}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${gs}\`.`
  ), gs);
}
const EB = /* @__PURE__ */ b({
  __name: "ProgressRoot",
  props: {
    modelValue: {},
    max: { default: gs },
    getValueLabel: { type: Function, default: (e, t) => `${Math.round(e / t * gs)}%` },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:max"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    fe();
    const o = pt(n, "modelValue", a, {
      passive: n.modelValue === void 0
    }), r = pt(n, "max", a, {
      passive: n.max === void 0
    });
    ce(
      () => o.value,
      async (i) => {
        const u = BB(i, n.max);
        u !== i && (await he(), o.value = u);
      },
      { immediate: !0 }
    ), ce(
      () => n.max,
      (i) => {
        const u = PB(n.max);
        u !== i && (r.value = u);
      },
      { immediate: !0 }
    );
    const s = E(() => Qo(o.value) ? "indeterminate" : o.value === r.value ? "complete" : "loading");
    return $B({
      modelValue: o,
      max: r,
      progressState: s
    }), (i, u) => (g(), C(l(Se), {
      "as-child": i.asChild,
      as: i.as,
      "aria-valuemax": l(r),
      "aria-valuemin": 0,
      "aria-valuenow": Nf(l(o)) ? l(o) : void 0,
      "aria-valuetext": i.getValueLabel(l(o), l(r)),
      "aria-label": i.getValueLabel(l(o), l(r)),
      role: "progressbar",
      "data-state": s.value,
      "data-value": l(o) ?? void 0,
      "data-max": l(r)
    }, {
      default: y(() => [
        w(i.$slots, "default", { modelValue: l(o) })
      ]),
      _: 3
    }, 8, ["as-child", "as", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-label", "data-state", "data-value", "data-max"]));
  }
}), DB = /* @__PURE__ */ b({
  __name: "ProgressIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = SB();
    return fe(), (a, o) => {
      var r;
      return g(), C(l(Se), A(t, {
        "data-state": l(n).progressState.value,
        "data-value": ((r = l(n).modelValue) == null ? void 0 : r.value) ?? void 0,
        "data-max": l(n).max.value
      }), {
        default: y(() => [
          w(a.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-state", "data-value", "data-max"]);
    };
  }
}), MB = ["default-value"], kB = /* @__PURE__ */ b({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(e) {
    const t = e, { value: n } = Be(t), a = O();
    return (o, r) => (g(), C(l(zs), { "as-child": "" }, {
      default: y(() => [
        br(ye("select", A({
          ref_key: "selectElement",
          ref: a
        }, t, {
          "onUpdate:modelValue": r[0] || (r[0] = (s) => ht(n) ? n.value = s : null),
          "default-value": l(n)
        }), [
          w(o.$slots, "default")
        ], 16, MB), [
          [p1, l(n)]
        ])
      ]),
      _: 3
    }));
  }
}), OB = {
  key: 0,
  value: ""
}, [Eo, qy] = Ye("SelectRoot"), [TB, AB] = Ye("SelectRoot"), IB = /* @__PURE__ */ b({
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: { default: "" },
    modelValue: { default: void 0 },
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = pt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), r = pt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = O(), i = O(), u = O({
      x: 0,
      y: 0
    }), d = O(!1), { required: c, disabled: f, dir: p } = Be(n), v = to(p);
    qy({
      triggerElement: s,
      onTriggerChange: (x) => {
        s.value = x;
      },
      valueElement: i,
      onValueElementChange: (x) => {
        i.value = x;
      },
      valueElementHasChildren: d,
      onValueElementHasChildrenChange: (x) => {
        d.value = x;
      },
      contentId: "",
      modelValue: o,
      onValueChange: (x) => {
        o.value = x;
      },
      open: r,
      required: c,
      onOpenChange: (x) => {
        r.value = x;
      },
      dir: v,
      triggerPointerDownPosRef: u,
      disabled: f
    });
    const m = nu(s), h = O(/* @__PURE__ */ new Set()), _ = E(() => Array.from(h.value).map((x) => {
      var S;
      return (S = x.props) == null ? void 0 : S.value;
    }).join(";"));
    return AB({
      onNativeOptionAdd: (x) => {
        h.value.add(x);
      },
      onNativeOptionRemove: (x) => {
        h.value.delete(x);
      }
    }), (x, S) => (g(), C(l($r), null, {
      default: y(() => [
        w(x.$slots, "default", {
          modelValue: l(o),
          open: l(r)
        }),
        l(m) ? (g(), C(kB, A({ key: _.value }, x.$attrs, {
          "aria-hidden": "true",
          tabindex: "-1",
          required: l(c),
          name: x.name,
          autocomplete: x.autocomplete,
          disabled: l(f),
          value: l(o),
          onChange: S[0] || (S[0] = ($) => o.value = $.target.value)
        }), {
          default: y(() => [
            l(o) === void 0 ? (g(), U("option", OB)) : Pe("", !0),
            (g(!0), U(Fe, null, $t(Array.from(h.value), ($) => (g(), C(mt($), A({ ref_for: !0 }, $.props, {
              key: $.key ?? ""
            }), null, 16))), 128))
          ]),
          _: 1
        }, 16, ["required", "name", "autocomplete", "disabled", "value"])) : Pe("", !0)
      ]),
      _: 3
    }));
  }
}), RB = [" ", "Enter", "ArrowUp", "ArrowDown"], qB = [" ", "Enter"], Rn = 10;
function Fy(e) {
  return e === "" || Qo(e);
}
const FB = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = Eo(), a = E(() => {
      var v;
      return ((v = n.disabled) == null ? void 0 : v.value) || t.disabled;
    }), { forwardRef: o, currentElement: r } = fe();
    n.contentId || (n.contentId = Ot(void 0, "radix-vue-select-content")), be(() => {
      n.triggerElement = r;
    });
    const { injectCollection: s } = xr(), i = s(), { search: u, handleTypeaheadSearch: d, resetTypeahead: c } = xf(i);
    function f() {
      a.value || (n.onOpenChange(!0), c());
    }
    function p(v) {
      f(), n.triggerPointerDownPosRef.value = {
        x: Math.round(v.pageX),
        y: Math.round(v.pageY)
      };
    }
    return (v, m) => (g(), C(l(Ls), { "as-child": "" }, {
      default: y(() => {
        var h, _, x, S;
        return [
          N(l(Se), {
            ref: l(o),
            role: "combobox",
            type: v.as === "button" ? "button" : void 0,
            "aria-controls": l(n).contentId,
            "aria-expanded": l(n).open.value || !1,
            "aria-required": (h = l(n).required) == null ? void 0 : h.value,
            "aria-autocomplete": "none",
            disabled: a.value,
            dir: (_ = l(n)) == null ? void 0 : _.dir.value,
            "data-state": (x = l(n)) != null && x.open.value ? "open" : "closed",
            "data-disabled": a.value ? "" : void 0,
            "data-placeholder": l(Fy)((S = l(n).modelValue) == null ? void 0 : S.value) ? "" : void 0,
            "as-child": v.asChild,
            as: v.as,
            onClick: m[0] || (m[0] = ($) => {
              var D;
              (D = $ == null ? void 0 : $.currentTarget) == null || D.focus();
            }),
            onPointerdown: m[1] || (m[1] = ($) => {
              if ($.pointerType === "touch")
                return $.preventDefault();
              const D = $.target;
              D.hasPointerCapture($.pointerId) && D.releasePointerCapture($.pointerId), $.button === 0 && $.ctrlKey === !1 && (p($), $.preventDefault());
            }),
            onPointerup: m[2] || (m[2] = We(
              ($) => {
                $.pointerType === "touch" && p($);
              },
              ["prevent"]
            )),
            onKeydown: m[3] || (m[3] = ($) => {
              const D = l(u) !== "";
              !($.ctrlKey || $.altKey || $.metaKey) && $.key.length === 1 && D && $.key === " " || (l(d)($.key), l(RB).includes($.key) && (f(), $.preventDefault()));
            })
          }, {
            default: y(() => [
              w(v.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ];
      }),
      _: 3
    }));
  }
}), VB = /* @__PURE__ */ b({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Cr), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Lf, NB] = Ye("SelectItemAlignedPosition"), LB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, { injectCollection: o } = xr(), r = Eo(), s = Do(), i = o(), u = O(!1), d = O(!0), c = O(), { forwardRef: f, currentElement: p } = fe(), { viewport: v, selectedItem: m, selectedItemText: h, focusSelectedItem: _ } = s;
    function x() {
      if (r.triggerElement.value && r.valueElement.value && c.value && p.value && v != null && v.value && m != null && m.value && h != null && h.value) {
        const D = r.triggerElement.value.getBoundingClientRect(), B = p.value.getBoundingClientRect(), k = r.valueElement.value.getBoundingClientRect(), M = h.value.getBoundingClientRect();
        if (r.dir.value !== "rtl") {
          const V = M.left - B.left, te = k.left - V, H = D.left - te, re = D.width + H, ie = Math.max(re, B.width), L = window.innerWidth - Rn, _e = di(te, Rn, Math.max(Rn, L - ie));
          c.value.style.minWidth = `${re}px`, c.value.style.left = `${_e}px`;
        } else {
          const V = B.right - M.right, te = window.innerWidth - k.right - V, H = window.innerWidth - D.right - te, re = D.width + H, ie = Math.max(re, B.width), L = window.innerWidth - Rn, _e = di(
            te,
            Rn,
            Math.max(Rn, L - ie)
          );
          c.value.style.minWidth = `${re}px`, c.value.style.right = `${_e}px`;
        }
        const I = i.value, T = window.innerHeight - Rn * 2, P = v.value.scrollHeight, q = window.getComputedStyle(p.value), R = Number.parseInt(
          q.borderTopWidth,
          10
        ), Q = Number.parseInt(q.paddingTop, 10), ee = Number.parseInt(
          q.borderBottomWidth,
          10
        ), K = Number.parseInt(
          q.paddingBottom,
          10
        ), W = R + Q + P + K + ee, j = Math.min(
          m.value.offsetHeight * 5,
          W
        ), J = window.getComputedStyle(v.value), z = Number.parseInt(J.paddingTop, 10), Y = Number.parseInt(
          J.paddingBottom,
          10
        ), Z = D.top + D.height / 2 - Rn, pe = T - Z, $e = m.value.offsetHeight / 2, Ce = m.value.offsetTop + $e, De = R + Q + Ce, ue = W - De;
        if (De <= Z) {
          const V = m.value === I[I.length - 1];
          c.value.style.bottom = "0px";
          const te = p.value.clientHeight - v.value.offsetTop - v.value.offsetHeight, H = Math.max(
            pe,
            $e + (V ? Y : 0) + te + ee
          ), re = De + H;
          c.value.style.height = `${re}px`;
        } else {
          const V = m.value === I[0];
          c.value.style.top = "0px";
          const te = Math.max(
            Z,
            R + v.value.offsetTop + (V ? z : 0) + $e
          ) + ue;
          c.value.style.height = `${te}px`, v.value.scrollTop = De - Z + v.value.offsetTop;
        }
        c.value.style.margin = `${Rn}px 0`, c.value.style.minHeight = `${j}px`, c.value.style.maxHeight = `${T}px`, a("placed"), requestAnimationFrame(() => u.value = !0);
      }
    }
    const S = O("");
    be(async () => {
      await he(), x(), p.value && (S.value = window.getComputedStyle(p.value).zIndex);
    });
    function $(D) {
      D && d.value === !0 && (x(), _ == null || _(), d.value = !1);
    }
    return NB({
      contentWrapper: c,
      shouldExpandOnScrollRef: u,
      onScrollButtonChange: $
    }), (D, B) => (g(), U("div", {
      ref_key: "contentWrapperElement",
      ref: c,
      style: vt({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: S.value
      })
    }, [
      N(l(Se), A({
        ref: l(f),
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%"
        }
      }, { ...D.$attrs, ...n }), {
        default: y(() => [
          w(D.$slots, "default")
        ]),
        _: 3
      }, 16)
    ], 4));
  }
}), zB = /* @__PURE__ */ b({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: Rn },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = Rt(e);
    return (n, a) => (g(), C(l(cr), A(l(t), { style: {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-select-content-available-width": "var(--radix-popper-available-width)",
      "--radix-select-content-available-height": "var(--radix-popper-available-height)",
      "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Er = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [Do, HB] = Ye("SelectContent"), UB = /* @__PURE__ */ b({
  __name: "SelectContentImpl",
  props: {
    position: { default: "item-aligned" },
    bodyLock: { type: Boolean, default: !0 },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Eo();
    wf(), Vs(n.bodyLock);
    const { createCollection: r } = xr(), s = O();
    Ns(s);
    const i = r(s), { search: u, handleTypeaheadSearch: d } = xf(i), c = O(), f = O(), p = O(), v = O(!1), m = O(!1);
    function h() {
      f.value && s.value && rc([f.value, s.value]);
    }
    ce(v, () => {
      h();
    });
    const { onOpenChange: _, triggerPointerDownPosRef: x } = o;
    Me((B) => {
      if (!s.value)
        return;
      let k = { x: 0, y: 0 };
      const M = (T) => {
        var P, q;
        k = {
          x: Math.abs(
            Math.round(T.pageX) - (((P = x.value) == null ? void 0 : P.x) ?? 0)
          ),
          y: Math.abs(
            Math.round(T.pageY) - (((q = x.value) == null ? void 0 : q.y) ?? 0)
          )
        };
      }, I = (T) => {
        var P;
        T.pointerType !== "touch" && (k.x <= 10 && k.y <= 10 ? T.preventDefault() : (P = s.value) != null && P.contains(T.target) || _(!1), document.removeEventListener("pointermove", M), x.value = null);
      };
      x.value !== null && (document.addEventListener("pointermove", M), document.addEventListener("pointerup", I, {
        capture: !0,
        once: !0
      })), B(() => {
        document.removeEventListener("pointermove", M), document.removeEventListener("pointerup", I, {
          capture: !0
        });
      });
    });
    function S(B) {
      const k = B.ctrlKey || B.altKey || B.metaKey;
      if (B.key === "Tab" && B.preventDefault(), !k && B.key.length === 1 && d(B.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(B.key)) {
        let M = i.value;
        if (["ArrowUp", "End"].includes(B.key) && (M = M.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(B.key)) {
          const I = B.target, T = M.indexOf(I);
          M = M.slice(T + 1);
        }
        setTimeout(() => rc(M)), B.preventDefault();
      }
    }
    const $ = E(() => n.position === "popper" ? n : {}), D = Rt($.value);
    return HB({
      content: s,
      viewport: c,
      onViewportChange: (B) => {
        c.value = B;
      },
      itemRefCallback: (B, k, M) => {
        var I, T;
        const P = !m.value && !M;
        (((I = o.modelValue) == null ? void 0 : I.value) !== void 0 && ((T = o.modelValue) == null ? void 0 : T.value) === k || P) && (f.value = B, P && (m.value = !0));
      },
      selectedItem: f,
      selectedItemText: p,
      onItemLeave: () => {
        var B;
        (B = s.value) == null || B.focus();
      },
      itemTextRefCallback: (B, k, M) => {
        var I, T;
        const P = !m.value && !M;
        (((I = o.modelValue) == null ? void 0 : I.value) !== void 0 && ((T = o.modelValue) == null ? void 0 : T.value) === k || P) && (p.value = B);
      },
      focusSelectedItem: h,
      position: n.position,
      isPositioned: v,
      searchRef: u
    }), (B, k) => (g(), C(l(ou), {
      "as-child": "",
      onMountAutoFocus: k[6] || (k[6] = We(() => {
      }, ["prevent"])),
      onUnmountAutoFocus: k[7] || (k[7] = (M) => {
        var I;
        a("closeAutoFocus", M), !M.defaultPrevented && ((I = l(o).triggerElement.value) == null || I.focus({ preventScroll: !0 }), M.preventDefault());
      })
    }, {
      default: y(() => [
        N(l(Sr), {
          "as-child": "",
          "disable-outside-pointer-events": "",
          onFocusOutside: k[2] || (k[2] = We(() => {
          }, ["prevent"])),
          onDismiss: k[3] || (k[3] = (M) => l(o).onOpenChange(!1)),
          onEscapeKeyDown: k[4] || (k[4] = (M) => a("escapeKeyDown", M)),
          onPointerDownOutside: k[5] || (k[5] = (M) => a("pointerDownOutside", M))
        }, {
          default: y(() => [
            (g(), C(mt(
              B.position === "popper" ? zB : LB
            ), A({ ...B.$attrs, ...l(D) }, {
              id: l(o).contentId,
              ref: (M) => {
                s.value = l(kn)(M);
              },
              role: "listbox",
              "data-state": l(o).open.value ? "open" : "closed",
              dir: l(o).dir.value,
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none"
              },
              onContextmenu: k[0] || (k[0] = We(() => {
              }, ["prevent"])),
              onPlaced: k[1] || (k[1] = (M) => v.value = !0),
              onKeydown: S
            }), {
              default: y(() => [
                w(B.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "dir", "onKeydown"]))
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), jB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(e) {
    return qy(e.context), (t, n) => w(t.$slots, "default");
  }
}), WB = { key: 1 }, KB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = Le(n, t), o = Eo(), r = O();
    be(() => {
      r.value = new DocumentFragment();
    });
    const s = O(), i = E(() => n.forceMount || o.open.value);
    return (u, d) => {
      var c;
      return i.value ? (g(), C(l(On), {
        key: 0,
        ref_key: "presenceRef",
        ref: s,
        present: !0
      }, {
        default: y(() => [
          N(UB, ne(oe({ ...l(a), ...u.$attrs })), {
            default: y(() => [
              w(u.$slots, "default")
            ]),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 512)) : !((c = s.value) != null && c.present) && r.value ? (g(), U("div", WB, [
        (g(), C(Co, { to: r.value }, [
          N(jB, { context: l(o) }, {
            default: y(() => [
              w(u.$slots, "default")
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"]))
      ])) : Pe("", !0);
    };
  }
}), GB = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), A({ "aria-hidden": "true" }, t), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Vy, YB] = Ye("SelectItem"), XB = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { disabled: n } = Be(t), a = Eo(), o = Do(Er), { forwardRef: r, currentElement: s } = fe(), i = E(() => {
      var h;
      return ((h = a.modelValue) == null ? void 0 : h.value) === t.value;
    }), u = O(!1), d = O(t.textValue ?? ""), c = Ot(void 0, "radix-vue-select-item-text");
    async function f(h) {
      await he(), !(h != null && h.defaultPrevented) && (n.value || (a.onValueChange(t.value), a.onOpenChange(!1)));
    }
    async function p(h) {
      var _;
      await he(), !h.defaultPrevented && (n.value ? (_ = o.onItemLeave) == null || _.call(o) : h.currentTarget.focus({ preventScroll: !0 }));
    }
    async function v(h) {
      var _;
      await he(), !h.defaultPrevented && h.currentTarget === It() && ((_ = o.onItemLeave) == null || _.call(o));
    }
    async function m(h) {
      var _;
      await he(), !(h.defaultPrevented || ((_ = o.searchRef) == null ? void 0 : _.value) !== "" && h.key === " ") && (qB.includes(h.key) && f(), h.key === " " && h.preventDefault());
    }
    if (t.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return be(() => {
      s.value && o.itemRefCallback(
        s.value,
        t.value,
        t.disabled
      );
    }), YB({
      value: t.value,
      disabled: n,
      textId: c,
      isSelected: i,
      onItemTextChange: (h) => {
        d.value = ((d.value || (h == null ? void 0 : h.textContent)) ?? "").trim();
      }
    }), (h, _) => (g(), C(l(Se), {
      ref: l(r),
      role: "option",
      "data-radix-vue-collection-item": "",
      "aria-labelledby": l(c),
      "data-highlighted": u.value ? "" : void 0,
      "aria-selected": i.value,
      "data-state": i.value ? "checked" : "unchecked",
      "aria-disabled": l(n) || void 0,
      "data-disabled": l(n) ? "" : void 0,
      tabindex: l(n) ? void 0 : -1,
      as: h.as,
      "as-child": h.asChild,
      onFocus: _[0] || (_[0] = (x) => u.value = !0),
      onBlur: _[1] || (_[1] = (x) => u.value = !1),
      onPointerup: f,
      onPointerdown: _[2] || (_[2] = (x) => {
        x.currentTarget.focus({ preventScroll: !0 });
      }),
      onTouchend: _[3] || (_[3] = We(() => {
      }, ["prevent", "stop"])),
      onPointermove: p,
      onPointerleave: v,
      onKeydown: m
    }, {
      default: y(() => [
        w(h.$slots, "default")
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"]));
  }
}), JB = /* @__PURE__ */ b({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, n = Vy();
    return (a, o) => l(n).isSelected.value ? (g(), C(l(Se), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16)) : Pe("", !0);
  }
}), [ZB, QB] = Ye("SelectGroup"), e2 = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = Ot(void 0, "radix-vue-select-group");
    return QB({ id: n }), (a, o) => (g(), C(l(Se), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), t2 = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e, n = ZB({ id: "" });
    return (a, o) => (g(), C(l(Se), A(t, {
      id: l(n).id
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), Ny = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, n = Eo(), a = Do(Er), o = TB(), r = Vy(), { forwardRef: s, currentElement: i } = fe(), u = E(() => {
      var d;
      return Bt("option", {
        key: r.value,
        value: r.value,
        disabled: r.disabled.value,
        textContent: (d = i.value) == null ? void 0 : d.textContent
      });
    });
    return be(() => {
      i.value && (r.onItemTextChange(i.value), a.itemTextRefCallback(
        i.value,
        r.value,
        r.disabled.value
      ), o.onNativeOptionAdd(u.value));
    }), ka(() => {
      o.onNativeOptionRemove(u.value);
    }), (d, c) => (g(), U(Fe, null, [
      N(l(Se), A({
        id: l(r).textId,
        ref: l(s)
      }, { ...t, ...d.$attrs }, { "data-item-text": "" }), {
        default: y(() => [
          w(d.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]),
      l(r).isSelected.value && l(n).valueElement.value && !l(n).valueElementHasChildren.value ? (g(), C(Co, {
        key: 0,
        to: l(n).valueElement.value
      }, [
        w(d.$slots, "default")
      ], 8, ["to"])) : Pe("", !0)
    ], 64));
  }
}), n2 = /* @__PURE__ */ b({
  __name: "SelectViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { nonce: n } = Be(t), a = _$(n), o = Do(Er), r = o.position === "item-aligned" ? Lf() : void 0, { forwardRef: s, currentElement: i } = fe();
    be(() => {
      o == null || o.onViewportChange(i.value);
    });
    const u = O(0);
    function d(c) {
      const f = c.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: v } = r ?? {};
      if (p != null && p.value && v != null && v.value) {
        const m = Math.abs(u.value - f.scrollTop);
        if (m > 0) {
          const h = window.innerHeight - Rn * 2, _ = Number.parseFloat(
            v.value.style.minHeight
          ), x = Number.parseFloat(v.value.style.height), S = Math.max(_, x);
          if (S < h) {
            const $ = S + m, D = Math.min(h, $), B = $ - D;
            v.value.style.height = `${D}px`, v.value.style.bottom === "0px" && (f.scrollTop = B > 0 ? B : 0, v.value.style.justifyContent = "flex-end");
          }
        }
      }
      u.value = f.scrollTop;
    }
    return (c, f) => (g(), U(Fe, null, [
      N(l(Se), A({
        ref: l(s),
        "data-radix-select-viewport": "",
        role: "presentation"
      }, { ...c.$attrs, ...t }, {
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "hidden auto"
        },
        onScroll: d
      }), {
        default: y(() => [
          w(c.$slots, "default")
        ]),
        _: 3
      }, 16),
      N(l(Se), {
        as: "style",
        nonce: l(a)
      }, {
        default: y(() => [
          Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
}), Ly = /* @__PURE__ */ b({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(e, { emit: t }) {
    const n = t, { injectCollection: a } = xr(), o = a(), r = Do(Er), s = O(null);
    function i() {
      s.value !== null && (window.clearInterval(s.value), s.value = null);
    }
    Me(() => {
      const c = o.value.find(
        (f) => f === It()
      );
      c == null || c.scrollIntoView({ block: "nearest" });
    });
    function u() {
      s.value === null && (s.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    function d() {
      var c;
      (c = r.onItemLeave) == null || c.call(r), s.value === null && (s.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    return ka(() => i()), (c, f) => {
      var p;
      return g(), C(l(Se), A({
        "aria-hidden": "true",
        style: {
          flexShrink: 0
        }
      }, (p = c.$parent) == null ? void 0 : p.$props, {
        onPointerdown: u,
        onPointermove: d,
        onPointerleave: f[0] || (f[0] = () => {
          i();
        })
      }), {
        default: y(() => [
          w(c.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
}), a2 = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = Do(Er), n = t.position === "item-aligned" ? Lf() : void 0, { forwardRef: a, currentElement: o } = fe(), r = O(!1);
    return Me((s) => {
      var i, u;
      if ((i = t.viewport) != null && i.value && (u = t.isPositioned) != null && u.value) {
        let d = function() {
          r.value = c.scrollTop > 0;
        };
        const c = t.viewport.value;
        d(), c.addEventListener("scroll", d), s(() => c.removeEventListener("scroll", d));
      }
    }), ce(o, () => {
      o.value && (n == null || n.onScrollButtonChange(o.value));
    }), (s, i) => r.value ? (g(), C(Ly, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u != null && u.value && d != null && d.value && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 512)) : Pe("", !0);
  }
}), o2 = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = Do(Er), n = t.position === "item-aligned" ? Lf() : void 0, { forwardRef: a, currentElement: o } = fe(), r = O(!1);
    return Me((s) => {
      var i, u;
      if ((i = t.viewport) != null && i.value && (u = t.isPositioned) != null && u.value) {
        let d = function() {
          const f = c.scrollHeight - c.clientHeight;
          r.value = Math.ceil(c.scrollTop) < f;
        };
        const c = t.viewport.value;
        d(), c.addEventListener("scroll", d), s(() => c.removeEventListener("scroll", d));
      }
    }), ce(o, () => {
      o.value && (n == null || n.onScrollButtonChange(o.value));
    }), (s, i) => r.value ? (g(), C(Ly, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u != null && u.value && d != null && d.value && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 512)) : Pe("", !0);
  }
}), r2 = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const { forwardRef: t, currentElement: n } = fe(), a = Eo(), o = Jc();
    return dg(() => {
      var r;
      const s = !!eu((r = o == null ? void 0 : o.default) == null ? void 0 : r.call(o)).length;
      a.onValueElementHasChildrenChange(s);
    }), be(() => {
      a.valueElement = n;
    }), (r, s) => (g(), C(l(Se), {
      ref: l(t),
      as: r.as,
      "as-child": r.asChild,
      style: { pointerEvents: "none" }
    }, {
      default: y(() => {
        var i;
        return [
          l(Fy)((i = l(a).modelValue) == null ? void 0 : i.value) ? (g(), U(Fe, { key: 0 }, [
            Re(Ve(r.placeholder), 1)
          ], 64)) : w(r.$slots, "default", { key: 1 })
        ];
      }),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), s2 = /* @__PURE__ */ b({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    return (t, n) => (g(), C(l(Se), {
      "aria-hidden": "true",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: y(() => [
        w(t.$slots, "default", {}, () => [
          Re("▼")
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function l2(e = [], t, n) {
  const a = [...e];
  return a[n] = t, a.sort((o, r) => o - r);
}
function zy(e, t, n) {
  const a = 100 / (n - t) * (e - t);
  return di(a, 0, 100);
}
function i2(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function u2(e, t) {
  if (e.length === 1)
    return 0;
  const n = e.map((o) => Math.abs(o - t)), a = Math.min(...n);
  return n.indexOf(a);
}
function d2(e, t, n) {
  const a = e / 2, o = zf([0, 50], [0, a]);
  return (a - o(t) * n) * n;
}
function c2(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function f2(e, t) {
  if (t > 0) {
    const n = c2(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function zf(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function p2(e) {
  return (String(e).split(".")[1] || "").length;
}
function v2(e, t) {
  const n = 10 ** t;
  return Math.round(e * n) / n;
}
const Hy = ["PageUp", "PageDown"], Uy = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], jy = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, [Wy, Ky] = Ye(["SliderVertical", "SliderHorizontal"]), Gy = /* @__PURE__ */ b({
  __name: "SliderImpl",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  emits: ["slideStart", "slideMove", "slideEnd", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = iu();
    return (r, s) => (g(), C(l(Se), A({ "data-slider-impl": "" }, n, {
      onKeydown: s[0] || (s[0] = (i) => {
        i.key === "Home" ? (a("homeKeyDown", i), i.preventDefault()) : i.key === "End" ? (a("endKeyDown", i), i.preventDefault()) : l(Hy).concat(l(Uy)).includes(i.key) && (a("stepKeyDown", i), i.preventDefault());
      }),
      onPointerdown: s[1] || (s[1] = (i) => {
        const u = i.target;
        u.setPointerCapture(i.pointerId), i.preventDefault(), l(o).thumbElements.value.includes(u) ? u.focus() : a("slideStart", i);
      }),
      onPointermove: s[2] || (s[2] = (i) => {
        i.target.hasPointerCapture(i.pointerId) && a("slideMove", i);
      }),
      onPointerup: s[3] || (s[3] = (i) => {
        const u = i.target;
        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), a("slideEnd", i));
      })
    }), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), m2 = /* @__PURE__ */ b({
  __name: "SliderHorizontal",
  props: {
    dir: {},
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: o, min: r, dir: s, inverted: i } = Be(n), { forwardRef: u, currentElement: d } = fe(), c = O(), f = E(() => (s == null ? void 0 : s.value) === "ltr" && !i.value || (s == null ? void 0 : s.value) !== "ltr" && i.value);
    function p(v) {
      const m = c.value || d.value.getBoundingClientRect(), h = [0, m.width], _ = f.value ? [r.value, o.value] : [o.value, r.value], x = zf(h, _);
      return c.value = m, x(v - m.left);
    }
    return Ky({
      startEdge: f.value ? "left" : "right",
      endEdge: f.value ? "right" : "left",
      direction: f.value ? 1 : -1,
      size: "width"
    }), (v, m) => (g(), C(Gy, {
      ref: l(u),
      dir: l(s),
      "data-orientation": "horizontal",
      style: {
        "--radix-slider-thumb-transform": "translateX(-50%)"
      },
      onSlideStart: m[0] || (m[0] = (h) => {
        const _ = p(h.clientX);
        a("slideStart", _);
      }),
      onSlideMove: m[1] || (m[1] = (h) => {
        const _ = p(h.clientX);
        a("slideMove", _);
      }),
      onSlideEnd: m[2] || (m[2] = () => {
        c.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: m[3] || (m[3] = (h) => {
        const _ = f.value ? "from-left" : "from-right", x = l(jy)[_].includes(h.key);
        a("stepKeyDown", h, x ? -1 : 1);
      }),
      onEndKeyDown: m[4] || (m[4] = (h) => a("endKeyDown", h)),
      onHomeKeyDown: m[5] || (m[5] = (h) => a("homeKeyDown", h))
    }, {
      default: y(() => [
        w(v.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir"]));
  }
}), h2 = /* @__PURE__ */ b({
  __name: "SliderVertical",
  props: {
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: o, min: r, inverted: s } = Be(n), { forwardRef: i, currentElement: u } = fe(), d = O(), c = E(() => !s.value);
    function f(p) {
      const v = d.value || u.value.getBoundingClientRect(), m = [0, v.height], h = c.value ? [o.value, r.value] : [r.value, o.value], _ = zf(m, h);
      return d.value = v, _(p - v.top);
    }
    return Ky({
      startEdge: c.value ? "bottom" : "top",
      endEdge: c.value ? "top" : "bottom",
      size: "height",
      direction: c.value ? 1 : -1
    }), (p, v) => (g(), C(Gy, {
      ref: l(i),
      "data-orientation": "vertical",
      style: {
        "--radix-slider-thumb-transform": "translateY(50%)"
      },
      onSlideStart: v[0] || (v[0] = (m) => {
        const h = f(m.clientY);
        a("slideStart", h);
      }),
      onSlideMove: v[1] || (v[1] = (m) => {
        const h = f(m.clientY);
        a("slideMove", h);
      }),
      onSlideEnd: v[2] || (v[2] = () => {
        d.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: v[3] || (v[3] = (m) => {
        const h = c.value ? "from-bottom" : "from-top", _ = l(jy)[h].includes(m.key);
        a("stepKeyDown", m, _ ? -1 : 1);
      }),
      onEndKeyDown: v[4] || (v[4] = (m) => a("endKeyDown", m)),
      onHomeKeyDown: v[5] || (v[5] = (m) => a("homeKeyDown", m))
    }, {
      default: y(() => [
        w(p.$slots, "default")
      ]),
      _: 3
    }, 512));
  }
}), g2 = ["value", "name", "disabled", "step"], [iu, y2] = Ye("SliderRoot"), b2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    name: {},
    defaultValue: { default: () => [0] },
    modelValue: {},
    disabled: { type: Boolean, default: !1 },
    orientation: { default: "horizontal" },
    dir: {},
    inverted: { type: Boolean, default: !1 },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    minStepsBetweenThumbs: { default: 0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, { min: o, max: r, step: s, minStepsBetweenThumbs: i, orientation: u, disabled: d, dir: c } = Be(n), f = to(c), { forwardRef: p, currentElement: v } = fe(), m = nu(v);
    Af();
    const h = pt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), _ = O(0), x = O(h.value);
    function S(M) {
      const I = u2(h.value, M);
      B(M, I);
    }
    function $(M) {
      B(M, _.value);
    }
    function D() {
      const M = x.value[_.value];
      h.value[_.value] !== M && a("valueCommit", v1(h.value));
    }
    function B(M, I, { commit: T } = { commit: !1 }) {
      var P;
      const q = p2(s.value), R = v2(Math.round((M - o.value) / s.value) * s.value + o.value, q), Q = di(R, o.value, r.value), ee = l2(h.value, Q, I);
      if (f2(ee, i.value * s.value)) {
        _.value = ee.indexOf(Q);
        const K = String(ee) !== String(h.value);
        K && T && a("valueCommit", ee), K && ((P = k.value[_.value]) == null || P.focus(), h.value = ee);
      }
    }
    const k = O([]);
    return y2({
      modelValue: h,
      valueIndexToChangeRef: _,
      thumbElements: k,
      orientation: u,
      min: o,
      max: r,
      disabled: d
    }), (M, I) => (g(), U(Fe, null, [
      N(l(If), null, {
        default: y(() => [
          (g(), C(mt(l(u) === "horizontal" ? m2 : h2), A(M.$attrs, {
            ref: l(p),
            "as-child": M.asChild,
            as: M.as,
            min: l(o),
            max: l(r),
            dir: l(f),
            inverted: M.inverted,
            "aria-disabled": l(d),
            "data-disabled": l(d) ? "" : void 0,
            onPointerdown: I[0] || (I[0] = () => {
              l(d) || (x.value = l(h));
            }),
            onSlideStart: I[1] || (I[1] = (T) => !l(d) && S(T)),
            onSlideMove: I[2] || (I[2] = (T) => !l(d) && $(T)),
            onSlideEnd: I[3] || (I[3] = (T) => !l(d) && D()),
            onHomeKeyDown: I[4] || (I[4] = (T) => !l(d) && B(l(o), 0, { commit: !0 })),
            onEndKeyDown: I[5] || (I[5] = (T) => !l(d) && B(l(r), l(h).length - 1, { commit: !0 })),
            onStepKeyDown: I[6] || (I[6] = (T, P) => {
              if (!l(d)) {
                const q = l(Hy).includes(T.key) || T.shiftKey && l(Uy).includes(T.key) ? 10 : 1, R = _.value, Q = l(h)[R], ee = l(s) * q * P;
                B(Q + ee, R, { commit: !0 });
              }
            })
          }), {
            default: y(() => [
              w(M.$slots, "default", { modelValue: l(h) })
            ]),
            _: 3
          }, 16, ["as-child", "as", "min", "max", "dir", "inverted", "aria-disabled", "data-disabled"]))
        ]),
        _: 3
      }),
      l(m) ? (g(!0), U(Fe, { key: 0 }, $t(l(h), (T, P) => (g(), U("input", {
        key: P,
        value: T,
        type: "number",
        style: { display: "none" },
        name: M.name ? M.name + (l(h).length > 1 ? "[]" : "") : void 0,
        disabled: l(d),
        step: l(s)
      }, null, 8, g2))), 128)) : Pe("", !0)
    ], 64));
  }
}), _2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = iu(), a = Wy(), { forwardRef: o, currentElement: r } = fe(), s = E(() => {
      var v, m;
      return (m = (v = n.modelValue) == null ? void 0 : v.value) == null ? void 0 : m[t.index];
    }), i = E(() => s.value === void 0 ? 0 : zy(s.value, n.min.value ?? 0, n.max.value ?? 100)), u = E(() => {
      var v, m;
      return i2(t.index, ((m = (v = n.modelValue) == null ? void 0 : v.value) == null ? void 0 : m.length) ?? 0);
    }), d = my(r), c = E(() => d[a.size].value), f = E(() => c.value ? d2(c.value, i.value, a.direction) : 0), p = _f();
    return be(() => {
      n.thumbElements.value.push(r.value);
    }), Ze(() => {
      const v = n.thumbElements.value.findIndex((m) => m === r.value) ?? -1;
      n.thumbElements.value.splice(v, 1);
    }), (v, m) => (g(), C(l(lu), null, {
      default: y(() => [
        N(l(Se), A(v.$attrs, {
          ref: l(o),
          role: "slider",
          "data-radix-vue-collection-item": "",
          tabindex: l(n).disabled.value ? void 0 : 0,
          "aria-label": v.$attrs["aria-label"] || u.value,
          "data-disabled": l(n).disabled.value ? "" : void 0,
          "data-orientation": l(n).orientation.value,
          "aria-valuenow": s.value,
          "aria-valuemin": l(n).min.value,
          "aria-valuemax": l(n).max.value,
          "aria-orientation": l(n).orientation.value,
          "as-child": v.asChild,
          as: v.as,
          style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [l(a).startEdge]: `calc(${i.value}% + ${f.value}px)`,
            /**
             * There will be no value on initial render while we work out the index so we hide thumbs
             * without a value, otherwise SSR will render them in the wrong position before they
             * snap into the correct position during hydration which would be visually jarring for
             * slower connections.
             */
            display: !l(p) && s.value === void 0 ? "none" : void 0
          },
          onFocus: m[0] || (m[0] = () => {
            l(n).valueIndexToChangeRef.value = v.index;
          })
        }), {
          default: y(() => [
            w(v.$slots, "default")
          ]),
          _: 3
        }, 16, ["tabindex", "aria-label", "data-disabled", "data-orientation", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "as-child", "as", "style"])
      ]),
      _: 3
    }));
  }
}), w2 = /* @__PURE__ */ b({
  __name: "SliderThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { getItems: n } = Rf(), { forwardRef: a, currentElement: o } = fe(), r = E(() => o.value ? n().findIndex((s) => s.ref === o.value) : -1);
    return (s, i) => (g(), C(_2, A({ ref: l(a) }, t, { index: r.value }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["index"]));
  }
}), x2 = /* @__PURE__ */ b({
  __name: "SliderTrack",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = iu();
    return fe(), (n, a) => (g(), C(l(Se), {
      "as-child": n.asChild,
      as: n.as,
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "data-disabled", "data-orientation"]));
  }
}), C2 = /* @__PURE__ */ b({
  __name: "SliderRange",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = iu(), n = Wy();
    fe();
    const a = E(() => {
      var s, i;
      return (i = (s = t.modelValue) == null ? void 0 : s.value) == null ? void 0 : i.map(
        (u) => zy(u, t.min.value, t.max.value)
      );
    }), o = E(() => t.modelValue.value.length > 1 ? Math.min(...a.value) : 0), r = E(() => 100 - Math.max(...a.value));
    return (s, i) => (g(), C(l(Se), {
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      "as-child": s.asChild,
      as: s.as,
      style: vt({
        [l(n).startEdge]: `${o.value}%`,
        [l(n).endEdge]: `${r.value}%`
      })
    }, {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-disabled", "data-orientation", "as-child", "as", "style"]));
  }
});
function S2() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
S2();
const $2 = ["name", "disabled", "required", "value", "checked", "data-state", "data-disabled"], [B2, P2] = Ye("SwitchRoot"), E2 = /* @__PURE__ */ b({
  __name: "SwitchRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    id: {},
    value: { default: "on" },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: o } = Be(n), r = pt(n, "checked", a, {
      defaultValue: n.defaultChecked,
      passive: n.checked === void 0
    });
    function s() {
      o.value || (r.value = !r.value);
    }
    const { forwardRef: i, currentElement: u } = fe(), d = nu(u), c = E(() => {
      var f;
      return n.id && u.value ? (f = document.querySelector(`[for="${n.id}"]`)) == null ? void 0 : f.innerText : void 0;
    });
    return P2({
      checked: r,
      toggleCheck: s,
      disabled: o
    }), (f, p) => (g(), U(Fe, null, [
      N(l(Se), A(f.$attrs, {
        id: f.id,
        ref: l(i),
        role: "switch",
        type: f.as === "button" ? "button" : void 0,
        value: f.value,
        "aria-label": f.$attrs["aria-label"] || c.value,
        "aria-checked": l(r),
        "aria-required": f.required,
        "data-state": l(r) ? "checked" : "unchecked",
        "data-disabled": l(o) ? "" : void 0,
        "as-child": f.asChild,
        as: f.as,
        disabled: l(o),
        onClick: s,
        onKeydown: Qe(We(s, ["prevent"]), ["enter"])
      }), {
        default: y(() => [
          w(f.$slots, "default", { checked: l(r) })
        ]),
        _: 3
      }, 16, ["id", "type", "value", "aria-label", "aria-checked", "aria-required", "data-state", "data-disabled", "as-child", "as", "disabled", "onKeydown"]),
      l(d) ? (g(), U("input", {
        key: 0,
        type: "checkbox",
        name: f.name,
        tabindex: "-1",
        "aria-hidden": "true",
        disabled: l(o),
        required: f.required,
        value: f.value,
        checked: !!l(r),
        "data-state": l(r) ? "checked" : "unchecked",
        "data-disabled": l(o) ? "" : void 0,
        style: {
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }, null, 8, $2)) : Pe("", !0)
    ], 64));
  }
}), D2 = /* @__PURE__ */ b({
  __name: "SwitchThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = B2();
    return fe(), (n, a) => {
      var o;
      return g(), C(l(Se), {
        "data-state": (o = l(t).checked) != null && o.value ? "checked" : "unchecked",
        "data-disabled": l(t).disabled.value ? "" : void 0,
        "as-child": n.asChild,
        as: n.as
      }, {
        default: y(() => [
          w(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "data-disabled", "as-child", "as"]);
    };
  }
}), [Hf, M2] = Ye("TabsRoot"), k2 = /* @__PURE__ */ b({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { orientation: o, dir: r } = Be(n), s = to(r);
    fe();
    const i = pt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), u = O();
    return M2({
      modelValue: i,
      changeModelValue: (d) => {
        i.value = d;
      },
      orientation: o,
      dir: s,
      activationMode: n.activationMode,
      baseId: Ot(void 0, "radix-vue-tabs"),
      tabsList: u
    }), (d, c) => (g(), C(l(Se), {
      dir: l(s),
      "data-orientation": l(o),
      "as-child": d.asChild,
      as: d.as
    }, {
      default: y(() => [
        w(d.$slots, "default", { modelValue: l(i) })
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
}), O2 = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { loop: n } = Be(t), { forwardRef: a, currentElement: o } = fe(), r = Hf();
    return r.tabsList = o, (s, i) => (g(), C(l(Dy), {
      "as-child": "",
      orientation: l(r).orientation.value,
      dir: l(r).dir.value,
      loop: l(n)
    }, {
      default: y(() => [
        N(l(Se), {
          ref: l(a),
          role: "tablist",
          "as-child": s.asChild,
          as: s.as,
          "aria-orientation": l(r).orientation.value
        }, {
          default: y(() => [
            w(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "aria-orientation"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
function Yy(e, t) {
  return `${e}-trigger-${t}`;
}
function Xy(e, t) {
  return `${e}-content-${t}`;
}
const T2 = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { forwardRef: n } = fe(), a = Hf(), o = E(() => Yy(a.baseId, t.value)), r = E(() => Xy(a.baseId, t.value)), s = E(() => t.value === a.modelValue.value), i = O(s.value);
    return be(() => {
      requestAnimationFrame(() => {
        i.value = !1;
      });
    }), (u, d) => (g(), C(l(On), {
      present: s.value,
      "force-mount": ""
    }, {
      default: y(({ present: c }) => [
        N(l(Se), {
          id: r.value,
          ref: l(n),
          "as-child": u.asChild,
          as: u.as,
          role: "tabpanel",
          "data-state": s.value ? "active" : "inactive",
          "data-orientation": l(a).orientation.value,
          "aria-labelledby": o.value,
          hidden: !c.value,
          tabindex: "0",
          style: vt({
            animationDuration: i.value ? "0s" : void 0
          })
        }, {
          default: y(() => [
            u.forceMount || s.value ? w(u.$slots, "default", { key: 0 }) : Pe("", !0)
          ]),
          _: 2
        }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), A2 = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, { forwardRef: n } = fe(), a = Hf(), o = E(() => Yy(a.baseId, t.value)), r = E(() => Xy(a.baseId, t.value)), s = E(() => t.value === a.modelValue.value);
    return (i, u) => (g(), C(l(q$), {
      "as-child": "",
      focusable: !i.disabled,
      active: s.value
    }, {
      default: y(() => [
        N(l(Se), {
          id: o.value,
          ref: l(n),
          role: "tab",
          type: i.as === "button" ? "button" : void 0,
          as: i.as,
          "as-child": i.asChild,
          "aria-selected": s.value ? "true" : "false",
          "aria-controls": r.value,
          "data-state": s.value ? "active" : "inactive",
          disabled: i.disabled,
          "data-disabled": i.disabled ? "" : void 0,
          "data-orientation": l(a).orientation.value,
          onMousedown: u[0] || (u[0] = We((d) => {
            !i.disabled && d.ctrlKey === !1 ? l(a).changeModelValue(i.value) : d.preventDefault();
          }, ["left"])),
          onKeydown: u[1] || (u[1] = Qe((d) => l(a).changeModelValue(i.value), ["enter", "space"])),
          onFocus: u[2] || (u[2] = () => {
            const d = l(a).activationMode !== "manual";
            !s.value && !i.disabled && d && l(a).changeModelValue(i.value);
          })
        }, {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), [uu, I2] = Ye("ToastProvider"), R2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(e) {
    const t = e, { label: n, duration: a, swipeDirection: o, swipeThreshold: r } = Be(t), s = O(), i = O(0), u = O(!1), d = O(!1);
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const c = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(c);
    }
    return I2({
      label: n,
      duration: a,
      swipeDirection: o,
      swipeThreshold: r,
      toastCount: i,
      viewport: s,
      onViewportChange(c) {
        s.value = c;
      },
      onToastAdd() {
        i.value++;
      },
      onToastRemove() {
        i.value--;
      },
      isFocusedToastEscapeKeyDownRef: u,
      isClosePausedRef: d
    }), (c, f) => w(c.$slots, "default");
  }
}), q2 = "toast.swipeStart", F2 = "toast.swipeMove", V2 = "toast.swipeCancel", N2 = "toast.swipeEnd", lc = "toast.viewportPause", ic = "toast.viewportResume";
function pl(e, t, n) {
  const a = n.originalEvent.currentTarget, o = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(o);
}
function nm(e, t, n = 0) {
  const a = Math.abs(e.x), o = Math.abs(e.y), r = a > o;
  return t === "left" || t === "right" ? r && a > n : !r && o > n;
}
function L2(e) {
  return e.nodeType === e.ELEMENT_NODE;
}
function Jy(e) {
  const t = [];
  return Array.from(e.childNodes).forEach((n) => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), L2(n)) {
      const a = n.ariaHidden || n.hidden || n.style.display === "none", o = n.dataset.radixToastAnnounceExclude === "";
      if (!a)
        if (o) {
          const r = n.dataset.radixToastAnnounceAlt;
          r && t.push(r);
        } else
          t.push(...Jy(n));
    }
  }), t;
}
const z2 = /* @__PURE__ */ b({
  __name: "ToastAnnounce",
  setup(e) {
    const t = uu(), n = BC(1e3), a = O(!1);
    return dy(() => {
      a.value = !0;
    }), (o, r) => l(n) || a.value ? (g(), C(l(zs), { key: 0 }, {
      default: y(() => [
        Re(Ve(l(t).label.value) + " ", 1),
        w(o.$slots, "default")
      ]),
      _: 3
    })) : Pe("", !0);
  }
}), [H2, U2] = Ye("ToastRoot"), j2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: !1 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = fe(), s = uu(), i = O(null), u = O(null), d = E(
      () => typeof n.duration == "number" ? n.duration : s.duration.value
    ), c = O(0), f = O(d.value), p = O(0), v = O(d.value), m = dy(() => {
      const S = (/* @__PURE__ */ new Date()).getTime() - c.value;
      v.value = Math.max(f.value - S, 0);
    }, { fpsLimit: 60 });
    function h(S) {
      S <= 0 || S === Number.POSITIVE_INFINITY || ia && (window.clearTimeout(p.value), c.value = (/* @__PURE__ */ new Date()).getTime(), p.value = window.setTimeout(_, S));
    }
    function _() {
      var S, $;
      (S = r.value) != null && S.contains(It()) && (($ = s.viewport.value) == null || $.focus()), s.isClosePausedRef.value = !1, a("close");
    }
    const x = E(() => r.value ? Jy(r.value) : null);
    if (n.type && !["foreground", "background"].includes(n.type)) {
      const S = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(S);
    }
    return Me((S) => {
      const $ = s.viewport.value;
      if ($) {
        const D = () => {
          h(f.value), m.resume(), a("resume");
        }, B = () => {
          const k = (/* @__PURE__ */ new Date()).getTime() - c.value;
          f.value = f.value - k, window.clearTimeout(p.value), m.pause(), a("pause");
        };
        return $.addEventListener(lc, B), $.addEventListener(ic, D), () => {
          $.removeEventListener(lc, B), $.removeEventListener(ic, D);
        };
      }
    }), ce(() => [n.open, d.value], () => {
      f.value = d.value, n.open && !s.isClosePausedRef.value && h(d.value);
    }, { immediate: !0 }), bf("Escape", (S) => {
      a("escapeKeyDown", S), S.defaultPrevented || (s.isFocusedToastEscapeKeyDownRef.value = !0, _());
    }), be(() => {
      s.onToastAdd();
    }), Ze(() => {
      s.onToastRemove();
    }), U2({ onClose: _ }), (S, $) => (g(), U(Fe, null, [
      x.value ? (g(), C(z2, {
        key: 0,
        role: "alert",
        "aria-live": S.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": "true"
      }, {
        default: y(() => [
          Re(Ve(x.value), 1)
        ]),
        _: 1
      }, 8, ["aria-live"])) : Pe("", !0),
      l(s).viewport.value ? (g(), C(Co, {
        key: 1,
        to: l(s).viewport.value
      }, [
        N(l(Se), A({
          ref: l(o),
          role: "alert",
          "aria-live": "off",
          "aria-atomic": "true",
          tabindex: "0",
          "data-radix-vue-collection-item": ""
        }, S.$attrs, {
          as: S.as,
          "as-child": S.asChild,
          "data-state": S.open ? "open" : "closed",
          "data-swipe-direction": l(s).swipeDirection.value,
          style: { userSelect: "none", touchAction: "none" },
          onPointerdown: $[0] || ($[0] = We((D) => {
            i.value = { x: D.clientX, y: D.clientY };
          }, ["left"])),
          onPointermove: $[1] || ($[1] = (D) => {
            if (!i.value) return;
            const B = D.clientX - i.value.x, k = D.clientY - i.value.y, M = !!u.value, I = ["left", "right"].includes(l(s).swipeDirection.value), T = ["left", "up"].includes(l(s).swipeDirection.value) ? Math.min : Math.max, P = I ? T(0, B) : 0, q = I ? 0 : T(0, k), R = D.pointerType === "touch" ? 10 : 2, Q = { x: P, y: q }, ee = { originalEvent: D, delta: Q };
            M ? (u.value = Q, l(pl)(l(F2), (K) => a("swipeMove", K), ee)) : l(nm)(Q, l(s).swipeDirection.value, R) ? (u.value = Q, l(pl)(l(q2), (K) => a("swipeStart", K), ee), D.target.setPointerCapture(D.pointerId)) : (Math.abs(B) > R || Math.abs(k) > R) && (i.value = null);
          }),
          onPointerup: $[2] || ($[2] = (D) => {
            const B = u.value, k = D.target;
            if (k.hasPointerCapture(D.pointerId) && k.releasePointerCapture(D.pointerId), u.value = null, i.value = null, B) {
              const M = D.currentTarget, I = { originalEvent: D, delta: B };
              l(nm)(B, l(s).swipeDirection.value, l(s).swipeThreshold.value) ? l(pl)(l(N2), (T) => a("swipeEnd", T), I) : l(pl)(l(V2), (T) => a("swipeCancel", T), I), M == null || M.addEventListener("click", (T) => T.preventDefault(), {
                once: !0
              });
            }
          })
        }), {
          default: y(() => [
            w(S.$slots, "default", {
              remaining: v.value,
              duration: d.value
            })
          ]),
          _: 3
        }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
      ], 8, ["to"])) : Pe("", !0)
    ], 64));
  }
}), W2 = /* @__PURE__ */ b({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean, default: !0 },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: void 0 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o } = fe(), r = pt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (s, i) => (g(), C(l(On), {
      present: s.forceMount || l(r)
    }, {
      default: y(() => [
        N(j2, A({
          ref: l(o),
          open: l(r),
          type: s.type,
          as: s.as,
          "as-child": s.asChild,
          duration: s.duration
        }, s.$attrs, {
          onClose: i[0] || (i[0] = (u) => r.value = !1),
          onPause: i[1] || (i[1] = (u) => a("pause")),
          onResume: i[2] || (i[2] = (u) => a("resume")),
          onEscapeKeyDown: i[3] || (i[3] = (u) => a("escapeKeyDown", u)),
          onSwipeStart: i[4] || (i[4] = (u) => {
            a("swipeStart", u), u.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: i[5] || (i[5] = (u) => {
            const { x: d, y: c } = u.detail.delta, f = u.currentTarget;
            f.setAttribute("data-swipe", "move"), f.style.setProperty("--radix-toast-swipe-move-x", `${d}px`), f.style.setProperty("--radix-toast-swipe-move-y", `${c}px`);
          }),
          onSwipeCancel: i[6] || (i[6] = (u) => {
            const d = u.currentTarget;
            d.setAttribute("data-swipe", "cancel"), d.style.removeProperty("--radix-toast-swipe-move-x"), d.style.removeProperty("--radix-toast-swipe-move-y"), d.style.removeProperty("--radix-toast-swipe-end-x"), d.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: i[7] || (i[7] = (u) => {
            const { x: d, y: c } = u.detail.delta, f = u.currentTarget;
            f.setAttribute("data-swipe", "end"), f.style.removeProperty("--radix-toast-swipe-move-x"), f.style.removeProperty("--radix-toast-swipe-move-y"), f.style.setProperty("--radix-toast-swipe-end-x", `${d}px`), f.style.setProperty("--radix-toast-swipe-end-y", `${c}px`), r.value = !1;
          })
        }), {
          default: y(({ remaining: u, duration: d }) => [
            w(s.$slots, "default", {
              remaining: u,
              duration: d,
              open: l(r)
            })
          ]),
          _: 3
        }, 16, ["open", "type", "as", "as-child", "duration"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Zy = /* @__PURE__ */ b({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    return (t, n) => (g(), C(l(Se), {
      as: t.as,
      "as-child": t.asChild,
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": t.altText || void 0
    }, {
      default: y(() => [
        w(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-radix-toast-announce-alt"]));
  }
}), Qy = /* @__PURE__ */ b({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = H2(), { forwardRef: a } = fe();
    return (o, r) => (g(), C(Zy, { "as-child": "" }, {
      default: y(() => [
        N(l(Se), A(t, {
          ref: l(a),
          type: o.as === "button" ? "button" : void 0,
          onClick: r[0] || (r[0] = (s) => l(n).onClose())
        }), {
          default: y(() => [
            w(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }));
  }
}), K2 = /* @__PURE__ */ b({
  __name: "ToastAction",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    if (!e.altText)
      throw new Error("Missing prop `altText` expected on `ToastAction`");
    const { forwardRef: t } = fe();
    return (n, a) => n.altText ? (g(), C(Zy, {
      key: 0,
      "alt-text": n.altText,
      "as-child": ""
    }, {
      default: y(() => [
        N(Qy, {
          ref: l(t),
          as: n.as,
          "as-child": n.asChild
        }, {
          default: y(() => [
            w(n.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child"])
      ]),
      _: 3
    }, 8, ["alt-text"])) : Pe("", !0);
  }
}), am = /* @__PURE__ */ b({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(e, { emit: t }) {
    const n = t, a = uu();
    return (o, r) => (g(), C(l(zs), {
      "aria-hidden": "true",
      tabindex: "0",
      style: { position: "fixed" },
      onFocus: r[0] || (r[0] = (s) => {
        var i;
        const u = s.relatedTarget;
        !((i = l(a).viewport.value) != null && i.contains(u)) && n("focusFromOutsideViewport");
      })
    }, {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }));
  }
}), G2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => ["F8"] },
    label: { type: [String, Function], default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(e) {
    const t = e, { hotkey: n, label: a } = Be(t), { forwardRef: o, currentElement: r } = fe(), { createCollection: s } = xr(), i = s(r), u = uu(), d = E(() => u.toastCount.value > 0), c = O(), f = O(), p = E(() => n.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    bf(n.value, () => {
      r.value.focus();
    }), be(() => {
      u.onViewportChange(r.value);
    }), Me((m) => {
      const h = r.value;
      if (d.value && h) {
        const _ = () => {
          if (!u.isClosePausedRef.value) {
            const B = new CustomEvent(lc);
            h.dispatchEvent(B), u.isClosePausedRef.value = !0;
          }
        }, x = () => {
          if (u.isClosePausedRef.value) {
            const B = new CustomEvent(ic);
            h.dispatchEvent(B), u.isClosePausedRef.value = !1;
          }
        }, S = (B) => {
          !h.contains(B.relatedTarget) && x();
        }, $ = () => {
          h.contains(It()) || x();
        }, D = (B) => {
          var k, M, I;
          const T = B.altKey || B.ctrlKey || B.metaKey;
          if (B.key === "Tab" && !T) {
            const P = It(), q = B.shiftKey;
            if (B.target === h && q) {
              (k = c.value) == null || k.focus();
              return;
            }
            const R = v({ tabbingDirection: q ? "backwards" : "forwards" }), Q = R.findIndex((ee) => ee === P);
            Vl(R.slice(Q + 1)) ? B.preventDefault() : q ? (M = c.value) == null || M.focus() : (I = f.value) == null || I.focus();
          }
        };
        h.addEventListener("focusin", _), h.addEventListener("focusout", S), h.addEventListener("pointermove", _), h.addEventListener("pointerleave", $), h.addEventListener("keydown", D), window.addEventListener("blur", _), window.addEventListener("focus", x), m(() => {
          h.removeEventListener("focusin", _), h.removeEventListener("focusout", S), h.removeEventListener("pointermove", _), h.removeEventListener("pointerleave", $), h.removeEventListener("keydown", D), window.removeEventListener("blur", _), window.removeEventListener("focus", x);
        });
      }
    });
    function v({ tabbingDirection: m }) {
      const h = i.value.map((_) => {
        const x = [_, ...Ef(_)];
        return m === "forwards" ? x : x.reverse();
      });
      return (m === "forwards" ? h.reverse() : h).flat();
    }
    return (m, h) => (g(), C(l(wS), {
      role: "region",
      "aria-label": typeof l(a) == "string" ? l(a).replace("{hotkey}", p.value) : l(a)(p.value),
      tabindex: "-1",
      style: vt({
        // incase list has size when empty (e.g. padding), we remove pointer events so
        // it doesn't prevent interactions with page elements that it overlays
        pointerEvents: d.value ? void 0 : "none"
      })
    }, {
      default: y(() => [
        d.value ? (g(), C(am, {
          key: 0,
          ref: (_) => {
            c.value = l(kn)(_);
          },
          onFocusFromOutsideViewport: h[0] || (h[0] = () => {
            const _ = v({
              tabbingDirection: "forwards"
            });
            l(Vl)(_);
          })
        }, null, 512)) : Pe("", !0),
        N(l(Se), A({
          ref: l(o),
          tabindex: "-1",
          as: m.as,
          "as-child": m.asChild
        }, m.$attrs), {
          default: y(() => [
            w(m.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child"]),
        d.value ? (g(), C(am, {
          key: 1,
          ref: (_) => {
            f.value = l(kn)(_);
          },
          onFocusFromOutsideViewport: h[1] || (h[1] = () => {
            const _ = v({
              tabbingDirection: "backwards"
            });
            l(Vl)(_);
          })
        }, null, 512)) : Pe("", !0)
      ]),
      _: 3
    }, 8, ["aria-label", "style"]));
  }
}), Y2 = /* @__PURE__ */ b({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(Se), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), X2 = /* @__PURE__ */ b({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return fe(), (n, a) => (g(), C(l(Se), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), eb = "tooltip.open", [Uf, J2] = Ye("TooltipProvider"), tb = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: !1 },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, { delayDuration: n, skipDelayDuration: a, disableHoverableContent: o, disableClosingTrigger: r, ignoreNonKeyboardFocus: s, disabled: i } = Be(t);
    fe();
    const u = O(!0), d = O(!1), { start: c, stop: f } = yf(() => {
      u.value = !0;
    }, a, { immediate: !1 });
    return J2({
      isOpenDelayed: u,
      delayDuration: n,
      onOpen() {
        f(), u.value = !1;
      },
      onClose() {
        c();
      },
      isPointerInTransitRef: d,
      disableHoverableContent: o,
      disableClosingTrigger: r,
      disabled: i,
      ignoreNonKeyboardFocus: s
    }), (p, v) => w(p.$slots, "default");
  }
}), [du, Z2] = Ye("TooltipRoot"), Q2 = /* @__PURE__ */ b({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    fe();
    const o = Uf(), r = E(() => n.disableHoverableContent ?? o.disableHoverableContent.value), s = E(() => n.disableClosingTrigger ?? o.disableClosingTrigger.value), i = E(() => n.disabled ?? o.disabled.value), u = E(() => n.delayDuration ?? o.delayDuration.value), d = E(() => n.ignoreNonKeyboardFocus ?? o.ignoreNonKeyboardFocus.value), c = pt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    ce(c, ($) => {
      o.onClose && ($ ? (o.onOpen(), document.dispatchEvent(new CustomEvent(eb))) : o.onClose());
    });
    const f = O(!1), p = O(), v = E(() => c.value ? f.value ? "delayed-open" : "instant-open" : "closed"), { start: m, stop: h } = yf(() => {
      f.value = !0, c.value = !0;
    }, u, { immediate: !1 });
    function _() {
      h(), f.value = !1, c.value = !0;
    }
    function x() {
      h(), c.value = !1;
    }
    function S() {
      m();
    }
    return Z2({
      contentId: "",
      open: c,
      stateAttribute: v,
      trigger: p,
      onTriggerChange($) {
        p.value = $;
      },
      onTriggerEnter() {
        o.isOpenDelayed.value ? S() : _();
      },
      onTriggerLeave() {
        r.value ? x() : h();
      },
      onOpen: _,
      onClose: x,
      disableHoverableContent: r,
      disableClosingTrigger: s,
      disabled: i,
      ignoreNonKeyboardFocus: d
    }), ($, D) => (g(), C(l($r), null, {
      default: y(() => [
        w($.$slots, "default", { open: l(c) })
      ]),
      _: 3
    }));
  }
}), eP = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = du(), a = Uf();
    n.contentId || (n.contentId = Ot(void 0, "radix-vue-tooltip-content"));
    const { forwardRef: o, currentElement: r } = fe(), s = O(!1), i = O(!1), u = E(() => n.disabled.value ? {} : {
      click: h,
      focus: v,
      pointermove: f,
      pointerleave: p,
      pointerdown: c,
      blur: m
    });
    be(() => {
      n.onTriggerChange(r.value);
    });
    function d() {
      setTimeout(() => {
        s.value = !1;
      }, 1);
    }
    function c() {
      s.value = !0, document.addEventListener("pointerup", d, { once: !0 });
    }
    function f(_) {
      _.pointerType !== "touch" && !i.value && !a.isPointerInTransitRef.value && (n.onTriggerEnter(), i.value = !0);
    }
    function p() {
      n.onTriggerLeave(), i.value = !1;
    }
    function v(_) {
      var x, S;
      s.value || n.ignoreNonKeyboardFocus.value && !((S = (x = _.target).matches) != null && S.call(x, ":focus-visible")) || n.onOpen();
    }
    function m() {
      n.onClose();
    }
    function h() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (_, x) => (g(), C(l(Ls), { "as-child": "" }, {
      default: y(() => [
        N(l(Se), A({
          ref: l(o),
          "aria-describedby": l(n).open.value ? l(n).contentId : void 0,
          "data-state": l(n).stateAttribute.value,
          as: _.as,
          "as-child": t.asChild,
          "data-grace-area-trigger": ""
        }, d1(u.value)), {
          default: y(() => [
            w(_.$slots, "default")
          ]),
          _: 3
        }, 16, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), nb = /* @__PURE__ */ b({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = du(), { forwardRef: r } = fe(), s = Jc(), i = E(() => {
      var c;
      return (c = s.default) == null ? void 0 : c.call(s);
    }), u = E(() => {
      var c;
      if (n.ariaLabel)
        return n.ariaLabel;
      let f = "";
      function p(v) {
        typeof v.children == "string" && v.type !== Zc ? f += v.children : Array.isArray(v.children) && v.children.forEach((m) => p(m));
      }
      return (c = i.value) == null || c.forEach((v) => p(v)), f;
    }), d = E(() => {
      const { ariaLabel: c, ...f } = n;
      return f;
    });
    return be(() => {
      dr(window, "scroll", (c) => {
        const f = c.target;
        f != null && f.contains(o.trigger.value) && o.onClose();
      }), dr(window, eb, o.onClose);
    }), (c, f) => (g(), C(l(Sr), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: f[0] || (f[0] = (p) => a("escapeKeyDown", p)),
      onPointerDownOutside: f[1] || (f[1] = (p) => {
        var v;
        l(o).disableClosingTrigger.value && (v = l(o).trigger.value) != null && v.contains(p.target) && p.preventDefault(), a("pointerDownOutside", p);
      }),
      onFocusOutside: f[2] || (f[2] = We(() => {
      }, ["prevent"])),
      onDismiss: f[3] || (f[3] = (p) => l(o).onClose())
    }, {
      default: y(() => [
        N(l(cr), A({
          ref: l(r),
          "data-state": l(o).stateAttribute.value
        }, { ...c.$attrs, ...d.value }, { style: {
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        } }), {
          default: y(() => [
            w(c.$slots, "default"),
            N(l(zs), {
              id: l(o).contentId,
              role: "tooltip"
            }, {
              default: y(() => [
                Re(Ve(u.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }));
  }
}), tP = /* @__PURE__ */ b({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  setup(e) {
    const t = Rt(e), { forwardRef: n, currentElement: a } = fe(), { trigger: o, onClose: r } = du(), s = Uf(), { isPointerInTransit: i, onPointerExit: u } = VC(o, a);
    return s.isPointerInTransitRef = i, u(() => {
      r();
    }), (d, c) => (g(), C(nb, A({ ref: l(n) }, l(t)), {
      default: y(() => [
        w(d.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nP = /* @__PURE__ */ b({
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = du(), r = Le(n, a), { forwardRef: s } = fe();
    return (i, u) => (g(), C(l(On), {
      present: i.forceMount || l(o).open.value
    }, {
      default: y(() => [
        (g(), C(mt(l(o).disableHoverableContent.value ? nb : tP), A({ ref: l(s) }, l(r)), {
          default: y(() => [
            w(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), aP = /* @__PURE__ */ b({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Cr), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function ab(e) {
  var t, n, a = "";
  if (typeof e == "string" || typeof e == "number") a += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (n = ab(e[t])) && (a && (a += " "), a += n);
  } else for (n in e) e[n] && (a && (a += " "), a += n);
  return a;
}
function ob() {
  for (var e, t, n = 0, a = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = ab(e)) && (a && (a += " "), a += t);
  return a;
}
const jf = "-", oP = (e) => {
  const t = sP(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: a
  } = e;
  return {
    getClassGroupId: (s) => {
      const i = s.split(jf);
      return i[0] === "" && i.length !== 1 && i.shift(), rb(i, t) || rP(s);
    },
    getConflictingClassGroupIds: (s, i) => {
      const u = n[s] || [];
      return i && a[s] ? [...u, ...a[s]] : u;
    }
  };
}, rb = (e, t) => {
  var s;
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], a = t.nextPart.get(n), o = a ? rb(e.slice(1), a) : void 0;
  if (o)
    return o;
  if (t.validators.length === 0)
    return;
  const r = e.join(jf);
  return (s = t.validators.find(({
    validator: i
  }) => i(r))) == null ? void 0 : s.classGroupId;
}, om = /^\[(.+)\]$/, rP = (e) => {
  if (om.test(e)) {
    const t = om.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, sP = (e) => {
  const {
    theme: t,
    prefix: n
  } = e, a = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return iP(Object.entries(e.classGroups), n).forEach(([r, s]) => {
    uc(s, a, r, t);
  }), a;
}, uc = (e, t, n, a) => {
  e.forEach((o) => {
    if (typeof o == "string") {
      const r = o === "" ? t : rm(t, o);
      r.classGroupId = n;
      return;
    }
    if (typeof o == "function") {
      if (lP(o)) {
        uc(o(a), t, n, a);
        return;
      }
      t.validators.push({
        validator: o,
        classGroupId: n
      });
      return;
    }
    Object.entries(o).forEach(([r, s]) => {
      uc(s, rm(t, r), n, a);
    });
  });
}, rm = (e, t) => {
  let n = e;
  return t.split(jf).forEach((a) => {
    n.nextPart.has(a) || n.nextPart.set(a, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(a);
  }), n;
}, lP = (e) => e.isThemeGetter, iP = (e, t) => t ? e.map(([n, a]) => {
  const o = a.map((r) => typeof r == "string" ? t + r : typeof r == "object" ? Object.fromEntries(Object.entries(r).map(([s, i]) => [t + s, i])) : r);
  return [n, o];
}) : e, uP = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  const o = (r, s) => {
    n.set(r, s), t++, t > e && (t = 0, a = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(r) {
      let s = n.get(r);
      if (s !== void 0)
        return s;
      if ((s = a.get(r)) !== void 0)
        return o(r, s), s;
    },
    set(r, s) {
      n.has(r) ? n.set(r, s) : o(r, s);
    }
  };
}, sb = "!", dP = (e) => {
  const {
    separator: t,
    experimentalParseClassName: n
  } = e, a = t.length === 1, o = t[0], r = t.length, s = (i) => {
    const u = [];
    let d = 0, c = 0, f;
    for (let _ = 0; _ < i.length; _++) {
      let x = i[_];
      if (d === 0) {
        if (x === o && (a || i.slice(_, _ + r) === t)) {
          u.push(i.slice(c, _)), c = _ + r;
          continue;
        }
        if (x === "/") {
          f = _;
          continue;
        }
      }
      x === "[" ? d++ : x === "]" && d--;
    }
    const p = u.length === 0 ? i : i.substring(c), v = p.startsWith(sb), m = v ? p.substring(1) : p, h = f && f > c ? f - c : void 0;
    return {
      modifiers: u,
      hasImportantModifier: v,
      baseClassName: m,
      maybePostfixModifierPosition: h
    };
  };
  return n ? (i) => n({
    className: i,
    parseClassName: s
  }) : s;
}, cP = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let n = [];
  return e.forEach((a) => {
    a[0] === "[" ? (t.push(...n.sort(), a), n = []) : n.push(a);
  }), t.push(...n.sort()), t;
}, fP = (e) => ({
  cache: uP(e.cacheSize),
  parseClassName: dP(e),
  ...oP(e)
}), pP = /\s+/, vP = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: a,
    getConflictingClassGroupIds: o
  } = t, r = [], s = e.trim().split(pP);
  let i = "";
  for (let u = s.length - 1; u >= 0; u -= 1) {
    const d = s[u], {
      modifiers: c,
      hasImportantModifier: f,
      baseClassName: p,
      maybePostfixModifierPosition: v
    } = n(d);
    let m = !!v, h = a(m ? p.substring(0, v) : p);
    if (!h) {
      if (!m) {
        i = d + (i.length > 0 ? " " + i : i);
        continue;
      }
      if (h = a(p), !h) {
        i = d + (i.length > 0 ? " " + i : i);
        continue;
      }
      m = !1;
    }
    const _ = cP(c).join(":"), x = f ? _ + sb : _, S = x + h;
    if (r.includes(S))
      continue;
    r.push(S);
    const $ = o(h, m);
    for (let D = 0; D < $.length; ++D) {
      const B = $[D];
      r.push(x + B);
    }
    i = d + (i.length > 0 ? " " + i : i);
  }
  return i;
};
function mP() {
  let e = 0, t, n, a = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = lb(t)) && (a && (a += " "), a += n);
  return a;
}
const lb = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let a = 0; a < e.length; a++)
    e[a] && (t = lb(e[a])) && (n && (n += " "), n += t);
  return n;
};
function hP(e, ...t) {
  let n, a, o, r = s;
  function s(u) {
    const d = t.reduce((c, f) => f(c), e());
    return n = fP(d), a = n.cache.get, o = n.cache.set, r = i, i(u);
  }
  function i(u) {
    const d = a(u);
    if (d)
      return d;
    const c = vP(u, n);
    return o(u, c), c;
  }
  return function() {
    return r(mP.apply(null, arguments));
  };
}
const ft = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, ib = /^\[(?:([a-z-]+):)?(.+)\]$/i, gP = /^\d+\/\d+$/, yP = /* @__PURE__ */ new Set(["px", "full", "screen"]), bP = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, _P = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, wP = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, xP = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, CP = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, fa = (e) => er(e) || yP.has(e) || gP.test(e), Ra = (e) => Dr(e, "length", kP), er = (e) => !!e && !Number.isNaN(Number(e)), md = (e) => Dr(e, "number", er), Vr = (e) => !!e && Number.isInteger(Number(e)), SP = (e) => e.endsWith("%") && er(e.slice(0, -1)), Ue = (e) => ib.test(e), qa = (e) => bP.test(e), $P = /* @__PURE__ */ new Set(["length", "size", "percentage"]), BP = (e) => Dr(e, $P, ub), PP = (e) => Dr(e, "position", ub), EP = /* @__PURE__ */ new Set(["image", "url"]), DP = (e) => Dr(e, EP, TP), MP = (e) => Dr(e, "", OP), Nr = () => !0, Dr = (e, t, n) => {
  const a = ib.exec(e);
  return a ? a[1] ? typeof t == "string" ? a[1] === t : t.has(a[1]) : n(a[2]) : !1;
}, kP = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  _P.test(e) && !wP.test(e)
), ub = () => !1, OP = (e) => xP.test(e), TP = (e) => CP.test(e), AP = () => {
  const e = ft("colors"), t = ft("spacing"), n = ft("blur"), a = ft("brightness"), o = ft("borderColor"), r = ft("borderRadius"), s = ft("borderSpacing"), i = ft("borderWidth"), u = ft("contrast"), d = ft("grayscale"), c = ft("hueRotate"), f = ft("invert"), p = ft("gap"), v = ft("gradientColorStops"), m = ft("gradientColorStopPositions"), h = ft("inset"), _ = ft("margin"), x = ft("opacity"), S = ft("padding"), $ = ft("saturate"), D = ft("scale"), B = ft("sepia"), k = ft("skew"), M = ft("space"), I = ft("translate"), T = () => ["auto", "contain", "none"], P = () => ["auto", "hidden", "clip", "visible", "scroll"], q = () => ["auto", Ue, t], R = () => [Ue, t], Q = () => ["", fa, Ra], ee = () => ["auto", er, Ue], K = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], W = () => ["solid", "dashed", "dotted", "double", "none"], j = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], J = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], z = () => ["", "0", Ue], Y = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Z = () => [er, Ue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Nr],
      spacing: [fa, Ra],
      blur: ["none", "", qa, Ue],
      brightness: Z(),
      borderColor: [e],
      borderRadius: ["none", "", "full", qa, Ue],
      borderSpacing: R(),
      borderWidth: Q(),
      contrast: Z(),
      grayscale: z(),
      hueRotate: Z(),
      invert: z(),
      gap: R(),
      gradientColorStops: [e],
      gradientColorStopPositions: [SP, Ra],
      inset: q(),
      margin: q(),
      opacity: Z(),
      padding: R(),
      saturate: Z(),
      scale: Z(),
      sepia: z(),
      skew: Z(),
      space: R(),
      translate: R()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [qa]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": Y()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": Y()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...K(), Ue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: P()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": P()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": P()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: T()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": T()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": T()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [h]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [h]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [h]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [h]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [h]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [h]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [h]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [h]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [h]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Vr, Ue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: q()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: z()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: z()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Vr, Ue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Nr]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Vr, Ue]
        }, Ue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": ee()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": ee()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Nr]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Vr, Ue]
        }, Ue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": ee()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": ee()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [p]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [p]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [p]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...J()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...J(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...J(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [S]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [S]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [S]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [S]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [S]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [S]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [S]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [S]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [S]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [_]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [_]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [_]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [_]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [_]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [_]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [_]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [_]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [_]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [M]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [M]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ue, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ue, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ue, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [qa]
        }, qa]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ue, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ue, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ue, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ue, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", qa, Ra]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", md]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Nr]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", er, md]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", fa, Ue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [x]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [x]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...W(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", fa, Ra]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", fa, Ue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: R()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [x]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...K(), PP]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", BP]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, DP]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [m]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [m]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [m]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [v]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [v]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [v]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [r]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [r]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [r]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [r]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [r]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [r]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [r]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [r]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [r]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [r]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [r]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [r]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [r]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [r]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [r]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [i]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [i]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [i]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [i]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [i]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [i]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [i]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [i]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [i]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [x]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...W(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [i]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [i]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [x]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: W()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [o]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [o]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [o]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [o]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [o]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [o]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [o]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [o]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [o]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [o]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...W()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [fa, Ue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [fa, Ra]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: Q()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [x]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [fa, Ra]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", qa, MP]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Nr]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [x]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...j(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": j()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [a]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", qa, Ue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [d]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [c]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [f]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [$]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [B]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [a]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [d]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [c]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [f]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [x]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [$]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [B]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [s]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [s]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [s]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Z()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Z()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [D]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [D]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [D]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Vr, Ue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [I]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [I]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [k]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [k]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": R()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": R()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": R()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": R()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": R()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": R()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": R()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": R()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": R()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": R()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": R()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": R()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": R()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": R()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": R()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": R()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": R()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": R()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [fa, Ra, md]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, IP = /* @__PURE__ */ hP(AP);
function F(...e) {
  return IP(ob(e));
}
function FU(e, t) {
  t.value = typeof e == "function" ? e(t.value) : e;
}
function VU(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = vn(a, s);
    if (i || i === null) return i;
    throw new Error(
      `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`
    );
  }, (s) => (Mn(a, s), s)];
}
var sm;
const db = typeof window < "u", RP = (e) => typeof e < "u", qP = (e) => typeof e == "function", FP = (e) => typeof e == "string", dc = () => {
};
db && ((sm = window == null ? void 0 : window.navigator) != null && sm.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function cb(e) {
  return typeof e == "function" ? e() : l(e);
}
function VP(e) {
  return e;
}
function fb(e) {
  return As() ? (Is(e), !0) : !1;
}
function NP(e) {
  const t = Symbol("InjectionState");
  return [(...o) => {
    const r = e(...o);
    return Mn(t, r), r;
  }, () => vn(t)];
}
function LP(e) {
  if (!ht(e))
    return Qt(e);
  const t = new Proxy({}, {
    get(n, a, o) {
      return l(Reflect.get(e.value, a, o));
    },
    set(n, a, o) {
      return ht(e.value[a]) && !ht(o) ? e.value[a].value = o : e.value[a] = o, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Qt(t);
}
function zP(e) {
  return LP(E(e));
}
function ve(e, ...t) {
  const n = t.flat();
  return zP(() => Object.fromEntries(Object.entries(Be(e)).filter((a) => !n.includes(a[0]))));
}
function HP(e) {
  return typeof e == "function" ? E(e) : O(e);
}
function UP(e, t = !0) {
  ct() ? be(e) : t ? e() : he(e);
}
function jP(e) {
  var t;
  const n = cb(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const Wf = db ? window : void 0;
function Xr(...e) {
  let t, n, a, o;
  if (FP(e[0]) || Array.isArray(e[0]) ? ([n, a, o] = e, t = Wf) : [t, n, a, o] = e, !t)
    return dc;
  Array.isArray(n) || (n = [n]), Array.isArray(a) || (a = [a]);
  const r = [], s = () => {
    r.forEach((c) => c()), r.length = 0;
  }, i = (c, f, p, v) => (c.addEventListener(f, p, v), () => c.removeEventListener(f, p, v)), u = ce(() => [jP(t), cb(o)], ([c, f]) => {
    s(), c && r.push(...n.flatMap((p) => a.map((v) => i(c, p, v, f))));
  }, { immediate: !0, flush: "post" }), d = () => {
    u(), s();
  };
  return fb(d), d;
}
function WP(e, t = !1) {
  const n = O(), a = () => n.value = !!e();
  return a(), UP(a, t), n;
}
function cc(e, t = {}) {
  const { window: n = Wf } = t, a = WP(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let o;
  const r = O(!1), s = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", i) : o.removeListener(i));
  }, i = () => {
    a.value && (s(), o = n.matchMedia(HP(e).value), r.value = o.matches, "addEventListener" in o ? o.addEventListener("change", i) : o.addListener(i));
  };
  return Me(i), fb(() => s()), r;
}
function KP(e) {
  return JSON.parse(JSON.stringify(e));
}
const lm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, im = "__vueuse_ssr_handlers__";
lm[im] = lm[im] || {};
var ga;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(ga || (ga = {}));
function GP(e, t = {}) {
  const {
    threshold: n = 50,
    onSwipe: a,
    onSwipeEnd: o,
    onSwipeStart: r,
    passive: s = !0,
    window: i = Wf
  } = t, u = Qt({ x: 0, y: 0 }), d = Qt({ x: 0, y: 0 }), c = E(() => u.x - d.x), f = E(() => u.y - d.y), { max: p, abs: v } = Math, m = E(() => p(v(c.value), v(f.value)) >= n), h = O(!1), _ = E(() => m.value ? v(c.value) > v(f.value) ? c.value > 0 ? ga.LEFT : ga.RIGHT : f.value > 0 ? ga.UP : ga.DOWN : ga.NONE), x = (T) => [T.touches[0].clientX, T.touches[0].clientY], S = (T, P) => {
    u.x = T, u.y = P;
  }, $ = (T, P) => {
    d.x = T, d.y = P;
  };
  let D;
  const B = YP(i == null ? void 0 : i.document);
  s ? D = B ? { passive: !0 } : { capture: !1 } : D = B ? { passive: !1, capture: !0 } : { capture: !0 };
  const k = (T) => {
    h.value && (o == null || o(T, _.value)), h.value = !1;
  }, M = [
    Xr(e, "touchstart", (T) => {
      D.capture && !D.passive && T.preventDefault();
      const [P, q] = x(T);
      S(P, q), $(P, q), r == null || r(T);
    }, D),
    Xr(e, "touchmove", (T) => {
      const [P, q] = x(T);
      $(P, q), !h.value && m.value && (h.value = !0), h.value && (a == null || a(T));
    }, D),
    Xr(e, "touchend", k, D),
    Xr(e, "touchcancel", k, D)
  ];
  return {
    isPassiveEventSupported: B,
    isSwiping: h,
    direction: _,
    coordsStart: u,
    coordsEnd: d,
    lengthX: c,
    lengthY: f,
    stop: () => M.forEach((T) => T())
  };
}
function YP(e) {
  if (!e)
    return !1;
  let t = !1;
  const n = {
    get passive() {
      return t = !0, !1;
    }
  };
  return e.addEventListener("x", dc, n), e.removeEventListener("x", dc), t;
}
var XP = Object.defineProperty, um = Object.getOwnPropertySymbols, JP = Object.prototype.hasOwnProperty, ZP = Object.prototype.propertyIsEnumerable, dm = (e, t, n) => t in e ? XP(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, QP = (e, t) => {
  for (var n in t || (t = {}))
    JP.call(t, n) && dm(e, n, t[n]);
  if (um)
    for (var n of um(t))
      ZP.call(t, n) && dm(e, n, t[n]);
  return e;
};
const eE = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
QP({
  linear: VP
}, eE);
function Kf(e, t, n, a = {}) {
  var o, r, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f
  } = a, p = ct(), v = n || (p == null ? void 0 : p.emit) || ((o = p == null ? void 0 : p.$emit) == null ? void 0 : o.bind(p)) || ((s = (r = p == null ? void 0 : p.proxy) == null ? void 0 : r.$emit) == null ? void 0 : s.bind(p == null ? void 0 : p.proxy));
  let m = d;
  t || (t = "modelValue"), m = d || m || `update:${t.toString()}`;
  const h = (x) => i ? qP(i) ? i(x) : KP(x) : x, _ = () => RP(e[t]) ? h(e[t]) : f;
  if (u) {
    const x = _(), S = O(x);
    return ce(() => e[t], ($) => S.value = h($)), ce(S, ($) => {
      ($ !== e[t] || c) && v(m, $);
    }, { deep: c }), S;
  } else
    return E({
      get() {
        return _();
      },
      set(x) {
        v(m, x);
      }
    });
}
function NU() {
  const e = cc("(max-width: 768px)"), t = cc("(min-width: 769px) and (max-width: 1024px)"), n = O(!1);
  be(() => {
    n.value = "ontouchstart" in window || navigator.maxTouchPoints > 0;
  });
  const a = E(() => e.value || t.value);
  return {
    isMobile: e,
    isTablet: t,
    isTouchDevice: n,
    isSmallScreen: a
  };
}
function LU(e, t = {}) {
  const { threshold: n = 50, enabled: a = !0, onSwipeLeft: o, onSwipeRight: r } = t, { direction: s, lengthX: i } = GP(e, {
    passive: !0,
    onSwipeEnd() {
      a && Math.abs(i.value) >= n && (s.value === ga.LEFT && o ? o() : s.value === ga.RIGHT && r && r());
    }
  });
  return {
    direction: s,
    lengthX: i
  };
}
function zU() {
  const e = O(!0);
  let t = 0, n = !1;
  const a = () => {
    n || (window.requestAnimationFrame(() => {
      const o = window.scrollY, r = o - t;
      r > 10 && o > 100 ? e.value = !1 : r < -10 && (e.value = !0), t = o, n = !1;
    }), n = !0);
  };
  return be(() => {
    window.addEventListener("scroll", a, { passive: !0 });
  }), Ze(() => {
    window.removeEventListener("scroll", a);
  }), {
    isVisible: e
  };
}
const tE = /* @__PURE__ */ b({
  __name: "AlertDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(LS), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), HU = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(zS), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nE = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(HS), null, {
      default: y(() => [
        N(l(KS), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(WS), A(l(r), {
          class: l(F)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            w(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), aE = /* @__PURE__ */ b({
  __name: "AlertDialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex flex-col gap-y-2 text-center sm:text-left", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), oE = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(YS), A(n.value, {
      class: l(F)("text-lg font-semibold", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rE = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(XS), A(n.value, {
      class: l(F)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sE = /* @__PURE__ */ b({
  __name: "AlertDialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), cm = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, fm = ob, en = (e, t) => (n) => {
  var a;
  if ((t == null ? void 0 : t.variants) == null) return fm(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: o, defaultVariants: r } = t, s = Object.keys(o).map((d) => {
    const c = n == null ? void 0 : n[d], f = r == null ? void 0 : r[d];
    if (c === null) return null;
    const p = cm(c) || cm(f);
    return o[d][p];
  }), i = n && Object.entries(n).reduce((d, c) => {
    let [f, p] = c;
    return p === void 0 || (d[f] = p), d;
  }, {}), u = t == null || (a = t.compoundVariants) === null || a === void 0 ? void 0 : a.reduce((d, c) => {
    let { class: f, className: p, ...v } = c;
    return Object.entries(v).every((m) => {
      let [h, _] = m;
      return Array.isArray(_) ? _.includes({
        ...r,
        ...i
      }[h]) : {
        ...r,
        ...i
      }[h] === _;
    }) ? [
      ...d,
      f,
      p
    ] : d;
  }, []);
  return fm(e, s, u, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
};
function pm(e) {
  return typeof e == "string" ? `'${e}'` : new lE().serialize(e);
}
const lE = /* @__PURE__ */ function() {
  var t;
  class e {
    constructor() {
      mv(this, t, /* @__PURE__ */ new Map());
    }
    compare(a, o) {
      const r = typeof a, s = typeof o;
      return r === "string" && s === "string" ? a.localeCompare(o) : r === "number" && s === "number" ? a - o : String.prototype.localeCompare.call(this.serialize(a, !0), this.serialize(o, !0));
    }
    serialize(a, o) {
      if (a === null) return "null";
      switch (typeof a) {
        case "string":
          return o ? a : `'${a}'`;
        case "bigint":
          return `${a}n`;
        case "object":
          return this.$object(a);
        case "function":
          return this.$function(a);
      }
      return String(a);
    }
    serializeObject(a) {
      const o = Object.prototype.toString.call(a);
      if (o !== "[object Object]") return this.serializeBuiltInType(o.length < 10 ? `unknown:${o}` : o.slice(8, -1), a);
      const r = a.constructor, s = r === Object || r === void 0 ? "" : r.name;
      if (s !== "" && globalThis[s] === r) return this.serializeBuiltInType(s, a);
      if (typeof a.toJSON == "function") {
        const i = a.toJSON();
        return s + (i !== null && typeof i == "object" ? this.$object(i) : `(${this.serialize(i)})`);
      }
      return this.serializeObjectEntries(s, Object.entries(a));
    }
    serializeBuiltInType(a, o) {
      const r = this["$" + a];
      if (r) return r.call(this, o);
      if (typeof (o == null ? void 0 : o.entries) == "function") return this.serializeObjectEntries(a, o.entries());
      throw new Error(`Cannot serialize ${a}`);
    }
    serializeObjectEntries(a, o) {
      const r = Array.from(o).sort((i, u) => this.compare(i[0], u[0]));
      let s = `${a}{`;
      for (let i = 0; i < r.length; i++) {
        const [u, d] = r[i];
        s += `${this.serialize(u, !0)}:${this.serialize(d)}`, i < r.length - 1 && (s += ",");
      }
      return s + "}";
    }
    $object(a) {
      let o = qr(this, t).get(a);
      return o === void 0 && (qr(this, t).set(a, `#${qr(this, t).size}`), o = this.serializeObject(a), qr(this, t).set(a, o)), o;
    }
    $function(a) {
      const o = Function.prototype.toString.call(a);
      return o.slice(-15) === "[native code] }" ? `${a.name || ""}()[native]` : `${a.name}(${a.length})${o.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(a) {
      let o = "[";
      for (let r = 0; r < a.length; r++) o += this.serialize(a[r]), r < a.length - 1 && (o += ",");
      return o + "]";
    }
    $Date(a) {
      try {
        return `Date(${a.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(a) {
      return `ArrayBuffer[${new Uint8Array(a).join(",")}]`;
    }
    $Set(a) {
      return `Set${this.$Array(Array.from(a).sort((o, r) => this.compare(o, r)))}`;
    }
    $Map(a) {
      return this.serializeObjectEntries("Map", a.entries());
    }
  }
  t = new WeakMap();
  for (const n of ["Error", "RegExp", "URL"]) e.prototype["$" + n] = function(a) {
    return `${n}(${a})`;
  };
  for (const n of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + n] = function(a) {
    return `${n}[${a.join(",")}]`;
  };
  for (const n of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + n] = function(a) {
    return `${n}[${a.join("n,")}${a.length > 0 ? "n" : ""}]`;
  };
  return e;
}();
function ra(e, t) {
  return e === t || pm(e) === pm(t);
}
function iE(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function uE(e, t, n) {
  const a = e.findIndex((i) => ra(i, t)), o = e.findIndex((i) => ra(i, n));
  if (a === -1 || o === -1) return [];
  const [r, s] = [a, o].sort((i, u) => i - u);
  return e.slice(r, s + 1);
}
const Us = typeof document < "u";
function pb(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e));
}
function vl(e, t) {
  let n = e;
  const a = t.toString(), o = a.indexOf("."), r = o >= 0 ? a.length - o : 0;
  if (r > 0) {
    const s = 10 ** r;
    n = Math.round(n * s) / s;
  }
  return n;
}
function dE(e, t, n, a) {
  t = Number(t), n = Number(n);
  const o = (e - (Number.isNaN(t) ? 0 : t)) % a;
  let r = vl(Math.abs(o) * 2 >= a ? e + Math.sign(o) * (a - Math.abs(o)) : e - o, a);
  return Number.isNaN(t) ? !Number.isNaN(n) && r > n && (r = Math.floor(vl(n / a, a)) * a) : r < t ? r = t : !Number.isNaN(n) && r > n && (r = t + Math.floor(vl((n - t) / a, a)) * a), r = vl(r, a), r;
}
function He(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = vn(a, s);
    if (i || i === null) return i;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (s) => (Mn(a, s), s)];
}
function gt() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function cu(e, t, n) {
  const a = n.originalEvent.target, o = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(o);
}
function mo(e) {
  return e == null;
}
function fi(e, t) {
  return mo(e) ? !1 : Array.isArray(e) ? e.some((n) => ra(n, t)) : ra(e, t);
}
function Gf(e) {
  return e ? e.flatMap((t) => t.type === Fe ? Gf(t.children) : [t]) : [];
}
const cE = ["INPUT", "TEXTAREA"];
function Mr(e, t, n, a = {}) {
  if (!t || a.enableIgnoredElement && cE.includes(t.nodeName)) return null;
  const { arrowKeyOptions: o = "both", attributeName: r = "[data-reka-collection-item]", itemsArray: s = [], loop: i = !0, dir: u = "ltr", preventScroll: d = !0, focus: c = !1 } = a, [f, p, v, m, h, _] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ], x = v || m, S = f || p;
  if (!h && !_ && (!x && !S || o === "vertical" && S || o === "horizontal" && x)) return null;
  const $ = n ? Array.from(n.querySelectorAll(r)) : s;
  if (!$.length) return null;
  d && e.preventDefault();
  let D = null;
  return S || x ? D = vb($, t, {
    goForward: x ? m : u === "ltr" ? f : p,
    loop: i
  }) : h ? D = $.at(0) || null : _ && (D = $.at(-1) || null), c && (D == null || D.focus()), D;
}
function vb(e, t, n, a = e.length) {
  if (--a === 0) return null;
  const o = e.indexOf(t), r = n.goForward ? o + 1 : o - 1;
  if (!n.loop && (r < 0 || r >= e.length)) return null;
  const s = (r + e.length) % e.length, i = e[s];
  return i ? i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false" ? vb(e, i, n, a) : i : null;
}
const [js] = He("ConfigProvider");
function fE(e, t) {
  var n;
  const a = Zt();
  return Me(() => {
    a.value = e();
  }, {
    ...t,
    flush: (n = void 0) != null ? n : "sync"
  }), Oa(a);
}
function ao(e) {
  return As() ? (Is(e), !0) : !1;
}
function tr() {
  const e = /* @__PURE__ */ new Set(), t = (r) => {
    e.delete(r);
  };
  return {
    on: (r) => {
      e.add(r);
      const s = () => t(r);
      return ao(s), {
        off: s
      };
    },
    off: t,
    trigger: (...r) => Promise.all(Array.from(e).map((s) => s(...r))),
    clear: () => {
      e.clear();
    }
  };
}
function pE(e) {
  let t = !1, n;
  const a = Wi(!0);
  return (...o) => (t || (n = a.run(() => e(...o)), t = !0), n);
}
function mb(e) {
  let t = 0, n, a;
  const o = () => {
    t -= 1, a && t <= 0 && (a.stop(), n = void 0, a = void 0);
  };
  return (...r) => (t += 1, a || (a = Wi(!0), n = a.run(() => e(...r))), ao(o), n);
}
function vE(e) {
  if (!ht(e))
    return Qt(e);
  const t = new Proxy({}, {
    get(n, a, o) {
      return l(Reflect.get(e.value, a, o));
    },
    set(n, a, o) {
      return ht(e.value[a]) && !ht(o) ? e.value[a].value = o : e.value[a] = o, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Qt(t);
}
function Yf(e) {
  return vE(E(e));
}
function fu(e, ...t) {
  const n = t.flat(), a = n[0];
  return Yf(() => Object.fromEntries(typeof a == "function" ? Object.entries(Be(e)).filter(([o, r]) => !a(me(r), o)) : Object.entries(Be(e)).filter((o) => !n.includes(o[0]))));
}
const Wn = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const mE = (e) => typeof e < "u", hE = (e) => e != null, gE = Object.prototype.toString, yE = (e) => gE.call(e) === "[object Object]", pi = () => {
}, vm = /* @__PURE__ */ bE();
function bE() {
  var e, t;
  return Wn && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function hb(e, t) {
  function n(...a) {
    return new Promise((o, r) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(o).catch(r);
    });
  }
  return n;
}
const gb = (e) => e();
function _E(e, t = {}) {
  let n, a, o = pi;
  const r = (u) => {
    clearTimeout(u), o(), o = pi;
  };
  let s;
  return (u) => {
    const d = me(e), c = me(t.maxWait);
    return n && r(n), d <= 0 || c !== void 0 && c <= 0 ? (a && (r(a), a = null), Promise.resolve(u())) : new Promise((f, p) => {
      o = t.rejectOnCancel ? p : f, s = u, c && !a && (a = setTimeout(() => {
        n && r(n), a = null, f(s());
      }, c)), n = setTimeout(() => {
        a && r(a), a = null, f(u());
      }, d);
    });
  };
}
function wE(e = gb, t = {}) {
  const {
    initialState: n = "active"
  } = t, a = CE(n === "active");
  function o() {
    a.value = !1;
  }
  function r() {
    a.value = !0;
  }
  const s = (...i) => {
    a.value && e(...i);
  };
  return { isActive: Oa(a), pause: o, resume: r, eventFilter: s };
}
function xE(e) {
  return ct();
}
function Nl(e) {
  return Array.isArray(e) ? e : [e];
}
function CE(...e) {
  if (e.length !== 1)
    return Fn(...e);
  const t = e[0];
  return typeof t == "function" ? Oa(Ki(() => ({ get: t, set: pi }))) : O(t);
}
function Ws(e, t = 1e4) {
  return Ki((n, a) => {
    let o = me(e), r;
    const s = () => setTimeout(() => {
      o = me(e), a();
    }, me(t));
    return ao(() => {
      clearTimeout(r);
    }), {
      get() {
        return n(), o;
      },
      set(i) {
        o = i, a(), clearTimeout(r), r = s();
      }
    };
  });
}
function Xf(e, t = 200, n = {}) {
  return hb(
    _E(t, n),
    e
  );
}
function SE(e, t, n = {}) {
  const {
    eventFilter: a = gb,
    ...o
  } = n;
  return ce(
    e,
    hb(
      a,
      t
    ),
    o
  );
}
function mm(e, t, n = {}) {
  const {
    eventFilter: a,
    initialState: o = "active",
    ...r
  } = n, { eventFilter: s, pause: i, resume: u, isActive: d } = wE(a, { initialState: o });
  return { stop: SE(
    e,
    t,
    {
      ...r,
      eventFilter: s
    }
  ), pause: i, resume: u, isActive: d };
}
function $E(e, t, ...[n]) {
  const {
    flush: a = "sync",
    deep: o = !1,
    immediate: r = !0,
    direction: s = "both",
    transform: i = {}
  } = n || {}, u = [], d = "ltr" in i && i.ltr || ((p) => p), c = "rtl" in i && i.rtl || ((p) => p);
  return (s === "both" || s === "ltr") && u.push(mm(
    e,
    (p) => {
      u.forEach((v) => v.pause()), t.value = d(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: o, immediate: r }
  )), (s === "both" || s === "rtl") && u.push(mm(
    t,
    (p) => {
      u.forEach((v) => v.pause()), e.value = c(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: o, immediate: r }
  )), () => {
    u.forEach((p) => p.stop());
  };
}
function BE(e, t) {
  xE() && ka(e, t);
}
function PE(e, t, n) {
  return ce(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
function EE(e, t, n) {
  const a = ce(e, (...o) => (he(() => a()), t(...o)), n);
  return a;
}
const oo = Wn ? window : void 0;
function mn(e) {
  var t;
  const n = me(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
function on(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), o = E(() => {
    const i = Nl(me(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), r = PE(
    () => {
      var i, u;
      return [
        (u = (i = o.value) == null ? void 0 : i.map((d) => mn(d))) != null ? u : [oo].filter((d) => d != null),
        Nl(me(o.value ? e[1] : e[0])),
        Nl(l(o.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        me(o.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !(i != null && i.length) || !(u != null && u.length) || !(d != null && d.length))
        return;
      const f = yE(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    r(), n();
  };
  return ao(n), s;
}
function yb() {
  const e = Zt(!1), t = ct();
  return t && be(() => {
    e.value = !0;
  }, t), e;
}
function bb(e) {
  const t = yb();
  return E(() => (t.value, !!e()));
}
function DE(e, t, n = {}) {
  const { window: a = oo, ...o } = n;
  let r;
  const s = bb(() => a && "MutationObserver" in a), i = () => {
    r && (r.disconnect(), r = void 0);
  }, u = E(() => {
    const p = me(e), v = Nl(p).map(mn).filter(hE);
    return new Set(v);
  }), d = ce(
    () => u.value,
    (p) => {
      i(), s.value && p.size && (r = new MutationObserver(t), p.forEach((v) => r.observe(v, o)));
    },
    { immediate: !0, flush: "post" }
  ), c = () => r == null ? void 0 : r.takeRecords(), f = () => {
    d(), i();
  };
  return ao(f), {
    isSupported: s,
    stop: f,
    takeRecords: c
  };
}
function ME(e, t, n = {}) {
  const {
    window: a = oo,
    document: o = a == null ? void 0 : a.document,
    flush: r = "sync"
  } = n;
  if (!a || !o)
    return pi;
  let s;
  const i = (c) => {
    s == null || s(), s = c;
  }, u = Me(() => {
    const c = mn(e);
    if (c) {
      const { stop: f } = DE(
        o,
        (p) => {
          p.map((m) => [...m.removedNodes]).flat().some((m) => m === c || m.contains(c)) && t(p);
        },
        {
          window: a,
          childList: !0,
          subtree: !0
        }
      );
      i(f);
    }
  }, { flush: r }), d = () => {
    u(), i();
  };
  return ao(d), d;
}
function kE(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function OE(...e) {
  let t, n, a = {};
  e.length === 3 ? (t = e[0], n = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], a = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: o = oo,
    eventName: r = "keydown",
    passive: s = !1,
    dedupe: i = !1
  } = a, u = kE(t);
  return on(o, r, (c) => {
    c.repeat && me(i) || u(c) && n(c);
  }, s);
}
function TE(e = {}) {
  var t;
  const {
    window: n = oo,
    deep: a = !0,
    triggerOnRemoval: o = !1
  } = e, r = (t = e.document) != null ? t : n == null ? void 0 : n.document, s = () => {
    var d;
    let c = r == null ? void 0 : r.activeElement;
    if (a)
      for (; c != null && c.shadowRoot; )
        c = (d = c == null ? void 0 : c.shadowRoot) == null ? void 0 : d.activeElement;
    return c;
  }, i = Zt(), u = () => {
    i.value = s();
  };
  if (n) {
    const d = {
      capture: !0,
      passive: !0
    };
    on(
      n,
      "blur",
      (c) => {
        c.relatedTarget === null && u();
      },
      d
    ), on(
      n,
      "focus",
      u,
      d
    );
  }
  return o && ME(i, u, { document: r }), u(), i;
}
function AE(e) {
  return JSON.parse(JSON.stringify(e));
}
function sa(e, t, n = {}) {
  const { window: a = oo, ...o } = n;
  let r;
  const s = bb(() => a && "ResizeObserver" in a), i = () => {
    r && (r.disconnect(), r = void 0);
  }, u = E(() => {
    const f = me(e);
    return Array.isArray(f) ? f.map((p) => mn(p)) : [mn(f)];
  }), d = ce(
    u,
    (f) => {
      if (i(), s.value && a) {
        r = new ResizeObserver(t);
        for (const p of f)
          p && r.observe(p, o);
      }
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    i(), d();
  };
  return ao(c), {
    isSupported: s,
    stop: c
  };
}
const IE = "focusin", RE = "focusout", qE = ":focus-within";
function FE(e, t = {}) {
  const { window: n = oo } = t, a = E(() => mn(e)), o = Zt(!1), r = E(() => o.value), s = TE(t);
  if (!n || !s.value)
    return { focused: r };
  const i = { passive: !0 };
  return on(a, IE, () => o.value = !0, i), on(a, RE, () => {
    var u, d, c;
    return o.value = (c = (d = (u = a.value) == null ? void 0 : u.matches) == null ? void 0 : d.call(u, qE)) != null ? c : !1;
  }, i), { focused: r };
}
function rt(e, t, n, a = {}) {
  var o, r, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = ct(), m = n || (v == null ? void 0 : v.emit) || ((o = v == null ? void 0 : v.$emit) == null ? void 0 : o.bind(v)) || ((s = (r = v == null ? void 0 : v.proxy) == null ? void 0 : r.$emit) == null ? void 0 : s.bind(v == null ? void 0 : v.proxy));
  let h = d;
  t || (t = "modelValue"), h = h || `update:${t.toString()}`;
  const _ = ($) => i ? typeof i == "function" ? i($) : AE($) : $, x = () => mE(e[t]) ? _(e[t]) : f, S = ($) => {
    p ? p($) && m(h, $) : m(h, $);
  };
  if (u) {
    const $ = x(), D = O($);
    let B = !1;
    return ce(
      () => e[t],
      (k) => {
        B || (B = !0, D.value = _(k), he(() => B = !1));
      }
    ), ce(
      D,
      (k) => {
        !B && (k !== e[t] || c) && S(k);
      },
      { deep: c }
    ), D;
  } else
    return E({
      get() {
        return x();
      },
      set($) {
        S($);
      }
    });
}
function hd(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function fc(e, t, n = ".", a) {
  if (!hd(t))
    return fc(e, {}, n, a);
  const o = Object.assign({}, t);
  for (const r in e) {
    if (r === "__proto__" || r === "constructor")
      continue;
    const s = e[r];
    s != null && (a && a(o, r, s, n) || (Array.isArray(s) && Array.isArray(o[r]) ? o[r] = [...s, ...o[r]] : hd(s) && hd(o[r]) ? o[r] = fc(
      s,
      o[r],
      (n ? `${n}.` : "") + r.toString(),
      a
    ) : o[r] = s));
  }
  return o;
}
function VE(e) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((n, a) => fc(n, a, "", e), {})
  );
}
const NE = VE(), LE = mb(() => {
  const e = O(/* @__PURE__ */ new Map()), t = O(), n = E(() => {
    for (const s of e.value.values()) if (s) return !0;
    return !1;
  }), a = js({ scrollBody: O(!0) });
  let o = null;
  const r = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", vm && (o == null || o()), t.value = void 0;
  };
  return ce(n, (s, i) => {
    var f;
    if (!Wn) return;
    if (!s) {
      i && r();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const u = window.innerWidth - document.documentElement.clientWidth, d = {
      padding: u,
      margin: 0
    }, c = (f = a.scrollBody) != null && f.value ? typeof a.scrollBody.value == "object" ? NE({
      padding: a.scrollBody.value.padding === !0 ? u : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? u : a.scrollBody.value.margin
    }, d) : d : {
      padding: 0,
      margin: 0
    };
    u > 0 && (document.body.style.paddingRight = typeof c.padding == "number" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == "number" ? `${c.margin}px` : String(c.margin), document.documentElement.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), vm && (o = on(document, "touchmove", (p) => zE(p), { passive: !1 })), he(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function Jf(e) {
  const t = Math.random().toString(36).substring(2, 7), n = LE();
  n.value.set(t, e ?? !1);
  const a = E({
    get: () => n.value.get(t) ?? !1,
    set: (o) => n.value.set(t, o)
  });
  return BE(() => {
    n.value.delete(t);
  }), a;
}
function _b(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : _b(n);
  }
}
function zE(e) {
  const t = e || window.event, n = t.target;
  return n instanceof Element && _b(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);
}
function Vn(e, t = _r()) {
  return Zf(e) ? e.toDate() : e.toDate(t);
}
function HE(e) {
  return e instanceof lr;
}
function Zf(e) {
  return e instanceof ir;
}
function UE(e) {
  return HE(e) || Zf(e);
}
function ys(e) {
  if (e instanceof Date) {
    const t = e.getFullYear(), n = e.getMonth() + 1;
    return new Date(t, n, 0).getDate();
  } else return e.set({ day: 100 }).day;
}
function ho(e, t) {
  return e.compare(t) < 0;
}
function Ll(e, t) {
  return e.compare(t) > 0;
}
function jE(e, t) {
  return e.compare(t) <= 0;
}
function WE(e, t) {
  return e.compare(t) >= 0;
}
function KE(e, t, n) {
  return WE(e, t) && jE(e, n);
}
function gd(e, t, n) {
  return Ll(e, t) && ho(e, n);
}
function GE(e, t, n) {
  const a = yg(e, n);
  return t > a ? e.subtract({ days: a + 7 - t }) : t === a ? e : e.subtract({ days: a - t });
}
function YE(e, t, n) {
  const a = yg(e, n), o = t === 0 ? 6 : t - 1;
  return a === o ? e : a > o ? e.add({ days: 7 - a + o }) : e.add({ days: o - a });
}
function XE(e, t, n, a, o) {
  if (n === void 0 && a === void 0 && o === void 0) return !0;
  let r = e.add({ days: 1 });
  if ((a != null && a(r) || n != null && n(r)) && !(o != null && o(r))) return !1;
  const s = t;
  for (; r.compare(s) < 0; )
    if (r = r.add({ days: 1 }), (a != null && a(r) || n != null && n(r)) && !(o != null && o(r))) return !1;
  return !0;
}
function wb(e) {
  const { defaultValue: t, defaultPlaceholder: n, granularity: a = "day", locale: o = "en" } = e;
  if (Array.isArray(t) && t.length) return t.at(-1).copy();
  if (t && !Array.isArray(t)) return t.copy();
  if (n) return n.copy();
  const r = /* @__PURE__ */ new Date(), s = r.getFullYear(), i = r.getMonth() + 1, u = r.getDate(), d = [
    "hour",
    "minute",
    "second"
  ], c = new va(o), f = ix(c.resolvedOptions().calendar);
  return d.includes(a ?? "day") ? cn(new lr(s, i, u, 0, 0, 0), f) : cn(new kt(s, i, u), f);
}
function JE(e, t) {
  const n = [];
  for (let a = 0; a < e.length; a += t) n.push(e.slice(a, a + t));
  return n;
}
function xb(e) {
  const t = e.querySelector("[data-selected]");
  if (t) return t.focus();
  const n = e.querySelector("[data-today]");
  if (n) return n.focus();
  const a = e.querySelector("[data-reka-calendar-day]");
  if (a) return a.focus();
}
function pc(e, t) {
  const n = [];
  let a = e.add({ days: 1 });
  const o = t;
  for (; a.compare(o) < 0; )
    n.push(a), a = a.add({ days: 1 });
  return n;
}
function yd(e) {
  const { dateObj: t, weekStartsOn: n, fixedWeeks: a, locale: o } = e, r = ys(t), s = Array.from({ length: r }, (_, x) => t.set({ day: x + 1 })), i = jd(t), u = bv(t), d = GE(i, n, o), c = YE(u, n, o), f = pc(d.subtract({ days: 1 }), i), p = pc(u, c.add({ days: 1 })), v = f.length + s.length + p.length;
  if (a && v < 42) {
    const _ = 42 - v;
    let x = p[p.length - 1];
    x || (x = bv(t));
    const S = Array.from({ length: _ }, ($, D) => {
      const B = D + 1;
      return x.add({ days: B });
    });
    p.push(...S);
  }
  const m = f.concat(s, p), h = JE(m, 7);
  return {
    value: t,
    cells: m,
    rows: h
  };
}
function so(e) {
  const { numberOfMonths: t, dateObj: n, ...a } = e, o = [];
  if (!t || t === 1)
    return o.push(yd({
      ...a,
      dateObj: n
    })), o;
  o.push(yd({
    ...a,
    dateObj: n
  }));
  for (let r = 1; r < t; r++) {
    const s = n.add({ months: r });
    o.push(yd({
      ...a,
      dateObj: s
    }));
  }
  return o;
}
function ZE(e, t = {}) {
  const n = O(e);
  function a() {
    return n.value;
  }
  function o(_) {
    n.value = _;
  }
  function r(_, x) {
    return new va(n.value, {
      ...t,
      ...x
    }).format(_);
  }
  function s(_, x = !0) {
    return UE(_) && x ? r(Vn(_), {
      dateStyle: "long",
      timeStyle: "long"
    }) : r(Vn(_), { dateStyle: "long" });
  }
  function i(_, x = {}) {
    return new va(n.value, {
      ...t,
      month: "long",
      year: "numeric",
      ...x
    }).format(_);
  }
  function u(_, x = {}) {
    return new va(n.value, {
      ...t,
      month: "long",
      ...x
    }).format(_);
  }
  function d() {
    const _ = bg(_r());
    return [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12
    ].map((S) => ({
      label: u(Vn(_.set({ month: S }))),
      value: S
    }));
  }
  function c(_, x = {}) {
    return new va(n.value, {
      ...t,
      year: "numeric",
      ...x
    }).format(_);
  }
  function f(_, x) {
    return Zf(_) ? new va(n.value, {
      ...t,
      ...x,
      timeZone: _.timeZone
    }).formatToParts(Vn(_)) : new va(n.value, {
      ...t,
      ...x
    }).formatToParts(Vn(_));
  }
  function p(_, x = "narrow") {
    return new va(n.value, {
      ...t,
      weekday: x
    }).format(_);
  }
  function v(_) {
    var $;
    const S = ($ = new va(n.value, {
      ...t,
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(_).find((D) => D.type === "dayPeriod")) == null ? void 0 : $.value;
    return S === "PM" || S === "p.m." ? "PM" : "AM";
  }
  const m = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function h(_, x, S = {}) {
    const $ = {
      ...m,
      ...S
    }, B = f(_, $).find((k) => k.type === x);
    return B ? B.value : "";
  }
  return {
    setLocale: o,
    getLocale: a,
    fullMonth: u,
    fullYear: c,
    fullMonthAndYear: i,
    toParts: f,
    custom: r,
    part: h,
    dayPeriod: v,
    selectedDate: s,
    dayOfWeek: p,
    getMonths: d
  };
}
function tn(e) {
  const t = js({ dir: O("ltr") });
  return E(() => {
    var n;
    return (e == null ? void 0 : e.value) || ((n = t.dir) == null ? void 0 : n.value) || "ltr";
  });
}
function Kn(e) {
  const t = ct(), n = t == null ? void 0 : t.type.emits, a = {};
  return n != null && n.length || console.warn(`No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`), n == null || n.forEach((o) => {
    a[cg(or(o))] = (...r) => e(o, ...r);
  }), a;
}
function QE(e) {
  const t = E(() => l(e)), n = E(() => new Intl.Collator("en", {
    usage: "search",
    ...t.value
  }));
  return {
    startsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(0, i.length), i) === 0),
    endsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(-i.length), i) === 0),
    contains: (s, i) => {
      if (i.length === 0) return !0;
      s = s.normalize("NFC"), i = i.normalize("NFC");
      let u = 0;
      const d = i.length;
      for (; u + d <= s.length; u++) {
        const c = s.slice(u, u + d);
        if (n.value.compare(i, c) === 0) return !0;
      }
      return !1;
    }
  };
}
let bd = 0;
function eD() {
  Me((e) => {
    if (!Wn) return;
    const t = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", t[0] ?? hm()), document.body.insertAdjacentElement("beforeend", t[1] ?? hm()), bd++, e(() => {
      bd === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((n) => n.remove()), bd--;
    });
  });
}
function hm() {
  const e = document.createElement("span");
  return e.setAttribute("data-reka-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
function ro(e) {
  return E(() => {
    var t;
    return me(e) ? !!((t = mn(e)) != null && t.closest("form")) : !0;
  });
}
function le() {
  const e = ct(), t = O(), n = E(() => {
    var s, i;
    return ["#text", "#comment"].includes((s = t.value) == null ? void 0 : s.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : mn(t);
  }), a = Object.assign({}, e.exposed), o = {};
  for (const s in e.props) Object.defineProperty(o, s, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[s]
  });
  if (Object.keys(a).length > 0) for (const s in a) Object.defineProperty(o, s, {
    enumerable: !0,
    configurable: !0,
    get: () => a[s]
  });
  Object.defineProperty(o, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = o;
  function r(s) {
    if (t.value = s, !!s && (Object.defineProperty(o, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s instanceof Element ? s : s.$el
    }), !(s instanceof Element) && !Object.hasOwn(s, "$el"))) {
      const i = s.$.exposed, u = Object.assign({}, o);
      for (const d in i) Object.defineProperty(u, d, {
        enumerable: !0,
        configurable: !0,
        get: () => i[d]
      });
      e.exposed = u;
    }
  }
  return {
    forwardRef: r,
    currentRef: t,
    currentElement: n
  };
}
function Ee(e) {
  const t = ct(), n = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((o, r) => {
    const s = (t == null ? void 0 : t.type.props[r]).default;
    return s !== void 0 && (o[r] = s), o;
  }, {}), a = Fn(e);
  return E(() => {
    const o = {}, r = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(r).forEach((s) => {
      o[or(s)] = r[s];
    }), Object.keys({
      ...n,
      ...o
    }).reduce((s, i) => (a.value[i] !== void 0 && (s[i] = a.value[i]), s), {});
  });
}
function qe(e, t) {
  const n = Ee(e), a = t ? Kn(t) : {};
  return E(() => ({
    ...n.value,
    ...a
  }));
}
function tD(e, t) {
  const n = Ws(!1, 300);
  ao(() => {
    n.value = !1;
  });
  const a = O(null), o = tr();
  function r() {
    a.value = null, n.value = !1;
  }
  function s(i, u) {
    const d = i.currentTarget, c = {
      x: i.clientX,
      y: i.clientY
    }, f = nD(c, d.getBoundingClientRect()), p = aD(c, f), v = oD(u.getBoundingClientRect()), m = sD([...p, ...v]);
    a.value = m, n.value = !0;
  }
  return Me((i) => {
    if (e.value && t.value) {
      const u = (c) => s(c, t.value), d = (c) => s(c, e.value);
      e.value.addEventListener("pointerleave", u), t.value.addEventListener("pointerleave", d), i(() => {
        var c, f;
        (c = e.value) == null || c.removeEventListener("pointerleave", u), (f = t.value) == null || f.removeEventListener("pointerleave", d);
      });
    }
  }), Me((i) => {
    var u;
    if (a.value) {
      const d = (c) => {
        var _, x;
        if (!a.value || !(c.target instanceof Element)) return;
        const f = c.target, p = {
          x: c.clientX,
          y: c.clientY
        }, v = ((_ = e.value) == null ? void 0 : _.contains(f)) || ((x = t.value) == null ? void 0 : x.contains(f)), m = !rD(p, a.value), h = !!f.closest("[data-grace-area-trigger]");
        v ? r() : (m || h) && (r(), o.trigger());
      };
      (u = e.value) == null || u.ownerDocument.addEventListener("pointermove", d), i(() => {
        var c;
        return (c = e.value) == null ? void 0 : c.ownerDocument.removeEventListener("pointermove", d);
      });
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: o.on
  };
}
function nD(e, t) {
  const n = Math.abs(t.top - e.y), a = Math.abs(t.bottom - e.y), o = Math.abs(t.right - e.x), r = Math.abs(t.left - e.x);
  switch (Math.min(n, a, o, r)) {
    case r:
      return "left";
    case o:
      return "right";
    case n:
      return "top";
    case a:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function aD(e, t, n = 5) {
  const a = [];
  switch (t) {
    case "top":
      a.push({
        x: e.x - n,
        y: e.y + n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "bottom":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y - n
      });
      break;
    case "left":
      a.push({
        x: e.x + n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "right":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x - n,
        y: e.y + n
      });
      break;
  }
  return a;
}
function oD(e) {
  const { top: t, right: n, bottom: a, left: o } = e;
  return [
    {
      x: o,
      y: t
    },
    {
      x: n,
      y: t
    },
    {
      x: n,
      y: a
    },
    {
      x: o,
      y: a
    }
  ];
}
function rD(e, t) {
  const { x: n, y: a } = e;
  let o = !1;
  for (let r = 0, s = t.length - 1; r < t.length; s = r++) {
    const i = t[r].x, u = t[r].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (o = !o);
  }
  return o;
}
function sD(e) {
  const t = e.slice();
  return t.sort((n, a) => n.x < a.x ? -1 : n.x > a.x ? 1 : n.y < a.y ? -1 : n.y > a.y ? 1 : 0), lD(t);
}
function lD(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let a = 0; a < e.length; a++) {
    const o = e[a];
    for (; t.length >= 2; ) {
      const r = t[t.length - 1], s = t[t.length - 2];
      if ((r.x - s.x) * (o.y - s.y) >= (r.y - s.y) * (o.x - s.x)) t.pop();
      else break;
    }
    t.push(o);
  }
  t.pop();
  const n = [];
  for (let a = e.length - 1; a >= 0; a--) {
    const o = e[a];
    for (; n.length >= 2; ) {
      const r = n[n.length - 1], s = n[n.length - 2];
      if ((r.x - s.x) * (o.y - s.y) >= (r.y - s.y) * (o.x - s.x)) n.pop();
      else break;
    }
    n.push(o);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var iD = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, zo = /* @__PURE__ */ new WeakMap(), ml = /* @__PURE__ */ new WeakMap(), hl = {}, _d = 0, Cb = function(e) {
  return e && (e.host || Cb(e.parentNode));
}, uD = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var a = Cb(n);
    return a && e.contains(a) ? a : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, dD = function(e, t, n, a) {
  var o = uD(t, Array.isArray(e) ? e : [e]);
  hl[n] || (hl[n] = /* @__PURE__ */ new WeakMap());
  var r = hl[n], s = [], i = /* @__PURE__ */ new Set(), u = new Set(o), d = function(f) {
    !f || i.has(f) || (i.add(f), d(f.parentNode));
  };
  o.forEach(d);
  var c = function(f) {
    !f || u.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (i.has(p))
        c(p);
      else
        try {
          var v = p.getAttribute(a), m = v !== null && v !== "false", h = (zo.get(p) || 0) + 1, _ = (r.get(p) || 0) + 1;
          zo.set(p, h), r.set(p, _), s.push(p), h === 1 && m && ml.set(p, !0), _ === 1 && p.setAttribute(n, "true"), m || p.setAttribute(a, "true");
        } catch (x) {
          console.error("aria-hidden: cannot operate on ", p, x);
        }
    });
  };
  return c(t), i.clear(), _d++, function() {
    s.forEach(function(f) {
      var p = zo.get(f) - 1, v = r.get(f) - 1;
      zo.set(f, p), r.set(f, v), p || (ml.has(f) || f.removeAttribute(a), ml.delete(f)), v || f.removeAttribute(n);
    }), _d--, _d || (zo = /* @__PURE__ */ new WeakMap(), zo = /* @__PURE__ */ new WeakMap(), ml = /* @__PURE__ */ new WeakMap(), hl = {});
  };
}, cD = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), o = iD(e);
  return o ? (a.push.apply(a, Array.from(o.querySelectorAll("[aria-live], script"))), dD(a, o, n, "aria-hidden")) : function() {
    return null;
  };
};
function Qf(e) {
  let t;
  ce(() => mn(e), (n) => {
    n ? t = cD(n) : t && t();
  }), Ze(() => {
    t && t();
  });
}
let fD = 0;
function yt(e, t = "reka") {
  var a;
  if (e) return e;
  if ("useId" in Wo) return `${t}-${(a = Wo.useId) == null ? void 0 : a.call(Wo)}`;
  const n = js({ useId: void 0 });
  return n.useId ? `${t}-${n.useId()}` : `${t}-${++fD}`;
}
function Ks() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function ep(e) {
  const t = js({ locale: O("en") });
  return E(() => {
    var n;
    return (e == null ? void 0 : e.value) || ((n = t.locale) == null ? void 0 : n.value) || "en";
  });
}
function pD(e) {
  const t = O(), n = E(() => {
    var o;
    return ((o = t.value) == null ? void 0 : o.width) ?? 0;
  }), a = E(() => {
    var o;
    return ((o = t.value) == null ? void 0 : o.height) ?? 0;
  });
  return be(() => {
    const o = mn(e);
    if (o) {
      t.value = {
        width: o.offsetWidth,
        height: o.offsetHeight
      };
      const r = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length) return;
        const i = s[0];
        let u, d;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          u = f.inlineSize, d = f.blockSize;
        } else
          u = o.offsetWidth, d = o.offsetHeight;
        t.value = {
          width: u,
          height: d
        };
      });
      return r.observe(o, { box: "border-box" }), () => r.unobserve(o);
    } else t.value = void 0;
  }), {
    width: n,
    height: a
  };
}
function Sb(e, t) {
  const n = O(e);
  function a(r) {
    return t[n.value][r] ?? n.value;
  }
  return {
    state: n,
    dispatch: (r) => {
      n.value = a(r);
    }
  };
}
function $b(e) {
  const t = Ws("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (o, r) => {
      t.value = t.value + o;
      {
        const s = gt(), i = r.map((p) => {
          var v, m;
          return {
            ...p,
            textValue: ((v = p.value) == null ? void 0 : v.textValue) ?? ((m = p.ref.textContent) == null ? void 0 : m.trim()) ?? ""
          };
        }), u = i.find((p) => p.ref === s), d = i.map((p) => p.textValue), c = vD(d, t.value, u == null ? void 0 : u.textValue), f = i.find((p) => p.textValue === c);
        return f && f.ref.focus(), f == null ? void 0 : f.ref;
      }
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function tp(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
function vD(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, r = n ? e.indexOf(n) : -1;
  let s = tp(e, Math.max(r, 0));
  o.length === 1 && (s = s.filter((d) => d !== n));
  const u = s.find((d) => d.toLowerCase().startsWith(o.toLowerCase()));
  return u !== n ? u : void 0;
}
function mD(e, t) {
  var _;
  const n = O({}), a = O("none"), o = O(e), r = e.value ? "mounted" : "unmounted";
  let s;
  const i = ((_ = t.value) == null ? void 0 : _.ownerDocument.defaultView) ?? oo, { state: u, dispatch: d } = Sb(r, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), c = (x) => {
    var S;
    if (Wn) {
      const $ = new CustomEvent(x, {
        bubbles: !1,
        cancelable: !1
      });
      (S = t.value) == null || S.dispatchEvent($);
    }
  };
  ce(e, async (x, S) => {
    var D;
    const $ = S !== x;
    if (await he(), $) {
      const B = a.value, k = gl(t.value);
      x ? (d("MOUNT"), c("enter"), k === "none" && c("after-enter")) : k === "none" || k === "undefined" || ((D = n.value) == null ? void 0 : D.display) === "none" ? (d("UNMOUNT"), c("leave"), c("after-leave")) : S && B !== k ? (d("ANIMATION_OUT"), c("leave")) : (d("UNMOUNT"), c("after-leave"));
    }
  }, { immediate: !0 });
  const f = (x) => {
    const S = gl(t.value), $ = S.includes(CSS.escape(x.animationName)), D = u.value === "mounted" ? "enter" : "leave";
    if (x.target === t.value && $ && (c(`after-${D}`), d("ANIMATION_END"), !o.value)) {
      const B = t.value.style.animationFillMode;
      t.value.style.animationFillMode = "forwards", s = i == null ? void 0 : i.setTimeout(() => {
        var k;
        ((k = t.value) == null ? void 0 : k.style.animationFillMode) === "forwards" && (t.value.style.animationFillMode = B);
      });
    }
    x.target === t.value && S === "none" && d("ANIMATION_END");
  }, p = (x) => {
    x.target === t.value && (a.value = gl(t.value));
  }, v = ce(t, (x, S) => {
    x ? (n.value = getComputedStyle(x), x.addEventListener("animationstart", p), x.addEventListener("animationcancel", f), x.addEventListener("animationend", f)) : (d("ANIMATION_END"), s !== void 0 && (i == null || i.clearTimeout(s)), S == null || S.removeEventListener("animationstart", p), S == null || S.removeEventListener("animationcancel", f), S == null || S.removeEventListener("animationend", f));
  }, { immediate: !0 }), m = ce(u, () => {
    const x = gl(t.value);
    a.value = u.value === "mounted" ? x : "none";
  });
  return Ze(() => {
    v(), m();
  }), { isPresent: E(() => ["mounted", "unmountSuspended"].includes(u.value)) };
}
function gl(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var nn = b({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: t, expose: n }) {
    var d;
    const { present: a, forceMount: o } = Be(e), r = O(), { isPresent: s } = mD(a, r);
    n({ present: s });
    let i = t.default({ present: s.value });
    i = Gf(i || []);
    const u = ct();
    if (i && (i == null ? void 0 : i.length) > 1) {
      const c = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((f) => `  - ${f}`).join(`
`)
      ].join(`
`));
    }
    return () => o.value || a.value || s.value ? Bt(t.default({ present: s.value })[0], { ref: (c) => {
      const f = mn(c);
      return typeof (f == null ? void 0 : f.hasAttribute) > "u" || (f != null && f.hasAttribute("data-reka-popper-content-wrapper") ? r.value = f.firstElementChild : r.value = f), f;
    } }) : null;
  }
});
const vi = b({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: t, slots: n }) {
    return () => {
      var u;
      if (!n.default) return null;
      const a = Gf(n.default()), o = a.findIndex((d) => d.type !== Zc);
      if (o === -1) return a;
      const r = a[o];
      (u = r.props) == null || delete u.ref;
      const s = r.props ? A(t, r.props) : t, i = pg({
        ...r,
        props: {}
      }, s);
      return a.length === 1 ? i : (a[o] = i, a);
    };
  }
}), hD = [
  "area",
  "img",
  "input"
], se = b({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: t, slots: n }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && hD.includes(a) ? () => Bt(a, t) : a !== "template" ? () => Bt(e.as, t, { default: n.default }) : () => Bt(vi, t, { default: n.default });
  }
});
function Kt() {
  const e = O(), t = E(() => {
    var n, a;
    return ["#text", "#comment"].includes((n = e.value) == null ? void 0 : n.$el.nodeName) ? (a = e.value) == null ? void 0 : a.$el.nextElementSibling : mn(e);
  });
  return {
    primitiveElement: e,
    currentElement: t
  };
}
const [Bb, gD] = He("CollapsibleRoot");
var yD = /* @__PURE__ */ b({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = rt(a, "open", n, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), { disabled: s, unmountOnHide: i } = Be(a);
    return gD({
      contentId: "",
      disabled: s,
      open: r,
      unmountOnHide: i,
      onOpenToggle: () => {
        s.value || (r.value = !r.value);
      }
    }), t({ open: r }), le(), (u, d) => (g(), C(l(se), {
      as: u.as,
      "as-child": a.asChild,
      "data-state": l(r) ? "open" : "closed",
      "data-disabled": l(s) ? "" : void 0
    }, {
      default: y(() => [w(u.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ]));
  }
}), bD = yD, _D = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["contentFound"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Bb();
    o.contentId || (o.contentId = yt(void 0, "reka-collapsible-content"));
    const r = O(), { forwardRef: s, currentElement: i } = le(), u = O(0), d = O(0), c = E(() => o.open.value), f = O(c.value), p = O();
    ce(() => {
      var m;
      return [c.value, (m = r.value) == null ? void 0 : m.present];
    }, async () => {
      await he();
      const m = i.value;
      if (!m) return;
      p.value = p.value || {
        transitionDuration: m.style.transitionDuration,
        animationName: m.style.animationName
      }, m.style.transitionDuration = "0s", m.style.animationName = "none";
      const h = m.getBoundingClientRect();
      d.value = h.height, u.value = h.width, f.value || (m.style.transitionDuration = p.value.transitionDuration, m.style.animationName = p.value.animationName);
    }, { immediate: !0 });
    const v = E(() => f.value && o.open.value);
    return be(() => {
      requestAnimationFrame(() => {
        f.value = !1;
      });
    }), on(i, "beforematch", (m) => {
      requestAnimationFrame(() => {
        o.onOpenToggle(), a("contentFound");
      });
    }), (m, h) => (g(), C(l(nn), {
      ref_key: "presentRef",
      ref: r,
      present: m.forceMount || l(o).open.value,
      "force-mount": !0
    }, {
      default: y(({ present: _ }) => {
        var x;
        return [N(l(se), A(m.$attrs, {
          id: l(o).contentId,
          ref: l(s),
          "as-child": n.asChild,
          as: m.as,
          hidden: _ ? void 0 : l(o).unmountOnHide.value ? "" : "until-found",
          "data-state": v.value ? void 0 : l(o).open.value ? "open" : "closed",
          "data-disabled": (x = l(o).disabled) != null && x.value ? "" : void 0,
          style: {
            "--reka-collapsible-content-height": `${d.value}px`,
            "--reka-collapsible-content-width": `${u.value}px`
          }
        }), {
          default: y(() => [!l(o).unmountOnHide.value || _ ? w(m.$slots, "default", { key: 0 }) : Pe("v-if", !0)]),
          _: 2
        }, 1040, [
          "id",
          "as-child",
          "as",
          "hidden",
          "data-state",
          "data-disabled",
          "style"
        ])];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), wD = _D, xD = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Bb();
    return (a, o) => {
      var r, s;
      return g(), C(l(se), {
        type: a.as === "button" ? "button" : void 0,
        as: a.as,
        "as-child": t.asChild,
        "aria-controls": l(n).contentId,
        "aria-expanded": l(n).open.value,
        "data-state": l(n).open.value ? "open" : "closed",
        "data-disabled": (r = l(n).disabled) != null && r.value ? "" : void 0,
        disabled: (s = l(n).disabled) == null ? void 0 : s.value,
        onClick: l(n).onOpenToggle
      }, {
        default: y(() => [w(a.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "as",
        "as-child",
        "aria-controls",
        "aria-expanded",
        "data-state",
        "data-disabled",
        "disabled",
        "onClick"
      ]);
    };
  }
}), CD = xD;
function SD({ type: e, defaultValue: t, modelValue: n }) {
  const a = n || t;
  return n !== void 0 || t !== void 0 ? Array.isArray(a) ? "multiple" : "single" : e ?? "single";
}
function $D({ type: e, defaultValue: t, modelValue: n }) {
  return e || SD({
    type: e,
    defaultValue: t,
    modelValue: n
  });
}
function BD({ type: e, defaultValue: t }) {
  return t !== void 0 ? t : e === "single" ? void 0 : [];
}
function PD(e, t) {
  const n = E(() => $D(e)), a = rt(e, "modelValue", t, {
    defaultValue: BD(e),
    passive: e.modelValue === void 0,
    deep: !0
  });
  function o(s) {
    if (n.value === "single") a.value = ra(s, a.value) ? void 0 : s;
    else {
      const i = Array.isArray(a.value) ? [...a.value || []] : [a.value].filter(Boolean);
      if (fi(i, s)) {
        const u = i.findIndex((d) => ra(d, s));
        i.splice(u, 1);
      } else i.push(s);
      a.value = i;
    }
  }
  const r = E(() => n.value === "single");
  return {
    modelValue: a,
    changeModelValue: o,
    isSingle: r
  };
}
const [da, ED] = He("DialogRoot");
var DD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, o = rt(n, "open", t, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), r = O(), s = O(), { modal: i } = Be(n);
    return ED({
      open: o,
      modal: i,
      openModal: () => {
        o.value = !0;
      },
      onOpenChange: (u) => {
        o.value = u;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: r,
      contentElement: s
    }), (u, d) => w(u.$slots, "default", {
      open: l(o),
      close: () => o.value = !1
    });
  }
}), MD = DD, kD = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = da();
    return (a, o) => (g(), C(l(se), A(t, {
      type: a.as === "button" ? "button" : void 0,
      onClick: o[0] || (o[0] = (r) => l(n).onOpenChange(!1))
    }), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), OD = kD;
const TD = "dismissableLayer.pointerDownOutside", AD = "dismissableLayer.focusOutside";
function Pb(e, t) {
  const n = t.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), o = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(n && (a === n || o.indexOf(a) < o.indexOf(n)));
}
function ID(e, t, n = !0) {
  var s;
  const a = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = O(!1), r = O(() => {
  });
  return Me((i) => {
    if (!Wn || !me(n)) return;
    const u = async (c) => {
      const f = c.target;
      if (!(!(t != null && t.value) || !f)) {
        if (Pb(t.value, f)) {
          o.value = !1;
          return;
        }
        if (c.target && !o.value) {
          let v = function() {
            cu(TD, e, p);
          };
          const p = { originalEvent: c };
          c.pointerType === "touch" ? (a.removeEventListener("click", r.value), r.value = v, a.addEventListener("click", r.value, { once: !0 })) : v();
        } else a.removeEventListener("click", r.value);
        o.value = !1;
      }
    }, d = window.setTimeout(() => {
      a.addEventListener("pointerdown", u);
    }, 0);
    i(() => {
      window.clearTimeout(d), a.removeEventListener("pointerdown", u), a.removeEventListener("click", r.value);
    });
  }), { onPointerDownCapture: () => {
    me(n) && (o.value = !0);
  } };
}
function RD(e, t, n = !0) {
  var r;
  const a = ((r = t == null ? void 0 : t.value) == null ? void 0 : r.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = O(!1);
  return Me((s) => {
    if (!Wn || !me(n)) return;
    const i = async (u) => {
      if (!(t != null && t.value)) return;
      await he(), await he();
      const d = u.target;
      !t.value || !d || Pb(t.value, d) || u.target && !o.value && cu(AD, e, { originalEvent: u });
    };
    a.addEventListener("focusin", i), s(() => a.removeEventListener("focusin", i));
  }), {
    onFocusCapture: () => {
      me(n) && (o.value = !0);
    },
    onBlurCapture: () => {
      me(n) && (o.value = !1);
    }
  };
}
const $n = Qt({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  originalBodyPointerEvents: void 0,
  branches: /* @__PURE__ */ new Set()
});
var qD = /* @__PURE__ */ b({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = le(), s = E(() => {
      var v;
      return ((v = r.value) == null ? void 0 : v.ownerDocument) ?? globalThis.document;
    }), i = E(() => $n.layersRoot), u = E(() => r.value ? Array.from(i.value).indexOf(r.value) : -1), d = E(() => $n.layersWithOutsidePointerEventsDisabled.size > 0), c = E(() => {
      const v = Array.from(i.value), [m] = [...$n.layersWithOutsidePointerEventsDisabled].slice(-1), h = v.indexOf(m);
      return u.value >= h;
    }), f = ID(async (v) => {
      const m = [...$n.branches].some((h) => h == null ? void 0 : h.contains(v.target));
      !c.value || m || (a("pointerDownOutside", v), a("interactOutside", v), await he(), v.defaultPrevented || a("dismiss"));
    }, r), p = RD((v) => {
      [...$n.branches].some((h) => h == null ? void 0 : h.contains(v.target)) || (a("focusOutside", v), a("interactOutside", v), v.defaultPrevented || a("dismiss"));
    }, r);
    return OE("Escape", (v) => {
      u.value === i.value.size - 1 && (a("escapeKeyDown", v), v.defaultPrevented || a("dismiss"));
    }), Me((v) => {
      r.value && (n.disableOutsidePointerEvents && ($n.layersWithOutsidePointerEventsDisabled.size === 0 && ($n.originalBodyPointerEvents = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), $n.layersWithOutsidePointerEventsDisabled.add(r.value)), i.value.add(r.value), v(() => {
        n.disableOutsidePointerEvents && $n.layersWithOutsidePointerEventsDisabled.size === 1 && !mo($n.originalBodyPointerEvents) && (s.value.body.style.pointerEvents = $n.originalBodyPointerEvents);
      }));
    }), Me((v) => {
      v(() => {
        r.value && (i.value.delete(r.value), $n.layersWithOutsidePointerEventsDisabled.delete(r.value));
      });
    }), (v, m) => (g(), C(l(se), {
      ref: l(o),
      "as-child": v.asChild,
      as: v.as,
      "data-dismissable-layer": "",
      style: vt({ pointerEvents: d.value ? c.value ? "auto" : "none" : void 0 }),
      onFocusCapture: l(p).onFocusCapture,
      onBlurCapture: l(p).onBlurCapture,
      onPointerdownCapture: l(f).onPointerDownCapture
    }, {
      default: y(() => [w(v.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), Gs = qD;
const FD = pE(() => O([]));
function VD() {
  const e = FD();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && (n == null || n.pause()), e.value = gm(e.value, t), e.value.unshift(t);
    },
    remove(t) {
      var n;
      e.value = gm(e.value, t), (n = e.value[0]) == null || n.resume();
    }
  };
}
function gm(e, t) {
  const n = [...e], a = n.indexOf(t);
  return a !== -1 && n.splice(a, 1), n;
}
function ND(e) {
  return e.filter((t) => t.tagName !== "A");
}
const wd = "focusScope.autoFocusOnMount", xd = "focusScope.autoFocusOnUnmount", ym = {
  bubbles: !1,
  cancelable: !0
};
function LD(e, { select: t = !1 } = {}) {
  const n = gt();
  for (const a of e)
    if (Ha(a, { select: t }), gt() !== n) return !0;
}
function zD(e) {
  const t = Eb(e), n = bm(t, e), a = bm(t.reverse(), e);
  return [n, a];
}
function Eb(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const o = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || o ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function bm(e, t) {
  for (const n of e) if (!HD(n, { upTo: t })) return n;
}
function HD(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function UD(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Ha(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = gt();
    e.focus({ preventScroll: !0 }), e !== n && UD(e) && t && e.select();
  }
}
var jD = /* @__PURE__ */ b({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    trapped: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, { currentRef: o, currentElement: r } = le(), s = O(null), i = VD(), u = Qt({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Me((c) => {
      if (!Wn) return;
      const f = r.value;
      if (!n.trapped) return;
      function p(_) {
        if (u.paused || !f) return;
        const x = _.target;
        f.contains(x) ? s.value = x : Ha(s.value, { select: !0 });
      }
      function v(_) {
        if (u.paused || !f) return;
        const x = _.relatedTarget;
        x !== null && (f.contains(x) || Ha(s.value, { select: !0 }));
      }
      function m(_) {
        f.contains(s.value) || Ha(f);
      }
      document.addEventListener("focusin", p), document.addEventListener("focusout", v);
      const h = new MutationObserver(m);
      f && h.observe(f, {
        childList: !0,
        subtree: !0
      }), c(() => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", v), h.disconnect();
      });
    }), Me(async (c) => {
      const f = r.value;
      if (await he(), !f) return;
      i.add(u);
      const p = gt();
      if (!f.contains(p)) {
        const m = new CustomEvent(wd, ym);
        f.addEventListener(wd, (h) => a("mountAutoFocus", h)), f.dispatchEvent(m), m.defaultPrevented || (LD(ND(Eb(f)), { select: !0 }), gt() === p && Ha(f));
      }
      c(() => {
        f.removeEventListener(wd, (_) => a("mountAutoFocus", _));
        const m = new CustomEvent(xd, ym), h = (_) => {
          a("unmountAutoFocus", _);
        };
        f.addEventListener(xd, h), f.dispatchEvent(m), setTimeout(() => {
          m.defaultPrevented || Ha(p ?? document.body, { select: !0 }), f.removeEventListener(xd, h), i.remove(u);
        }, 0);
      });
    });
    function d(c) {
      if (!n.loop && !n.trapped || u.paused) return;
      const f = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, p = gt();
      if (f && p) {
        const v = c.currentTarget, [m, h] = zD(v);
        m && h ? !c.shiftKey && p === h ? (c.preventDefault(), n.loop && Ha(m, { select: !0 })) : c.shiftKey && p === m && (c.preventDefault(), n.loop && Ha(h, { select: !0 })) : p === v && c.preventDefault();
      }
    }
    return (c, f) => (g(), C(l(se), {
      ref_key: "currentRef",
      ref: o,
      tabindex: "-1",
      "as-child": c.asChild,
      as: c.as,
      onKeydown: d
    }, {
      default: y(() => [w(c.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), Db = jD;
const WD = "menu.itemSelect", vc = ["Enter", " "], KD = [
  "ArrowDown",
  "PageUp",
  "Home"
], Mb = [
  "ArrowUp",
  "PageDown",
  "End"
], GD = [...KD, ...Mb], YD = {
  ltr: [...vc, "ArrowRight"],
  rtl: [...vc, "ArrowLeft"]
}, XD = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function np(e) {
  return e ? "open" : "closed";
}
function mi(e) {
  return e === "indeterminate";
}
function ap(e) {
  return mi(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function JD(e) {
  const t = gt();
  for (const n of e)
    if (n === t || (n.focus(), gt() !== t)) return;
}
function ZD(e, t) {
  const { x: n, y: a } = e;
  let o = !1;
  for (let r = 0, s = t.length - 1; r < t.length; s = r++) {
    const i = t[r].x, u = t[r].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (o = !o);
  }
  return o;
}
function QD(e, t) {
  if (!t) return !1;
  const n = {
    x: e.clientX,
    y: e.clientY
  };
  return ZD(n, t);
}
function bs(e) {
  return e.pointerType === "mouse";
}
const e3 = "DialogTitle", t3 = "DialogContent";
function n3({ titleName: e = e3, contentName: t = t3, componentLink: n = "dialog.html#title", titleId: a, descriptionId: o, contentElement: r }) {
  const s = `Warning: \`${t}\` requires a \`${e}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${n}`, i = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${t}.`;
  be(() => {
    var c;
    document.getElementById(a) || console.warn(s);
    const d = (c = r.value) == null ? void 0 : c.getAttribute("aria-describedby");
    o && d && (document.getElementById(o) || console.warn(i));
  });
}
var a3 = /* @__PURE__ */ b({
  __name: "DialogContentImpl",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = da(), { forwardRef: r, currentElement: s } = le();
    return o.titleId || (o.titleId = yt(void 0, "reka-dialog-title")), o.descriptionId || (o.descriptionId = yt(void 0, "reka-dialog-description")), be(() => {
      o.contentElement = s, gt() !== document.body && (o.triggerElement.value = gt());
    }), process.env.NODE_ENV !== "production" && n3({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: o.titleId,
      descriptionId: o.descriptionId,
      contentElement: s
    }), (i, u) => (g(), C(l(Db), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [N(l(Gs), A({
        id: l(o).contentId,
        ref: l(r),
        as: i.as,
        "as-child": i.asChild,
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        role: "dialog",
        "aria-describedby": l(o).descriptionId,
        "aria-labelledby": l(o).titleId,
        "data-state": l(np)(l(o).open.value)
      }, i.$attrs, {
        onDismiss: u[0] || (u[0] = (d) => l(o).onOpenChange(!1)),
        onEscapeKeyDown: u[1] || (u[1] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[2] || (u[2] = (d) => a("focusOutside", d)),
        onInteractOutside: u[3] || (u[3] = (d) => a("interactOutside", d)),
        onPointerDownOutside: u[4] || (u[4] = (d) => a("pointerDownOutside", d))
      }), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "as",
        "as-child",
        "disable-outside-pointer-events",
        "aria-describedby",
        "aria-labelledby",
        "data-state"
      ])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), kb = a3, o3 = /* @__PURE__ */ b({
  __name: "DialogContentModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = da(), r = Kn(a), { forwardRef: s, currentElement: i } = le();
    return Qf(i), (u, d) => (g(), C(kb, A({
      ...n,
      ...l(r)
    }, {
      ref: l(s),
      "trap-focus": l(o).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        var f;
        c.defaultPrevented || (c.preventDefault(), (f = l(o).triggerElement.value) == null || f.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0;
        (f.button === 2 || p) && c.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (c) => {
        c.preventDefault();
      })
    }), {
      default: y(() => [w(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), r3 = o3, s3 = /* @__PURE__ */ b({
  __name: "DialogContentNonModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    le();
    const r = da(), s = O(!1), i = O(!1);
    return (u, d) => (g(), C(kb, A({
      ...n,
      ...l(o)
    }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        var f;
        c.defaultPrevented || (s.value || (f = l(r).triggerElement.value) == null || f.focus(), c.preventDefault()), s.value = !1, i.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = (c) => {
        var v;
        c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const f = c.target;
        ((v = l(r).triggerElement.value) == null ? void 0 : v.contains(f)) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && i.value && c.preventDefault();
      })
    }), {
      default: y(() => [w(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), l3 = s3, i3 = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = da(), r = Kn(a), { forwardRef: s } = le();
    return (i, u) => (g(), C(l(nn), { present: i.forceMount || l(o).open.value }, {
      default: y(() => [l(o).modal.value ? (g(), C(r3, A({
        key: 0,
        ref: l(s)
      }, {
        ...n,
        ...l(r),
        ...i.$attrs
      }), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16)) : (g(), C(l3, A({
        key: 1,
        ref: l(s)
      }, {
        ...n,
        ...l(r),
        ...i.$attrs
      }), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), u3 = i3, d3 = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = da();
    return (a, o) => (g(), C(l(se), A(t, { id: l(n).descriptionId }), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), c3 = d3, f3 = /* @__PURE__ */ b({
  __name: "DialogOverlayImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = da();
    return Jf(!0), le(), (n, a) => (g(), C(l(se), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": l(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state"
    ]));
  }
}), p3 = f3, v3 = /* @__PURE__ */ b({
  __name: "DialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = da(), { forwardRef: n } = le();
    return (a, o) => {
      var r;
      return (r = l(t)) != null && r.modal.value ? (g(), C(l(nn), {
        key: 0,
        present: a.forceMount || l(t).open.value
      }, {
        default: y(() => [N(p3, A(a.$attrs, {
          ref: l(n),
          as: a.as,
          "as-child": a.asChild
        }), {
          default: y(() => [w(a.$slots, "default")]),
          _: 3
        }, 16, ["as", "as-child"])]),
        _: 3
      }, 8, ["present"])) : Pe("v-if", !0);
    };
  }
}), m3 = v3, h3 = /* @__PURE__ */ b({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: !1,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = yb();
    return (n, a) => l(t) || n.forceMount ? (g(), C(Co, {
      key: 0,
      to: n.to,
      disabled: n.disabled,
      defer: n.defer
    }, [w(n.$slots, "default")], 8, [
      "to",
      "disabled",
      "defer"
    ])) : Pe("v-if", !0);
  }
}), pu = h3, g3 = /* @__PURE__ */ b({
  __name: "DialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(pu), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), y3 = g3, b3 = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e, n = da();
    return le(), (a, o) => (g(), C(l(se), A(t, { id: l(n).titleId }), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), _3 = b3, w3 = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = da(), { forwardRef: a, currentElement: o } = le();
    return n.contentId || (n.contentId = yt(void 0, "reka-dialog-content")), be(() => {
      n.triggerElement.value = o.value;
    }), (r, s) => (g(), C(l(se), A(t, {
      ref: l(a),
      type: r.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": l(n).open.value || !1,
      "aria-controls": l(n).open.value ? l(n).contentId : void 0,
      "data-state": l(n).open.value ? "open" : "closed",
      onClick: l(n).onOpenToggle
    }), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "onClick"
    ]));
  }
}), x3 = w3, C3 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "AspectRatio",
  props: {
    ratio: {
      type: Number,
      required: !1,
      default: 1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = le(), a = E(() => 1 / t.ratio * 100);
    return (o, r) => (g(), U("div", {
      style: vt(`position: relative; width: 100%; padding-bottom: ${a.value}%`),
      "data-reka-aspect-ratio-wrapper": ""
    }, [N(l(se), A({
      ref: l(n),
      "as-child": o.asChild,
      as: o.as,
      style: {
        position: "absolute",
        inset: "0px"
      }
    }, o.$attrs), {
      default: y(() => [w(o.$slots, "default", { aspect: a.value })]),
      _: 3
    }, 16, ["as-child", "as"])], 4));
  }
}), S3 = C3;
function $3(e) {
  function t(a) {
    return Array.isArray(e.date.value) ? e.date.value.some((o) => Dt(o, a)) : e.date.value ? Dt(e.date.value, a) : !1;
  }
  const n = E(() => {
    var a, o, r, s;
    if (Array.isArray(e.date.value)) {
      if (!e.date.value.length) return !1;
      for (const i of e.date.value)
        if ((a = e.isDateDisabled) != null && a.call(e, i) || (o = e.isDateUnavailable) != null && o.call(e, i)) return !0;
    } else {
      if (!e.date.value) return !1;
      if ((r = e.isDateDisabled) != null && r.call(e, e.date.value) || (s = e.isDateUnavailable) != null && s.call(e, e.date.value)) return !0;
    }
    return !1;
  });
  return {
    isDateSelected: t,
    isInvalid: n
  };
}
function B3(e, t) {
  const n = t(e), a = n.compare(e), o = {};
  return a >= 7 && (o.day = 1), a >= ys(e) && (o.month = 1), n.set({ ...o });
}
function P3(e, t) {
  const n = t(e), a = e.compare(n), o = {};
  return a >= 7 && (o.day = 35), a >= ys(e) && (o.month = 13), n.set({ ...o });
}
function E3(e, t) {
  return t(e);
}
function D3(e, t) {
  return t(e);
}
function Ob(e) {
  const t = ZE(e.locale.value), n = E(() => {
    const h = { calendar: e.placeholder.value.calendar.identifier };
    return e.placeholder.value.calendar.identifier === "gregory" && e.placeholder.value.era === "BC" && (h.era = "short"), h;
  }), a = O(so({
    dateObj: e.placeholder.value,
    weekStartsOn: e.weekStartsOn.value,
    locale: e.locale.value,
    fixedWeeks: e.fixedWeeks.value,
    numberOfMonths: e.numberOfMonths.value
  })), o = E(() => a.value.map((h) => h.value));
  function r(h) {
    return !o.value.some((_) => gv(h, _));
  }
  const s = (h) => {
    if (!e.maxValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const _ = a.value[a.value.length - 1].value;
    if (!h && !e.nextPage.value) {
      const S = _.add({ months: 1 }).set({ day: 1 });
      return Ll(S, e.maxValue.value);
    }
    const x = B3(_, h || e.nextPage.value);
    return Ll(x, e.maxValue.value);
  }, i = (h) => {
    if (!e.minValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const _ = a.value[0].value;
    if (!h && !e.prevPage.value) {
      const S = _.subtract({ months: 1 }).set({ day: 35 });
      return ho(S, e.minValue.value);
    }
    const x = P3(_, h || e.prevPage.value);
    return ho(x, e.minValue.value);
  };
  function u(h) {
    var _;
    return !!((_ = e.isDateDisabled) != null && _.call(e, h) || e.disabled.value || e.maxValue.value && Ll(h, e.maxValue.value) || e.minValue.value && ho(h, e.minValue.value));
  }
  const d = (h) => {
    var _;
    return !!((_ = e.isDateUnavailable) != null && _.call(e, h));
  }, c = E(() => a.value.length ? a.value[0].rows[0].map((h) => t.dayOfWeek(Vn(h), e.weekdayFormat.value)) : []), f = (h) => {
    const _ = a.value[0].value;
    if (!h && !e.nextPage.value) {
      const D = _.add({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), B = so({
        dateObj: D,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = B, e.placeholder.value = B[0].value.set({ day: 1 });
      return;
    }
    const x = E3(_, h || e.nextPage.value), S = so({
      dateObj: x,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!h) {
      const D = S[0].value.compare(_);
      D >= ys(_) && ($.day = 1), D >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  }, p = (h) => {
    const _ = a.value[0].value;
    if (!h && !e.prevPage.value) {
      const D = _.subtract({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), B = so({
        dateObj: D,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = B, e.placeholder.value = B[0].value.set({ day: 1 });
      return;
    }
    const x = D3(_, h || e.prevPage.value), S = so({
      dateObj: x,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!h) {
      const D = _.compare(S[0].value);
      D >= ys(_) && ($.day = 1), D >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  };
  ce(e.placeholder, (h) => {
    o.value.some((_) => gv(_, h)) || (a.value = so({
      dateObj: h,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    }));
  }), ce([
    e.locale,
    e.weekStartsOn,
    e.fixedWeeks,
    e.numberOfMonths
  ], () => {
    a.value = so({
      dateObj: e.placeholder.value,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
  });
  const v = E(() => {
    if (!a.value.length) return "";
    if (e.locale.value !== t.getLocale() && t.setLocale(e.locale.value), a.value.length === 1) {
      const k = a.value[0].value;
      return `${t.fullMonthAndYear(Vn(k), n.value)}`;
    }
    const h = Vn(a.value[0].value), _ = Vn(a.value[a.value.length - 1].value), x = t.fullMonth(h, n.value), S = t.fullMonth(_, n.value), $ = t.fullYear(h, n.value), D = t.fullYear(_, n.value);
    return $ === D ? `${x} - ${S} ${D}` : `${x} ${$} - ${S} ${D}`;
  }), m = E(() => `${e.calendarLabel.value ?? "Event Date"}, ${v.value}`);
  return {
    isDateDisabled: u,
    isDateUnavailable: d,
    isNextButtonDisabled: s,
    isPrevButtonDisabled: i,
    grid: a,
    weekdays: c,
    visibleView: o,
    isOutsideVisibleView: r,
    formatter: t,
    nextPage: f,
    prevPage: p,
    headingValue: v,
    fullCalendarLabel: m
  };
}
const M3 = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, k3 = {
  role: "heading",
  "aria-level": "2"
}, [kr, O3] = He("CalendarRoot");
var T3 = /* @__PURE__ */ b({
  __name: "CalendarRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: o, readonly: r, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, multiple: f, minValue: p, maxValue: v, numberOfMonths: m, preventDeselect: h, isDateDisabled: _, isDateUnavailable: x, calendarLabel: S, defaultValue: $, nextPage: D, prevPage: B, dir: k, locale: M, disableDaysOutsideCurrentView: I } = Be(n), { primitiveElement: T, currentElement: P } = Kt(), q = ep(M), R = tn(k), Q = rt(n, "modelValue", a, {
      defaultValue: $.value,
      passive: n.modelValue === void 0
    }), ee = wb({
      defaultPlaceholder: n.placeholder,
      defaultValue: Q.value,
      locale: n.locale
    }), K = rt(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ee.copy(),
      passive: n.placeholder === void 0
    });
    function W(L) {
      K.value = L.copy();
    }
    const { fullCalendarLabel: j, headingValue: J, isDateDisabled: z, isDateUnavailable: Y, isNextButtonDisabled: Z, isPrevButtonDisabled: pe, weekdays: $e, isOutsideVisibleView: Ce, nextPage: De, prevPage: ue, formatter: V, grid: te } = Ob({
      locale: q,
      placeholder: K,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: m,
      minValue: p,
      maxValue: v,
      disabled: o,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: _.value,
      isDateUnavailable: x.value,
      calendarLabel: S,
      nextPage: D,
      prevPage: B
    }), { isInvalid: H, isDateSelected: re } = $3({
      date: Q,
      isDateDisabled: z,
      isDateUnavailable: Y
    });
    ce(Q, (L) => {
      if (Array.isArray(L) && L.length) {
        const _e = L[L.length - 1];
        _e && !ja(K.value, _e) && W(_e);
      } else !Array.isArray(L) && L && !ja(K.value, L) && W(L);
    });
    function ie(L) {
      if (f.value) {
        if (!Q.value) Q.value = [L.copy()];
        else if (Array.isArray(Q.value)) {
          if (Q.value.findIndex((we) => Dt(we, L)) === -1) Q.value = [...Q.value, L];
          else if (!h.value) {
            const we = Q.value.filter((Te) => !Dt(Te, L));
            if (!we.length) {
              K.value = L.copy(), Q.value = void 0;
              return;
            }
            Q.value = we.map((Te) => Te.copy());
          }
        }
      } else {
        if (!Q.value) {
          Q.value = L.copy();
          return;
        }
        !h.value && ja(Q.value, L) ? (K.value = L.copy(), Q.value = void 0) : Q.value = L.copy();
      }
    }
    return be(() => {
      s.value && xb(P.value);
    }), O3({
      isDateUnavailable: Y,
      dir: R,
      isDateDisabled: z,
      locale: q,
      formatter: V,
      modelValue: Q,
      placeholder: K,
      disabled: o,
      initialFocus: s,
      pagedNavigation: i,
      grid: te,
      weekDays: $e,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      multiple: f,
      numberOfMonths: m,
      readonly: r,
      preventDeselect: h,
      fullCalendarLabel: j,
      headingValue: J,
      isInvalid: H,
      isDateSelected: re,
      isNextButtonDisabled: Z,
      isPrevButtonDisabled: pe,
      isOutsideVisibleView: Ce,
      nextPage: De,
      prevPage: ue,
      parentElement: P,
      onPlaceholderChange: W,
      onDateChange: ie,
      disableDaysOutsideCurrentView: I,
      minValue: p,
      maxValue: v
    }), (L, _e) => (g(), C(l(se), {
      ref_key: "primitiveElement",
      ref: T,
      as: L.as,
      "as-child": L.asChild,
      "aria-label": l(j),
      "data-readonly": l(r) ? "" : void 0,
      "data-disabled": l(o) ? "" : void 0,
      "data-invalid": l(H) ? "" : void 0,
      dir: l(R)
    }, {
      default: y(() => [w(L.$slots, "default", {
        date: l(K),
        grid: l(te),
        weekDays: l($e),
        weekStartsOn: l(u),
        locale: l(q),
        fixedWeeks: l(c),
        modelValue: l(Q)
      }), ye("div", M3, [ye("div", k3, Ve(l(j)), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), A3 = T3, I3 = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = kr();
    return (n, a) => {
      var o, r;
      return g(), C(l(se), {
        as: n.as,
        "as-child": n.asChild,
        role: "gridcell",
        "aria-selected": l(t).isDateSelected(n.date) ? !0 : void 0,
        "aria-disabled": l(t).isDateDisabled(n.date) || ((r = (o = l(t)).isDateUnavailable) == null ? void 0 : r.call(o, n.date)) || l(t).disableDaysOutsideCurrentView.value,
        "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
      }, {
        default: y(() => [w(n.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-selected",
        "aria-disabled",
        "data-disabled"
      ]);
    };
  }
}), R3 = I3, q3 = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Ks(), a = kr(), { primitiveElement: o } = Kt(), r = E(() => t.day.day.toLocaleString(a.locale.value)), s = E(() => a.formatter.custom(Vn(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), i = E(() => {
      var x;
      return ((x = a.isDateUnavailable) == null ? void 0 : x.call(a, t.day)) ?? !1;
    }), u = E(() => gg(t.day, _r())), d = E(() => !ef(t.day, t.month)), c = E(() => a.isOutsideVisibleView(t.day)), f = E(() => a.isDateDisabled(t.day) || a.disableDaysOutsideCurrentView.value && d.value), p = E(() => !a.disabled.value && Dt(t.day, a.placeholder.value)), v = E(() => a.isDateSelected(t.day));
    function m(x) {
      var S;
      a.readonly.value || a.isDateDisabled(x) || (S = a.isDateUnavailable) != null && S.call(a, x) || a.onDateChange(x);
    }
    function h() {
      f.value || m(t.day);
    }
    function _(x) {
      if (f.value) return;
      x.preventDefault(), x.stopPropagation();
      const S = a.parentElement.value, $ = 7, D = a.dir.value === "rtl" ? -1 : 1;
      switch (x.code) {
        case n.ARROW_RIGHT:
          B(t.day, D);
          break;
        case n.ARROW_LEFT:
          B(t.day, -D);
          break;
        case n.ARROW_UP:
          B(t.day, -$);
          break;
        case n.ARROW_DOWN:
          B(t.day, $);
          break;
        case n.ENTER:
        case n.SPACE_CODE:
          m(t.day);
      }
      function B(k, M) {
        const I = k.add({ days: M });
        if (a.minValue.value && I.compare(a.minValue.value) < 0 || a.maxValue.value && I.compare(a.maxValue.value) > 0) return;
        const T = S.querySelector(`[data-value='${I.toString()}']:not([data-outside-view])`);
        if (!T) {
          if (M > 0) {
            if (a.isNextButtonDisabled()) return;
            a.nextPage();
          } else {
            if (a.isPrevButtonDisabled()) return;
            a.prevPage();
          }
          he(() => {
            B(k, M);
          });
          return;
        }
        if (T && T.hasAttribute("data-disabled")) return B(I, M);
        a.onPlaceholderChange(I), T == null || T.focus();
      }
    }
    return (x, S) => (g(), C(l(se), A({
      ref_key: "primitiveElement",
      ref: o
    }, t, {
      role: "button",
      "aria-label": s.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-disabled": f.value || i.value ? !0 : void 0,
      "data-selected": v.value ? !0 : void 0,
      "data-value": x.day.toString(),
      "data-disabled": f.value ? "" : void 0,
      "data-unavailable": i.value ? "" : void 0,
      "data-today": u.value ? "" : void 0,
      "data-outside-view": d.value ? "" : void 0,
      "data-outside-visible-view": c.value ? "" : void 0,
      "data-focused": p.value ? "" : void 0,
      tabindex: p.value ? 0 : d.value || f.value ? void 0 : -1,
      onClick: h,
      onKeydown: [Qe(_, [
        "up",
        "down",
        "left",
        "right",
        "space",
        "enter"
      ]), S[0] || (S[0] = Qe(We(() => {
      }, ["prevent"]), ["enter"]))]
    }), {
      default: y(() => [w(x.$slots, "default", {
        dayValue: r.value,
        disabled: f.value,
        today: u.value,
        selected: v.value,
        outsideView: d.value,
        outsideVisibleView: c.value,
        unavailable: i.value
      }, () => [Re(Ve(r.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-disabled",
      "data-selected",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-outside-visible-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), F3 = q3, V3 = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = kr(), a = E(() => n.disabled.value ? !0 : void 0), o = E(() => n.readonly.value ? !0 : void 0);
    return (r, s) => (g(), C(l(se), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": o.value,
      "aria-disabled": a.value,
      "data-readonly": o.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), N3 = V3, L3 = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), z3 = L3, H3 = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), A(t, { "aria-hidden": "true" }), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), U3 = H3, j3 = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), W3 = j3, K3 = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), G3 = K3, Y3 = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), X3 = Y3, J3 = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = kr();
    return (a, o) => (g(), C(l(se), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [w(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Ve(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), Z3 = J3, Q3 = /* @__PURE__ */ b({
  __name: "CalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = kr();
    return (o, r) => (g(), C(l(se), {
      as: t.as,
      "as-child": t.asChild,
      "aria-label": "Next page",
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: r[0] || (r[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [w(o.$slots, "default", { disabled: n.value }, () => [r[1] || (r[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), eM = Q3, tM = /* @__PURE__ */ b({
  __name: "CalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = kr();
    return (o, r) => (g(), C(l(se), {
      "aria-label": "Previous page",
      as: t.as,
      "as-child": t.asChild,
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: r[0] || (r[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [w(o.$slots, "default", { disabled: n.value }, () => [r[1] || (r[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), nM = tM;
const _m = "data-reka-collection-item";
function Gt(e = {}) {
  const { key: t = "", isProvider: n = !1 } = e, a = `${t}CollectionProvider`;
  let o;
  if (n) {
    const c = O(/* @__PURE__ */ new Map());
    o = {
      collectionRef: O(),
      itemMap: c
    }, Mn(a, o);
  } else o = vn(a);
  const r = (c = !1) => {
    const f = o.collectionRef.value;
    if (!f) return [];
    const p = Array.from(f.querySelectorAll(`[${_m}]`)), m = Array.from(o.itemMap.value.values()).sort((h, _) => p.indexOf(h.ref) - p.indexOf(_.ref));
    return c ? m : m.filter((h) => h.ref.dataset.disabled !== "");
  }, s = b({
    name: "CollectionSlot",
    setup(c, { slots: f }) {
      const { primitiveElement: p, currentElement: v } = Kt();
      return ce(v, () => {
        o.collectionRef.value = v.value;
      }), () => Bt(vi, { ref: p }, f);
    }
  }), i = b({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(c, { slots: f, attrs: p }) {
      const { primitiveElement: v, currentElement: m } = Kt();
      return Me((h) => {
        if (m.value) {
          const _ = fg(m.value);
          o.itemMap.value.set(_, {
            ref: m.value,
            value: c.value
          }), h(() => o.itemMap.value.delete(_));
        }
      }), () => Bt(vi, {
        ...p,
        [_m]: "",
        ref: v
      }, f);
    }
  }), u = E(() => Array.from(o.itemMap.value.values())), d = E(() => o.itemMap.value.size);
  return {
    getItems: r,
    reactiveItems: u,
    itemMapSize: d,
    CollectionSlot: s,
    CollectionItem: i
  };
}
const aM = "rovingFocusGroup.onEntryFocus", oM = {
  bubbles: !1,
  cancelable: !0
}, rM = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function sM(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Tb(e, t, n) {
  const a = sM(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return rM[a];
}
function Ab(e, t = !1) {
  const n = gt();
  for (const a of e)
    if (a === n || (a.focus({ preventScroll: t }), gt() !== n)) return;
}
function lM(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
const [iM, uM] = He("RovingFocusGroup");
var dM = /* @__PURE__ */ b({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { loop: r, orientation: s, dir: i } = Be(a), u = tn(i), d = rt(a, "currentTabStopId", o, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), c = O(!1), f = O(!1), p = O(0), { getItems: v, CollectionSlot: m } = Gt({ isProvider: !0 });
    function h(x) {
      const S = !f.value;
      if (x.currentTarget && x.target === x.currentTarget && S && !c.value) {
        const $ = new CustomEvent(aM, oM);
        if (x.currentTarget.dispatchEvent($), o("entryFocus", $), !$.defaultPrevented) {
          const D = v().map((T) => T.ref).filter((T) => T.dataset.disabled !== ""), B = D.find((T) => T.getAttribute("data-active") === ""), k = D.find((T) => T.getAttribute("data-highlighted") === ""), M = D.find((T) => T.id === d.value), I = [
            B,
            k,
            M,
            ...D
          ].filter(Boolean);
          Ab(I, a.preventScrollOnEntryFocus);
        }
      }
      f.value = !1;
    }
    function _() {
      setTimeout(() => {
        f.value = !1;
      }, 1);
    }
    return t({ getItems: v }), uM({
      loop: r,
      dir: u,
      orientation: s,
      currentTabStopId: d,
      onItemFocus: (x) => {
        d.value = x;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        p.value++;
      },
      onFocusableItemRemove: () => {
        p.value--;
      }
    }), (x, S) => (g(), C(l(m), null, {
      default: y(() => [N(l(se), {
        tabindex: c.value || p.value === 0 ? -1 : 0,
        "data-orientation": l(s),
        as: x.as,
        "as-child": x.asChild,
        dir: l(u),
        style: { outline: "none" },
        onMousedown: S[0] || (S[0] = ($) => f.value = !0),
        onMouseup: _,
        onFocus: h,
        onBlur: S[1] || (S[1] = ($) => c.value = !1)
      }, {
        default: y(() => [w(x.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), vu = dM, cM = /* @__PURE__ */ b({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = iM(), a = yt(), o = E(() => t.tabStopId || a), r = E(() => n.currentTabStopId.value === o.value), { getItems: s, CollectionItem: i } = Gt();
    be(() => {
      t.focusable && n.onFocusableItemAdd();
    }), Ze(() => {
      t.focusable && n.onFocusableItemRemove();
    });
    function u(d) {
      if (d.key === "Tab" && d.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (d.target !== d.currentTarget) return;
      const c = Tb(d, n.orientation.value, n.dir.value);
      if (c !== void 0) {
        if (d.metaKey || d.ctrlKey || d.altKey || !t.allowShiftKey && d.shiftKey) return;
        d.preventDefault();
        let f = [...s().map((p) => p.ref).filter((p) => p.dataset.disabled !== "")];
        if (c === "last") f.reverse();
        else if (c === "prev" || c === "next") {
          c === "prev" && f.reverse();
          const p = f.indexOf(d.currentTarget);
          f = n.loop.value ? lM(f, p + 1) : f.slice(p + 1);
        }
        he(() => Ab(f));
      }
    }
    return (d, c) => (g(), C(l(i), null, {
      default: y(() => [N(l(se), {
        tabindex: r.value ? 0 : -1,
        "data-orientation": l(n).orientation.value,
        "data-active": d.active ? "" : void 0,
        "data-disabled": d.focusable ? void 0 : "",
        as: d.as,
        "as-child": d.asChild,
        onMousedown: c[0] || (c[0] = (f) => {
          d.focusable ? l(n).onItemFocus(o.value) : f.preventDefault();
        }),
        onFocus: c[1] || (c[1] = (f) => l(n).onItemFocus(o.value)),
        onKeydown: u
      }, {
        default: y(() => [w(d.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), mu = cM, fM = /* @__PURE__ */ b({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (g(), C(l(se), {
      as: t.as,
      "as-child": t.asChild,
      "aria-hidden": t.feature === "focusable" ? "true" : void 0,
      "data-hidden": t.feature === "fully-hidden" ? "" : void 0,
      tabindex: t.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: y(() => [w(t.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), Ib = fM, pM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Kt(), o = E(() => t.checked ?? t.value);
    return ce(o, (r, s) => {
      if (!a.value) return;
      const i = a.value, u = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(u, "value").set;
      if (c && r !== s) {
        const f = new Event("input", { bubbles: !0 }), p = new Event("change", { bubbles: !0 });
        c.call(i, r), i.dispatchEvent(f), i.dispatchEvent(p);
      }
    }), (r, s) => (g(), C(Ib, A({
      ref_key: "primitiveElement",
      ref: n
    }, {
      ...t,
      ...r.$attrs
    }, { as: "input" }), null, 16));
  }
}), wm = pM, vM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, n = E(() => typeof t.value == "object" && Array.isArray(t.value) && t.value.length === 0 && t.required), a = E(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" || t.value === null || t.value === void 0 ? [{
      name: t.name,
      value: t.value
    }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((o, r) => typeof o == "object" ? Object.entries(o).map(([s, i]) => ({
      name: `${t.name}[${r}][${s}]`,
      value: i
    })) : {
      name: `${t.name}[${r}]`,
      value: o
    }) : t.value !== null && typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([o, r]) => ({
      name: `${t.name}[${o}]`,
      value: r
    })) : []);
    return (o, r) => (g(), U(Fe, null, [Pe(" We render single input if it's required "), n.value ? (g(), C(wm, A({ key: o.name }, {
      ...t,
      ...o.$attrs
    }, {
      name: o.name,
      value: o.value
    }), null, 16, ["name", "value"])) : (g(!0), U(Fe, { key: 1 }, $t(a.value, (s) => (g(), C(wm, A({ key: s.name }, { ref_for: !0 }, {
      ...t,
      ...o.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), Ta = vM;
const [mM] = He("CheckboxGroupRoot");
function hi(e) {
  return e === "indeterminate";
}
function Rb(e) {
  return hi(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
const [hM, gM] = He("CheckboxRoot");
var yM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultValue: {
      type: [Boolean, String],
      required: !1
    },
    modelValue: {
      type: [
        Boolean,
        String,
        null
      ],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: null,
      required: !1,
      default: "on"
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = le(), s = mM(null), i = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), u = E(() => (s == null ? void 0 : s.disabled.value) || n.disabled), d = E(() => mo(s == null ? void 0 : s.modelValue.value) ? i.value === "indeterminate" ? "indeterminate" : i.value : fi(s.modelValue.value, n.value));
    function c() {
      if (mo(s == null ? void 0 : s.modelValue.value))
        i.value = hi(i.value) ? !0 : !i.value;
      else {
        const v = [...s.modelValue.value || []];
        if (fi(v, n.value)) {
          const m = v.findIndex((h) => ra(h, n.value));
          v.splice(m, 1);
        } else v.push(n.value);
        s.modelValue.value = v;
      }
    }
    const f = ro(r), p = E(() => {
      var v;
      return n.id && r.value ? (v = document.querySelector(`[for="${n.id}"]`)) == null ? void 0 : v.innerText : void 0;
    });
    return gM({
      disabled: u,
      state: d
    }), (v, m) => {
      var h, _;
      return g(), C(mt((h = l(s)) != null && h.rovingFocus.value ? l(mu) : l(se)), A(v.$attrs, {
        id: v.id,
        ref: l(o),
        role: "checkbox",
        "as-child": v.asChild,
        as: v.as,
        type: v.as === "button" ? "button" : void 0,
        "aria-checked": l(hi)(d.value) ? "mixed" : d.value,
        "aria-required": v.required,
        "aria-label": v.$attrs["aria-label"] || p.value,
        "data-state": l(Rb)(d.value),
        "data-disabled": u.value ? "" : void 0,
        disabled: u.value,
        focusable: (_ = l(s)) != null && _.rovingFocus.value ? !u.value : void 0,
        onKeydown: Qe(We(() => {
        }, ["prevent"]), ["enter"]),
        onClick: c
      }), {
        default: y(() => [w(v.$slots, "default", {
          modelValue: l(i),
          state: d.value
        }), l(f) && v.name && !l(s) ? (g(), C(l(Ta), {
          key: 0,
          type: "checkbox",
          checked: !!d.value,
          name: v.name,
          value: v.value,
          disabled: u.value,
          required: v.required
        }, null, 8, [
          "checked",
          "name",
          "value",
          "disabled",
          "required"
        ])) : Pe("v-if", !0)]),
        _: 3
      }, 16, [
        "id",
        "as-child",
        "as",
        "type",
        "aria-checked",
        "aria-required",
        "aria-label",
        "data-state",
        "data-disabled",
        "disabled",
        "focusable",
        "onKeydown"
      ]);
    };
  }
}), bM = yM, _M = /* @__PURE__ */ b({
  __name: "CheckboxIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = le(), n = hM();
    return (a, o) => (g(), C(l(nn), { present: a.forceMount || l(hi)(l(n).state.value) || l(n).state.value === !0 }, {
      default: y(() => [N(l(se), A({
        ref: l(t),
        "data-state": l(Rb)(l(n).state.value),
        "data-disabled": l(n).disabled.value ? "" : void 0,
        style: { pointerEvents: "none" },
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [w(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), wM = _M;
const [qb, xM] = He("PopperRoot");
var CM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = O();
    return xM({
      anchor: t,
      onAnchorChange: (n) => t.value = n
    }), (n, a) => w(n.$slots, "default");
  }
}), hu = CM, SM = /* @__PURE__ */ b({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = le(), o = qb();
    return Qc(() => {
      o.onAnchorChange(t.reference ?? a.value);
    }), (r, s) => (g(), C(l(se), {
      ref: l(n),
      as: r.as,
      "as-child": r.asChild
    }, {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), op = SM;
function $M(e) {
  return e !== null;
}
function BM(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      var _, x, S;
      const { placement: n, rects: a, middlewareData: o } = t, s = ((_ = o.arrow) == null ? void 0 : _.centerOffset) !== 0, i = s ? 0 : e.arrowWidth, u = s ? 0 : e.arrowHeight, [d, c] = mc(n), f = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[c], p = (((x = o.arrow) == null ? void 0 : x.x) ?? 0) + i / 2, v = (((S = o.arrow) == null ? void 0 : S.y) ?? 0) + u / 2;
      let m = "", h = "";
      return d === "bottom" ? (m = s ? f : `${p}px`, h = `${-u}px`) : d === "top" ? (m = s ? f : `${p}px`, h = `${a.floating.height + u}px`) : d === "right" ? (m = `${-u}px`, h = s ? f : `${v}px`) : d === "left" && (m = `${a.floating.width + u}px`, h = s ? f : `${v}px`), { data: {
        x: m,
        y: h
      } };
    }
  };
}
function mc(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
const Fb = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [UU, PM] = He("PopperContent");
var EM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ ji({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...Fb }),
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = qb(), { forwardRef: r, currentElement: s } = le(), i = O(), u = O(), { width: d, height: c } = pD(u), f = E(() => n.side + (n.align !== "center" ? `-${n.align}` : "")), p = E(() => typeof n.collisionPadding == "number" ? n.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...n.collisionPadding
    }), v = E(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = E(() => ({
      padding: p.value,
      boundary: v.value.filter($M),
      altBoundary: v.value.length > 0
    })), h = E(() => ({
      mainAxis: n.sideFlip,
      crossAxis: n.alignFlip
    })), _ = fE(() => [
      Xg({
        mainAxis: n.sideOffset + c.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && ii({
        ...m.value,
        ...h.value
      }),
      n.avoidCollisions && Jg({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? ey() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && ii({
        ...m.value,
        ...h.value
      }),
      Zg({
        ...m.value,
        apply: ({ elements: R, rects: Q, availableWidth: ee, availableHeight: K }) => {
          const { width: W, height: j } = Q.reference, J = R.floating.style;
          J.setProperty("--reka-popper-available-width", `${ee}px`), J.setProperty("--reka-popper-available-height", `${K}px`), J.setProperty("--reka-popper-anchor-width", `${W}px`), J.setProperty("--reka-popper-anchor-height", `${j}px`);
        }
      }),
      u.value && ty({
        element: u.value,
        padding: n.arrowPadding
      }),
      BM({
        arrowWidth: d.value,
        arrowHeight: c.value
      }),
      n.hideWhenDetached && Qg({
        strategy: "referenceHidden",
        ...m.value
      })
    ]), x = E(() => n.reference ?? o.anchor.value), { floatingStyles: S, placement: $, isPositioned: D, middlewareData: B } = ay(x, i, {
      strategy: n.positionStrategy,
      placement: f,
      whileElementsMounted: (...R) => Yg(...R, {
        layoutShift: !n.disableUpdateOnLayoutShift,
        animationFrame: n.updatePositionStrategy === "always"
      }),
      middleware: _
    }), k = E(() => mc($.value)[0]), M = E(() => mc($.value)[1]);
    Qc(() => {
      D.value && a("placed");
    });
    const I = E(() => {
      var R;
      return ((R = B.value.arrow) == null ? void 0 : R.centerOffset) !== 0;
    }), T = O("");
    Me(() => {
      s.value && (T.value = window.getComputedStyle(s.value).zIndex);
    });
    const P = E(() => {
      var R;
      return ((R = B.value.arrow) == null ? void 0 : R.x) ?? 0;
    }), q = E(() => {
      var R;
      return ((R = B.value.arrow) == null ? void 0 : R.y) ?? 0;
    });
    return PM({
      placedSide: k,
      onArrowChange: (R) => u.value = R,
      arrowX: P,
      arrowY: q,
      shouldHideArrow: I
    }), (R, Q) => {
      var ee, K, W;
      return g(), U("div", {
        ref_key: "floatingRef",
        ref: i,
        "data-reka-popper-content-wrapper": "",
        style: vt({
          ...l(S),
          transform: l(D) ? l(S).transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: T.value,
          "--reka-popper-transform-origin": [(ee = l(B).transformOrigin) == null ? void 0 : ee.x, (K = l(B).transformOrigin) == null ? void 0 : K.y].join(" "),
          ...((W = l(B).hide) == null ? void 0 : W.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [N(l(se), A({ ref: l(r) }, R.$attrs, {
        "as-child": n.asChild,
        as: R.as,
        "data-side": k.value,
        "data-align": M.value,
        style: { animation: l(D) ? void 0 : "none" }
      }), {
        default: y(() => [w(R.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-side",
        "data-align",
        "style"
      ])], 4);
    };
  }
}), rp = EM, DM = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: t } = le();
    return (n, a) => (g(), C(l(op), {
      "as-child": "",
      reference: n.reference
    }, {
      default: y(() => [N(l(se), A({
        ref: l(t),
        "as-child": n.asChild,
        as: n.as
      }, n.$attrs), {
        default: y(() => [w(n.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), MM = DM;
function kM(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => rs(a, t, n)) : rs(e, t, n);
}
function rs(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? (e == null ? void 0 : e[n]) === (t == null ? void 0 : t[n]) : ra(e, t);
}
const [gu, OM] = He("ListboxRoot");
var TM = /* @__PURE__ */ b({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { multiple: r, highlightOnHover: s, orientation: i, disabled: u, selectionBehavior: d, dir: c } = Be(a), { getItems: f } = Gt({ isProvider: !0 }), { handleTypeaheadSearch: p } = $b(), { primitiveElement: v, currentElement: m } = Kt(), h = Ks(), _ = tn(c), x = ro(m), S = O(), $ = O(!1), D = O(!0), B = rt(a, "modelValue", o, {
      defaultValue: a.defaultValue ?? (r.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function k(V) {
      if ($.value = !0, a.multiple) {
        const te = Array.isArray(B.value) ? [...B.value] : [], H = te.findIndex((re) => rs(re, V, a.by));
        a.selectionBehavior === "toggle" ? (H === -1 ? te.push(V) : te.splice(H, 1), B.value = te) : (B.value = [V], S.value = V);
      } else a.selectionBehavior === "toggle" && rs(B.value, V, a.by) ? B.value = void 0 : B.value = V;
      setTimeout(() => {
        $.value = !1;
      }, 1);
    }
    const M = O(null), I = O(null), T = O(!1), P = O(!1), q = tr(), R = tr(), Q = tr();
    function ee() {
      return f().map((V) => V.ref).filter((V) => V.dataset.disabled !== "");
    }
    function K(V, te = !0) {
      if (!V) return;
      M.value = V, D.value && M.value.focus(), te && M.value.scrollIntoView({ block: "nearest" });
      const H = f().find((re) => re.ref === V);
      o("highlight", H);
    }
    function W(V) {
      if (T.value) Q.trigger(V);
      else {
        const te = f().find((H) => rs(H.value, V, a.by));
        te && (M.value = te.ref, K(te.ref));
      }
    }
    function j(V) {
      M.value && M.value.isConnected && (V.preventDefault(), V.stopPropagation(), P.value || M.value.click());
    }
    function J(V) {
      if (D.value) {
        if ($.value = !0, T.value) R.trigger(V);
        else {
          const te = V.altKey || V.ctrlKey || V.metaKey;
          if (te && V.key === "a" && r.value) {
            const H = f(), re = H.map((ie) => ie.value);
            B.value = [...re], V.preventDefault(), K(H[H.length - 1].ref);
          } else if (!te) {
            const H = p(V.key, f());
            H && K(H);
          }
        }
        setTimeout(() => {
          $.value = !1;
        }, 1);
      }
    }
    function z() {
      P.value = !0;
    }
    function Y() {
      he(() => {
        P.value = !1;
      });
    }
    function Z() {
      he(() => {
        const V = new KeyboardEvent("keydown", { key: "PageUp" });
        Ce(V);
      });
    }
    function pe(V) {
      const te = M.value;
      te != null && te.isConnected && (I.value = te), M.value = null, o("leave", V);
    }
    function $e(V) {
      var H, re;
      const te = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if ((H = V.currentTarget) == null || H.dispatchEvent(te), o("entryFocus", te), !te.defaultPrevented)
        if (I.value) K(I.value);
        else {
          const ie = (re = ee()) == null ? void 0 : re[0];
          K(ie);
        }
    }
    function Ce(V) {
      const te = Tb(V, i.value, _.value);
      if (!te) return;
      let H = ee();
      if (M.value) {
        if (te === "last") H.reverse();
        else if (te === "prev" || te === "next") {
          te === "prev" && H.reverse();
          const re = H.indexOf(M.value);
          H = H.slice(re + 1);
        }
        De(V, H[0]);
      }
      if (H.length) {
        const re = !M.value && te === "prev" ? H.length - 1 : 0;
        K(H[re]);
      }
      if (T.value) return R.trigger(V);
    }
    function De(V, te) {
      var re;
      if (!(T.value || a.selectionBehavior !== "replace" || !r.value || !Array.isArray(B.value) || (V.altKey || V.ctrlKey || V.metaKey) && !V.shiftKey) && V.shiftKey) {
        const ie = f().filter((we) => we.ref.dataset.disabled !== "");
        let L = (re = ie.find((we) => we.ref === te)) == null ? void 0 : re.value;
        if (V.key === h.END ? L = ie[ie.length - 1].value : V.key === h.HOME && (L = ie[0].value), !L || !S.value) return;
        const _e = uE(ie.map((we) => we.value), S.value, L);
        B.value = _e;
      }
    }
    async function ue(V) {
      if (await he(), T.value) q.trigger(V);
      else {
        const te = ee(), H = te.find((re) => re.dataset.state === "checked");
        H ? K(H) : te.length && K(te[0]);
      }
    }
    return ce(B, () => {
      $.value || he(() => {
        ue();
      });
    }, {
      immediate: !0,
      deep: !0
    }), t({
      highlightedElement: M,
      highlightItem: W,
      highlightFirstItem: Z,
      highlightSelected: ue,
      getItems: f
    }), OM({
      modelValue: B,
      onValueChange: k,
      multiple: r,
      orientation: i,
      dir: _,
      disabled: u,
      highlightOnHover: s,
      highlightedElement: M,
      isVirtual: T,
      virtualFocusHook: q,
      virtualKeydownHook: R,
      virtualHighlightHook: Q,
      by: a.by,
      firstValue: S,
      selectionBehavior: d,
      focusable: D,
      onLeave: pe,
      onEnter: $e,
      changeHighlight: K,
      onKeydownEnter: j,
      onKeydownNavigation: Ce,
      onKeydownTypeAhead: J,
      onCompositionStart: z,
      onCompositionEnd: Y,
      highlightFirstItem: Z
    }), (V, te) => (g(), C(l(se), {
      ref_key: "primitiveElement",
      ref: v,
      as: V.as,
      "as-child": V.asChild,
      dir: l(_),
      "data-disabled": l(u) ? "" : void 0,
      onPointerleave: pe,
      onFocusout: te[0] || (te[0] = async (H) => {
        const re = H.relatedTarget || H.target;
        await he(), M.value && l(m) && !l(m).contains(re) && pe(H);
      })
    }, {
      default: y(() => [w(V.$slots, "default", { modelValue: l(B) }), l(x) && V.name ? (g(), C(l(Ta), {
        key: 0,
        name: V.name,
        value: l(B),
        disabled: l(u),
        required: V.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : Pe("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), AM = TM, IM = /* @__PURE__ */ b({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: t } = Gt(), n = gu(), a = Ws(!1, 10);
    return (o, r) => (g(), C(l(t), null, {
      default: y(() => [N(l(se), {
        role: "listbox",
        as: o.as,
        "as-child": o.asChild,
        tabindex: l(n).focusable.value ? l(n).highlightedElement.value ? "-1" : "0" : "-1",
        "aria-orientation": l(n).orientation.value,
        "aria-multiselectable": !!l(n).multiple.value,
        "data-orientation": l(n).orientation.value,
        onMousedown: r[0] || (r[0] = We((s) => a.value = !0, ["left"])),
        onFocus: r[1] || (r[1] = (s) => {
          l(a) || l(n).onEnter(s);
        }),
        onKeydown: [
          r[2] || (r[2] = Qe((s) => {
            l(n).orientation.value === "vertical" && (s.key === "ArrowLeft" || s.key === "ArrowRight") || l(n).orientation.value === "horizontal" && (s.key === "ArrowUp" || s.key === "ArrowDown") || (s.preventDefault(), l(n).focusable.value && l(n).onKeydownNavigation(s));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          Qe(l(n).onKeydownEnter, ["enter"]),
          l(n).onKeydownTypeAhead
        ]
      }, {
        default: y(() => [w(o.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), RM = IM, qM = /* @__PURE__ */ b({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = rt(n, "modelValue", t, {
      defaultValue: "",
      passive: n.modelValue === void 0
    }), r = gu(), { primitiveElement: s, currentElement: i } = Kt(), u = E(() => n.disabled || r.disabled.value || !1), d = O();
    return ug(() => {
      var c;
      return d.value = (c = r.highlightedElement.value) == null ? void 0 : c.id;
    }), be(() => {
      r.focusable.value = !1, setTimeout(() => {
        var c;
        n.autoFocus && ((c = i.value) == null || c.focus());
      }, 1);
    }), Ze(() => {
      r.focusable.value = !0;
    }), (c, f) => (g(), C(l(se), {
      ref_key: "primitiveElement",
      ref: s,
      as: c.as,
      "as-child": c.asChild,
      value: l(o),
      disabled: u.value ? "" : void 0,
      "data-disabled": u.value ? "" : void 0,
      "aria-disabled": u.value ?? void 0,
      "aria-activedescendant": d.value,
      type: "text",
      onKeydown: [Qe(We(l(r).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), Qe(l(r).onKeydownEnter, ["enter"])],
      onInput: f[0] || (f[0] = (p) => {
        o.value = p.target.value, l(r).highlightFirstItem();
      }),
      onCompositionstart: l(r).onCompositionStart,
      onCompositionend: l(r).onCompositionEnd
    }, {
      default: y(() => [w(c.$slots, "default", { modelValue: l(o) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), FM = qM;
const [jU, VM] = He("ListboxGroup");
var NM = /* @__PURE__ */ b({
  __name: "ListboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = yt(void 0, "reka-listbox-group");
    return VM({ id: n }), (a, o) => (g(), C(l(se), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), LM = NM;
const zM = "listbox.select", [HM, UM] = He("ListboxItem");
var jM = /* @__PURE__ */ b({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = yt(void 0, "reka-listbox-item"), { CollectionItem: r } = Gt(), { forwardRef: s, currentElement: i } = le(), u = gu(), d = E(() => i.value === u.highlightedElement.value), c = E(() => kM(u.modelValue.value, n.value, u.by)), f = E(() => u.disabled.value || n.disabled);
    async function p(m) {
      a("select", m), !(m != null && m.defaultPrevented) && !f.value && m && (u.onValueChange(n.value), u.changeHighlight(i.value));
    }
    function v(m) {
      const h = {
        originalEvent: m,
        value: n.value
      };
      cu(zM, p, h);
    }
    return UM({ isSelected: c }), (m, h) => (g(), C(l(r), { value: m.value }, {
      default: y(() => [m1([d.value, c.value], () => N(l(se), A({ id: l(o) }, m.$attrs, {
        ref: l(s),
        role: "option",
        tabindex: l(u).focusable.value ? d.value ? "0" : "-1" : -1,
        "aria-selected": c.value,
        as: m.as,
        "as-child": m.asChild,
        disabled: f.value ? "" : void 0,
        "data-disabled": f.value ? "" : void 0,
        "data-highlighted": d.value ? "" : void 0,
        "data-state": c.value ? "checked" : "unchecked",
        onClick: v,
        onKeydown: Qe(We(v, ["prevent"]), ["space"]),
        onPointermove: h[0] || (h[0] = () => {
          l(u).highlightedElement.value !== l(i) && l(u).highlightOnHover.value && !l(u).focusable.value && l(u).changeHighlight(l(i), !1);
        })
      }), {
        default: y(() => [w(m.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), h, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), WM = jM, KM = /* @__PURE__ */ b({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = HM();
    return (a, o) => l(n).isSelected.value ? (g(), C(l(se), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16)) : Pe("v-if", !0);
  }
}), GM = KM;
const [Aa, YM] = He("ComboboxRoot");
var XM = /* @__PURE__ */ b({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    resetModelValueOnClear: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1,
      default: !0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: t, emit: n }) {
    var W, j, J;
    const a = e, o = n, { primitiveElement: r, currentElement: s } = Kt(), { multiple: i, disabled: u, ignoreFilter: d, resetSearchTermOnSelect: c, openOnFocus: f, openOnClick: p, dir: v, resetModelValueOnClear: m, highlightOnHover: h } = Be(a), _ = tn(v), x = rt(a, "modelValue", o, {
      defaultValue: a.defaultValue ?? (i.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), S = rt(a, "open", o, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function $(z) {
      var Y, Z;
      S.value = z, Q.value = "", z ? (await he(), (Y = r.value) == null || Y.highlightSelected(), B.value = !0, (Z = M.value) == null || Z.focus()) : (B.value = !1, setTimeout(() => {
        !z && a.resetSearchTermOnBlur && D.trigger();
      }, 1));
    }
    const D = tr(), B = O(!1), k = O(!1), M = O(), I = O(), T = E(() => {
      var z;
      return ((z = r.value) == null ? void 0 : z.highlightedElement) ?? void 0;
    }), P = O(/* @__PURE__ */ new Map()), q = O(/* @__PURE__ */ new Map()), { contains: R } = QE({ sensitivity: "base" }), Q = O(""), ee = E((z) => {
      if (!Q.value || a.ignoreFilter || k.value) return {
        count: P.value.size,
        items: (z == null ? void 0 : z.items) ?? /* @__PURE__ */ new Map(),
        groups: (z == null ? void 0 : z.groups) ?? new Set(q.value.keys())
      };
      let Y = 0;
      const Z = /* @__PURE__ */ new Map(), pe = /* @__PURE__ */ new Set();
      for (const [$e, Ce] of P.value) {
        const De = R(Ce, Q.value);
        Z.set($e, De ? 1 : 0), De && Y++;
      }
      for (const [$e, Ce] of q.value) for (const De of Ce) if (Z.get(De) > 0) {
        pe.add($e);
        break;
      }
      return {
        count: Y,
        items: Z,
        groups: pe
      };
    }), K = ct();
    return be(() => {
      var z, Y, Z;
      K != null && K.exposed && (K.exposed.highlightItem = (z = r.value) == null ? void 0 : z.highlightItem, K.exposed.highlightFirstItem = (Y = r.value) == null ? void 0 : Y.highlightFirstItem, K.exposed.highlightSelected = (Z = r.value) == null ? void 0 : Z.highlightSelected);
    }), t({
      filtered: ee,
      highlightedElement: T,
      highlightItem: (W = r.value) == null ? void 0 : W.highlightItem,
      highlightFirstItem: (j = r.value) == null ? void 0 : j.highlightFirstItem,
      highlightSelected: (J = r.value) == null ? void 0 : J.highlightSelected
    }), YM({
      modelValue: x,
      multiple: i,
      disabled: u,
      open: S,
      onOpenChange: $,
      contentId: "",
      isUserInputted: B,
      isVirtual: k,
      inputElement: M,
      highlightedElement: T,
      onInputElementChange: (z) => M.value = z,
      triggerElement: I,
      onTriggerElementChange: (z) => I.value = z,
      parentElement: s,
      resetSearchTermOnSelect: c,
      onResetSearchTerm: D.on,
      allItems: P,
      allGroups: q,
      filterSearch: Q,
      filterState: ee,
      ignoreFilter: d,
      openOnFocus: f,
      openOnClick: p,
      resetModelValueOnClear: m
    }), (z, Y) => (g(), C(l(hu), null, {
      default: y(() => [N(l(AM), A({
        ref_key: "primitiveElement",
        ref: r
      }, z.$attrs, {
        modelValue: l(x),
        "onUpdate:modelValue": Y[0] || (Y[0] = (Z) => ht(x) ? x.value = Z : null),
        style: { pointerEvents: l(S) ? "auto" : void 0 },
        as: z.as,
        "as-child": z.asChild,
        dir: l(_),
        multiple: l(i),
        name: z.name,
        required: z.required,
        disabled: l(u),
        "highlight-on-hover": l(h),
        by: a.by,
        onHighlight: Y[1] || (Y[1] = (Z) => o("highlight", Z))
      }), {
        default: y(() => [w(z.$slots, "default", {
          open: l(S),
          modelValue: l(x)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "highlight-on-hover",
        "by"
      ])]),
      _: 3
    }));
  }
}), JM = XM;
const [WU, ZM] = He("ComboboxContent");
var QM = /* @__PURE__ */ b({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { position: o } = Be(n), r = Aa(), { forwardRef: s, currentElement: i } = le();
    Jf(n.bodyLock), Qf(r.parentElement);
    const u = E(() => n.position === "popper" ? n : {}), d = Ee(u.value), c = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    ZM({ position: o });
    const f = O(!1);
    return be(() => {
      r.inputElement.value && (f.value = i.value.contains(r.inputElement.value), f.value && r.inputElement.value.focus());
    }), Ze(() => {
      var v;
      const p = gt();
      f.value && (!p || p === document.body) && ((v = r.triggerElement.value) == null || v.focus());
    }), (p, v) => (g(), C(l(RM), { "as-child": "" }, {
      default: y(() => [N(l(Gs), {
        "as-child": "",
        "disable-outside-pointer-events": p.disableOutsidePointerEvents,
        onDismiss: v[0] || (v[0] = (m) => l(r).onOpenChange(!1)),
        onFocusOutside: v[1] || (v[1] = (m) => {
          var h;
          (h = l(r).parentElement.value) != null && h.contains(m.target) && m.preventDefault(), a("focusOutside", m);
        }),
        onInteractOutside: v[2] || (v[2] = (m) => a("interactOutside", m)),
        onEscapeKeyDown: v[3] || (v[3] = (m) => a("escapeKeyDown", m)),
        onPointerDownOutside: v[4] || (v[4] = (m) => {
          var h;
          (h = l(r).parentElement.value) != null && h.contains(m.target) && m.preventDefault(), a("pointerDownOutside", m);
        })
      }, {
        default: y(() => [(g(), C(mt(l(o) === "popper" ? l(rp) : l(se)), A({
          ...p.$attrs,
          ...l(d)
        }, {
          id: l(r).contentId,
          ref: l(s),
          "data-state": l(r).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...l(o) === "popper" ? c : {}
          }
        }), {
          default: y(() => [w(p.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), ek = QM, tk = /* @__PURE__ */ b({
  __name: "ComboboxCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Aa();
    function a() {
      var o;
      n.filterSearch.value = "", n.inputElement.value && (n.inputElement.value.value = "", n.inputElement.value.focus()), (o = n.resetModelValueOnClear) != null && o.value && (n.modelValue.value = n.multiple.value ? [] : null);
    }
    return (o, r) => (g(), C(l(se), A({ type: o.as === "button" ? "button" : void 0 }, t, {
      tabindex: "-1",
      onClick: a
    }), {
      default: y(() => [w(o.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), KU = tk, nk = /* @__PURE__ */ b({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t), { forwardRef: r } = le(), s = Aa();
    return s.contentId || (s.contentId = yt(void 0, "reka-combobox-content")), (i, u) => (g(), C(l(nn), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(ek, A({
        ...l(o),
        ...i.$attrs
      }, { ref: l(r) }), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), ak = nk, ok = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Aa(), a = E(() => n.ignoreFilter.value ? n.allItems.value.size === 0 : n.filterState.value.count === 0);
    return (o, r) => a.value ? (g(), C(l(se), ne(A({ key: 0 }, t)), {
      default: y(() => [w(o.$slots, "default", {}, () => [r[0] || (r[0] = Re("No options"))])]),
      _: 3
    }, 16)) : Pe("v-if", !0);
  }
}), rk = ok;
const [Vb, sk] = He("ComboboxGroup");
var lk = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = yt(void 0, "reka-combobox-group"), a = Aa(), o = E(() => a.ignoreFilter.value ? !0 : a.filterSearch.value ? a.filterState.value.groups.has(n) : !0), r = sk({
      id: n,
      labelId: ""
    });
    return be(() => {
      a.allGroups.value.has(n) || a.allGroups.value.set(n, /* @__PURE__ */ new Set());
    }), Ze(() => {
      a.allGroups.value.delete(n);
    }), (s, i) => (g(), C(l(LM), A({
      id: l(n),
      "aria-labelledby": l(r).labelId
    }, t, { hidden: o.value ? void 0 : !0 }), {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "hidden"
    ]));
  }
}), ik = lk, uk = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Aa(), r = gu(), { primitiveElement: s, currentElement: i } = Kt(), u = rt(n, "modelValue", a, { passive: n.modelValue === void 0 });
    be(() => {
      i.value && o.onInputElementChange(i.value);
    });
    function d(m) {
      o.open.value || o.onOpenChange(!0);
    }
    function c(m) {
      const h = m.target;
      o.open.value ? o.filterSearch.value = h.value : (o.onOpenChange(!0), he(() => {
        h.value && (o.filterSearch.value = h.value, r.highlightFirstItem());
      }));
    }
    function f() {
      o.openOnFocus.value && !o.open.value && o.onOpenChange(!0);
    }
    function p() {
      o.openOnClick.value && !o.open.value && o.onOpenChange(!0);
    }
    function v() {
      const m = o.modelValue.value;
      n.displayValue ? u.value = n.displayValue(m) : !o.multiple.value && m && !Array.isArray(m) && typeof m != "object" ? u.value = m.toString() : u.value = "", he(() => {
        u.value = u.value;
      });
    }
    return o.onResetSearchTerm(() => {
      v();
    }), ce(o.modelValue, async () => {
      !o.isUserInputted.value && o.resetSearchTermOnSelect.value && v();
    }, {
      immediate: !0,
      deep: !0
    }), ce(o.filterState, (m, h) => {
      !o.isVirtual.value && h.count === 0 && r.highlightFirstItem();
    }), (m, h) => (g(), C(l(FM), {
      ref_key: "primitiveElement",
      ref: s,
      modelValue: l(u),
      "onUpdate:modelValue": h[0] || (h[0] = (_) => ht(u) ? u.value = _ : null),
      as: m.as,
      "as-child": m.asChild,
      "auto-focus": m.autoFocus,
      disabled: m.disabled,
      "aria-expanded": l(o).open.value,
      "aria-controls": l(o).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: p,
      onInput: c,
      onKeydown: Qe(We(d, ["prevent"]), ["down", "up"]),
      onFocus: f
    }, {
      default: y(() => [w(m.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), dk = uk, ck = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = yt(void 0, "reka-combobox-item"), r = Aa(), s = Vb(null), { primitiveElement: i, currentElement: u } = Kt();
    if (n.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const d = E(() => {
      if (r.isVirtual.value || r.ignoreFilter.value || !r.filterSearch.value) return !0;
      {
        const c = r.filterState.value.items.get(o);
        return c === void 0 ? !0 : c > 0;
      }
    });
    return be(() => {
      var f;
      r.allItems.value.set(o, n.textValue || u.value.textContent || u.value.innerText);
      const c = s == null ? void 0 : s.id;
      c && (r.allGroups.value.has(c) ? (f = r.allGroups.value.get(c)) == null || f.add(o) : r.allGroups.value.set(c, /* @__PURE__ */ new Set([o])));
    }), Ze(() => {
      r.allItems.value.delete(o);
    }), (c, f) => d.value ? (g(), C(l(WM), A({ key: 0 }, n, {
      id: l(o),
      ref_key: "primitiveElement",
      ref: i,
      disabled: l(r).disabled.value || c.disabled,
      onSelect: f[0] || (f[0] = (p) => {
        a("select", p), !p.defaultPrevented && !l(r).multiple.value && !c.disabled && !l(r).disabled.value && (p.preventDefault(), l(r).onOpenChange(!1), l(r).modelValue.value = n.value);
      })
    }), {
      default: y(() => [w(c.$slots, "default", {}, () => [Re(Ve(c.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : Pe("v-if", !0);
  }
}), fk = ck, pk = /* @__PURE__ */ b({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(GM), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), GU = pk, vk = /* @__PURE__ */ b({
  __name: "ComboboxLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Vb({
      id: "",
      labelId: ""
    });
    return n.labelId || (n.labelId = yt(void 0, "reka-combobox-group-label")), (a, o) => (g(), C(l(se), A(t, { id: l(n).labelId }), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), mk = vk, hk = /* @__PURE__ */ b({
  __name: "ComboboxPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(pu), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gk = hk, yk = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(se), A(t, { "aria-hidden": "true" }), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bk = yk, _k = /* @__PURE__ */ b({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = le(), o = Aa(), r = E(() => t.disabled || o.disabled.value || !1);
    return be(() => {
      a.value && o.onTriggerElementChange(a.value);
    }), (s, i) => (g(), C(l(se), A(t, {
      ref: l(n),
      type: s.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": l(o).open.value,
      "aria-controls": l(o).contentId,
      "data-state": l(o).open.value ? "open" : "closed",
      disabled: r.value,
      "data-disabled": r.value ? "" : void 0,
      "aria-disabled": r.value ?? void 0,
      onClick: i[0] || (i[0] = (u) => l(o).onOpenChange(!l(o).open.value))
    }), {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), YU = _k;
function sp(e) {
  const t = js({ nonce: O() });
  return E(() => {
    var n;
    return (e == null ? void 0 : e.value) || ((n = t.nonce) == null ? void 0 : n.value);
  });
}
var wk = /* @__PURE__ */ b({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = le(), { nonce: a } = Be(t), o = sp(a), r = Aa();
    return (s, i) => (g(), U(Fe, null, [N(l(se), A({
      ...s.$attrs,
      ...t
    }, {
      ref: l(n),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: l(r).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 16, ["style"]), N(l(se), {
      as: "style",
      nonce: l(o)
    }, {
      default: y(() => i[0] || (i[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), xk = wk, Ck = /* @__PURE__ */ b({
  __name: "MenuAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(op), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), lp = Ck;
function Sk() {
  const e = O(!1);
  return be(() => {
    on("keydown", () => {
      e.value = !0;
    }, {
      capture: !0,
      passive: !0
    }), on(["pointerdown", "pointermove"], () => {
      e.value = !1;
    }, {
      capture: !0,
      passive: !0
    });
  }), e;
}
const $k = mb(Sk), [Mo, Nb] = He(["MenuRoot", "MenuSub"], "MenuContext"), [Ys, Bk] = He("MenuRoot");
var Pk = /* @__PURE__ */ b({
  __name: "MenuRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: o, dir: r } = Be(n), s = tn(r), i = rt(n, "open", a), u = O(), d = $k();
    return Nb({
      open: i,
      onOpenChange: (c) => {
        i.value = c;
      },
      content: u,
      onContentChange: (c) => {
        u.value = c;
      }
    }), Bk({
      onClose: () => {
        i.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: s,
      modal: o
    }), (c, f) => (g(), C(l(hu), null, {
      default: y(() => [w(c.$slots, "default")]),
      _: 3
    }));
  }
}), Lb = Pk;
const [ip, Ek] = He("MenuContent");
var Dk = /* @__PURE__ */ b({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ ji({
    loop: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    disableOutsideScroll: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...Fb }),
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Mo(), r = Ys(), { trapFocus: s, disableOutsidePointerEvents: i, loop: u } = Be(n);
    eD(), Jf(i.value);
    const d = O(""), c = O(0), f = O(0), p = O(null), v = O("right"), m = O(0), h = O(null), _ = O(), { forwardRef: x, currentElement: S } = le(), { handleTypeaheadSearch: $ } = $b();
    ce(S, (T) => {
      o.onContentChange(T);
    }), Ze(() => {
      window.clearTimeout(c.value);
    });
    function D(T) {
      var q, R;
      return v.value === ((q = p.value) == null ? void 0 : q.side) && QD(T, (R = p.value) == null ? void 0 : R.area);
    }
    async function B(T) {
      var P;
      a("openAutoFocus", T), !T.defaultPrevented && (T.preventDefault(), (P = S.value) == null || P.focus({ preventScroll: !0 }));
    }
    function k(T) {
      var j;
      if (T.defaultPrevented) return;
      const q = T.target.closest("[data-reka-menu-content]") === T.currentTarget, R = T.ctrlKey || T.altKey || T.metaKey, Q = T.key.length === 1, ee = Mr(T, gt(), S.value, {
        loop: u.value,
        arrowKeyOptions: "vertical",
        dir: r == null ? void 0 : r.dir.value,
        focus: !0,
        attributeName: "[data-reka-collection-item]:not([data-disabled])"
      });
      if (ee) return ee == null ? void 0 : ee.focus();
      if (T.code === "Space") return;
      const K = ((j = _.value) == null ? void 0 : j.getItems()) ?? [];
      if (q && (T.key === "Tab" && T.preventDefault(), !R && Q && $(T.key, K)), T.target !== S.value || !GD.includes(T.key)) return;
      T.preventDefault();
      const W = [...K.map((J) => J.ref)];
      Mb.includes(T.key) && W.reverse(), JD(W);
    }
    function M(T) {
      var P, q;
      (q = (P = T == null ? void 0 : T.currentTarget) == null ? void 0 : P.contains) != null && q.call(P, T.target) || (window.clearTimeout(c.value), d.value = "");
    }
    function I(T) {
      var R;
      if (!bs(T)) return;
      const P = T.target, q = m.value !== T.clientX;
      if ((R = T == null ? void 0 : T.currentTarget) != null && R.contains(P) && q) {
        const Q = T.clientX > m.value ? "right" : "left";
        v.value = Q, m.value = T.clientX;
      }
    }
    return Ek({
      onItemEnter: (T) => !!D(T),
      onItemLeave: (T) => {
        var P;
        D(T) || ((P = S.value) == null || P.focus(), h.value = null);
      },
      onTriggerLeave: (T) => !!D(T),
      searchRef: d,
      pointerGraceTimerRef: f,
      onPointerGraceIntentChange: (T) => {
        p.value = T;
      }
    }), (T, P) => (g(), C(l(Db), {
      "as-child": "",
      trapped: l(s),
      onMountAutoFocus: B,
      onUnmountAutoFocus: P[7] || (P[7] = (q) => a("closeAutoFocus", q))
    }, {
      default: y(() => [N(l(Gs), {
        "as-child": "",
        "disable-outside-pointer-events": l(i),
        onEscapeKeyDown: P[2] || (P[2] = (q) => a("escapeKeyDown", q)),
        onPointerDownOutside: P[3] || (P[3] = (q) => a("pointerDownOutside", q)),
        onFocusOutside: P[4] || (P[4] = (q) => a("focusOutside", q)),
        onInteractOutside: P[5] || (P[5] = (q) => a("interactOutside", q)),
        onDismiss: P[6] || (P[6] = (q) => a("dismiss"))
      }, {
        default: y(() => [N(l(vu), {
          ref_key: "rovingFocusGroupRef",
          ref: _,
          "current-tab-stop-id": h.value,
          "onUpdate:currentTabStopId": P[0] || (P[0] = (q) => h.value = q),
          "as-child": "",
          orientation: "vertical",
          dir: l(r).dir.value,
          loop: l(u),
          onEntryFocus: P[1] || (P[1] = (q) => {
            a("entryFocus", q), l(r).isUsingKeyboardRef.value || q.preventDefault();
          })
        }, {
          default: y(() => [N(l(rp), {
            ref: l(x),
            role: "menu",
            as: T.as,
            "as-child": T.asChild,
            "aria-orientation": "vertical",
            "data-reka-menu-content": "",
            "data-state": l(np)(l(o).open.value),
            dir: l(r).dir.value,
            side: T.side,
            "side-offset": T.sideOffset,
            align: T.align,
            "align-offset": T.alignOffset,
            "avoid-collisions": T.avoidCollisions,
            "collision-boundary": T.collisionBoundary,
            "collision-padding": T.collisionPadding,
            "arrow-padding": T.arrowPadding,
            "prioritize-position": T.prioritizePosition,
            "position-strategy": T.positionStrategy,
            "update-position-strategy": T.updatePositionStrategy,
            sticky: T.sticky,
            "hide-when-detached": T.hideWhenDetached,
            reference: T.reference,
            onKeydown: k,
            onBlur: M,
            onPointermove: I
          }, {
            default: y(() => [w(T.$slots, "default")]),
            _: 3
          }, 8, [
            "as",
            "as-child",
            "data-state",
            "dir",
            "side",
            "side-offset",
            "align",
            "align-offset",
            "avoid-collisions",
            "collision-boundary",
            "collision-padding",
            "arrow-padding",
            "prioritize-position",
            "position-strategy",
            "update-position-strategy",
            "sticky",
            "hide-when-detached",
            "reference"
          ])]),
          _: 3
        }, 8, [
          "current-tab-stop-id",
          "dir",
          "loop"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), up = Dk, Mk = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ip(), { forwardRef: a } = le(), { CollectionItem: o } = Gt(), r = O(!1);
    async function s(u) {
      if (!u.defaultPrevented && bs(u)) {
        if (t.disabled) n.onItemLeave(u);
        else if (!n.onItemEnter(u)) {
          const c = u.currentTarget;
          c == null || c.focus({ preventScroll: !0 });
        }
      }
    }
    async function i(u) {
      await he(), !u.defaultPrevented && bs(u) && n.onItemLeave(u);
    }
    return (u, d) => (g(), C(l(o), { value: { textValue: u.textValue } }, {
      default: y(() => [N(l(se), A({
        ref: l(a),
        role: "menuitem",
        tabindex: "-1"
      }, u.$attrs, {
        as: u.as,
        "as-child": u.asChild,
        "aria-disabled": u.disabled || void 0,
        "data-disabled": u.disabled ? "" : void 0,
        "data-highlighted": r.value ? "" : void 0,
        onPointermove: s,
        onPointerleave: i,
        onFocus: d[0] || (d[0] = async (c) => {
          await he(), !(c.defaultPrevented || u.disabled) && (r.value = !0);
        }),
        onBlur: d[1] || (d[1] = async (c) => {
          await he(), !c.defaultPrevented && (r.value = !1);
        })
      }), {
        default: y(() => [w(u.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-disabled",
        "data-disabled",
        "data-highlighted"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), zb = Mk, kk = /* @__PURE__ */ b({
  __name: "MenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = le(), s = Ys(), i = ip(), u = O(!1);
    async function d() {
      const c = r.value;
      if (!n.disabled && c) {
        const f = new CustomEvent(WD, {
          bubbles: !0,
          cancelable: !0
        });
        a("select", f), await he(), f.defaultPrevented ? u.value = !1 : s.onClose();
      }
    }
    return (c, f) => (g(), C(zb, A(n, {
      ref: l(o),
      onClick: d,
      onPointerdown: f[0] || (f[0] = () => {
        u.value = !0;
      }),
      onPointerup: f[1] || (f[1] = async (p) => {
        var v;
        await he(), !p.defaultPrevented && (u.value || (v = p.currentTarget) == null || v.click());
      }),
      onKeydown: f[2] || (f[2] = async (p) => {
        const v = l(i).searchRef.value !== "";
        c.disabled || v && p.key === " " || l(vc).includes(p.key) && (p.currentTarget.click(), p.preventDefault());
      })
    }), {
      default: y(() => [w(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), yu = kk;
const [Ok, Hb] = He(["MenuCheckboxItem", "MenuRadioItem"], "MenuItemIndicatorContext");
var Tk = /* @__PURE__ */ b({
  __name: "MenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = Ok({ modelValue: O(!1) });
    return (n, a) => (g(), C(l(nn), { present: n.forceMount || l(mi)(l(t).modelValue.value) || l(t).modelValue.value === !0 }, {
      default: y(() => [N(l(se), {
        as: n.as,
        "as-child": n.asChild,
        "data-state": l(ap)(l(t).modelValue.value)
      }, {
        default: y(() => [w(n.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Ub = Tk, Ak = /* @__PURE__ */ b({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = fu(n, ["modelValue"]), r = Ee(o), s = rt(n, "modelValue", a);
    return Hb({ modelValue: s }), (i, u) => (g(), C(yu, A({ role: "menuitemcheckbox" }, l(r), {
      "aria-checked": l(mi)(l(s)) ? "mixed" : l(s),
      "data-state": l(ap)(l(s)),
      onSelect: u[0] || (u[0] = async (d) => {
        a("select", d), l(mi)(l(s)) ? s.value = !0 : s.value = !l(s);
      })
    }), {
      default: y(() => [w(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), jb = Ak, Ik = /* @__PURE__ */ b({
  __name: "MenuRootContentModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = qe(n, a), r = Mo(), { forwardRef: s, currentElement: i } = le();
    return Qf(i), (u, d) => (g(), C(up, A(l(o), {
      ref: l(s),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": l(r).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (c) => l(r).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = We((c) => a("focusOutside", c), ["prevent"]))
    }), {
      default: y(() => [w(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), Rk = Ik, qk = /* @__PURE__ */ b({
  __name: "MenuRootContentNonModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t), r = Mo();
    return (s, i) => (g(), C(up, A(l(o), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (u) => l(r).onOpenChange(!1))
    }), {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Fk = qk, Vk = /* @__PURE__ */ b({
  __name: "MenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t), r = Mo(), s = Ys();
    return (i, u) => (g(), C(l(nn), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [l(s).modal.value ? (g(), C(Rk, ne(A({ key: 0 }, {
        ...i.$attrs,
        ...l(o)
      })), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16)) : (g(), C(Fk, ne(A({ key: 1 }, {
        ...i.$attrs,
        ...l(o)
      })), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), Wb = Vk, Nk = /* @__PURE__ */ b({
  __name: "MenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), A({ role: "group" }, t), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), dp = Nk, Lk = /* @__PURE__ */ b({
  __name: "MenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Kb = Lk, zk = /* @__PURE__ */ b({
  __name: "MenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(pu), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Gb = zk;
const [Hk, Uk] = He("MenuRadioGroup");
var jk = /* @__PURE__ */ b({
  __name: "MenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = fu(n, ["modelValue"]), r = Ee(o), s = rt(n, "modelValue", a);
    return Uk({
      modelValue: s,
      onValueChange: (i) => {
        s.value = i;
      }
    }), (i, u) => (g(), C(dp, ne(oe(l(r))), {
      default: y(() => [w(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16));
  }
}), Yb = jk, Wk = /* @__PURE__ */ b({
  __name: "MenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = fu(n, ["value"]), r = Ee(o), { value: s } = Be(n), i = Hk(), u = E(() => i.modelValue.value === (s == null ? void 0 : s.value));
    return Hb({ modelValue: u }), (d, c) => (g(), C(yu, A({ role: "menuitemradio" }, l(r), {
      "aria-checked": u.value,
      "data-state": l(ap)(u.value),
      onSelect: c[0] || (c[0] = async (f) => {
        a("select", f), l(i).onValueChange(l(s));
      })
    }), {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Xb = Wk, Kk = /* @__PURE__ */ b({
  __name: "MenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), A(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Jb = Kk;
const [Zb, Gk] = He("MenuSub");
var Yk = /* @__PURE__ */ b({
  __name: "MenuSub",
  props: { open: {
    type: Boolean,
    required: !1,
    default: void 0
  } },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, o = rt(n, "open", t, {
      defaultValue: !1,
      passive: n.open === void 0
    }), r = Mo(), s = O(), i = O();
    return Me((u) => {
      (r == null ? void 0 : r.open.value) === !1 && (o.value = !1), u(() => o.value = !1);
    }), Nb({
      open: o,
      onOpenChange: (u) => {
        o.value = u;
      },
      content: i,
      onContentChange: (u) => {
        i.value = u;
      }
    }), Gk({
      triggerId: "",
      contentId: "",
      trigger: s,
      onTriggerChange: (u) => {
        s.value = u;
      }
    }), (u, d) => (g(), C(l(hu), null, {
      default: y(() => [w(u.$slots, "default")]),
      _: 3
    }));
  }
}), Qb = Yk, Xk = /* @__PURE__ */ b({
  __name: "MenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1,
      default: !0
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t), r = Mo(), s = Ys(), i = Zb(), { forwardRef: u, currentElement: d } = le();
    return i.contentId || (i.contentId = yt(void 0, "reka-menu-sub-content")), (c, f) => (g(), C(l(nn), { present: c.forceMount || l(r).open.value }, {
      default: y(() => [N(up, A(l(o), {
        id: l(i).contentId,
        ref: l(u),
        "aria-labelledby": l(i).triggerId,
        align: "start",
        side: l(s).dir.value === "rtl" ? "left" : "right",
        "disable-outside-pointer-events": !1,
        "disable-outside-scroll": !1,
        "trap-focus": !1,
        onOpenAutoFocus: f[0] || (f[0] = We((p) => {
          var v;
          l(s).isUsingKeyboardRef.value && ((v = l(d)) == null || v.focus());
        }, ["prevent"])),
        onCloseAutoFocus: f[1] || (f[1] = We(() => {
        }, ["prevent"])),
        onFocusOutside: f[2] || (f[2] = (p) => {
          p.defaultPrevented || p.target !== l(i).trigger.value && l(r).onOpenChange(!1);
        }),
        onEscapeKeyDown: f[3] || (f[3] = (p) => {
          l(s).onClose(), p.preventDefault();
        }),
        onKeydown: f[4] || (f[4] = (p) => {
          var h, _;
          const v = (h = p.currentTarget) == null ? void 0 : h.contains(p.target), m = l(XD)[l(s).dir.value].includes(p.key);
          v && m && (l(r).onOpenChange(!1), (_ = l(i).trigger.value) == null || _.focus(), p.preventDefault());
        })
      }), {
        default: y(() => [w(c.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "side"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), e0 = Xk, Jk = /* @__PURE__ */ b({
  __name: "MenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Mo(), a = Ys(), o = Zb(), r = ip(), s = O(null);
    o.triggerId || (o.triggerId = yt(void 0, "reka-menu-sub-trigger"));
    function i() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    Ze(() => {
      i();
    });
    function u(f) {
      !bs(f) || r.onItemEnter(f) || !t.disabled && !n.open.value && !s.value && (r.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), i();
      }, 100));
    }
    async function d(f) {
      var v, m;
      if (!bs(f)) return;
      i();
      const p = (v = n.content.value) == null ? void 0 : v.getBoundingClientRect();
      if (p != null && p.width) {
        const h = (m = n.content.value) == null ? void 0 : m.dataset.side, _ = h === "right", x = _ ? -5 : 5, S = p[_ ? "left" : "right"], $ = p[_ ? "right" : "left"];
        r.onPointerGraceIntentChange({
          area: [
            {
              x: f.clientX + x,
              y: f.clientY
            },
            {
              x: S,
              y: p.top
            },
            {
              x: $,
              y: p.top
            },
            {
              x: $,
              y: p.bottom
            },
            {
              x: S,
              y: p.bottom
            }
          ],
          side: h
        }), window.clearTimeout(r.pointerGraceTimerRef.value), r.pointerGraceTimerRef.value = window.setTimeout(() => r.onPointerGraceIntentChange(null), 300);
      } else {
        if (r.onTriggerLeave(f)) return;
        r.onPointerGraceIntentChange(null);
      }
    }
    async function c(f) {
      var v;
      const p = r.searchRef.value !== "";
      t.disabled || p && f.key === " " || YD[a.dir.value].includes(f.key) && (n.onOpenChange(!0), await he(), (v = n.content.value) == null || v.focus(), f.preventDefault());
    }
    return (f, p) => (g(), C(lp, { "as-child": "" }, {
      default: y(() => [N(zb, A(t, {
        id: l(o).triggerId,
        ref: (v) => {
          var m;
          (m = l(o)) == null || m.onTriggerChange(v == null ? void 0 : v.$el);
        },
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(o).contentId,
        "data-state": l(np)(l(n).open.value),
        onClick: p[0] || (p[0] = async (v) => {
          t.disabled || v.defaultPrevented || (v.currentTarget.focus(), l(n).open.value || l(n).onOpenChange(!0));
        }),
        onPointermove: u,
        onPointerleave: d,
        onKeydown: c
      }), {
        default: y(() => [w(f.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-expanded",
        "aria-controls",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), t0 = Jk, Zk = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    return le(), (r, s) => (g(), C(l(jb), ne(oe({
      ...n,
      ...l(o)
    })), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Qk = Zk;
const [n0, eO] = He("ContextMenuRoot");
var tO = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuRoot",
  props: {
    pressOpenDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: o, modal: r, pressOpenDelay: s } = Be(n);
    le();
    const i = tn(o), u = O(!1), d = O();
    return eO({
      open: u,
      onOpenChange: (c) => {
        u.value = c;
      },
      dir: i,
      modal: r,
      triggerElement: d,
      pressOpenDelay: s
    }), ce(u, (c) => {
      a("update:open", c);
    }), (c, f) => (g(), C(l(Lb), {
      open: u.value,
      "onUpdate:open": f[0] || (f[0] = (p) => u.value = p),
      dir: l(i),
      modal: l(r)
    }, {
      default: y(() => [w(c.$slots, "default")]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), nO = tO, aO = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    le();
    const r = n0(), s = O(!1);
    return (i, u) => (g(), C(l(Wb), A(l(o), {
      side: "right",
      "side-offset": 2,
      align: "start",
      "update-position-strategy": "always",
      style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        !d.defaultPrevented && s.value && d.preventDefault(), s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        d.detail.originalEvent.button === 2 && d.target === l(r).triggerElement.value && d.preventDefault(), !d.defaultPrevented && !l(r).modal.value && (s.value = !0);
      })
    }), {
      default: y(() => [w(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), oO = aO, rO = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(dp), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sO = rO, lO = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    return le(), (r, s) => (g(), C(l(yu), ne(oe({
      ...n,
      ...l(o)
    })), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iO = lO, uO = /* @__PURE__ */ b({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(Ub), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), a0 = uO, dO = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(Kb), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), cO = dO, fO = /* @__PURE__ */ b({
  __name: "ContextMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Gb), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), pO = fO, vO = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    return le(), (r, s) => (g(), C(l(Yb), ne(oe({
      ...n,
      ...l(o)
    })), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), mO = vO, hO = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    return le(), (r, s) => (g(), C(l(Xb), ne(oe({
      ...n,
      ...l(o)
    })), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gO = hO, yO = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(Jb), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bO = yO, _O = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    le();
    const o = rt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (r, s) => (g(), C(l(Qb), {
      open: l(o),
      "onUpdate:open": s[0] || (s[0] = (i) => ht(o) ? o.value = i : null)
    }, {
      default: y(() => [w(r.$slots, "default", { open: l(o) })]),
      _: 3
    }, 8, ["open"]));
  }
}), wO = _O, xO = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return le(), (r, s) => (g(), C(l(e0), A(l(o), { style: {
      "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), CO = xO, SO = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(t0), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $O = SO;
function xm(e) {
  return e.pointerType !== "mouse";
}
var BO = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { disabled: n } = Be(t), { forwardRef: a, currentElement: o } = le(), r = n0(), s = O({
      x: 0,
      y: 0
    }), i = E(() => ({ getBoundingClientRect: () => ({
      width: 0,
      height: 0,
      left: s.value.x,
      right: s.value.x,
      top: s.value.y,
      bottom: s.value.y,
      ...s.value
    }) })), u = O(0);
    function d() {
      window.clearTimeout(u.value);
    }
    function c(m) {
      s.value = {
        x: m.clientX,
        y: m.clientY
      }, r.onOpenChange(!0);
    }
    async function f(m) {
      n.value || (await he(), m.defaultPrevented || (d(), c(m), m.preventDefault()));
    }
    async function p(m) {
      n.value || (await he(), xm(m) && !m.defaultPrevented && (d(), u.value = window.setTimeout(() => c(m), r.pressOpenDelay.value)));
    }
    async function v(m) {
      n.value || (await he(), xm(m) && !m.defaultPrevented && d());
    }
    return be(() => {
      o.value && (r.triggerElement.value = o.value);
    }), (m, h) => (g(), U(Fe, null, [N(l(lp), {
      as: "template",
      reference: i.value
    }, null, 8, ["reference"]), N(l(se), A({
      ref: l(a),
      as: m.as,
      "as-child": m.asChild,
      "data-state": l(r).open.value ? "open" : "closed",
      "data-disabled": l(n) ? "" : void 0,
      style: {
        WebkitTouchCallout: "none",
        pointerEvents: "auto"
      }
    }, m.$attrs, {
      onContextmenu: f,
      onPointerdown: p,
      onPointermove: v,
      onPointercancel: v,
      onPointerup: v
    }), {
      default: y(() => [w(m.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ])], 64));
  }
}), PO = BO;
function EO(e) {
  const t = E(() => e.start.value ? !!e.isDateDisabled(e.start.value) : !1), n = E(() => e.end.value ? !!e.isDateDisabled(e.end.value) : !1), a = E(() => t.value || n.value ? !1 : !!(e.start.value && e.end.value && ho(e.end.value, e.start.value))), o = (p) => e.start.value ? Dt(e.start.value, p) : !1, r = (p) => e.end.value ? Dt(e.end.value, p) : !1, s = (p) => e.start.value && Dt(e.start.value, p) || e.end.value && Dt(e.end.value, p) ? !0 : e.end.value && e.start.value ? gd(p, e.start.value, e.end.value) : !1, i = (p) => {
    var v;
    if (e.isDateDisabled(p)) return !0;
    if ((v = e.maximumDays) != null && v.value) {
      if (e.start.value && e.end.value) {
        if (e.fixedDate.value) {
          const m = pc(e.start.value, e.end.value).length;
          if (m <= e.maximumDays.value) {
            const h = e.maximumDays.value - m - 1, _ = e.start.value.subtract({ days: h }), x = e.end.value.add({ days: h });
            return !gd(p, _, x);
          }
        }
        return !1;
      }
      if (e.start.value) {
        const m = e.start.value.add({ days: e.maximumDays.value }), h = e.start.value.subtract({ days: e.maximumDays.value });
        return !gd(p, h, m);
      }
    }
    return !e.start.value || e.end.value || Dt(e.start.value, p), !1;
  }, u = (p) => {
    var v;
    return !!((v = e.isDateHighlightable) != null && v.call(e, p));
  }, d = E(() => {
    var _;
    if (e.start.value && e.end.value && !e.fixedDate.value || !e.start.value || !e.focusedValue.value) return null;
    const p = ho(e.start.value, e.focusedValue.value), v = p ? e.start.value : e.focusedValue.value, m = p ? e.focusedValue.value : e.start.value;
    if (Dt(v, m)) return {
      start: v,
      end: m
    };
    if ((_ = e.maximumDays) != null && _.value && !e.end.value) {
      const x = p ? v.add({ days: e.maximumDays.value - 1 }) : v.subtract({ days: e.maximumDays.value });
      return {
        start: v,
        end: x
      };
    }
    return XE(v, m, e.allowNonContiguousRanges.value ? () => !1 : e.isDateUnavailable, i, e.isDateHighlightable) ? {
      start: v,
      end: m
    } : null;
  });
  return {
    isInvalid: a,
    isSelected: s,
    isDateHighlightable: u,
    highlightedRange: d,
    isSelectionStart: o,
    isSelectionEnd: r,
    isHighlightedStart: (p) => !d.value || !d.value.start ? !1 : Dt(d.value.start, p),
    isHighlightedEnd: (p) => !d.value || !d.value.end ? !1 : Dt(d.value.end, p),
    isDateDisabled: i
  };
}
const DO = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, MO = {
  role: "heading",
  "aria-level": "2"
}, [Or, kO] = He("RangeCalendarRoot");
var OO = /* @__PURE__ */ b({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: Object,
      required: !1,
      default: () => ({
        start: void 0,
        end: void 0
      })
    },
    modelValue: {
      type: [Object, null],
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    allowNonContiguousRanges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maximumDays: {
      type: Number,
      required: !1,
      default: void 0
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateHighlightable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    fixedDate: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: [
    "update:modelValue",
    "update:validModelValue",
    "update:placeholder",
    "update:startValue"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: o, readonly: r, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, numberOfMonths: f, preventDeselect: p, isDateUnavailable: v, isDateHighlightable: m, isDateDisabled: h, calendarLabel: _, maxValue: x, minValue: S, dir: $, locale: D, nextPage: B, prevPage: k, allowNonContiguousRanges: M, disableDaysOutsideCurrentView: I, fixedDate: T, maximumDays: P } = Be(n), { primitiveElement: q, currentElement: R } = Kt(), Q = tn($), ee = ep(D), K = O(), W = O(), j = O(!1), J = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: n.modelValue === void 0
    }), z = O(J.value);
    ce(z, (Ae) => {
      a("update:validModelValue", Ae);
    });
    const Y = wb({
      defaultPlaceholder: n.placeholder,
      defaultValue: J.value.start,
      locale: n.locale
    }), Z = O(J.value.start), pe = O(J.value.end), $e = rt(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? Y.copy(),
      passive: n.placeholder === void 0
    });
    function Ce(Ae) {
      $e.value = Ae.copy();
    }
    const { fullCalendarLabel: De, headingValue: ue, isDateDisabled: V, isDateUnavailable: te, isNextButtonDisabled: H, isPrevButtonDisabled: re, grid: ie, weekdays: L, isOutsideVisibleView: _e, nextPage: we, prevPage: Te, formatter: Ne } = Ob({
      locale: ee,
      placeholder: $e,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: f,
      minValue: S,
      maxValue: x,
      disabled: o,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: h.value,
      isDateUnavailable: v.value,
      calendarLabel: _,
      nextPage: B,
      prevPage: k
    }), { isInvalid: Je, isSelected: xe, isDateHighlightable: ze, highlightedRange: je, isSelectionStart: Ke, isSelectionEnd: lt, isHighlightedStart: it, isHighlightedEnd: St, isDateDisabled: Xt } = EO({
      start: Z,
      end: pe,
      isDateDisabled: V,
      isDateUnavailable: te,
      isDateHighlightable: m.value,
      focusedValue: W,
      allowNonContiguousRanges: M,
      fixedDate: T,
      maximumDays: P
    });
    ce(J, (Ae, st) => {
      var dt, bt, G, X;
      (!(st != null && st.start) && (Ae != null && Ae.start) || !Ae || !Ae.start || Z.value && !ja(Ae.start, Z.value)) && (Z.value = (bt = (dt = Ae == null ? void 0 : Ae.start) == null ? void 0 : dt.copy) == null ? void 0 : bt.call(dt)), (!(st != null && st.end) && Ae.end || !Ae || !Ae.end || pe.value && !ja(Ae.end, pe.value)) && (pe.value = (X = (G = Ae == null ? void 0 : Ae.end) == null ? void 0 : G.copy) == null ? void 0 : X.call(G));
    }), ce(Z, (Ae) => {
      Ae && !ja(Ae, $e.value) && Ce(Ae), a("update:startValue", Ae);
    }), ce([Z, pe], ([Ae, st]) => {
      const dt = J.value;
      if (!(dt && dt.start && dt.end && Ae && st && ja(dt.start, Ae) && ja(dt.end, st)))
        if (j.value = !0, st && Ae) {
          const bt = ho(st, Ae) ? {
            start: st.copy(),
            end: Ae.copy()
          } : {
            start: Ae.copy(),
            end: st.copy()
          };
          J.value = {
            start: bt.start,
            end: bt.end
          }, j.value = !1, z.value = {
            start: bt.start.copy(),
            end: bt.end.copy()
          };
        } else J.value = Ae ? {
          start: Ae.copy(),
          end: void 0
        } : {
          start: st == null ? void 0 : st.copy(),
          end: void 0
        };
    });
    const an = Ks();
    return on("keydown", (Ae) => {
      var st, dt;
      Ae.key === an.ESCAPE && j.value && (Z.value = (st = z.value.start) == null ? void 0 : st.copy(), pe.value = (dt = z.value.end) == null ? void 0 : dt.copy());
    }), kO({
      isDateUnavailable: te,
      isDateHighlightable: ze,
      startValue: Z,
      endValue: pe,
      formatter: Ne,
      modelValue: J,
      placeholder: $e,
      disabled: o,
      initialFocus: s,
      pagedNavigation: i,
      grid: ie,
      weekDays: L,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      numberOfMonths: f,
      readonly: r,
      preventDeselect: p,
      fullCalendarLabel: De,
      headingValue: ue,
      isInvalid: Je,
      isDateDisabled: Xt,
      allowNonContiguousRanges: M,
      highlightedRange: je,
      focusedValue: W,
      lastPressedDateValue: K,
      isSelected: xe,
      isSelectionEnd: lt,
      isSelectionStart: Ke,
      isNextButtonDisabled: H,
      isPrevButtonDisabled: re,
      isOutsideVisibleView: _e,
      nextPage: we,
      prevPage: Te,
      parentElement: R,
      onPlaceholderChange: Ce,
      locale: ee,
      dir: Q,
      isHighlightedStart: it,
      isHighlightedEnd: St,
      disableDaysOutsideCurrentView: I,
      fixedDate: T,
      maximumDays: P,
      minValue: S,
      maxValue: x
    }), be(() => {
      s.value && xb(R.value);
    }), (Ae, st) => (g(), C(l(se), {
      ref_key: "primitiveElement",
      ref: q,
      as: Ae.as,
      "as-child": Ae.asChild,
      "aria-label": l(De),
      "data-readonly": l(r) ? "" : void 0,
      "data-disabled": l(o) ? "" : void 0,
      "data-invalid": l(Je) ? "" : void 0,
      dir: l(Q)
    }, {
      default: y(() => [ye("div", DO, [ye("div", MO, Ve(l(De)), 1)]), w(Ae.$slots, "default", {
        date: l($e),
        grid: l(ie),
        weekDays: l(L),
        weekStartsOn: l(u),
        locale: l(ee),
        fixedWeeks: l(c),
        modelValue: l(J)
      })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), TO = OO, AO = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = Or();
    return (n, a) => {
      var o, r;
      return g(), C(l(se), {
        as: n.as,
        "as-child": n.asChild,
        role: "gridcell",
        "aria-selected": l(t).isSelected(n.date) ? !0 : void 0,
        "aria-disabled": l(t).isDateDisabled(n.date) || ((r = (o = l(t)).isDateUnavailable) == null ? void 0 : r.call(o, n.date)) || l(t).disableDaysOutsideCurrentView.value,
        "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
      }, {
        default: y(() => [w(n.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-selected",
        "aria-disabled",
        "data-disabled"
      ]);
    };
  }
}), IO = AO, RO = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Or(), a = Ks(), { primitiveElement: o } = Kt(), r = E(() => n.formatter.custom(Vn(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), s = E(() => {
      var I;
      return ((I = n.isDateUnavailable) == null ? void 0 : I.call(n, t.day)) ?? !1;
    }), i = E(() => n.isSelected(t.day)), u = E(() => n.isSelectionStart(t.day)), d = E(() => n.isSelectionEnd(t.day)), c = E(() => n.isHighlightedStart(t.day)), f = E(() => n.isHighlightedEnd(t.day)), p = E(() => n.highlightedRange.value ? KE(t.day, n.highlightedRange.value.start, n.highlightedRange.value.end) : !1), v = E(() => n.allowNonContiguousRanges.value), m = E(() => gg(t.day, _r())), h = E(() => !ef(t.day, t.month)), _ = E(() => n.isOutsideVisibleView(t.day)), x = E(() => n.isDateDisabled(t.day) || n.disableDaysOutsideCurrentView.value && h.value), S = E(() => t.day.day.toLocaleString(n.locale.value)), $ = E(() => !n.disabled.value && Dt(t.day, n.placeholder.value));
    function D(I, T) {
      var P;
      if (!n.readonly.value && !(n.isDateDisabled(T) || (P = n.isDateUnavailable) != null && P.call(n, T))) {
        if (n.lastPressedDateValue.value = T.copy(), n.startValue.value && n.highlightedRange.value === null) {
          if (Dt(T, n.startValue.value) && !n.preventDeselect.value && !n.endValue.value) {
            n.startValue.value = void 0, n.onPlaceholderChange(T);
            return;
          } else if (!n.endValue.value) {
            I.preventDefault(), n.lastPressedDateValue.value && Dt(n.lastPressedDateValue.value, T) && (n.startValue.value = T.copy());
            return;
          }
        }
        if (n.startValue.value && n.endValue.value && Dt(n.startValue.value, n.endValue.value) && Dt(n.startValue.value, T) && !n.preventDeselect.value) {
          n.startValue.value = void 0, n.endValue.value = void 0, n.onPlaceholderChange(T);
          return;
        }
        n.startValue.value ? n.endValue.value ? n.endValue.value && n.startValue.value && (n.fixedDate.value ? n.fixedDate.value === "start" ? T.compare(n.startValue.value) < 0 ? n.startValue.value = T.copy() : n.endValue.value = T.copy() : n.fixedDate.value === "end" && (T.compare(n.endValue.value) > 0 ? n.endValue.value = T.copy() : n.startValue.value = T.copy()) : (n.endValue.value = void 0, n.startValue.value = T.copy())) : n.endValue.value = T.copy() : n.startValue.value = T.copy();
      }
    }
    function B(I) {
      x.value || D(I, t.day);
    }
    function k() {
      var I;
      x.value || (I = n.isDateUnavailable) != null && I.call(n, t.day) || (n.focusedValue.value = t.day.copy());
    }
    function M(I) {
      if (x.value) return;
      I.preventDefault(), I.stopPropagation();
      const T = n.parentElement.value, P = 7, q = n.dir.value === "rtl" ? -1 : 1;
      switch (I.code) {
        case a.ARROW_RIGHT:
          R(t.day, q);
          break;
        case a.ARROW_LEFT:
          R(t.day, -q);
          break;
        case a.ARROW_UP:
          R(t.day, -P);
          break;
        case a.ARROW_DOWN:
          R(t.day, P);
          break;
        case a.ENTER:
        case a.SPACE_CODE:
          D(I, t.day);
      }
      function R(Q, ee) {
        const K = Q.add({ days: ee });
        if (n.minValue.value && K.compare(n.minValue.value) < 0 || n.maxValue.value && K.compare(n.maxValue.value) > 0) return;
        const W = T.querySelector(`[data-value='${K.toString()}']:not([data-outside-view])`);
        if (!W) {
          if (ee > 0) {
            if (n.isNextButtonDisabled()) return;
            n.nextPage();
          } else {
            if (n.isPrevButtonDisabled()) return;
            n.prevPage();
          }
          he(() => {
            R(Q, ee);
          });
          return;
        }
        if (W && W.hasAttribute("data-disabled")) return R(K, ee);
        n.onPlaceholderChange(K), W == null || W.focus();
      }
    }
    return (I, T) => (g(), C(l(se), {
      ref_key: "primitiveElement",
      ref: o,
      as: I.as,
      "as-child": I.asChild,
      role: "button",
      "aria-label": r.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-pressed": i.value && (v.value || !s.value) ? !0 : void 0,
      "aria-disabled": x.value || s.value ? !0 : void 0,
      "data-highlighted": p.value && (v.value || !s.value) ? "" : void 0,
      "data-selection-start": u.value ? !0 : void 0,
      "data-selection-end": d.value ? !0 : void 0,
      "data-highlighted-start": c.value ? !0 : void 0,
      "data-highlighted-end": f.value ? !0 : void 0,
      "data-selected": i.value && (v.value || !s.value) ? !0 : void 0,
      "data-outside-visible-view": _.value ? "" : void 0,
      "data-value": I.day.toString(),
      "data-disabled": x.value ? "" : void 0,
      "data-unavailable": s.value ? "" : void 0,
      "data-today": m.value ? "" : void 0,
      "data-outside-view": h.value ? "" : void 0,
      "data-focused": $.value ? "" : void 0,
      tabindex: $.value ? 0 : h.value || x.value ? void 0 : -1,
      onClick: B,
      onFocusin: k,
      onMouseenter: k,
      onKeydown: Qe(M, [
        "up",
        "down",
        "left",
        "right",
        "enter",
        "space"
      ])
    }, {
      default: y(() => [w(I.$slots, "default", {
        dayValue: S.value,
        disabled: x.value,
        today: m.value,
        selected: i.value,
        outsideView: h.value,
        outsideVisibleView: _.value,
        unavailable: s.value,
        highlighted: p.value && (v.value || !s.value),
        highlightedStart: c.value,
        highlightedEnd: f.value,
        selectionStart: u.value,
        selectionEnd: d.value
      }, () => [Re(Ve(S.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "aria-pressed",
      "aria-disabled",
      "data-highlighted",
      "data-selection-start",
      "data-selection-end",
      "data-highlighted-start",
      "data-highlighted-end",
      "data-selected",
      "data-outside-visible-view",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), qO = RO, FO = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = Or(), a = E(() => n.disabled.value ? !0 : void 0), o = E(() => n.readonly.value ? !0 : void 0);
    return (r, s) => (g(), C(l(se), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": o.value,
      "aria-disabled": a.value,
      "data-readonly": o.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), VO = FO, NO = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), LO = NO, zO = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), A(t, { "aria-hidden": "true" }), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), HO = zO, UO = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), jO = UO, WO = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), KO = WO, GO = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), YO = GO, XO = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Or();
    return (a, o) => (g(), C(l(se), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [w(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Ve(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), JO = XO, ZO = /* @__PURE__ */ b({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = Or();
    return (o, r) => (g(), C(l(se), {
      as: o.as,
      "as-child": o.asChild,
      "aria-label": "Next page",
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: r[0] || (r[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [w(o.$slots, "default", { disabled: n.value }, () => [r[1] || (r[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), QO = ZO, eT = /* @__PURE__ */ b({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = Or();
    return (o, r) => (g(), C(l(se), {
      as: o.as,
      "as-child": o.asChild,
      "aria-label": "Previous page",
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: r[0] || (r[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [w(o.$slots, "default", { disabled: n.value }, () => [r[1] || (r[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), tT = eT;
const [cp, nT] = He("HoverCardRoot");
var aT = /* @__PURE__ */ b({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    openDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    closeDelay: {
      type: Number,
      required: !1,
      default: 300
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { openDelay: o, closeDelay: r } = Be(n);
    le();
    const s = rt(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = O(0), u = O(0), d = O(!1), c = O(!1), f = O(!1), p = O();
    function v() {
      clearTimeout(u.value), i.value = window.setTimeout(() => s.value = !0, o.value);
    }
    function m() {
      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => s.value = !1, r.value));
    }
    function h() {
      s.value = !1;
    }
    return nT({
      open: s,
      onOpenChange(_) {
        s.value = _;
      },
      onOpen: v,
      onClose: m,
      onDismiss: h,
      hasSelectionRef: d,
      isPointerDownOnContentRef: c,
      isPointerInTransitRef: f,
      triggerElement: p
    }), (_, x) => (g(), C(l(hu), null, {
      default: y(() => [w(_.$slots, "default", { open: l(s) })]),
      _: 3
    }));
  }
}), oT = aT;
function hc(e) {
  return (t) => t.pointerType === "touch" ? void 0 : e();
}
function rT(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
var sT = /* @__PURE__ */ b({
  __name: "HoverCardContentImpl",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Ee(n), { forwardRef: r, currentElement: s } = le(), i = cp(), { isPointerInTransit: u, onPointerExit: d } = tD(i.triggerElement, s);
    $E(i.isPointerInTransitRef, u, { direction: "rtl" }), d(() => {
      i.onClose();
    });
    const c = O(!1);
    let f;
    Me((v) => {
      if (c.value) {
        const m = document.body;
        f = m.style.userSelect || m.style.webkitUserSelect, m.style.userSelect = "none", m.style.webkitUserSelect = "none", v(() => {
          m.style.userSelect = f, m.style.webkitUserSelect = f;
        });
      }
    });
    function p() {
      c.value = !1, i.isPointerDownOnContentRef.value = !1, he(() => {
        var m;
        ((m = document.getSelection()) == null ? void 0 : m.toString()) !== "" && (i.hasSelectionRef.value = !0);
      });
    }
    return be(() => {
      s.value && (document.addEventListener("pointerup", p), rT(s.value).forEach((m) => m.setAttribute("tabindex", "-1")));
    }), Ze(() => {
      document.removeEventListener("pointerup", p), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;
    }), (v, m) => (g(), C(l(Gs), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: m[1] || (m[1] = (h) => a("escapeKeyDown", h)),
      onPointerDownOutside: m[2] || (m[2] = (h) => a("pointerDownOutside", h)),
      onFocusOutside: m[3] || (m[3] = We((h) => a("focusOutside", h), ["prevent"])),
      onDismiss: l(i).onDismiss
    }, {
      default: y(() => [N(l(rp), A({
        ...l(o),
        ...v.$attrs
      }, {
        ref: l(r),
        "data-state": l(i).open.value ? "open" : "closed",
        style: {
          userSelect: c.value ? "text" : void 0,
          WebkitUserSelect: c.value ? "text" : void 0,
          "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
          "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
          "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onPointerdown: m[0] || (m[0] = (h) => {
          h.currentTarget.contains(h.target) && (c.value = !0), l(i).hasSelectionRef.value = !1, l(i).isPointerDownOnContentRef.value = !0;
        })
      }), {
        default: y(() => [w(v.$slots, "default")]),
        _: 3
      }, 16, ["data-state", "style"])]),
      _: 3
    }, 8, ["onDismiss"]));
  }
}), lT = sT, iT = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t), { forwardRef: r } = le(), s = cp();
    return (i, u) => (g(), C(l(nn), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(lT, A(l(o), {
        ref: l(r),
        onPointerenter: u[0] || (u[0] = (d) => l(hc)(l(s).onOpen)(d))
      }), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), uT = iT, dT = /* @__PURE__ */ b({
  __name: "HoverCardPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(pu), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), cT = dT, fT = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  setup(e) {
    const { forwardRef: t, currentElement: n } = le(), a = cp();
    a.triggerElement = n;
    function o() {
      setTimeout(() => {
        !a.isPointerInTransitRef.value && !a.open.value && a.onClose();
      }, 0);
    }
    return (r, s) => (g(), C(l(op), {
      "as-child": "",
      reference: r.reference
    }, {
      default: y(() => [N(l(se), {
        ref: l(t),
        "as-child": r.asChild,
        as: r.as,
        "data-state": l(a).open.value ? "open" : "closed",
        "data-grace-area-trigger": "",
        onPointerenter: s[0] || (s[0] = (i) => l(hc)(l(a).onOpen)(i)),
        onPointerleave: s[1] || (s[1] = (i) => l(hc)(o)(i)),
        onFocus: s[2] || (s[2] = (i) => l(a).onOpen()),
        onBlur: s[3] || (s[3] = (i) => l(a).onClose())
      }, {
        default: y(() => [w(r.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "data-state"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), pT = fT, vT = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "label"
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(se), A(t, { onMousedown: a[0] || (a[0] = (o) => {
      !o.defaultPrevented && o.detail > 1 && o.preventDefault();
    }) }), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), mT = vT, hT = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    return le(), (r, s) => (g(), C(l(jb), ne(oe({
      ...n,
      ...l(o)
    })), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gT = hT;
const [bu, yT] = He("MenubarRoot");
var bT = /* @__PURE__ */ b({
  __name: "MenubarRoot",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o } = le(), { CollectionSlot: r } = Gt({
      key: "Menubar",
      isProvider: !0
    }), s = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), i = O(null), { dir: u, loop: d } = Be(n), c = tn(u);
    return yT({
      modelValue: s,
      dir: c,
      loop: d,
      onMenuOpen: (f) => {
        s.value = f, i.value = f;
      },
      onMenuClose: () => {
        s.value = "";
      },
      onMenuToggle: (f) => {
        s.value = s.value ? "" : f, i.value = f;
      }
    }), (f, p) => (g(), C(l(r), null, {
      default: y(() => [N(l(vu), {
        "current-tab-stop-id": i.value,
        "onUpdate:currentTabStopId": p[0] || (p[0] = (v) => i.value = v),
        orientation: "horizontal",
        loop: l(d),
        dir: l(c),
        "as-child": ""
      }, {
        default: y(() => [N(l(se), {
          ref: l(o),
          role: "menubar"
        }, {
          default: y(() => [w(f.$slots, "default", { modelValue: l(s) })]),
          _: 3
        }, 512)]),
        _: 3
      }, 8, [
        "current-tab-stop-id",
        "loop",
        "dir"
      ])]),
      _: 3
    }));
  }
}), _T = bT;
const [fp, wT] = He("MenubarMenu");
var xT = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: { value: {
    type: String,
    required: !1
  } },
  setup(e) {
    const n = yt(e.value), a = bu();
    le();
    const o = O(), r = O(!1), s = E(() => a.modelValue.value === n);
    return ce(s, () => {
      s.value || (r.value = !1);
    }), wT({
      value: n,
      triggerElement: o,
      triggerId: n,
      contentId: "",
      wasKeyboardTriggerOpenRef: r
    }), (i, u) => (g(), C(l(Lb), {
      open: s.value,
      modal: !1,
      dir: l(a).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || l(a).onMenuClose();
      })
    }, {
      default: y(() => [w(i.$slots, "default")]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), CT = xT, ST = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    le();
    const r = bu(), s = fp();
    s.contentId || (s.contentId = yt(void 0, "reka-menubar-content"));
    const { getItems: i } = Gt({ key: "Menubar" }), u = O(!1);
    function d(c) {
      const p = c.target.hasAttribute("data-reka-menubar-subtrigger"), m = (r.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!m && p) return;
      let _ = i().filter(($) => $.ref.dataset.disabled !== "").map(($) => $.ref.dataset.value);
      m && _.reverse();
      const x = _.indexOf(s.value);
      _ = r.loop.value ? tp(_, x + 1) : _.slice(x + 1);
      const [S] = _;
      S && r.onMenuOpen(S);
    }
    return (c, f) => (g(), C(l(Wb), A(l(o), {
      id: l(s).contentId,
      "data-reka-menubar-content": "",
      "aria-labelledby": l(s).triggerId,
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (p) => {
        var m;
        !!!l(r).modelValue.value && !u.value && ((m = l(s).triggerElement.value) == null || m.focus()), u.value = !1, p.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (p) => {
        const v = p.target;
        l(i)().filter((h) => h.ref.dataset.disabled !== "").some((h) => h.ref.contains(v)) && p.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (p) => {
        u.value = !0;
      }),
      onEntryFocus: f[3] || (f[3] = (p) => {
        l(s).wasKeyboardTriggerOpenRef.value || p.preventDefault();
      }),
      onKeydown: Qe(d, ["arrow-right", "arrow-left"])
    }), {
      default: y(() => [w(c.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), $T = ST, BT = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(dp), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), PT = BT, ET = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    return le(), (r, s) => (g(), C(l(yu), ne(oe({
      ...n,
      ...l(o)
    })), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), DT = ET, MT = /* @__PURE__ */ b({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(Ub), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), o0 = MT, kT = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(Kb), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OT = kT, TT = /* @__PURE__ */ b({
  __name: "MenubarPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Gb), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), r0 = TT, AT = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = Kn(t);
    return le(), (r, s) => (g(), C(l(Yb), ne(oe({
      ...n,
      ...l(o)
    })), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), IT = AT, RT = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return le(), (r, s) => (g(), C(l(Xb), ne(oe(l(o))), {
      default: y(() => [w(r.$slots, "default")]),
      _: 3
    }, 16));
  }
}), qT = RT, FT = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(Jb), ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VT = FT, NT = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    le();
    const o = rt(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    return (r, s) => (g(), C(l(Qb), {
      open: l(o),
      "onUpdate:open": s[0] || (s[0] = (i) => ht(o) ? o.value = i : null)
    }, {
      default: y(() => [w(r.$slots, "default", { open: l(o) })]),
      _: 3
    }, 8, ["open"]));
  }
}), LT = NT, zT = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    le();
    const { getItems: r } = Gt({ key: "Menubar" }), s = bu(), i = fp();
    function u(d) {
      if (d.target.hasAttribute("data-reka-menubar-subtrigger")) return;
      let p = r().filter((h) => h.ref.dataset.disabled !== "").map((h) => h.ref.dataset.value);
      const v = p.indexOf(i.value);
      p = s.loop.value ? tp(p, v + 1) : p.slice(v + 1);
      const [m] = p;
      m && s.onMenuOpen(m);
    }
    return (d, c) => (g(), C(l(e0), A(l(o), {
      "data-reka-menubar-content": "",
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onKeydown: Qe(u, ["arrow-right"])
    }), {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), HT = zT, UT = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(t0), A(t, { "data-reka-menubar-subtrigger": "" }), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), jT = UT, WT = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = bu(), n = fp(), { forwardRef: a, currentElement: o } = le(), { CollectionItem: r } = Gt({ key: "Menubar" }), s = O(!1), i = E(() => t.modelValue.value === n.value);
    return be(() => {
      n.triggerElement = o;
    }), (u, d) => (g(), C(l(mu), {
      "as-child": "",
      focusable: !u.disabled,
      "tab-stop-id": l(n).value
    }, {
      default: y(() => [N(l(r), null, {
        default: y(() => [N(l(lp), { "as-child": "" }, {
          default: y(() => [N(l(se), {
            id: l(n).triggerId,
            ref: l(a),
            as: u.as,
            "as-child": u.asChild,
            type: u.as === "button" ? "button" : void 0,
            role: "menuitem",
            "aria-haspopup": "menu",
            "aria-expanded": i.value,
            "aria-controls": i.value ? l(n).contentId : void 0,
            "data-highlighted": s.value ? "" : void 0,
            "data-state": i.value ? "open" : "closed",
            "data-disabled": u.disabled ? "" : void 0,
            disabled: u.disabled,
            "data-value": l(n).value,
            onPointerdown: d[0] || (d[0] = (c) => {
              !u.disabled && c.button === 0 && c.ctrlKey === !1 && (l(t).onMenuOpen(l(n).value), i.value || c.preventDefault());
            }),
            onPointerenter: d[1] || (d[1] = () => {
              var f;
              !!l(t).modelValue.value && !i.value && (l(t).onMenuOpen(l(n).value), (f = l(o)) == null || f.focus());
            }),
            onKeydown: d[2] || (d[2] = Qe((c) => {
              u.disabled || (["Enter", " "].includes(c.key) && l(t).onMenuToggle(l(n).value), c.key === "ArrowDown" && l(t).onMenuOpen(l(n).value), [
                "Enter",
                " ",
                "ArrowDown"
              ].includes(c.key) && (l(n).wasKeyboardTriggerOpenRef.value = !0, c.preventDefault()));
            }, [
              "enter",
              "space",
              "arrow-down"
            ])),
            onFocus: d[3] || (d[3] = (c) => s.value = !0),
            onBlur: d[4] || (d[4] = (c) => s.value = !1)
          }, {
            default: y(() => [w(u.$slots, "default")]),
            _: 3
          }, 8, [
            "id",
            "as",
            "as-child",
            "type",
            "aria-expanded",
            "aria-controls",
            "data-highlighted",
            "data-state",
            "data-disabled",
            "disabled",
            "data-value"
          ])]),
          _: 3
        })]),
        _: 3
      })]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), KT = WT;
const [ko, GT] = He(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var YT = /* @__PURE__ */ b({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: void 0
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: 200
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableClickTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableHoverTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disablePointerLeaveClose: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = rt(n, "modelValue", t, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), r = O(""), { forwardRef: s, currentElement: i } = le(), u = O(), d = O(), c = O(), { getItems: f, CollectionSlot: p } = Gt({
      key: "NavigationMenu",
      isProvider: !0
    }), { delayDuration: v, skipDelayDuration: m, dir: h, disableClickTrigger: _, disableHoverTrigger: x, unmountOnHide: S } = Be(n), $ = tn(h), D = Ws(!1, m), B = E(() => o.value !== "" || D.value ? 150 : v.value), k = Xf((M) => {
      typeof M == "string" && (r.value = o.value, o.value = M);
    }, B);
    return Me(() => {
      if (!o.value) return;
      const M = f().map((I) => I.ref);
      c.value = M.find((I) => I.id.includes(o.value));
    }), GT({
      isRootMenu: !0,
      modelValue: o,
      previousValue: r,
      baseId: yt(void 0, "reka-navigation-menu"),
      disableClickTrigger: _,
      disableHoverTrigger: x,
      dir: $,
      unmountOnHide: S,
      orientation: n.orientation,
      rootNavigationMenu: i,
      indicatorTrack: u,
      activeTrigger: c,
      onIndicatorTrackChange: (M) => {
        u.value = M;
      },
      viewport: d,
      onViewportChange: (M) => {
        d.value = M;
      },
      onTriggerEnter: (M) => {
        k(M);
      },
      onTriggerLeave: () => {
        D.value = !0, k("");
      },
      onContentEnter: () => {
        k();
      },
      onContentLeave: () => {
        n.disablePointerLeaveClose || k("");
      },
      onItemSelect: (M) => {
        r.value = o.value, o.value = M;
      },
      onItemDismiss: () => {
        r.value = o.value, o.value = "";
      }
    }), (M, I) => (g(), C(l(p), null, {
      default: y(() => [N(l(se), {
        ref: l(s),
        "aria-label": "Main",
        as: M.as,
        "as-child": M.asChild,
        "data-orientation": M.orientation,
        dir: l($),
        "data-reka-navigation-menu": ""
      }, {
        default: y(() => [w(M.$slots, "default", { modelValue: l(o) })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-orientation",
        "dir"
      ])]),
      _: 3
    }));
  }
}), XT = YT;
function _u(e) {
  return e ? "open" : "closed";
}
function s0(e, t) {
  return `${e}-trigger-${t}`;
}
function pp(e, t) {
  return `${e}-content-${t}`;
}
const JT = "navigationMenu.linkSelect", zl = "navigationMenu.rootContentDismiss";
function gc(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const o = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || o ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function l0(e) {
  const t = gt();
  return e.some((n) => n === t ? !0 : (n.focus(), gt() !== t));
}
function ZT(e) {
  return e.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    e.forEach((t) => {
      const n = t.dataset.tabindex;
      t.setAttribute("tabindex", n);
    });
  };
}
function i0(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
const [vp, QT] = He("NavigationMenuItem");
var eA = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  setup(e) {
    const t = e;
    le();
    const { getItems: n } = Gt({ key: "NavigationMenu" }), a = ko(), o = yt(t.value), r = O(), s = O(), i = pp(a.baseId, o);
    let u = () => ({});
    const d = O(!1);
    async function c(m = "start") {
      const h = document.getElementById(i);
      if (h) {
        u();
        const _ = gc(h);
        _.length && l0(m === "start" ? _ : _.reverse());
      }
    }
    function f() {
      const m = document.getElementById(i);
      if (m) {
        const h = gc(m);
        h.length && (u = ZT(h));
      }
    }
    QT({
      value: o,
      contentId: i,
      triggerRef: r,
      focusProxyRef: s,
      wasEscapeCloseRef: d,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function p() {
      var m;
      a.onItemDismiss(), (m = r.value) == null || m.focus();
    }
    function v(m) {
      const h = gt();
      if (m.keyCode === 32 || m.key === "Enter") if (a.modelValue.value === o) {
        p(), m.preventDefault();
        return;
      } else {
        m.target.click(), m.preventDefault();
        return;
      }
      const _ = n().filter((S) => {
        var $;
        return ($ = S.ref.parentElement) == null ? void 0 : $.hasAttribute("data-menu-item");
      }).map((S) => S.ref);
      if (!_.includes(h)) return;
      const x = Mr(m, h, void 0, {
        itemsArray: _,
        loop: !1
      });
      x && (x == null || x.focus()), m.preventDefault(), m.stopPropagation();
    }
    return (m, h) => (g(), C(l(se), {
      "as-child": m.asChild,
      as: m.as,
      "data-menu-item": "",
      onKeydown: Qe(v, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end",
        "space"
      ])
    }, {
      default: y(() => [w(m.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), tA = eA, nA = /* @__PURE__ */ b({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: o } = Gt({ key: "NavigationMenu" }), { forwardRef: r, currentElement: s } = le(), i = ko(), u = vp(), d = s0(i.baseId, u.value), c = pp(i.baseId, u.value), f = O(null), p = E(() => {
      const S = o().map((I) => I.ref.id.split("trigger-")[1]);
      i.dir.value === "rtl" && S.reverse();
      const $ = S.indexOf(i.modelValue.value), D = S.indexOf(i.previousValue.value), B = u.value === i.modelValue.value, k = D === S.indexOf(u.value);
      if (!B && !k) return f.value;
      const M = (() => {
        if ($ !== D) {
          if (B && D !== -1) return $ > D ? "from-end" : "from-start";
          if (k && $ !== -1) return $ > D ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = M, M;
    });
    function v(S) {
      var D, B;
      if (a("focusOutside", S), a("interactOutside", S), S.detail.originalEvent.target.hasAttribute("data-navigation-menu-trigger") && S.preventDefault(), !S.defaultPrevented) {
        u.onContentFocusOutside();
        const k = S.target;
        (B = (D = i.rootNavigationMenu) == null ? void 0 : D.value) != null && B.contains(k) && S.preventDefault();
      }
    }
    function m(S) {
      var $;
      if (a("pointerDownOutside", S), !S.defaultPrevented) {
        const D = S.target, B = o().some((M) => M.ref.contains(D)), k = i.isRootMenu && (($ = i.viewport.value) == null ? void 0 : $.contains(D));
        (B || k || !i.isRootMenu) && S.preventDefault();
      }
    }
    Me((S) => {
      const $ = s.value;
      if (i.isRootMenu && $) {
        const D = () => {
          var B;
          i.onItemDismiss(), u.onRootContentClose(), $.contains(gt()) && ((B = u.triggerRef.value) == null || B.focus());
        };
        $.addEventListener(zl, D), S(() => $.removeEventListener(zl, D));
      }
    });
    function h(S) {
      var $, D;
      a("escapeKeyDown", S), S.defaultPrevented || (i.onItemDismiss(), (D = ($ = u.triggerRef) == null ? void 0 : $.value) == null || D.focus(), u.wasEscapeCloseRef.value = !0);
    }
    function _(S) {
      var M;
      if (S.target.closest("[data-reka-navigation-menu]") !== i.rootNavigationMenu.value) return;
      const $ = S.altKey || S.ctrlKey || S.metaKey, D = S.key === "Tab" && !$, B = gc(S.currentTarget);
      if (D) {
        const I = gt(), T = B.findIndex((R) => R === I), q = S.shiftKey ? B.slice(0, T).reverse() : B.slice(T + 1, B.length);
        if (l0(q)) S.preventDefault();
        else {
          (M = u.focusProxyRef.value) == null || M.focus();
          return;
        }
      }
      const k = Mr(S, gt(), void 0, {
        itemsArray: B,
        loop: !1,
        enableIgnoredElement: !0
      });
      k == null || k.focus();
    }
    function x() {
      var $;
      const S = new Event(zl, {
        bubbles: !0,
        cancelable: !0
      });
      ($ = s.value) == null || $.dispatchEvent(S);
    }
    return (S, $) => (g(), C(l(Gs), A({
      id: l(c),
      ref: l(r),
      "aria-labelledby": l(d),
      "data-motion": p.value,
      "data-state": l(_u)(l(i).modelValue.value === l(u).value),
      "data-orientation": l(i).orientation
    }, n, {
      onKeydown: _,
      onEscapeKeyDown: h,
      onPointerDownOutside: m,
      onFocusOutside: v,
      onDismiss: x
    }), {
      default: y(() => [w(S.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "data-motion",
      "data-state",
      "data-orientation"
    ]));
  }
}), aA = nA, oA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = qe(fu(n, "forceMount"), a), { forwardRef: r } = le(), s = ko(), i = vp(), u = E(() => i.value === s.modelValue.value), d = E(() => s.viewport.value && !s.modelValue.value && s.previousValue.value ? s.previousValue.value === i.value : !1);
    return (c, f) => (g(), C(Co, {
      to: l(Wn) && l(s).viewport.value ? l(s).viewport.value : "body",
      disabled: l(Wn) && l(s).viewport.value ? !l(s).viewport.value : !0
    }, [N(l(nn), {
      present: c.forceMount || u.value || d.value,
      "force-mount": !l(s).unmountOnHide.value
    }, {
      default: y(({ present: p }) => [N(aA, A({
        ref: l(r),
        "data-state": l(_u)(u.value),
        style: { pointerEvents: !u.value && l(s).isRootMenu ? "none" : void 0 }
      }, {
        ...c.$attrs,
        ...l(o)
      }, {
        hidden: !p,
        onPointerenter: f[0] || (f[0] = (v) => l(s).onContentEnter(l(i).value)),
        onPointerleave: f[1] || (f[1] = (v) => l(i0)(() => l(s).onContentLeave())(v)),
        onPointerDownOutside: f[2] || (f[2] = (v) => a("pointerDownOutside", v)),
        onFocusOutside: f[3] || (f[3] = (v) => a("focusOutside", v)),
        onInteractOutside: f[4] || (f[4] = (v) => a("interactOutside", v))
      }), {
        default: y(() => [w(c.$slots, "default")]),
        _: 2
      }, 1040, [
        "data-state",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"])], 8, ["to", "disabled"]));
  }
}), rA = oA, sA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = le(), a = ko(), o = O(), r = E(() => a.orientation === "horizontal"), s = E(() => !!a.modelValue.value), { activeTrigger: i } = a;
    function u() {
      i.value && (o.value = {
        size: r.value ? i.value.offsetWidth : i.value.offsetHeight,
        position: r.value ? i.value.offsetLeft : i.value.offsetTop
      });
    }
    return Me(() => {
      a.modelValue.value && u();
    }), sa(i, u), sa(a.indicatorTrack, u), (d, c) => l(a).indicatorTrack.value ? (g(), C(Co, {
      key: 0,
      to: l(a).indicatorTrack.value
    }, [N(l(nn), { present: d.forceMount || s.value }, {
      default: y(() => [N(l(se), A({
        ref: l(n),
        "aria-hidden": "true",
        "data-state": s.value ? "visible" : "hidden",
        "data-orientation": l(a).orientation,
        "as-child": t.asChild,
        as: d.as,
        style: { ...o.value ? {
          "--reka-navigation-menu-indicator-size": `${o.value.size}px`,
          "--reka-navigation-menu-indicator-position": `${o.value.position}px`
        } : {} }
      }, d.$attrs), {
        default: y(() => [w(d.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }, 8, ["present"])], 8, ["to"])) : Pe("v-if", !0);
  }
}), lA = sA, iA = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { CollectionItem: o } = Gt({ key: "NavigationMenu" });
    le();
    async function r(s) {
      var u;
      const i = new CustomEvent(JT, {
        bubbles: !0,
        cancelable: !0,
        detail: { originalEvent: s }
      });
      if (a("select", i), !i.defaultPrevented && !s.metaKey) {
        const d = new CustomEvent(zl, {
          bubbles: !0,
          cancelable: !0
        });
        (u = s.target) == null || u.dispatchEvent(d);
      }
    }
    return (s, i) => (g(), C(l(o), null, {
      default: y(() => [N(l(se), {
        as: s.as,
        "data-active": s.active ? "" : void 0,
        "aria-current": s.active ? "page" : void 0,
        "as-child": n.asChild,
        onClick: r
      }, {
        default: y(() => [w(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "data-active",
        "aria-current",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), uA = iA, dA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  setup(e) {
    const t = e, n = ko(), { forwardRef: a, currentElement: o } = le();
    return be(() => {
      n.onIndicatorTrackChange(o.value);
    }), (r, s) => (g(), C(l(se), {
      ref: l(a),
      style: { position: "relative" }
    }, {
      default: y(() => [N(l(se), A(r.$attrs, {
        "as-child": t.asChild,
        as: r.as,
        "data-orientation": l(n).orientation
      }), {
        default: y(() => [w(r.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-orientation"
      ])]),
      _: 3
    }, 512));
  }
}), cA = dA;
const fA = ["aria-owns"];
var pA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = ko(), a = vp(), { CollectionItem: o } = Gt({ key: "NavigationMenu" }), { forwardRef: r, currentElement: s } = le(), i = O(""), u = O(""), d = Ws(!1, 300), c = O(!1), f = E(() => a.value === n.modelValue.value);
    be(() => {
      a.triggerRef = s, i.value = s0(n.baseId, a.value), u.value = pp(n.baseId, a.value);
    });
    function p() {
      n.disableHoverTrigger.value || (c.value = !1, a.wasEscapeCloseRef.value = !1);
    }
    function v($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled || c.value || a.wasEscapeCloseRef.value || d.value) return;
        n.onTriggerEnter(a.value), d.value = !0;
      }
    }
    function m($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled) return;
        n.onTriggerLeave(), d.value = !1;
      }
    }
    function h($) {
      (!("pointerType" in $) || $.pointerType === "mouse") && n.disableClickTrigger.value || d.value || (f.value ? n.onItemSelect("") : n.onItemSelect(a.value), c.value = f.value);
    }
    function _($) {
      const B = {
        horizontal: "ArrowDown",
        vertical: n.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight"
      }[n.orientation];
      f.value && $.key === B && (a.onEntryKeyDown(), $.preventDefault(), $.stopPropagation());
    }
    function x($) {
      a.focusProxyRef.value = mn($);
    }
    function S($) {
      const D = document.getElementById(a.contentId), B = $.relatedTarget, k = B === s.value, M = D == null ? void 0 : D.contains(B);
      (k || !M) && a.onFocusProxyEnter(k ? "start" : "end");
    }
    return ($, D) => (g(), U(Fe, null, [N(l(o), null, {
      default: y(() => [N(l(se), A({
        id: i.value,
        ref: l(r),
        disabled: $.disabled,
        "data-disabled": $.disabled ? "" : void 0,
        "data-state": l(_u)(f.value),
        "data-navigation-menu-trigger": "",
        "aria-expanded": f.value,
        "aria-controls": u.value,
        "as-child": t.asChild,
        as: $.as
      }, $.$attrs, {
        onPointerenter: p,
        onPointermove: v,
        onPointerleave: m,
        onClick: h,
        onKeydown: _
      }), {
        default: y(() => [w($.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "disabled",
        "data-disabled",
        "data-state",
        "aria-expanded",
        "aria-controls",
        "as-child",
        "as"
      ])]),
      _: 3
    }), f.value ? (g(), U(Fe, { key: 0 }, [N(l(Ib), {
      ref: x,
      "aria-hidden": "true",
      tabindex: 0,
      onFocus: S
    }), l(n).viewport ? (g(), U("span", {
      key: 0,
      "aria-owns": u.value
    }, null, 8, fA)) : Pe("v-if", !0)], 64)) : Pe("v-if", !0)], 64));
  }
}), vA = pA, mA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    align: {
      type: String,
      required: !1,
      default: "center"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    var v;
    const t = e, { forwardRef: n, currentElement: a } = le(), o = ko(), { activeTrigger: r, rootNavigationMenu: s, modelValue: i } = o, u = O(), d = O(), c = E(() => !!o.modelValue.value);
    ce(a, () => {
      o.onViewportChange(a.value);
    });
    const f = O();
    ce([i, c], () => {
      he(() => {
        a.value && requestAnimationFrame(() => {
          var h;
          const m = (h = a.value) == null ? void 0 : h.querySelector("[data-state=open]");
          f.value = m;
        });
      });
    }, { immediate: !0 });
    function p() {
      if (f.value && r.value && s.value) {
        const m = document.documentElement.offsetWidth, h = document.documentElement.offsetHeight, _ = s.value.getBoundingClientRect(), x = r.value.getBoundingClientRect(), { offsetWidth: S, offsetHeight: $ } = f.value, D = x.left - _.left, B = x.top - _.top;
        let k = null, M = null;
        switch (t.align) {
          case "start":
            k = D, M = B;
            break;
          case "end":
            k = D - S + x.width, M = B - $ + x.height;
            break;
          default:
            k = D - S / 2 + x.width / 2, M = B - $ / 2 + x.height / 2;
        }
        const I = 10;
        k + _.left < I && (k = I - _.left);
        const T = k + _.left + S;
        T > m - I && (k -= T - m + I, k < I - _.left && (k = I - _.left)), M + _.top < I && (M = I - _.top);
        const P = M + _.top + $;
        P > h - I && (M -= P - h + I, M < I - _.top && (M = I - _.top)), k = Math.round(k), M = Math.round(M), d.value = {
          left: k,
          top: M
        };
      }
    }
    return sa(f, () => {
      f.value && (u.value = {
        width: f.value.offsetWidth,
        height: f.value.offsetHeight
      }, p());
    }), sa([(v = globalThis.document) == null ? void 0 : v.body, s], () => {
      p();
    }), (m, h) => (g(), C(l(nn), {
      present: m.forceMount || c.value,
      "force-mount": !l(o).unmountOnHide.value,
      onAfterLeave: h[2] || (h[2] = () => {
        u.value = void 0, d.value = void 0;
      })
    }, {
      default: y(({ present: _ }) => {
        var x, S, $, D;
        return [N(l(se), A(m.$attrs, {
          ref: l(n),
          as: m.as,
          "as-child": m.asChild,
          "data-state": l(_u)(c.value),
          "data-orientation": l(o).orientation,
          style: {
            pointerEvents: !c.value && l(o).isRootMenu ? "none" : void 0,
            "--reka-navigation-menu-viewport-width": u.value ? `${(x = u.value) == null ? void 0 : x.width}px` : void 0,
            "--reka-navigation-menu-viewport-height": u.value ? `${(S = u.value) == null ? void 0 : S.height}px` : void 0,
            "--reka-navigation-menu-viewport-left": d.value ? `${($ = d.value) == null ? void 0 : $.left}px` : void 0,
            "--reka-navigation-menu-viewport-top": d.value ? `${(D = d.value) == null ? void 0 : D.top}px` : void 0
          },
          hidden: !_,
          onPointerenter: h[0] || (h[0] = (B) => l(o).onContentEnter(l(o).modelValue.value)),
          onPointerleave: h[1] || (h[1] = (B) => l(i0)(() => l(o).onContentLeave())(B))
        }), {
          default: y(() => [w(m.$slots, "default")]),
          _: 2
        }, 1040, [
          "as",
          "as-child",
          "data-state",
          "data-orientation",
          "style",
          "hidden"
        ])];
      }),
      _: 3
    }, 8, ["present", "force-mount"]));
  }
}), hA = mA;
function u0(e) {
  const { disabled: t } = e, n = O(), a = tr(), o = () => window.clearTimeout(n.value), r = (p) => {
    o(), !t.value && (a.trigger(), n.value = window.setTimeout(() => {
      r(60);
    }, p));
  }, s = () => {
    r(400);
  }, i = () => {
    o();
  }, u = O(!1), d = E(() => mn(e.target)), c = (p) => {
    p.button !== 0 || u.value || (p.preventDefault(), u.value = !0, s());
  }, f = () => {
    u.value = !1, i();
  };
  return Wn && (on(d || window, "pointerdown", c), on(window, "pointerup", f), on(window, "pointercancel", f)), {
    isPressed: u,
    onTrigger: a.on
  };
}
function Cm(e, t = O({})) {
  return Yf(() => new ry(e.value, t.value));
}
function gA(e, t = O({})) {
  return Yf(() => new sy(e.value, t.value));
}
function Sm(e, t, n) {
  let a = e === "+" ? t + n : t - n;
  if (t % 1 !== 0 || n % 1 !== 0) {
    const o = t.toString().split("."), r = n.toString().split("."), s = o[1] && o[1].length || 0, i = r[1] && r[1].length || 0, u = 10 ** Math.max(s, i);
    t = Math.round(t * u), n = Math.round(n * u), a = e === "+" ? t + n : t - n, a /= u;
  }
  return a;
}
const [mp, yA] = He("NumberFieldRoot");
var bA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NumberFieldRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: void 0
    },
    modelValue: {
      type: [Number, null],
      required: !1
    },
    min: {
      type: Number,
      required: !1
    },
    max: {
      type: Number,
      required: !1
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    stepSnapping: {
      type: Boolean,
      required: !1,
      default: !0
    },
    formatOptions: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    readonly: {
      type: Boolean,
      required: !1
    },
    disableWheelChange: {
      type: Boolean,
      required: !1
    },
    invertWheelChange: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: o, readonly: r, disableWheelChange: s, invertWheelChange: i, min: u, max: d, step: c, stepSnapping: f, formatOptions: p, id: v, locale: m } = Be(n), h = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { primitiveElement: _, currentElement: x } = Kt(), S = ep(m), $ = ro(x), D = O(), B = E(() => !mo(h.value) && (J(h.value) === u.value || u.value && !isNaN(h.value) ? Sm("-", h.value, c.value) < u.value : !1)), k = E(() => !mo(h.value) && (J(h.value) === d.value || d.value && !isNaN(h.value) ? Sm("+", h.value, c.value) > d.value : !1));
    function M(Y, Z = 1) {
      var $e, Ce;
      if (($e = D.value) == null || $e.focus(), n.disabled || n.readonly) return;
      const pe = R.parse(((Ce = D.value) == null ? void 0 : Ce.value) ?? "");
      isNaN(pe) ? h.value = u.value ?? 0 : Y === "increase" ? h.value = J(pe + (c.value ?? 1) * Z) : h.value = J(pe - (c.value ?? 1) * Z);
    }
    function I(Y = 1) {
      M("increase", Y);
    }
    function T(Y = 1) {
      M("decrease", Y);
    }
    function P(Y) {
      Y === "min" && u.value !== void 0 ? h.value = J(u.value) : Y === "max" && d.value !== void 0 && (h.value = J(d.value));
    }
    const q = Cm(S, p), R = gA(S, p), Q = E(() => q.resolvedOptions().maximumFractionDigits > 0 ? "decimal" : "numeric"), ee = Cm(S, p), K = E(() => mo(h.value) || isNaN(h.value) ? "" : ee.format(h.value));
    function W(Y) {
      return R.isValidPartialNumber(Y, u.value, d.value);
    }
    function j(Y) {
      D.value && (D.value.value = Y);
    }
    function J(Y) {
      let Z;
      return c.value === void 0 || isNaN(c.value) || !f.value ? Z = pb(Y, u.value, d.value) : Z = dE(Y, u.value, d.value, c.value), Z = R.parse(q.format(Z)), Z;
    }
    function z(Y) {
      const Z = R.parse(Y);
      return h.value = isNaN(Z) ? void 0 : J(Z), Y.length ? (isNaN(Z), j(K.value)) : j(Y);
    }
    return yA({
      modelValue: h,
      handleDecrease: T,
      handleIncrease: I,
      handleMinMaxValue: P,
      inputMode: Q,
      inputEl: D,
      onInputElement: (Y) => D.value = Y,
      textValue: K,
      validate: W,
      applyInputValue: z,
      disabled: o,
      readonly: r,
      disableWheelChange: s,
      invertWheelChange: i,
      max: d,
      min: u,
      isDecreaseDisabled: B,
      isIncreaseDisabled: k,
      id: v
    }), (Y, Z) => (g(), C(l(se), A(Y.$attrs, {
      ref_key: "primitiveElement",
      ref: _,
      role: "group",
      as: Y.as,
      "as-child": Y.asChild,
      "data-disabled": l(o) ? "" : void 0,
      "data-readonly": l(r) ? "" : void 0
    }), {
      default: y(() => [w(Y.$slots, "default", {
        modelValue: l(h),
        textValue: K.value
      }), l($) && Y.name ? (g(), C(l(Ta), {
        key: 0,
        type: "text",
        value: l(h),
        name: Y.name,
        disabled: l(o),
        readonly: l(r),
        required: Y.required
      }, null, 8, [
        "value",
        "name",
        "disabled",
        "readonly",
        "required"
      ])) : Pe("v-if", !0)]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-disabled",
      "data-readonly"
    ]));
  }
}), _A = bA, wA = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = mp(), a = E(() => {
      var u;
      return ((u = n.disabled) == null ? void 0 : u.value) || n.readonly.value || t.disabled || n.isDecreaseDisabled.value;
    }), { primitiveElement: o, currentElement: r } = Kt(), { isPressed: s, onTrigger: i } = u0({
      target: r,
      disabled: a
    });
    return i(() => {
      n.handleDecrease();
    }), (u, d) => (g(), C(l(se), A(t, {
      ref_key: "primitiveElement",
      ref: o,
      tabindex: "-1",
      "aria-label": "Decrease",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = We(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [w(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), xA = wA, CA = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = mp(), a = E(() => {
      var u;
      return ((u = n.disabled) == null ? void 0 : u.value) || n.readonly.value || t.disabled || n.isIncreaseDisabled.value;
    }), { primitiveElement: o, currentElement: r } = Kt(), { isPressed: s, onTrigger: i } = u0({
      target: r,
      disabled: a
    });
    return i(() => {
      n.handleIncrease();
    }), (u, d) => (g(), C(l(se), A(t, {
      ref_key: "primitiveElement",
      ref: o,
      tabindex: "-1",
      "aria-label": "Increase",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = We(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [w(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), SA = CA, $A = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Kt(), o = mp();
    function r(u) {
      o.disableWheelChange.value || u.target === gt() && (Math.abs(u.deltaY) <= Math.abs(u.deltaX) || (u.preventDefault(), u.deltaY > 0 ? o.invertWheelChange.value ? o.handleDecrease() : o.handleIncrease() : u.deltaY < 0 && (o.invertWheelChange.value ? o.handleIncrease() : o.handleDecrease())));
    }
    be(() => {
      o.onInputElement(a.value);
    });
    const s = O(o.textValue.value);
    ce(() => o.textValue.value, () => {
      s.value = o.textValue.value;
    }, {
      immediate: !0,
      deep: !0
    });
    function i() {
      requestAnimationFrame(() => {
        s.value = o.textValue.value;
      });
    }
    return (u, d) => (g(), C(l(se), A(t, {
      id: l(o).id.value,
      ref_key: "primitiveElement",
      ref: n,
      value: s.value,
      role: "spinbutton",
      type: "text",
      tabindex: "0",
      inputmode: l(o).inputMode.value,
      disabled: l(o).disabled.value ? "" : void 0,
      "data-disabled": l(o).disabled.value ? "" : void 0,
      readonly: l(o).readonly.value ? "" : void 0,
      "data-readonly": l(o).readonly.value ? "" : void 0,
      autocomplete: "off",
      autocorrect: "off",
      spellcheck: "false",
      "aria-roledescription": "Number field",
      "aria-valuenow": l(o).modelValue.value,
      "aria-valuemin": l(o).min.value,
      "aria-valuemax": l(o).max.value,
      onKeydown: [
        d[0] || (d[0] = Qe(We((c) => l(o).handleIncrease(), ["prevent"]), ["up"])),
        d[1] || (d[1] = Qe(We((c) => l(o).handleDecrease(), ["prevent"]), ["down"])),
        d[2] || (d[2] = Qe(We((c) => l(o).handleIncrease(10), ["prevent"]), ["page-up"])),
        d[3] || (d[3] = Qe(We((c) => l(o).handleDecrease(10), ["prevent"]), ["page-down"])),
        d[4] || (d[4] = Qe(We((c) => l(o).handleMinMaxValue("min"), ["prevent"]), ["home"])),
        d[5] || (d[5] = Qe(We((c) => l(o).handleMinMaxValue("max"), ["prevent"]), ["end"])),
        d[8] || (d[8] = Qe((c) => {
          var f;
          return l(o).applyInputValue((f = c.target) == null ? void 0 : f.value);
        }, ["enter"]))
      ],
      onWheel: r,
      onBeforeinput: d[6] || (d[6] = (c) => {
        const f = c.target;
        let p = f.value.slice(0, f.selectionStart ?? void 0) + (c.data ?? "") + f.value.slice(f.selectionEnd ?? void 0);
        l(o).validate(p) || c.preventDefault();
      }),
      onInput: d[7] || (d[7] = (c) => {
        const f = c.target;
        s.value = f.value;
      }),
      onChange: i,
      onBlur: d[9] || (d[9] = (c) => {
        var f;
        return l(o).applyInputValue((f = c.target) == null ? void 0 : f.value);
      })
    }), {
      default: y(() => [w(u.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "value",
      "inputmode",
      "disabled",
      "data-disabled",
      "readonly",
      "data-readonly",
      "aria-valuenow",
      "aria-valuemin",
      "aria-valuemax"
    ]));
  }
}), BA = $A, PA = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return le(), (n, a) => (g(), C(l(se), A(t, { "data-type": "ellipsis" }), {
      default: y(() => [w(n.$slots, "default", {}, () => [a[0] || (a[0] = Re("…"))])]),
      _: 3
    }, 16));
  }
}), EA = PA;
const [Tr, DA] = He("PaginationRoot");
var MA = /* @__PURE__ */ b({
  __name: "PaginationRoot",
  props: {
    page: {
      type: Number,
      required: !1
    },
    defaultPage: {
      type: Number,
      required: !1,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      required: !0
    },
    total: {
      type: Number,
      required: !1,
      default: 0
    },
    siblingCount: {
      type: Number,
      required: !1,
      default: 2
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    showEdges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, { siblingCount: o, disabled: r, showEdges: s } = Be(n);
    le();
    const i = rt(n, "page", a, {
      defaultValue: n.defaultPage,
      passive: n.page === void 0
    }), u = E(() => Math.max(1, Math.ceil(n.total / (n.itemsPerPage || 1))));
    return DA({
      page: i,
      onPageChange(d) {
        i.value = d;
      },
      pageCount: u,
      siblingCount: o,
      disabled: r,
      showEdges: s
    }), (d, c) => (g(), C(l(se), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: y(() => [w(d.$slots, "default", {
        page: l(i),
        pageCount: u.value
      })]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), kA = MA, OA = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Tr();
    le();
    const a = E(() => n.page.value === 1 || n.disabled.value);
    return (o, r) => (g(), C(l(se), A(t, {
      "aria-label": "First Page",
      type: o.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: r[0] || (r[0] = (s) => !a.value && l(n).onPageChange(1))
    }), {
      default: y(() => [w(o.$slots, "default", {}, () => [r[1] || (r[1] = Re("First page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), TA = OA, AA = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Tr();
    le();
    const a = E(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (o, r) => (g(), C(l(se), A(t, {
      "aria-label": "Last Page",
      type: o.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: r[0] || (r[0] = (s) => !a.value && l(n).onPageChange(l(n).pageCount.value))
    }), {
      default: y(() => [w(o.$slots, "default", {}, () => [r[1] || (r[1] = Re("Last page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), IA = AA;
function Fa(e, t) {
  const n = t - e + 1;
  return Array.from({ length: n }, (a, o) => o + e);
}
function RA(e) {
  return e.map((t) => typeof t == "number" ? {
    type: "page",
    value: t
  } : { type: "ellipsis" });
}
const yl = "ellipsis";
function qA(e, t, n, a) {
  const r = t, s = Math.max(e - n, 1), i = Math.min(e + n, r);
  if (a) {
    const d = Math.min(2 * n + 5, t) - 2, c = s > 3 && Math.abs(r - d - 1 + 1) > 2 && Math.abs(s - 1) > 2, f = i < r - 2 && Math.abs(r - d) > 2 && Math.abs(r - i) > 2;
    if (!c && f)
      return [
        ...Fa(1, d),
        yl,
        r
      ];
    if (c && !f) {
      const v = Fa(r - d + 1, r);
      return [
        1,
        yl,
        ...v
      ];
    }
    if (c && f) {
      const v = Fa(s, i);
      return [
        1,
        yl,
        ...v,
        yl,
        r
      ];
    }
    return Fa(1, r);
  } else {
    const u = n * 2 + 1;
    return t < u ? Fa(1, r) : e <= n + 1 ? Fa(1, u) : t - e <= n ? Fa(t - u + 1, r) : Fa(s, i);
  }
}
var FA = /* @__PURE__ */ b({
  __name: "PaginationList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Tr(), a = E(() => RA(qA(n.page.value, n.pageCount.value, n.siblingCount.value, n.showEdges.value)));
    return (o, r) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(o.$slots, "default", { items: a.value })]),
      _: 3
    }, 16));
  }
}), VA = FA, NA = /* @__PURE__ */ b({
  __name: "PaginationListItem",
  props: {
    value: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Tr(), a = E(() => n.page.value === t.value), o = E(() => n.disabled.value);
    return (r, s) => (g(), C(l(se), A(t, {
      "data-type": "page",
      "aria-label": `Page ${r.value}`,
      "aria-current": a.value ? "page" : void 0,
      "data-selected": a.value ? "true" : void 0,
      disabled: o.value,
      type: r.as === "button" ? "button" : void 0,
      onClick: s[0] || (s[0] = (i) => !o.value && l(n).onPageChange(r.value))
    }), {
      default: y(() => [w(r.$slots, "default", {}, () => [Re(Ve(r.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-current",
      "data-selected",
      "disabled",
      "type"
    ]));
  }
}), LA = NA, zA = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Tr(), a = E(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (o, r) => (g(), C(l(se), A(t, {
      "aria-label": "Next Page",
      type: o.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: r[0] || (r[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value + 1))
    }), {
      default: y(() => [w(o.$slots, "default", {}, () => [r[1] || (r[1] = Re("Next page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), HA = zA, UA = /* @__PURE__ */ b({
  __name: "PaginationPrev",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Tr(), a = E(() => n.page.value === 1 || n.disabled.value);
    return (o, r) => (g(), C(l(se), A(t, {
      "aria-label": "Previous Page",
      type: o.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: r[0] || (r[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value - 1))
    }), {
      default: y(() => [w(o.$slots, "default", {}, () => [r[1] || (r[1] = Re("Prev page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), jA = UA;
const [WA, KA] = He("PinInputRoot");
var GA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PinInputRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    mask: {
      type: Boolean,
      required: !1
    },
    otp: {
      type: Boolean,
      required: !1
    },
    type: {
      type: null,
      required: !1,
      default: "text"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, { mask: o, otp: r, placeholder: s, type: i, disabled: u, dir: d } = Be(n), { forwardRef: c } = le(), f = tn(d), p = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? [],
      passive: !0,
      deep: !0
    }), v = E(() => Array.isArray(p.value) ? [...p.value] : []), m = O(/* @__PURE__ */ new Set());
    function h(S) {
      m.value.add(S);
    }
    const _ = E(() => n.type === "number"), x = E(() => v.value.filter(($) => !!$ || _.value && $ === 0).length === m.value.size);
    return ce(p, () => {
      x.value && a("complete", p.value);
    }, { deep: !0 }), KA({
      modelValue: p,
      currentModelValue: v,
      mask: o,
      otp: r,
      placeholder: s,
      type: i,
      dir: f,
      disabled: u,
      isCompleted: x,
      inputElements: m,
      onInputElementChange: h,
      isNumericMode: _
    }), (S, $) => (g(), C(l(se), A(S.$attrs, {
      ref: l(c),
      dir: l(f),
      "data-complete": x.value ? "" : void 0,
      "data-disabled": l(u) ? "" : void 0
    }), {
      default: y(() => [w(S.$slots, "default", { modelValue: l(p) }), N(Ta, {
        id: S.id,
        as: "input",
        feature: "focusable",
        tabindex: "-1",
        value: v.value.join(""),
        name: S.name ?? "",
        disabled: l(u),
        required: S.required,
        onFocus: $[0] || ($[0] = (D) => {
          var B, k;
          return (k = (B = Array.from(m.value)) == null ? void 0 : B[0]) == null ? void 0 : k.focus();
        })
      }, null, 8, [
        "id",
        "value",
        "name",
        "disabled",
        "required"
      ])]),
      _: 3
    }, 16, [
      "dir",
      "data-complete",
      "data-disabled"
    ]));
  }
}), YA = GA, XA = /* @__PURE__ */ b({
  __name: "PinInputInput",
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = WA(), a = E(() => Array.from(n.inputElements.value)), o = E(() => n.currentModelValue.value[t.index]), r = E(() => t.disabled || n.disabled.value), s = E(() => n.otp.value), i = E(() => n.mask.value), { primitiveElement: u, currentElement: d } = Kt();
    function c(B) {
      var I;
      const k = B.target;
      if ((((I = B.data) == null ? void 0 : I.length) ?? 0) > 1) {
        S(k.value);
        return;
      }
      if (n.isNumericMode.value && !/^\d*$/.test(k.value)) {
        k.value = k.value.replace(/\D/g, "");
        return;
      }
      k.value = B.data || k.value.slice(-1), D(t.index, k.value);
      const M = a.value[t.index + 1];
      M && M.focus();
    }
    function f() {
      const B = d.value;
      he(() => {
        B && !B.value && (B.placeholder = n.placeholder.value);
      });
    }
    function p(B) {
      Mr(B, gt(), void 0, {
        itemsArray: a.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: "horizontal",
        dir: n.dir.value
      });
    }
    function v(B) {
      if (B.preventDefault(), B.target.value) D(t.index, "");
      else {
        const I = a.value[t.index - 1];
        I && (I.focus(), D(t.index - 1, ""));
      }
    }
    function m(B) {
      B.key === "Delete" && (B.preventDefault(), D(t.index, ""));
    }
    function h(B) {
      const k = B.target;
      k.setSelectionRange(1, 1), k.value || (k.placeholder = ""), setTimeout(() => {
        k.value || (k.placeholder = "");
      });
    }
    function _(B) {
      f();
    }
    function x(B) {
      B.preventDefault();
      const k = B.clipboardData;
      if (!k) return;
      const M = k.getData("text");
      S(M);
    }
    function S(B) {
      var T;
      const k = [...n.currentModelValue.value], M = B.length >= a.value.length ? 0 : t.index, I = Math.min(M + B.length, a.value.length);
      for (let P = M; P < I; P++) {
        const q = a.value[P], R = B[P - M];
        n.isNumericMode.value && !/^\d*$/.test(R) || (k[P] = R, q.focus());
      }
      n.modelValue.value = k, (T = a.value[I]) == null || T.focus();
    }
    function $(B) {
      let k = B.length - 1;
      for (; k >= 0 && B[k] === ""; )
        B.pop(), k--;
      return B;
    }
    function D(B, k) {
      const M = [...n.currentModelValue.value];
      if (n.isNumericMode.value) {
        const I = +k;
        k === "" || isNaN(I) ? delete M[B] : M[B] = I;
      } else M[B] = k;
      n.modelValue.value = $(M);
    }
    return ce(o, () => {
      o.value || f();
    }), be(() => {
      n.onInputElementChange(d.value);
    }), Ze(() => {
      var B;
      (B = n.inputElements) == null || B.value.delete(d.value);
    }), (B, k) => (g(), C(l(se), {
      ref_key: "primitiveElement",
      ref: u,
      autocapitalize: "none",
      as: B.as,
      "as-child": B.asChild,
      autocomplete: s.value ? "one-time-code" : "false",
      type: i.value ? "password" : "text",
      inputmode: l(n).isNumericMode.value ? "numeric" : "text",
      pattern: l(n).isNumericMode.value ? "[0-9]*" : void 0,
      placeholder: l(n).placeholder.value,
      value: o.value,
      disabled: r.value,
      "data-disabled": r.value ? "" : void 0,
      "data-complete": l(n).isCompleted.value ? "" : void 0,
      "aria-label": `pin input ${B.index + 1} of ${a.value.length}`,
      onInput: k[0] || (k[0] = (M) => c(M)),
      onKeydown: [
        Qe(p, [
          "left",
          "right",
          "up",
          "down",
          "home",
          "end"
        ]),
        Qe(v, ["backspace"]),
        Qe(m, ["delete"])
      ],
      onFocus: h,
      onBlur: _,
      onPaste: x
    }, {
      default: y(() => [w(B.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "autocomplete",
      "type",
      "inputmode",
      "pattern",
      "placeholder",
      "value",
      "disabled",
      "data-disabled",
      "data-complete",
      "aria-label"
    ]));
  }
}), JA = XA;
const ZA = "radio.select";
function QA(e, t, n) {
  cu(ZA, n, {
    originalEvent: e,
    value: t
  });
}
var eI = /* @__PURE__ */ b({
  __name: "Radio",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:checked", "select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = rt(n, "checked", a, { passive: n.checked === void 0 }), { value: r } = Be(n), { forwardRef: s, currentElement: i } = le(), u = ro(i), d = E(() => {
      var f;
      return n.id && i.value ? ((f = document.querySelector(`[for="${n.id}"]`)) == null ? void 0 : f.innerText) ?? n.value : void 0;
    });
    function c(f) {
      n.disabled || QA(f, n.value, (p) => {
        a("select", p), !(p != null && p.defaultPrevented) && (o.value = !0, u.value && p.stopPropagation());
      });
    }
    return (f, p) => (g(), C(l(se), A(f.$attrs, {
      id: f.id,
      ref: l(s),
      role: "radio",
      type: f.as === "button" ? "button" : void 0,
      as: f.as,
      "aria-checked": l(o),
      "aria-label": d.value,
      "as-child": f.asChild,
      disabled: f.disabled ? "" : void 0,
      "data-state": l(o) ? "checked" : "unchecked",
      "data-disabled": f.disabled ? "" : void 0,
      value: l(r),
      required: f.required,
      name: f.name,
      onClick: We(c, ["stop"])
    }), {
      default: y(() => [w(f.$slots, "default", { checked: l(o) }), l(u) && f.name ? (g(), C(l(Ta), {
        key: 0,
        type: "radio",
        tabindex: "-1",
        value: l(r),
        checked: !!l(o),
        name: f.name,
        disabled: f.disabled,
        required: f.required
      }, null, 8, [
        "value",
        "checked",
        "name",
        "disabled",
        "required"
      ])) : Pe("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "as",
      "aria-checked",
      "aria-label",
      "as-child",
      "disabled",
      "data-state",
      "data-disabled",
      "value",
      "required",
      "name"
    ]));
  }
}), tI = eI;
const [nI, aI] = He("RadioGroupRoot");
var oI = /* @__PURE__ */ b({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = le(), s = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { disabled: i, loop: u, orientation: d, name: c, required: f, dir: p } = Be(n), v = tn(p), m = ro(r);
    return aI({
      modelValue: s,
      changeModelValue: (h) => {
        s.value = h;
      },
      disabled: i,
      loop: u,
      orientation: d,
      name: c == null ? void 0 : c.value,
      required: f
    }), (h, _) => (g(), C(l(vu), {
      "as-child": "",
      orientation: l(d),
      dir: l(v),
      loop: l(u)
    }, {
      default: y(() => [N(l(se), {
        ref: l(o),
        role: "radiogroup",
        "data-disabled": l(i) ? "" : void 0,
        "as-child": h.asChild,
        as: h.as,
        "aria-orientation": l(d),
        "aria-required": l(f),
        dir: l(v)
      }, {
        default: y(() => [w(h.$slots, "default", { modelValue: l(s) }), l(m) && l(c) ? (g(), C(l(Ta), {
          key: 0,
          required: l(f),
          disabled: l(i),
          value: l(s),
          name: l(c)
        }, null, 8, [
          "required",
          "disabled",
          "value",
          "name"
        ])) : Pe("v-if", !0)]),
        _: 3
      }, 8, [
        "data-disabled",
        "as-child",
        "as",
        "aria-orientation",
        "aria-required",
        "dir"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), rI = oI;
const [sI, lI] = He("RadioGroupItem");
var iI = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = le(), s = nI(), i = E(() => s.disabled.value || n.disabled), u = E(() => s.required.value || n.required), d = E(() => {
      var v;
      return ra((v = s.modelValue) == null ? void 0 : v.value, n.value);
    });
    lI({
      disabled: i,
      checked: d
    });
    const c = O(!1), f = [
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ];
    on("keydown", (v) => {
      f.includes(v.key) && (c.value = !0);
    }), on("keyup", () => {
      c.value = !1;
    });
    function p() {
      setTimeout(() => {
        var v;
        c.value && ((v = r.value) == null || v.click());
      }, 0);
    }
    return (v, m) => (g(), C(l(mu), {
      checked: d.value,
      disabled: i.value,
      "as-child": "",
      focusable: !i.value,
      active: d.value
    }, {
      default: y(() => [N(tI, A({
        ...v.$attrs,
        ...n
      }, {
        ref: l(o),
        checked: d.value,
        required: u.value,
        disabled: i.value,
        "onUpdate:checked": m[0] || (m[0] = (h) => l(s).changeModelValue(v.value)),
        onSelect: m[1] || (m[1] = (h) => a("select", h)),
        onKeydown: m[2] || (m[2] = Qe(We(() => {
        }, ["prevent"]), ["enter"])),
        onFocus: p
      }), {
        default: y(() => [w(v.$slots, "default", {
          checked: d.value,
          required: u.value,
          disabled: i.value
        })]),
        _: 3
      }, 16, [
        "checked",
        "required",
        "disabled"
      ])]),
      _: 3
    }, 8, [
      "checked",
      "disabled",
      "focusable",
      "active"
    ]));
  }
}), uI = iI, dI = /* @__PURE__ */ b({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = le(), n = sI();
    return (a, o) => (g(), C(l(nn), { present: a.forceMount || l(n).checked.value }, {
      default: y(() => [N(l(se), A({
        ref: l(t),
        "data-state": l(n).checked.value ? "checked" : "unchecked",
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [w(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), cI = dI;
const [Tn, fI] = He("ScrollAreaRoot");
var pI = /* @__PURE__ */ b({
  __name: "ScrollAreaRoot",
  props: {
    type: {
      type: String,
      required: !1,
      default: "hover"
    },
    dir: {
      type: String,
      required: !1
    },
    scrollHideDelay: {
      type: Number,
      required: !1,
      default: 600
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = O(0), o = O(0), r = O(), s = O(), i = O(), u = O(), d = O(!1), c = O(!1), { type: f, dir: p, scrollHideDelay: v } = Be(n), m = tn(p);
    function h() {
      var $;
      ($ = r.value) == null || $.scrollTo({ top: 0 });
    }
    function _() {
      var $;
      ($ = r.value) == null || $.scrollTo({
        top: 0,
        left: 0
      });
    }
    t({
      viewport: r,
      scrollTop: h,
      scrollTopLeft: _
    });
    const { forwardRef: x, currentElement: S } = le();
    return fI({
      type: f,
      dir: m,
      scrollHideDelay: v,
      scrollArea: S,
      viewport: r,
      onViewportChange: ($) => {
        r.value = $ || void 0;
      },
      content: s,
      onContentChange: ($) => {
        s.value = $;
      },
      scrollbarX: i,
      scrollbarXEnabled: d,
      scrollbarY: u,
      scrollbarYEnabled: c,
      onScrollbarXChange: ($) => {
        i.value = $ || void 0;
      },
      onScrollbarYChange: ($) => {
        u.value = $ || void 0;
      },
      onScrollbarXEnabledChange: ($) => {
        d.value = $;
      },
      onScrollbarYEnabledChange: ($) => {
        c.value = $;
      },
      onCornerWidthChange: ($) => {
        a.value = $;
      },
      onCornerHeightChange: ($) => {
        o.value = $;
      }
    }), ($, D) => (g(), C(l(se), {
      ref: l(x),
      "as-child": n.asChild,
      as: $.as,
      dir: l(m),
      style: vt({
        position: "relative",
        "--reka-scroll-area-corner-width": `${a.value}px`,
        "--reka-scroll-area-corner-height": `${o.value}px`
      })
    }, {
      default: y(() => [w($.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "dir",
      "style"
    ]));
  }
}), vI = pI, mI = /* @__PURE__ */ b({
  __name: "ScrollAreaCornerImpl",
  setup(e) {
    const t = Tn(), n = O(0), a = O(0), o = E(() => !!n.value && !!a.value);
    function r() {
      var u;
      const i = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;
      t.onCornerHeightChange(i), a.value = i;
    }
    function s() {
      var u;
      const i = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;
      t.onCornerWidthChange(i), n.value = i;
    }
    return sa(t.scrollbarX.value, r), sa(t.scrollbarY.value, s), ce(() => t.scrollbarX.value, r), ce(() => t.scrollbarY.value, s), (i, u) => {
      var d;
      return o.value ? (g(), C(l(se), A({
        key: 0,
        style: {
          width: `${n.value}px`,
          height: `${a.value}px`,
          position: "absolute",
          right: l(t).dir.value === "ltr" ? 0 : void 0,
          left: l(t).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, (d = i.$parent) == null ? void 0 : d.$props), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16, ["style"])) : Pe("v-if", !0);
    };
  }
}), hI = mI, gI = /* @__PURE__ */ b({
  __name: "ScrollAreaCorner",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = le(), a = Tn(), o = E(() => !!a.scrollbarX.value && !!a.scrollbarY.value), r = E(() => a.type.value !== "scroll" && o.value);
    return (s, i) => r.value ? (g(), C(hI, A({ key: 0 }, t, { ref: l(n) }), {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 16)) : Pe("v-if", !0);
  }
}), yI = gI;
function d0(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function wu(e) {
  const t = c0(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, a = (e.scrollbar.size - n) * t;
  return Math.max(a, 18);
}
function c0(e, t) {
  const n = e / t;
  return Number.isNaN(n) ? 0 : n;
}
function bI(e, t = () => {
}) {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, a = 0;
  return function o() {
    const r = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, s = n.left !== r.left, i = n.top !== r.top;
    (s || i) && t(), n = r, a = window.requestAnimationFrame(o);
  }(), () => window.cancelAnimationFrame(a);
}
function $m(e, t, n = "ltr") {
  const a = wu(t), o = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, r = t.scrollbar.size - o, s = t.content - t.viewport, i = r - a, u = n === "ltr" ? [0, s] : [s * -1, 0], d = pb(e, u[0], u[1]);
  return d0([0, s], [0, i])(d);
}
function bl(e) {
  return e ? Number.parseInt(e, 10) : 0;
}
function _I(e, t, n, a = "ltr") {
  const o = wu(n), r = o / 2, s = t || r, i = o - s, u = n.scrollbar.paddingStart + s, d = n.scrollbar.size - n.scrollbar.paddingEnd - i, c = n.content - n.viewport, f = a === "ltr" ? [0, c] : [c * -1, 0];
  return d0([u, d], f)(e);
}
function Bm(e, t) {
  return e > 0 && e < t;
}
var wI = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarX",
  setup(e) {
    const t = Tn(), n = Cu(), { forwardRef: a, currentElement: o } = le();
    be(() => {
      o.value && t.onScrollbarXChange(o.value);
    });
    const r = E(() => n.sizes.value);
    return (s, i) => (g(), C(p0, {
      ref: l(a),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: vt({
        bottom: 0,
        left: l(t).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
        right: l(t).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
        "--reka-scroll-area-thumb-width": r.value ? `${l(wu)(r.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.x))
    }, {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), xI = wI, CI = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarY",
  setup(e) {
    const t = Tn(), n = Cu(), { forwardRef: a, currentElement: o } = le();
    be(() => {
      o.value && t.onScrollbarYChange(o.value);
    });
    const r = E(() => n.sizes.value);
    return (s, i) => (g(), C(p0, {
      ref: l(a),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: vt({
        top: 0,
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--reka-scroll-area-corner-height)",
        "--reka-scroll-area-thumb-height": r.value ? `${l(wu)(r.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.y))
    }, {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), SI = CI, $I = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarAuto",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Tn(), n = xu(), { forwardRef: a } = le(), o = O(!1), r = Xf(() => {
      if (t.viewport.value) {
        const s = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        o.value = n.isHorizontal.value ? s : i;
      }
    }, 10);
    return be(() => r()), sa(t.viewport, r), sa(t.content, r), (s, i) => (g(), C(l(nn), { present: s.forceMount || o.value }, {
      default: y(() => [N(hp, A(s.$attrs, {
        ref: l(a),
        "data-state": o.value ? "visible" : "hidden"
      }), {
        default: y(() => [w(s.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), f0 = $I, BI = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Tn(), { forwardRef: n } = le();
    let a;
    const o = O(!1);
    function r() {
      window.clearTimeout(a), o.value = !0;
    }
    function s() {
      a = window.setTimeout(() => {
        o.value = !1;
      }, t.scrollHideDelay.value);
    }
    return be(() => {
      const i = t.scrollArea.value;
      i && (i.addEventListener("pointerenter", r), i.addEventListener("pointerleave", s));
    }), Ze(() => {
      const i = t.scrollArea.value;
      i && (window.clearTimeout(a), i.removeEventListener("pointerenter", r), i.removeEventListener("pointerleave", s));
    }), (i, u) => (g(), C(l(nn), { present: i.forceMount || o.value }, {
      default: y(() => [N(f0, A(i.$attrs, {
        ref: l(n),
        "data-state": o.value ? "visible" : "hidden"
      }), {
        default: y(() => [w(i.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), PI = BI, EI = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarScroll",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Tn(), n = xu(), { forwardRef: a } = le(), { state: o, dispatch: r } = Sb("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }), s = E(() => o.value !== "hidden");
    Me((u) => {
      if (o.value === "idle") {
        const d = window.setTimeout(() => r("HIDE"), t.scrollHideDelay.value);
        u(() => {
          window.clearTimeout(d);
        });
      }
    });
    const i = Xf(() => r("SCROLL_END"), 100);
    return Me((u) => {
      const d = t.viewport.value, c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (d) {
        let f = d[c];
        const p = () => {
          const v = d[c];
          f !== v && (r("SCROLL"), i()), f = v;
        };
        d.addEventListener("scroll", p), u(() => {
          d.removeEventListener("scroll", p);
        });
      }
    }), (u, d) => (g(), C(l(nn), { present: u.forceMount || s.value }, {
      default: y(() => [N(hp, A(u.$attrs, {
        ref: l(a),
        "data-state": s.value ? "visible" : "hidden"
      }), {
        default: y(() => [w(u.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), DI = EI;
const [xu, MI] = He("ScrollAreaScrollbar");
var kI = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = le(), a = Tn(), o = E(() => t.orientation === "horizontal");
    ce(o, () => {
      o.value ? a.onScrollbarXEnabledChange(!0) : a.onScrollbarYEnabledChange(!0);
    }, { immediate: !0 }), Ze(() => {
      a.onScrollbarXEnabledChange(!1), a.onScrollbarYEnabledChange(!1);
    });
    const { orientation: r, forceMount: s, asChild: i, as: u } = Be(t);
    return MI({
      orientation: r,
      forceMount: s,
      isHorizontal: o,
      as: u,
      asChild: i
    }), (d, c) => l(a).type.value === "hover" ? (g(), C(PI, A({ key: 0 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "scroll" ? (g(), C(DI, A({ key: 1 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "auto" ? (g(), C(f0, A({ key: 2 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "always" ? (g(), C(hp, A({ key: 3 }, d.$attrs, {
      ref: l(n),
      "data-state": "visible"
    }), {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 16)) : Pe("v-if", !0);
  }
}), OI = kI;
const [Cu, TI] = He("ScrollAreaScrollbarVisible");
var AI = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarVisible",
  setup(e) {
    const t = Tn(), n = xu(), { forwardRef: a } = le(), o = O({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    }), r = E(() => {
      const x = c0(o.value.viewport, o.value.content);
      return x > 0 && x < 1;
    }), s = O(), i = O(0);
    function u(x, S) {
      if (v.value) {
        const $ = t.viewport.value.scrollLeft + x.deltaY;
        t.viewport.value.scrollLeft = $, Bm($, S) && x.preventDefault();
      } else {
        const $ = t.viewport.value.scrollTop + x.deltaY;
        t.viewport.value.scrollTop = $, Bm($, S) && x.preventDefault();
      }
    }
    function d(x, S) {
      v.value ? i.value = S.x : i.value = S.y;
    }
    function c(x) {
      i.value = 0;
    }
    function f(x) {
      o.value = x;
    }
    function p(x, S) {
      return _I(x, i.value, o.value, S);
    }
    const v = E(() => n.isHorizontal.value);
    function m(x) {
      v.value ? t.viewport.value.scrollLeft = p(x, t.dir.value) : t.viewport.value.scrollTop = p(x);
    }
    function h() {
      if (v.value) {
        if (t.viewport.value && s.value) {
          const x = t.viewport.value.scrollLeft, S = $m(x, o.value, t.dir.value);
          s.value.style.transform = `translate3d(${S}px, 0, 0)`;
        }
      } else if (t.viewport.value && s.value) {
        const x = t.viewport.value.scrollTop, S = $m(x, o.value);
        s.value.style.transform = `translate3d(0, ${S}px, 0)`;
      }
    }
    function _(x) {
      s.value = x;
    }
    return TI({
      sizes: o,
      hasThumb: r,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: c,
      handleSizeChange: f,
      onThumbPositionChange: h,
      onThumbChange: _,
      onDragScroll: m
    }), (x, S) => v.value ? (g(), C(xI, A({ key: 0 }, x.$attrs, { ref: l(a) }), {
      default: y(() => [w(x.$slots, "default")]),
      _: 3
    }, 16)) : (g(), C(SI, A({ key: 1 }, x.$attrs, { ref: l(a) }), {
      default: y(() => [w(x.$slots, "default")]),
      _: 3
    }, 16));
  }
}), hp = AI, II = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarImpl",
  props: { isHorizontal: {
    type: Boolean,
    required: !0
  } },
  emits: [
    "onDragScroll",
    "onWheelScroll",
    "onThumbPointerDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = Tn(), r = Cu(), s = xu(), { forwardRef: i, currentElement: u } = le(), d = O(""), c = O();
    function f(x) {
      var S, $;
      if (c.value) {
        const D = x.clientX - ((S = c.value) == null ? void 0 : S.left), B = x.clientY - (($ = c.value) == null ? void 0 : $.top);
        a("onDragScroll", {
          x: D,
          y: B
        });
      }
    }
    function p(x) {
      x.button === 0 && (x.target.setPointerCapture(x.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", o.viewport && (o.viewport.value.style.scrollBehavior = "auto"), f(x));
    }
    function v(x) {
      f(x);
    }
    function m(x) {
      const S = x.target;
      S.hasPointerCapture(x.pointerId) && S.releasePointerCapture(x.pointerId), document.body.style.webkitUserSelect = d.value, o.viewport && (o.viewport.value.style.scrollBehavior = ""), c.value = void 0;
    }
    function h(x) {
      var B;
      const S = x.target, $ = (B = u.value) == null ? void 0 : B.contains(S), D = r.sizes.value.content - r.sizes.value.viewport;
      $ && r.handleWheelScroll(x, D);
    }
    be(() => {
      document.addEventListener("wheel", h, { passive: !1 });
    }), Ze(() => {
      document.removeEventListener("wheel", h);
    });
    function _() {
      var x, S, $, D, B;
      u.value && (n.isHorizontal ? r.handleSizeChange({
        content: ((x = o.viewport.value) == null ? void 0 : x.scrollWidth) ?? 0,
        viewport: ((S = o.viewport.value) == null ? void 0 : S.offsetWidth) ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: bl(getComputedStyle(u.value).paddingLeft),
          paddingEnd: bl(getComputedStyle(u.value).paddingRight)
        }
      }) : r.handleSizeChange({
        content: (($ = o.viewport.value) == null ? void 0 : $.scrollHeight) ?? 0,
        viewport: ((D = o.viewport.value) == null ? void 0 : D.offsetHeight) ?? 0,
        scrollbar: {
          size: ((B = u.value) == null ? void 0 : B.clientHeight) ?? 0,
          paddingStart: bl(getComputedStyle(u.value).paddingTop),
          paddingEnd: bl(getComputedStyle(u.value).paddingBottom)
        }
      }), r.onThumbPositionChange());
    }
    return sa(u, _), sa(o.content, _), (x, S) => (g(), C(l(se), {
      ref: l(i),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: l(s).as.value,
      "as-child": l(s).asChild.value,
      onPointerdown: p,
      onPointermove: v,
      onPointerup: m
    }, {
      default: y(() => [w(x.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), p0 = II, RI = /* @__PURE__ */ b({
  __name: "ScrollAreaThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Tn(), a = Cu();
    function o(p) {
      const m = p.target.getBoundingClientRect(), h = p.clientX - m.left, _ = p.clientY - m.top;
      a.handleThumbDown(p, {
        x: h,
        y: _
      });
    }
    function r(p) {
      a.handleThumbUp(p);
    }
    const { forwardRef: s, currentElement: i } = le(), u = O(), d = E(() => n.viewport.value);
    function c() {
      if (!u.value) {
        const p = bI(d.value, a.onThumbPositionChange);
        u.value = p, a.onThumbPositionChange();
      }
    }
    const f = E(() => a.sizes.value);
    return EE(f, () => {
      a.onThumbChange(i.value), d.value && (a.onThumbPositionChange(), d.value.addEventListener("scroll", c));
    }), Ze(() => {
      var p;
      d.value.removeEventListener("scroll", c), (p = n.viewport.value) == null || p.removeEventListener("scroll", c);
    }), (p, v) => (g(), C(l(se), {
      ref: l(s),
      "data-state": l(a).hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--reka-scroll-area-thumb-width)",
        height: "var(--reka-scroll-area-thumb-height)"
      },
      "as-child": t.asChild,
      as: p.as,
      onPointerdown: o,
      onPointerup: r
    }, {
      default: y(() => [w(p.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "as-child",
      "as"
    ]));
  }
}), qI = RI, FI = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, { nonce: a } = Be(n), o = sp(a), r = Tn(), s = O();
    be(() => {
      r.onViewportChange(s.value), r.onContentChange(u.value);
    }), t({ viewportElement: s });
    const { forwardRef: i, currentElement: u } = le();
    return (d, c) => (g(), U(Fe, null, [ye("div", A({
      ref_key: "viewportElement",
      ref: s,
      "data-reka-scroll-area-viewport": "",
      style: {
        overflowX: l(r).scrollbarXEnabled.value ? "scroll" : "hidden",
        overflowY: l(r).scrollbarYEnabled.value ? "scroll" : "hidden"
      }
    }, d.$attrs, { tabindex: 0 }), [N(l(se), {
      ref: l(i),
      style: vt({ minWidth: l(r).scrollbarXEnabled.value ? "fit-content" : void 0 }),
      "as-child": n.asChild,
      as: d.as
    }, {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 8, [
      "style",
      "as-child",
      "as"
    ])], 16), N(l(se), {
      as: "style",
      nonce: l(o)
    }, {
      default: y(() => c[0] || (c[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), VI = FI, NI = /* @__PURE__ */ b({
  __name: "BaseSeparator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ["horizontal", "vertical"];
    function a(i) {
      return n.includes(i);
    }
    const o = E(() => a(t.orientation) ? t.orientation : "horizontal"), r = E(() => o.value === "vertical" ? t.orientation : void 0), s = E(() => t.decorative ? { role: "none" } : {
      "aria-orientation": r.value,
      role: "separator"
    });
    return (i, u) => (g(), C(l(se), A({
      as: i.as,
      "as-child": i.asChild,
      "data-orientation": o.value
    }, s.value), {
      default: y(() => [w(i.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-orientation"
    ]));
  }
}), LI = NI, zI = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(LI, ne(oe(t)), {
      default: y(() => [w(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), v0 = zI;
function Ge(e, t = "Assertion failed!") {
  if (!e)
    throw console.error(t), new Error(t);
}
function m0(e, t = document) {
  var a;
  if (!Us) return null;
  if (t instanceof HTMLElement && ((a = t == null ? void 0 : t.dataset) == null ? void 0 : a.panelGroupId) === e) return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function Su(e, t = document) {
  if (!Us) return null;
  const n = t.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return n || null;
}
function h0(e, t, n = document) {
  return Us ? _s(e, n).findIndex((r) => r.getAttribute("data-panel-resize-handle-id") === t) ?? null : null;
}
function _s(e, t = document) {
  return Us ? Array.from(t.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function HI(e, t, n, a = document) {
  var d, c;
  const o = Su(t, a), r = _s(e, a), s = o ? r.indexOf(o) : -1, i = ((d = n[s]) == null ? void 0 : d.id) ?? null, u = ((c = n[s + 1]) == null ? void 0 : c.id) ?? null;
  return [i, u];
}
function g0(e) {
  return e.type === "keydown";
}
function y0(e) {
  return e.type.startsWith("mouse");
}
function b0(e) {
  return e.type.startsWith("touch");
}
function $u(e) {
  if (y0(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (b0(e)) {
    const t = e.touches[0];
    if (t && t.clientX && t.clientY) return {
      x: t.clientX,
      y: t.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function _0(e, t) {
  const n = e === "horizontal", { x: a, y: o } = $u(t);
  return n ? a : o;
}
function UI(e, t, n, a, o) {
  const r = n === "horizontal", s = Su(t, o);
  Ge(s);
  const i = s.getAttribute("data-panel-group-id");
  Ge(i);
  const { initialCursorPosition: u } = a, d = _0(n, e), c = m0(i, o);
  Ge(c);
  const f = c.getBoundingClientRect(), p = r ? f.width : f.height;
  return (d - u) / p * 100;
}
function jI(e, t, n, a, o, r) {
  if (g0(e)) {
    const s = n === "horizontal";
    let i = 0;
    e.shiftKey ? i = 100 : i = o ?? 10;
    let u = 0;
    switch (e.key) {
      case "ArrowDown":
        u = s ? 0 : i;
        break;
      case "ArrowLeft":
        u = s ? -i : 0;
        break;
      case "ArrowRight":
        u = s ? i : 0;
        break;
      case "ArrowUp":
        u = s ? 0 : -i;
        break;
      case "End":
        u = 100;
        break;
      case "Home":
        u = -100;
        break;
    }
    return u;
  } else
    return a == null ? 0 : UI(e, t, n, a, r);
}
function WI({ layout: e, panelsArray: t, pivotIndices: n }) {
  let a = 0, o = 100, r = 0, s = 0;
  const i = n[0];
  Ge(i != null), t.forEach((f, p) => {
    const { constraints: v } = f, { maxSize: m = 100, minSize: h = 0 } = v;
    p === i ? (a = h, o = m) : (r += h, s += m);
  });
  const u = Math.min(o, 100 - r), d = Math.max(a, 100 - s), c = e[i];
  return {
    valueMax: u,
    valueMin: d,
    valueNow: c
  };
}
function KI({ panelDataArray: e }) {
  const t = Array.from({ length: e.length }), n = e.map((r) => r.constraints);
  let a = 0, o = 100;
  for (let r = 0; r < e.length; r++) {
    const s = n[r];
    Ge(s);
    const { defaultSize: i } = s;
    i != null && (a++, t[r] = i, o -= i);
  }
  for (let r = 0; r < e.length; r++) {
    const s = n[r];
    Ge(s);
    const { defaultSize: i } = s;
    if (i != null) continue;
    const u = e.length - a, d = o / u;
    a++, t[r] = d, o -= d;
  }
  return t;
}
function Lr(e, t, n) {
  t.forEach((a, o) => {
    const r = e[o];
    Ge(r);
    const { callbacks: s, constraints: i, id: u } = r, { collapsedSize: d = 0, collapsible: c } = i, f = n[u];
    if (f == null || a !== f) {
      n[u] = a;
      const { onCollapse: p, onExpand: v, onResize: m } = s;
      m && m(a, f), c && (p || v) && (v && (f == null || f === d) && a !== d && v(), p && (f == null || f !== d) && a === d && p());
    }
  });
}
function GI(e, t = 10) {
  let n = null;
  return (...o) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...o);
    }, t);
  };
}
const gp = 10;
function ws(e, t, n = gp) {
  e = Number.parseFloat(e.toFixed(n)), t = Number.parseFloat(t.toFixed(n));
  const a = e - t;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function yn(e, t, n) {
  return ws(e, t, n) === 0;
}
function Ko({ panelConstraints: e, panelIndex: t, size: n }) {
  const a = e[t];
  Ge(a != null);
  const { collapsedSize: o = 0, collapsible: r, maxSize: s = 100, minSize: i = 0 } = a;
  if (ws(n, i) < 0) if (r) {
    const u = (o + i) / 2;
    ws(n, u) < 0 ? n = o : n = i;
  } else n = i;
  return n = Math.min(s, n), n = Number.parseFloat(n.toFixed(gp)), n;
}
function _l(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function Jr({ delta: e, layout: t, panelConstraints: n, pivotIndices: a, trigger: o }) {
  if (yn(e, 0)) return t;
  const r = [...t], [s, i] = a;
  Ge(s != null), Ge(i != null);
  let u = 0;
  if (o === "keyboard") {
    {
      const c = e < 0 ? i : s, f = n[c];
      if (Ge(f), f.collapsible) {
        const p = t[c];
        Ge(p != null);
        const v = n[c];
        Ge(v);
        const { collapsedSize: m = 0, minSize: h = 0 } = v;
        if (yn(p, m)) {
          const _ = h - p;
          ws(_, Math.abs(e)) > 0 && (e = e < 0 ? 0 - _ : _);
        }
      }
    }
    {
      const c = e < 0 ? s : i, f = n[c];
      Ge(f);
      const { collapsible: p } = f;
      if (p) {
        const v = t[c];
        Ge(v != null);
        const m = n[c];
        Ge(m);
        const { collapsedSize: h = 0, minSize: _ = 0 } = m;
        if (yn(v, _)) {
          const x = v - h;
          ws(x, Math.abs(e)) > 0 && (e = e < 0 ? 0 - x : x);
        }
      }
    }
  }
  {
    const c = e < 0 ? 1 : -1;
    let f = e < 0 ? i : s, p = 0;
    for (; ; ) {
      const m = t[f];
      Ge(m != null);
      const _ = Ko({
        panelConstraints: n,
        panelIndex: f,
        size: 100
      }) - m;
      if (p += _, f += c, f < 0 || f >= n.length) break;
    }
    const v = Math.min(Math.abs(e), Math.abs(p));
    e = e < 0 ? 0 - v : v;
  }
  {
    let f = e < 0 ? s : i;
    for (; f >= 0 && f < n.length; ) {
      const p = Math.abs(e) - Math.abs(u), v = t[f];
      Ge(v != null);
      const m = v - p, h = Ko({
        panelConstraints: n,
        panelIndex: f,
        size: m
      });
      if (!yn(v, h) && (u += v - h, r[f] = h, u.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? f-- : f++;
    }
  }
  if (yn(u, 0)) return t;
  {
    const c = e < 0 ? i : s, f = t[c];
    Ge(f != null);
    const p = f + u, v = Ko({
      panelConstraints: n,
      panelIndex: c,
      size: p
    });
    if (r[c] = v, !yn(v, p)) {
      let m = p - v, _ = e < 0 ? i : s;
      for (; _ >= 0 && _ < n.length; ) {
        const x = r[_];
        Ge(x != null);
        const S = x + m, $ = Ko({
          panelConstraints: n,
          panelIndex: _,
          size: S
        });
        if (yn(x, $) || (m -= $ - x, r[_] = $), yn(m, 0)) break;
        e > 0 ? _-- : _++;
      }
    }
  }
  const d = r.reduce((c, f) => f + c, 0);
  return yn(d, 100) ? r : t;
}
function w0(e, t, n) {
  const a = h0(e, t, n);
  return a != null ? [a, a + 1] : [-1, -1];
}
function YI(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function XI(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: Dm(e),
    b: Dm(t)
  };
  let a;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), a = e;
  Ge(a);
  const o = {
    a: Em(Pm(n.a)),
    b: Em(Pm(n.b))
  };
  if (o.a === o.b) {
    const r = a.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let i = r.length;
    for (; i--; ) {
      const u = r[i];
      if (u === s.a) return 1;
      if (u === s.b) return -1;
    }
  }
  return Math.sign(o.a - o.b);
}
const JI = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function ZI(e) {
  const t = getComputedStyle(x0(e)).display;
  return t === "flex" || t === "inline-flex";
}
function QI(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || ZI(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || JI.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function Pm(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (Ge(n), QI(n)) return n;
  }
  return null;
}
function Em(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function Dm(e) {
  const t = [];
  for (; e; )
    t.push(e), e = x0(e);
  return t;
}
function x0(e) {
  var t;
  return e.parentNode instanceof DocumentFragment && ((t = e.parentNode) == null ? void 0 : t.host) || e.parentNode;
}
const C0 = 1, S0 = 2, $0 = 4, B0 = 8;
function e5() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const t5 = e5() === "coarse", Qa = [];
let Bu = !1;
const Wa = /* @__PURE__ */ new Map(), Pu = /* @__PURE__ */ new Map(), xs = /* @__PURE__ */ new Set();
function n5(e, t, n, a, o, r) {
  const { ownerDocument: s } = t, i = {
    direction: n,
    element: t,
    hitAreaMargins: a,
    nonce: o,
    setResizeHandlerState: r
  }, u = Wa.get(s) ?? 0;
  return Wa.set(s, u + 1), xs.add(i), gi(), function() {
    Pu.delete(e), xs.delete(i);
    const c = Wa.get(s) ?? 1;
    Wa.set(s, c - 1), gi(), E0(), c === 1 && Wa.delete(s);
  };
}
function wl(e) {
  const { target: t } = e, { x: n, y: a } = $u(e);
  Bu = !0, yp({
    target: t,
    x: n,
    y: a
  }), gi(), Qa.length > 0 && (bp("down", e), e.preventDefault());
}
function Va(e) {
  const { x: t, y: n } = $u(e);
  if (!Bu) {
    const { target: a } = e;
    yp({
      target: a,
      x: t,
      y: n
    });
  }
  bp("move", e), P0(), Qa.length > 0 && e.preventDefault();
}
function Na(e) {
  const { target: t } = e, { x: n, y: a } = $u(e);
  Pu.clear(), Bu = !1, Qa.length > 0 && e.preventDefault(), bp("up", e), yp({
    target: t,
    x: n,
    y: a
  }), P0(), gi();
}
function yp({ target: e, x: t, y: n }) {
  Qa.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), xs.forEach((o) => {
    const { element: r, hitAreaMargins: s } = o, i = r.getBoundingClientRect(), { bottom: u, left: d, right: c, top: f } = i, p = t5 ? s.coarse : s.fine;
    if (t >= d - p && t <= c + p && n >= f - p && n <= u + p) {
      if (a !== null && r !== a && !r.contains(a) && !a.contains(r) && XI(a, r) > 0) {
        let m = a, h = !1;
        for (; m && !m.contains(r); ) {
          if (YI(m.getBoundingClientRect(), i)) {
            h = !0;
            break;
          }
          m = m.parentElement;
        }
        if (h) return;
      }
      Qa.push(o);
    }
  });
}
function Cd(e, t) {
  Pu.set(e, t);
}
function P0() {
  let e = !1, t = !1, n;
  Qa.forEach((o) => {
    const { direction: r, nonce: s } = o;
    r.value === "horizontal" ? e = !0 : t = !0, n = s.value;
  });
  let a = 0;
  Pu.forEach((o) => {
    a |= o;
  }), e && t ? Sd("intersection", a, n) : e ? Sd("horizontal", a, n) : t ? Sd("vertical", a, n) : E0();
}
function gi() {
  Wa.forEach((e, t) => {
    const { body: n } = t;
    n.removeEventListener("contextmenu", Na), n.removeEventListener("mousedown", wl), n.removeEventListener("mouseleave", Va), n.removeEventListener("mousemove", Va), n.removeEventListener("touchmove", Va), n.removeEventListener("touchstart", wl);
  }), window.removeEventListener("mouseup", Na), window.removeEventListener("touchcancel", Na), window.removeEventListener("touchend", Na), xs.size > 0 && (Bu ? (Qa.length > 0 && Wa.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("contextmenu", Na), n.addEventListener("mouseleave", Va), n.addEventListener("mousemove", Va), n.addEventListener("touchmove", Va, { passive: !1 }));
  }), window.addEventListener("mouseup", Na), window.addEventListener("touchcancel", Na), window.addEventListener("touchend", Na)) : Wa.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("mousedown", wl), n.addEventListener("mousemove", Va), n.addEventListener("touchmove", Va, { passive: !1 }), n.addEventListener("touchstart", wl));
  }));
}
function bp(e, t) {
  xs.forEach((n) => {
    const { setResizeHandlerState: a } = n, o = Qa.includes(n);
    a(e, o, t);
  });
}
let yc = null, Ka = null;
function a5(e, t) {
  if (t) {
    const n = (t & C0) !== 0, a = (t & S0) !== 0, o = (t & $0) !== 0, r = (t & B0) !== 0;
    if (n) return o ? "se-resize" : r ? "ne-resize" : "e-resize";
    if (a) return o ? "sw-resize" : r ? "nw-resize" : "w-resize";
    if (o) return "s-resize";
    if (r) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function E0() {
  Ka !== null && (document.head.removeChild(Ka), yc = null, Ka = null);
}
function Sd(e, t, n) {
  const a = a5(e, t);
  yc !== a && (yc = a, Ka === null && (Ka = document.createElement("style"), n && (Ka.nonce = n), document.head.appendChild(Ka)), Ka.innerHTML = `*{cursor: ${a}!important;}`);
}
function o5({ defaultSize: e, dragState: t, layout: n, panelData: a, panelIndex: o, precision: r = 3 }) {
  const s = n[o];
  let i;
  return s == null ? i = e !== void 0 ? e.toPrecision(r) : "1" : a.length === 1 ? i = "1" : i = s.toPrecision(r), {
    flexBasis: 0,
    flexGrow: i,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: t !== null ? "none" : void 0
  };
}
function r5({ layout: e, panelConstraints: t }) {
  const n = [...e], a = n.reduce((r, s) => r + s, 0);
  if (n.length !== t.length) throw new Error(`Invalid ${t.length} panel layout: ${n.map((r) => `${r}%`).join(", ")}`);
  if (!yn(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${n.map((r) => `${r}%`).join(", ")}. Layout normalization will be applied.`);
    for (let r = 0; r < t.length; r++) {
      const s = n[r];
      Ge(s != null);
      const i = 100 / a * s;
      n[r] = i;
    }
  }
  let o = 0;
  for (let r = 0; r < t.length; r++) {
    const s = n[r];
    Ge(s != null);
    const i = Ko({
      panelConstraints: t,
      panelIndex: r,
      size: s
    });
    s !== i && (o += s - i, n[r] = i);
  }
  if (!yn(o, 0)) for (let r = 0; r < t.length; r++) {
    const s = n[r];
    Ge(s != null);
    const i = s + o, u = Ko({
      panelConstraints: t,
      panelIndex: r,
      size: i
    });
    if (s !== u && (o -= u - s, n[r] = u, yn(o, 0)))
      break;
  }
  return n;
}
function s5({ eagerValuesRef: e, groupId: t, layout: n, panelDataArray: a, panelGroupElement: o, setLayout: r }) {
  Me((s) => {
    const i = o.value;
    if (!i) return;
    const u = _s(t, i);
    for (let d = 0; d < a.length - 1; d++) {
      const { valueMax: c, valueMin: f, valueNow: p } = WI({
        layout: n.value,
        panelsArray: a,
        pivotIndices: [d, d + 1]
      }), v = u[d];
      if (v != null) {
        const m = a[d];
        Ge(m), v.setAttribute("aria-controls", m.id), v.setAttribute("aria-valuemax", `${Math.round(c)}`), v.setAttribute("aria-valuemin", `${Math.round(f)}`), v.setAttribute("aria-valuenow", p != null ? `${Math.round(p)}` : "");
      }
    }
    s(() => {
      u.forEach((d) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    });
  }), Me((s) => {
    const i = o.value;
    if (!i) return;
    const u = e.value;
    Ge(u);
    const { panelDataArray: d } = u, c = m0(t, i);
    Ge(c != null, `No group found for id "${t}"`);
    const f = _s(t, i);
    Ge(f);
    const p = f.map((v) => {
      const m = v.getAttribute("data-panel-resize-handle-id");
      Ge(m);
      const [h, _] = HI(t, m, d, i);
      if (h == null || _ == null) return () => {
      };
      const x = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const $ = d.findIndex((D) => D.id === h);
              if ($ >= 0) {
                const D = d[$];
                Ge(D);
                const B = n.value[$], { collapsedSize: k = 0, collapsible: M, minSize: I = 0 } = D.constraints;
                if (B != null && M) {
                  const T = Jr({
                    delta: yn(B, k) ? I - k : k - B,
                    layout: n.value,
                    panelConstraints: d.map((P) => P.constraints),
                    pivotIndices: w0(t, m, i),
                    trigger: "keyboard"
                  });
                  n.value !== T && r(T);
                }
              }
              break;
            }
          }
      };
      return v.addEventListener("keydown", x), () => {
        v.removeEventListener("keydown", x);
      };
    });
    s(() => {
      p.forEach((v) => v());
    });
  });
}
function Mm(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function D0(e) {
  return `reka:${e}`;
}
function M0(e) {
  return e.map((t) => {
    const { constraints: n, id: a, idIsFromProps: o, order: r } = t;
    return o ? a : r ? `${r}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function k0(e, t) {
  try {
    const n = D0(e), a = t.getItem(n);
    if (a) {
      const o = JSON.parse(a);
      if (typeof o == "object" && o != null) return o;
    }
  } catch {
  }
  return null;
}
function l5(e, t, n) {
  const a = k0(e, n) ?? {}, o = M0(t);
  return a[o] ?? null;
}
function i5(e, t, n, a, o) {
  const r = D0(e), s = M0(t), i = k0(e, o) ?? {};
  i[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: a
  };
  try {
    o.setItem(r, JSON.stringify(i));
  } catch (u) {
    console.error(u);
  }
}
const u5 = 100, Zr = {
  getItem: (e) => (Mm(Zr), Zr.getItem(e)),
  setItem: (e, t) => {
    Mm(Zr), Zr.setItem(e, t);
  }
}, [O0, d5] = He("PanelGroup");
var c5 = /* @__PURE__ */ b({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => Zr
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = {}, { direction: r } = Be(n), s = yt(n.id, "reka-splitter-group"), i = tn(), { forwardRef: u, currentElement: d } = le(), c = O(null), f = O([]), p = O({}), v = O(/* @__PURE__ */ new Map()), m = O(0), h = E(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: c.value,
      id: s,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), _ = O({
      layout: f.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), x = (j) => f.value = j;
    s5({
      eagerValuesRef: _,
      groupId: s,
      layout: f,
      panelDataArray: _.value.panelDataArray,
      setLayout: x,
      panelGroupElement: d
    }), Me(() => {
      const { panelDataArray: j } = _.value, { autoSaveId: J } = n;
      if (J) {
        if (f.value.length === 0 || f.value.length !== j.length) return;
        let z = o[J];
        z || (z = GI(i5, u5), o[J] = z);
        const Y = [...j], Z = new Map(v.value);
        z(J, Y, Z, f.value, n.storage);
      }
    });
    function S(j, J) {
      const { panelDataArray: z } = _.value, Y = K(z, j);
      return o5({
        defaultSize: J,
        dragState: c.value,
        layout: f.value,
        panelData: z,
        panelIndex: Y
      });
    }
    function $(j) {
      const { panelDataArray: J } = _.value;
      J.push(j), J.sort((z, Y) => {
        const Z = z.order, pe = Y.order;
        return Z == null && pe == null ? 0 : Z == null ? -1 : pe == null ? 1 : Z - pe;
      }), _.value.panelDataArrayChanged = !0;
    }
    ce(() => _.value.panelDataArrayChanged, () => {
      if (_.value.panelDataArrayChanged) {
        _.value.panelDataArrayChanged = !1;
        const { autoSaveId: j, storage: J } = h.value, { layout: z, panelDataArray: Y } = _.value;
        let Z = null;
        if (j) {
          const $e = l5(j, Y, J);
          $e && (v.value = new Map(Object.entries($e.expandToSizes)), Z = $e.layout);
        }
        Z === null && (Z = KI({ panelDataArray: Y }));
        const pe = r5({
          layout: Z,
          panelConstraints: Y.map(($e) => $e.constraints)
        });
        iE(z, pe) || (x(pe), _.value.layout = pe, a("layout", pe), Lr(Y, pe, p.value));
      }
    });
    function D(j) {
      return function(z) {
        z.preventDefault();
        const Y = d.value;
        if (!Y) return () => null;
        const { direction: Z, dragState: pe, id: $e, keyboardResizeBy: Ce } = h.value, { layout: De, panelDataArray: ue } = _.value, { initialLayout: V } = pe ?? {}, te = w0($e, j, Y);
        let H = jI(z, j, Z, pe, Ce, Y);
        if (H === 0) return;
        const re = Z === "horizontal";
        i.value === "rtl" && re && (H = -H);
        const ie = ue.map((we) => we.constraints), L = Jr({
          delta: H,
          layout: V ?? De,
          panelConstraints: ie,
          pivotIndices: te,
          trigger: g0(z) ? "keyboard" : "mouse-or-touch"
        }), _e = !_l(De, L);
        (y0(z) || b0(z)) && m.value !== H && (m.value = H, _e ? Cd(j, 0) : re ? Cd(j, H < 0 ? C0 : S0) : Cd(j, H < 0 ? $0 : B0)), _e && (x(L), _.value.layout = L, a("layout", L), Lr(ue, L, p.value));
      };
    }
    function B(j, J) {
      const { layout: z, panelDataArray: Y } = _.value, Z = Y.map((V) => V.constraints), { panelSize: pe, pivotIndices: $e } = W(Y, j, z);
      Ge(pe != null);
      const De = K(Y, j) === Y.length - 1 ? pe - J : J - pe, ue = Jr({
        delta: De,
        layout: z,
        panelConstraints: Z,
        pivotIndices: $e,
        trigger: "imperative-api"
      });
      _l(z, ue) || (x(ue), _.value.layout = ue, a("layout", ue), Lr(Y, ue, p.value));
    }
    function k(j, J) {
      const { layout: z, panelDataArray: Y } = _.value, Z = K(Y, j);
      Y[Z] = j, _.value.panelDataArrayChanged = !0;
      const { collapsedSize: pe = 0, collapsible: $e } = J, { collapsedSize: Ce = 0, collapsible: De, maxSize: ue = 100, minSize: V = 0 } = j.constraints, { panelSize: te } = W(Y, j, z);
      te !== null && ($e && De && te === pe ? pe !== Ce && B(j, Ce) : te < V ? B(j, V) : te > ue && B(j, ue));
    }
    function M(j, J) {
      const { direction: z } = h.value, { layout: Y } = _.value;
      if (!d.value) return;
      const Z = Su(j, d.value);
      Ge(Z);
      const pe = _0(z, J);
      c.value = {
        dragHandleId: j,
        dragHandleRect: Z.getBoundingClientRect(),
        initialCursorPosition: pe,
        initialLayout: Y
      };
    }
    function I() {
      c.value = null;
    }
    function T(j) {
      const { panelDataArray: J } = _.value, z = K(J, j);
      z >= 0 && (J.splice(z, 1), delete p.value[j.id], _.value.panelDataArrayChanged = !0);
    }
    function P(j) {
      const { layout: J, panelDataArray: z } = _.value;
      if (j.constraints.collapsible) {
        const Y = z.map((Ce) => Ce.constraints), { collapsedSize: Z = 0, panelSize: pe, pivotIndices: $e } = W(z, j, J);
        if (Ge(pe != null, `Panel size not found for panel "${j.id}"`), pe !== Z) {
          v.value.set(j.id, pe);
          const De = K(z, j) === z.length - 1 ? pe - Z : Z - pe, ue = Jr({
            delta: De,
            layout: J,
            panelConstraints: Y,
            pivotIndices: $e,
            trigger: "imperative-api"
          });
          _l(J, ue) || (x(ue), _.value.layout = ue, a("layout", ue), Lr(z, ue, p.value));
        }
      }
    }
    function q(j) {
      const { layout: J, panelDataArray: z } = _.value;
      if (j.constraints.collapsible) {
        const Y = z.map((De) => De.constraints), { collapsedSize: Z = 0, panelSize: pe, minSize: $e = 0, pivotIndices: Ce } = W(z, j, J);
        if (pe === Z) {
          const De = v.value.get(j.id), ue = De != null && De >= $e ? De : $e, te = K(z, j) === z.length - 1 ? pe - ue : ue - pe, H = Jr({
            delta: te,
            layout: J,
            panelConstraints: Y,
            pivotIndices: Ce,
            trigger: "imperative-api"
          });
          _l(J, H) || (x(H), _.value.layout = H, a("layout", H), Lr(z, H, p.value));
        }
      }
    }
    function R(j) {
      const { layout: J, panelDataArray: z } = _.value, { panelSize: Y } = W(z, j, J);
      return Ge(Y != null, `Panel size not found for panel "${j.id}"`), Y;
    }
    function Q(j) {
      const { layout: J, panelDataArray: z } = _.value, { collapsedSize: Y = 0, collapsible: Z, panelSize: pe } = W(z, j, J);
      return Z ? pe === void 0 ? j.constraints.defaultSize === j.constraints.collapsedSize : pe === Y : !1;
    }
    function ee(j) {
      const { layout: J, panelDataArray: z } = _.value, { collapsedSize: Y = 0, collapsible: Z, panelSize: pe } = W(z, j, J);
      return Ge(pe != null, `Panel size not found for panel "${j.id}"`), !Z || pe > Y;
    }
    d5({
      direction: r,
      dragState: c.value,
      groupId: s,
      reevaluatePanelConstraints: k,
      registerPanel: $,
      registerResizeHandle: D,
      resizePanel: B,
      startDragging: M,
      stopDragging: I,
      unregisterPanel: T,
      panelGroupElement: d,
      collapsePanel: P,
      expandPanel: q,
      isPanelCollapsed: Q,
      isPanelExpanded: ee,
      getPanelSize: R,
      getPanelStyle: S
    });
    function K(j, J) {
      return j.findIndex((z) => z === J || z.id === J.id);
    }
    function W(j, J, z) {
      const Y = K(j, J), pe = Y === j.length - 1 ? [Y - 1, Y] : [Y, Y + 1], $e = z[Y];
      return {
        ...J.constraints,
        panelSize: $e,
        pivotIndices: pe
      };
    }
    return (j, J) => (g(), C(l(se), {
      ref: l(u),
      as: j.as,
      "as-child": j.asChild,
      style: vt({
        display: "flex",
        flexDirection: l(r) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": l(r),
      "data-panel-group-id": l(s)
    }, {
      default: y(() => [w(j.$slots, "default", { layout: f.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), f5 = c5, p5 = /* @__PURE__ */ b({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, r = O0();
    if (r === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: s, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: f, groupId: p, reevaluatePanelConstraints: v, registerPanel: m, unregisterPanel: h } = r, _ = yt(a.id, "reka-splitter-panel"), x = E(() => ({
      callbacks: {
        onCollapse: () => o("collapse"),
        onExpand: () => o("expand"),
        onResize: (...I) => o("resize", ...I)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(gp)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: _,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    ce(() => x.value.constraints, (I, T) => {
      (T.collapsedSize !== I.collapsedSize || T.collapsible !== I.collapsible || T.maxSize !== I.maxSize || T.minSize !== I.minSize) && v(x.value, T);
    }, { deep: !0 }), be(() => {
      m(x.value);
    }), Ze(() => {
      h(x.value);
    });
    const S = E(() => d(x.value, a.defaultSize)), $ = E(() => c(x.value)), D = E(() => !$.value);
    function B() {
      s(x.value);
    }
    function k() {
      i(x.value);
    }
    function M(I) {
      f(x.value, I);
    }
    return t({
      collapse: B,
      expand: k,
      getSize() {
        return u(x.value);
      },
      resize: M,
      isCollapsed: $,
      isExpanded: D
    }), (I, T) => (g(), C(l(se), {
      id: l(_),
      style: vt(S.value),
      as: I.as,
      "as-child": I.asChild,
      "data-panel": "",
      "data-panel-collapsible": I.collapsible || void 0,
      "data-panel-group-id": l(p),
      "data-panel-id": l(_),
      "data-panel-size": Number.parseFloat(`${S.value.flexGrow}`).toFixed(1),
      "data-state": I.collapsible ? $.value ? "collapsed" : "expanded" : void 0
    }, {
      default: y(() => [w(I.$slots, "default", {
        isCollapsed: $.value,
        isExpanded: D.value,
        expand: k,
        collapse: B,
        resize: M
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), XU = p5;
function v5({ disabled: e, handleId: t, resizeHandler: n, panelGroupElement: a }) {
  Me((o) => {
    const r = a.value;
    if (e.value || n.value === null || r === null) return;
    const s = Su(t, r);
    if (s == null) return;
    const i = (u) => {
      var d;
      if (!u.defaultPrevented)
        switch (u.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            u.preventDefault(), (d = n.value) == null || d.call(n, u);
            break;
          }
          case "F6": {
            u.preventDefault();
            const c = s.getAttribute("data-panel-group-id");
            Ge(c);
            const f = _s(c, r), p = h0(c, t, r);
            Ge(p !== null);
            const v = u.shiftKey ? p > 0 ? p - 1 : f.length - 1 : p + 1 < f.length ? p + 1 : 0;
            f[v].focus();
            break;
          }
        }
    };
    s.addEventListener("keydown", i), o(() => {
      s.removeEventListener("keydown", i);
    });
  });
}
var m5 = /* @__PURE__ */ b({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = le(), { disabled: s } = Be(n), i = O0();
    if (i === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: u, groupId: d, registerResizeHandle: c, startDragging: f, stopDragging: p, panelGroupElement: v } = i, m = yt(n.id, "reka-splitter-resize-handle"), h = O("inactive"), _ = O(!1), x = O(null), { nonce: S } = Be(n), $ = sp(S);
    return ce(s, () => {
      Us && (s.value ? x.value = null : x.value = c(m));
    }, { immediate: !0 }), Me((D) => {
      var M, I;
      if (s.value || x.value === null) return;
      const B = r.value;
      if (!B) return;
      Ge(B);
      const k = (T, P, q) => {
        var R;
        if (P) switch (T) {
          case "down": {
            h.value = "drag", f(m, q), a("dragging", !0);
            break;
          }
          case "move": {
            h.value !== "drag" && (h.value = "hover"), (R = x.value) == null || R.call(x, q);
            break;
          }
          case "up": {
            h.value = "hover", p(), a("dragging", !1);
            break;
          }
        }
        else h.value = "inactive";
      };
      D(n5(m, B, u, {
        coarse: ((M = n.hitAreaMargins) == null ? void 0 : M.coarse) ?? 15,
        fine: ((I = n.hitAreaMargins) == null ? void 0 : I.fine) ?? 5
      }, $, k));
    }), v5({
      disabled: s,
      resizeHandler: x,
      handleId: m,
      panelGroupElement: v
    }), (D, B) => (g(), C(l(se), {
      id: l(m),
      ref: l(o),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: D.as,
      "as-child": D.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: D.tabindex,
      "data-state": h.value,
      "data-disabled": l(s) ? "" : void 0,
      "data-orientation": l(u),
      "data-panel-group-id": l(d),
      "data-resize-handle-active": h.value === "drag" ? "pointer" : _.value ? "keyboard" : void 0,
      "data-resize-handle-state": h.value,
      "data-panel-resize-handle-enabled": !l(s),
      "data-panel-resize-handle-id": l(m),
      onBlur: B[0] || (B[0] = (k) => _.value = !1),
      onFocus: B[1] || (B[1] = (k) => _.value = !1)
    }, {
      default: y(() => [w(D.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), h5 = m5;
const g5 = {
  "aria-live": "polite",
  "aria-atomic": "true",
  role: "status",
  style: {
    transform: "translateX(-100%)",
    position: "absolute",
    pointerEvents: "none",
    opacity: 0,
    margin: 0
  }
}, [_p, y5] = He("StepperRoot");
var b5 = /* @__PURE__ */ b({
  __name: "StepperRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: 1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    modelValue: {
      type: Number,
      required: !1
    },
    linear: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { dir: r, orientation: s, linear: i } = Be(a), u = tn(r), d = O(/* @__PURE__ */ new Set()), c = rt(a, "modelValue", o, {
      defaultValue: a.defaultValue,
      passive: a.modelValue === void 0
    }), f = E(() => Array.from(d.value)), p = E(() => c.value === 1), v = E(() => c.value === f.value.length), m = E(() => d.value.size);
    function h(I) {
      I > m.value || I < 1 || d.value.size && f.value[I] && f.value[I].getAttribute("disabled") || i.value && I > (c.value ?? 1) + 1 || (c.value = I);
    }
    function _() {
      h((c.value ?? 1) + 1);
    }
    function x() {
      h((c.value ?? 1) - 1);
    }
    function S() {
      return (c.value ?? 1) < m.value;
    }
    function $() {
      return (c.value ?? 1) > 1;
    }
    const D = O(null), B = O(null), k = E(() => D.value ? D.value.getAttribute("disabled") === "" : !0), M = E(() => B.value ? B.value.getAttribute("disabled") === "" : !0);
    return ce(c, async () => {
      await he(() => {
        D.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, B.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), ce(f, async () => {
      await he(() => {
        D.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, B.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), y5({
      modelValue: c,
      changeModelValue: (I) => {
        c.value = I;
      },
      orientation: s,
      dir: u,
      linear: i,
      totalStepperItems: d
    }), t({
      goToStep: h,
      nextStep: _,
      prevStep: x,
      modelValue: c,
      totalSteps: m,
      isNextDisabled: k,
      isPrevDisabled: M,
      isFirstStep: p,
      isLastStep: v,
      hasNext: S,
      hasPrev: $
    }), le(), (I, T) => (g(), C(l(se), {
      role: "group",
      "aria-label": "progress",
      as: I.as,
      "as-child": I.asChild,
      "data-linear": l(i) ? "" : void 0,
      "data-orientation": I.orientation
    }, {
      default: y(() => [w(I.$slots, "default", {
        modelValue: l(c),
        totalSteps: d.value.size,
        isNextDisabled: k.value,
        isPrevDisabled: M.value,
        isFirstStep: p.value,
        isLastStep: v.value,
        goToStep: h,
        nextStep: _,
        prevStep: x,
        hasNext: S,
        hasPrev: $
      }), ye("div", g5, " Step " + Ve(l(c)) + " of " + Ve(d.value.size), 1)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-linear",
      "data-orientation"
    ]));
  }
}), _5 = b5;
const [Xs, w5] = He("StepperItem");
var x5 = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    completed: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { disabled: n, step: a, completed: o } = Be(t), { forwardRef: r } = le(), s = _p(), i = yt(void 0, "reka-stepper-item-title"), u = yt(void 0, "reka-stepper-item-description"), d = E(() => o.value ? "completed" : s.modelValue.value === a.value ? "active" : s.modelValue.value > a.value ? "completed" : "inactive"), c = E(() => n.value ? !1 : s.linear.value ? a.value <= s.modelValue.value || a.value === s.modelValue.value + 1 : !0);
    return w5({
      titleId: i,
      descriptionId: u,
      state: d,
      disabled: n,
      step: a,
      isFocusable: c
    }), (f, p) => (g(), C(l(se), {
      ref: l(r),
      as: f.as,
      "as-child": f.asChild,
      "aria-current": d.value === "active" ? "true" : void 0,
      "data-state": d.value,
      disabled: l(n) || !c.value ? "" : void 0,
      "data-disabled": l(n) || !c.value ? "" : void 0,
      "data-orientation": l(s).orientation.value
    }, {
      default: y(() => [w(f.$slots, "default", { state: d.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-current",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), C5 = x5, S5 = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = Xs();
    return (a, o) => (g(), C(l(se), A(t, { id: l(n).descriptionId }), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), $5 = S5, B5 = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Xs();
    return le(), (a, o) => (g(), C(l(se), ne(oe(t)), {
      default: y(() => [w(a.$slots, "default", { step: l(n).step.value }, () => [Re(" Step " + Ve(l(n).step.value), 1)])]),
      _: 3
    }, 16));
  }
}), P5 = B5, E5 = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {
      type: String,
      required: !1
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = _p(), a = Xs();
    return le(), (o, r) => (g(), C(l(v0), A(t, {
      decorative: "",
      orientation: l(n).orientation.value,
      "data-state": l(a).state.value
    }), {
      default: y(() => [w(o.$slots, "default")]),
      _: 3
    }, 16, ["orientation", "data-state"]));
  }
}), D5 = E5, M5 = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h4"
    }
  },
  setup(e) {
    const t = e, n = Xs();
    return le(), (a, o) => (g(), C(l(se), A(t, { id: l(n).titleId }), {
      default: y(() => [w(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), k5 = M5, O5 = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = _p(), n = Xs(), a = Ks(), o = E(() => Array.from(t.totalStepperItems.value));
    function r(d) {
      if (!n.disabled.value) {
        if (t.linear.value) {
          if ((n.step.value <= t.modelValue.value || n.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {
            t.changeModelValue(n.step.value);
            return;
          }
        } else if (d.ctrlKey === !1) {
          t.changeModelValue(n.step.value);
          return;
        }
        d.preventDefault();
      }
    }
    function s(d) {
      d.preventDefault(), !n.disabled.value && ((d.key === a.ENTER || d.key === a.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(n.step.value), [
        a.ARROW_LEFT,
        a.ARROW_RIGHT,
        a.ARROW_UP,
        a.ARROW_DOWN
      ].includes(d.key) && Mr(d, gt(), void 0, {
        itemsArray: o.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: t.orientation.value,
        dir: t.dir.value
      }));
    }
    const { forwardRef: i, currentElement: u } = le();
    return be(() => {
      t.totalStepperItems.value.add(u.value);
    }), Ze(() => {
      t.totalStepperItems.value.delete(u.value);
    }), (d, c) => (g(), C(l(se), {
      ref: l(i),
      type: d.as === "button" ? "button" : void 0,
      as: d.as,
      "as-child": d.asChild,
      "data-state": l(n).state.value,
      disabled: l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-disabled": l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      tabindex: l(n).isFocusable.value ? 0 : -1,
      "aria-describedby": l(n).descriptionId,
      "aria-labelledby": l(n).titleId,
      onMousedown: We(r, ["left"]),
      onKeydown: Qe(s, [
        "enter",
        "space",
        "left",
        "right",
        "up",
        "down"
      ])
    }, {
      default: y(() => [w(d.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation",
      "tabindex",
      "aria-describedby",
      "aria-labelledby"
    ]));
  }
}), T5 = O5;
const [wp, A5] = He("TagsInputRoot");
var I5 = /* @__PURE__ */ b({
  __name: "TagsInputRoot",
  props: {
    modelValue: {
      type: [Array, null],
      required: !1
    },
    defaultValue: {
      type: Array,
      required: !1,
      default: () => []
    },
    addOnPaste: {
      type: Boolean,
      required: !1
    },
    addOnTab: {
      type: Boolean,
      required: !1
    },
    addOnBlur: {
      type: Boolean,
      required: !1
    },
    duplicate: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    delimiter: {
      type: null,
      required: !1,
      default: ","
    },
    dir: {
      type: String,
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: 0
    },
    id: {
      type: String,
      required: !1
    },
    convertValue: {
      type: Function,
      required: !1
    },
    displayValue: {
      type: Function,
      required: !1,
      default: (e) => e.toString()
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "invalid",
    "addTag",
    "removeTag"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { addOnPaste: o, disabled: r, delimiter: s, max: i, id: u, dir: d, addOnBlur: c, addOnTab: f } = Be(n), p = tn(d), v = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: !0,
      deep: !0
    }), { forwardRef: m, currentElement: h } = le(), { focused: _ } = FE(h), x = ro(h), { getItems: S, CollectionSlot: $ } = Gt({ isProvider: !0 }), D = O(), B = O(!1), k = E(() => Array.isArray(v.value) ? [...v.value] : []);
    function M(I) {
      if (I !== -1) {
        const T = S().filter((P) => P.ref.dataset.disabled !== "");
        v.value = v.value.filter((P, q) => q !== I), a("removeTag", T[I].value);
      }
    }
    return A5({
      modelValue: v,
      onAddValue: (I) => {
        const T = [...k.value], P = T.length > 0 && typeof T[0] == "object", q = T.length > 0 && typeof n.defaultValue[0] == "object";
        if ((P || q) && typeof n.convertValue != "function") throw new Error("You must provide a `convertValue` function when using objects as values.");
        const R = n.convertValue ? n.convertValue(I) : I;
        if (T.length >= i.value && i.value)
          return a("invalid", R), !1;
        if (n.duplicate)
          return v.value = [...T, R], a("addTag", R), !0;
        if (T.includes(R))
          B.value = !0;
        else return v.value = [...T, R], a("addTag", R), !0;
        return a("invalid", R), !1;
      },
      onRemoveValue: M,
      onInputKeydown: (I) => {
        const T = I.target, P = S().map((R) => R.ref).filter((R) => R.dataset.disabled !== "");
        if (!P.length) return;
        const q = P.at(-1);
        switch (I.key) {
          case "Delete":
          case "Backspace": {
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (D.value) {
              const R = P.findIndex((Q) => Q === D.value);
              M(R), D.value = D.value === q ? P.at(R - 1) : P.at(R + 1), I.preventDefault();
            } else I.key === "Backspace" && (D.value = q, I.preventDefault());
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const R = I.key === "ArrowRight" && p.value === "ltr" || I.key === "ArrowLeft" && p.value === "rtl", Q = !R;
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (Q && !D.value)
              D.value = q, I.preventDefault();
            else if (R && q && D.value === q)
              D.value = void 0, I.preventDefault();
            else if (D.value) {
              const ee = Mr(I, D.value, void 0, {
                itemsArray: P,
                loop: !1,
                dir: p.value
              });
              ee && (D.value = ee), I.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            D.value && I.preventDefault();
            break;
          }
          default:
            D.value = void 0;
        }
      },
      selectedElement: D,
      isInvalidInput: B,
      addOnPaste: o,
      addOnBlur: c,
      addOnTab: f,
      dir: p,
      disabled: r,
      delimiter: s,
      max: i,
      id: u,
      displayValue: n.displayValue
    }), (I, T) => (g(), C(l($), null, {
      default: y(() => [N(l(se), {
        ref: l(m),
        dir: l(p),
        as: I.as,
        "as-child": I.asChild,
        "data-invalid": B.value ? "" : void 0,
        "data-disabled": l(r) ? "" : void 0,
        "data-focused": l(_) ? "" : void 0
      }, {
        default: y(() => [w(I.$slots, "default", { modelValue: l(v) }), l(x) && I.name ? (g(), C(l(Ta), {
          key: 0,
          name: I.name,
          value: l(v),
          required: I.required,
          disabled: l(r)
        }, null, 8, [
          "name",
          "value",
          "required",
          "disabled"
        ])) : Pe("v-if", !0)]),
        _: 3
      }, 8, [
        "dir",
        "as",
        "as-child",
        "data-invalid",
        "data-disabled",
        "data-focused"
      ])]),
      _: 3
    }));
  }
}), R5 = I5, q5 = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    maxLength: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = wp(), { forwardRef: a, currentElement: o } = le();
    function r(v) {
      if (n.selectedElement.value = void 0, !n.addOnBlur.value) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = "");
    }
    function s(v) {
      n.addOnTab.value && c(v);
    }
    const i = O(!1);
    function u() {
      i.value = !0;
    }
    function d() {
      he(() => {
        i.value = !1;
      });
    }
    async function c(v) {
      if (i.value || (await he(), v.defaultPrevented)) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = ""), v.preventDefault();
    }
    function f(v) {
      if (n.isInvalidInput.value = !1, v.data === null) return;
      const m = n.delimiter.value;
      if (m === v.data || m instanceof RegExp && m.test(v.data)) {
        const _ = v.target;
        if (_.value = _.value.replace(m, ""), _.value.trim() === "") {
          _.value = "";
          return;
        }
        n.onAddValue(_.value) && (_.value = "");
      }
    }
    function p(v) {
      if (n.addOnPaste.value) {
        v.preventDefault();
        const m = v.clipboardData;
        if (!m) return;
        const h = m.getData("text");
        n.delimiter.value ? h.split(n.delimiter.value).forEach((x) => {
          n.onAddValue(x);
        }) : n.onAddValue(h);
      }
    }
    return be(() => {
      const v = o.value.nodeName === "INPUT" ? o.value : o.value.querySelector("input");
      v && setTimeout(() => {
        t.autoFocus && (v == null || v.focus());
      }, 1);
    }), (v, m) => {
      var h;
      return g(), C(l(se), {
        id: (h = l(n).id) == null ? void 0 : h.value,
        ref: l(a),
        type: "text",
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        as: v.as,
        "as-child": v.asChild,
        maxlength: v.maxLength,
        placeholder: v.placeholder,
        disabled: l(n).disabled.value,
        "data-invalid": l(n).isInvalidInput.value ? "" : void 0,
        onInput: f,
        onKeydown: [
          Qe(c, ["enter"]),
          Qe(s, ["tab"]),
          l(n).onInputKeydown
        ],
        onBlur: r,
        onCompositionstart: u,
        onCompositionend: d,
        onPaste: p
      }, {
        default: y(() => [w(v.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "as",
        "as-child",
        "maxlength",
        "placeholder",
        "disabled",
        "data-invalid",
        "onKeydown"
      ]);
    };
  }
}), F5 = q5;
const [T0, V5] = He("TagsInputItem");
var N5 = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { value: n } = Be(t), a = wp(), { forwardRef: o, currentElement: r } = le(), { CollectionItem: s } = Gt(), i = E(() => a.selectedElement.value === r.value), u = E(() => t.disabled || a.disabled.value), d = V5({
      value: n,
      isSelected: i,
      disabled: u,
      textId: "",
      displayValue: E(() => a.displayValue(n.value))
    });
    return (c, f) => (g(), C(l(s), { value: l(n) }, {
      default: y(() => [N(l(se), {
        ref: l(o),
        as: c.as,
        "as-child": c.asChild,
        "aria-labelledby": l(d).textId,
        "aria-current": i.value,
        "data-disabled": u.value ? "" : void 0,
        "data-state": i.value ? "active" : "inactive"
      }, {
        default: y(() => [w(c.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-labelledby",
        "aria-current",
        "data-disabled",
        "data-state"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), L5 = N5, z5 = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    le();
    const n = wp(), a = T0(), o = E(() => {
      var s;
      return ((s = a.disabled) == null ? void 0 : s.value) || n.disabled.value;
    });
    function r() {
      if (o.value) return;
      const s = n.modelValue.value.findIndex((i) => ra(i, a.value.value));
      n.onRemoveValue(s);
    }
    return (s, i) => (g(), C(l(se), A({ tabindex: "-1" }, t, {
      "aria-labelledby": l(a).textId,
      "aria-current": l(a).isSelected.value,
      "data-state": l(a).isSelected.value ? "active" : "inactive",
      "data-disabled": o.value ? "" : void 0,
      type: s.as === "button" ? "button" : void 0,
      onClick: r
    }), {
      default: y(() => [w(s.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-labelledby",
      "aria-current",
      "data-state",
      "data-disabled",
      "type"
    ]));
  }
}), H5 = z5, U5 = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = T0();
    return le(), n.textId || (n.textId = yt(void 0, "reka-tags-input-item-text")), (a, o) => (g(), C(l(se), A(t, { id: l(n).textId }), {
      default: y(() => [w(a.$slots, "default", {}, () => [Re(Ve(l(n).displayValue.value), 1)])]),
      _: 3
    }, 16, ["id"]));
  }
}), j5 = U5;
const [A0, W5] = He("ToggleGroupRoot");
var K5 = /* @__PURE__ */ b({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: {
      type: Boolean,
      required: !1,
      default: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { loop: o, rovingFocus: r, disabled: s, dir: i } = Be(n), u = tn(i), { forwardRef: d, currentElement: c } = le(), { modelValue: f, changeModelValue: p, isSingle: v } = PD(n, a), m = ro(c);
    return W5({
      isSingle: v,
      modelValue: f,
      changeModelValue: p,
      dir: u,
      orientation: n.orientation,
      loop: o,
      rovingFocus: r,
      disabled: s
    }), (h, _) => (g(), C(mt(l(r) ? l(vu) : l(se)), {
      "as-child": "",
      orientation: l(r) ? h.orientation : void 0,
      dir: l(u),
      loop: l(r) ? l(o) : void 0
    }, {
      default: y(() => [N(l(se), {
        ref: l(d),
        role: "group",
        "as-child": h.asChild,
        as: h.as
      }, {
        default: y(() => [w(h.$slots, "default", { modelValue: l(f) }), l(m) && h.name ? (g(), C(Ta, {
          key: 0,
          name: h.name,
          required: h.required,
          value: l(f)
        }, null, 8, [
          "name",
          "required",
          "value"
        ])) : Pe("v-if", !0)]),
        _: 3
      }, 8, ["as-child", "as"])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), G5 = K5, Y5 = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: r } = le(), s = A0(null), i = rt(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function u() {
      i.value = !i.value;
    }
    const d = E(() => i.value ? "on" : "off"), c = ro(r);
    return (f, p) => (g(), C(l(se), {
      ref: l(o),
      type: f.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: f.as,
      "aria-pressed": l(i),
      "data-state": d.value,
      "data-disabled": f.disabled ? "" : void 0,
      disabled: f.disabled,
      onClick: u
    }, {
      default: y(() => [w(f.$slots, "default", {
        modelValue: l(i),
        disabled: f.disabled,
        pressed: l(i),
        state: d.value
      }), l(c) && f.name && !l(s) ? (g(), C(Ta, {
        key: 0,
        type: "checkbox",
        name: f.name,
        value: l(i),
        required: f.required
      }, null, 8, [
        "name",
        "value",
        "required"
      ])) : Pe("v-if", !0)]),
      _: 3
    }, 8, [
      "type",
      "as-child",
      "as",
      "aria-pressed",
      "data-state",
      "data-disabled",
      "disabled"
    ]));
  }
}), I0 = Y5, X5 = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = A0(), a = E(() => {
      var s;
      return ((s = n.disabled) == null ? void 0 : s.value) || t.disabled;
    }), o = E(() => fi(n.modelValue.value, t.value)), { forwardRef: r } = le();
    return (s, i) => (g(), C(mt(l(n).rovingFocus.value ? l(mu) : l(se)), A({ "as-child": "" }, l(n).rovingFocus.value ? {
      focusable: !a.value,
      active: o.value
    } : {}), {
      default: y(() => [N(l(I0), A(t, {
        ref: l(r),
        disabled: a.value,
        "model-value": o.value,
        "onUpdate:modelValue": i[0] || (i[0] = (u) => l(n).changeModelValue(s.value))
      }), {
        default: y((u) => [w(s.$slots, "default", ne(oe(u)))]),
        _: 3
      }, 16, ["disabled", "model-value"])]),
      _: 3
    }, 16));
  }
}), J5 = X5;
const Eu = /* @__PURE__ */ b({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), {
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(F)(l(rn)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), rn = en(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        xs: "h-7 rounded px-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Z5 = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(JS), A(n.value, {
      class: l(F)(l(rn)({ variant: e.variant }), t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Q5 = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(GS), A(n.value, {
      class: l(F)(l(rn)({ variant: "outline" }), "mt-2 sm:mt-0", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), JU = /* @__PURE__ */ b({
  __name: "ConfirmDialog",
  setup(e) {
    const { isOpen: t, close: n, cancelButton: a, actionButton: o, title: r, description: s, variant: i } = n6();
    return (u, d) => (g(), C(l(tE), { open: l(t) }, {
      default: y(() => [
        N(l(nE), {
          onEscapeKeyDown: l(n),
          onPointerDownOutside: l(n)
        }, {
          default: y(() => [
            N(l(aE), null, {
              default: y(() => [
                N(l(oE), null, {
                  default: y(() => [
                    Re(Ve(l(r)), 1)
                  ]),
                  _: 1
                }),
                N(l(rE), null, {
                  default: y(() => [
                    Re(Ve(l(s)), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            N(l(sE), null, {
              default: y(() => [
                N(l(Q5), {
                  onClick: l(a).handler
                }, {
                  default: y(() => [
                    Re(Ve(l(a).label ?? "Cancel"), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                N(l(Z5), {
                  variant: l(i),
                  onClick: l(o).handler
                }, {
                  default: y(() => [
                    Re(Ve(l(o).label ?? "Confirm"), 1)
                  ]),
                  _: 1
                }, 8, ["variant", "onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onEscapeKeyDown", "onPointerDownOutside"])
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), xp = O(!1), R0 = O(""), q0 = O(""), F0 = O(null), V0 = O({
  label: void 0,
  handler: () => {
  }
}), N0 = O({
  label: void 0,
  handler: () => {
  }
}), e6 = (e) => {
  R0.value = e.title, q0.value = e.description, F0.value = e.variant, V0.value = km(e.cancelAction), N0.value = km(e.action), t6();
}, km = (e) => typeof e == "string" ? {
  label: e,
  handler: Hl
} : typeof e == "function" ? {
  label: void 0,
  handler: e
} : typeof e == "object" && e !== void 0 ? {
  label: e.label ?? void 0,
  handler: e.handler ?? Hl
} : {
  label: void 0,
  handler: Hl
}, Hl = () => {
  xp.value = !1;
}, t6 = () => {
  xp.value = !0;
};
function n6() {
  return {
    confirmDialog: (e) => e6(e),
    title: R0,
    description: q0,
    variant: F0,
    isOpen: xp,
    close: Hl,
    cancelButton: V0,
    actionButton: N0
  };
}
const Oo = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, o] of t)
    n[a] = o;
  return n;
}, a6 = {}, o6 = { class: "h-full bg-background dark:text-white" };
function r6(e, t) {
  return g(), U("div", o6, [
    w(e.$slots, "default")
  ]);
}
const ZU = /* @__PURE__ */ Oo(a6, [["render", r6]]), s6 = {}, l6 = { class: "sticky top-0 z-50 flex h-16 shrink-0 items-center gap-x-4 bg-background/60 px-4 backdrop-blur sm:gap-x-6 sm:px-6 lg:px-8" };
function i6(e, t) {
  return g(), U("header", l6, [
    w(e.$slots, "default")
  ]);
}
const QU = /* @__PURE__ */ Oo(s6, [["render", i6]]), u6 = {}, d6 = { class: "px-4 py-10 sm:px-6 lg:px-8 lg:pl-72" };
function c6(e, t) {
  return g(), U("main", d6, [
    w(e.$slots, "default")
  ]);
}
const ej = /* @__PURE__ */ Oo(u6, [["render", c6]]), f6 = {};
function p6(e, t) {
  return w(e.$slots, "default");
}
const tj = /* @__PURE__ */ Oo(f6, [["render", p6]]), v6 = {}, m6 = { class: "hidden px-6 py-10 lg:fixed lg:inset-y-0 lg:top-16 lg:z-50 lg:flex lg:w-72 lg:flex-col" }, h6 = { class: "gap-y-5 overflow-y-auto" };
function g6(e, t) {
  return g(), U("div", m6, [
    ye("div", h6, [
      w(e.$slots, "default")
    ])
  ]);
}
const nj = /* @__PURE__ */ Oo(v6, [["render", g6]]), y6 = {};
function b6(e, t) {
  return w(e.$slots, "default");
}
const aj = /* @__PURE__ */ Oo(y6, [["render", b6]]);
function _6(e, t) {
  return g(), U("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    ye("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
    })
  ]);
}
function w6(e, t) {
  return g(), U("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    ye("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
    })
  ]);
}
function Om(e, t) {
  return g(), U("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    ye("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"
    })
  ]);
}
function x6(e, t) {
  return g(), U("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    ye("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"
    })
  ]);
}
const C6 = {
  type: "button",
  class: "-m-2.5 p-2.5 lg:hidden"
}, oj = /* @__PURE__ */ b({
  __name: "TwoColumnLayoutSidebarTrigger",
  setup(e) {
    return (t, n) => (g(), U("button", C6, [
      n[0] || (n[0] = ye("span", { class: "sr-only" }, "Open sidebar", -1)),
      N(l(_6), {
        class: "h-6 w-6",
        "aria-hidden": "true"
      })
    ]));
  }
}), S6 = 3, $6 = 1e6, _a = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST"
};
let $d = 0;
function B6() {
  return $d = ($d + 1) % Number.MAX_VALUE, $d.toString();
}
const Bd = /* @__PURE__ */ new Map();
function Tm(e) {
  if (Bd.has(e)) return;
  const t = setTimeout(() => {
    Bd.delete(e), ss({
      type: _a.REMOVE_TOAST,
      toastId: e
    });
  }, $6);
  Bd.set(e, t);
}
const An = O({
  toasts: []
});
function ss(e) {
  switch (e.type) {
    case _a.ADD_TOAST:
      An.value.toasts = [e.toast, ...An.value.toasts].slice(0, S6);
      break;
    case _a.UPDATE_TOAST:
      An.value.toasts = An.value.toasts.map(
        (t) => t.id === e.toast.id ? { ...t, ...e.toast } : t
      );
      break;
    case _a.DISMISS_TOAST: {
      const { toastId: t } = e;
      t ? Tm(t) : An.value.toasts.forEach((n) => {
        Tm(n.id);
      }), An.value.toasts = An.value.toasts.map(
        (n) => n.id === t || t === void 0 ? {
          ...n,
          open: !1
        } : n
      );
      break;
    }
    case _a.REMOVE_TOAST:
      e.toastId === void 0 ? An.value.toasts = [] : An.value.toasts = An.value.toasts.filter((t) => t.id !== e.toastId);
      break;
  }
}
function L0() {
  return {
    toasts: E(() => An.value.toasts),
    toast: P6,
    dismiss: (e) => ss({ type: _a.DISMISS_TOAST, toastId: e })
  };
}
function P6(e) {
  const t = B6(), n = (o) => ss({
    type: _a.UPDATE_TOAST,
    toast: { ...o, id: t }
  }), a = () => ss({ type: _a.DISMISS_TOAST, toastId: t });
  return ss({
    type: _a.ADD_TOAST,
    toast: {
      ...e,
      id: t,
      open: !0,
      onOpenChange: (o) => {
        o || a();
      }
    }
  }), {
    id: t,
    dismiss: a,
    update: n
  };
}
const E6 = { class: "flex items-start space-x-3" }, D6 = ["src", "alt"], M6 = { class: "grid gap-1" }, k6 = { class: "font-bold" }, O6 = /* @__PURE__ */ b({
  __name: "Toaster",
  props: {
    position: {}
  },
  emits: ["click"],
  setup(e) {
    const { toasts: t } = L0();
    return (n, a) => (g(), C(l(U6), null, {
      default: y(() => [
        (g(!0), U(Fe, null, $t(l(t), (o) => (g(), C(l(T6), A({
          key: o.id
        }, { ref_for: !0 }, o, {
          class: "mt-1.5",
          onClick: (r) => n.$emit("click", o)
        }), {
          default: y(() => [
            ye("div", E6, [
              o.icon ? (g(), U(Fe, { key: 0 }, [
                typeof o.icon == "string" ? (g(), U("img", {
                  key: 0,
                  src: o.icon,
                  class: ae(["size-16 rounded-sm object-cover", o.iconClasses]),
                  alt: o.title
                }, null, 10, D6)) : (g(), C(mt(o.icon), {
                  key: 1,
                  class: ae(["size-6", o.iconClasses])
                }, null, 8, ["class"]))
              ], 64)) : Pe("", !0),
              ye("div", M6, [
                o.title ? (g(), C(l(H6), { key: 0 }, {
                  default: y(() => [
                    Re(Ve(o.title), 1)
                  ]),
                  _: 2
                }, 1024)) : Pe("", !0),
                o.description ? (g(), U(Fe, { key: 1 }, [
                  Uo(o.description) ? (g(), C(l(Am), { key: 0 }, {
                    default: y(() => [
                      (g(), C(mt(o.description)))
                    ]),
                    _: 2
                  }, 1024)) : typeof o.description == "object" ? (g(!0), U(Fe, { key: 1 }, $t(o.description, (r, s) => (g(), U("p", {
                    key: s,
                    class: "text-sm opacity-90"
                  }, [
                    o.objectFormat === "key" ? (g(), U(Fe, { key: 0 }, [
                      Re(Ve(s), 1)
                    ], 64)) : o.objectFormat === "both" ? (g(), U(Fe, { key: 1 }, [
                      ye("span", k6, Ve(s), 1),
                      Re(": " + Ve(r), 1)
                    ], 64)) : (g(), U(Fe, { key: 2 }, [
                      Re(Ve(r), 1)
                    ], 64))
                  ]))), 128)) : (g(), C(l(Am), { key: 2 }, {
                    default: y(() => [
                      Re(Ve(o.description), 1)
                    ]),
                    _: 2
                  }, 1024))
                ], 64)) : Pe("", !0),
                N(l(z6))
              ])
            ]),
            (g(), C(mt(o.action)))
          ]),
          _: 2
        }, 1040, ["onClick"]))), 128)),
        N(l(A6), { position: e.position }, null, 8, ["position"])
      ]),
      _: 1
    }));
  }
}), T6 = /* @__PURE__ */ b({
  __name: "Toast",
  props: {
    class: {},
    variant: {},
    onOpenChange: { type: Function },
    defaultOpen: { type: Boolean },
    forceMount: { type: Boolean },
    type: {},
    open: { type: Boolean },
    duration: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(W2), A(l(r), {
      class: l(F)(l(j6)({ variant: e.variant }), n.class),
      "onUpdate:open": e.onOpenChange
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "onUpdate:open"]));
  }
}), A6 = /* @__PURE__ */ b({
  __name: "ToastViewport",
  props: {
    position: { default: "bottom-right" },
    hotkey: {},
    label: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = E(() => {
      switch (t.position) {
        case "top-left":
          return "top-0 left-0 bottom-auto";
        case "top-right":
          return "top-0 right-0 bottom-auto";
        case "bottom-left":
          return "bottom-0 left-0 top-auto";
        case "bottom-right":
          return "bottom-0 right-0 top-auto";
        default:
          return "bottom-0 right-0 top-auto";
      }
    });
    return (o, r) => (g(), C(l(G2), A(n.value, {
      class: l(F)(
        // overriding the defaults to position at the bottom on mobile viewport
        // 'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
        "fixed z-[100] flex max-h-screen w-full flex-col p-4 md:max-w-[420px]",
        a.value,
        t.class
      )
    }), null, 16, ["class"]));
  }
}), rj = /* @__PURE__ */ b({
  __name: "ToastAction",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(K2), A(n.value, {
      class: l(F)(
        "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:ring-1 focus:ring-ring focus:outline-none group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
function I6(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.85355 3.14645C7.04882 3.34171 7.04882 3.65829 6.85355 3.85355L3.70711 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H3.70711L6.85355 11.1464C7.04882 11.3417 7.04882 11.6583 6.85355 11.8536C6.65829 12.0488 6.34171 12.0488 6.14645 11.8536L2.14645 7.85355C1.95118 7.65829 1.95118 7.34171 2.14645 7.14645L6.14645 3.14645C6.34171 2.95118 6.65829 2.95118 6.85355 3.14645Z",
      fill: "currentColor"
    })
  ]);
}
function R6(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.14645 3.14645C8.34171 2.95118 8.65829 2.95118 8.85355 3.14645L12.8536 7.14645C13.0488 7.34171 13.0488 7.65829 12.8536 7.85355L8.85355 11.8536C8.65829 12.0488 8.34171 12.0488 8.14645 11.8536C7.95118 11.6583 7.95118 11.3417 8.14645 11.1464L11.2929 8H2.5C2.22386 8 2 7.77614 2 7.5C2 7.22386 2.22386 7 2.5 7H11.2929L8.14645 3.85355C7.95118 3.65829 7.95118 3.34171 8.14645 3.14645Z",
      fill: "currentColor"
    })
  ]);
}
function q6(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
      fill: "currentColor"
    })
  ]);
}
function z0(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
      fill: "currentColor"
    })
  ]);
}
function H0(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
      fill: "currentColor"
    })
  ]);
}
function F6(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
      fill: "currentColor"
    })
  ]);
}
function V6(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M3.13523 8.84197C3.3241 9.04343 3.64052 9.05363 3.84197 8.86477L7.5 5.43536L11.158 8.86477C11.3595 9.05363 11.6759 9.04343 11.8648 8.84197C12.0536 8.64051 12.0434 8.32409 11.842 8.13523L7.84197 4.38523C7.64964 4.20492 7.35036 4.20492 7.15803 4.38523L3.15803 8.13523C2.95657 8.32409 2.94637 8.64051 3.13523 8.84197Z",
      fill: "currentColor"
    })
  ]);
}
function Du(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
      fill: "currentColor"
    })
  ]);
}
function N6(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      d: "M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z",
      fill: "currentColor"
    })
  ]);
}
function L6(e, t) {
  return g(), U("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    ye("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z",
      fill: "currentColor"
    })
  ]);
}
const z6 = /* @__PURE__ */ b({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(Qy), A(n.value, {
      class: l(F)(
        "absolute top-1 right-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:ring-1 focus:outline-none group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
        t.class
      )
    }), {
      default: y(() => [
        N(l(Du), { class: "h-4 w-4" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), H6 = /* @__PURE__ */ b({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(Y2), A(n.value, {
      class: l(F)("text-sm font-semibold [&+div]:text-xs", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Am = /* @__PURE__ */ b({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(X2), A({
      class: l(F)("text-sm opacity-90", t.class)
    }, n.value), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), U6 = /* @__PURE__ */ b({
  __name: "ToastProvider",
  props: {
    label: {},
    duration: {},
    swipeDirection: {},
    swipeThreshold: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(R2), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), j6 = en(
  // overriding the defaults to position at the bottom on mobile viewport
  // "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), { toast: xl } = L0();
function W6() {
  return {
    info: (e) => {
      xl({
        icon: x6,
        iconClasses: "text-blue-400",
        title: "FYI",
        description: e
      });
    },
    success: (e) => {
      xl({
        icon: w6,
        iconClasses: "text-green-400",
        title: "Success",
        description: e
      });
    },
    warning: (e) => {
      xl({
        icon: Om,
        iconClasses: "text-orange-400",
        title: "Warning",
        description: e
      });
    },
    error: (e, t = "value") => {
      xl({
        icon: Om,
        iconClasses: "text-red-400",
        title: "Oh snap! Some errors were encountered.",
        description: e,
        objectFormat: t
      });
    }
  };
}
const sj = /* @__PURE__ */ b({
  __name: "Flasher",
  props: {
    info: {},
    success: {},
    warning: {},
    errors: {},
    objectFormat: { default: "value" }
  },
  setup(e) {
    const t = e, {
      info: n,
      success: a,
      warning: o,
      error: r
    } = W6();
    return ce(
      () => t.info,
      (s) => {
        s && n(t.info);
      },
      {
        immediate: !0
      }
    ), ce(
      () => t.success,
      (s) => {
        s && a(t.success);
      },
      { immediate: !0 }
    ), ce(
      () => t.warning,
      (s) => {
        s && o(t.warning);
      },
      { immediate: !0 }
    ), ce(
      () => t.errors,
      () => {
        t.errors !== void 0 && Object.keys(t.errors).length > 0 && r(t.errors, t.objectFormat);
      }
    ), (s, i) => (g(), C(l(O6)));
  }
}), K6 = { class: "flex items-center justify-between space-y-2" }, G6 = { class: "flex items-center space-x-2" }, lj = /* @__PURE__ */ b({
  __name: "Heading",
  props: {
    as: { default: "h2" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", K6, [
      (g(), C(mt(e.as), {
        class: ae(l(F)("text-3xl font-bold tracking-tight", t.class))
      }, {
        default: y(() => [
          w(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])),
      ye("div", G6, [
        w(n.$slots, "actions")
      ])
    ]));
  }
}), Y6 = /* @__PURE__ */ b({
  __name: "Accordion",
  props: {
    collapsible: { type: Boolean },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(dS), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ij = /* @__PURE__ */ b({
  __name: "Accord",
  props: {
    content: {},
    collapsible: { type: Boolean, default: !0 },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    asChild: { type: Boolean },
    as: {},
    type: { default: "single" },
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(Y6, ne(oe(l(o))), {
      default: y(() => [
        (g(!0), U(Fe, null, $t(e.content, (i, u) => (g(), C(l(J6), {
          key: u,
          value: "item-" + u
        }, {
          default: y(() => [
            N(l(Z6), null, {
              default: y(() => [
                w(r.$slots, u + ".title", { item: i }, () => [
                  Re(Ve(i.title), 1)
                ])
              ]),
              _: 2
            }, 1024),
            N(l(X6), null, {
              default: y(() => [
                w(r.$slots, u + ".content", { item: i }, () => [
                  Re(Ve(i.content), 1)
                ])
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1032, ["value"]))), 128))
      ]),
      _: 3
    }, 16));
  }
}), X6 = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(pS), A(n.value, { class: "accordion-content overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down" }), {
      default: y(() => [
        ye("div", {
          class: ae(l(F)("pt-0 pb-4", t.class))
        }, [
          w(a.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16));
  }
}), J6 = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(fS), A(l(a), {
      class: l(F)("border-b", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Z6 = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(vS), { class: "flex" }, {
      default: y(() => [
        N(l(mS), A(n.value, {
          class: l(F)(
            "accordion-trigger flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
            t.class
          )
        }), {
          default: y(() => [
            w(a.$slots, "default"),
            w(a.$slots, "icon", {}, () => [
              N(l(H0), { class: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), uj = /* @__PURE__ */ b({
  __name: "Tip",
  props: {
    tooltip: {},
    indicator: { type: Boolean },
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(Q6), null, {
      default: y(() => [
        N(l(U0), ne(oe(l(o))), {
          default: y(() => [
            N(l(W0), {
              class: ae(e.indicator ? "underline decoration-dotted underline-offset-4" : "")
            }, {
              default: y(() => [
                w(r.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(j0), ne(oe(r.$attrs)), {
              default: y(() => [
                w(r.$slots, "tooltip", {}, () => [
                  Re(Ve(e.tooltip), 1)
                ])
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), U0 = /* @__PURE__ */ b({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(Q2), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), j0 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(aP), null, {
      default: y(() => [
        N(l(nP), A({ ...l(r), ...s.$attrs }, {
          class: l(F)(
            "z-50 animate-in overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground fade-in-0 zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
            n.class
          )
        }), {
          default: y(() => [
            w(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Q6 = /* @__PURE__ */ b({
  __name: "TooltipProvider",
  props: {
    delayDuration: {},
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(tb), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), W0 = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(eP), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dj = /* @__PURE__ */ b({
  __name: "Alert",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)(l(eR)({ variant: e.variant }), t.class)),
      role: "alert"
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), cj = /* @__PURE__ */ b({
  __name: "AlertDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("text-sm [&_p]:leading-relaxed", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), fj = /* @__PURE__ */ b({
  __name: "AlertTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("h5", {
      class: ae(l(F)("mb-1 leading-none font-medium tracking-tight", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), eR = en(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), pj = /* @__PURE__ */ b({
  __name: "AspectRatio",
  props: {
    ratio: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(S3), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vj = /* @__PURE__ */ b({
  __name: "Avatar",
  props: {
    class: {},
    size: { default: "sm" },
    shape: { default: "circle" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(QS), {
      class: ae(l(F)(l(tR)({ size: e.size, shape: e.shape }), t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), mj = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {},
    referrerPolicy: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(t$), A(t, { class: "h-full w-full object-cover" }), null, 16));
  }
}), hj = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(n$), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tR = en(
  "inline-flex shrink-0 select-none items-center justify-center overflow-hidden bg-secondary font-normal text-foreground",
  {
    variants: {
      size: {
        sm: "h-10 w-10 text-xs",
        base: "h-16 w-16 text-2xl",
        lg: "h-32 w-32 text-5xl"
      },
      shape: {
        circle: "rounded-full",
        square: "rounded-md"
      }
    }
  }
), gj = /* @__PURE__ */ b({
  __name: "Badge",
  props: {
    variant: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)(l(nR)({ variant: e.variant }), t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), nR = en(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        success: "border-transparent bg-success text-success-foreground shadow hover:bg-success/80",
        warning: "border-transparent bg-warning text-warning-foreground shadow hover:bg-warning/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), yj = /* @__PURE__ */ b({
  __name: "Breadcrumb",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("nav", {
      "aria-label": "breadcrumb",
      class: ae(t.class)
    }, [
      w(n.$slots, "default")
    ], 2));
  }
});
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aR = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Cl = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oR = ({ size: e, strokeWidth: t = 2, absoluteStrokeWidth: n, color: a, iconNode: o, name: r, class: s, ...i }, { slots: u }) => Bt(
  "svg",
  {
    ...Cl,
    width: e || Cl.width,
    height: e || Cl.height,
    stroke: a || Cl.stroke,
    "stroke-width": n ? Number(t) * 24 / Number(e) : t,
    class: ["lucide", `lucide-${aR(r ?? "icon")}`],
    ...i
  },
  [...o.map((d) => Bt(...d)), ...u.default ? [u.default()] : []]
);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yt = (e, t) => (n, { slots: a }) => Bt(
  oR,
  {
    ...n,
    iconNode: t,
    name: e
  },
  a
);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mu = Yt("CheckIcon", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rR = Yt("ChevronDownIcon", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ku = Yt("ChevronLeftIcon", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const To = Yt("ChevronRightIcon", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sR = Yt("CircleCheckIcon", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const K0 = Yt("CircleIcon", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const G0 = Yt("EllipsisIcon", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lR = Yt("GripVerticalIcon", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iR = Yt("InfoIcon", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Y0 = Yt("LoaderCircleIcon", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uR = Yt("MenuIcon", [
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
  ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
  ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Cp = Yt("MinusIcon", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dR = Yt("OctagonXIcon", [
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  [
    "path",
    {
      d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z",
      key: "2d38gg"
    }
  ],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cR = Yt("PanelLeftIcon", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fR = Yt("PlusIcon", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pR = Yt("TriangleAlertIcon", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-vue-next v0.439.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X0 = Yt("XIcon", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), bj = /* @__PURE__ */ b({
  __name: "BreadcrumbEllipsis",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("span", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(F)("flex h-9 w-9 items-center justify-center", t.class))
    }, [
      w(n.$slots, "default", {}, () => [
        N(l(G0), { class: "h-4 w-4" })
      ]),
      a[0] || (a[0] = ye("span", { class: "sr-only" }, "More", -1))
    ], 2));
  }
}), _j = /* @__PURE__ */ b({
  __name: "BreadcrumbItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("li", {
      class: ae(l(F)("inline-flex items-center gap-1.5", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), wj = /* @__PURE__ */ b({
  __name: "BreadcrumbLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), {
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(F)("transition-colors hover:text-foreground", t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), xj = /* @__PURE__ */ b({
  __name: "BreadcrumbList",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("ol", {
      class: ae(
        l(F)(
          "flex flex-wrap items-center gap-1.5 text-sm break-words text-muted-foreground sm:gap-2.5",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), Cj = /* @__PURE__ */ b({
  __name: "BreadcrumbPage",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("span", {
      role: "link",
      "aria-disabled": "true",
      "aria-current": "page",
      class: ae(l(F)("font-normal text-foreground", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), Sj = /* @__PURE__ */ b({
  __name: "BreadcrumbSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("li", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(F)("[&>svg]:size-3.5", t.class))
    }, [
      w(n.$slots, "default", {}, () => [
        N(l(To))
      ])
    ], 2));
  }
}), vR = ["data-orientation"], $j = /* @__PURE__ */ b({
  __name: "ButtonGroup",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      class: ae(l(F)(l(mR)({ orientation: t.orientation }), t.class))
    }, [
      w(n.$slots, "default")
    ], 10, vR));
  }
}), Ou = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(v0), A(l(n), {
      class: l(F)(
        "shrink-0 bg-border",
        t.orientation === "horizontal" ? "h-px w-full" : "h-full w-px",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), Bj = /* @__PURE__ */ b({
  __name: "ButtonGroupSeparator",
  props: {
    orientation: { default: "vertical" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(Ou), A({ "data-slot": "button-group-separator" }, l(n), {
      orientation: t.orientation,
      class: l(F)("relative !m-0 self-stretch bg-input data-[orientation=vertical]:h-auto", t.class)
    }), null, 16, ["orientation", "class"]));
  }
}), Pj = /* @__PURE__ */ b({
  __name: "ButtonGroupText",
  props: {
    class: {},
    orientation: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(F)(
          "flex items-center gap-2 rounded-md border bg-muted px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as", "as-child", "class"]));
  }
}), mR = en(
  "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*:focus-visible]:relative [&>*:focus-visible]:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  {
    variants: {
      orientation: {
        horizontal: "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
        vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
      }
    },
    defaultVariants: {
      orientation: "horizontal"
    }
  }
), hR = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, Ej = /* @__PURE__ */ b({
  __name: "Calendar",
  props: {
    defaultValue: {},
    defaultPlaceholder: {},
    placeholder: {},
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    modelValue: {},
    multiple: { type: Boolean },
    disableDaysOutsideCurrentView: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(A3), A({
      class: l(F)("p-3", n.class)
    }, l(r)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(CR), null, {
          default: y(() => [
            N(l(BR)),
            N(l(SR)),
            N(l($R))
          ]),
          _: 1
        }),
        ye("div", hR, [
          (g(!0), U(Fe, null, $t(u, (c) => (g(), C(l(bR), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(wR), null, {
                default: y(() => [
                  N(l(Im), null, {
                    default: y(() => [
                      (g(!0), U(Fe, null, $t(d, (f) => (g(), C(l(xR), { key: f }, {
                        default: y(() => [
                          Re(Ve(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(_R), null, {
                default: y(() => [
                  (g(!0), U(Fe, null, $t(c.rows, (f, p) => (g(), C(l(Im), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (g(!0), U(Fe, null, $t(f, (v) => (g(), C(l(gR), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(yR), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), gR = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(R3), A({
      class: l(F)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:rounded-md [&:has([data-selected])]:bg-accent [&:has([data-selected][data-outside-view])]:bg-accent/50",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), yR = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(F3), A({
      class: l(F)(
        l(rn)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selected
        "data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:opacity-100 data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:bg-accent/50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bR = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(N3), A({
      class: l(F)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _R = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(z3), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wR = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(U3), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Im = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(W3), A({
      class: l(F)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xR = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(G3), A({
      class: l(F)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CR = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(X3), A({
      class: l(F)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), SR = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(Z3), A({
      class: l(F)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        w(o.$slots, "default", { headingValue: s }, () => [
          Re(Ve(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $R = /* @__PURE__ */ b({
  __name: "CalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(eM), A({
      class: l(F)(
        l(rn)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(To), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), BR = /* @__PURE__ */ b({
  __name: "CalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(nM), A({
      class: l(F)(
        l(rn)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(ku), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PR = /* @__PURE__ */ b({
  __name: "Card",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("rounded-xl border bg-card text-card-foreground shadow", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), ER = /* @__PURE__ */ b({
  __name: "CardContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("p-6 pt-0", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), Dj = /* @__PURE__ */ b({
  __name: "CardDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("p", {
      class: ae(l(F)("text-sm text-muted-foreground", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), Mj = /* @__PURE__ */ b({
  __name: "CardFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex items-center p-6 pt-0", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), DR = /* @__PURE__ */ b({
  __name: "CardHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex flex-col gap-y-1.5 p-6", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), MR = /* @__PURE__ */ b({
  __name: "CardTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("h3", {
      class: ae(l(F)("leading-none font-semibold tracking-tight", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
});
function kR(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Rm(e) {
  return kR(e) || Array.isArray(e);
}
function OR() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Sp(e, t) {
  const n = Object.keys(e), a = Object.keys(t);
  if (n.length !== a.length) return !1;
  const o = JSON.stringify(Object.keys(e.breakpoints || {})), r = JSON.stringify(Object.keys(t.breakpoints || {}));
  return o !== r ? !1 : n.every((s) => {
    const i = e[s], u = t[s];
    return typeof i == "function" ? `${i}` == `${u}` : !Rm(i) || !Rm(u) ? i === u : Sp(i, u);
  });
}
function qm(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function TR(e, t) {
  if (e.length !== t.length) return !1;
  const n = qm(e), a = qm(t);
  return n.every((o, r) => {
    const s = a[r];
    return Sp(o, s);
  });
}
function $p(e) {
  return typeof e == "number";
}
function bc(e) {
  return typeof e == "string";
}
function Tu(e) {
  return typeof e == "boolean";
}
function Fm(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ct(e) {
  return Math.abs(e);
}
function Bp(e) {
  return Math.sign(e);
}
function ls(e, t) {
  return Ct(e - t);
}
function AR(e, t) {
  if (e === 0 || t === 0 || Ct(e) <= Ct(t)) return 0;
  const n = ls(Ct(e), Ct(t));
  return Ct(n / e);
}
function IR(e) {
  return Math.round(e * 100) / 100;
}
function Cs(e) {
  return Ss(e).map(Number);
}
function zn(e) {
  return e[Js(e)];
}
function Js(e) {
  return Math.max(0, e.length - 1);
}
function Pp(e, t) {
  return t === Js(e);
}
function Vm(e, t = 0) {
  return Array.from(Array(e), (n, a) => t + a);
}
function Ss(e) {
  return Object.keys(e);
}
function J0(e, t) {
  return [e, t].reduce((n, a) => (Ss(a).forEach((o) => {
    const r = n[o], s = a[o], i = Fm(r) && Fm(s);
    n[o] = i ? J0(r, s) : s;
  }), n), {});
}
function _c(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function RR(e, t) {
  const n = {
    start: a,
    center: o,
    end: r
  };
  function a() {
    return 0;
  }
  function o(u) {
    return r(u) / 2;
  }
  function r(u) {
    return t - u;
  }
  function s(u, d) {
    return bc(e) ? n[e](u) : e(t, u, d);
  }
  return {
    measure: s
  };
}
function $s() {
  let e = [];
  function t(o, r, s, i = {
    passive: !0
  }) {
    let u;
    if ("addEventListener" in o)
      o.addEventListener(r, s, i), u = () => o.removeEventListener(r, s, i);
    else {
      const d = o;
      d.addListener(s), u = () => d.removeListener(s);
    }
    return e.push(u), a;
  }
  function n() {
    e = e.filter((o) => o());
  }
  const a = {
    add: t,
    clear: n
  };
  return a;
}
function qR(e, t, n, a) {
  const o = $s(), r = 1e3 / 60;
  let s = null, i = 0, u = 0;
  function d() {
    o.add(e, "visibilitychange", () => {
      e.hidden && m();
    });
  }
  function c() {
    v(), o.clear();
  }
  function f(_) {
    if (!u) return;
    s || (s = _, n(), n());
    const x = _ - s;
    for (s = _, i += x; i >= r; )
      n(), i -= r;
    const S = i / r;
    a(S), u && (u = t.requestAnimationFrame(f));
  }
  function p() {
    u || (u = t.requestAnimationFrame(f));
  }
  function v() {
    t.cancelAnimationFrame(u), s = null, i = 0, u = 0;
  }
  function m() {
    s = null, i = 0;
  }
  return {
    init: d,
    destroy: c,
    start: p,
    stop: v,
    update: n,
    render: a
  };
}
function FR(e, t) {
  const n = t === "rtl", a = e === "y", o = a ? "y" : "x", r = a ? "x" : "y", s = !a && n ? -1 : 1, i = c(), u = f();
  function d(m) {
    const {
      height: h,
      width: _
    } = m;
    return a ? h : _;
  }
  function c() {
    return a ? "top" : n ? "right" : "left";
  }
  function f() {
    return a ? "bottom" : n ? "left" : "right";
  }
  function p(m) {
    return m * s;
  }
  return {
    scroll: o,
    cross: r,
    startEdge: i,
    endEdge: u,
    measureSize: d,
    direction: p
  };
}
function _o(e = 0, t = 0) {
  const n = Ct(e - t);
  function a(d) {
    return d < e;
  }
  function o(d) {
    return d > t;
  }
  function r(d) {
    return a(d) || o(d);
  }
  function s(d) {
    return r(d) ? a(d) ? e : t : d;
  }
  function i(d) {
    return n ? d - n * Math.ceil((d - t) / n) : d;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: s,
    reachedAny: r,
    reachedMax: o,
    reachedMin: a,
    removeOffset: i
  };
}
function Z0(e, t, n) {
  const {
    constrain: a
  } = _o(0, e), o = e + 1;
  let r = s(t);
  function s(p) {
    return n ? Ct((o + p) % o) : a(p);
  }
  function i() {
    return r;
  }
  function u(p) {
    return r = s(p), f;
  }
  function d(p) {
    return c().set(i() + p);
  }
  function c() {
    return Z0(e, i(), n);
  }
  const f = {
    get: i,
    set: u,
    add: d,
    clone: c
  };
  return f;
}
function VR(e, t, n, a, o, r, s, i, u, d, c, f, p, v, m, h, _, x, S) {
  const {
    cross: $,
    direction: D
  } = e, B = ["INPUT", "SELECT", "TEXTAREA"], k = {
    passive: !1
  }, M = $s(), I = $s(), T = _o(50, 225).constrain(v.measure(20)), P = {
    mouse: 300,
    touch: 400
  }, q = {
    mouse: 500,
    touch: 600
  }, R = m ? 43 : 25;
  let Q = !1, ee = 0, K = 0, W = !1, j = !1, J = !1, z = !1;
  function Y(L) {
    if (!S) return;
    function _e(Te) {
      (Tu(S) || S(L, Te)) && ue(Te);
    }
    const we = t;
    M.add(we, "dragstart", (Te) => Te.preventDefault(), k).add(we, "touchmove", () => {
    }, k).add(we, "touchend", () => {
    }).add(we, "touchstart", _e).add(we, "mousedown", _e).add(we, "touchcancel", te).add(we, "contextmenu", te).add(we, "click", H, !0);
  }
  function Z() {
    M.clear(), I.clear();
  }
  function pe() {
    const L = z ? n : t;
    I.add(L, "touchmove", V, k).add(L, "touchend", te).add(L, "mousemove", V, k).add(L, "mouseup", te);
  }
  function $e(L) {
    const _e = L.nodeName || "";
    return B.includes(_e);
  }
  function Ce() {
    return (m ? q : P)[z ? "mouse" : "touch"];
  }
  function De(L, _e) {
    const we = f.add(Bp(L) * -1), Te = c.byDistance(L, !m).distance;
    return m || Ct(L) < T ? Te : _ && _e ? Te * 0.5 : c.byIndex(we.get(), 0).distance;
  }
  function ue(L) {
    const _e = _c(L, a);
    z = _e, J = m && _e && !L.buttons && Q, Q = ls(o.get(), s.get()) >= 2, !(_e && L.button !== 0) && ($e(L.target) || (W = !0, r.pointerDown(L), d.useFriction(0).useDuration(0), o.set(s), pe(), ee = r.readPoint(L), K = r.readPoint(L, $), p.emit("pointerDown")));
  }
  function V(L) {
    if (!_c(L, a) && L.touches.length >= 2) return te(L);
    const we = r.readPoint(L), Te = r.readPoint(L, $), Ne = ls(we, ee), Je = ls(Te, K);
    if (!j && !z && (!L.cancelable || (j = Ne > Je, !j)))
      return te(L);
    const xe = r.pointerMove(L);
    Ne > h && (J = !0), d.useFriction(0.3).useDuration(0.75), i.start(), o.add(D(xe)), L.preventDefault();
  }
  function te(L) {
    const we = c.byDistance(0, !1).index !== f.get(), Te = r.pointerUp(L) * Ce(), Ne = De(D(Te), we), Je = AR(Te, Ne), xe = R - 10 * Je, ze = x + Je / 50;
    j = !1, W = !1, I.clear(), d.useDuration(xe).useFriction(ze), u.distance(Ne, !m), z = !1, p.emit("pointerUp");
  }
  function H(L) {
    J && (L.stopPropagation(), L.preventDefault(), J = !1);
  }
  function re() {
    return W;
  }
  return {
    init: Y,
    destroy: Z,
    pointerDown: re
  };
}
function NR(e, t) {
  let a, o;
  function r(f) {
    return f.timeStamp;
  }
  function s(f, p) {
    const m = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (_c(f, t) ? f : f.touches[0])[m];
  }
  function i(f) {
    return a = f, o = f, s(f);
  }
  function u(f) {
    const p = s(f) - s(o), v = r(f) - r(a) > 170;
    return o = f, v && (a = f), p;
  }
  function d(f) {
    if (!a || !o) return 0;
    const p = s(o) - s(a), v = r(f) - r(a), m = r(f) - r(o) > 170, h = p / v;
    return v && !m && Ct(h) > 0.1 ? h : 0;
  }
  return {
    pointerDown: i,
    pointerMove: u,
    pointerUp: d,
    readPoint: s
  };
}
function LR() {
  function e(n) {
    const {
      offsetTop: a,
      offsetLeft: o,
      offsetWidth: r,
      offsetHeight: s
    } = n;
    return {
      top: a,
      right: o + r,
      bottom: a + s,
      left: o,
      width: r,
      height: s
    };
  }
  return {
    measure: e
  };
}
function zR(e) {
  function t(a) {
    return e * (a / 100);
  }
  return {
    measure: t
  };
}
function HR(e, t, n, a, o, r, s) {
  const i = [e].concat(a);
  let u, d, c = [], f = !1;
  function p(_) {
    return o.measureSize(s.measure(_));
  }
  function v(_) {
    if (!r) return;
    d = p(e), c = a.map(p);
    function x(S) {
      for (const $ of S) {
        if (f) return;
        const D = $.target === e, B = a.indexOf($.target), k = D ? d : c[B], M = p(D ? e : a[B]);
        if (Ct(M - k) >= 0.5) {
          _.reInit(), t.emit("resize");
          break;
        }
      }
    }
    u = new ResizeObserver((S) => {
      (Tu(r) || r(_, S)) && x(S);
    }), n.requestAnimationFrame(() => {
      i.forEach((S) => u.observe(S));
    });
  }
  function m() {
    f = !0, u && u.disconnect();
  }
  return {
    init: v,
    destroy: m
  };
}
function UR(e, t, n, a, o, r) {
  let s = 0, i = 0, u = o, d = r, c = e.get(), f = 0;
  function p() {
    const k = a.get() - e.get(), M = !u;
    let I = 0;
    return M ? (s = 0, n.set(a), e.set(a), I = k) : (n.set(e), s += k / u, s *= d, c += s, e.add(s), I = c - f), i = Bp(I), f = c, B;
  }
  function v() {
    const k = a.get() - t.get();
    return Ct(k) < 1e-3;
  }
  function m() {
    return u;
  }
  function h() {
    return i;
  }
  function _() {
    return s;
  }
  function x() {
    return $(o);
  }
  function S() {
    return D(r);
  }
  function $(k) {
    return u = k, B;
  }
  function D(k) {
    return d = k, B;
  }
  const B = {
    direction: h,
    duration: m,
    velocity: _,
    seek: p,
    settled: v,
    useBaseFriction: S,
    useBaseDuration: x,
    useFriction: D,
    useDuration: $
  };
  return B;
}
function jR(e, t, n, a, o) {
  const r = o.measure(10), s = o.measure(50), i = _o(0.1, 0.99);
  let u = !1;
  function d() {
    return !(u || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function c(v) {
    if (!d()) return;
    const m = e.reachedMin(t.get()) ? "min" : "max", h = Ct(e[m] - t.get()), _ = n.get() - t.get(), x = i.constrain(h / s);
    n.subtract(_ * x), !v && Ct(_) < r && (n.set(e.constrain(n.get())), a.useDuration(25).useBaseFriction());
  }
  function f(v) {
    u = !v;
  }
  return {
    shouldConstrain: d,
    constrain: c,
    toggleActive: f
  };
}
function WR(e, t, n, a, o) {
  const r = _o(-t + e, 0), s = f(), i = c(), u = p();
  function d(m, h) {
    return ls(m, h) <= 1;
  }
  function c() {
    const m = s[0], h = zn(s), _ = s.lastIndexOf(m), x = s.indexOf(h) + 1;
    return _o(_, x);
  }
  function f() {
    return n.map((m, h) => {
      const {
        min: _,
        max: x
      } = r, S = r.constrain(m), $ = !h, D = Pp(n, h);
      return $ ? x : D || d(_, S) ? _ : d(x, S) ? x : S;
    }).map((m) => parseFloat(m.toFixed(3)));
  }
  function p() {
    if (t <= e + o) return [r.max];
    if (a === "keepSnaps") return s;
    const {
      min: m,
      max: h
    } = i;
    return s.slice(m, h);
  }
  return {
    snapsContained: u,
    scrollContainLimit: i
  };
}
function KR(e, t, n) {
  const a = t[0], o = n ? a - e : zn(t);
  return {
    limit: _o(o, a)
  };
}
function GR(e, t, n, a) {
  const r = t.min + 0.1, s = t.max + 0.1, {
    reachedMin: i,
    reachedMax: u
  } = _o(r, s);
  function d(p) {
    return p === 1 ? u(n.get()) : p === -1 ? i(n.get()) : !1;
  }
  function c(p) {
    if (!d(p)) return;
    const v = e * (p * -1);
    a.forEach((m) => m.add(v));
  }
  return {
    loop: c
  };
}
function YR(e) {
  const {
    max: t,
    length: n
  } = e;
  function a(r) {
    const s = r - t;
    return n ? s / -n : 0;
  }
  return {
    get: a
  };
}
function XR(e, t, n, a, o) {
  const {
    startEdge: r,
    endEdge: s
  } = e, {
    groupSlides: i
  } = o, u = f().map(t.measure), d = p(), c = v();
  function f() {
    return i(a).map((h) => zn(h)[s] - h[0][r]).map(Ct);
  }
  function p() {
    return a.map((h) => n[r] - h[r]).map((h) => -Ct(h));
  }
  function v() {
    return i(d).map((h) => h[0]).map((h, _) => h + u[_]);
  }
  return {
    snaps: d,
    snapsAligned: c
  };
}
function JR(e, t, n, a, o, r) {
  const {
    groupSlides: s
  } = o, {
    min: i,
    max: u
  } = a, d = c();
  function c() {
    const p = s(r), v = !e || t === "keepSnaps";
    return n.length === 1 ? [r] : v ? p : p.slice(i, u).map((m, h, _) => {
      const x = !h, S = Pp(_, h);
      if (x) {
        const $ = zn(_[0]) + 1;
        return Vm($);
      }
      if (S) {
        const $ = Js(r) - zn(_)[0] + 1;
        return Vm($, zn(_)[0]);
      }
      return m;
    });
  }
  return {
    slideRegistry: d
  };
}
function ZR(e, t, n, a, o) {
  const {
    reachedAny: r,
    removeOffset: s,
    constrain: i
  } = a;
  function u(m) {
    return m.concat().sort((h, _) => Ct(h) - Ct(_))[0];
  }
  function d(m) {
    const h = e ? s(m) : i(m), _ = t.map((S, $) => ({
      diff: c(S - h, 0),
      index: $
    })).sort((S, $) => Ct(S.diff) - Ct($.diff)), {
      index: x
    } = _[0];
    return {
      index: x,
      distance: h
    };
  }
  function c(m, h) {
    const _ = [m, m + n, m - n];
    if (!e) return m;
    if (!h) return u(_);
    const x = _.filter((S) => Bp(S) === h);
    return x.length ? u(x) : zn(_) - n;
  }
  function f(m, h) {
    const _ = t[m] - o.get(), x = c(_, h);
    return {
      index: m,
      distance: x
    };
  }
  function p(m, h) {
    const _ = o.get() + m, {
      index: x,
      distance: S
    } = d(_), $ = !e && r(_);
    if (!h || $) return {
      index: x,
      distance: m
    };
    const D = t[x] - S, B = m + c(D, 0);
    return {
      index: x,
      distance: B
    };
  }
  return {
    byDistance: p,
    byIndex: f,
    shortcut: c
  };
}
function QR(e, t, n, a, o, r, s) {
  function i(f) {
    const p = f.distance, v = f.index !== t.get();
    r.add(p), p && (a.duration() ? e.start() : (e.update(), e.render(1), e.update())), v && (n.set(t.get()), t.set(f.index), s.emit("select"));
  }
  function u(f, p) {
    const v = o.byDistance(f, p);
    i(v);
  }
  function d(f, p) {
    const v = t.clone().set(f), m = o.byIndex(v.get(), p);
    i(m);
  }
  return {
    distance: u,
    index: d
  };
}
function eq(e, t, n, a, o, r, s, i) {
  const u = {
    passive: !0,
    capture: !0
  };
  let d = 0;
  function c(v) {
    if (!i) return;
    function m(h) {
      if ((/* @__PURE__ */ new Date()).getTime() - d > 10) return;
      s.emit("slideFocusStart"), e.scrollLeft = 0;
      const S = n.findIndex(($) => $.includes(h));
      $p(S) && (o.useDuration(0), a.index(S, 0), s.emit("slideFocus"));
    }
    r.add(document, "keydown", f, !1), t.forEach((h, _) => {
      r.add(h, "focus", (x) => {
        (Tu(i) || i(v, x)) && m(_);
      }, u);
    });
  }
  function f(v) {
    v.code === "Tab" && (d = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: c
  };
}
function Qr(e) {
  let t = e;
  function n() {
    return t;
  }
  function a(u) {
    t = s(u);
  }
  function o(u) {
    t += s(u);
  }
  function r(u) {
    t -= s(u);
  }
  function s(u) {
    return $p(u) ? u : u.get();
  }
  return {
    get: n,
    set: a,
    add: o,
    subtract: r
  };
}
function Q0(e, t) {
  const n = e.scroll === "x" ? s : i, a = t.style;
  let o = null, r = !1;
  function s(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function i(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function u(p) {
    if (r) return;
    const v = IR(e.direction(p));
    v !== o && (a.transform = n(v), o = v);
  }
  function d(p) {
    r = !p;
  }
  function c() {
    r || (a.transform = "", t.getAttribute("style") || t.removeAttribute("style"));
  }
  return {
    clear: c,
    to: u,
    toggleActive: d
  };
}
function tq(e, t, n, a, o, r, s, i, u) {
  const c = Cs(o), f = Cs(o).reverse(), p = x().concat(S());
  function v(M, I) {
    return M.reduce((T, P) => T - o[P], I);
  }
  function m(M, I) {
    return M.reduce((T, P) => v(T, I) > 0 ? T.concat([P]) : T, []);
  }
  function h(M) {
    return r.map((I, T) => ({
      start: I - a[T] + 0.5 + M,
      end: I + t - 0.5 + M
    }));
  }
  function _(M, I, T) {
    const P = h(I);
    return M.map((q) => {
      const R = T ? 0 : -n, Q = T ? n : 0, ee = T ? "end" : "start", K = P[q][ee];
      return {
        index: q,
        loopPoint: K,
        slideLocation: Qr(-1),
        translate: Q0(e, u[q]),
        target: () => i.get() > K ? R : Q
      };
    });
  }
  function x() {
    const M = s[0], I = m(f, M);
    return _(I, n, !1);
  }
  function S() {
    const M = t - s[0] - 1, I = m(c, M);
    return _(I, -n, !0);
  }
  function $() {
    return p.every(({
      index: M
    }) => {
      const I = c.filter((T) => T !== M);
      return v(I, t) <= 0.1;
    });
  }
  function D() {
    p.forEach((M) => {
      const {
        target: I,
        translate: T,
        slideLocation: P
      } = M, q = I();
      q !== P.get() && (T.to(q), P.set(q));
    });
  }
  function B() {
    p.forEach((M) => M.translate.clear());
  }
  return {
    canLoop: $,
    clear: B,
    loop: D,
    loopPoints: p
  };
}
function nq(e, t, n) {
  let a, o = !1;
  function r(u) {
    if (!n) return;
    function d(c) {
      for (const f of c)
        if (f.type === "childList") {
          u.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    a = new MutationObserver((c) => {
      o || (Tu(n) || n(u, c)) && d(c);
    }), a.observe(e, {
      childList: !0
    });
  }
  function s() {
    a && a.disconnect(), o = !0;
  }
  return {
    init: r,
    destroy: s
  };
}
function aq(e, t, n, a) {
  const o = {};
  let r = null, s = null, i, u = !1;
  function d() {
    i = new IntersectionObserver((m) => {
      u || (m.forEach((h) => {
        const _ = t.indexOf(h.target);
        o[_] = h;
      }), r = null, s = null, n.emit("slidesInView"));
    }, {
      root: e.parentElement,
      threshold: a
    }), t.forEach((m) => i.observe(m));
  }
  function c() {
    i && i.disconnect(), u = !0;
  }
  function f(m) {
    return Ss(o).reduce((h, _) => {
      const x = parseInt(_), {
        isIntersecting: S
      } = o[x];
      return (m && S || !m && !S) && h.push(x), h;
    }, []);
  }
  function p(m = !0) {
    if (m && r) return r;
    if (!m && s) return s;
    const h = f(m);
    return m && (r = h), m || (s = h), h;
  }
  return {
    init: d,
    destroy: c,
    get: p
  };
}
function oq(e, t, n, a, o, r) {
  const {
    measureSize: s,
    startEdge: i,
    endEdge: u
  } = e, d = n[0] && o, c = m(), f = h(), p = n.map(s), v = _();
  function m() {
    if (!d) return 0;
    const S = n[0];
    return Ct(t[i] - S[i]);
  }
  function h() {
    if (!d) return 0;
    const S = r.getComputedStyle(zn(a));
    return parseFloat(S.getPropertyValue(`margin-${u}`));
  }
  function _() {
    return n.map((S, $, D) => {
      const B = !$, k = Pp(D, $);
      return B ? p[$] + c : k ? p[$] + f : D[$ + 1][i] - S[i];
    }).map(Ct);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: v,
    startGap: c,
    endGap: f
  };
}
function rq(e, t, n, a, o, r, s, i, u) {
  const {
    startEdge: d,
    endEdge: c,
    direction: f
  } = e, p = $p(n);
  function v(x, S) {
    return Cs(x).filter(($) => $ % S === 0).map(($) => x.slice($, $ + S));
  }
  function m(x) {
    return x.length ? Cs(x).reduce((S, $, D) => {
      const B = zn(S) || 0, k = B === 0, M = $ === Js(x), I = o[d] - r[B][d], T = o[d] - r[$][c], P = !a && k ? f(s) : 0, q = !a && M ? f(i) : 0, R = Ct(T - q - (I + P));
      return D && R > t + u && S.push($), M && S.push(x.length), S;
    }, []).map((S, $, D) => {
      const B = Math.max(D[$ - 1] || 0);
      return x.slice(B, S);
    }) : [];
  }
  function h(x) {
    return p ? v(x, n) : m(x);
  }
  return {
    groupSlides: h
  };
}
function sq(e, t, n, a, o, r, s) {
  const {
    align: i,
    axis: u,
    direction: d,
    startIndex: c,
    loop: f,
    duration: p,
    dragFree: v,
    dragThreshold: m,
    inViewThreshold: h,
    slidesToScroll: _,
    skipSnaps: x,
    containScroll: S,
    watchResize: $,
    watchSlides: D,
    watchDrag: B,
    watchFocus: k
  } = r, M = 2, I = LR(), T = I.measure(t), P = n.map(I.measure), q = FR(u, d), R = q.measureSize(T), Q = zR(R), ee = RR(i, R), K = !f && !!S, W = f || !!S, {
    slideSizes: j,
    slideSizesWithGaps: J,
    startGap: z,
    endGap: Y
  } = oq(q, T, P, n, W, o), Z = rq(q, R, _, f, T, P, z, Y, M), {
    snaps: pe,
    snapsAligned: $e
  } = XR(q, ee, T, P, Z), Ce = -zn(pe) + zn(J), {
    snapsContained: De,
    scrollContainLimit: ue
  } = WR(R, Ce, $e, S, M), V = K ? De : $e, {
    limit: te
  } = KR(Ce, V, f), H = Z0(Js(V), c, f), re = H.clone(), ie = Cs(n), L = ({
    dragHandler: bt,
    scrollBody: G,
    scrollBounds: X,
    options: {
      loop: de
    }
  }) => {
    de || X.constrain(bt.pointerDown()), G.seek();
  }, _e = ({
    scrollBody: bt,
    translate: G,
    location: X,
    offsetLocation: de,
    previousLocation: ge,
    scrollLooper: ke,
    slideLooper: Ie,
    dragHandler: Oe,
    animation: et,
    eventHandler: _t,
    scrollBounds: Ft,
    options: {
      loop: ut
    }
  }, Tt) => {
    const Ut = bt.settled(), sn = !Ft.shouldConstrain(), Ia = ut ? Ut : Ut && sn, qo = Ia && !Oe.pointerDown();
    qo && et.stop();
    const Rr = X.get() * Tt + ge.get() * (1 - Tt);
    de.set(Rr), ut && (ke.loop(bt.direction()), Ie.loop()), G.to(de.get()), qo && _t.emit("settle"), Ia || _t.emit("scroll");
  }, we = qR(a, o, () => L(dt), (bt) => _e(dt, bt)), Te = 0.68, Ne = V[H.get()], Je = Qr(Ne), xe = Qr(Ne), ze = Qr(Ne), je = Qr(Ne), Ke = UR(Je, ze, xe, je, p, Te), lt = ZR(f, V, Ce, te, je), it = QR(we, H, re, Ke, lt, je, s), St = YR(te), Xt = $s(), an = aq(t, n, s, h), {
    slideRegistry: Ae
  } = JR(K, S, V, ue, Z, ie), st = eq(e, n, Ae, it, Ke, Xt, s, k), dt = {
    ownerDocument: a,
    ownerWindow: o,
    eventHandler: s,
    containerRect: T,
    slideRects: P,
    animation: we,
    axis: q,
    dragHandler: VR(q, e, a, o, je, NR(q, o), Je, we, it, Ke, lt, H, s, Q, v, m, x, Te, B),
    eventStore: Xt,
    percentOfView: Q,
    index: H,
    indexPrevious: re,
    limit: te,
    location: Je,
    offsetLocation: ze,
    previousLocation: xe,
    options: r,
    resizeHandler: HR(t, s, o, n, q, $, I),
    scrollBody: Ke,
    scrollBounds: jR(te, ze, je, Ke, Q),
    scrollLooper: GR(Ce, te, ze, [Je, ze, xe, je]),
    scrollProgress: St,
    scrollSnapList: V.map(St.get),
    scrollSnaps: V,
    scrollTarget: lt,
    scrollTo: it,
    slideLooper: tq(q, R, Ce, j, J, pe, V, ze, n),
    slideFocus: st,
    slidesHandler: nq(t, s, D),
    slidesInView: an,
    slideIndexes: ie,
    slideRegistry: Ae,
    slidesToScroll: Z,
    target: je,
    translate: Q0(q, t)
  };
  return dt;
}
function lq() {
  let e = {}, t;
  function n(d) {
    t = d;
  }
  function a(d) {
    return e[d] || [];
  }
  function o(d) {
    return a(d).forEach((c) => c(t, d)), u;
  }
  function r(d, c) {
    return e[d] = a(d).concat([c]), u;
  }
  function s(d, c) {
    return e[d] = a(d).filter((f) => f !== c), u;
  }
  function i() {
    e = {};
  }
  const u = {
    init: n,
    emit: o,
    off: s,
    on: r,
    clear: i
  };
  return u;
}
const iq = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function uq(e) {
  function t(r, s) {
    return J0(r, s || {});
  }
  function n(r) {
    const s = r.breakpoints || {}, i = Ss(s).filter((u) => e.matchMedia(u).matches).map((u) => s[u]).reduce((u, d) => t(u, d), {});
    return t(r, i);
  }
  function a(r) {
    return r.map((s) => Ss(s.breakpoints || {})).reduce((s, i) => s.concat(i), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: a
  };
}
function dq(e) {
  let t = [];
  function n(r, s) {
    return t = s.filter(({
      options: i
    }) => e.optionsAtMedia(i).active !== !1), t.forEach((i) => i.init(r, e)), s.reduce((i, u) => Object.assign(i, {
      [u.name]: u
    }), {});
  }
  function a() {
    t = t.filter((r) => r.destroy());
  }
  return {
    init: n,
    destroy: a
  };
}
function yi(e, t, n) {
  const a = e.ownerDocument, o = a.defaultView, r = uq(o), s = dq(r), i = $s(), u = lq(), {
    mergeOptions: d,
    optionsAtMedia: c,
    optionsMediaQueries: f
  } = r, {
    on: p,
    off: v,
    emit: m
  } = u, h = q;
  let _ = !1, x, S = d(iq, yi.globalOptions), $ = d(S), D = [], B, k, M;
  function I() {
    const {
      container: ie,
      slides: L
    } = $;
    k = (bc(ie) ? e.querySelector(ie) : ie) || e.children[0];
    const we = bc(L) ? k.querySelectorAll(L) : L;
    M = [].slice.call(we || k.children);
  }
  function T(ie) {
    const L = sq(e, k, M, a, o, ie, u);
    if (ie.loop && !L.slideLooper.canLoop()) {
      const _e = Object.assign({}, ie, {
        loop: !1
      });
      return T(_e);
    }
    return L;
  }
  function P(ie, L) {
    _ || (S = d(S, ie), $ = c(S), D = L || D, I(), x = T($), f([S, ...D.map(({
      options: _e
    }) => _e)]).forEach((_e) => i.add(_e, "change", q)), $.active && (x.translate.to(x.location.get()), x.animation.init(), x.slidesInView.init(), x.slideFocus.init(re), x.eventHandler.init(re), x.resizeHandler.init(re), x.slidesHandler.init(re), x.options.loop && x.slideLooper.loop(), k.offsetParent && M.length && x.dragHandler.init(re), B = s.init(re, D)));
  }
  function q(ie, L) {
    const _e = Z();
    R(), P(d({
      startIndex: _e
    }, ie), L), u.emit("reInit");
  }
  function R() {
    x.dragHandler.destroy(), x.eventStore.clear(), x.translate.clear(), x.slideLooper.clear(), x.resizeHandler.destroy(), x.slidesHandler.destroy(), x.slidesInView.destroy(), x.animation.destroy(), s.destroy(), i.clear();
  }
  function Q() {
    _ || (_ = !0, i.clear(), R(), u.emit("destroy"), u.clear());
  }
  function ee(ie, L, _e) {
    !$.active || _ || (x.scrollBody.useBaseFriction().useDuration(L === !0 ? 0 : $.duration), x.scrollTo.index(ie, _e || 0));
  }
  function K(ie) {
    const L = x.index.add(1).get();
    ee(L, ie, -1);
  }
  function W(ie) {
    const L = x.index.add(-1).get();
    ee(L, ie, 1);
  }
  function j() {
    return x.index.add(1).get() !== Z();
  }
  function J() {
    return x.index.add(-1).get() !== Z();
  }
  function z() {
    return x.scrollSnapList;
  }
  function Y() {
    return x.scrollProgress.get(x.offsetLocation.get());
  }
  function Z() {
    return x.index.get();
  }
  function pe() {
    return x.indexPrevious.get();
  }
  function $e() {
    return x.slidesInView.get();
  }
  function Ce() {
    return x.slidesInView.get(!1);
  }
  function De() {
    return B;
  }
  function ue() {
    return x;
  }
  function V() {
    return e;
  }
  function te() {
    return k;
  }
  function H() {
    return M;
  }
  const re = {
    canScrollNext: j,
    canScrollPrev: J,
    containerNode: te,
    internalEngine: ue,
    destroy: Q,
    off: v,
    on: p,
    emit: m,
    plugins: De,
    previousScrollSnap: pe,
    reInit: h,
    rootNode: V,
    scrollNext: K,
    scrollPrev: W,
    scrollProgress: Y,
    scrollSnapList: z,
    scrollTo: ee,
    selectedScrollSnap: Z,
    slideNodes: H,
    slidesInView: $e,
    slidesNotInView: Ce
  };
  return P(t, n), setTimeout(() => u.emit("init"), 0), re;
}
yi.globalOptions = void 0;
function Ep(e = {}, t = []) {
  const n = ht(e), a = ht(t);
  let o = n ? e.value : e, r = a ? t.value : t;
  const s = Zt(), i = Zt();
  function u() {
    i.value && i.value.reInit(o, r);
  }
  return be(() => {
    !OR() || !s.value || (yi.globalOptions = Ep.globalOptions, i.value = yi(s.value, o, r));
  }), ka(() => {
    i.value && i.value.destroy();
  }), n && ce(e, (d) => {
    Sp(o, d) || (o = d, u());
  }), a && ce(t, (d) => {
    TR(r, d) || (r = d, u());
  }), [s, i];
}
Ep.globalOptions = void 0;
const [cq, fq] = NP(
  ({ opts: e, orientation: t, plugins: n }, a) => {
    const [o, r] = Ep(
      {
        ...e,
        axis: t === "horizontal" ? "x" : "y"
      },
      n
    );
    function s() {
      var f;
      (f = r.value) == null || f.scrollPrev();
    }
    function i() {
      var f;
      (f = r.value) == null || f.scrollNext();
    }
    const u = O(!1), d = O(!1);
    function c(f) {
      u.value = (f == null ? void 0 : f.canScrollNext()) || !1, d.value = (f == null ? void 0 : f.canScrollPrev()) || !1;
    }
    return be(() => {
      var f, p, v;
      r.value && ((f = r.value) == null || f.on("init", c), (p = r.value) == null || p.on("reInit", c), (v = r.value) == null || v.on("select", c), a("init-api", r.value));
    }), {
      carouselRef: o,
      carouselApi: r,
      canScrollPrev: d,
      canScrollNext: u,
      scrollPrev: s,
      scrollNext: i,
      orientation: t
    };
  }
);
function Au() {
  const e = fq();
  if (!e) throw new Error("useCarousel must be used within a <Carousel />");
  return e;
}
const kj = /* @__PURE__ */ b({
  __name: "Carousel",
  props: {
    opts: {},
    plugins: {},
    orientation: { default: "horizontal" },
    class: {}
  },
  emits: ["init-api"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, {
      canScrollNext: r,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    } = cq(a, o);
    t({
      canScrollNext: r,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    });
    function p(v) {
      const m = a.orientation === "vertical" ? "ArrowUp" : "ArrowLeft", h = a.orientation === "vertical" ? "ArrowDown" : "ArrowRight";
      if (v.key === m) {
        v.preventDefault(), f();
        return;
      }
      v.key === h && (v.preventDefault(), c());
    }
    return (v, m) => (g(), U("div", {
      class: ae(l(F)("relative", a.class)),
      role: "region",
      "aria-roledescription": "carousel",
      tabindex: "0",
      onKeydown: p
    }, [
      w(v.$slots, "default", {
        canScrollNext: l(r),
        canScrollPrev: l(s),
        carouselApi: l(i),
        carouselRef: l(u),
        orientation: l(d),
        scrollNext: l(c),
        scrollPrev: l(f)
      })
    ], 34));
  }
}), Oj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CarouselContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { carouselRef: n, orientation: a } = Au();
    return (o, r) => (g(), U("div", {
      ref_key: "carouselRef",
      ref: n,
      class: "overflow-hidden"
    }, [
      ye("div", A({
        class: l(F)("flex", l(a) === "horizontal" ? "-ml-4" : "-mt-4 flex-col", t.class)
      }, o.$attrs), [
        w(o.$slots, "default")
      ], 16)
    ], 512));
  }
}), Tj = /* @__PURE__ */ b({
  __name: "CarouselItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n } = Au();
    return (a, o) => (g(), U("div", {
      role: "group",
      "aria-roledescription": "slide",
      class: ae(
        l(F)(
          "min-w-0 shrink-0 grow-0 basis-full",
          l(n) === "horizontal" ? "pl-4" : "pt-4",
          t.class
        )
      )
    }, [
      w(a.$slots, "default")
    ], 2));
  }
}), Aj = /* @__PURE__ */ b({
  __name: "CarouselPrevious",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollPrev: a, scrollPrev: o } = Au();
    return (r, s) => (g(), C(l(Eu), {
      disabled: !l(a),
      class: ae(
        l(F)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -left-12 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(o)
    }, {
      default: y(() => [
        w(r.$slots, "default", {}, () => [
          N(l(I6), { class: "size-4 text-current" }),
          s[0] || (s[0] = ye("span", { class: "sr-only" }, "Previous Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
}), Ij = /* @__PURE__ */ b({
  __name: "CarouselNext",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollNext: a, scrollNext: o } = Au();
    return (r, s) => (g(), C(l(Eu), {
      disabled: !l(a),
      class: ae(
        l(F)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -right-12 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(o)
    }, {
      default: y(() => [
        w(r.$slots, "default", {}, () => [
          N(l(R6), { class: "size-4 text-current" }),
          s[0] || (s[0] = ye("span", { class: "sr-only" }, "Next Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
});
var wc = "http://www.w3.org/1999/xhtml";
const Nm = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: wc,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Iu(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Nm.hasOwnProperty(t) ? { space: Nm[t], local: e } : e;
}
function pq(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === wc && t.documentElement.namespaceURI === wc ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function vq(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function e_(e) {
  var t = Iu(e);
  return (t.local ? vq : pq)(t);
}
function mq() {
}
function Dp(e) {
  return e == null ? mq : function() {
    return this.querySelector(e);
  };
}
function hq(e) {
  typeof e != "function" && (e = Dp(e));
  for (var t = this._groups, n = t.length, a = new Array(n), o = 0; o < n; ++o)
    for (var r = t[o], s = r.length, i = a[o] = new Array(s), u, d, c = 0; c < s; ++c)
      (u = r[c]) && (d = e.call(u, u.__data__, c, r)) && ("__data__" in u && (d.__data__ = u.__data__), i[c] = d);
  return new Sn(a, this._parents);
}
function gq(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function yq() {
  return [];
}
function t_(e) {
  return e == null ? yq : function() {
    return this.querySelectorAll(e);
  };
}
function bq(e) {
  return function() {
    return gq(e.apply(this, arguments));
  };
}
function _q(e) {
  typeof e == "function" ? e = bq(e) : e = t_(e);
  for (var t = this._groups, n = t.length, a = [], o = [], r = 0; r < n; ++r)
    for (var s = t[r], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && (a.push(e.call(u, u.__data__, d, s)), o.push(u));
  return new Sn(a, o);
}
function n_(e) {
  return function() {
    return this.matches(e);
  };
}
function a_(e) {
  return function(t) {
    return t.matches(e);
  };
}
var wq = Array.prototype.find;
function xq(e) {
  return function() {
    return wq.call(this.children, e);
  };
}
function Cq() {
  return this.firstElementChild;
}
function Sq(e) {
  return this.select(e == null ? Cq : xq(typeof e == "function" ? e : a_(e)));
}
var $q = Array.prototype.filter;
function Bq() {
  return Array.from(this.children);
}
function Pq(e) {
  return function() {
    return $q.call(this.children, e);
  };
}
function Eq(e) {
  return this.selectAll(e == null ? Bq : Pq(typeof e == "function" ? e : a_(e)));
}
function Dq(e) {
  typeof e != "function" && (e = n_(e));
  for (var t = this._groups, n = t.length, a = new Array(n), o = 0; o < n; ++o)
    for (var r = t[o], s = r.length, i = a[o] = [], u, d = 0; d < s; ++d)
      (u = r[d]) && e.call(u, u.__data__, d, r) && i.push(u);
  return new Sn(a, this._parents);
}
function o_(e) {
  return new Array(e.length);
}
function Mq() {
  return new Sn(this._enter || this._groups.map(o_), this._parents);
}
function bi(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
bi.prototype = {
  constructor: bi,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function kq(e) {
  return function() {
    return e;
  };
}
function Oq(e, t, n, a, o, r) {
  for (var s = 0, i, u = t.length, d = r.length; s < d; ++s)
    (i = t[s]) ? (i.__data__ = r[s], a[s] = i) : n[s] = new bi(e, r[s]);
  for (; s < u; ++s)
    (i = t[s]) && (o[s] = i);
}
function Tq(e, t, n, a, o, r, s) {
  var i, u, d = /* @__PURE__ */ new Map(), c = t.length, f = r.length, p = new Array(c), v;
  for (i = 0; i < c; ++i)
    (u = t[i]) && (p[i] = v = s.call(u, u.__data__, i, t) + "", d.has(v) ? o[i] = u : d.set(v, u));
  for (i = 0; i < f; ++i)
    v = s.call(e, r[i], i, r) + "", (u = d.get(v)) ? (a[i] = u, u.__data__ = r[i], d.delete(v)) : n[i] = new bi(e, r[i]);
  for (i = 0; i < c; ++i)
    (u = t[i]) && d.get(p[i]) === u && (o[i] = u);
}
function Aq(e) {
  return e.__data__;
}
function Iq(e, t) {
  if (!arguments.length) return Array.from(this, Aq);
  var n = t ? Tq : Oq, a = this._parents, o = this._groups;
  typeof e != "function" && (e = kq(e));
  for (var r = o.length, s = new Array(r), i = new Array(r), u = new Array(r), d = 0; d < r; ++d) {
    var c = a[d], f = o[d], p = f.length, v = Rq(e.call(c, c && c.__data__, d, a)), m = v.length, h = i[d] = new Array(m), _ = s[d] = new Array(m), x = u[d] = new Array(p);
    n(c, f, h, _, x, v, t);
    for (var S = 0, $ = 0, D, B; S < m; ++S)
      if (D = h[S]) {
        for (S >= $ && ($ = S + 1); !(B = _[$]) && ++$ < m; ) ;
        D._next = B || null;
      }
  }
  return s = new Sn(s, a), s._enter = i, s._exit = u, s;
}
function Rq(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function qq() {
  return new Sn(this._exit || this._groups.map(o_), this._parents);
}
function Fq(e, t, n) {
  var a = this.enter(), o = this, r = this.exit();
  return typeof e == "function" ? (a = e(a), a && (a = a.selection())) : a = a.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? r.remove() : n(r), a && o ? a.merge(o).order() : o;
}
function Vq(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, a = t._groups, o = n.length, r = a.length, s = Math.min(o, r), i = new Array(o), u = 0; u < s; ++u)
    for (var d = n[u], c = a[u], f = d.length, p = i[u] = new Array(f), v, m = 0; m < f; ++m)
      (v = d[m] || c[m]) && (p[m] = v);
  for (; u < o; ++u)
    i[u] = n[u];
  return new Sn(i, this._parents);
}
function Nq() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var a = e[t], o = a.length - 1, r = a[o], s; --o >= 0; )
      (s = a[o]) && (r && s.compareDocumentPosition(r) ^ 4 && r.parentNode.insertBefore(s, r), r = s);
  return this;
}
function Lq(e) {
  e || (e = zq);
  function t(f, p) {
    return f && p ? e(f.__data__, p.__data__) : !f - !p;
  }
  for (var n = this._groups, a = n.length, o = new Array(a), r = 0; r < a; ++r) {
    for (var s = n[r], i = s.length, u = o[r] = new Array(i), d, c = 0; c < i; ++c)
      (d = s[c]) && (u[c] = d);
    u.sort(t);
  }
  return new Sn(o, this._parents).order();
}
function zq(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Hq() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function Uq() {
  return Array.from(this);
}
function jq() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], o = 0, r = a.length; o < r; ++o) {
      var s = a[o];
      if (s) return s;
    }
  return null;
}
function Wq() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function Kq() {
  return !this.node();
}
function Gq(e) {
  for (var t = this._groups, n = 0, a = t.length; n < a; ++n)
    for (var o = t[n], r = 0, s = o.length, i; r < s; ++r)
      (i = o[r]) && e.call(i, i.__data__, r, o);
  return this;
}
function Yq(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Xq(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Jq(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Zq(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Qq(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function eF(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function tF(e, t) {
  var n = Iu(e);
  if (arguments.length < 2) {
    var a = this.node();
    return n.local ? a.getAttributeNS(n.space, n.local) : a.getAttribute(n);
  }
  return this.each((t == null ? n.local ? Xq : Yq : typeof t == "function" ? n.local ? eF : Qq : n.local ? Zq : Jq)(n, t));
}
function r_(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function nF(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function aF(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function oF(e, t, n) {
  return function() {
    var a = t.apply(this, arguments);
    a == null ? this.style.removeProperty(e) : this.style.setProperty(e, a, n);
  };
}
function rF(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? nF : typeof t == "function" ? oF : aF)(e, t, n ?? "")) : fr(this.node(), e);
}
function fr(e, t) {
  return e.style.getPropertyValue(t) || r_(e).getComputedStyle(e, null).getPropertyValue(t);
}
function sF(e) {
  return function() {
    delete this[e];
  };
}
function lF(e, t) {
  return function() {
    this[e] = t;
  };
}
function iF(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function uF(e, t) {
  return arguments.length > 1 ? this.each((t == null ? sF : typeof t == "function" ? iF : lF)(e, t)) : this.node()[e];
}
function s_(e) {
  return e.trim().split(/^|\s+/);
}
function Mp(e) {
  return e.classList || new l_(e);
}
function l_(e) {
  this._node = e, this._names = s_(e.getAttribute("class") || "");
}
l_.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function i_(e, t) {
  for (var n = Mp(e), a = -1, o = t.length; ++a < o; ) n.add(t[a]);
}
function u_(e, t) {
  for (var n = Mp(e), a = -1, o = t.length; ++a < o; ) n.remove(t[a]);
}
function dF(e) {
  return function() {
    i_(this, e);
  };
}
function cF(e) {
  return function() {
    u_(this, e);
  };
}
function fF(e, t) {
  return function() {
    (t.apply(this, arguments) ? i_ : u_)(this, e);
  };
}
function pF(e, t) {
  var n = s_(e + "");
  if (arguments.length < 2) {
    for (var a = Mp(this.node()), o = -1, r = n.length; ++o < r; ) if (!a.contains(n[o])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? fF : t ? dF : cF)(n, t));
}
function vF() {
  this.textContent = "";
}
function mF(e) {
  return function() {
    this.textContent = e;
  };
}
function hF(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function gF(e) {
  return arguments.length ? this.each(e == null ? vF : (typeof e == "function" ? hF : mF)(e)) : this.node().textContent;
}
function yF() {
  this.innerHTML = "";
}
function bF(e) {
  return function() {
    this.innerHTML = e;
  };
}
function _F(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function wF(e) {
  return arguments.length ? this.each(e == null ? yF : (typeof e == "function" ? _F : bF)(e)) : this.node().innerHTML;
}
function xF() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function CF() {
  return this.each(xF);
}
function SF() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function $F() {
  return this.each(SF);
}
function BF(e) {
  var t = typeof e == "function" ? e : e_(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function PF() {
  return null;
}
function EF(e, t) {
  var n = typeof e == "function" ? e : e_(e), a = t == null ? PF : typeof t == "function" ? t : Dp(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), a.apply(this, arguments) || null);
  });
}
function DF() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function MF() {
  return this.each(DF);
}
function kF() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function OF() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function TF(e) {
  return this.select(e ? OF : kF);
}
function AF(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function IF(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function RF(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", a = t.indexOf(".");
    return a >= 0 && (n = t.slice(a + 1), t = t.slice(0, a)), { type: t, name: n };
  });
}
function qF(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, a = -1, o = t.length, r; n < o; ++n)
        r = t[n], (!e.type || r.type === e.type) && r.name === e.name ? this.removeEventListener(r.type, r.listener, r.options) : t[++a] = r;
      ++a ? t.length = a : delete this.__on;
    }
  };
}
function FF(e, t, n) {
  return function() {
    var a = this.__on, o, r = IF(t);
    if (a) {
      for (var s = 0, i = a.length; s < i; ++s)
        if ((o = a[s]).type === e.type && o.name === e.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = r, o.options = n), o.value = t;
          return;
        }
    }
    this.addEventListener(e.type, r, n), o = { type: e.type, name: e.name, value: t, listener: r, options: n }, a ? a.push(o) : this.__on = [o];
  };
}
function VF(e, t, n) {
  var a = RF(e + ""), o, r = a.length, s;
  if (arguments.length < 2) {
    var i = this.node().__on;
    if (i) {
      for (var u = 0, d = i.length, c; u < d; ++u)
        for (o = 0, c = i[u]; o < r; ++o)
          if ((s = a[o]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (i = t ? FF : qF, o = 0; o < r; ++o) this.each(i(a[o], t, n));
  return this;
}
function d_(e, t, n) {
  var a = r_(e), o = a.CustomEvent;
  typeof o == "function" ? o = new o(t, n) : (o = a.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
}
function NF(e, t) {
  return function() {
    return d_(this, e, t);
  };
}
function LF(e, t) {
  return function() {
    return d_(this, e, t.apply(this, arguments));
  };
}
function zF(e, t) {
  return this.each((typeof t == "function" ? LF : NF)(e, t));
}
function* HF() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], o = 0, r = a.length, s; o < r; ++o)
      (s = a[o]) && (yield s);
}
var c_ = [null];
function Sn(e, t) {
  this._groups = e, this._parents = t;
}
function Zs() {
  return new Sn([[document.documentElement]], c_);
}
function UF() {
  return this;
}
Sn.prototype = Zs.prototype = {
  constructor: Sn,
  select: hq,
  selectAll: _q,
  selectChild: Sq,
  selectChildren: Eq,
  filter: Dq,
  data: Iq,
  enter: Mq,
  exit: qq,
  join: Fq,
  merge: Vq,
  selection: UF,
  order: Nq,
  sort: Lq,
  call: Hq,
  nodes: Uq,
  node: jq,
  size: Wq,
  empty: Kq,
  each: Gq,
  attr: tF,
  style: rF,
  property: uF,
  classed: pF,
  text: gF,
  html: wF,
  raise: CF,
  lower: $F,
  append: BF,
  insert: EF,
  remove: MF,
  clone: TF,
  datum: AF,
  on: VF,
  dispatch: zF,
  [Symbol.iterator]: HF
};
function Xa(e) {
  return typeof e == "string" ? new Sn([[document.querySelector(e)]], [document.documentElement]) : new Sn([[e]], c_);
}
function jF(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function _i(e, t) {
  if (e = jF(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var a = n.createSVGPoint();
      return a.x = e.clientX, a.y = e.clientY, a = a.matrixTransform(t.getScreenCTM().inverse()), [a.x, a.y];
    }
    if (t.getBoundingClientRect) {
      var o = t.getBoundingClientRect();
      return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
var is;
(function(e) {
  e[e.SVG = 0] = "SVG", e[e.HTML = 1] = "HTML";
})(is || (is = {}));
var xc;
(function(e) {
  e.Fit = "fit", e.Extend = "extend", e.FitWidth = "fit_width";
})(xc || (xc = {}));
function us(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function WF(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function kp(e) {
  let t, n, a;
  e.length !== 2 ? (t = us, n = (i, u) => us(e(i), u), a = (i, u) => e(i) - u) : (t = e === us || e === WF ? e : KF, n = e, a = e);
  function o(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) < 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function r(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) <= 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function s(i, u, d = 0, c = i.length) {
    const f = o(i, u, d, c - 1);
    return f > d && a(i[f - 1], u) > -a(i[f], u) ? f - 1 : f;
  }
  return { left: o, center: s, right: r };
}
function KF() {
  return 0;
}
function f_(e) {
  return e === null ? NaN : +e;
}
const p_ = kp(us), Qs = p_.right, GF = p_.left;
kp(f_).center;
class Lm extends Map {
  constructor(t, n = JF) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [a, o] of t) this.set(a, o);
  }
  get(t) {
    return super.get(zm(this, t));
  }
  has(t) {
    return super.has(zm(this, t));
  }
  set(t, n) {
    return super.set(YF(this, t), n);
  }
  delete(t) {
    return super.delete(XF(this, t));
  }
}
function zm({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : n;
}
function YF({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : (e.set(a, n), n);
}
function XF({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) && (n = e.get(a), e.delete(a)), n;
}
function JF(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const ZF = Math.sqrt(50), QF = Math.sqrt(10), eV = Math.sqrt(2);
function wi(e, t, n) {
  const a = (t - e) / Math.max(0, n), o = Math.floor(Math.log10(a)), r = a / Math.pow(10, o), s = r >= ZF ? 10 : r >= QF ? 5 : r >= eV ? 2 : 1;
  let i, u, d;
  return o < 0 ? (d = Math.pow(10, -o) / s, i = Math.round(e * d), u = Math.round(t * d), i / d < e && ++i, u / d > t && --u, d = -d) : (d = Math.pow(10, o) * s, i = Math.round(e / d), u = Math.round(t / d), i * d < e && ++i, u * d > t && --u), u < i && 0.5 <= n && n < 2 ? wi(e, t, n * 2) : [i, u, d];
}
function Cc(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const a = t < e, [o, r, s] = a ? wi(t, e, n) : wi(e, t, n);
  if (!(r >= o)) return [];
  const i = r - o + 1, u = new Array(i);
  if (a)
    if (s < 0) for (let d = 0; d < i; ++d) u[d] = (r - d) / -s;
    else for (let d = 0; d < i; ++d) u[d] = (r - d) * s;
  else if (s < 0) for (let d = 0; d < i; ++d) u[d] = (o + d) / -s;
  else for (let d = 0; d < i; ++d) u[d] = (o + d) * s;
  return u;
}
function Sc(e, t, n) {
  return t = +t, e = +e, n = +n, wi(e, t, n)[2];
}
function $c(e, t, n) {
  t = +t, e = +e, n = +n;
  const a = t < e, o = a ? Sc(t, e, n) : Sc(e, t, n);
  return (a ? -1 : 1) * (o < 0 ? 1 / -o : o);
}
function Hm(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let o of e)
      (o = t(o, ++a, e)) != null && (n < o || n === void 0 && o >= o) && (n = o);
  }
  return n;
}
function Um(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let o of e)
      (o = t(o, ++a, e)) != null && (n > o || n === void 0 && o >= o) && (n = o);
  }
  return n;
}
function tV(e, t, n = f_) {
  if (!(!(a = e.length) || isNaN(t = +t))) {
    if (t <= 0 || a < 2) return +n(e[0], 0, e);
    if (t >= 1) return +n(e[a - 1], a - 1, e);
    var a, o = (a - 1) * t, r = Math.floor(o), s = +n(e[r], r, e), i = +n(e[r + 1], r + 1, e);
    return s + (i - s) * (o - r);
  }
}
function nV(e, t, n) {
  e = +e, t = +t, n = (o = arguments.length) < 2 ? (t = e, e = 0, 1) : o < 3 ? 1 : +n;
  for (var a = -1, o = Math.max(0, Math.ceil((t - e) / n)) | 0, r = new Array(o); ++a < o; )
    r[a] = e + a * n;
  return r;
}
function aV(e, t, n) {
  var a = {}, o = a.noTrailing, r = o === void 0 ? !1 : o, s = a.noLeading, i = s === void 0 ? !1 : s, u = a.debounceMode, d = u === void 0 ? void 0 : u, c, f = !1, p = 0;
  function v() {
    c && clearTimeout(c);
  }
  function m(_) {
    var x = _ || {}, S = x.upcomingOnly, $ = S === void 0 ? !1 : S;
    v(), f = !$;
  }
  function h() {
    for (var _ = arguments.length, x = new Array(_), S = 0; S < _; S++)
      x[S] = arguments[S];
    var $ = this, D = Date.now() - p;
    if (f)
      return;
    function B() {
      p = Date.now(), t.apply($, x);
    }
    function k() {
      c = void 0;
    }
    !i && d && !c && B(), v(), d === void 0 && D > e ? i ? (p = Date.now(), r || (c = setTimeout(d ? k : B, e))) : B() : r !== !0 && (c = setTimeout(d ? k : B, d === void 0 ? e - D : e));
  }
  return h.cancel = m, h;
}
var wa;
(function(e) {
  e.Left = "left", e.Right = "right", e.Auto = "auto";
})(wa || (wa = {}));
const ds = (e) => typeof e == "number", Op = (e) => typeof e == "function", Tp = (e) => Array.isArray(e), oV = (e) => e instanceof Object, xi = (e) => e.constructor.name !== "Function" && e.constructor.name !== "Object", jm = (e) => oV(e) && !Tp(e) && !Op(e) && !xi(e), Bc = (e, t, n = [], a = /* @__PURE__ */ new Set()) => {
  if (Array.isArray(e)) {
    if (!Array.isArray(t) || e.length !== t.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (let o = 0; o < e.length; o++)
      if (!Bc(e[o], t[o], n, a))
        return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (typeof e == "object" && e !== null && t !== null) {
    if (typeof t != "object")
      return !1;
    if (e === t)
      return !0;
    const o = Object.keys(e).filter((s) => !n.includes(s)), r = Object.keys(t).filter((s) => !n.includes(s));
    if (o.length !== r.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (const s of o)
      if (!Bc(e[s], t[s], n, a))
        return !1;
    return !0;
  }
  return e === t;
}, Ci = (e, t = /* @__PURE__ */ new Map()) => {
  if (typeof e != "object" || e === null)
    return e;
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof Array) {
    const n = [];
    t.set(e, n);
    for (const a of e)
      n.push(t.has(a) ? t.get(a) : Ci(a, t));
    return n;
  }
  if (xi(e))
    return e;
  if (e instanceof Object) {
    const n = {};
    t.set(e, n);
    const a = e;
    return Object.keys(e).reduce((o, r) => (o[r] = t.has(a[r]) ? t.get(a[r]) : Ci(a[r], t), o), n), n;
  }
  return e;
}, Ru = (e, t, n = /* @__PURE__ */ new Map()) => {
  if (!e || !t || e === t)
    return e;
  const a = xi(e) ? e : Ci(e);
  return n.has(t) ? n.get(t) : (n.set(t, a), Object.keys(t).forEach((o) => {
    o === "__proto__" || o === "constructor" || (jm(e[o]) && jm(t[o]) ? a[o] = Ru(e[o], t[o], n) : xi(t) ? a[o] = t : a[o] = Ci(t[o]));
  }), a);
}, v_ = (e, t) => (e = Object.assign({}, e), t.forEach((n) => delete e[n]), e), Si = (e, t, n) => aV(t, e);
function m_(e, t, n) {
  return Op(t) ? t(e, n) : t;
}
function h_(e, t, n) {
  return m_(e, t, n);
}
function wn(e, t, n) {
  return m_(e, t, n);
}
function Wm(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function rV(e, t, ...n) {
  const a = [];
  let o = 0, r = 0;
  for (const s of n) {
    const i = wn(e, s, t) || 0;
    i >= 0 ? a.push(o += i) : a.push(r += i);
  }
  return a;
}
function sV(e, ...t) {
  return e ? Um(e, (a, o) => Um(t, (r) => wn(a, r, o))) : void 0;
}
function lV(e, ...t) {
  return e ? Hm(e, (a, o) => Hm(t, (r) => wn(a, r, o))) : void 0;
}
function Pd(e, ...t) {
  return [sV(e, ...t), lV(e, ...t)];
}
function $i(e, t, n, a = wa.Auto) {
  if (e.length <= 1)
    return e[0];
  const r = e.map((u, d) => [u, d]).sort(([u, d], [c, f]) => wn(u, n, d) - wn(c, n, f)), s = r.map(([u, d]) => wn(u, n, d)), i = a === wa.Right ? GF(s, t, 0, e.length - 1) : Qs(s, t, 1, e.length);
  return a === wa.Right ? r[i][0] : a === wa.Left ? r[i - 1][0] : t - s[i - 1] > s[i] - t ? r[i][0] : r[i - 1][0];
}
function iV(e, t, n, a = !1) {
  if (!n)
    return [];
  const o = e.filter((r, s) => {
    const i = wn(r, n, s);
    return i >= t[0] && i <= t[1];
  });
  if (a) {
    if (o.length === 0) {
      const f = $i(e, t[0], n, wa.Left), p = $i(e, t[1], n, wa.Right);
      return [f, p].filter(Boolean);
    }
    const r = o[0], s = o[o.length - 1], i = e.findIndex((f) => f === r), u = e.findIndex((f) => f === s), d = Math.max(0, i - 1), c = Math.min(e.length - 1, u + 1);
    return e.slice(d, c + 1);
  }
  return o;
}
const uV = (e) => e == null ? [] : Array.isArray(e) ? e : [e];
function dV(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function cV(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var fV = /* @__PURE__ */ function() {
  function e(n) {
    var a = this;
    this._insertTag = function(o) {
      var r;
      a.tags.length === 0 ? a.insertionPoint ? r = a.insertionPoint.nextSibling : a.prepend ? r = a.container.firstChild : r = a.before : r = a.tags[a.tags.length - 1].nextSibling, a.container.insertBefore(o, r), a.tags.push(o);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(a) {
    a.forEach(this._insertTag);
  }, t.insert = function(a) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(cV(this));
    var o = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var r = dV(o);
      try {
        r.insertRule(a, r.cssRules.length);
      } catch {
      }
    } else
      o.appendChild(document.createTextNode(a));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(a) {
      var o;
      return (o = a.parentNode) == null ? void 0 : o.removeChild(a);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Jt = "-ms-", Bi = "-moz-", nt = "-webkit-", g_ = "comm", Ap = "rule", Ip = "decl", pV = "@import", y_ = "@keyframes", vV = "@layer", mV = Math.abs, qu = String.fromCharCode, hV = Object.assign;
function gV(e, t) {
  return jt(e, 0) ^ 45 ? (((t << 2 ^ jt(e, 0)) << 2 ^ jt(e, 1)) << 2 ^ jt(e, 2)) << 2 ^ jt(e, 3) : 0;
}
function b_(e) {
  return e.trim();
}
function yV(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function ot(e, t, n) {
  return e.replace(t, n);
}
function Pc(e, t) {
  return e.indexOf(t);
}
function jt(e, t) {
  return e.charCodeAt(t) | 0;
}
function Bs(e, t, n) {
  return e.slice(t, n);
}
function Qn(e) {
  return e.length;
}
function Rp(e) {
  return e.length;
}
function Sl(e, t) {
  return t.push(e), e;
}
function bV(e, t) {
  return e.map(t).join("");
}
var Fu = 1, pr = 1, __ = 0, hn = 0, Mt = 0, Ar = "";
function Vu(e, t, n, a, o, r, s) {
  return { value: e, root: t, parent: n, type: a, props: o, children: r, line: Fu, column: pr, length: s, return: "" };
}
function zr(e, t) {
  return hV(Vu("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function _V() {
  return Mt;
}
function wV() {
  return Mt = hn > 0 ? jt(Ar, --hn) : 0, pr--, Mt === 10 && (pr = 1, Fu--), Mt;
}
function Cn() {
  return Mt = hn < __ ? jt(Ar, hn++) : 0, pr++, Mt === 10 && (pr = 1, Fu++), Mt;
}
function na() {
  return jt(Ar, hn);
}
function Ul() {
  return hn;
}
function el(e, t) {
  return Bs(Ar, e, t);
}
function Ps(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function w_(e) {
  return Fu = pr = 1, __ = Qn(Ar = e), hn = 0, [];
}
function x_(e) {
  return Ar = "", e;
}
function jl(e) {
  return b_(el(hn - 1, Ec(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function xV(e) {
  for (; (Mt = na()) && Mt < 33; )
    Cn();
  return Ps(e) > 2 || Ps(Mt) > 3 ? "" : " ";
}
function CV(e, t) {
  for (; --t && Cn() && !(Mt < 48 || Mt > 102 || Mt > 57 && Mt < 65 || Mt > 70 && Mt < 97); )
    ;
  return el(e, Ul() + (t < 6 && na() == 32 && Cn() == 32));
}
function Ec(e) {
  for (; Cn(); )
    switch (Mt) {
      case e:
        return hn;
      case 34:
      case 39:
        e !== 34 && e !== 39 && Ec(Mt);
        break;
      case 40:
        e === 41 && Ec(e);
        break;
      case 92:
        Cn();
        break;
    }
  return hn;
}
function SV(e, t) {
  for (; Cn() && e + Mt !== 57; )
    if (e + Mt === 84 && na() === 47)
      break;
  return "/*" + el(t, hn - 1) + "*" + qu(e === 47 ? e : Cn());
}
function $V(e) {
  for (; !Ps(na()); )
    Cn();
  return el(e, hn);
}
function BV(e) {
  return x_(Wl("", null, null, null, [""], e = w_(e), 0, [0], e));
}
function Wl(e, t, n, a, o, r, s, i, u) {
  for (var d = 0, c = 0, f = s, p = 0, v = 0, m = 0, h = 1, _ = 1, x = 1, S = 0, $ = "", D = o, B = r, k = a, M = $; _; )
    switch (m = S, S = Cn()) {
      case 40:
        if (m != 108 && jt(M, f - 1) == 58) {
          Pc(M += ot(jl(S), "&", "&\f"), "&\f") != -1 && (x = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        M += jl(S);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        M += xV(m);
        break;
      case 92:
        M += CV(Ul() - 1, 7);
        continue;
      case 47:
        switch (na()) {
          case 42:
          case 47:
            Sl(PV(SV(Cn(), Ul()), t, n), u);
            break;
          default:
            M += "/";
        }
        break;
      case 123 * h:
        i[d++] = Qn(M) * x;
      case 125 * h:
      case 59:
      case 0:
        switch (S) {
          case 0:
          case 125:
            _ = 0;
          case 59 + c:
            x == -1 && (M = ot(M, /\f/g, "")), v > 0 && Qn(M) - f && Sl(v > 32 ? Gm(M + ";", a, n, f - 1) : Gm(ot(M, " ", "") + ";", a, n, f - 2), u);
            break;
          case 59:
            M += ";";
          default:
            if (Sl(k = Km(M, t, n, d, c, o, i, $, D = [], B = [], f), r), S === 123)
              if (c === 0)
                Wl(M, t, k, k, D, r, f, i, B);
              else
                switch (p === 99 && jt(M, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Wl(e, k, k, a && Sl(Km(e, k, k, 0, 0, o, i, $, o, D = [], f), B), o, B, f, i, a ? D : B);
                    break;
                  default:
                    Wl(M, k, k, k, [""], B, 0, i, B);
                }
        }
        d = c = v = 0, h = x = 1, $ = M = "", f = s;
        break;
      case 58:
        f = 1 + Qn(M), v = m;
      default:
        if (h < 1) {
          if (S == 123)
            --h;
          else if (S == 125 && h++ == 0 && wV() == 125)
            continue;
        }
        switch (M += qu(S), S * h) {
          case 38:
            x = c > 0 ? 1 : (M += "\f", -1);
            break;
          case 44:
            i[d++] = (Qn(M) - 1) * x, x = 1;
            break;
          case 64:
            na() === 45 && (M += jl(Cn())), p = na(), c = f = Qn($ = M += $V(Ul())), S++;
            break;
          case 45:
            m === 45 && Qn(M) == 2 && (h = 0);
        }
    }
  return r;
}
function Km(e, t, n, a, o, r, s, i, u, d, c) {
  for (var f = o - 1, p = o === 0 ? r : [""], v = Rp(p), m = 0, h = 0, _ = 0; m < a; ++m)
    for (var x = 0, S = Bs(e, f + 1, f = mV(h = s[m])), $ = e; x < v; ++x)
      ($ = b_(h > 0 ? p[x] + " " + S : ot(S, /&\f/g, p[x]))) && (u[_++] = $);
  return Vu(e, t, n, o === 0 ? Ap : i, u, d, c);
}
function PV(e, t, n) {
  return Vu(e, t, n, g_, qu(_V()), Bs(e, 2, -2), 0);
}
function Gm(e, t, n, a) {
  return Vu(e, t, n, Ip, Bs(e, 0, a), Bs(e, a + 1, -1), a);
}
function nr(e, t) {
  for (var n = "", a = Rp(e), o = 0; o < a; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function EV(e, t, n, a) {
  switch (e.type) {
    case vV:
      if (e.children.length) break;
    case pV:
    case Ip:
      return e.return = e.return || e.value;
    case g_:
      return "";
    case y_:
      return e.return = e.value + "{" + nr(e.children, a) + "}";
    case Ap:
      e.value = e.props.join(",");
  }
  return Qn(n = nr(e.children, a)) ? e.return = e.value + "{" + n + "}" : "";
}
function DV(e) {
  var t = Rp(e);
  return function(n, a, o, r) {
    for (var s = "", i = 0; i < t; i++)
      s += e[i](n, a, o, r) || "";
    return s;
  };
}
function MV(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function kV(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var OV = function(t, n, a) {
  for (var o = 0, r = 0; o = r, r = na(), o === 38 && r === 12 && (n[a] = 1), !Ps(r); )
    Cn();
  return el(t, hn);
}, TV = function(t, n) {
  var a = -1, o = 44;
  do
    switch (Ps(o)) {
      case 0:
        o === 38 && na() === 12 && (n[a] = 1), t[a] += OV(hn - 1, n, a);
        break;
      case 2:
        t[a] += jl(o);
        break;
      case 4:
        if (o === 44) {
          t[++a] = na() === 58 ? "&\f" : "", n[a] = t[a].length;
          break;
        }
      default:
        t[a] += qu(o);
    }
  while (o = Cn());
  return t;
}, AV = function(t, n) {
  return x_(TV(w_(t), n));
}, Ym = /* @__PURE__ */ new WeakMap(), IV = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, a = t.parent, o = t.column === a.column && t.line === a.line; a.type !== "rule"; )
      if (a = a.parent, !a) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Ym.get(a)) && !o) {
      Ym.set(t, !0);
      for (var r = [], s = AV(n, r), i = a.props, u = 0, d = 0; u < s.length; u++)
        for (var c = 0; c < i.length; c++, d++)
          t.props[d] = r[u] ? s[u].replace(/&\f/g, i[c]) : i[c] + " " + s[u];
    }
  }
}, RV = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function C_(e, t) {
  switch (gV(e, t)) {
    case 5103:
      return nt + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return nt + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return nt + e + Bi + e + Jt + e + e;
    case 6828:
    case 4268:
      return nt + e + Jt + e + e;
    case 6165:
      return nt + e + Jt + "flex-" + e + e;
    case 5187:
      return nt + e + ot(e, /(\w+).+(:[^]+)/, nt + "box-$1$2" + Jt + "flex-$1$2") + e;
    case 5443:
      return nt + e + Jt + "flex-item-" + ot(e, /flex-|-self/, "") + e;
    case 4675:
      return nt + e + Jt + "flex-line-pack" + ot(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return nt + e + Jt + ot(e, "shrink", "negative") + e;
    case 5292:
      return nt + e + Jt + ot(e, "basis", "preferred-size") + e;
    case 6060:
      return nt + "box-" + ot(e, "-grow", "") + nt + e + Jt + ot(e, "grow", "positive") + e;
    case 4554:
      return nt + ot(e, /([^-])(transform)/g, "$1" + nt + "$2") + e;
    case 6187:
      return ot(ot(ot(e, /(zoom-|grab)/, nt + "$1"), /(image-set)/, nt + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return ot(e, /(image-set\([^]*)/, nt + "$1$`$1");
    case 4968:
      return ot(ot(e, /(.+:)(flex-)?(.*)/, nt + "box-pack:$3" + Jt + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + nt + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return ot(e, /(.+)-inline(.+)/, nt + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Qn(e) - 1 - t > 6) switch (jt(e, t + 1)) {
        case 109:
          if (jt(e, t + 4) !== 45) break;
        case 102:
          return ot(e, /(.+:)(.+)-([^]+)/, "$1" + nt + "$2-$3$1" + Bi + (jt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~Pc(e, "stretch") ? C_(ot(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    case 4949:
      if (jt(e, t + 1) !== 115) break;
    case 6444:
      switch (jt(e, Qn(e) - 3 - (~Pc(e, "!important") && 10))) {
        case 107:
          return ot(e, ":", ":" + nt) + e;
        case 101:
          return ot(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + nt + (jt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + nt + "$2$3$1" + Jt + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (jt(e, t + 11)) {
        case 114:
          return nt + e + Jt + ot(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return nt + e + Jt + ot(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return nt + e + Jt + ot(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return nt + e + Jt + e + e;
  }
  return e;
}
var qV = function(t, n, a, o) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Ip:
      t.return = C_(t.value, t.length);
      break;
    case y_:
      return nr([zr(t, {
        value: ot(t.value, "@", "@" + nt)
      })], o);
    case Ap:
      if (t.length) return bV(t.props, function(r) {
        switch (yV(r, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return nr([zr(t, {
              props: [ot(r, /:(read-\w+)/, ":" + Bi + "$1")]
            })], o);
          case "::placeholder":
            return nr([zr(t, {
              props: [ot(r, /:(plac\w+)/, ":" + nt + "input-$1")]
            }), zr(t, {
              props: [ot(r, /:(plac\w+)/, ":" + Bi + "$1")]
            }), zr(t, {
              props: [ot(r, /:(plac\w+)/, Jt + "input-$1")]
            })], o);
        }
        return "";
      });
  }
}, FV = [qV], VV = function(t) {
  var n = t.key;
  if (n === "css") {
    var a = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(a, function(h) {
      var _ = h.getAttribute("data-emotion");
      _.indexOf(" ") !== -1 && (document.head.appendChild(h), h.setAttribute("data-s", ""));
    });
  }
  var o = t.stylisPlugins || FV, r = {}, s, i = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(h) {
      for (var _ = h.getAttribute("data-emotion").split(" "), x = 1; x < _.length; x++)
        r[_[x]] = !0;
      i.push(h);
    }
  );
  var u, d = [IV, RV];
  {
    var c, f = [EV, MV(function(h) {
      c.insert(h);
    })], p = DV(d.concat(o, f)), v = function(_) {
      return nr(BV(_), p);
    };
    u = function(_, x, S, $) {
      c = S, v(_ ? _ + "{" + x.styles + "}" : x.styles), $ && (m.inserted[x.name] = !0);
    };
  }
  var m = {
    key: n,
    sheet: new fV({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: r,
    registered: {},
    insert: u
  };
  return m.sheet.hydrate(i), m;
};
function NV(e) {
  for (var t = 0, n, a = 0, o = e.length; o >= 4; ++a, o -= 4)
    n = e.charCodeAt(a) & 255 | (e.charCodeAt(++a) & 255) << 8 | (e.charCodeAt(++a) & 255) << 16 | (e.charCodeAt(++a) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (o) {
    case 3:
      t ^= (e.charCodeAt(a + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(a + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(a) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var LV = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, zV = /[A-Z]|^ms/g, HV = /_EMO_([^_]+?)_([^]*?)_EMO_/g, S_ = function(t) {
  return t.charCodeAt(1) === 45;
}, Xm = function(t) {
  return t != null && typeof t != "boolean";
}, Ed = /* @__PURE__ */ kV(function(e) {
  return S_(e) ? e : e.replace(zV, "-$&").toLowerCase();
}), Jm = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(HV, function(a, o, r) {
          return Ya = {
            name: o,
            styles: r,
            next: Ya
          }, o;
        });
  }
  return LV[t] !== 1 && !S_(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Pi(e, t, n) {
  if (n == null)
    return "";
  var a = n;
  if (a.__emotion_styles !== void 0)
    return a;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var o = n;
      if (o.anim === 1)
        return Ya = {
          name: o.name,
          styles: o.styles,
          next: Ya
        }, o.name;
      var r = n;
      if (r.styles !== void 0) {
        var s = r.next;
        if (s !== void 0)
          for (; s !== void 0; )
            Ya = {
              name: s.name,
              styles: s.styles,
              next: Ya
            }, s = s.next;
        var i = r.styles + ";";
        return i;
      }
      return UV(e, t, n);
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function UV(e, t, n) {
  var a = "";
  if (Array.isArray(n))
    for (var o = 0; o < n.length; o++)
      a += Pi(e, t, n[o]) + ";";
  else
    for (var r in n) {
      var s = n[r];
      if (typeof s != "object") {
        var i = s;
        t != null && t[i] !== void 0 ? a += r + "{" + t[i] + "}" : Xm(i) && (a += Ed(r) + ":" + Jm(r, i) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var u = 0; u < s.length; u++)
          Xm(s[u]) && (a += Ed(r) + ":" + Jm(r, s[u]) + ";");
      else {
        var d = Pi(e, t, s);
        switch (r) {
          case "animation":
          case "animationName": {
            a += Ed(r) + ":" + d + ";";
            break;
          }
          default:
            a += r + "{" + d + "}";
        }
      }
    }
  return a;
}
var Zm = /label:\s*([^\s;{]+)\s*(;|$)/g, Ya;
function Dd(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var a = !0, o = "";
  Ya = void 0;
  var r = e[0];
  if (r == null || r.raw === void 0)
    a = !1, o += Pi(n, t, r);
  else {
    var s = r;
    o += s[0];
  }
  for (var i = 1; i < e.length; i++)
    if (o += Pi(n, t, e[i]), a) {
      var u = r;
      o += u[i];
    }
  Zm.lastIndex = 0;
  for (var d = "", c; (c = Zm.exec(o)) !== null; )
    d += "-" + c[1];
  var f = NV(o) + d;
  return {
    name: f,
    styles: o,
    next: Ya
  };
}
function $_(e, t, n) {
  var a = "";
  return n.split(" ").forEach(function(o) {
    e[o] !== void 0 ? t.push(e[o] + ";") : o && (a += o + " ");
  }), a;
}
var jV = function(t, n, a) {
  var o = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[o] === void 0 && (t.registered[o] = n.styles);
}, WV = function(t, n, a) {
  jV(t, n);
  var o = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var r = n;
    do
      t.insert(n === r ? "." + o : "", r, t.sheet, !0), r = r.next;
    while (r !== void 0);
  }
};
function Qm(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function eh(e, t, n) {
  var a = [], o = $_(e, a, n);
  return a.length < 2 ? n : o + t(a);
}
var KV = function(t) {
  var n = VV(t);
  n.sheet.speedy = function(i) {
    this.isSpeedy = i;
  }, n.compat = !0;
  var a = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Dd(d, n.registered, void 0);
    return WV(n, f), n.key + "-" + f.name;
  }, o = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Dd(d, n.registered), p = "animation-" + f.name;
    return Qm(n, {
      name: f.name,
      styles: "@keyframes " + p + "{" + f.styles + "}"
    }), p;
  }, r = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Dd(d, n.registered);
    Qm(n, f);
  }, s = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    return eh(n.registered, a, GV(d));
  };
  return {
    css: a,
    cx: s,
    injectGlobal: r,
    keyframes: o,
    hydrate: function(u) {
      u.forEach(function(d) {
        n.inserted[d] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: $_.bind(null, n.registered),
    merge: eh.bind(null, n.registered, a)
  };
}, GV = function e(t) {
  for (var n = "", a = 0; a < t.length; a++) {
    var o = t[a];
    if (o != null) {
      var r = void 0;
      switch (typeof o) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(o))
            r = e(o);
          else {
            r = "";
            for (var s in o)
              o[s] && s && (r && (r += " "), r += s);
          }
          break;
        }
        default:
          r = o;
      }
      r && (n && (n += " "), n += r);
    }
  }
  return n;
}, B_ = KV({
  key: "css"
}), qp = B_.injectGlobal, gn = B_.css;
function YV(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var XV = function(t, n) {
  n || (n = [0, ""]), t = String(t);
  var a = parseFloat(t, 10);
  return n[0] = a, n[1] = t.match(/[\d.\-\+]*\s*(.*)/)[1] || "", n;
}, P_ = XV, JV = Fp, Hr = E_("in", document.body);
function Dc(e, t) {
  var n = P_(getComputedStyle(e).getPropertyValue(t));
  return n[0] * Fp(n[1], e);
}
function E_(e, t) {
  var n = document.createElement("div");
  n.style.height = "128" + e, t.appendChild(n);
  var a = Dc(n, "height") / 128;
  return t.removeChild(n), a;
}
function Fp(e, t) {
  if (!e) return null;
  switch (t = t || document.body, e = (e + "" || "px").trim().toLowerCase(), (t === window || t === document) && (t = document.body), e) {
    case "%":
      return t.clientHeight / 100;
    case "ch":
    case "ex":
      return E_(e, t);
    case "em":
      return Dc(t, "font-size");
    case "rem":
      return Dc(document.body, "font-size");
    case "vw":
      return window.innerWidth / 100;
    case "vh":
      return window.innerHeight / 100;
    case "vmin":
      return Math.min(window.innerWidth, window.innerHeight) / 100;
    case "vmax":
      return Math.max(window.innerWidth, window.innerHeight) / 100;
    case "in":
      return Hr;
    case "cm":
      return Hr / 2.54;
    case "mm":
      return Hr / 25.4;
    case "pt":
      return Hr / 72;
    case "pc":
      return Hr / 6;
    case "px":
      return 1;
  }
  var n = P_(e);
  if (!isNaN(n[0]) && n[1]) {
    var a = Fp(n[1], t);
    return typeof a == "number" ? n[0] * a : null;
  }
  return null;
}
const Mc = /* @__PURE__ */ YV(JV);
function ZV() {
  const e = () => Math.floor((1 + crypto.getRandomValues(new Uint32Array(1))[0]) * 65536).toString(16).substring(1);
  return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`;
}
function Vp(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function D_(e, t) {
  var n = Object.create(e.prototype);
  for (var a in t) n[a] = t[a];
  return n;
}
function tl() {
}
var Es = 0.7, Ei = 1 / Es, ar = "\\s*([+-]?\\d+)\\s*", Ds = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", aa = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", QV = /^#([0-9a-f]{3,8})$/, e4 = new RegExp(`^rgb\\(${ar},${ar},${ar}\\)$`), t4 = new RegExp(`^rgb\\(${aa},${aa},${aa}\\)$`), n4 = new RegExp(`^rgba\\(${ar},${ar},${ar},${Ds}\\)$`), a4 = new RegExp(`^rgba\\(${aa},${aa},${aa},${Ds}\\)$`), o4 = new RegExp(`^hsl\\(${Ds},${aa},${aa}\\)$`), r4 = new RegExp(`^hsla\\(${Ds},${aa},${aa},${Ds}\\)$`), th = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Vp(tl, wo, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: nh,
  // Deprecated! Use color.formatHex.
  formatHex: nh,
  formatHex8: s4,
  formatHsl: l4,
  formatRgb: ah,
  toString: ah
});
function nh() {
  return this.rgb().formatHex();
}
function s4() {
  return this.rgb().formatHex8();
}
function l4() {
  return M_(this).formatHsl();
}
function ah() {
  return this.rgb().formatRgb();
}
function wo(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = QV.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? oh(t) : n === 3 ? new fn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? $l(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? $l(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = e4.exec(e)) ? new fn(t[1], t[2], t[3], 1) : (t = t4.exec(e)) ? new fn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = n4.exec(e)) ? $l(t[1], t[2], t[3], t[4]) : (t = a4.exec(e)) ? $l(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = o4.exec(e)) ? lh(t[1], t[2] / 100, t[3] / 100, 1) : (t = r4.exec(e)) ? lh(t[1], t[2] / 100, t[3] / 100, t[4]) : th.hasOwnProperty(e) ? oh(th[e]) : e === "transparent" ? new fn(NaN, NaN, NaN, 0) : null;
}
function oh(e) {
  return new fn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function $l(e, t, n, a) {
  return a <= 0 && (e = t = n = NaN), new fn(e, t, n, a);
}
function i4(e) {
  return e instanceof tl || (e = wo(e)), e ? (e = e.rgb(), new fn(e.r, e.g, e.b, e.opacity)) : new fn();
}
function kc(e, t, n, a) {
  return arguments.length === 1 ? i4(e) : new fn(e, t, n, a ?? 1);
}
function fn(e, t, n, a) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +a;
}
Vp(fn, kc, D_(tl, {
  brighter(e) {
    return e = e == null ? Ei : Math.pow(Ei, e), new fn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Es : Math.pow(Es, e), new fn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new fn(go(this.r), go(this.g), go(this.b), Di(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rh,
  // Deprecated! Use color.formatHex.
  formatHex: rh,
  formatHex8: u4,
  formatRgb: sh,
  toString: sh
}));
function rh() {
  return `#${fo(this.r)}${fo(this.g)}${fo(this.b)}`;
}
function u4() {
  return `#${fo(this.r)}${fo(this.g)}${fo(this.b)}${fo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function sh() {
  const e = Di(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${go(this.r)}, ${go(this.g)}, ${go(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Di(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function go(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function fo(e) {
  return e = go(e), (e < 16 ? "0" : "") + e.toString(16);
}
function lh(e, t, n, a) {
  return a <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Nn(e, t, n, a);
}
function M_(e) {
  if (e instanceof Nn) return new Nn(e.h, e.s, e.l, e.opacity);
  if (e instanceof tl || (e = wo(e)), !e) return new Nn();
  if (e instanceof Nn) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, a = e.b / 255, o = Math.min(t, n, a), r = Math.max(t, n, a), s = NaN, i = r - o, u = (r + o) / 2;
  return i ? (t === r ? s = (n - a) / i + (n < a) * 6 : n === r ? s = (a - t) / i + 2 : s = (t - n) / i + 4, i /= u < 0.5 ? r + o : 2 - r - o, s *= 60) : i = u > 0 && u < 1 ? 0 : s, new Nn(s, i, u, e.opacity);
}
function d4(e, t, n, a) {
  return arguments.length === 1 ? M_(e) : new Nn(e, t, n, a ?? 1);
}
function Nn(e, t, n, a) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +a;
}
Vp(Nn, d4, D_(tl, {
  brighter(e) {
    return e = e == null ? Ei : Math.pow(Ei, e), new Nn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Es : Math.pow(Es, e), new Nn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, a = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - a;
    return new fn(
      Md(e >= 240 ? e - 240 : e + 120, o, a),
      Md(e, o, a),
      Md(e < 120 ? e + 240 : e - 120, o, a),
      this.opacity
    );
  },
  clamp() {
    return new Nn(ih(this.h), Bl(this.s), Bl(this.l), Di(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Di(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${ih(this.h)}, ${Bl(this.s) * 100}%, ${Bl(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function ih(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Bl(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Md(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const c4 = (globalThis == null ? void 0 : globalThis.UNOVIS_COLORS) || ["#4D8CFD", "#FF6B7E", "#F4B83E", "#A6CC74", "#00C19A", "#6859BE"], k_ = (e) => `--vis-${ds(e) ? `color${e % c4.length}` : e}`, Ms = 10, f4 = [
  { id: "stripes-diagonal", svg: '<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="#000"/>' },
  { id: "dots", svg: '<path d="m0-1.5a1 1 0 010 3m10-3a1 1 0 000 3M5 3.5a1 1 0 010 3 1 1 0 010-3M0 8.5 a1 1 0 010 3m10-3a1 1 0 000 3" fill"#000"/>' },
  { id: "stripes-vertical", svg: '<path d="M 5,-1 L5,11" stroke="#000"/>' },
  { id: "crosshatch", svg: '<path d="M0 0L10 10ZM10 0L0 10Z" stroke="#000"/>' },
  { id: "waves", svg: '<path d="M0 4Q2.5 1 5 4 7.5 7 10 4v2Q7.5 9 5 6 2.5 3 0 6Z" fill="#000"/>' },
  { id: "circles", svg: '<circle cx="5" cy="5" r="3" stroke="#000" fill="#fff"/>' }
], p4 = [
  { id: "circle", marker: '<circle cx="5" cy="5" r="5"/>', dashArray: [] },
  { id: "triangle", marker: '<path d="M5,0 L10,9 L0,9Z">', dashArray: [9, 1] },
  { id: "diamond", marker: '<path d="M 0 5 L5 0 L 10 5 L 5 10 L 0 5Z">', dashArray: [2] },
  { id: "arrow", marker: '<path d="M4 0 0 0 6 5 0 10 4 10 10 5Z">', dashArray: [2, 3, 8, 3] },
  { id: "square", marker: '<rect x="1" y="1" width="8" height="8"/>', dashArray: [6] },
  { id: "star", marker: '<path d="m2 9 3-9 3 9L0 3h10Z"/>', dashArray: [1, 6] }
];
function O_(e) {
  return `vis-${`pattern-${e.svg ? "fill" : "marker"}`}-${e.id}`;
}
const v4 = (e) => `<mask id="${O_(e)}">
    <pattern id="${e.id}" viewBox="0 0 10 10" width="${Ms}" height="${Ms}" patternUnits="userSpaceOnUse">
      <rect width="100%" height="100%" fill="#fff"/>
      ${e.svg}
    </pattern>
    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#${e.id})"/>
  </mask>`, m4 = (e, t) => `<marker id="${O_(e)}"
    fill="var(${k_(t)})"
    markerUnits="userSpaceOnUse"
    refX="5"
    refY="5"
    markerWidth="${Ms}"
    markerHeight="${Ms}">
    ${e.marker}
  </marker>`;
function h4() {
  const e = f4.map(v4).concat(p4.map(m4)).join(""), t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.style.position = "fixed", t.style.zIndex = "-99999999", t.innerHTML = `<defs>${e}</defs>`, document.body.appendChild(t);
}
typeof window < "u" && h4();
var g4 = { value: () => {
} };
function T_() {
  for (var e = 0, t = arguments.length, n = {}, a; e < t; ++e) {
    if (!(a = arguments[e] + "") || a in n || /[\s.]/.test(a)) throw new Error("illegal type: " + a);
    n[a] = [];
  }
  return new Kl(n);
}
function Kl(e) {
  this._ = e;
}
function y4(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var a = "", o = n.indexOf(".");
    if (o >= 0 && (a = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: a };
  });
}
Kl.prototype = T_.prototype = {
  constructor: Kl,
  on: function(e, t) {
    var n = this._, a = y4(e + "", n), o, r = -1, s = a.length;
    if (arguments.length < 2) {
      for (; ++r < s; ) if ((o = (e = a[r]).type) && (o = b4(n[o], e.name))) return o;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++r < s; )
      if (o = (e = a[r]).type) n[o] = uh(n[o], e.name, t);
      else if (t == null) for (o in n) n[o] = uh(n[o], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new Kl(e);
  },
  call: function(e, t) {
    if ((o = arguments.length - 2) > 0) for (var n = new Array(o), a = 0, o, r; a < o; ++a) n[a] = arguments[a + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (r = this._[e], a = 0, o = r.length; a < o; ++a) r[a].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var a = this._[e], o = 0, r = a.length; o < r; ++o) a[o].value.apply(t, n);
  }
};
function b4(e, t) {
  for (var n = 0, a = e.length, o; n < a; ++n)
    if ((o = e[n]).name === t)
      return o.value;
}
function uh(e, t, n) {
  for (var a = 0, o = e.length; a < o; ++a)
    if (e[a].name === t) {
      e[a] = g4, e = e.slice(0, a).concat(e.slice(a + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var vr = 0, es = 0, Ur = 0, A_ = 1e3, Mi, ts, ki = 0, xo = 0, Nu = 0, ks = typeof performance == "object" && performance.now ? performance : Date, I_ = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Np() {
  return xo || (I_(_4), xo = ks.now() + Nu);
}
function _4() {
  xo = 0;
}
function Oi() {
  this._call = this._time = this._next = null;
}
Oi.prototype = R_.prototype = {
  constructor: Oi,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Np() : +n) + (t == null ? 0 : +t), !this._next && ts !== this && (ts ? ts._next = this : Mi = this, ts = this), this._call = e, this._time = n, Oc();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Oc());
  }
};
function R_(e, t, n) {
  var a = new Oi();
  return a.restart(e, t, n), a;
}
function w4() {
  Np(), ++vr;
  for (var e = Mi, t; e; )
    (t = xo - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --vr;
}
function dh() {
  xo = (ki = ks.now()) + Nu, vr = es = 0;
  try {
    w4();
  } finally {
    vr = 0, C4(), xo = 0;
  }
}
function x4() {
  var e = ks.now(), t = e - ki;
  t > A_ && (Nu -= t, ki = e);
}
function C4() {
  for (var e, t = Mi, n, a = 1 / 0; t; )
    t._call ? (a > t._time && (a = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Mi = n);
  ts = e, Oc(a);
}
function Oc(e) {
  if (!vr) {
    es && (es = clearTimeout(es));
    var t = e - xo;
    t > 24 ? (e < 1 / 0 && (es = setTimeout(dh, e - ks.now() - Nu)), Ur && (Ur = clearInterval(Ur))) : (Ur || (ki = ks.now(), Ur = setInterval(x4, A_)), vr = 1, I_(dh));
  }
}
function ch(e, t, n) {
  var a = new Oi();
  return t = t == null ? 0 : +t, a.restart((o) => {
    a.stop(), e(o + t);
  }, t, n), a;
}
var S4 = T_("start", "end", "cancel", "interrupt"), $4 = [], q_ = 0, fh = 1, Tc = 2, Gl = 3, ph = 4, Ac = 5, Yl = 6;
function Lu(e, t, n, a, o, r) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  B4(e, n, {
    name: t,
    index: a,
    // For context during callback.
    group: o,
    // For context during callback.
    on: S4,
    tween: $4,
    time: r.time,
    delay: r.delay,
    duration: r.duration,
    ease: r.ease,
    timer: null,
    state: q_
  });
}
function Lp(e, t) {
  var n = Gn(e, t);
  if (n.state > q_) throw new Error("too late; already scheduled");
  return n;
}
function ca(e, t) {
  var n = Gn(e, t);
  if (n.state > Gl) throw new Error("too late; already running");
  return n;
}
function Gn(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function B4(e, t, n) {
  var a = e.__transition, o;
  a[t] = n, n.timer = R_(r, 0, n.time);
  function r(d) {
    n.state = fh, n.timer.restart(s, n.delay, n.time), n.delay <= d && s(d - n.delay);
  }
  function s(d) {
    var c, f, p, v;
    if (n.state !== fh) return u();
    for (c in a)
      if (v = a[c], v.name === n.name) {
        if (v.state === Gl) return ch(s);
        v.state === ph ? (v.state = Yl, v.timer.stop(), v.on.call("interrupt", e, e.__data__, v.index, v.group), delete a[c]) : +c < t && (v.state = Yl, v.timer.stop(), v.on.call("cancel", e, e.__data__, v.index, v.group), delete a[c]);
      }
    if (ch(function() {
      n.state === Gl && (n.state = ph, n.timer.restart(i, n.delay, n.time), i(d));
    }), n.state = Tc, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Tc) {
      for (n.state = Gl, o = new Array(p = n.tween.length), c = 0, f = -1; c < p; ++c)
        (v = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (o[++f] = v);
      o.length = f + 1;
    }
  }
  function i(d) {
    for (var c = d < n.duration ? n.ease.call(null, d / n.duration) : (n.timer.restart(u), n.state = Ac, 1), f = -1, p = o.length; ++f < p; )
      o[f].call(e, c);
    n.state === Ac && (n.on.call("end", e, e.__data__, n.index, n.group), u());
  }
  function u() {
    n.state = Yl, n.timer.stop(), delete a[t];
    for (var d in a) return;
    delete e.__transition;
  }
}
function F_(e, t) {
  var n = e.__transition, a, o, r = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((a = n[s]).name !== t) {
        r = !1;
        continue;
      }
      o = a.state > Tc && a.state < Ac, a.state = Yl, a.timer.stop(), a.on.call(o ? "interrupt" : "cancel", e, e.__data__, a.index, a.group), delete n[s];
    }
    r && delete e.__transition;
  }
}
function P4(e) {
  return this.each(function() {
    F_(this, e);
  });
}
const zp = (e) => () => e;
function E4(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function D4(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(a) {
    return Math.pow(e + a * t, n);
  };
}
function M4(e) {
  return (e = +e) == 1 ? V_ : function(t, n) {
    return n - t ? D4(t, n, e) : zp(isNaN(t) ? n : t);
  };
}
function V_(e, t) {
  var n = t - e;
  return n ? E4(e, n) : zp(isNaN(e) ? t : e);
}
const Ti = function e(t) {
  var n = M4(t);
  function a(o, r) {
    var s = n((o = kc(o)).r, (r = kc(r)).r), i = n(o.g, r.g), u = n(o.b, r.b), d = V_(o.opacity, r.opacity);
    return function(c) {
      return o.r = s(c), o.g = i(c), o.b = u(c), o.opacity = d(c), o + "";
    };
  }
  return a.gamma = e, a;
}(1);
function k4(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, a = t.slice(), o;
  return function(r) {
    for (o = 0; o < n; ++o) a[o] = e[o] * (1 - r) + t[o] * r;
    return a;
  };
}
function O4(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function T4(e, t) {
  var n = t ? t.length : 0, a = e ? Math.min(n, e.length) : 0, o = new Array(a), r = new Array(n), s;
  for (s = 0; s < a; ++s) o[s] = Ir(e[s], t[s]);
  for (; s < n; ++s) r[s] = t[s];
  return function(i) {
    for (s = 0; s < a; ++s) r[s] = o[s](i);
    return r;
  };
}
function A4(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(a) {
    return n.setTime(e * (1 - a) + t * a), n;
  };
}
function qn(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function I4(e, t) {
  var n = {}, a = {}, o;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (o in t)
    o in e ? n[o] = Ir(e[o], t[o]) : a[o] = t[o];
  return function(r) {
    for (o in n) a[o] = n[o](r);
    return a;
  };
}
var Ic = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, kd = new RegExp(Ic.source, "g");
function R4(e) {
  return function() {
    return e;
  };
}
function q4(e) {
  return function(t) {
    return e(t) + "";
  };
}
function N_(e, t) {
  var n = Ic.lastIndex = kd.lastIndex = 0, a, o, r, s = -1, i = [], u = [];
  for (e = e + "", t = t + ""; (a = Ic.exec(e)) && (o = kd.exec(t)); )
    (r = o.index) > n && (r = t.slice(n, r), i[s] ? i[s] += r : i[++s] = r), (a = a[0]) === (o = o[0]) ? i[s] ? i[s] += o : i[++s] = o : (i[++s] = null, u.push({ i: s, x: qn(a, o) })), n = kd.lastIndex;
  return n < t.length && (r = t.slice(n), i[s] ? i[s] += r : i[++s] = r), i.length < 2 ? u[0] ? q4(u[0].x) : R4(t) : (t = u.length, function(d) {
    for (var c = 0, f; c < t; ++c) i[(f = u[c]).i] = f.x(d);
    return i.join("");
  });
}
function Ir(e, t) {
  var n = typeof t, a;
  return t == null || n === "boolean" ? zp(t) : (n === "number" ? qn : n === "string" ? (a = wo(t)) ? (t = a, Ti) : N_ : t instanceof wo ? Ti : t instanceof Date ? A4 : O4(t) ? k4 : Array.isArray(t) ? T4 : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? I4 : qn)(e, t);
}
function Hp(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var vh = 180 / Math.PI, Rc = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function L_(e, t, n, a, o, r) {
  var s, i, u;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (u = e * n + t * a) && (n -= e * u, a -= t * u), (i = Math.sqrt(n * n + a * a)) && (n /= i, a /= i, u /= i), e * a < t * n && (e = -e, t = -t, u = -u, s = -s), {
    translateX: o,
    translateY: r,
    rotate: Math.atan2(t, e) * vh,
    skewX: Math.atan(u) * vh,
    scaleX: s,
    scaleY: i
  };
}
var Pl;
function F4(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Rc : L_(t.a, t.b, t.c, t.d, t.e, t.f);
}
function V4(e) {
  return e == null || (Pl || (Pl = document.createElementNS("http://www.w3.org/2000/svg", "g")), Pl.setAttribute("transform", e), !(e = Pl.transform.baseVal.consolidate())) ? Rc : (e = e.matrix, L_(e.a, e.b, e.c, e.d, e.e, e.f));
}
function z_(e, t, n, a) {
  function o(d) {
    return d.length ? d.pop() + " " : "";
  }
  function r(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var h = v.push("translate(", null, t, null, n);
      m.push({ i: h - 4, x: qn(d, f) }, { i: h - 2, x: qn(c, p) });
    } else (f || p) && v.push("translate(" + f + t + p + n);
  }
  function s(d, c, f, p) {
    d !== c ? (d - c > 180 ? c += 360 : c - d > 180 && (d += 360), p.push({ i: f.push(o(f) + "rotate(", null, a) - 2, x: qn(d, c) })) : c && f.push(o(f) + "rotate(" + c + a);
  }
  function i(d, c, f, p) {
    d !== c ? p.push({ i: f.push(o(f) + "skewX(", null, a) - 2, x: qn(d, c) }) : c && f.push(o(f) + "skewX(" + c + a);
  }
  function u(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var h = v.push(o(v) + "scale(", null, ",", null, ")");
      m.push({ i: h - 4, x: qn(d, f) }, { i: h - 2, x: qn(c, p) });
    } else (f !== 1 || p !== 1) && v.push(o(v) + "scale(" + f + "," + p + ")");
  }
  return function(d, c) {
    var f = [], p = [];
    return d = e(d), c = e(c), r(d.translateX, d.translateY, c.translateX, c.translateY, f, p), s(d.rotate, c.rotate, f, p), i(d.skewX, c.skewX, f, p), u(d.scaleX, d.scaleY, c.scaleX, c.scaleY, f, p), d = c = null, function(v) {
      for (var m = -1, h = p.length, _; ++m < h; ) f[(_ = p[m]).i] = _.x(v);
      return f.join("");
    };
  };
}
var N4 = z_(F4, "px, ", "px)", "deg)"), L4 = z_(V4, ", ", ")", ")");
function z4(e, t) {
  t === void 0 && (t = e, e = Ir);
  for (var n = 0, a = t.length - 1, o = t[0], r = new Array(a < 0 ? 0 : a); n < a; ) r[n] = e(o, o = t[++n]);
  return function(s) {
    var i = Math.max(0, Math.min(a - 1, Math.floor(s *= a)));
    return r[i](s - i);
  };
}
function H4(e, t) {
  var n, a;
  return function() {
    var o = ca(this, e), r = o.tween;
    if (r !== n) {
      a = n = r;
      for (var s = 0, i = a.length; s < i; ++s)
        if (a[s].name === t) {
          a = a.slice(), a.splice(s, 1);
          break;
        }
    }
    o.tween = a;
  };
}
function U4(e, t, n) {
  var a, o;
  if (typeof n != "function") throw new Error();
  return function() {
    var r = ca(this, e), s = r.tween;
    if (s !== a) {
      o = (a = s).slice();
      for (var i = { name: t, value: n }, u = 0, d = o.length; u < d; ++u)
        if (o[u].name === t) {
          o[u] = i;
          break;
        }
      u === d && o.push(i);
    }
    r.tween = o;
  };
}
function j4(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var a = Gn(this.node(), n).tween, o = 0, r = a.length, s; o < r; ++o)
      if ((s = a[o]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? H4 : U4)(n, e, t));
}
function Up(e, t, n) {
  var a = e._id;
  return e.each(function() {
    var o = ca(this, a);
    (o.value || (o.value = {}))[t] = n.apply(this, arguments);
  }), function(o) {
    return Gn(o, a).value[t];
  };
}
function H_(e, t) {
  var n;
  return (typeof t == "number" ? qn : t instanceof wo ? Ti : (n = wo(t)) ? (t = n, Ti) : N_)(e, t);
}
function W4(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function K4(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function G4(e, t, n) {
  var a, o = n + "", r;
  return function() {
    var s = this.getAttribute(e);
    return s === o ? null : s === a ? r : r = t(a = s, n);
  };
}
function Y4(e, t, n) {
  var a, o = n + "", r;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === o ? null : s === a ? r : r = t(a = s, n);
  };
}
function X4(e, t, n) {
  var a, o, r;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), u = i + "", s === u ? null : s === a && u === o ? r : (o = u, r = t(a = s, i)));
  };
}
function J4(e, t, n) {
  var a, o, r;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), u = i + "", s === u ? null : s === a && u === o ? r : (o = u, r = t(a = s, i)));
  };
}
function Z4(e, t) {
  var n = Iu(e), a = n === "transform" ? L4 : H_;
  return this.attrTween(e, typeof t == "function" ? (n.local ? J4 : X4)(n, a, Up(this, "attr." + e, t)) : t == null ? (n.local ? K4 : W4)(n) : (n.local ? Y4 : G4)(n, a, t));
}
function Q4(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function e8(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function t8(e, t) {
  var n, a;
  function o() {
    var r = t.apply(this, arguments);
    return r !== a && (n = (a = r) && e8(e, r)), n;
  }
  return o._value = t, o;
}
function n8(e, t) {
  var n, a;
  function o() {
    var r = t.apply(this, arguments);
    return r !== a && (n = (a = r) && Q4(e, r)), n;
  }
  return o._value = t, o;
}
function a8(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var a = Iu(e);
  return this.tween(n, (a.local ? t8 : n8)(a, t));
}
function o8(e, t) {
  return function() {
    Lp(this, e).delay = +t.apply(this, arguments);
  };
}
function r8(e, t) {
  return t = +t, function() {
    Lp(this, e).delay = t;
  };
}
function s8(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? o8 : r8)(t, e)) : Gn(this.node(), t).delay;
}
function l8(e, t) {
  return function() {
    ca(this, e).duration = +t.apply(this, arguments);
  };
}
function i8(e, t) {
  return t = +t, function() {
    ca(this, e).duration = t;
  };
}
function u8(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? l8 : i8)(t, e)) : Gn(this.node(), t).duration;
}
function d8(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    ca(this, e).ease = t;
  };
}
function c8(e) {
  var t = this._id;
  return arguments.length ? this.each(d8(t, e)) : Gn(this.node(), t).ease;
}
function f8(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    ca(this, e).ease = n;
  };
}
function p8(e) {
  if (typeof e != "function") throw new Error();
  return this.each(f8(this._id, e));
}
function v8(e) {
  typeof e != "function" && (e = n_(e));
  for (var t = this._groups, n = t.length, a = new Array(n), o = 0; o < n; ++o)
    for (var r = t[o], s = r.length, i = a[o] = [], u, d = 0; d < s; ++d)
      (u = r[d]) && e.call(u, u.__data__, d, r) && i.push(u);
  return new Pa(a, this._parents, this._name, this._id);
}
function m8(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, a = t.length, o = n.length, r = Math.min(a, o), s = new Array(a), i = 0; i < r; ++i)
    for (var u = t[i], d = n[i], c = u.length, f = s[i] = new Array(c), p, v = 0; v < c; ++v)
      (p = u[v] || d[v]) && (f[v] = p);
  for (; i < a; ++i)
    s[i] = t[i];
  return new Pa(s, this._parents, this._name, this._id);
}
function h8(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function g8(e, t, n) {
  var a, o, r = h8(t) ? Lp : ca;
  return function() {
    var s = r(this, e), i = s.on;
    i !== a && (o = (a = i).copy()).on(t, n), s.on = o;
  };
}
function y8(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Gn(this.node(), n).on.on(e) : this.each(g8(n, e, t));
}
function b8(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function _8() {
  return this.on("end.remove", b8(this._id));
}
function w8(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Dp(e));
  for (var a = this._groups, o = a.length, r = new Array(o), s = 0; s < o; ++s)
    for (var i = a[s], u = i.length, d = r[s] = new Array(u), c, f, p = 0; p < u; ++p)
      (c = i[p]) && (f = e.call(c, c.__data__, p, i)) && ("__data__" in c && (f.__data__ = c.__data__), d[p] = f, Lu(d[p], t, n, p, d, Gn(c, n)));
  return new Pa(r, this._parents, t, n);
}
function x8(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = t_(e));
  for (var a = this._groups, o = a.length, r = [], s = [], i = 0; i < o; ++i)
    for (var u = a[i], d = u.length, c, f = 0; f < d; ++f)
      if (c = u[f]) {
        for (var p = e.call(c, c.__data__, f, u), v, m = Gn(c, n), h = 0, _ = p.length; h < _; ++h)
          (v = p[h]) && Lu(v, t, n, h, p, m);
        r.push(p), s.push(c);
      }
  return new Pa(r, s, t, n);
}
var C8 = Zs.prototype.constructor;
function S8() {
  return new C8(this._groups, this._parents);
}
function $8(e, t) {
  var n, a, o;
  return function() {
    var r = fr(this, e), s = (this.style.removeProperty(e), fr(this, e));
    return r === s ? null : r === n && s === a ? o : o = t(n = r, a = s);
  };
}
function U_(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function B8(e, t, n) {
  var a, o = n + "", r;
  return function() {
    var s = fr(this, e);
    return s === o ? null : s === a ? r : r = t(a = s, n);
  };
}
function P8(e, t, n) {
  var a, o, r;
  return function() {
    var s = fr(this, e), i = n(this), u = i + "";
    return i == null && (u = i = (this.style.removeProperty(e), fr(this, e))), s === u ? null : s === a && u === o ? r : (o = u, r = t(a = s, i));
  };
}
function E8(e, t) {
  var n, a, o, r = "style." + t, s = "end." + r, i;
  return function() {
    var u = ca(this, e), d = u.on, c = u.value[r] == null ? i || (i = U_(t)) : void 0;
    (d !== n || o !== c) && (a = (n = d).copy()).on(s, o = c), u.on = a;
  };
}
function D8(e, t, n) {
  var a = (e += "") == "transform" ? N4 : H_;
  return t == null ? this.styleTween(e, $8(e, a)).on("end.style." + e, U_(e)) : typeof t == "function" ? this.styleTween(e, P8(e, a, Up(this, "style." + e, t))).each(E8(this._id, e)) : this.styleTween(e, B8(e, a, t), n).on("end.style." + e, null);
}
function M8(e, t, n) {
  return function(a) {
    this.style.setProperty(e, t.call(this, a), n);
  };
}
function k8(e, t, n) {
  var a, o;
  function r() {
    var s = t.apply(this, arguments);
    return s !== o && (a = (o = s) && M8(e, s, n)), a;
  }
  return r._value = t, r;
}
function O8(e, t, n) {
  var a = "style." + (e += "");
  if (arguments.length < 2) return (a = this.tween(a)) && a._value;
  if (t == null) return this.tween(a, null);
  if (typeof t != "function") throw new Error();
  return this.tween(a, k8(e, t, n ?? ""));
}
function T8(e) {
  return function() {
    this.textContent = e;
  };
}
function A8(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function I8(e) {
  return this.tween("text", typeof e == "function" ? A8(Up(this, "text", e)) : T8(e == null ? "" : e + ""));
}
function R8(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function q8(e) {
  var t, n;
  function a() {
    var o = e.apply(this, arguments);
    return o !== n && (t = (n = o) && R8(o)), t;
  }
  return a._value = e, a;
}
function F8(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, q8(e));
}
function V8() {
  for (var e = this._name, t = this._id, n = j_(), a = this._groups, o = a.length, r = 0; r < o; ++r)
    for (var s = a[r], i = s.length, u, d = 0; d < i; ++d)
      if (u = s[d]) {
        var c = Gn(u, t);
        Lu(u, e, n, d, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new Pa(a, this._parents, e, n);
}
function N8() {
  var e, t, n = this, a = n._id, o = n.size();
  return new Promise(function(r, s) {
    var i = { value: s }, u = { value: function() {
      --o === 0 && r();
    } };
    n.each(function() {
      var d = ca(this, a), c = d.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(i), t._.interrupt.push(i), t._.end.push(u)), d.on = t;
    }), o === 0 && r();
  });
}
var L8 = 0;
function Pa(e, t, n, a) {
  this._groups = e, this._parents = t, this._name = n, this._id = a;
}
function j_() {
  return ++L8;
}
var pa = Zs.prototype;
Pa.prototype = {
  constructor: Pa,
  select: w8,
  selectAll: x8,
  selectChild: pa.selectChild,
  selectChildren: pa.selectChildren,
  filter: v8,
  merge: m8,
  selection: S8,
  transition: V8,
  call: pa.call,
  nodes: pa.nodes,
  node: pa.node,
  size: pa.size,
  empty: pa.empty,
  each: pa.each,
  on: y8,
  attr: Z4,
  attrTween: a8,
  style: D8,
  styleTween: O8,
  text: I8,
  textTween: F8,
  remove: _8,
  tween: j4,
  delay: s8,
  duration: u8,
  ease: c8,
  easeVarying: p8,
  end: N8,
  [Symbol.iterator]: pa[Symbol.iterator]
};
const mh = (e) => +e;
function z8(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var H8 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: z8
};
function U8(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function j8(e) {
  var t, n;
  e instanceof Pa ? (t = e._id, e = e._name) : (t = j_(), (n = H8).time = Np(), e = e == null ? null : e + "");
  for (var a = this._groups, o = a.length, r = 0; r < o; ++r)
    for (var s = a[r], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && Lu(u, e, t, d, s, n || U8(u, t));
  return new Pa(a, this._parents, e, t);
}
Zs.prototype.interrupt = P4;
Zs.prototype.transition = j8;
function Od(e, t, n) {
  if (e.nodes().forEach((a) => F_(a)), t) {
    const a = e.transition().duration(t);
    return n && a.ease(n), a;
  } else
    return e;
}
class W_ {
  constructor(t) {
    this.data = t;
  }
  get data() {
    return this._data;
  }
  set data(t) {
    this._data = t;
  }
}
function Yn(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function K_(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const hh = Symbol("implicit");
function jp() {
  var e = new Lm(), t = [], n = [], a = hh;
  function o(r) {
    let s = e.get(r);
    if (s === void 0) {
      if (a !== hh) return a;
      e.set(r, s = t.push(r) - 1);
    }
    return n[s % n.length];
  }
  return o.domain = function(r) {
    if (!arguments.length) return t.slice();
    t = [], e = new Lm();
    for (const s of r)
      e.has(s) || e.set(s, t.push(s) - 1);
    return o;
  }, o.range = function(r) {
    return arguments.length ? (n = Array.from(r), o) : n.slice();
  }, o.unknown = function(r) {
    return arguments.length ? (a = r, o) : a;
  }, o.copy = function() {
    return jp(t, n).unknown(a);
  }, Yn.apply(o, arguments), o;
}
function Wp() {
  var e = jp().unknown(void 0), t = e.domain, n = e.range, a = 0, o = 1, r, s, i = !1, u = 0, d = 0, c = 0.5;
  delete e.unknown;
  function f() {
    var p = t().length, v = o < a, m = v ? o : a, h = v ? a : o;
    r = (h - m) / Math.max(1, p - u + d * 2), i && (r = Math.floor(r)), m += (h - m - r * (p - u)) * c, s = r * (1 - u), i && (m = Math.round(m), s = Math.round(s));
    var _ = nV(p).map(function(x) {
      return m + r * x;
    });
    return n(v ? _.reverse() : _);
  }
  return e.domain = function(p) {
    return arguments.length ? (t(p), f()) : t();
  }, e.range = function(p) {
    return arguments.length ? ([a, o] = p, a = +a, o = +o, f()) : [a, o];
  }, e.rangeRound = function(p) {
    return [a, o] = p, a = +a, o = +o, i = !0, f();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return r;
  }, e.round = function(p) {
    return arguments.length ? (i = !!p, f()) : i;
  }, e.padding = function(p) {
    return arguments.length ? (u = Math.min(1, d = +p), f()) : u;
  }, e.paddingInner = function(p) {
    return arguments.length ? (u = Math.min(1, p), f()) : u;
  }, e.paddingOuter = function(p) {
    return arguments.length ? (d = +p, f()) : d;
  }, e.align = function(p) {
    return arguments.length ? (c = Math.max(0, Math.min(1, p)), f()) : c;
  }, e.copy = function() {
    return Wp(t(), [a, o]).round(i).paddingInner(u).paddingOuter(d).align(c);
  }, Yn.apply(f(), arguments);
}
function G_(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return G_(t());
  }, e;
}
function W8() {
  return G_(Wp.apply(null, arguments).paddingInner(1));
}
function K8(e) {
  return function() {
    return e;
  };
}
function qc(e) {
  return +e;
}
var gh = [0, 1];
function pn(e) {
  return e;
}
function Fc(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : K8(isNaN(t) ? NaN : 0.5);
}
function G8(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(a) {
    return Math.max(e, Math.min(t, a));
  };
}
function Y8(e, t, n) {
  var a = e[0], o = e[1], r = t[0], s = t[1];
  return o < a ? (a = Fc(o, a), r = n(s, r)) : (a = Fc(a, o), r = n(r, s)), function(i) {
    return r(a(i));
  };
}
function X8(e, t, n) {
  var a = Math.min(e.length, t.length) - 1, o = new Array(a), r = new Array(a), s = -1;
  for (e[a] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < a; )
    o[s] = Fc(e[s], e[s + 1]), r[s] = n(t[s], t[s + 1]);
  return function(i) {
    var u = Qs(e, i, 1, a) - 1;
    return r[u](o[u](i));
  };
}
function nl(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function zu() {
  var e = gh, t = gh, n = Ir, a, o, r, s = pn, i, u, d;
  function c() {
    var p = Math.min(e.length, t.length);
    return s !== pn && (s = G8(e[0], e[p - 1])), i = p > 2 ? X8 : Y8, u = d = null, f;
  }
  function f(p) {
    return p == null || isNaN(p = +p) ? r : (u || (u = i(e.map(a), t, n)))(a(s(p)));
  }
  return f.invert = function(p) {
    return s(o((d || (d = i(t, e.map(a), qn)))(p)));
  }, f.domain = function(p) {
    return arguments.length ? (e = Array.from(p, qc), c()) : e.slice();
  }, f.range = function(p) {
    return arguments.length ? (t = Array.from(p), c()) : t.slice();
  }, f.rangeRound = function(p) {
    return t = Array.from(p), n = Hp, c();
  }, f.clamp = function(p) {
    return arguments.length ? (s = p ? !0 : pn, c()) : s !== pn;
  }, f.interpolate = function(p) {
    return arguments.length ? (n = p, c()) : n;
  }, f.unknown = function(p) {
    return arguments.length ? (r = p, f) : r;
  }, function(p, v) {
    return a = p, o = v, c();
  };
}
function Y_() {
  return zu()(pn, pn);
}
function J8(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Ai(e, t) {
  if (!isFinite(e) || e === 0) return null;
  var n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e"), a = e.slice(0, n);
  return [
    a.length > 1 ? a[0] + a.slice(2) : a,
    +e.slice(n + 1)
  ];
}
function mr(e) {
  return e = Ai(Math.abs(e)), e ? e[1] : NaN;
}
function Z8(e, t) {
  return function(n, a) {
    for (var o = n.length, r = [], s = 0, i = e[0], u = 0; o > 0 && i > 0 && (u + i + 1 > a && (i = Math.max(1, a - u)), r.push(n.substring(o -= i, o + i)), !((u += i + 1) > a)); )
      i = e[s = (s + 1) % e.length];
    return r.reverse().join(t);
  };
}
function Q8(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var eN = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Os(e) {
  if (!(t = eN.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new Kp({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Os.prototype = Kp.prototype;
function Kp(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
Kp.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function tN(e) {
  e: for (var t = e.length, n = 1, a = -1, o; n < t; ++n)
    switch (e[n]) {
      case ".":
        a = o = n;
        break;
      case "0":
        a === 0 && (a = n), o = n;
        break;
      default:
        if (!+e[n]) break e;
        a > 0 && (a = 0);
        break;
    }
  return a > 0 ? e.slice(0, a) + e.slice(o + 1) : e;
}
var Ii;
function nN(e, t) {
  var n = Ai(e, t);
  if (!n) return Ii = void 0, e.toPrecision(t);
  var a = n[0], o = n[1], r = o - (Ii = Math.max(-8, Math.min(8, Math.floor(o / 3))) * 3) + 1, s = a.length;
  return r === s ? a : r > s ? a + new Array(r - s + 1).join("0") : r > 0 ? a.slice(0, r) + "." + a.slice(r) : "0." + new Array(1 - r).join("0") + Ai(e, Math.max(0, t + r - 1))[0];
}
function yh(e, t) {
  var n = Ai(e, t);
  if (!n) return e + "";
  var a = n[0], o = n[1];
  return o < 0 ? "0." + new Array(-o).join("0") + a : a.length > o + 1 ? a.slice(0, o + 1) + "." + a.slice(o + 1) : a + new Array(o - a.length + 2).join("0");
}
const bh = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: J8,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => yh(e * 100, t),
  r: yh,
  s: nN,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function _h(e) {
  return e;
}
var wh = Array.prototype.map, xh = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function aN(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? _h : Z8(wh.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", a = e.currency === void 0 ? "" : e.currency[1] + "", o = e.decimal === void 0 ? "." : e.decimal + "", r = e.numerals === void 0 ? _h : Q8(wh.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", i = e.minus === void 0 ? "−" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function d(f, p) {
    f = Os(f);
    var v = f.fill, m = f.align, h = f.sign, _ = f.symbol, x = f.zero, S = f.width, $ = f.comma, D = f.precision, B = f.trim, k = f.type;
    k === "n" ? ($ = !0, k = "g") : bh[k] || (D === void 0 && (D = 12), B = !0, k = "g"), (x || v === "0" && m === "=") && (x = !0, v = "0", m = "=");
    var M = (p && p.prefix !== void 0 ? p.prefix : "") + (_ === "$" ? n : _ === "#" && /[boxX]/.test(k) ? "0" + k.toLowerCase() : ""), I = (_ === "$" ? a : /[%p]/.test(k) ? s : "") + (p && p.suffix !== void 0 ? p.suffix : ""), T = bh[k], P = /[defgprs%]/.test(k);
    D = D === void 0 ? 6 : /[gprs]/.test(k) ? Math.max(1, Math.min(21, D)) : Math.max(0, Math.min(20, D));
    function q(R) {
      var Q = M, ee = I, K, W, j;
      if (k === "c")
        ee = T(R) + ee, R = "";
      else {
        R = +R;
        var J = R < 0 || 1 / R < 0;
        if (R = isNaN(R) ? u : T(Math.abs(R), D), B && (R = tN(R)), J && +R == 0 && h !== "+" && (J = !1), Q = (J ? h === "(" ? h : i : h === "-" || h === "(" ? "" : h) + Q, ee = (k === "s" && !isNaN(R) && Ii !== void 0 ? xh[8 + Ii / 3] : "") + ee + (J && h === "(" ? ")" : ""), P) {
          for (K = -1, W = R.length; ++K < W; )
            if (j = R.charCodeAt(K), 48 > j || j > 57) {
              ee = (j === 46 ? o + R.slice(K + 1) : R.slice(K)) + ee, R = R.slice(0, K);
              break;
            }
        }
      }
      $ && !x && (R = t(R, 1 / 0));
      var z = Q.length + R.length + ee.length, Y = z < S ? new Array(S - z + 1).join(v) : "";
      switch ($ && x && (R = t(Y + R, Y.length ? S - ee.length : 1 / 0), Y = ""), m) {
        case "<":
          R = Q + R + ee + Y;
          break;
        case "=":
          R = Q + Y + R + ee;
          break;
        case "^":
          R = Y.slice(0, z = Y.length >> 1) + Q + R + ee + Y.slice(z);
          break;
        default:
          R = Y + Q + R + ee;
          break;
      }
      return r(R);
    }
    return q.toString = function() {
      return f + "";
    }, q;
  }
  function c(f, p) {
    var v = Math.max(-8, Math.min(8, Math.floor(mr(p) / 3))) * 3, m = Math.pow(10, -v), h = d((f = Os(f), f.type = "f", f), { suffix: xh[8 + v / 3] });
    return function(_) {
      return h(m * _);
    };
  }
  return {
    format: d,
    formatPrefix: c
  };
}
var El, Gp, X_;
oN({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function oN(e) {
  return El = aN(e), Gp = El.format, X_ = El.formatPrefix, El;
}
function rN(e) {
  return Math.max(0, -mr(Math.abs(e)));
}
function sN(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(mr(t) / 3))) * 3 - mr(Math.abs(e)));
}
function lN(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, mr(t) - mr(e)) + 1;
}
function iN(e, t, n, a) {
  var o = $c(e, t, n), r;
  switch (a = Os(a ?? ",f"), a.type) {
    case "s": {
      var s = Math.max(Math.abs(e), Math.abs(t));
      return a.precision == null && !isNaN(r = sN(o, s)) && (a.precision = r), X_(a, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      a.precision == null && !isNaN(r = lN(o, Math.max(Math.abs(e), Math.abs(t)))) && (a.precision = r - (a.type === "e"));
      break;
    }
    case "f":
    case "%": {
      a.precision == null && !isNaN(r = rN(o)) && (a.precision = r - (a.type === "%") * 2);
      break;
    }
  }
  return Gp(a);
}
function Ao(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var a = t();
    return Cc(a[0], a[a.length - 1], n ?? 10);
  }, e.tickFormat = function(n, a) {
    var o = t();
    return iN(o[0], o[o.length - 1], n ?? 10, a);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var a = t(), o = 0, r = a.length - 1, s = a[o], i = a[r], u, d, c = 10;
    for (i < s && (d = s, s = i, i = d, d = o, o = r, r = d); c-- > 0; ) {
      if (d = Sc(s, i, n), d === u)
        return a[o] = s, a[r] = i, t(a);
      if (d > 0)
        s = Math.floor(s / d) * d, i = Math.ceil(i / d) * d;
      else if (d < 0)
        s = Math.ceil(s * d) / d, i = Math.floor(i * d) / d;
      else
        break;
      u = d;
    }
    return e;
  }, e;
}
function J_() {
  var e = Y_();
  return e.copy = function() {
    return nl(e, J_());
  }, Yn.apply(e, arguments), Ao(e);
}
function Z_(e) {
  var t;
  function n(a) {
    return a == null || isNaN(a = +a) ? t : a;
  }
  return n.invert = n, n.domain = n.range = function(a) {
    return arguments.length ? (e = Array.from(a, qc), n) : e.slice();
  }, n.unknown = function(a) {
    return arguments.length ? (t = a, n) : t;
  }, n.copy = function() {
    return Z_(e).unknown(t);
  }, e = arguments.length ? Array.from(e, qc) : [0, 1], Ao(n);
}
function Q_(e, t) {
  e = e.slice();
  var n = 0, a = e.length - 1, o = e[n], r = e[a], s;
  return r < o && (s = n, n = a, a = s, s = o, o = r, r = s), e[n] = t.floor(o), e[a] = t.ceil(r), e;
}
function Ch(e) {
  return Math.log(e);
}
function Sh(e) {
  return Math.exp(e);
}
function uN(e) {
  return -Math.log(-e);
}
function dN(e) {
  return -Math.exp(-e);
}
function cN(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function fN(e) {
  return e === 10 ? cN : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function pN(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function $h(e) {
  return (t, n) => -e(-t, n);
}
function vN(e) {
  const t = e(Ch, Sh), n = t.domain;
  let a = 10, o, r;
  function s() {
    return o = pN(a), r = fN(a), n()[0] < 0 ? (o = $h(o), r = $h(r), e(uN, dN)) : e(Ch, Sh), t;
  }
  return t.base = function(i) {
    return arguments.length ? (a = +i, s()) : a;
  }, t.domain = function(i) {
    return arguments.length ? (n(i), s()) : n();
  }, t.ticks = (i) => {
    const u = n();
    let d = u[0], c = u[u.length - 1];
    const f = c < d;
    f && ([d, c] = [c, d]);
    let p = o(d), v = o(c), m, h;
    const _ = i == null ? 10 : +i;
    let x = [];
    if (!(a % 1) && v - p < _) {
      if (p = Math.floor(p), v = Math.ceil(v), d > 0) {
        for (; p <= v; ++p)
          for (m = 1; m < a; ++m)
            if (h = p < 0 ? m / r(-p) : m * r(p), !(h < d)) {
              if (h > c) break;
              x.push(h);
            }
      } else for (; p <= v; ++p)
        for (m = a - 1; m >= 1; --m)
          if (h = p > 0 ? m / r(-p) : m * r(p), !(h < d)) {
            if (h > c) break;
            x.push(h);
          }
      x.length * 2 < _ && (x = Cc(d, c, _));
    } else
      x = Cc(p, v, Math.min(v - p, _)).map(r);
    return f ? x.reverse() : x;
  }, t.tickFormat = (i, u) => {
    if (i == null && (i = 10), u == null && (u = a === 10 ? "s" : ","), typeof u != "function" && (!(a % 1) && (u = Os(u)).precision == null && (u.trim = !0), u = Gp(u)), i === 1 / 0) return u;
    const d = Math.max(1, a * i / t.ticks().length);
    return (c) => {
      let f = c / r(Math.round(o(c)));
      return f * a < a - 0.5 && (f *= a), f <= d ? u(c) : "";
    };
  }, t.nice = () => n(Q_(n(), {
    floor: (i) => r(Math.floor(o(i))),
    ceil: (i) => r(Math.ceil(o(i)))
  })), t;
}
function ew() {
  const e = vN(zu()).domain([1, 10]);
  return e.copy = () => nl(e, ew()).base(e.base()), Yn.apply(e, arguments), e;
}
function Bh(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function Ph(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function mN(e) {
  var t = 1, n = e(Bh(t), Ph(t));
  return n.constant = function(a) {
    return arguments.length ? e(Bh(t = +a), Ph(t)) : t;
  }, Ao(n);
}
function tw() {
  var e = mN(zu());
  return e.copy = function() {
    return nl(e, tw()).constant(e.constant());
  }, Yn.apply(e, arguments);
}
function Eh(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function hN(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function gN(e) {
  return e < 0 ? -e * e : e * e;
}
function yN(e) {
  var t = e(pn, pn), n = 1;
  function a() {
    return n === 1 ? e(pn, pn) : n === 0.5 ? e(hN, gN) : e(Eh(n), Eh(1 / n));
  }
  return t.exponent = function(o) {
    return arguments.length ? (n = +o, a()) : n;
  }, Ao(t);
}
function Yp() {
  var e = yN(zu());
  return e.copy = function() {
    return nl(e, Yp()).exponent(e.exponent());
  }, Yn.apply(e, arguments), e;
}
function bN() {
  return Yp.apply(null, arguments).exponent(0.5);
}
function nw() {
  var e = [], t = [], n = [], a;
  function o() {
    var s = 0, i = Math.max(1, t.length);
    for (n = new Array(i - 1); ++s < i; ) n[s - 1] = tV(e, s / i);
    return r;
  }
  function r(s) {
    return s == null || isNaN(s = +s) ? a : t[Qs(n, s)];
  }
  return r.invertExtent = function(s) {
    var i = t.indexOf(s);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? n[i - 1] : e[0],
      i < n.length ? n[i] : e[e.length - 1]
    ];
  }, r.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of s) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort(us), o();
  }, r.range = function(s) {
    return arguments.length ? (t = Array.from(s), o()) : t.slice();
  }, r.unknown = function(s) {
    return arguments.length ? (a = s, r) : a;
  }, r.quantiles = function() {
    return n.slice();
  }, r.copy = function() {
    return nw().domain(e).range(t).unknown(a);
  }, Yn.apply(r, arguments);
}
function aw() {
  var e = 0, t = 1, n = 1, a = [0.5], o = [0, 1], r;
  function s(u) {
    return u != null && u <= u ? o[Qs(a, u, 0, n)] : r;
  }
  function i() {
    var u = -1;
    for (a = new Array(n); ++u < n; ) a[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return s;
  }
  return s.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, i()) : [e, t];
  }, s.range = function(u) {
    return arguments.length ? (n = (o = Array.from(u)).length - 1, i()) : o.slice();
  }, s.invertExtent = function(u) {
    var d = o.indexOf(u);
    return d < 0 ? [NaN, NaN] : d < 1 ? [e, a[0]] : d >= n ? [a[n - 1], t] : [a[d - 1], a[d]];
  }, s.unknown = function(u) {
    return arguments.length && (r = u), s;
  }, s.thresholds = function() {
    return a.slice();
  }, s.copy = function() {
    return aw().domain([e, t]).range(o).unknown(r);
  }, Yn.apply(Ao(s), arguments);
}
function ow() {
  var e = [0.5], t = [0, 1], n, a = 1;
  function o(r) {
    return r != null && r <= r ? t[Qs(e, r, 0, a)] : n;
  }
  return o.domain = function(r) {
    return arguments.length ? (e = Array.from(r), a = Math.min(e.length, t.length - 1), o) : e.slice();
  }, o.range = function(r) {
    return arguments.length ? (t = Array.from(r), a = Math.min(e.length, t.length - 1), o) : t.slice();
  }, o.invertExtent = function(r) {
    var s = t.indexOf(r);
    return [e[s - 1], e[s]];
  }, o.unknown = function(r) {
    return arguments.length ? (n = r, o) : n;
  }, o.copy = function() {
    return ow().domain(e).range(t).unknown(n);
  }, Yn.apply(o, arguments);
}
const Td = /* @__PURE__ */ new Date(), Ad = /* @__PURE__ */ new Date();
function qt(e, t, n, a) {
  function o(r) {
    return e(r = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+r)), r;
  }
  return o.floor = (r) => (e(r = /* @__PURE__ */ new Date(+r)), r), o.ceil = (r) => (e(r = new Date(r - 1)), t(r, 1), e(r), r), o.round = (r) => {
    const s = o(r), i = o.ceil(r);
    return r - s < i - r ? s : i;
  }, o.offset = (r, s) => (t(r = /* @__PURE__ */ new Date(+r), s == null ? 1 : Math.floor(s)), r), o.range = (r, s, i) => {
    const u = [];
    if (r = o.ceil(r), i = i == null ? 1 : Math.floor(i), !(r < s) || !(i > 0)) return u;
    let d;
    do
      u.push(d = /* @__PURE__ */ new Date(+r)), t(r, i), e(r);
    while (d < r && r < s);
    return u;
  }, o.filter = (r) => qt((s) => {
    if (s >= s) for (; e(s), !r(s); ) s.setTime(s - 1);
  }, (s, i) => {
    if (s >= s)
      if (i < 0) for (; ++i <= 0; )
        for (; t(s, -1), !r(s); )
          ;
      else for (; --i >= 0; )
        for (; t(s, 1), !r(s); )
          ;
  }), n && (o.count = (r, s) => (Td.setTime(+r), Ad.setTime(+s), e(Td), e(Ad), Math.floor(n(Td, Ad))), o.every = (r) => (r = Math.floor(r), !isFinite(r) || !(r > 0) ? null : r > 1 ? o.filter(a ? (s) => a(s) % r === 0 : (s) => o.count(0, s) % r === 0) : o)), o;
}
const Ri = qt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
Ri.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? qt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : Ri);
Ri.range;
const xa = 1e3, Dn = xa * 60, Ca = Dn * 60, Ea = Ca * 24, Xp = Ea * 7, Dh = Ea * 30, Id = Ea * 365, po = qt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * xa);
}, (e, t) => (t - e) / xa, (e) => e.getUTCSeconds());
po.range;
const Jp = qt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * xa);
}, (e, t) => {
  e.setTime(+e + t * Dn);
}, (e, t) => (t - e) / Dn, (e) => e.getMinutes());
Jp.range;
const Zp = qt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Dn);
}, (e, t) => (t - e) / Dn, (e) => e.getUTCMinutes());
Zp.range;
const Qp = qt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * xa - e.getMinutes() * Dn);
}, (e, t) => {
  e.setTime(+e + t * Ca);
}, (e, t) => (t - e) / Ca, (e) => e.getHours());
Qp.range;
const ev = qt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * Ca);
}, (e, t) => (t - e) / Ca, (e) => e.getUTCHours());
ev.range;
const al = qt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Dn) / Ea,
  (e) => e.getDate() - 1
);
al.range;
const Hu = qt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / Ea, (e) => e.getUTCDate() - 1);
Hu.range;
const rw = qt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / Ea, (e) => Math.floor(e / Ea));
rw.range;
function Io(e) {
  return qt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Dn) / Xp);
}
const Uu = Io(0), qi = Io(1), _N = Io(2), wN = Io(3), hr = Io(4), xN = Io(5), CN = Io(6);
Uu.range;
qi.range;
_N.range;
wN.range;
hr.range;
xN.range;
CN.range;
function Ro(e) {
  return qt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / Xp);
}
const ju = Ro(0), Fi = Ro(1), SN = Ro(2), $N = Ro(3), gr = Ro(4), BN = Ro(5), PN = Ro(6);
ju.range;
Fi.range;
SN.range;
$N.range;
gr.range;
BN.range;
PN.range;
const tv = qt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
tv.range;
const nv = qt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
nv.range;
const Da = qt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
Da.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : qt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
Da.range;
const Ma = qt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
Ma.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : qt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
Ma.range;
function sw(e, t, n, a, o, r) {
  const s = [
    [po, 1, xa],
    [po, 5, 5 * xa],
    [po, 15, 15 * xa],
    [po, 30, 30 * xa],
    [r, 1, Dn],
    [r, 5, 5 * Dn],
    [r, 15, 15 * Dn],
    [r, 30, 30 * Dn],
    [o, 1, Ca],
    [o, 3, 3 * Ca],
    [o, 6, 6 * Ca],
    [o, 12, 12 * Ca],
    [a, 1, Ea],
    [a, 2, 2 * Ea],
    [n, 1, Xp],
    [t, 1, Dh],
    [t, 3, 3 * Dh],
    [e, 1, Id]
  ];
  function i(d, c, f) {
    const p = c < d;
    p && ([d, c] = [c, d]);
    const v = f && typeof f.range == "function" ? f : u(d, c, f), m = v ? v.range(d, +c + 1) : [];
    return p ? m.reverse() : m;
  }
  function u(d, c, f) {
    const p = Math.abs(c - d) / f, v = kp(([, , _]) => _).right(s, p);
    if (v === s.length) return e.every($c(d / Id, c / Id, f));
    if (v === 0) return Ri.every(Math.max($c(d, c, f), 1));
    const [m, h] = s[p / s[v - 1][2] < s[v][2] / p ? v - 1 : v];
    return m.every(h);
  }
  return [i, u];
}
const [EN, DN] = sw(Ma, nv, ju, rw, ev, Zp), [MN, kN] = sw(Da, tv, Uu, al, Qp, Jp);
function Rd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function qd(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function jr(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function ON(e) {
  var t = e.dateTime, n = e.date, a = e.time, o = e.periods, r = e.days, s = e.shortDays, i = e.months, u = e.shortMonths, d = Wr(o), c = Kr(o), f = Wr(r), p = Kr(r), v = Wr(s), m = Kr(s), h = Wr(i), _ = Kr(i), x = Wr(u), S = Kr(u), $ = {
    a: j,
    A: J,
    b: z,
    B: Y,
    c: null,
    d: Ih,
    e: Ih,
    f: tL,
    g: cL,
    G: pL,
    H: ZN,
    I: QN,
    j: eL,
    L: lw,
    m: nL,
    M: aL,
    p: Z,
    q: pe,
    Q: Fh,
    s: Vh,
    S: oL,
    u: rL,
    U: sL,
    V: lL,
    w: iL,
    W: uL,
    x: null,
    X: null,
    y: dL,
    Y: fL,
    Z: vL,
    "%": qh
  }, D = {
    a: $e,
    A: Ce,
    b: De,
    B: ue,
    c: null,
    d: Rh,
    e: Rh,
    f: yL,
    g: EL,
    G: ML,
    H: mL,
    I: hL,
    j: gL,
    L: uw,
    m: bL,
    M: _L,
    p: V,
    q: te,
    Q: Fh,
    s: Vh,
    S: wL,
    u: xL,
    U: CL,
    V: SL,
    w: $L,
    W: BL,
    x: null,
    X: null,
    y: PL,
    Y: DL,
    Z: kL,
    "%": qh
  }, B = {
    a: P,
    A: q,
    b: R,
    B: Q,
    c: ee,
    d: Th,
    e: Th,
    f: GN,
    g: Oh,
    G: kh,
    H: Ah,
    I: Ah,
    j: UN,
    L: KN,
    m: HN,
    M: jN,
    p: T,
    q: zN,
    Q: XN,
    s: JN,
    S: WN,
    u: qN,
    U: FN,
    V: VN,
    w: RN,
    W: NN,
    x: K,
    X: W,
    y: Oh,
    Y: kh,
    Z: LN,
    "%": YN
  };
  $.x = k(n, $), $.X = k(a, $), $.c = k(t, $), D.x = k(n, D), D.X = k(a, D), D.c = k(t, D);
  function k(H, re) {
    return function(ie) {
      var L = [], _e = -1, we = 0, Te = H.length, Ne, Je, xe;
      for (ie instanceof Date || (ie = /* @__PURE__ */ new Date(+ie)); ++_e < Te; )
        H.charCodeAt(_e) === 37 && (L.push(H.slice(we, _e)), (Je = Mh[Ne = H.charAt(++_e)]) != null ? Ne = H.charAt(++_e) : Je = Ne === "e" ? " " : "0", (xe = re[Ne]) && (Ne = xe(ie, Je)), L.push(Ne), we = _e + 1);
      return L.push(H.slice(we, _e)), L.join("");
    };
  }
  function M(H, re) {
    return function(ie) {
      var L = jr(1900, void 0, 1), _e = I(L, H, ie += "", 0), we, Te;
      if (_e != ie.length) return null;
      if ("Q" in L) return new Date(L.Q);
      if ("s" in L) return new Date(L.s * 1e3 + ("L" in L ? L.L : 0));
      if (re && !("Z" in L) && (L.Z = 0), "p" in L && (L.H = L.H % 12 + L.p * 12), L.m === void 0 && (L.m = "q" in L ? L.q : 0), "V" in L) {
        if (L.V < 1 || L.V > 53) return null;
        "w" in L || (L.w = 1), "Z" in L ? (we = qd(jr(L.y, 0, 1)), Te = we.getUTCDay(), we = Te > 4 || Te === 0 ? Fi.ceil(we) : Fi(we), we = Hu.offset(we, (L.V - 1) * 7), L.y = we.getUTCFullYear(), L.m = we.getUTCMonth(), L.d = we.getUTCDate() + (L.w + 6) % 7) : (we = Rd(jr(L.y, 0, 1)), Te = we.getDay(), we = Te > 4 || Te === 0 ? qi.ceil(we) : qi(we), we = al.offset(we, (L.V - 1) * 7), L.y = we.getFullYear(), L.m = we.getMonth(), L.d = we.getDate() + (L.w + 6) % 7);
      } else ("W" in L || "U" in L) && ("w" in L || (L.w = "u" in L ? L.u % 7 : "W" in L ? 1 : 0), Te = "Z" in L ? qd(jr(L.y, 0, 1)).getUTCDay() : Rd(jr(L.y, 0, 1)).getDay(), L.m = 0, L.d = "W" in L ? (L.w + 6) % 7 + L.W * 7 - (Te + 5) % 7 : L.w + L.U * 7 - (Te + 6) % 7);
      return "Z" in L ? (L.H += L.Z / 100 | 0, L.M += L.Z % 100, qd(L)) : Rd(L);
    };
  }
  function I(H, re, ie, L) {
    for (var _e = 0, we = re.length, Te = ie.length, Ne, Je; _e < we; ) {
      if (L >= Te) return -1;
      if (Ne = re.charCodeAt(_e++), Ne === 37) {
        if (Ne = re.charAt(_e++), Je = B[Ne in Mh ? re.charAt(_e++) : Ne], !Je || (L = Je(H, ie, L)) < 0) return -1;
      } else if (Ne != ie.charCodeAt(L++))
        return -1;
    }
    return L;
  }
  function T(H, re, ie) {
    var L = d.exec(re.slice(ie));
    return L ? (H.p = c.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function P(H, re, ie) {
    var L = v.exec(re.slice(ie));
    return L ? (H.w = m.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function q(H, re, ie) {
    var L = f.exec(re.slice(ie));
    return L ? (H.w = p.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function R(H, re, ie) {
    var L = x.exec(re.slice(ie));
    return L ? (H.m = S.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function Q(H, re, ie) {
    var L = h.exec(re.slice(ie));
    return L ? (H.m = _.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function ee(H, re, ie) {
    return I(H, t, re, ie);
  }
  function K(H, re, ie) {
    return I(H, n, re, ie);
  }
  function W(H, re, ie) {
    return I(H, a, re, ie);
  }
  function j(H) {
    return s[H.getDay()];
  }
  function J(H) {
    return r[H.getDay()];
  }
  function z(H) {
    return u[H.getMonth()];
  }
  function Y(H) {
    return i[H.getMonth()];
  }
  function Z(H) {
    return o[+(H.getHours() >= 12)];
  }
  function pe(H) {
    return 1 + ~~(H.getMonth() / 3);
  }
  function $e(H) {
    return s[H.getUTCDay()];
  }
  function Ce(H) {
    return r[H.getUTCDay()];
  }
  function De(H) {
    return u[H.getUTCMonth()];
  }
  function ue(H) {
    return i[H.getUTCMonth()];
  }
  function V(H) {
    return o[+(H.getUTCHours() >= 12)];
  }
  function te(H) {
    return 1 + ~~(H.getUTCMonth() / 3);
  }
  return {
    format: function(H) {
      var re = k(H += "", $);
      return re.toString = function() {
        return H;
      }, re;
    },
    parse: function(H) {
      var re = M(H += "", !1);
      return re.toString = function() {
        return H;
      }, re;
    },
    utcFormat: function(H) {
      var re = k(H += "", D);
      return re.toString = function() {
        return H;
      }, re;
    },
    utcParse: function(H) {
      var re = M(H += "", !0);
      return re.toString = function() {
        return H;
      }, re;
    }
  };
}
var Mh = { "-": "", _: " ", 0: "0" }, Ht = /^\s*\d+/, TN = /^%/, AN = /[\\^$*+?|[\]().{}]/g;
function tt(e, t, n) {
  var a = e < 0 ? "-" : "", o = (a ? -e : e) + "", r = o.length;
  return a + (r < n ? new Array(n - r + 1).join(t) + o : o);
}
function IN(e) {
  return e.replace(AN, "\\$&");
}
function Wr(e) {
  return new RegExp("^(?:" + e.map(IN).join("|") + ")", "i");
}
function Kr(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function RN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 1));
  return a ? (e.w = +a[0], n + a[0].length) : -1;
}
function qN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 1));
  return a ? (e.u = +a[0], n + a[0].length) : -1;
}
function FN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.U = +a[0], n + a[0].length) : -1;
}
function VN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.V = +a[0], n + a[0].length) : -1;
}
function NN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.W = +a[0], n + a[0].length) : -1;
}
function kh(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 4));
  return a ? (e.y = +a[0], n + a[0].length) : -1;
}
function Oh(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), n + a[0].length) : -1;
}
function LN(e, t, n) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), n + a[0].length) : -1;
}
function zN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 1));
  return a ? (e.q = a[0] * 3 - 3, n + a[0].length) : -1;
}
function HN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.m = a[0] - 1, n + a[0].length) : -1;
}
function Th(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.d = +a[0], n + a[0].length) : -1;
}
function UN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 3));
  return a ? (e.m = 0, e.d = +a[0], n + a[0].length) : -1;
}
function Ah(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.H = +a[0], n + a[0].length) : -1;
}
function jN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.M = +a[0], n + a[0].length) : -1;
}
function WN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 2));
  return a ? (e.S = +a[0], n + a[0].length) : -1;
}
function KN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 3));
  return a ? (e.L = +a[0], n + a[0].length) : -1;
}
function GN(e, t, n) {
  var a = Ht.exec(t.slice(n, n + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), n + a[0].length) : -1;
}
function YN(e, t, n) {
  var a = TN.exec(t.slice(n, n + 1));
  return a ? n + a[0].length : -1;
}
function XN(e, t, n) {
  var a = Ht.exec(t.slice(n));
  return a ? (e.Q = +a[0], n + a[0].length) : -1;
}
function JN(e, t, n) {
  var a = Ht.exec(t.slice(n));
  return a ? (e.s = +a[0], n + a[0].length) : -1;
}
function Ih(e, t) {
  return tt(e.getDate(), t, 2);
}
function ZN(e, t) {
  return tt(e.getHours(), t, 2);
}
function QN(e, t) {
  return tt(e.getHours() % 12 || 12, t, 2);
}
function eL(e, t) {
  return tt(1 + al.count(Da(e), e), t, 3);
}
function lw(e, t) {
  return tt(e.getMilliseconds(), t, 3);
}
function tL(e, t) {
  return lw(e, t) + "000";
}
function nL(e, t) {
  return tt(e.getMonth() + 1, t, 2);
}
function aL(e, t) {
  return tt(e.getMinutes(), t, 2);
}
function oL(e, t) {
  return tt(e.getSeconds(), t, 2);
}
function rL(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function sL(e, t) {
  return tt(Uu.count(Da(e) - 1, e), t, 2);
}
function iw(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? hr(e) : hr.ceil(e);
}
function lL(e, t) {
  return e = iw(e), tt(hr.count(Da(e), e) + (Da(e).getDay() === 4), t, 2);
}
function iL(e) {
  return e.getDay();
}
function uL(e, t) {
  return tt(qi.count(Da(e) - 1, e), t, 2);
}
function dL(e, t) {
  return tt(e.getFullYear() % 100, t, 2);
}
function cL(e, t) {
  return e = iw(e), tt(e.getFullYear() % 100, t, 2);
}
function fL(e, t) {
  return tt(e.getFullYear() % 1e4, t, 4);
}
function pL(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? hr(e) : hr.ceil(e), tt(e.getFullYear() % 1e4, t, 4);
}
function vL(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + tt(t / 60 | 0, "0", 2) + tt(t % 60, "0", 2);
}
function Rh(e, t) {
  return tt(e.getUTCDate(), t, 2);
}
function mL(e, t) {
  return tt(e.getUTCHours(), t, 2);
}
function hL(e, t) {
  return tt(e.getUTCHours() % 12 || 12, t, 2);
}
function gL(e, t) {
  return tt(1 + Hu.count(Ma(e), e), t, 3);
}
function uw(e, t) {
  return tt(e.getUTCMilliseconds(), t, 3);
}
function yL(e, t) {
  return uw(e, t) + "000";
}
function bL(e, t) {
  return tt(e.getUTCMonth() + 1, t, 2);
}
function _L(e, t) {
  return tt(e.getUTCMinutes(), t, 2);
}
function wL(e, t) {
  return tt(e.getUTCSeconds(), t, 2);
}
function xL(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function CL(e, t) {
  return tt(ju.count(Ma(e) - 1, e), t, 2);
}
function dw(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? gr(e) : gr.ceil(e);
}
function SL(e, t) {
  return e = dw(e), tt(gr.count(Ma(e), e) + (Ma(e).getUTCDay() === 4), t, 2);
}
function $L(e) {
  return e.getUTCDay();
}
function BL(e, t) {
  return tt(Fi.count(Ma(e) - 1, e), t, 2);
}
function PL(e, t) {
  return tt(e.getUTCFullYear() % 100, t, 2);
}
function EL(e, t) {
  return e = dw(e), tt(e.getUTCFullYear() % 100, t, 2);
}
function DL(e, t) {
  return tt(e.getUTCFullYear() % 1e4, t, 4);
}
function ML(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? gr(e) : gr.ceil(e), tt(e.getUTCFullYear() % 1e4, t, 4);
}
function kL() {
  return "+0000";
}
function qh() {
  return "%";
}
function Fh(e) {
  return +e;
}
function Vh(e) {
  return Math.floor(+e / 1e3);
}
var Ho, cw, fw;
OL({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function OL(e) {
  return Ho = ON(e), cw = Ho.format, Ho.parse, fw = Ho.utcFormat, Ho.utcParse, Ho;
}
function TL(e) {
  return new Date(e);
}
function AL(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function av(e, t, n, a, o, r, s, i, u, d) {
  var c = Y_(), f = c.invert, p = c.domain, v = d(".%L"), m = d(":%S"), h = d("%I:%M"), _ = d("%I %p"), x = d("%a %d"), S = d("%b %d"), $ = d("%B"), D = d("%Y");
  function B(k) {
    return (u(k) < k ? v : i(k) < k ? m : s(k) < k ? h : r(k) < k ? _ : a(k) < k ? o(k) < k ? x : S : n(k) < k ? $ : D)(k);
  }
  return c.invert = function(k) {
    return new Date(f(k));
  }, c.domain = function(k) {
    return arguments.length ? p(Array.from(k, AL)) : p().map(TL);
  }, c.ticks = function(k) {
    var M = p();
    return e(M[0], M[M.length - 1], k ?? 10);
  }, c.tickFormat = function(k, M) {
    return M == null ? B : d(M);
  }, c.nice = function(k) {
    var M = p();
    return (!k || typeof k.range != "function") && (k = t(M[0], M[M.length - 1], k ?? 10)), k ? p(Q_(M, k)) : c;
  }, c.copy = function() {
    return nl(c, av(e, t, n, a, o, r, s, i, u, d));
  }, c;
}
function IL() {
  return Yn.apply(av(MN, kN, Da, tv, Uu, al, Qp, Jp, po, cw).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function RL() {
  return Yn.apply(av(EN, DN, Ma, nv, ju, Hu, ev, Zp, po, fw).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function qL() {
  var e = 0, t = 1, n, a, o, r, s = pn, i = !1, u;
  function d(f) {
    return f == null || isNaN(f = +f) ? u : s(o === 0 ? 0.5 : (f = (r(f) - n) * o, i ? Math.max(0, Math.min(1, f)) : f));
  }
  d.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = r(e = +e), a = r(t = +t), o = n === a ? 0 : 1 / (a - n), d) : [e, t];
  }, d.clamp = function(f) {
    return arguments.length ? (i = !!f, d) : i;
  }, d.interpolator = function(f) {
    return arguments.length ? (s = f, d) : s;
  };
  function c(f) {
    return function(p) {
      var v, m;
      return arguments.length ? ([v, m] = p, s = f(v, m), d) : [s(0), s(1)];
    };
  }
  return d.range = c(Ir), d.rangeRound = c(Hp), d.unknown = function(f) {
    return arguments.length ? (u = f, d) : u;
  }, function(f) {
    return r = f, n = f(e), a = f(t), o = n === a ? 0 : 1 / (a - n), d;
  };
}
function pw(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function vw() {
  var e = Ao(qL()(pn));
  return e.copy = function() {
    return pw(e, vw());
  }, K_.apply(e, arguments);
}
function FL() {
  var e = 0, t = 0.5, n = 1, a = 1, o, r, s, i, u, d = pn, c, f = !1, p;
  function v(h) {
    return isNaN(h = +h) ? p : (h = 0.5 + ((h = +c(h)) - r) * (a * h < a * r ? i : u), d(f ? Math.max(0, Math.min(1, h)) : h));
  }
  v.domain = function(h) {
    return arguments.length ? ([e, t, n] = h, o = c(e = +e), r = c(t = +t), s = c(n = +n), i = o === r ? 0 : 0.5 / (r - o), u = r === s ? 0 : 0.5 / (s - r), a = r < o ? -1 : 1, v) : [e, t, n];
  }, v.clamp = function(h) {
    return arguments.length ? (f = !!h, v) : f;
  }, v.interpolator = function(h) {
    return arguments.length ? (d = h, v) : d;
  };
  function m(h) {
    return function(_) {
      var x, S, $;
      return arguments.length ? ([x, S, $] = _, d = z4(h, [x, S, $]), v) : [d(0), d(0.5), d(1)];
    };
  }
  return v.range = m(Ir), v.rangeRound = m(Hp), v.unknown = function(h) {
    return arguments.length ? (p = h, v) : p;
  }, function(h) {
    return c = h, o = h(e), r = h(t), s = h(n), i = o === r ? 0 : 0.5 / (r - o), u = r === s ? 0 : 0.5 / (s - r), a = r < o ? -1 : 1, v;
  };
}
function mw() {
  var e = Ao(FL()(pn));
  return e.copy = function() {
    return pw(e, mw());
  }, K_.apply(e, arguments);
}
const Nh = {
  scaleLinear: J_,
  scalePow: Yp,
  scaleSqrt: bN,
  scaleLog: ew,
  scaleSymlog: tw,
  scaleIdentity: Z_,
  scaleTime: IL,
  scaleUtc: RL,
  scaleSequential: vw,
  scaleDiverging: mw,
  scaleQuantize: aw,
  scaleQuantile: nw,
  scaleThreshold: ow,
  scaleOrdinal: jp,
  scaleBand: Wp,
  scalePoint: W8
};
var Jn;
(function(e) {
  e.X = "x", e.Y = "y";
})(Jn || (Jn = {}));
const hw = {
  duration: 600,
  events: {},
  attributes: {}
};
class VL {
  constructor(t = is.SVG) {
    var n, a;
    this.type = is.SVG, this.datamodel = new W_(), this.sizing = xc.Fit, this.events = {}, this._defaultConfig = hw, this._width = 400, this._height = 200, this._containerWidth = void 0, this._containerHeight = void 0, this._containerMargin = { top: 0, bottom: 0, left: 0, right: 0 }, this._setUpComponentEventsThrottled = Si(this._setUpComponentEvents, 500), this._setCustomAttributesThrottled = Si(this._setCustomAttributes, 500), t === is.SVG ? this.element = document.createElementNS("http://www.w3.org/2000/svg", "g") : this.element = document.createElement("div"), this.uid = ZV(), this.g = Xa(this.element);
    const o = (a = (n = this.constructor) === null || n === void 0 ? void 0 : n.selectors) === null || a === void 0 ? void 0 : a.root;
    o && this.g.attr("class", o);
  }
  /** Set the container margin. Called automatically by containers. */
  setContainerMargin(t) {
    this._containerMargin = t;
  }
  setConfig(t) {
    this.prevConfig = this.config, this.config = Ru(this._defaultConfig, t);
  }
  setData(t) {
    this.datamodel.data = t;
  }
  setSize(t, n, a, o) {
    isFinite(t) && (this._width = t), isFinite(n) && (this._height = n), isFinite(a) && (this._containerWidth = a), isFinite(o) && (this._containerHeight = o);
  }
  render(t = this.config.duration) {
    this._render(t);
    const n = "animating";
    t && (this.g.attr(n, ""), this.g.transition(n).duration(t).on("end interrupt", () => {
      this.g.attr(n, null);
    })), this._setUpComponentEventsThrottled(), this._setCustomAttributesThrottled();
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _render(t = this.config.duration) {
  }
  _setCustomAttributes() {
    const t = this.config.attributes;
    Object.keys(t).forEach((n) => {
      Object.keys(t[n]).forEach((a) => {
        this.g.selectAll(`.${n}`).attr(a, t[n][a]);
      });
    });
  }
  _setUpComponentEvents() {
    this._bindEvents(this.events), this._bindEvents(this.config.events, ".user");
  }
  _bindEvents(t = this.events, n = "") {
    Object.keys(t).forEach((a) => {
      Object.keys(t[a]).forEach((o) => {
        const r = this.g.selectAll(`.${a}`);
        r.on(o + n, (s, i) => {
          const u = r.nodes(), d = u.indexOf(s.currentTarget), c = t[a][o];
          return c == null ? void 0 : c(i, s, d, u);
        });
      });
    });
  }
  destroy() {
    var t;
    (t = this.g) === null || t === void 0 || t.remove(), this.element = void 0;
  }
  isDestroyed() {
    return !this.element;
  }
}
class NL extends W_ {
  constructor(t) {
    super(t);
  }
  get data() {
    var t;
    return (t = this._data) !== null && t !== void 0 ? t : [];
  }
  set data(t) {
    Array.isArray(t) && (this._data = t);
  }
}
const gw = Object.assign(Object.assign({}, hw), { x: void 0, y: void 0, id: (e, t) => {
  var n;
  return (n = e.id) !== null && n !== void 0 ? n : `${t}`;
}, color: (e) => e.color, xScale: void 0, yScale: void 0, excludeFromDomainCalculation: !1 });
class LL extends VL {
  constructor() {
    super(...arguments), this.datamodel = new NL(), this.clippable = !0, this.stacked = !1, this._defaultConfig = gw, this._xScale = Nh.scaleLinear(), this._yScale = Nh.scaleLinear();
  }
  get xScale() {
    return this.config.xScale || this._xScale;
  }
  get yScale() {
    return this.config.yScale || this._yScale;
  }
  setConfig(t) {
    var n, a;
    !((n = this.config) === null || n === void 0) && n.xScale && (t.xScale = this.config.xScale), !((a = this.config) === null || a === void 0) && a.yScale && (t.yScale = this.config.yScale), super.setConfig(t);
  }
  setScaleDomain(t, n) {
    var a, o;
    t === Jn.X && ((a = this._xScale) === null || a === void 0 || a.domain(n)), t === Jn.Y && ((o = this._yScale) === null || o === void 0 || o.domain(n));
  }
  setScaleRange(t, n) {
    var a, o;
    t === Jn.X && ((a = this._xScale) === null || a === void 0 || a.range(n)), t === Jn.Y && ((o = this._yScale) === null || o === void 0 || o.range(n));
  }
  setScale(t, n) {
    n && t === Jn.X && (this._xScale = n), n && t === Jn.Y && (this._yScale = n);
  }
  getDataExtent(t, n) {
    const { config: a, datamodel: o } = this;
    switch (t) {
      case Jn.X:
        return this.getXDataExtent();
      case Jn.Y:
        return this.getYDataExtent(n);
      default:
        return Pd(o.data, a[t]);
    }
  }
  getXDataExtent() {
    const { config: t, datamodel: n } = this;
    return Pd(n.data, t.x);
  }
  /** Some components override this method to provide custom data extent calculation */
  getYDataExtent(t) {
    const { config: n, datamodel: a } = this, o = this.xScale.domain(), r = t ? iV(a.data, o, n.x, !0) : a.data, s = Tp(n.y) ? n.y : [n.y];
    return Pd(r, ...s);
  }
}
var at;
(function(e) {
  e.Top = "top", e.Bottom = "bottom", e.Left = "left", e.Right = "right", e.Center = "center", e.Auto = "auto";
})(at || (at = {}));
var Lh;
(function(e) {
  e.Absolute = "absolute", e.Fixed = "fixed";
})(Lh || (Lh = {}));
var zh;
(function(e) {
  e.Inside = "inside", e.Outside = "outside", e.Center = "center";
})(zh || (zh = {}));
var Hh;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(Hh || (Hh = {}));
const zL = {
  components: [],
  container: void 0,
  followCursor: !0,
  allowHover: !1,
  horizontalPlacement: at.Auto,
  horizontalShift: 0,
  verticalPlacement: at.Top,
  verticalShift: 0,
  attributes: {},
  triggers: {},
  className: void 0,
  showDelay: void 0,
  hideDelay: void 0
}, Wu = gn`
  label: tooltip;
  display: inline-block;
  left: 0;
  bottom: 0;
  min-width: max-content;
  position: absolute;
  opacity: 0;
  transition: opacity;
  transition-duration: var(--vis-tooltip-transition-duration);
  z-index: 999999;
  padding: var(--vis-tooltip-padding);
  color: var(--vis-tooltip-text-color);
  border-radius: var(--vis-tooltip-border-radius);
  box-shadow: var(--vis-tooltip-box-shadow);
  border: solid 1px var(--vis-tooltip-border-color);
  background-color: var(--vis-tooltip-background-color);
  backdrop-filter: var(--vis-tooltip-backdrop-filter);
`, HL = Wu, UL = qp`
  :root {
    --vis-tooltip-background-color: rgba(255, 255, 255, 0.95);
    --vis-tooltip-border-color: #e5e9f7;
    --vis-tooltip-text-color: #000;
    --vis-tooltip-shadow-color: rgba(172, 179, 184, 0.35);
    --vis-tooltip-backdrop-filter: none;
    --vis-tooltip-padding: 10px 15px;
    --vis-tooltip-border-radius: 5px;
    --vis-tooltip-transition-duration: 300ms;
    --vis-tooltip-box-shadow: none;

    --vis-dark-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-dark-tooltip-text-color: #e5e9f7;
    --vis-dark-tooltip-border-color: var(--vis-color-grey);
    --vis-dark-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }

  body.theme-dark ${`.${Wu}`} {
    --vis-tooltip-background-color: var(--vis-dark-tooltip-background-color);
    --vis-tooltip-text-color: var(--vis-dark-tooltip-text-color);
    --vis-tooltip-border-color: var(--vis-dark-tooltip-border-color);
    --vis-tooltip-shadow-color: var(--vis-dark-tooltip-shadow-color);
  }

  body.theme-dark {
    --vis-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-tooltip-text-color: #e5e9f7;
    --vis-tooltip-border-color: var(--vis-color-grey);
    --vis-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }
`, yw = gn`
  bottom: unset;
  position: fixed;
`, Xl = gn`
  opacity: 1;
`, Jl = gn`
  display: none;
`, bw = gn`
  label: non-interactive;
  pointer-events: none;
  user-select: none;
`, jL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hidden: Jl,
  nonInteractive: bw,
  positionFixed: yw,
  root: Wu,
  show: Xl,
  tooltip: HL,
  variables: UL
}, Symbol.toStringTag, { value: "Module" }));
class _w {
  constructor(t = {}) {
    this._defaultConfig = zL, this.config = this._defaultConfig, this._setUpEventsThrottled = Si(this._setUpEvents, 500), this._setContainerPositionThrottled = Si(this._setContainerPosition, 500), this._isShown = !1, this.element = document.createElement("div"), this.div = Xa(this.element).attr("class", Wu).classed(Xl, !1).classed(Jl, !0), this.setConfig(t), this.components = this.config.components, this._mutationObserver = new MutationObserver(() => {
      this._isShown && (!this.config.followCursor && this._hoveredElement ? this.placeByElement(this._hoveredElement) : this._position && this.place({ x: this._position[0], y: this._position[1] }));
    }), this._mutationObserver.observe(this.div.node(), { childList: !0, subtree: !0 });
  }
  setConfig(t) {
    var n;
    this.prevConfig = this.config, this.config = Ru(this._defaultConfig, t), this.prevConfig.horizontalPlacement !== this.config.horizontalPlacement && this.overrideHorizontalPlacement(void 0), this.config.container && this.config.container !== ((n = this.prevConfig) === null || n === void 0 ? void 0 : n.container) && this.setContainer(this.config.container), this._setUpAttributes();
  }
  setContainer(t) {
    var n;
    (n = this.element.parentNode) === null || n === void 0 || n.removeChild(this.element), this._container = t, this._container.appendChild(this.element), this._setContainerPositionThrottled();
  }
  getContainer() {
    return this._container;
  }
  hasContainer() {
    return !!this._container && this._container.isConnected;
  }
  setComponents(t) {
    this.components = t;
  }
  update() {
    this._container && this._setUpEventsThrottled();
  }
  /** Show the tooltip immediately by providing content and position */
  show(t, n) {
    this.render(t), this.place(n);
  }
  _hide() {
    this.div.classed(Xl, !1).on("transitionend", () => {
      this.div.classed(Jl, !this._isShown);
    }), this._isShown = !1;
  }
  /** Hides the tooltip after `hideDelay` */
  hide() {
    window.clearTimeout(this._showDelayTimeoutId), this.config.hideDelay ? (window.clearTimeout(this._hideDelayTimeoutId), this._hideDelayTimeoutId = setTimeout(() => this._hide(), this.config.hideDelay)) : this._hide();
  }
  _display() {
    window.clearTimeout(this._hideDelayTimeoutId), this.div.classed(Jl, !1).classed(Xl, !0), this._isShown = !0;
  }
  /** Simply display the tooltip with its previous content on position, taking into account `showDelay` */
  display() {
    this._isShown || (this.config.showDelay ? (window.clearTimeout(this._showDelayTimeoutId), this._showDelayTimeoutId = setTimeout(() => {
      this._display(), this.place({ x: this._position[0], y: this._position[1] });
    }, this.config.showDelay)) : this._display());
  }
  place(t) {
    if (this._position = [t.x, t.y], !this.hasContainer()) {
      console.warn("Unovis | Tooltip: Container was not set or is not initialized yet");
      return;
    }
    const { config: n } = this, a = this.element.offsetWidth, o = this.element.offsetHeight, r = this._overriddenHorizontalPlacement || (n.horizontalPlacement === at.Auto ? at.Center : n.horizontalPlacement), s = n.verticalPlacement === at.Auto ? t.y - o < 0 ? at.Bottom : at.Top : n.verticalPlacement, i = 5, u = r === at.Left ? -a - i - n.horizontalShift : r === at.Center ? -a / 2 : i + n.horizontalShift, d = s === at.Bottom ? i + n.verticalShift : s === at.Center ? -o / 2 : -i - n.verticalShift - o, [c, f] = this._constraintPosToContainer(t.x + u, t.y + d, a, o);
    this._applyPosition(c, f, o);
  }
  placeByElement(t) {
    const { config: n } = this;
    this._hoveredElement = t;
    const a = 5, o = this.element.offsetWidth, r = this.element.offsetHeight, s = this.isContainerBody(), i = s ? window.innerWidth : this._container.scrollWidth, u = t.getBoundingClientRect(), d = s ? [u.x, u.y] : _i({
      clientX: u.x,
      clientY: u.y,
      pageX: u.x,
      pageY: u.y
    }, this._container), c = this._overriddenHorizontalPlacement || (n.horizontalPlacement === at.Auto ? d[0] - o < 0 ? at.Right : d[0] + o > i ? at.Left : at.Center : n.horizontalPlacement);
    let f = 0;
    switch (c) {
      case at.Left:
        f = -o - a - n.horizontalShift;
        break;
      case at.Right:
        f = u.width + a + n.horizontalShift;
        break;
      case at.Center:
      default:
        f = (-o + u.width) / 2;
        break;
    }
    const p = n.verticalPlacement === at.Auto ? c !== at.Center ? at.Center : d[1] - r < 0 ? at.Bottom : at.Top : n.verticalPlacement;
    let v = -r;
    switch (p) {
      case at.Center:
        v += (r + u.height) / 2;
        break;
      case at.Bottom:
        v += r + u.height + a + n.verticalShift;
        break;
      case at.Top:
      default:
        v += -a - n.verticalShift;
        break;
    }
    const [m, h] = this._constraintPosToContainer(d[0] + f, d[1] + v, o, r);
    this._applyPosition(m, h, r);
  }
  isContainerBody() {
    return this._container === document.body;
  }
  /** Allows to override the horizontal placement of the tooltip which is useful when you want to define custom positioning behavior.
   * This method has been added for Crosshair to allow it position tooltip left or right of the crosshair line
   * (see the `_showTooltip` method of the Crosshair component).
   */
  overrideHorizontalPlacement(t) {
    this._overriddenHorizontalPlacement = t;
  }
  render(t) {
    var n;
    const { config: a, prevConfig: o } = this;
    t instanceof HTMLElement ? this.div.select(":first-child").node() !== t && this.div.html("").append(() => t) : t !== null && this.div.html(t || ""), this.div.classed((n = a.className) !== null && n !== void 0 ? n : "", !!a.className).classed(bw, !a.allowHover), o != null && o.className && o.className !== a.className && this.div.classed(o.className, !1), this.display();
  }
  _applyPosition(t, n, a) {
    const o = this.isContainerBody(), r = o ? window.innerHeight : this._container.scrollHeight;
    this.div.classed(yw, o).style("top", o ? `${n}px` : "unset").style("bottom", o ? "unset" : `${r - n - a}px`).style("left", `${t}px`);
  }
  _constraintPosToContainer(t, n, a, o) {
    const r = this.isContainerBody(), s = r ? window.innerHeight : this._container.scrollHeight, i = r ? window.innerWidth : this._container.scrollWidth, u = 10, d = t > i - a - u, c = t < u, f = d ? i - a - u : c ? u : t, p = 10, v = n > s - o - p, m = n < p, h = v ? s - o - p : m ? p : n;
    return [
      i < a ? 0 : f,
      s < o ? 0 : h
    ];
  }
  _setContainerPosition() {
    var t;
    this._container !== document.body && ((t = getComputedStyle(this._container)) === null || t === void 0 ? void 0 : t.position) === "static" && (this._container.style.position = "relative");
  }
  _setUpEvents() {
    const { config: t } = this;
    this.components.forEach((n) => {
      const a = Xa(n.element);
      a.on("mousemove.tooltip", (o) => {
        const { config: r } = this, s = o.composedPath && o.composedPath() || o.path || [o.target];
        for (const i of Object.keys(r.triggers)) {
          const u = r.triggers[i];
          if (!u)
            continue;
          const d = a.selectAll(`.${i}`).nodes();
          for (const c of s) {
            if (c === a.node())
              break;
            if (c.classList.contains(i)) {
              const f = d.indexOf(c), p = Xa(c).datum(), v = u(p, f, d), [m, h] = this.isContainerBody() ? [o.clientX, o.clientY] : _i(o, this._container);
              v === null ? this.hide() : (this.render(v), r.followCursor ? this.place({ x: m, y: h }) : this.placeByElement(c)), o.stopPropagation();
              return;
            }
          }
        }
        this._isShown && this.hide();
      }).on("mouseleave.tooltip", (o) => {
        o.stopPropagation(), this.hide();
      });
    }), t.allowHover ? this.div.on("mouseenter.tooltip", this._display.bind(this)).on("mouseleave.tooltip", this.hide.bind(this)) : this.div.on("mouseenter.tooltip", null).on("mouseleave.tooltip", null);
  }
  _setUpAttributes() {
    const t = this.config.attributes;
    t && Object.keys(t).forEach((n) => {
      this.div.attr(n, t[n]);
    });
  }
  destroy() {
    var t;
    this._mutationObserver.disconnect(), window.clearTimeout(this._hideDelayTimeoutId), window.clearTimeout(this._showDelayTimeoutId), (t = this.div) === null || t === void 0 || t.remove();
  }
}
_w.selectors = jL;
function Dl(e) {
  return function() {
    return e;
  };
}
const ww = Math.cos, Vi = Math.sin, Xn = Math.sqrt, Ni = Math.PI, Ku = 2 * Ni, Vc = Math.PI, Nc = 2 * Vc, lo = 1e-6, WL = Nc - lo;
function xw(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function KL(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return xw;
  const n = 10 ** t;
  return function(a) {
    this._ += a[0];
    for (let o = 1, r = a.length; o < r; ++o)
      this._ += Math.round(arguments[o] * n) / n + a[o];
  };
}
class GL {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? xw : KL(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, a, o) {
    this._append`Q${+t},${+n},${this._x1 = +a},${this._y1 = +o}`;
  }
  bezierCurveTo(t, n, a, o, r, s) {
    this._append`C${+t},${+n},${+a},${+o},${this._x1 = +r},${this._y1 = +s}`;
  }
  arcTo(t, n, a, o, r) {
    if (t = +t, n = +n, a = +a, o = +o, r = +r, r < 0) throw new Error(`negative radius: ${r}`);
    let s = this._x1, i = this._y1, u = a - t, d = o - n, c = s - t, f = i - n, p = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > lo) if (!(Math.abs(f * u - d * c) > lo) || !r)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let v = a - s, m = o - i, h = u * u + d * d, _ = v * v + m * m, x = Math.sqrt(h), S = Math.sqrt(p), $ = r * Math.tan((Vc - Math.acos((h + p - _) / (2 * x * S))) / 2), D = $ / S, B = $ / x;
      Math.abs(D - 1) > lo && this._append`L${t + D * c},${n + D * f}`, this._append`A${r},${r},0,0,${+(f * v > c * m)},${this._x1 = t + B * u},${this._y1 = n + B * d}`;
    }
  }
  arc(t, n, a, o, r, s) {
    if (t = +t, n = +n, a = +a, s = !!s, a < 0) throw new Error(`negative radius: ${a}`);
    let i = a * Math.cos(o), u = a * Math.sin(o), d = t + i, c = n + u, f = 1 ^ s, p = s ? o - r : r - o;
    this._x1 === null ? this._append`M${d},${c}` : (Math.abs(this._x1 - d) > lo || Math.abs(this._y1 - c) > lo) && this._append`L${d},${c}`, a && (p < 0 && (p = p % Nc + Nc), p > WL ? this._append`A${a},${a},0,1,${f},${t - i},${n - u}A${a},${a},0,1,${f},${this._x1 = d},${this._y1 = c}` : p > lo && this._append`A${a},${a},0,${+(p >= Vc)},${f},${this._x1 = t + a * Math.cos(r)},${this._y1 = n + a * Math.sin(r)}`);
  }
  rect(t, n, a, o) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${a = +a}v${+o}h${-a}Z`;
  }
  toString() {
    return this._;
  }
}
function YL(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const a = Math.floor(n);
      if (!(a >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = a;
    }
    return e;
  }, () => new GL(t);
}
const Cw = {
  draw(e, t) {
    const n = Xn(t / Ni);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, Ku);
  }
}, XL = {
  draw(e, t) {
    const n = Xn(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, Sw = Xn(1 / 3), JL = Sw * 2, ZL = {
  draw(e, t) {
    const n = Xn(t / JL), a = n * Sw;
    e.moveTo(0, -n), e.lineTo(a, 0), e.lineTo(0, n), e.lineTo(-a, 0), e.closePath();
  }
}, QL = {
  draw(e, t) {
    const n = Xn(t), a = -n / 2;
    e.rect(a, a, n, n);
  }
}, e7 = 0.8908130915292852, $w = Vi(Ni / 10) / Vi(7 * Ni / 10), t7 = Vi(Ku / 10) * $w, n7 = -ww(Ku / 10) * $w, a7 = {
  draw(e, t) {
    const n = Xn(t * e7), a = t7 * n, o = n7 * n;
    e.moveTo(0, -n), e.lineTo(a, o);
    for (let r = 1; r < 5; ++r) {
      const s = Ku * r / 5, i = ww(s), u = Vi(s);
      e.lineTo(u * n, -i * n), e.lineTo(i * a - u * o, u * a + i * o);
    }
    e.closePath();
  }
}, Fd = Xn(3), o7 = {
  draw(e, t) {
    const n = -Xn(t / (Fd * 3));
    e.moveTo(0, n * 2), e.lineTo(-Fd * n, -n), e.lineTo(Fd * n, -n), e.closePath();
  }
}, Bn = -0.5, Pn = Xn(3) / 2, Lc = 1 / Xn(12), r7 = (Lc / 2 + 1) * 3, s7 = {
  draw(e, t) {
    const n = Xn(t / r7), a = n / 2, o = n * Lc, r = a, s = n * Lc + n, i = -r, u = s;
    e.moveTo(a, o), e.lineTo(r, s), e.lineTo(i, u), e.lineTo(Bn * a - Pn * o, Pn * a + Bn * o), e.lineTo(Bn * r - Pn * s, Pn * r + Bn * s), e.lineTo(Bn * i - Pn * u, Pn * i + Bn * u), e.lineTo(Bn * a + Pn * o, Bn * o - Pn * a), e.lineTo(Bn * r + Pn * s, Bn * s - Pn * r), e.lineTo(Bn * i + Pn * u, Bn * u - Pn * i), e.closePath();
  }
};
function l7(e, t) {
  let n = null, a = YL(o);
  e = typeof e == "function" ? e : Dl(e || Cw), t = typeof t == "function" ? t : Dl(t === void 0 ? 64 : +t);
  function o() {
    let r;
    if (n || (n = r = a()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), r) return n = null, r + "" || null;
  }
  return o.type = function(r) {
    return arguments.length ? (e = typeof r == "function" ? r : Dl(r), o) : e;
  }, o.size = function(r) {
    return arguments.length ? (t = typeof r == "function" ? r : Dl(+r), o) : t;
  }, o.context = function(r) {
    return arguments.length ? (n = r ?? null, o) : n;
  }, o;
}
function ns(e, t, n, a) {
  return Array.isArray(t) && isFinite(n) ? t[n % t.length] : h_(e, t, n) || (ds(n) ? `var(${k_(n)})` : null);
}
var Zn;
(function(e) {
  e.Circle = "circle", e.Cross = "cross", e.Diamond = "diamond", e.Square = "square", e.Star = "star", e.Triangle = "triangle", e.Wye = "wye";
})(Zn || (Zn = {}));
const i7 = {
  [Zn.Circle]: Cw,
  [Zn.Cross]: XL,
  [Zn.Diamond]: ZL,
  [Zn.Square]: QL,
  [Zn.Star]: a7,
  [Zn.Triangle]: o7,
  [Zn.Wye]: s7
}, bn = Object.assign(Object.assign({}, Zn), { Line: "line" });
var Li;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(Li || (Li = {}));
const u7 = {
  items: [],
  labelClassName: "",
  onLegendItemClick: void 0,
  labelFontSize: null,
  labelMaxWidth: null,
  bulletSize: null,
  bulletSpacing: 4,
  bulletShape: (e) => {
    var t;
    return (t = e.shape) !== null && t !== void 0 ? t : bn.Circle;
  },
  orientation: Li.Horizontal,
  renderIntoProvidedDomNode: !1
}, Ml = Ms * 3, d7 = {
  [bn.Circle]: Math.PI / 4,
  [bn.Cross]: 5 / 9,
  [bn.Diamond]: Math.sqrt(3) / 6,
  [bn.Square]: 1,
  [bn.Star]: 0.3,
  [bn.Triangle]: Math.sqrt(3) / 4,
  [bn.Wye]: 5 / 11
};
function Bw(e, t, n) {
  return t < 1 ? 0 : e * t + n * (t - 1);
}
function c7(e) {
  e.each((t, n, a) => {
    Xa(a[n]).append("svg").attr("width", "100%").attr("height", "100%").append("path");
  });
}
function f7(e, t, n) {
  e.each((a, o, r) => {
    var s;
    const i = h_(a, t.bulletShape, o), u = uV((s = a.color) !== null && s !== void 0 ? s : ns(a, n, o)), d = u.length, c = Ml, f = Mc(getComputedStyle(r[o]).getPropertyValue("--vis-legend-bullet-size")), p = t.bulletSpacing * (Ml / f), v = Bw(c, d, p), m = i === bn.Line ? Ml / 2.5 : Ml, h = Xa(r[o]).select("svg").attr("viewBox", `0 0 ${v} ${m}`);
    h.selectAll("path").remove();
    const _ = a.inactive ? "var(--vis-legend-bullet-inactive-opacity)" : 1;
    u.forEach((x, S) => {
      const $ = h.append("path");
      if (i === bn.Line) {
        const D = S * (c + p), B = D + c;
        $.attr("d", `M${D},${m / 2} L${B},${m / 2}`).attr("transform", null).style("opacity", _).style("stroke", x).style("stroke-width", "3px").style("fill", null).style("fill-opacity", null).style("marker-start", "none").style("marker-end", "none");
      } else {
        const D = l7().type(i7[i]).size(c * m * d7[i]), B = (c - 2) / c;
        let k = m / 2;
        switch (i) {
          case bn.Triangle:
            k += m / 8;
            break;
          case bn.Star:
            k += m / 16;
            break;
          case bn.Wye:
            k -= m / 16;
            break;
        }
        const M = S * (c + p) + c / 2;
        $.attr("d", D).attr("transform", `translate(${M}, ${Math.round(k)}) scale(${B})`).style("stroke", x).style("stroke-width", "1px").style("opacity", null).style("fill", x).style("fill-opacity", _);
      }
    });
  });
}
const ov = gn`
  label: bullet-legend-component;
`, p7 = qp`
  :root {
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-legend-font-family: */

    --vis-legend-label-color: #6c778c;
    --vis-legend-label-max-width: 300px;
    --vis-legend-label-font-size: 12px;
    --vis-legend-bullet-size: 9px;
    --vis-legend-bullet-inactive-opacity: 0.15;
    --vis-legend-item-spacing: 20px;
    --vis-legend-vertical-item-spacing: 5px;
    --vis-legend-bullet-label-spacing: 8px;

    --vis-dark-legend-label-color: #eee;
  }

  body.theme-dark ${`.${ov}`} {
    --vis-legend-label-color: var(--vis-dark-legend-label-color);
  }

  body.theme-patterns {
    --vis-legend-bullet-size: 14px;
  }
`, Zl = gn`
  label: legendItem;
  display: inline-flex;
  align-items: center;
  font-family: var(--vis-legend-font-family, var(--vis-font-family));
  margin-right: var(--vis-legend-item-spacing);
  white-space: nowrap;
  cursor: default;
  user-select: none;
  max-width: min-content;
`, Pw = gn`
  label: legendItemVertical;
  display: flex;
  margin-top: var(--vis-legend-vertical-item-spacing);
`, Ew = gn`
  cursor: pointer;
`, zc = gn`
  label: legendItemLabel;
  font-size: var(--vis-legend-label-font-size);
  display: inline-block;
  vertical-align: middle;
  color: var(--vis-legend-label-color);
  max-width: var(--vis-legend-label-max-width);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`, Hc = gn`
  flex: 0 0 auto;
  label: legendItemBullet;
  margin-right: var(--vis-legend-bullet-label-spacing);
  height: var(--vis-legend-bullet-size);
  width: var(--vis-legend-bullet-size);

  svg {
    display: block;
  }
`, v7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bullet: Hc,
  clickable: Ew,
  item: Zl,
  itemVertical: Pw,
  label: zc,
  root: ov,
  variables: p7
}, Symbol.toStringTag, { value: "Module" }));
class rv {
  constructor(t, n) {
    this._defaultConfig = u7, this.config = this._defaultConfig, this._colorAccessor = (a) => a.color, this._container = t, this.div = n != null && n.renderIntoProvidedDomNode ? Xa(this._container) : Xa(this._container).append("div"), this.div.classed(ov, !0), this.element = this.div.node(), n && this.update(n);
  }
  update(t) {
    this.prevConfig = this.config, this.config = Ru(this._defaultConfig, t), this.render();
  }
  render() {
    const { config: t } = this, n = this.div.selectAll(`.${Zl}`).data(t.items), a = n.enter().append("div").on("click", this._onItemClick.bind(this)), o = a.merge(n);
    o.attr("class", (r) => {
      var s;
      return `${Zl} ${(s = r.className) !== null && s !== void 0 ? s : ""}`;
    }).classed(Pw, t.orientation === Li.Vertical).classed(Ew, (r) => !!t.onLegendItemClick && this._isItemClickable(r)).attr("title", (r) => r.name).style("display", (r) => r.hidden ? "none" : null), a.append("span").attr("class", Hc).call(c7), o.select(`.${Hc}`).style("width", function(r) {
      const i = (Array.isArray(r.color) ? r.color : [r.color]).length, u = Mc(getComputedStyle(this).getPropertyValue("--vis-legend-bullet-size")) || 9, d = t.bulletSize ? Mc(t.bulletSize) : u, c = t.bulletSpacing;
      return `${Bw(d, i, c)}px`;
    }).style("height", t.bulletSize).style("box-sizing", "content-box").call(f7, this.config, this._colorAccessor), a.append("span").attr("class", zc).classed(t.labelClassName, !0).style("max-width", t.labelMaxWidth).style("font-size", t.labelFontSize), o.select(`.${zc}`).text((r) => r.name), n.exit().remove();
  }
  _isItemClickable(t) {
    return t.pointer === void 0 ? !0 : t.pointer;
  }
  _onItemClick(t, n) {
    const { config: { onLegendItemClick: a } } = this, r = this.div.selectAll(`.${Zl}`).nodes().indexOf(t.currentTarget);
    a && a(n, r);
  }
  destroy() {
    this.element !== this._container && this.div.remove();
  }
}
rv.selectors = v7;
const m7 = Object.assign(Object.assign({}, gw), { yStacked: void 0, baseline: null, duration: 100, tooltip: void 0, template: (e, t, n, a) => "", hideWhenFarFromPointer: !0, hideWhenFarFromPointerDistance: 100, snapToData: !0, getCircles: void 0, color: void 0, strokeColor: void 0, strokeWidth: void 0, onCrosshairMove: void 0, forceShowAt: void 0, skipRangeCheck: !1 }), h7 = qp`
  :root {
    --vis-crosshair-line-stroke-color: #888;
    --vis-crosshair-line-stroke-width: 1px;
    --vis-crosshair-line-stroke-opacity: 1;
    --vis-crosshair-circle-stroke-color: #fff;
    --vis-crosshair-circle-stroke-width: 1px;
    --vis-crosshair-circle-stroke-opacity: 0.75;
  }
`, g7 = gn`
  label: crosshair-component;
`, Dw = gn`
  stroke: var(--vis-crosshair-line-stroke-color);
  stroke-width: var(--vis-crosshair-line-stroke-width);
  stroke-opacity: var(--vis-crosshair-line-stroke-opacity);
  pointer-events: none;
`, Mw = gn`
  stroke: var(--vis-crosshair-circle-stroke-color);
  stroke-width: var(--vis-crosshair-circle-stroke-width);
  stroke-opacity: var(--vis-crosshair-circle-stroke-opacity);
  pointer-events: none;
`, y7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle: Mw,
  globalStyles: h7,
  line: Dw,
  root: g7
}, Symbol.toStringTag, { value: "Module" }));
class kw extends LL {
  constructor(t) {
    super(), this.clippable = !0, this._defaultConfig = m7, this.config = this._defaultConfig, this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, this._animFrameId = null, this._accessors = {
      x: void 0,
      y: void 0,
      yStacked: void 0,
      baseline: void 0
    }, t && this.setConfig(t), this.g.style("opacity", 0), this.line = this.g.append("line").attr("class", Dw);
  }
  set accessors(t) {
    this._accessors = t;
  }
  get accessors() {
    var t;
    const { config: n } = this, a = !!(n.x || n.y || n.yStacked), o = a ? n.x : this._accessors.x, r = a ? n.y : this._accessors.y, s = r ? Tp(r) ? r : [r] : void 0, i = a ? n.yStacked : this._accessors.yStacked, u = (t = n.baseline) !== null && t !== void 0 ? t : this._accessors.baseline;
    return { x: o, y: s, yStacked: i, baseline: u };
  }
  _isContainerInViewport() {
    var t;
    if (!(!((t = this.container) === null || t === void 0) && t.node()))
      return !1;
    const n = this.container.node().getBoundingClientRect(), a = window.innerWidth || document.documentElement.clientWidth, o = window.innerHeight || document.documentElement.clientHeight, r = Math.max(0, Math.min(n.right, a) - Math.max(n.left, 0)), s = Math.max(0, Math.min(n.bottom, o) - Math.max(n.top, 0)), i = n.width * n.height, u = r * s;
    return i > 0 && u / i >= 0.35;
  }
  setContainer(t) {
    this.container !== t && (this.container = t, this.container.on("mousemove.crosshair", this._onMouseMove.bind(this)), this.container.on("mouseout.crosshair", this._onMouseOut.bind(this)), this.container.on("wheel.crosshair", this._onWheel.bind(this)));
  }
  _render(t) {
    var n, a, o, r, s;
    const { config: i, datamodel: u } = this, d = ds(t) ? t : i.duration, c = i.forceShowAt !== void 0, f = c ? this.xScale(i.forceShowAt) : this._xPx, p = this.xScale.invert(f), v = !((n = u.data) === null || n === void 0) && n.length && this.accessors.x ? u.data.indexOf($i(u.data, p, this.accessors.x, wa.Left)) : void 0;
    let m, h;
    i.snapToData && (!this.accessors.y && !this.accessors.yStacked && (!((a = u.data) === null || a === void 0) && a.length) && console.warn("Unovis | Crosshair: Y accessors have not been configured. Please check if they're present in the configuration object"), !(!((o = u.data) === null || o === void 0) && o.length) && this._mouseEvent && console.warn("Unovis | Crosshair: No data to snap to. Make sure the data has been passed to the container or to the crosshair itself"), m = $i(u.data, p, this.accessors.x), h = u.data.indexOf(m));
    const _ = this.xScale.range(), x = this.yScale.range(), S = i.snapToData && m ? Wm(Math.round(this.xScale(wn(m, this.accessors.x, h))), 0, this._width) : Wm(f, _[0], _[1]), $ = f >= _[0] && f <= _[1], D = this._yPx >= Math.min(x[0], x[1]) && this._yPx <= Math.max(x[0], x[1]);
    let B = i.skipRangeCheck ? !!this._xPx : this._xPx ? $ && D : $;
    i.hideWhenFarFromPointer && Math.abs(S - +f) >= i.hideWhenFarFromPointerDistance && (B = !1);
    const k = (r = i.tooltip) !== null && r !== void 0 ? r : this.tooltip;
    if (B && k && this._isContainerInViewport()) {
      const P = k.getContainer() || this.container.node(), q = k.isContainerBody();
      if (c) {
        const R = this.container.node().getBoundingClientRect(), Q = (q ? f + R.left : f) + this._containerMargin.left, ee = this._height / 2 + (q ? R.top : 0), K = [Q, ee];
        this._showTooltip(m, p, K, v);
      } else if (this._mouseEvent) {
        const R = q ? [this._mouseEvent.clientX, this._mouseEvent.clientY] : _i(this._mouseEvent, P);
        this._showTooltip(m, p, R, v);
      }
    } else
      this._hideTooltip();
    if (this._mouseEvent && ((s = i.onCrosshairMove) === null || s === void 0 || s.call(i, B ? this.xScale.invert(this._xPx) : void 0, m, h, this._mouseEvent), this._mouseEvent = void 0), Od(this.g, d).style("opacity", B ? 1 : 0), !isFinite(f))
      return;
    this.line.attr("y1", 0).attr("y2", this._height), Od(this.line, d, mh).attr("x1", S).attr("x2", S);
    const M = Op(i.getCircles) ? i.getCircles(p, u.data, this.yScale, v) : this.getCircleData(m, h), I = this.g.selectAll("circle").data(M, (P, q) => {
      var R;
      return (R = P.id) !== null && R !== void 0 ? R : q;
    }), T = I.enter().append("circle").attr("class", Mw).attr("r", 0).attr("cx", S).attr("cy", (P) => P.y).style("fill", (P) => P.color).style("stroke", (P) => P.strokeColor).style("stroke-width", (P) => P.strokeWidth);
    Od(T.merge(I), d, mh).attr("cx", S).attr("cy", (P) => P.y).attr("r", 4).style("opacity", (P) => P.opacity).style("fill", (P) => P.color).style("stroke", (P) => P.strokeColor).style("stroke-width", (P) => P.strokeWidth), I.exit().remove();
  }
  hide(t) {
    window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      var n, a;
      this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, (a = (n = this.config).onCrosshairMove) === null || a === void 0 || a.call(n, void 0, void 0, void 0, t), this._render();
    });
  }
  _onMouseMove(t) {
    var n;
    const { datamodel: a, element: o } = this;
    !this.accessors.x && (!((n = a.data) === null || n === void 0) && n.length) && console.warn("Unovis | Crosshair: X accessor function has not been configured. Please check if it's present in the configuration object");
    const [r, s] = _i(t, o);
    this._xPx = r, this._yPx = s, this._mouseEvent = t, window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      this._render();
    });
  }
  _onMouseOut(t) {
    var n;
    (!t || !(!((n = this.container) === null || n === void 0) && n.node().contains(t.relatedTarget))) && this.hide(t);
  }
  _onWheel(t) {
    this.hide(t);
  }
  _showTooltip(t, n, a, o) {
    var r;
    const { config: s, datamodel: i } = this, u = (r = s.tooltip) !== null && r !== void 0 ? r : this.tooltip;
    if (!u || !a)
      return;
    const [d, c] = a, f = s.template(t, n, i.data, o);
    if (u.config.followCursor = !0, !u.config.horizontalPlacement || u.config.horizontalPlacement === at.Auto) {
      const p = u.isContainerBody() ? d - this.container.node().getBoundingClientRect().left : d;
      u.overrideHorizontalPlacement(p > this._containerWidth / 2 ? at.Left : at.Right);
    }
    f && u.show(f, { x: d, y: c });
  }
  _hideTooltip() {
    var t;
    const { config: n } = this, a = (t = n.tooltip) !== null && t !== void 0 ? t : this.tooltip;
    a == null || a.hide();
  }
  // We don't want Crosshair to be be taken in to account in domain calculations
  getYDataExtent() {
    return [void 0, void 0];
  }
  getCircleData(t, n) {
    var a, o;
    const { config: r } = this;
    if (r.snapToData && t) {
      const s = (a = this.accessors.y) !== null && a !== void 0 ? a : [], i = (o = this.accessors.yStacked) !== null && o !== void 0 ? o : [], u = wn(t, this.accessors.baseline, n) || 0, d = rV(t, n, ...i).map((f, p) => ({
        y: this.yScale(f + u),
        opacity: ds(wn(t, i[p], p)) ? 1 : 0,
        color: ns(t, r.color, p),
        strokeColor: r.strokeColor ? ns(t, r.strokeColor, p) : void 0,
        strokeWidth: r.strokeWidth ? wn(t, r.strokeWidth, p) : void 0
      })), c = s.map((f, p) => {
        const v = wn(t, f, n);
        return {
          y: this.yScale(v),
          opacity: ds(v) ? 1 : 0,
          color: ns(t, r.color, d.length + p),
          strokeColor: r.strokeColor ? ns(t, r.strokeColor, p) : void 0,
          strokeWidth: r.strokeWidth ? wn(t, r.strokeWidth, p) : void 0
        };
      });
      return d.concat(c);
    }
    return [];
  }
}
kw.selectors = y7;
const b7 = Symbol("tooltipAccessorKey"), _7 = Symbol("crosshairAccessorKey");
function sv(e, t) {
  return Bc(e, t);
}
function lv(e) {
  const t = ct(), n = t.attrs;
  return E(() => {
    const a = {}, o = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(o).forEach((r) => {
      a[or(r)] = e[or(r)];
    }), { ...a, ...n };
  });
}
const w7 = { "data-vis-crosshair": "" }, x7 = /* @__PURE__ */ b({
  __name: "index",
  props: {
    data: {}
  },
  setup(e, { expose: t }) {
    const n = vn(_7), a = e, o = E(() => n.data.value ?? a.data), r = lv(a), s = O();
    return be(() => {
      he(() => {
        var i;
        s.value = new kw(r.value), (i = s.value) == null || i.setData(o.value), n.update(s.value);
      });
    }), Ze(() => {
      var i;
      (i = s.value) == null || i.destroy(), n.destroy();
    }), ce(r, (i, u) => {
      var d;
      sv(i, u) || (d = s.value) == null || d.setConfig(r.value);
    }), ce(o, () => {
      var i;
      (i = s.value) == null || i.setData(o.value);
    }), t({
      component: s
    }), (i, u) => (g(), U("div", w7));
  }
}), C7 = { "data-vis-tooltip": "" }, Ow = /* @__PURE__ */ b({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    hideDelay: {},
    showDelay: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = vn(b7), a = lv(e), o = O();
    return be(() => {
      he(() => {
        o.value = new _w(a.value), n.update(o.value);
      });
    }), Ze(() => {
      var r;
      (r = o.value) == null || r.destroy(), n.destroy();
    }), ce(a, (r, s) => {
      var i;
      sv(r, s) || (i = o.value) == null || i.setConfig(a.value);
    }), t({
      component: o
    }), (r, s) => (g(), U("div", C7));
  }
}), S7 = /* @__PURE__ */ b({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletSpacing: {},
    bulletShape: {},
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e;
    E(() => n.data);
    const a = lv(n), o = O(), r = O();
    return be(() => {
      he(() => {
        r.value && (o.value = new rv(r.value, { ...a.value, renderIntoProvidedDomNode: !0 }));
      });
    }), Ze(() => {
      var s;
      (s = o.value) == null || s.destroy();
    }), ce(a, (s, i) => {
      var u;
      sv(s, i) || (u = o.value) == null || u.update(a.value);
    }), t({
      component: o
    }), (s, i) => (g(), U("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: r
    }, null, 512));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-map],[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend],[data-vis-rolling-pin-legend]{display:block}")), document.head.appendChild(e);
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t);
  }
})();
const Rj = /* @__PURE__ */ b({
  __name: "ChartCrosshair",
  props: {
    colors: { default: () => [] },
    index: {},
    items: {},
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(r) {
      if (n.has(r))
        return n.get(r);
      {
        const s = document.createElement("div"), i = Object.entries(v_(r, [t.index])).map(([d, c]) => ({ ...t.items.find((p) => p.name === d), value: c })), u = t.customTooltip ?? Uc;
        return Ud(u, { title: r[t.index].toString(), data: i }).mount(
          s
        ), n.set(r, s.innerHTML), s.innerHTML;
      }
    }
    function o(r, s) {
      return t.colors[s] ?? "transparent";
    }
    return (r, s) => (g(), U(Fe, null, [
      N(l(Ow), {
        "horizontal-shift": 20,
        "vertical-shift": 20
      }),
      N(l(x7), {
        template: a,
        color: o
      })
    ], 64));
  }
}), qj = /* @__PURE__ */ b({
  __name: "ChartLegend",
  props: {
    items: { default: () => [] }
  },
  emits: ["legendItemClick", "update:items"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = O();
    function r() {
      const i = `.${rv.selectors.item}`;
      he(() => {
        var c;
        const u = (c = o.value) == null ? void 0 : c.querySelectorAll(i), d = rn({ variant: "ghost", size: "xs" }).split(" ");
        u == null || u.forEach((f) => f.classList.add(...d, "!inline-flex", "!mr-2"));
      });
    }
    be(() => {
      r();
    });
    function s(i, u) {
      a("legendItemClick", i, u);
      const d = !n.items[u].inactive;
      n.items.some((f) => f.inactive) && d ? a(
        "update:items",
        n.items.map((f) => ({ ...f, inactive: !1 }))
      ) : a(
        "update:items",
        n.items.map(
          (f) => f.name === i.name ? { ...i, inactive: !1 } : { ...f, inactive: !0 }
        )
      ), r();
    }
    return (i, u) => (g(), U("div", {
      ref_key: "elRef",
      ref: o,
      class: "w-max",
      style: {
        "--vis-legend-bullet-size": "16px"
      }
    }, [
      N(l(S7), {
        items: e.items,
        "on-legend-item-click": s
      }, null, 8, ["items"])
    ], 512));
  }
}), Fj = /* @__PURE__ */ b({
  __name: "ChartSingleTooltip",
  props: {
    selector: {},
    index: {},
    items: {},
    valueFormatter: { type: Function },
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(o, r, s) {
      const i = t.valueFormatter ?? ((u) => `${u}`);
      if (t.index in o) {
        if (n.has(o))
          return n.get(o);
        {
          const u = document.createElement("div"), d = Object.entries(v_(o, [t.index])).map(([f, p]) => {
            var m;
            return { ...(m = t.items) == null ? void 0 : m.find((h) => h.name === f), value: i(p) };
          }), c = t.customTooltip ?? Uc;
          return Ud(c, { title: o[t.index], data: d }).mount(u), n.set(o, u.innerHTML), u.innerHTML;
        }
      } else {
        const u = o.data;
        if (n.has(u))
          return n.get(u);
        {
          const d = getComputedStyle(s[r]), c = [
            { name: u.name, value: i(u[t.index]), color: d.fill }
          ], f = document.createElement("div"), p = t.customTooltip ?? Uc;
          return Ud(p, { title: o[t.index], data: c }).mount(f), n.set(o, f.innerHTML), f.innerHTML;
        }
      }
    }
    return (o, r) => (g(), C(l(Ow), {
      "horizontal-shift": 20,
      "vertical-shift": 20,
      triggers: {
        [e.selector]: a
      }
    }, null, 8, ["triggers"]));
  }
}), $7 = { class: "flex items-center" }, B7 = { class: "mr-2 h-2.5 w-2.5" }, P7 = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 30 30"
}, E7 = ["stroke", "fill"], D7 = { class: "ml-4 font-semibold" }, Uc = /* @__PURE__ */ b({
  __name: "ChartTooltip",
  props: {
    title: {},
    data: {}
  },
  setup(e) {
    return (t, n) => (g(), C(l(PR), { class: "text-sm" }, {
      default: y(() => [
        e.title ? (g(), C(l(DR), {
          key: 0,
          class: "border-b p-3"
        }, {
          default: y(() => [
            N(l(MR), null, {
              default: y(() => [
                Re(Ve(e.title), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : Pe("", !0),
        N(l(ER), { class: "flex min-w-[180px] flex-col gap-1 p-3" }, {
          default: y(() => [
            (g(!0), U(Fe, null, $t(e.data, (a, o) => (g(), U("div", {
              key: o,
              class: "flex justify-between"
            }, [
              ye("div", $7, [
                ye("span", B7, [
                  (g(), U("svg", P7, [
                    ye("path", {
                      d: " M 15 15 m -14, 0 a 14,14 0 1,1 28,0 a 14,14 0 1,1 -28,0",
                      stroke: a.color,
                      fill: a.color,
                      "stroke-width": "1"
                    }, null, 8, E7)
                  ]))
                ]),
                ye("span", null, Ve(a.name), 1)
              ]),
              ye("span", D7, Ve(a.value), 1)
            ]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
function Vj(e = 3) {
  const t = Math.floor(e / 2), n = e % 2, a = t + n, o = t;
  return [
    ...Array.from(new Array(a).keys()).map(
      (r) => `hsl(var(--vis-primary-color) / ${1 - 1 / a * r})`
    ),
    ...Array.from(new Array(o).keys()).map(
      (r) => `hsl(var(--vis-secondary-color) / ${1 - 1 / o * r})`
    )
  ];
}
const Nj = /* @__PURE__ */ b({
  __name: "Checkbox",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null] },
    disabled: { type: Boolean },
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = qe(o, a);
    return (s, i) => (g(), C(l(bM), A(l(r), {
      class: l(F)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: y(() => [
        N(l(wM), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: y(() => [
            w(s.$slots, "default", {}, () => [
              N(l(Mu), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Lj = /* @__PURE__ */ b({
  __name: "Collapsible",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(bD), ne(oe(l(o))), {
      default: y(({ open: i }) => [
        w(r.$slots, "default", { open: i })
      ]),
      _: 3
    }, 16));
  }
}), zj = /* @__PURE__ */ b({
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(wD), A(t, { class: "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down" }), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Hj = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(CD), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Uj = /* @__PURE__ */ b({
  __name: "Combobox",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    resetSearchTermOnBlur: { type: Boolean },
    resetSearchTermOnSelect: { type: Boolean },
    openOnFocus: { type: Boolean },
    openOnClick: { type: Boolean },
    ignoreFilter: { type: Boolean },
    resetModelValueOnClear: { type: Boolean },
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    highlightOnHover: { type: Boolean },
    by: { type: [String, Function] },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "update:open"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(JM), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), jj = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(MM), A(l(a), {
      class: l(F)("w-[200px]", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Wj = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(rk), A(l(n), {
      class: l(F)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Kj = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(ik), A(l(n), {
      class: l(F)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        e.heading ? (g(), C(l(mk), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(Ve(e.heading), 1)
          ]),
          _: 1
        })) : Pe("", !0),
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Gj = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: { type: Function },
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(dk), A(l(r), {
      class: l(F)(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Yj = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(fk), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center justify-between gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Xj = /* @__PURE__ */ b({
  __name: "ComboboxList",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(gk), null, {
      default: y(() => [
        N(l(ak), A(l(r), {
          class: l(F)(
            "z-50 w-[200px] rounded-md border bg-popover text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            N(l(xk), null, {
              default: y(() => [
                w(s.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Jj = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(bk), A(l(n), {
      class: l(F)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), M7 = /* @__PURE__ */ b({
  __name: "Command",
  props: {
    modelValue: { default: "" },
    defaultValue: {},
    open: { type: Boolean, default: !0 },
    defaultOpen: { type: Boolean },
    searchTerm: {},
    selectedValue: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    name: {},
    dir: {},
    filterFunction: {},
    displayValue: {},
    resetSearchTermOnBlur: { type: Boolean },
    resetSearchTermOnSelect: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:open", "update:searchTerm", "update:selectedValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(c$), A(l(r), {
      class: l(F)(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), k7 = /* @__PURE__ */ b({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l($f), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zj = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Bo), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qj = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Bf), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), eW = /* @__PURE__ */ b({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex flex-col gap-y-1.5 text-center sm:text-left", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), tW = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(kf), A(l(a), {
      class: l(F)("text-lg leading-none font-semibold tracking-tight", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), nW = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(Of), A(l(a), {
      class: l(F)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), O7 = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus", "close"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(Pf), null, {
      default: y(() => [
        N(l(su), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(ru), A(l(r), {
          class: l(F)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            w(s.$slots, "default"),
            N(l(Bo), {
              class: "absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-none disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
              onClick: i[0] || (i[0] = (u) => a("close", u))
            }, {
              default: y(() => [
                N(l(Du), { class: "size-4" }),
                i[1] || (i[1] = ye("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), aW = /* @__PURE__ */ b({
  __name: "DialogScrollContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(Pf), null, {
      default: y(() => [
        N(l(su), { class: "fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }, {
          default: y(() => [
            N(l(ru), A({
              class: l(F)(
                "relative z-50 my-8 grid w-full max-w-lg gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full",
                n.class
              )
            }, l(r), {
              onPointerDownOutside: i[0] || (i[0] = (u) => {
                const d = u.detail.originalEvent, c = d.target;
                (d.offsetX > c.clientWidth || d.offsetY > c.clientHeight) && u.preventDefault();
              })
            }), {
              default: y(() => [
                w(s.$slots, "default"),
                N(l(Bo), { class: "absolute top-4 right-4 rounded-md p-0.5 transition-colors hover:bg-secondary" }, {
                  default: y(() => [
                    N(l(Du), { class: "h-4 w-4" }),
                    i[1] || (i[1] = ye("span", { class: "sr-only" }, "Close", -1))
                  ]),
                  _: 1
                })
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), oW = /* @__PURE__ */ b({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), rW = /* @__PURE__ */ b({
  __name: "CommandDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(k7), ne(oe(l(o))), {
      default: y(() => [
        N(l(O7), { class: "overflow-hidden p-0 shadow-lg" }, {
          default: y(() => [
            N(M7, { class: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5" }, {
              default: y(() => [
                w(r.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16));
  }
}), sW = /* @__PURE__ */ b({
  __name: "CommandEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(b$), A(n.value, {
      class: l(F)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lW = /* @__PURE__ */ b({
  __name: "CommandGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(v$), A(n.value, {
      class: l(F)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        e.heading ? (g(), C(l(m$), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(Ve(e.heading), 1)
          ]),
          _: 1
        })) : Pe("", !0),
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), T7 = {
  class: "flex items-center border-b px-3",
  "cmdk-input-wrapper": ""
}, iW = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CommandInput",
  props: {
    type: {},
    disabled: { type: Boolean },
    autoFocus: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), U("div", T7, [
      N(l(L6), { class: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
      N(l(f$), A({ ...l(a), ...o.$attrs }, {
        "auto-focus": "",
        class: l(F)(
          "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), uW = /* @__PURE__ */ b({
  __name: "CommandItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(C$), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), A7 = { role: "presentation" }, dW = /* @__PURE__ */ b({
  __name: "CommandList",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean, default: !1 },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(y$), A(l(r), {
      class: l(F)("max-h-[300px] overflow-x-hidden overflow-y-auto", n.class)
    }), {
      default: y(() => [
        ye("div", A7, [
          w(s.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cW = /* @__PURE__ */ b({
  __name: "CommandSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(S$), A(n.value, {
      class: l(F)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fW = /* @__PURE__ */ b({
  __name: "CommandShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("span", {
      class: ae(l(F)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), pW = /* @__PURE__ */ b({
  __name: "ContextMenu",
  props: {
    pressOpenDelay: {},
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(nO), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), I7 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, vW = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(Qk), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        ye("span", I7, [
          N(l(a0), null, {
            default: y(() => [
              N(l(Mu), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), mW = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(pO), null, {
      default: y(() => [
        N(l(oO), A(l(r), {
          class: l(F)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            w(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), hW = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(sO), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gW = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(iO), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), yW = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(cO), A(l(n), {
      class: l(F)("px-2 py-1.5 text-sm font-semibold text-foreground", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bW = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(mO), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), R7 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, _W = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(gO), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        ye("span", R7, [
          N(l(a0), null, {
            default: y(() => [
              N(l(K0), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), wW = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(bO), A(l(n), {
      class: l(F)("-mx-1 my-1 h-px bg-border", t.class)
    }), null, 16, ["class"]));
  }
}), xW = /* @__PURE__ */ b({
  __name: "ContextMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("span", {
      class: ae(l(F)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), CW = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(wO), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), SW = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(CO), A(l(r), {
      class: l(F)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $W = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l($O), A(l(a), {
      class: l(F)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default"),
        N(l(To), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), BW = /* @__PURE__ */ b({
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = Ee(e);
    return (a, o) => (g(), C(l(PO), ne(oe(l(n))), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
(function() {
  var e;
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.nonce = (e = document.head.querySelector("meta[property=csp-nonce]")) == null ? void 0 : e.content, t.appendChild(document.createTextNode('[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32,.72,0,1);animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform, 100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform, 100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height, 0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height, 0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true]):after{content:"";position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]:after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]:after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]:after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]:after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:hover,[data-vaul-handle]:active{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover: hover) and (pointer: fine){[data-vaul-drawer]{-webkit-user-select:none;user-select:none}}@media (pointer: fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{0%{transform:translate3d(0,var(--initial-transform, 100%),0)}to{transform:translateZ(0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform, 100%),0)}}@keyframes slideFromTop{0%{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}to{transform:translateZ(0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}}@keyframes slideFromLeft{0%{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}to{transform:translateZ(0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}}@keyframes slideFromRight{0%{transform:translate3d(var(--initial-transform, 100%),0,0)}to{transform:translateZ(0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform, 100%),0,0)}}')), document.head.appendChild(t);
    }
  } catch (n) {
    console.error("vite-plugin-css-injected-by-js", n);
  }
})();
const q7 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const F7 = (e) => typeof e < "u";
function V7(e) {
  return JSON.parse(JSON.stringify(e));
}
function Uh(e, t, n, a = {}) {
  var o, r, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = ct(), m = n || (v == null ? void 0 : v.emit) || ((o = v == null ? void 0 : v.$emit) == null ? void 0 : o.bind(v)) || ((s = (r = v == null ? void 0 : v.proxy) == null ? void 0 : r.$emit) == null ? void 0 : s.bind(v == null ? void 0 : v.proxy));
  let h = d;
  t || (t = "modelValue"), h = h || `update:${t.toString()}`;
  const _ = ($) => i ? typeof i == "function" ? i($) : V7($) : $, x = () => F7(e[t]) ? _(e[t]) : f, S = ($) => {
    p ? p($) && m(h, $) : m(h, $);
  };
  if (u) {
    const $ = x(), D = O($);
    let B = !1;
    return ce(
      () => e[t],
      (k) => {
        B || (B = !0, D.value = _(k), he(() => B = !1));
      }
    ), ce(
      D,
      (k) => {
        !B && (k !== e[t] || c) && S(k);
      },
      { deep: c }
    ), D;
  } else
    return E({
      get() {
        return x();
      },
      set($) {
        S($);
      }
    });
}
const [iv, N7] = He("DrawerRoot"), Tw = /* @__PURE__ */ new WeakMap();
function Nt(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement) || !t)
    return;
  const a = {};
  Object.entries(t).forEach(([o, r]) => {
    if (o.startsWith("--")) {
      e.style.setProperty(o, r);
      return;
    }
    a[o] = e.style[o], e.style[o] = r;
  }), !n && Tw.set(e, a);
}
function L7(e, t) {
  if (!e || !(e instanceof HTMLElement))
    return;
  const n = Tw.get(e);
  n && Object.entries(n).forEach(([a, o]) => {
    e.style[a] = o;
  });
}
function kl(e, t) {
  const n = window.getComputedStyle(e), a = n.transform || n.webkitTransform || n.mozTransform;
  let o = a.match(/^matrix3d\((.+)\)$/);
  return o ? Number.parseFloat(o[1].split(", ")[Et(t) ? 13 : 12]) : (o = a.match(/^matrix\((.+)\)$/), o ? Number.parseFloat(o[1].split(", ")[Et(t) ? 5 : 4]) : null);
}
function z7(e) {
  return 8 * (Math.log(e + 1) - 2);
}
function Et(e) {
  switch (e) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return e;
  }
}
function Vd(e, t) {
  if (!e)
    return () => {
    };
  const n = e.style.cssText;
  return Object.assign(e.style, t), () => {
    e.style.cssText = n;
  };
}
function H7(...e) {
  return (...t) => {
    for (const n of e)
      typeof n == "function" && n(...t);
  };
}
const wt = {
  DURATION: 0.5,
  EASE: [0.32, 0.72, 0, 1]
}, Aw = 0.4, U7 = 0.25, j7 = 100, Iw = 8, Ol = 16, Rw = 26, jh = "vaul-dragging";
function W7({
  activeSnapPoint: e,
  snapPoints: t,
  drawerRef: n,
  overlayRef: a,
  fadeFromIndex: o,
  onSnapPointChange: r,
  direction: s
}) {
  const i = O(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  function u() {
    i.value = {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    };
  }
  be(() => {
    typeof window < "u" && window.addEventListener("resize", u);
  }), ka(() => {
    typeof window < "u" && window.removeEventListener("resize", u);
  });
  const d = E(
    () => (t.value && e.value === t.value[t.value.length - 1]) ?? null
  ), c = E(
    () => t.value && t.value.length > 0 && ((o == null ? void 0 : o.value) || (o == null ? void 0 : o.value) === 0) && !Number.isNaN(o == null ? void 0 : o.value) && t.value[(o == null ? void 0 : o.value) ?? -1] === e.value || !t.value
  ), f = E(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.findIndex(($) => $ === e.value)) ?? null;
    }
  ), p = E(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.map(($) => {
        const D = typeof $ == "string";
        let B = 0;
        if (D && (B = Number.parseInt($, 10)), Et(s.value)) {
          const M = D ? B : i.value ? $ * i.value.innerHeight : 0;
          return i.value ? s.value === "bottom" ? i.value.innerHeight - M : -i.value.innerHeight + M : M;
        }
        const k = D ? B : i.value ? $ * i.value.innerWidth : 0;
        return i.value ? s.value === "right" ? i.value.innerWidth - k : -i.value.innerWidth + k : k;
      })) ?? [];
    }
  ), v = E(
    () => {
      var S;
      return f.value !== null ? (S = p.value) == null ? void 0 : S[f.value] : null;
    }
  ), m = (S) => {
    var $, D, B, k;
    const M = (($ = p.value) == null ? void 0 : $.findIndex((I) => I === S)) ?? null;
    he(() => {
      var I;
      r(M, p.value), Nt((I = n.value) == null ? void 0 : I.$el, {
        transition: `transform ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`,
        transform: Et(s.value) ? `translate3d(0, ${S}px, 0)` : `translate3d(${S}px, 0, 0)`
      });
    }), p.value && M !== p.value.length - 1 && M !== (o == null ? void 0 : o.value) ? Nt((D = a.value) == null ? void 0 : D.$el, {
      transition: `opacity ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`,
      opacity: "0"
    }) : Nt((B = a.value) == null ? void 0 : B.$el, {
      transition: `opacity ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`,
      opacity: "1"
    }), e.value = M !== null ? ((k = t.value) == null ? void 0 : k[M]) ?? null : null;
  };
  ce(
    [e, p, t],
    () => {
      var S;
      if (e.value) {
        const $ = ((S = t.value) == null ? void 0 : S.findIndex((D) => D === e.value)) ?? -1;
        p.value && $ !== -1 && typeof p.value[$] == "number" && m(p.value[$]);
      }
    },
    {
      immediate: !0
      // if you want to run the effect immediately as well
    }
  );
  function h({
    draggedDistance: S,
    closeDrawer: $,
    velocity: D,
    dismissible: B
  }) {
    var k, M, I;
    if (o.value === void 0)
      return;
    const T = s.value === "bottom" || s.value === "right" ? (v.value ?? 0) - S : (v.value ?? 0) + S, P = f.value === o.value - 1, q = f.value === 0, R = S > 0;
    if (P && Nt((k = a.value) == null ? void 0 : k.$el, {
      transition: `opacity ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`
    }), D > 2 && !R) {
      B ? $() : m(p.value[0]);
      return;
    }
    if (D > 2 && R && p && t.value) {
      m(p.value[t.value.length - 1]);
      return;
    }
    const Q = (M = p.value) == null ? void 0 : M.reduce((K, W) => typeof K != "number" || typeof W != "number" ? K : Math.abs(W - T) < Math.abs(K - T) ? W : K), ee = Et(s.value) ? window.innerHeight : window.innerWidth;
    if (D > Aw && Math.abs(S) < ee * 0.4) {
      const K = R ? 1 : -1;
      if (K > 0 && d) {
        m(p.value[(((I = t.value) == null ? void 0 : I.length) ?? 0) - 1]);
        return;
      }
      if (q && K < 0 && B && $(), f.value === null)
        return;
      m(p.value[f.value + K]);
      return;
    }
    m(Q);
  }
  function _({ draggedDistance: S }) {
    var $;
    if (v.value === null)
      return;
    const D = s.value === "bottom" || s.value === "right" ? v.value - S : v.value + S;
    (s.value === "bottom" || s.value === "right") && D < p.value[p.value.length - 1] || (s.value === "top" || s.value === "left") && D > p.value[p.value.length - 1] || Nt(($ = n.value) == null ? void 0 : $.$el, {
      transform: Et(s.value) ? `translate3d(0, ${D}px, 0)` : `translate3d(${D}px, 0, 0)`
    });
  }
  function x(S, $) {
    if (!t.value || typeof f.value != "number" || !p.value || o.value === void 0)
      return null;
    const D = f.value === o.value - 1;
    if (f.value >= o.value && $)
      return 0;
    if (D && !$)
      return 1;
    if (!c.value && !D)
      return null;
    const B = D ? f.value + 1 : f.value - 1, k = D ? p.value[B] - p.value[B - 1] : p.value[B + 1] - p.value[B], M = S / Math.abs(k);
    return D ? 1 - M : M;
  }
  return {
    isLastSnapPoint: d,
    shouldFade: c,
    getPercentageDragged: x,
    activeSnapPointIndex: f,
    onRelease: h,
    onDrag: _,
    snapPointsOffset: p
  };
}
function Wh() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
let Gr = null;
function K7(e) {
  const { isOpen: t, modal: n, nested: a, hasBeenOpened: o, preventScrollRestoration: r, noBodyStyles: s } = e, i = O(typeof window < "u" ? window.location.href : ""), u = O(0);
  function d() {
    if (Wh() && Gr === null && t.value && !s.value) {
      Gr = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      };
      const { scrollX: f, innerHeight: p } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-u.value}px`,
        left: `${-f}px`,
        right: "0px",
        height: "auto"
      }), setTimeout(() => {
        requestAnimationFrame(() => {
          const v = p - window.innerHeight;
          v && u.value >= p && (document.body.style.top = `-${u.value + v}px`);
        });
      }, 300);
    }
  }
  function c() {
    if (Wh() && Gr !== null && !s.value) {
      const f = -Number.parseInt(document.body.style.top, 10), p = -Number.parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, Gr), window.requestAnimationFrame(() => {
        if (r.value && i.value !== window.location.href) {
          i.value = window.location.href;
          return;
        }
        window.scrollTo(p, f);
      }), Gr = null;
    }
  }
  return be(() => {
    function f() {
      u.value = window.scrollY;
    }
    f(), window.addEventListener("scroll", f), Ze(() => {
      window.removeEventListener("scroll", f);
    });
  }), ce([t, o, i], () => {
    a.value || !o.value || (t.value ? (window.matchMedia("(display-mode: standalone)").matches || d(), n.value || setTimeout(() => {
      c();
    }, 500)) : c());
  }), { restorePositionSetting: c };
}
function G7(e, t) {
  return e && e.value ? e : t;
}
function Y7(e) {
  const {
    emitDrag: t,
    emitRelease: n,
    emitClose: a,
    emitOpenChange: o,
    open: r,
    dismissible: s,
    nested: i,
    modal: u,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    scrollLockTimeout: f,
    closeThreshold: p,
    activeSnapPoint: v,
    fadeFromIndex: m,
    direction: h,
    noBodyStyles: _,
    handleOnly: x,
    preventScrollRestoration: S
  } = e, $ = O(r.value ?? !1), D = O(!1), B = O(!1), k = O(!1), M = O(null), I = O(null), T = O(null), P = O(null), q = O(null), R = O(!1), Q = O(null), ee = O(0), K = O(!1);
  O(0);
  const W = O(null);
  O(0);
  const j = E(() => {
    var xe;
    return ((xe = W.value) == null ? void 0 : xe.$el.getBoundingClientRect().height) || 0;
  }), J = G7(
    e.snapPoints,
    O(void 0)
  ), z = E(() => {
    var xe;
    return J && (((xe = J.value) == null ? void 0 : xe.length) ?? 0) > 0;
  }), Y = O(null), {
    activeSnapPointIndex: Z,
    onRelease: pe,
    snapPointsOffset: $e,
    onDrag: Ce,
    shouldFade: De,
    getPercentageDragged: ue
  } = W7({
    snapPoints: J,
    activeSnapPoint: v,
    drawerRef: W,
    fadeFromIndex: m,
    overlayRef: M,
    onSnapPointChange: V,
    direction: h
  });
  function V(xe, ze) {
    J.value && xe === ze.length - 1 && (I.value = /* @__PURE__ */ new Date());
  }
  K7({
    isOpen: $,
    modal: u,
    nested: i,
    hasBeenOpened: D,
    noBodyStyles: _,
    preventScrollRestoration: S
  });
  function te() {
    return (window.innerWidth - Rw) / window.innerWidth;
  }
  function H(xe, ze) {
    var je;
    if (!xe)
      return !1;
    let Ke = xe;
    const lt = (je = window.getSelection()) == null ? void 0 : je.toString(), it = W.value ? kl(W.value.$el, h.value) : null, St = /* @__PURE__ */ new Date();
    if (Ke.hasAttribute("data-vaul-no-drag") || Ke.closest("[data-vaul-no-drag]"))
      return !1;
    if (h.value === "right" || h.value === "left")
      return !0;
    if (I.value && St.getTime() - I.value.getTime() < 500)
      return !1;
    if (it !== null && (h.value === "bottom" ? it > 0 : it < 0))
      return !0;
    if (lt && lt.length > 0)
      return !1;
    if (q.value && St.getTime() - q.value.getTime() < f.value && it === 0 || ze)
      return q.value = St, !1;
    for (; Ke; ) {
      if (Ke.scrollHeight > Ke.clientHeight) {
        if (Ke.scrollTop !== 0)
          return q.value = /* @__PURE__ */ new Date(), !1;
        if (Ke.getAttribute("role") === "dialog")
          return !0;
      }
      Ke = Ke.parentNode;
    }
    return !0;
  }
  function re(xe) {
    !s.value && !J.value || W.value && !W.value.$el.contains(xe.target) || (B.value = !0, T.value = /* @__PURE__ */ new Date(), xe.target.setPointerCapture(xe.pointerId), ee.value = Et(h.value) ? xe.clientY : xe.clientX);
  }
  function ie(xe) {
    var ze, je, Ke, lt, it, St;
    if (W.value && B.value) {
      const Xt = h.value === "bottom" || h.value === "right" ? 1 : -1, an = (ee.value - (Et(h.value) ? xe.clientY : xe.clientX)) * Xt, Ae = an > 0, st = J.value && !s.value && !Ae;
      if (st && Z.value === 0)
        return;
      const dt = Math.abs(an), bt = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      let G = dt / j.value;
      const X = ue(dt, Ae);
      if (X !== null && (G = X), st && G >= 1 || !R.value && !H(xe.target, Ae))
        return;
      if ((ze = W == null ? void 0 : W.value) == null || ze.$el.classList.add(jh), R.value = !0, Nt((je = W.value) == null ? void 0 : je.$el, {
        transition: "none"
      }), Nt((Ke = M.value) == null ? void 0 : Ke.$el, {
        transition: "none"
      }), J.value && Ce({ draggedDistance: an }), Ae && !J.value) {
        const ge = z7(an), ke = Math.min(ge * -1, 0) * Xt;
        Nt((lt = W.value) == null ? void 0 : lt.$el, {
          transform: Et(h.value) ? `translate3d(0, ${ke}px, 0)` : `translate3d(${ke}px, 0, 0)`
        });
        return;
      }
      const de = 1 - G;
      if ((De.value || m.value && Z.value === m.value - 1) && (t(G), Nt(
        (it = M.value) == null ? void 0 : it.$el,
        {
          opacity: `${de}`,
          transition: "none"
        },
        !0
      )), bt && M.value && d.value) {
        const ge = Math.min(te() + G * (1 - te()), 1), ke = 8 - G * 8, Ie = Math.max(0, 14 - G * 14);
        Nt(
          bt,
          {
            borderRadius: `${ke}px`,
            transform: Et(h.value) ? `scale(${ge}) translate3d(0, ${Ie}px, 0)` : `scale(${ge}) translate3d(${Ie}px, 0, 0)`,
            transition: "none"
          },
          !0
        );
      }
      if (!J.value) {
        const ge = dt * Xt;
        Nt((St = W.value) == null ? void 0 : St.$el, {
          transform: Et(h.value) ? `translate3d(0, ${ge}px, 0)` : `translate3d(${ge}px, 0, 0)`
        });
      }
    }
  }
  function L() {
    var xe;
    if (!W.value)
      return;
    const ze = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]"), je = kl(W.value.$el, h.value);
    Nt(W.value.$el, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`
    }), Nt((xe = M.value) == null ? void 0 : xe.$el, {
      transition: `opacity ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`,
      opacity: "1"
    }), d.value && je && je > 0 && $.value && Nt(
      ze,
      {
        borderRadius: `${Iw}px`,
        overflow: "hidden",
        ...Et(h.value) ? {
          transform: `scale(${te()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${te()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${wt.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${wt.EASE.join(",")})`
      },
      !0
    );
  }
  function _e(xe) {
    W.value && (a(), xe || ($.value = !1), window.setTimeout(() => {
      J.value && (v.value = J.value[0]);
    }, wt.DURATION * 1e3));
  }
  Me(() => {
    if (!$.value && d.value && q7) {
      const xe = setTimeout(() => {
        L7(document.body);
      }, 200);
      return () => clearTimeout(xe);
    }
  }), ce(r, () => {
    $.value = r.value, r.value || _e();
  });
  function we(xe) {
    if (!B.value || !W.value)
      return;
    W.value.$el.classList.remove(jh), R.value = !1, B.value = !1, P.value = /* @__PURE__ */ new Date();
    const ze = kl(W.value.$el, h.value);
    if (!H(xe.target, !1) || !ze || Number.isNaN(ze) || T.value === null)
      return;
    const je = P.value.getTime() - T.value.getTime(), Ke = ee.value - (Et(h.value) ? xe.clientY : xe.clientX), lt = Math.abs(Ke) / je;
    if (lt > 0.05 && (k.value = !0, window.setTimeout(() => {
      k.value = !1;
    }, 200)), J.value) {
      const St = h.value === "bottom" || h.value === "right" ? 1 : -1;
      pe({
        draggedDistance: Ke * St,
        closeDrawer: _e,
        velocity: lt,
        dismissible: s.value
      }), n(!0);
      return;
    }
    if (h.value === "bottom" || h.value === "right" ? Ke > 0 : Ke < 0) {
      L(), n(!0);
      return;
    }
    if (lt > Aw) {
      _e(), n(!1);
      return;
    }
    const it = Math.min(
      W.value.$el.getBoundingClientRect().height ?? 0,
      window.innerHeight
    );
    if (ze >= it * p.value) {
      _e(), n(!1);
      return;
    }
    n(!0), L();
  }
  ce($, (xe) => {
    xe && (I.value = /* @__PURE__ */ new Date()), o(xe);
  }, { immediate: !0 });
  function Te(xe) {
    var ze, je;
    const Ke = xe ? (window.innerWidth - Ol) / window.innerWidth : 1, lt = xe ? -16 : 0;
    Q.value && window.clearTimeout(Q.value), Nt((ze = W.value) == null ? void 0 : ze.$el, {
      transition: `transform ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`,
      transform: `scale(${Ke}) translate3d(0, ${lt}px, 0)`
    }), !xe && (je = W.value) != null && je.$el && (Q.value = window.setTimeout(() => {
      var it, St;
      const Xt = kl((it = W.value) == null ? void 0 : it.$el, h.value);
      Nt((St = W.value) == null ? void 0 : St.$el, {
        transition: "none",
        transform: Et(h.value) ? `translate3d(0, ${Xt}px, 0)` : `translate3d(${Xt}px, 0, 0)`
      });
    }, 500));
  }
  function Ne(xe) {
    var ze;
    if (xe < 0)
      return;
    const je = Et(h.value) ? window.innerHeight : window.innerWidth, Ke = (je - Ol) / je, lt = Ke + xe * (1 - Ke), it = -16 + xe * Ol;
    Nt((ze = W.value) == null ? void 0 : ze.$el, {
      transform: Et(h.value) ? `scale(${lt}) translate3d(0, ${it}px, 0)` : `scale(${lt}) translate3d(${it}px, 0, 0)`,
      transition: "none"
    });
  }
  function Je(xe) {
    var ze;
    const je = Et(h.value) ? window.innerHeight : window.innerWidth, Ke = xe ? (je - Ol) / je : 1, lt = xe ? -16 : 0;
    xe && Nt((ze = W.value) == null ? void 0 : ze.$el, {
      transition: `transform ${wt.DURATION}s cubic-bezier(${wt.EASE.join(",")})`,
      transform: Et(h.value) ? `scale(${Ke}) translate3d(0, ${lt}px, 0)` : `scale(${Ke}) translate3d(${lt}px, 0, 0)`
    });
  }
  return {
    open: r,
    isOpen: $,
    modal: u,
    keyboardIsOpen: K,
    hasBeenOpened: D,
    drawerRef: W,
    drawerHeightRef: j,
    overlayRef: M,
    handleRef: Y,
    isDragging: B,
    dragStartTime: T,
    isAllowedToDrag: R,
    snapPoints: J,
    activeSnapPoint: v,
    hasSnapPoints: z,
    pointerStart: ee,
    dismissible: s,
    snapPointsOffset: $e,
    direction: h,
    shouldFade: De,
    fadeFromIndex: m,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    onPress: re,
    onDrag: ie,
    onRelease: we,
    closeDrawer: _e,
    onNestedDrag: Ne,
    onNestedRelease: Je,
    onNestedOpenChange: Te,
    emitClose: a,
    emitDrag: t,
    emitRelease: n,
    emitOpenChange: o,
    nested: i,
    handleOnly: x,
    noBodyStyles: _
  };
}
const X7 = /* @__PURE__ */ b({
  __name: "DrawerRoot",
  props: {
    activeSnapPoint: { default: void 0 },
    closeThreshold: { default: U7 },
    shouldScaleBackground: { type: Boolean, default: void 0 },
    setBackgroundColorOnScale: { type: Boolean, default: !0 },
    scrollLockTimeout: { default: j7 },
    fixed: { type: Boolean, default: void 0 },
    dismissible: { type: Boolean, default: !0 },
    modal: { type: Boolean, default: !0 },
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: void 0 },
    nested: { type: Boolean, default: !1 },
    direction: { default: "bottom" },
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean, default: !1 },
    preventScrollRestoration: { type: Boolean },
    snapPoints: { default: void 0 },
    fadeFromIndex: { default: void 0 }
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n;
    Jc();
    const r = E(() => a.fadeFromIndex ?? (a.snapPoints && a.snapPoints.length - 1)), s = Uh(a, "open", o, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), i = Uh(a, "activeSnapPoint", o, {
      passive: a.activeSnapPoint === void 0
    }), u = {
      emitDrag: (m) => o("drag", m),
      emitRelease: (m) => o("release", m),
      emitClose: () => o("close"),
      emitOpenChange: (m) => {
        o("update:open", m), setTimeout(() => {
          o("animationEnd", m);
        }, wt.DURATION * 1e3);
      }
    }, { closeDrawer: d, hasBeenOpened: c, modal: f, isOpen: p } = N7(
      Y7({
        ...u,
        ...Be(a),
        activeSnapPoint: i,
        fadeFromIndex: r,
        open: s
      })
    );
    function v(m) {
      if (s.value !== void 0) {
        u.emitOpenChange(m);
        return;
      }
      p.value = m, m ? c.value = !0 : d();
    }
    return t({
      open: p
    }), (m, h) => (g(), C(l(MD), {
      open: l(p),
      modal: l(f),
      "onUpdate:open": v
    }, {
      default: y(() => [
        w(m.$slots, "default", { open: l(p) })
      ]),
      _: 3
    }, 8, ["open", "modal"]));
  }
}), J7 = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  setup(e) {
    const { overlayRef: t, hasSnapPoints: n, isOpen: a, shouldFade: o } = iv();
    return (r, s) => (g(), C(l(m3), {
      ref_key: "overlayRef",
      ref: t,
      "data-vaul-overlay": "",
      "data-vaul-snap-points": l(a) && l(n) ? "true" : "false",
      "data-vaul-snap-points-overlay": l(a) && l(o) ? "true" : "false"
    }, null, 8, ["data-vaul-snap-points", "data-vaul-snap-points-overlay"]));
  }
}), Z7 = () => () => {
};
function Q7() {
  const { direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: a, noBodyStyles: o } = iv(), r = O(null), s = O(document.body.style.backgroundColor);
  function i() {
    return (window.innerWidth - Rw) / window.innerWidth;
  }
  Me((u) => {
    if (t.value && n.value) {
      r.value && clearTimeout(r.value);
      const d = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!d)
        return;
      H7(
        a.value && !o.value ? Vd(document.body, { background: "black" }) : Z7,
        Vd(d, {
          transformOrigin: Et(e.value) ? "top" : "left",
          transitionProperty: "transform, border-radius",
          transitionDuration: `${wt.DURATION}s`,
          transitionTimingFunction: `cubic-bezier(${wt.EASE.join(",")})`
        })
      );
      const c = Vd(d, {
        borderRadius: `${Iw}px`,
        overflow: "hidden",
        ...Et(e.value) ? {
          transform: `scale(${i()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${i()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      u(() => {
        c(), r.value = window.setTimeout(() => {
          s.value ? document.body.style.background = s.value : document.body.style.removeProperty("background");
        }, wt.DURATION * 1e3);
      });
    }
  }, { flush: "pre" });
}
const ez = /* @__PURE__ */ b({
  __name: "DrawerContent",
  setup(e) {
    const {
      open: t,
      isOpen: n,
      snapPointsOffset: a,
      hasSnapPoints: o,
      drawerRef: r,
      onPress: s,
      onDrag: i,
      onRelease: u,
      modal: d,
      emitOpenChange: c,
      dismissible: f,
      keyboardIsOpen: p,
      closeDrawer: v,
      direction: m,
      handleOnly: h
    } = iv();
    Q7();
    const _ = O(!1), x = E(() => a.value && a.value.length > 0 ? `${a.value[0]}px` : "0");
    function S(B) {
      if (!d.value || B.defaultPrevented) {
        B.preventDefault();
        return;
      }
      p.value && (p.value = !1), f.value ? c(!1) : B.preventDefault();
    }
    function $(B) {
      h.value || s(B);
    }
    function D(B) {
      h.value || i(B);
    }
    return Me(() => {
      o.value && window.requestAnimationFrame(() => {
        _.value = !0;
      });
    }), (B, k) => (g(), C(l(u3), {
      ref_key: "drawerRef",
      ref: r,
      "data-vaul-drawer": "",
      "data-vaul-drawer-direction": l(m),
      "data-vaul-delayed-snap-points": _.value ? "true" : "false",
      "data-vaul-snap-points": l(n) && l(o) ? "true" : "false",
      style: vt({ "--snap-point-height": x.value }),
      onPointerdown: $,
      onPointermove: D,
      onPointerup: l(u),
      onPointerDownOutside: S,
      onOpenAutoFocus: k[0] || (k[0] = We(() => {
      }, ["prevent"])),
      onEscapeKeyDown: k[1] || (k[1] = (M) => {
        l(f) || M.preventDefault();
      })
    }, {
      default: y(() => [
        w(B.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-vaul-drawer-direction", "data-vaul-delayed-snap-points", "data-vaul-snap-points", "style", "onPointerup"]));
  }
}), PW = /* @__PURE__ */ b({
  __name: "Drawer",
  props: {
    activeSnapPoint: {},
    closeThreshold: {},
    shouldScaleBackground: { type: Boolean, default: !0 },
    setBackgroundColorOnScale: { type: Boolean },
    scrollLockTimeout: {},
    fixed: { type: Boolean },
    dismissible: { type: Boolean },
    modal: { type: Boolean },
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    nested: { type: Boolean },
    direction: {},
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean },
    preventScrollRestoration: { type: Boolean },
    snapPoints: {},
    fadeFromIndex: {}
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(X7), A({ "data-slot": "drawer" }, l(o)), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), EW = /* @__PURE__ */ b({
  __name: "DrawerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(OD), A({ "data-slot": "drawer-close" }, t), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tz = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(J7), A({ "data-slot": "drawer-overlay" }, l(n), {
      class: l(F)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), DW = /* @__PURE__ */ b({
  __name: "DrawerContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, o = qe(n, t);
    return (r, s) => (g(), C(l(y3), null, {
      default: y(() => [
        N(tz),
        N(l(ez), A({ "data-slot": "drawer-content" }, l(o), {
          class: l(F)(
            "group/drawer-content fixed z-50 flex h-auto flex-col bg-background",
            "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg",
            "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg",
            "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm",
            "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm",
            n.class
          )
        }), {
          default: y(() => [
            s[0] || (s[0] = ye("div", { class: "mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full bg-muted group-data-[vaul-drawer-direction=bottom]/drawer-content:block" }, null, -1)),
            w(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), MW = /* @__PURE__ */ b({
  __name: "DrawerDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(c3), A({ "data-slot": "drawer-description" }, l(n), {
      class: l(F)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kW = /* @__PURE__ */ b({
  __name: "DrawerFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "drawer-footer",
      class: ae(l(F)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), OW = /* @__PURE__ */ b({
  __name: "DrawerHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "drawer-header",
      class: ae(l(F)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), TW = /* @__PURE__ */ b({
  __name: "DrawerTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(_3), A({ "data-slot": "drawer-title" }, l(n), {
      class: l(F)("font-semibold text-foreground", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), AW = /* @__PURE__ */ b({
  __name: "DrawerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(x3), A({ "data-slot": "drawer-trigger" }, t), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), IW = /* @__PURE__ */ b({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(aB), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), RW = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = Rt(e);
    return (a, o) => (g(), C(l(oB), A({ class: "outline-none" }, l(n)), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qW = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(rB), null, {
      default: y(() => [
        N(l(sB), A(l(r), {
          class: l(F)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            w(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), FW = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(iB), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), VW = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(fB), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), NW = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(lB), A(l(a), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), nz = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, LW = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:checked"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(dB), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        ye("span", nz, [
          N(l(Iy), null, {
            default: y(() => [
              N(l(z0), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), az = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, zW = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(pB), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        ye("span", az, [
          N(l(Iy), null, {
            default: y(() => [
              N(l(N6), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), HW = /* @__PURE__ */ b({
  __name: "DropdownMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("span", {
      class: ae(l(F)("ml-auto text-xs tracking-widest opacity-60", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), UW = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(uB), A(n.value, {
      class: l(F)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), jW = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(cB), A(l(a), {
      class: l(F)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), WW = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(vB), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), KW = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(hB), A(l(a), {
      class: l(F)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent data-[state=open]:bg-accent",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default"),
        N(l(F6), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), GW = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(mB), A(l(r), {
      class: l(F)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), YW = /* @__PURE__ */ b({
  __name: "Empty",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "empty",
      class: ae(
        l(F)(
          "flex min-w-0 flex-1 flex-col items-center justify-center gap-6 rounded-lg border-dashed p-6 text-center text-balance md:p-12",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), XW = /* @__PURE__ */ b({
  __name: "EmptyContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "empty-content",
      class: ae(
        l(F)(
          "flex w-full max-w-sm min-w-0 flex-col items-center gap-4 text-sm text-balance",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), JW = /* @__PURE__ */ b({
  __name: "EmptyDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("p", {
      "data-slot": "empty-description",
      class: ae(
        l(F)(
          "text-sm/relaxed text-muted-foreground [&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), ZW = /* @__PURE__ */ b({
  __name: "EmptyHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "empty-header",
      class: ae(l(F)("flex max-w-sm flex-col items-center gap-2 text-center", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), oz = ["data-variant"], QW = /* @__PURE__ */ b({
  __name: "EmptyMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "empty-icon",
      "data-variant": e.variant,
      class: ae(l(F)(l(rz)({ variant: e.variant }), t.class))
    }, [
      w(n.$slots, "default")
    ], 10, oz));
  }
}), eK = /* @__PURE__ */ b({
  __name: "EmptyTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "empty-title",
      class: ae(l(F)("text-lg font-medium tracking-tight", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), rz = en(
  "mb-2 flex shrink-0 items-center justify-center [&_svg]:pointer-events-none [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground [&_svg:not([class*='size-'])]:size-6"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), sz = ["data-orientation"], tK = /* @__PURE__ */ b({
  __name: "Field",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      role: "group",
      "data-slot": "field",
      "data-orientation": e.orientation,
      class: ae(l(F)(l(cz)({ orientation: e.orientation }), t.class))
    }, [
      w(n.$slots, "default")
    ], 10, sz));
  }
}), nK = /* @__PURE__ */ b({
  __name: "FieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "field-content",
      class: ae(l(F)("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), aK = /* @__PURE__ */ b({
  __name: "FieldDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("p", {
      "data-slot": "field-description",
      class: ae(
        l(F)(
          "text-sm leading-normal font-normal text-muted-foreground group-has-[[data-orientation=horizontal]]/field:text-balance",
          "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), lz = {
  key: 2,
  class: "ml-4 flex list-disc flex-col gap-1"
}, oK = /* @__PURE__ */ b({
  __name: "FieldError",
  props: {
    class: {},
    errors: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      var a;
      return !t.errors || t.errors.length === 0 ? null : t.errors.length === 1 && ((a = t.errors[0]) != null && a.message) ? t.errors[0].message : t.errors.some((o) => o == null ? void 0 : o.message) ? t.errors : null;
    });
    return (a, o) => a.$slots.default || n.value ? (g(), U("div", {
      key: 0,
      role: "alert",
      "data-slot": "field-error",
      class: ae(l(F)("text-sm font-normal text-destructive", t.class))
    }, [
      a.$slots.default ? w(a.$slots, "default", { key: 0 }) : typeof n.value == "string" ? (g(), U(Fe, { key: 1 }, [
        Re(Ve(n.value), 1)
      ], 64)) : Array.isArray(n.value) ? (g(), U("ul", lz, [
        (g(!0), U(Fe, null, $t(n.value, (r, s) => (g(), U("li", { key: s }, Ve(r == null ? void 0 : r.message), 1))), 128))
      ])) : Pe("", !0)
    ], 2)) : Pe("", !0);
  }
}), rK = /* @__PURE__ */ b({
  __name: "FieldGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "field-group",
      class: ae(
        l(F)(
          "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), qw = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(mT), A(l(n), {
      class: l(F)(
        "text-sm leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        t.class
      )
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sK = /* @__PURE__ */ b({
  __name: "FieldLabel",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(qw), {
      "data-slot": "field-label",
      class: ae(
        l(F)(
          "group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50",
          "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&_>[data-slot=field]]:p-3",
          "has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-primary/5 dark:has-[[data-state=checked]]:bg-primary/10",
          t.class
        )
      )
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), iz = ["data-variant"], lK = /* @__PURE__ */ b({
  __name: "FieldLegend",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("legend", {
      "data-slot": "field-legend",
      "data-variant": e.variant,
      class: ae(
        l(F)(
          "mb-3 font-medium",
          "data-[variant=legend]:text-base",
          "data-[variant=label]:text-sm",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 10, iz));
  }
}), uz = ["data-content"], dz = {
  key: 0,
  class: "relative mx-auto block w-fit bg-background px-2 text-muted-foreground",
  "data-slot": "field-separator-content"
}, iK = /* @__PURE__ */ b({
  __name: "FieldSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "field-separator",
      "data-content": !!n.$slots.default,
      class: ae(
        l(F)("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", t.class)
      )
    }, [
      N(l(Ou), { class: "absolute inset-0 top-1/2" }),
      n.$slots.default ? (g(), U("span", dz, [
        w(n.$slots, "default")
      ])) : Pe("", !0)
    ], 10, uz));
  }
}), uK = /* @__PURE__ */ b({
  __name: "FieldSet",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("fieldset", {
      "data-slot": "field-set",
      class: ae(
        l(F)(
          "flex flex-col gap-6",
          "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), dK = /* @__PURE__ */ b({
  __name: "FieldTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "field-label",
      class: ae(
        l(F)(
          "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), cz = en(
  "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
  {
    variants: {
      orientation: {
        vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
        horizontal: [
          "flex-row items-center",
          "[&>[data-slot=field-label]]:flex-auto",
          "has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px has-[>[data-slot=field-content]]:items-start"
        ],
        responsive: [
          "@md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto flex-col [&>*]:w-full [&>.sr-only]:w-auto",
          "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
          "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
        ]
      }
    },
    defaultVariants: {
      orientation: "vertical"
    }
  }
);
/**
  * vee-validate v4.15.1
  * (c) 2025 Abdelrahman Awad
  * @license MIT
  */
function Wt(e) {
  return typeof e == "function";
}
function Go(e) {
  return e == null;
}
const eo = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function uv(e) {
  return Number(e) >= 0;
}
function fz(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function pz(e) {
  return typeof e == "object" && e !== null;
}
function vz(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function Kh(e) {
  if (!pz(e) || vz(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function Ts(e, t) {
  return Object.keys(t).forEach((n) => {
    if (Kh(t[n]) && Kh(e[n])) {
      e[n] || (e[n] = {}), Ts(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function as(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let a = 1; a < t.length; a++) {
    if (uv(t[a])) {
      n += `[${t[a]}]`;
      continue;
    }
    n += `.${t[a]}`;
  }
  return n;
}
const mz = {};
function hz(e) {
  return mz[e];
}
function Gh(e, t, n) {
  typeof n.value == "object" && (n.value = Xe(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function Xe(e) {
  if (typeof e != "object") return e;
  var t = 0, n, a, o, r = Object.prototype.toString.call(e);
  if (r === "[object Object]" ? o = Object.create(e.__proto__ || null) : r === "[object Array]" ? o = Array(e.length) : r === "[object Set]" ? (o = /* @__PURE__ */ new Set(), e.forEach(function(s) {
    o.add(Xe(s));
  })) : r === "[object Map]" ? (o = /* @__PURE__ */ new Map(), e.forEach(function(s, i) {
    o.set(Xe(i), Xe(s));
  })) : r === "[object Date]" ? o = /* @__PURE__ */ new Date(+e) : r === "[object RegExp]" ? o = new RegExp(e.source, e.flags) : r === "[object DataView]" ? o = new e.constructor(Xe(e.buffer)) : r === "[object ArrayBuffer]" ? o = e.slice(0) : r.slice(-6) === "Array]" && (o = new e.constructor(e)), o) {
    for (a = Object.getOwnPropertySymbols(e); t < a.length; t++)
      Gh(o, a[t], Object.getOwnPropertyDescriptor(e, a[t]));
    for (t = 0, a = Object.getOwnPropertyNames(e); t < a.length; t++)
      Object.hasOwnProperty.call(o, n = a[t]) && o[n] === e[n] || Gh(o, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return o || e;
}
const ol = Symbol("vee-validate-form"), gz = Symbol("vee-validate-form-context"), Fw = Symbol("vee-validate-field-instance"), zi = Symbol("Default empty value"), Vw = typeof window < "u";
function jc(e) {
  return Wt(e) && !!e.__locatorRef;
}
function Ln(e) {
  return !!e && Wt(e.parse) && e.__type === "VVTypedSchema";
}
function Hi(e) {
  return !!e && Wt(e.validate);
}
function rl(e) {
  return e === "checkbox" || e === "radio";
}
function yz(e) {
  return eo(e) || Array.isArray(e);
}
function bz(e) {
  return Array.isArray(e) ? e.length === 0 : eo(e) && Object.keys(e).length === 0;
}
function Gu(e) {
  return /^\[.+\]$/i.test(e);
}
function _z(e) {
  return Nw(e) && e.multiple;
}
function Nw(e) {
  return e.tagName === "SELECT";
}
function wz(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function xz(e, t) {
  return !wz(e, t) && t.type !== "file" && !rl(t.type);
}
function Lw(e) {
  return dv(e) && e.target && "submit" in e.target;
}
function dv(e) {
  return e ? !!(typeof Event < "u" && Wt(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function Yh(e, t) {
  return t in e && e[t] !== zi;
}
function zt(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, a, o;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (!zt(e[a], t[a]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      for (a of e.entries())
        if (!zt(a[1], t.get(a[0])))
          return !1;
      return !0;
    }
    if (Jh(e) && Jh(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (e[a] !== t[a])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (e = Xh(e), t = Xh(t), o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (a = n; a-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, o[a]))
        return !1;
    for (a = n; a-- !== 0; ) {
      var r = o[a];
      if (!zt(e[r], t[r]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Xh(e) {
  return Object.fromEntries(Object.entries(e).filter(([, t]) => t !== void 0));
}
function Jh(e) {
  return Vw ? e instanceof File : !1;
}
function cv(e) {
  return Gu(e) ? e.replace(/\[|\]/gi, "") : e;
}
function xt(e, t, n) {
  return e ? Gu(t) ? e[cv(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((o, r) => yz(o) && r in o ? o[r] : n, e) : n;
}
function Lt(e, t, n) {
  if (Gu(t)) {
    e[cv(t)] = n;
    return;
  }
  const a = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let o = e;
  for (let r = 0; r < a.length; r++) {
    if (r === a.length - 1) {
      o[a[r]] = n;
      return;
    }
    (!(a[r] in o) || Go(o[a[r]])) && (o[a[r]] = uv(a[r + 1]) ? [] : {}), o = o[a[r]];
  }
}
function Nd(e, t) {
  if (Array.isArray(e) && uv(t)) {
    e.splice(Number(t), 1);
    return;
  }
  eo(e) && delete e[t];
}
function Zh(e, t) {
  if (Gu(t)) {
    delete e[cv(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let a = e;
  for (let r = 0; r < n.length; r++) {
    if (r === n.length - 1) {
      Nd(a, n[r]);
      break;
    }
    if (!(n[r] in a) || Go(a[n[r]]))
      break;
    a = a[n[r]];
  }
  const o = n.map((r, s) => xt(e, n.slice(0, s).join(".")));
  for (let r = o.length - 1; r >= 0; r--)
    if (bz(o[r])) {
      if (r === 0) {
        Nd(e, n[0]);
        continue;
      }
      Nd(o[r - 1], n[r - 1]);
    }
}
function ln(e) {
  return Object.keys(e);
}
function fv(e, t = void 0) {
  const n = ct();
  return (n == null ? void 0 : n.provides[e]) || vn(e, t);
}
function Ld(e) {
  vg(`[vee-validate]: ${e}`);
}
function Qh(e, t, n) {
  if (Array.isArray(e)) {
    const a = [...e], o = a.findIndex((r) => zt(r, t));
    return o >= 0 ? a.splice(o, 1) : a.push(t), a;
  }
  return zt(e, t) ? n : t;
}
function Cz(e, t) {
  let n, a;
  return function(...o) {
    const r = this;
    return n || (n = !0, setTimeout(() => n = !1, t), a = e.apply(r, o)), a;
  };
}
function eg(e, t = 0) {
  let n = null, a = [];
  return function(...o) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const r = e(...o);
      a.forEach((s) => s(r)), a = [];
    }, t), new Promise((r) => a.push(r));
  };
}
function Sz(e, t) {
  return eo(t) && t.number ? fz(e) : e;
}
function Wc(e, t) {
  let n;
  return async function(...o) {
    const r = e(...o);
    n = r;
    const s = await r;
    return r !== n ? s : (n = void 0, t(s, o));
  };
}
function $z({ get: e, set: t }) {
  const n = O(Xe(e()));
  return ce(e, (a) => {
    zt(a, n.value) || (n.value = Xe(a));
  }, {
    deep: !0
  }), ce(n, (a) => {
    zt(a, e()) || t(Xe(a));
  }, {
    deep: !0
  }), n;
}
function Kc(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function Tl(e, t) {
  const n = {};
  for (const a in e)
    t.includes(a) || (n[a] = e[a]);
  return n;
}
function Bz(e) {
  let t = null, n = [];
  return function(...a) {
    const o = he(() => {
      if (t !== o)
        return;
      const r = e(...a);
      n.forEach((s) => s(r)), n = [], t = null;
    });
    return t = o, new Promise((r) => n.push(r));
  };
}
function Yu(e, t, n) {
  return t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
    default: () => {
      var a, o;
      return (o = (a = t.slots).default) === null || o === void 0 ? void 0 : o.call(a, n());
    }
  } : t.slots.default;
}
function zd(e) {
  if (zw(e))
    return e._value;
}
function zw(e) {
  return "_value" in e;
}
function Pz(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function Ui(e) {
  if (!dv(e))
    return e;
  const t = e.target;
  if (rl(t.type) && zw(t))
    return zd(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (_z(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(zd);
  if (Nw(t)) {
    const n = Array.from(t.options).find((a) => a.selected);
    return n ? zd(n) : t.value;
  }
  return Pz(t);
}
function Hw(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? eo(e) && e._$$isNormalized ? e : eo(e) ? Object.keys(e).reduce((n, a) => {
    const o = Ez(e[a]);
    return e[a] !== !1 && (n[a] = tg(o)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, a) => {
    const o = Dz(a);
    return o.name && (n[o.name] = tg(o.params)), n;
  }, t) : t;
}
function Ez(e) {
  return e === !0 ? [] : Array.isArray(e) || eo(e) ? e : [e];
}
function tg(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? Mz(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, a) => (n[a] = t(e[a]), n), {});
}
const Dz = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function Mz(e) {
  const t = (n) => {
    var a;
    return (a = xt(n, e)) !== null && a !== void 0 ? a : n[e];
  };
  return t.__locatorRef = e, t;
}
function kz(e) {
  return Array.isArray(e) ? e.filter(jc) : ln(e).filter((t) => jc(e[t])).map((t) => e[t]);
}
const Oz = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let Tz = Object.assign({}, Oz);
const vo = () => Tz;
async function Uw(e, t, n = {}) {
  const a = n == null ? void 0 : n.bails, o = {
    name: (n == null ? void 0 : n.name) || "{field}",
    rules: t,
    label: n == null ? void 0 : n.label,
    bails: a ?? !0,
    formData: (n == null ? void 0 : n.values) || {}
  }, r = await Az(o, e);
  return Object.assign(Object.assign({}, r), { valid: !r.errors.length });
}
async function Az(e, t) {
  const n = e.rules;
  if (Ln(n) || Hi(n))
    return Rz(t, Object.assign(Object.assign({}, e), { rules: n }));
  if (Wt(n) || Array.isArray(n)) {
    const i = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, u = Array.isArray(n) ? n : [n], d = u.length, c = [];
    for (let f = 0; f < d; f++) {
      const p = u[f], v = await p(t, i);
      if (!(typeof v != "string" && !Array.isArray(v) && v)) {
        if (Array.isArray(v))
          c.push(...v);
        else {
          const h = typeof v == "string" ? v : Ww(i);
          c.push(h);
        }
        if (e.bails)
          return {
            errors: c
          };
      }
    }
    return {
      errors: c
    };
  }
  const a = Object.assign(Object.assign({}, e), { rules: Hw(n) }), o = [], r = Object.keys(a.rules), s = r.length;
  for (let i = 0; i < s; i++) {
    const u = r[i], d = await qz(a, t, {
      name: u,
      params: a.rules[u]
    });
    if (d.error && (o.push(d.error), e.bails))
      return {
        errors: o
      };
  }
  return {
    errors: o
  };
}
function Iz(e) {
  return !!e && e.name === "ValidationError";
}
function jw(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n, a) {
      var o;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1, context: (a == null ? void 0 : a.formData) || {} }),
          errors: []
        };
      } catch (r) {
        if (!Iz(r))
          throw r;
        if (!(!((o = r.inner) === null || o === void 0) && o.length) && r.errors.length)
          return { errors: [{ path: r.path, errors: r.errors }] };
        const s = r.inner.reduce((i, u) => {
          const d = u.path || "";
          return i[d] || (i[d] = { errors: [], path: d }), i[d].errors.push(...u.errors), i;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function Rz(e, t) {
  const a = await (Ln(t.rules) ? t.rules : jw(t.rules)).parse(e, { formData: t.formData }), o = [];
  for (const r of a.errors)
    r.errors.length && o.push(...r.errors);
  return {
    value: a.value,
    errors: o
  };
}
async function qz(e, t, n) {
  const a = hz(n.name);
  if (!a)
    throw new Error(`No such validator '${n.name}' exists.`);
  const o = Fz(n.params, e.formData), r = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: o })
  }, s = await a(t, o, r);
  return typeof s == "string" ? {
    error: s
  } : {
    error: s ? void 0 : Ww(r)
  };
}
function Ww(e) {
  const t = vo().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function Fz(e, t) {
  const n = (a) => jc(a) ? a(t) : a;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((a, o) => (a[o] = n(e[o]), a), {});
}
async function Vz(e, t) {
  const a = await (Ln(e) ? e : jw(e)).parse(Xe(t), { formData: Xe(t) }), o = {}, r = {};
  for (const s of a.errors) {
    const i = s.errors, u = (s.path || "").replace(/\["(\d+)"\]/g, (d, c) => `[${c}]`);
    o[u] = { valid: !i.length, errors: i }, i.length && (r[u] = i[0]);
  }
  return {
    valid: !a.errors.length,
    results: o,
    errors: r,
    values: a.value,
    source: "schema"
  };
}
async function Nz(e, t, n) {
  const o = ln(e).map(async (d) => {
    var c, f, p;
    const v = (c = n == null ? void 0 : n.names) === null || c === void 0 ? void 0 : c[d], m = await Uw(xt(t, d), e[d], {
      name: (v == null ? void 0 : v.name) || d,
      label: v == null ? void 0 : v.label,
      values: t,
      bails: (p = (f = n == null ? void 0 : n.bailsMap) === null || f === void 0 ? void 0 : f[d]) !== null && p !== void 0 ? p : !0
    });
    return Object.assign(Object.assign({}, m), { path: d });
  });
  let r = !0;
  const s = await Promise.all(o), i = {}, u = {};
  for (const d of s)
    i[d.path] = {
      valid: d.valid,
      errors: d.errors
    }, d.valid || (r = !1, u[d.path] = d.errors[0]);
  return {
    valid: r,
    results: i,
    errors: u,
    source: "schema"
  };
}
let ng = 0;
function Lz(e, t) {
  const { value: n, initialValue: a, setInitialValue: o } = zz(e, t.modelValue, t.form);
  if (!t.form) {
    let p = function(v) {
      var m;
      "value" in v && (n.value = v.value), "errors" in v && d(v.errors), "touched" in v && (f.touched = (m = v.touched) !== null && m !== void 0 ? m : f.touched), "initialValue" in v && o(v.initialValue);
    };
    const { errors: u, setErrors: d } = jz(), c = ng >= Number.MAX_SAFE_INTEGER ? 0 : ++ng, f = Uz(n, a, u, t.schema);
    return {
      id: c,
      path: e,
      value: n,
      initialValue: a,
      meta: f,
      flags: { pendingUnmount: { [c]: !1 }, pendingReset: !1 },
      errors: u,
      setState: p
    };
  }
  const r = t.form.createPathState(e, {
    bails: t.bails,
    label: t.label,
    type: t.type,
    validate: t.validate,
    schema: t.schema
  }), s = E(() => r.errors);
  function i(u) {
    var d, c, f;
    "value" in u && (n.value = u.value), "errors" in u && ((d = t.form) === null || d === void 0 || d.setFieldError(l(e), u.errors)), "touched" in u && ((c = t.form) === null || c === void 0 || c.setFieldTouched(l(e), (f = u.touched) !== null && f !== void 0 ? f : !1)), "initialValue" in u && o(u.initialValue);
  }
  return {
    id: Array.isArray(r.id) ? r.id[r.id.length - 1] : r.id,
    path: e,
    value: n,
    errors: s,
    meta: r,
    initialValue: a,
    flags: r.__flags,
    setState: i
  };
}
function zz(e, t, n) {
  const a = O(l(t));
  function o() {
    return n ? xt(n.initialValues.value, l(e), l(a)) : l(a);
  }
  function r(d) {
    if (!n) {
      a.value = d;
      return;
    }
    n.setFieldInitialValue(l(e), d, !0);
  }
  const s = E(o);
  if (!n)
    return {
      value: O(o()),
      initialValue: s,
      setInitialValue: r
    };
  const i = Hz(t, n, s, e);
  return n.stageInitialValue(l(e), i, !0), {
    value: E({
      get() {
        return xt(n.values, l(e));
      },
      set(d) {
        n.setFieldValue(l(e), d, !1);
      }
    }),
    initialValue: s,
    setInitialValue: r
  };
}
function Hz(e, t, n, a) {
  return ht(e) ? l(e) : e !== void 0 ? e : xt(t.values, l(a), l(n));
}
function Uz(e, t, n, a) {
  const o = E(() => {
    var s, i, u;
    return (u = (i = (s = me(a)) === null || s === void 0 ? void 0 : s.describe) === null || i === void 0 ? void 0 : i.call(s).required) !== null && u !== void 0 ? u : !1;
  }), r = Qt({
    touched: !1,
    pending: !1,
    valid: !0,
    required: o,
    validated: !!l(n).length,
    initialValue: E(() => l(t)),
    dirty: E(() => !zt(l(e), l(t)))
  });
  return ce(n, (s) => {
    r.valid = !s.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), r;
}
function jz() {
  const e = O([]);
  return {
    errors: e,
    setErrors: (t) => {
      e.value = Kc(t);
    }
  };
}
const cs = {}, fs = {}, ps = "vee-validate-inspector", dn = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let Pt = null, ma;
async function Kw(e) {
  if (process.env.NODE_ENV !== "production") {
    if (!Vw)
      return;
    (await import("./index-D-WRsztv.js")).setupDevtoolsPlugin({
      id: "vee-validate-devtools-plugin",
      label: "VeeValidate Plugin",
      packageName: "vee-validate",
      homepage: "https://vee-validate.logaretm.com/v4",
      app: e,
      logo: "https://vee-validate.logaretm.com/v4/logo.png"
    }, (n) => {
      ma = n, n.addInspector({
        id: ps,
        icon: "rule",
        label: "vee-validate",
        noSelectionText: "Select a vee-validate node to inspect",
        actions: [
          {
            icon: "done_outline",
            tooltip: "Validate selected item",
            action: async () => {
              if (!Pt) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (Pt.type === "field") {
                await Pt.field.validate();
                return;
              }
              if (Pt.type === "form") {
                await Pt.form.validate();
                return;
              }
              Pt.type === "pathState" && await Pt.form.validateField(Pt.state.path);
            }
          },
          {
            icon: "delete_sweep",
            tooltip: "Clear validation state of the selected item",
            action: () => {
              if (!Pt) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (Pt.type === "field") {
                Pt.field.resetField();
                return;
              }
              Pt.type === "form" && Pt.form.resetForm(), Pt.type === "pathState" && Pt.form.resetField(Pt.state.path);
            }
          }
        ]
      }), n.on.getInspectorTree((a) => {
        if (a.inspectorId !== ps)
          return;
        const o = Object.values(cs), r = Object.values(fs);
        a.rootNodes = [
          ...o.map(Gz),
          ...r.map((s) => Xz(s))
        ];
      }), n.on.getInspectorState((a) => {
        if (a.inspectorId !== ps)
          return;
        const { form: o, field: r, state: s, type: i } = Jz(a.nodeId);
        if (n.unhighlightElement(), o && i === "form") {
          a.state = Zz(o), Pt = { type: "form", form: o }, n.highlightElement(o._vm);
          return;
        }
        if (s && i === "pathState" && o) {
          a.state = ag(s), Pt = { type: "pathState", state: s, form: o };
          return;
        }
        if (r && i === "field") {
          a.state = ag({
            errors: r.errors.value,
            dirty: r.meta.dirty,
            valid: r.meta.valid,
            touched: r.meta.touched,
            value: r.value.value,
            initialValue: r.meta.initialValue
          }), Pt = { field: r, type: "field" }, n.highlightElement(r._vm);
          return;
        }
        Pt = null, n.unhighlightElement();
      });
    });
  }
}
const yr = Cz(() => {
  setTimeout(async () => {
    await he(), ma == null || ma.sendInspectorState(ps), ma == null || ma.sendInspectorTree(ps);
  }, 100);
}, 100);
function Wz(e) {
  const t = ct();
  if (!ma) {
    const n = t == null ? void 0 : t.appContext.app;
    if (!n)
      return;
    Kw(n);
  }
  cs[e.formId] = Object.assign({}, e), cs[e.formId]._vm = t, Ze(() => {
    delete cs[e.formId], yr();
  }), yr();
}
function Kz(e) {
  const t = ct();
  if (!ma) {
    const n = t == null ? void 0 : t.appContext.app;
    if (!n)
      return;
    Kw(n);
  }
  fs[e.id] = Object.assign({}, e), fs[e.id]._vm = t, Ze(() => {
    delete fs[e.id], yr();
  }), yr();
}
function Gz(e) {
  const { textColor: t, bgColor: n } = Yw(e.meta.value.valid), a = {};
  Object.values(e.getAllPathStates()).forEach((s) => {
    Lt(a, me(s.path), Yz(s, e));
  });
  function o(s, i = []) {
    const u = [...i].pop();
    return "id" in s ? Object.assign(Object.assign({}, s), { label: u || s.label }) : eo(s) ? {
      id: `${i.join(".")}`,
      label: u || "",
      children: Object.keys(s).map((d) => o(s[d], [...i, d]))
    } : Array.isArray(s) ? {
      id: `${i.join(".")}`,
      label: `${u}[]`,
      children: s.map((d, c) => o(d, [...i, String(c)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: r } = o(a);
  return {
    id: pv(e),
    label: e.name,
    children: r,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${e.getAllPathStates().length} fields`,
        textColor: dn.white,
        backgroundColor: dn.unknown
      }
    ]
  };
}
function Yz(e, t) {
  return {
    id: pv(t, e),
    label: me(e.path),
    tags: Gw(e.multiple, e.fieldsCount, e.type, e.valid, t)
  };
}
function Xz(e, t) {
  return {
    id: pv(t, e),
    label: l(e.name),
    tags: Gw(!1, 1, e.type, e.meta.valid, t)
  };
}
function Gw(e, t, n, a, o) {
  const { textColor: r, bgColor: s } = Yw(a);
  return [
    e ? void 0 : {
      label: "Field",
      textColor: r,
      backgroundColor: s
    },
    o ? void 0 : {
      label: "Standalone",
      textColor: dn.black,
      backgroundColor: dn.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: dn.white,
      backgroundColor: dn.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: dn.white,
      backgroundColor: dn.purple
    } : void 0,
    e ? {
      label: "Multiple",
      textColor: dn.black,
      backgroundColor: dn.orange
    } : void 0
  ].filter(Boolean);
}
function pv(e, t) {
  const n = t ? "path" in t ? "pathState" : "field" : "form", a = t ? "path" in t ? t == null ? void 0 : t.path : me(t == null ? void 0 : t.name) : "", o = { f: e == null ? void 0 : e.formId, ff: (t == null ? void 0 : t.id) || a, type: n };
  return btoa(encodeURIComponent(JSON.stringify(o)));
}
function Jz(e) {
  try {
    const t = JSON.parse(decodeURIComponent(atob(e))), n = cs[t.f];
    if (!n && t.ff) {
      const o = fs[t.ff];
      return o ? {
        type: t.type,
        field: o
      } : {};
    }
    if (!n)
      return {};
    const a = n.getPathState(t.ff);
    return {
      type: t.type,
      form: n,
      state: a
    };
  } catch {
  }
  return {};
}
function ag(e) {
  return {
    "Field state": [
      { key: "errors", value: e.errors },
      {
        key: "initialValue",
        value: e.initialValue
      },
      {
        key: "currentValue",
        value: e.value
      },
      {
        key: "touched",
        value: e.touched
      },
      {
        key: "dirty",
        value: e.dirty
      },
      {
        key: "valid",
        value: e.valid
      }
    ]
  };
}
function Zz(e) {
  const { errorBag: t, meta: n, values: a, isSubmitting: o, isValidating: r, submitCount: s } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: s.value
      },
      {
        key: "isSubmitting",
        value: o.value
      },
      {
        key: "isValidating",
        value: r.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: a
      },
      {
        key: "errors",
        value: ln(t.value).reduce((i, u) => {
          var d;
          const c = (d = t.value[u]) === null || d === void 0 ? void 0 : d[0];
          return c && (i[u] = c), i;
        }, {})
      }
    ]
  };
}
function Yw(e) {
  return {
    bgColor: e ? dn.success : dn.error,
    textColor: e ? dn.black : dn.white
  };
}
function Qz(e, t, n) {
  return rl(n == null ? void 0 : n.type) ? t9(e, t, n) : Xw(e, t, n);
}
function Xw(e, t, n) {
  const { initialValue: a, validateOnMount: o, bails: r, type: s, checkedValue: i, label: u, validateOnValueUpdate: d, uncheckedValue: c, controlled: f, keepValueOnUnmount: p, syncVModel: v, form: m } = e9(n), h = f ? fv(ol) : void 0, _ = m || h, x = E(() => as(me(e))), S = E(() => {
    if (me(_ == null ? void 0 : _.schema))
      return;
    const V = l(t);
    return Hi(V) || Ln(V) || Wt(V) || Array.isArray(V) ? V : Hw(V);
  }), $ = !Wt(S.value) && Ln(me(t)), { id: D, value: B, initialValue: k, meta: M, setState: I, errors: T, flags: P } = Lz(x, {
    modelValue: a,
    form: _,
    bails: r,
    label: u,
    type: s,
    validate: S.value ? W : void 0,
    schema: $ ? t : void 0
  }), q = E(() => T.value[0]);
  v && n9({
    value: B,
    prop: v,
    handleChange: j,
    shouldValidate: () => d && !P.pendingReset
  });
  const R = (ue, V = !1) => {
    M.touched = !0, V && ee();
  };
  async function Q(ue) {
    var V, te;
    if (_ != null && _.validateSchema) {
      const { results: H } = await _.validateSchema(ue);
      return (V = H[me(x)]) !== null && V !== void 0 ? V : { valid: !0, errors: [] };
    }
    return S.value ? Uw(B.value, S.value, {
      name: me(x),
      label: me(u),
      values: (te = _ == null ? void 0 : _.values) !== null && te !== void 0 ? te : {},
      bails: r
    }) : { valid: !0, errors: [] };
  }
  const ee = Wc(async () => (M.pending = !0, M.validated = !0, Q("validated-only")), (ue) => (P.pendingUnmount[Ce.id] || (I({ errors: ue.errors }), M.pending = !1, M.valid = ue.valid), ue)), K = Wc(async () => Q("silent"), (ue) => (M.valid = ue.valid, ue));
  function W(ue) {
    return (ue == null ? void 0 : ue.mode) === "silent" ? K() : ee();
  }
  function j(ue, V = !0) {
    const te = Ui(ue);
    Z(te, V);
  }
  be(() => {
    if (o)
      return ee();
    (!_ || !_.validateSchema) && K();
  });
  function J(ue) {
    M.touched = ue;
  }
  function z(ue) {
    var V;
    const te = ue && "value" in ue ? ue.value : k.value;
    I({
      value: Xe(te),
      initialValue: Xe(te),
      touched: (V = ue == null ? void 0 : ue.touched) !== null && V !== void 0 ? V : !1,
      errors: (ue == null ? void 0 : ue.errors) || []
    }), M.pending = !1, M.validated = !1, K();
  }
  const Y = ct();
  function Z(ue, V = !0) {
    B.value = Y && v ? Sz(ue, Y.props.modelModifiers) : ue, (V ? ee : K)();
  }
  function pe(ue) {
    I({ errors: Array.isArray(ue) ? ue : [ue] });
  }
  const $e = E({
    get() {
      return B.value;
    },
    set(ue) {
      Z(ue, d);
    }
  }), Ce = {
    id: D,
    name: x,
    label: u,
    value: $e,
    meta: M,
    errors: T,
    errorMessage: q,
    type: s,
    checkedValue: i,
    uncheckedValue: c,
    bails: r,
    keepValueOnUnmount: p,
    resetField: z,
    handleReset: () => z(),
    validate: W,
    handleChange: j,
    handleBlur: R,
    setState: I,
    setTouched: J,
    setErrors: pe,
    setValue: Z
  };
  if (Mn(Fw, Ce), ht(t) && typeof l(t) != "function" && ce(t, (ue, V) => {
    zt(ue, V) || (M.validated ? ee() : K());
  }, {
    deep: !0
  }), process.env.NODE_ENV !== "production" && (Ce._vm = ct(), ce(() => Object.assign(Object.assign({ errors: T.value }, M), { value: B.value }), yr, {
    deep: !0
  }), _ || Kz(Ce)), !_)
    return Ce;
  const De = E(() => {
    const ue = S.value;
    return !ue || Wt(ue) || Hi(ue) || Ln(ue) || Array.isArray(ue) ? {} : Object.keys(ue).reduce((V, te) => {
      const H = kz(ue[te]).map((re) => re.__locatorRef).reduce((re, ie) => {
        const L = xt(_.values, ie) || _.values[ie];
        return L !== void 0 && (re[ie] = L), re;
      }, {});
      return Object.assign(V, H), V;
    }, {});
  });
  return ce(De, (ue, V) => {
    if (!Object.keys(ue).length)
      return;
    !zt(ue, V) && (M.validated ? ee() : K());
  }), ka(() => {
    var ue;
    const V = (ue = me(Ce.keepValueOnUnmount)) !== null && ue !== void 0 ? ue : me(_.keepValuesOnUnmount), te = me(x);
    if (V || !_ || P.pendingUnmount[Ce.id]) {
      _ == null || _.removePathState(te, D);
      return;
    }
    P.pendingUnmount[Ce.id] = !0;
    const H = _.getPathState(te);
    if (Array.isArray(H == null ? void 0 : H.id) && (H != null && H.multiple) ? H != null && H.id.includes(Ce.id) : (H == null ? void 0 : H.id) === Ce.id) {
      if (H != null && H.multiple && Array.isArray(H.value)) {
        const ie = H.value.findIndex((L) => zt(L, me(Ce.checkedValue)));
        if (ie > -1) {
          const L = [...H.value];
          L.splice(ie, 1), _.setFieldValue(te, L);
        }
        Array.isArray(H.id) && H.id.splice(H.id.indexOf(Ce.id), 1);
      } else
        _.unsetPathValue(me(x));
      _.removePathState(te, D);
    }
  }), Ce;
}
function e9(e) {
  const t = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    label: void 0,
    validateOnValueUpdate: !0,
    keepValueOnUnmount: void 0,
    syncVModel: !1,
    controlled: !0
  }), n = !!(e != null && e.syncVModel), a = typeof (e == null ? void 0 : e.syncVModel) == "string" ? e.syncVModel : (e == null ? void 0 : e.modelPropName) || "modelValue", o = n && !("initialValue" in (e || {})) ? Gc(ct(), a) : e == null ? void 0 : e.initialValue;
  if (!e)
    return Object.assign(Object.assign({}, t()), { initialValue: o });
  const r = "valueProp" in e ? e.valueProp : e.checkedValue, s = "standalone" in e ? !e.standalone : e.controlled, i = (e == null ? void 0 : e.modelPropName) || (e == null ? void 0 : e.syncVModel) || !1;
  return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
    initialValue: o,
    controlled: s ?? !0,
    checkedValue: r,
    syncVModel: i
  });
}
function t9(e, t, n) {
  const a = n != null && n.standalone ? void 0 : fv(ol), o = n == null ? void 0 : n.checkedValue, r = n == null ? void 0 : n.uncheckedValue;
  function s(i) {
    const u = i.handleChange, d = E(() => {
      const f = me(i.value), p = me(o);
      return Array.isArray(f) ? f.findIndex((v) => zt(v, p)) >= 0 : zt(p, f);
    });
    function c(f, p = !0) {
      var v, m;
      if (d.value === ((v = f == null ? void 0 : f.target) === null || v === void 0 ? void 0 : v.checked)) {
        p && i.validate();
        return;
      }
      const h = me(e), _ = a == null ? void 0 : a.getPathState(h), x = Ui(f);
      let S = (m = me(o)) !== null && m !== void 0 ? m : x;
      a && (_ != null && _.multiple) && _.type === "checkbox" ? S = Qh(xt(a.values, h) || [], S, void 0) : (n == null ? void 0 : n.type) === "checkbox" && (S = Qh(me(i.value), S, me(r))), u(S, p);
    }
    return Object.assign(Object.assign({}, i), {
      checked: d,
      checkedValue: o,
      uncheckedValue: r,
      handleChange: c
    });
  }
  return s(Xw(e, t, n));
}
function n9({ prop: e, value: t, handleChange: n, shouldValidate: a }) {
  const o = ct();
  if (!o || !e) {
    process.env.NODE_ENV !== "production" && console.warn("Failed to setup model events because `useField` was not called in setup.");
    return;
  }
  const r = typeof e == "string" ? e : "modelValue", s = `update:${r}`;
  r in o.props && (ce(t, (i) => {
    zt(i, Gc(o, r)) || o.emit(s, i);
  }), ce(() => Gc(o, r), (i) => {
    if (i === zi && t.value === void 0)
      return;
    const u = i === zi ? void 0 : i;
    zt(u, t.value) || n(u, a());
  }));
}
function Gc(e, t) {
  if (e)
    return e.props[t];
}
const a9 = /* @__PURE__ */ b({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => vo().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: zi
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = Fn(e, "rules"), a = Fn(e, "name"), o = Fn(e, "label"), r = Fn(e, "uncheckedValue"), s = Fn(e, "keepValue"), { errors: i, value: u, errorMessage: d, validate: c, handleChange: f, handleBlur: p, setTouched: v, resetField: m, handleReset: h, meta: _, checked: x, setErrors: S, setValue: $ } = Qz(a, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: r9(e, t),
      // Only for checkboxes and radio buttons
      checkedValue: t.attrs.value,
      uncheckedValue: r,
      label: o,
      validateOnValueUpdate: e.validateOnModelUpdate,
      keepValueOnUnmount: s,
      syncVModel: !0
    }), D = function(P, q = !0) {
      f(P, q);
    }, B = E(() => {
      const { validateOnInput: T, validateOnChange: P, validateOnBlur: q, validateOnModelUpdate: R } = o9(e);
      function Q(j) {
        p(j, q), Wt(t.attrs.onBlur) && t.attrs.onBlur(j);
      }
      function ee(j) {
        D(j, T), Wt(t.attrs.onInput) && t.attrs.onInput(j);
      }
      function K(j) {
        D(j, P), Wt(t.attrs.onChange) && t.attrs.onChange(j);
      }
      const W = {
        name: e.name,
        onBlur: Q,
        onInput: ee,
        onChange: K
      };
      return W["onUpdate:modelValue"] = (j) => D(j, R), W;
    }), k = E(() => {
      const T = Object.assign({}, B.value);
      rl(t.attrs.type) && x && (T.checked = x.value);
      const P = og(e, t);
      return xz(P, t.attrs) && (T.value = u.value), T;
    }), M = E(() => Object.assign(Object.assign({}, B.value), { modelValue: u.value }));
    function I() {
      return {
        field: k.value,
        componentField: M.value,
        value: u.value,
        meta: _,
        errors: i.value,
        errorMessage: d.value,
        validate: c,
        resetField: m,
        handleChange: D,
        handleInput: (T) => D(T, !1),
        handleReset: h,
        handleBlur: B.value.onBlur,
        setTouched: v,
        setErrors: S,
        setValue: $
      };
    }
    return t.expose({
      value: u,
      meta: _,
      errors: i,
      errorMessage: d,
      setErrors: S,
      setTouched: v,
      setValue: $,
      reset: m,
      validate: c,
      handleChange: f
    }), () => {
      const T = mt(og(e, t)), P = Yu(T, t, I);
      return T ? Bt(T, Object.assign(Object.assign({}, t.attrs), k.value), P) : P;
    };
  }
});
function og(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function o9(e) {
  var t, n, a, o;
  const { validateOnInput: r, validateOnChange: s, validateOnBlur: i, validateOnModelUpdate: u } = vo();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : r,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : s,
    validateOnBlur: (a = e.validateOnBlur) !== null && a !== void 0 ? a : i,
    validateOnModelUpdate: (o = e.validateOnModelUpdate) !== null && o !== void 0 ? o : u
  };
}
function r9(e, t) {
  return rl(t.attrs.type) ? Yh(e, "modelValue") ? e.modelValue : void 0 : Yh(e, "modelValue") ? e.modelValue : t.attrs.value;
}
const cK = a9;
let s9 = 0;
const Al = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function Jw(e) {
  const t = (e == null ? void 0 : e.initialValues) || {}, n = Object.assign({}, me(t)), a = l(e == null ? void 0 : e.validationSchema);
  return a && Ln(a) && Wt(a.cast) ? Xe(a.cast(n) || {}) : Xe(n);
}
function l9(e) {
  var t;
  const n = s9++, a = (e == null ? void 0 : e.name) || "Form";
  let o = 0;
  const r = O(!1), s = O(!1), i = O(0), u = [], d = Qt(Jw(e)), c = O([]), f = O({}), p = O({}), v = Bz(() => {
    p.value = c.value.reduce((G, X) => (G[as(me(X.path))] = X, G), {});
  });
  function m(G, X) {
    const de = j(G);
    if (!de) {
      typeof G == "string" && (f.value[as(G)] = Kc(X));
      return;
    }
    if (typeof G == "string") {
      const ge = as(G);
      f.value[ge] && delete f.value[ge];
    }
    de.errors = Kc(X), de.valid = !de.errors.length;
  }
  function h(G) {
    ln(G).forEach((X) => {
      m(X, G[X]);
    });
  }
  e != null && e.initialErrors && h(e.initialErrors);
  const _ = E(() => {
    const G = c.value.reduce((X, de) => (de.errors.length && (X[me(de.path)] = de.errors), X), {});
    return Object.assign(Object.assign({}, f.value), G);
  }), x = E(() => ln(_.value).reduce((G, X) => {
    const de = _.value[X];
    return de != null && de.length && (G[X] = de[0]), G;
  }, {})), S = E(() => c.value.reduce((G, X) => (G[me(X.path)] = { name: me(X.path) || "", label: X.label || "" }, G), {})), $ = E(() => c.value.reduce((G, X) => {
    var de;
    return G[me(X.path)] = (de = X.bails) !== null && de !== void 0 ? de : !0, G;
  }, {})), D = Object.assign({}, (e == null ? void 0 : e.initialErrors) || {}), B = (t = e == null ? void 0 : e.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: k, originalInitialValues: M, setInitialValues: I } = u9(c, d, e), T = i9(c, d, M, x), P = E(() => c.value.reduce((G, X) => {
    const de = xt(d, me(X.path));
    return Lt(G, me(X.path), de), G;
  }, {})), q = e == null ? void 0 : e.validationSchema;
  function R(G, X) {
    var de, ge;
    const ke = E(() => xt(k.value, me(G))), Ie = p.value[me(G)], Oe = (X == null ? void 0 : X.type) === "checkbox" || (X == null ? void 0 : X.type) === "radio";
    if (Ie && Oe) {
      Ie.multiple = !0;
      const sn = o++;
      return Array.isArray(Ie.id) ? Ie.id.push(sn) : Ie.id = [Ie.id, sn], Ie.fieldsCount++, Ie.__flags.pendingUnmount[sn] = !1, Ie;
    }
    const et = E(() => xt(d, me(G))), _t = me(G), Ft = z.findIndex((sn) => sn === _t);
    Ft !== -1 && z.splice(Ft, 1);
    const ut = E(() => {
      var sn, Ia, qo, Rr;
      const Zu = me(q);
      if (Ln(Zu))
        return (Ia = (sn = Zu.describe) === null || sn === void 0 ? void 0 : sn.call(Zu, me(G)).required) !== null && Ia !== void 0 ? Ia : !1;
      const Qu = me(X == null ? void 0 : X.schema);
      return Ln(Qu) && (Rr = (qo = Qu.describe) === null || qo === void 0 ? void 0 : qo.call(Qu).required) !== null && Rr !== void 0 ? Rr : !1;
    }), Tt = o++, Ut = Qt({
      id: Tt,
      path: G,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((de = D[_t]) === null || de === void 0) && de.length),
      required: ut,
      initialValue: ke,
      errors: Zt([]),
      bails: (ge = X == null ? void 0 : X.bails) !== null && ge !== void 0 ? ge : !1,
      label: X == null ? void 0 : X.label,
      type: (X == null ? void 0 : X.type) || "default",
      value: et,
      multiple: !1,
      __flags: {
        pendingUnmount: { [Tt]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: X == null ? void 0 : X.validate,
      dirty: E(() => !zt(l(et), l(ke)))
    });
    return c.value.push(Ut), p.value[_t] = Ut, v(), x.value[_t] && !D[_t] && he(() => {
      je(_t, { mode: "silent" });
    }), ht(G) && ce(G, (sn) => {
      v();
      const Ia = Xe(et.value);
      p.value[sn] = Ut, he(() => {
        Lt(d, sn, Ia);
      });
    }), Ut;
  }
  const Q = eg(St, 5), ee = eg(St, 5), K = Wc(async (G) => await (G === "silent" ? Q() : ee()), (G, [X]) => {
    const de = ln(V.errorBag.value), ke = [
      .../* @__PURE__ */ new Set([...ln(G.results), ...c.value.map((Ie) => Ie.path), ...de])
    ].sort().reduce((Ie, Oe) => {
      var et;
      const _t = Oe, Ft = j(_t) || J(_t), ut = ((et = G.results[_t]) === null || et === void 0 ? void 0 : et.errors) || [], Tt = me(Ft == null ? void 0 : Ft.path) || _t, Ut = d9({ errors: ut, valid: !ut.length }, Ie.results[Tt]);
      return Ie.results[Tt] = Ut, Ut.valid || (Ie.errors[Tt] = Ut.errors[0]), Ft && f.value[Tt] && delete f.value[Tt], Ft ? (Ft.valid = Ut.valid, X === "silent" || X === "validated-only" && !Ft.validated || m(Ft, Ut.errors), Ie) : (m(Tt, ut), Ie);
    }, {
      valid: G.valid,
      results: {},
      errors: {},
      source: G.source
    });
    return G.values && (ke.values = G.values, ke.source = G.source), ln(ke.results).forEach((Ie) => {
      var Oe;
      const et = j(Ie);
      et && X !== "silent" && (X === "validated-only" && !et.validated || m(et, (Oe = ke.results[Ie]) === null || Oe === void 0 ? void 0 : Oe.errors));
    }), ke;
  });
  function W(G) {
    c.value.forEach(G);
  }
  function j(G) {
    const X = typeof G == "string" ? as(G) : G;
    return typeof X == "string" ? p.value[X] : X;
  }
  function J(G) {
    return c.value.filter((de) => G.startsWith(me(de.path))).reduce((de, ge) => de ? ge.path.length > de.path.length ? ge : de : ge, void 0);
  }
  let z = [], Y;
  function Z(G) {
    return z.push(G), Y || (Y = he(() => {
      [...z].sort().reverse().forEach((de) => {
        Zh(d, de);
      }), z = [], Y = null;
    })), Y;
  }
  function pe(G) {
    return function(de, ge) {
      return function(Ie) {
        return Ie instanceof Event && (Ie.preventDefault(), Ie.stopPropagation()), W((Oe) => Oe.touched = !0), r.value = !0, i.value++, ze().then((Oe) => {
          const et = Xe(d);
          if (Oe.valid && typeof de == "function") {
            const _t = Xe(P.value);
            let Ft = G ? _t : et;
            return Oe.values && (Ft = Oe.source === "schema" ? Oe.values : Object.assign({}, Ft, Oe.values)), de(Ft, {
              evt: Ie,
              controlledValues: _t,
              setErrors: h,
              setFieldError: m,
              setTouched: Ne,
              setFieldTouched: L,
              setValues: re,
              setFieldValue: te,
              resetForm: xe,
              resetField: Je
            });
          }
          !Oe.valid && typeof ge == "function" && ge({
            values: et,
            evt: Ie,
            errors: Oe.errors,
            results: Oe.results
          });
        }).then((Oe) => (r.value = !1, Oe), (Oe) => {
          throw r.value = !1, Oe;
        });
      };
    };
  }
  const Ce = pe(!1);
  Ce.withControlled = pe(!0);
  function De(G, X) {
    const de = c.value.findIndex((ke) => ke.path === G && (Array.isArray(ke.id) ? ke.id.includes(X) : ke.id === X)), ge = c.value[de];
    if (!(de === -1 || !ge)) {
      if (he(() => {
        je(G, { mode: "silent", warn: !1 });
      }), ge.multiple && ge.fieldsCount && ge.fieldsCount--, Array.isArray(ge.id)) {
        const ke = ge.id.indexOf(X);
        ke >= 0 && ge.id.splice(ke, 1), delete ge.__flags.pendingUnmount[X];
      }
      (!ge.multiple || ge.fieldsCount <= 0) && (c.value.splice(de, 1), Ke(G), v(), delete p.value[G]);
    }
  }
  function ue(G) {
    ln(p.value).forEach((X) => {
      X.startsWith(G) && delete p.value[X];
    }), c.value = c.value.filter((X) => !X.path.startsWith(G)), he(() => {
      v();
    });
  }
  const V = {
    name: a,
    formId: n,
    values: d,
    controlledValues: P,
    errorBag: _,
    errors: x,
    schema: q,
    submitCount: i,
    meta: T,
    isSubmitting: r,
    isValidating: s,
    fieldArrays: u,
    keepValuesOnUnmount: B,
    validateSchema: l(q) ? K : void 0,
    validate: ze,
    setFieldError: m,
    validateField: je,
    setFieldValue: te,
    setValues: re,
    setErrors: h,
    setFieldTouched: L,
    setTouched: Ne,
    resetForm: xe,
    resetField: Je,
    handleSubmit: Ce,
    useFieldModel: Ae,
    defineInputBinds: st,
    defineComponentBinds: dt,
    defineField: an,
    stageInitialValue: lt,
    unsetInitialValue: Ke,
    setFieldInitialValue: it,
    createPathState: R,
    getPathState: j,
    unsetPathValue: Z,
    removePathState: De,
    initialValues: k,
    getAllPathStates: () => c.value,
    destroyPath: ue,
    isFieldTouched: _e,
    isFieldDirty: we,
    isFieldValid: Te
  };
  function te(G, X, de = !0) {
    const ge = Xe(X), ke = typeof G == "string" ? G : G.path;
    j(ke) || R(ke), Lt(d, ke, ge), de && je(ke);
  }
  function H(G, X = !0) {
    ln(d).forEach((de) => {
      delete d[de];
    }), ln(G).forEach((de) => {
      te(de, G[de], !1);
    }), X && ze();
  }
  function re(G, X = !0) {
    Ts(d, G), u.forEach((de) => de && de.reset()), X && ze();
  }
  function ie(G, X) {
    const de = j(me(G)) || R(G);
    return E({
      get() {
        return de.value;
      },
      set(ge) {
        var ke;
        const Ie = me(G);
        te(Ie, ge, (ke = me(X)) !== null && ke !== void 0 ? ke : !1);
      }
    });
  }
  function L(G, X) {
    const de = j(G);
    de && (de.touched = X);
  }
  function _e(G) {
    const X = j(G);
    return X ? X.touched : c.value.filter((de) => de.path.startsWith(G)).some((de) => de.touched);
  }
  function we(G) {
    const X = j(G);
    return X ? X.dirty : c.value.filter((de) => de.path.startsWith(G)).some((de) => de.dirty);
  }
  function Te(G) {
    const X = j(G);
    return X ? X.valid : c.value.filter((de) => de.path.startsWith(G)).every((de) => de.valid);
  }
  function Ne(G) {
    if (typeof G == "boolean") {
      W((X) => {
        X.touched = G;
      });
      return;
    }
    ln(G).forEach((X) => {
      L(X, !!G[X]);
    });
  }
  function Je(G, X) {
    var de;
    const ge = X && "value" in X ? X.value : xt(k.value, G), ke = j(G);
    ke && (ke.__flags.pendingReset = !0), it(G, Xe(ge), !0), te(G, ge, !1), L(G, (de = X == null ? void 0 : X.touched) !== null && de !== void 0 ? de : !1), m(G, (X == null ? void 0 : X.errors) || []), he(() => {
      ke && (ke.__flags.pendingReset = !1);
    });
  }
  function xe(G, X) {
    let de = Xe(G != null && G.values ? G.values : M.value);
    de = X != null && X.force ? de : Ts(M.value, de), de = Ln(q) && Wt(q.cast) ? q.cast(de) : de, I(de, { force: X == null ? void 0 : X.force }), W((ge) => {
      var ke;
      ge.__flags.pendingReset = !0, ge.validated = !1, ge.touched = ((ke = G == null ? void 0 : G.touched) === null || ke === void 0 ? void 0 : ke[me(ge.path)]) || !1, te(me(ge.path), xt(de, me(ge.path)), !1), m(me(ge.path), void 0);
    }), X != null && X.force ? H(de, !1) : re(de, !1), h((G == null ? void 0 : G.errors) || {}), i.value = (G == null ? void 0 : G.submitCount) || 0, he(() => {
      ze({ mode: "silent" }), W((ge) => {
        ge.__flags.pendingReset = !1;
      });
    });
  }
  async function ze(G) {
    const X = (G == null ? void 0 : G.mode) || "force";
    if (X === "force" && W((Oe) => Oe.validated = !0), V.validateSchema)
      return V.validateSchema(X);
    s.value = !0;
    const de = await Promise.all(c.value.map((Oe) => Oe.validate ? Oe.validate(G).then((et) => ({
      key: me(Oe.path),
      valid: et.valid,
      errors: et.errors,
      value: et.value
    })) : Promise.resolve({
      key: me(Oe.path),
      valid: !0,
      errors: [],
      value: void 0
    })));
    s.value = !1;
    const ge = {}, ke = {}, Ie = {};
    for (const Oe of de)
      ge[Oe.key] = {
        valid: Oe.valid,
        errors: Oe.errors
      }, Oe.value && Lt(Ie, Oe.key, Oe.value), Oe.errors.length && (ke[Oe.key] = Oe.errors[0]);
    return {
      valid: de.every((Oe) => Oe.valid),
      results: ge,
      errors: ke,
      values: Ie,
      source: "fields"
    };
  }
  async function je(G, X) {
    var de;
    const ge = j(G);
    if (ge && (X == null ? void 0 : X.mode) !== "silent" && (ge.validated = !0), q) {
      const { results: Ie } = await K((X == null ? void 0 : X.mode) || "validated-only");
      return Ie[G] || { errors: [], valid: !0 };
    }
    return ge != null && ge.validate ? ge.validate(X) : (!ge && ((de = X == null ? void 0 : X.warn) !== null && de !== void 0 ? de : !0) && process.env.NODE_ENV !== "production" && vg(`field with path ${G} was not found`), Promise.resolve({ errors: [], valid: !0 }));
  }
  function Ke(G) {
    Zh(k.value, G);
  }
  function lt(G, X, de = !1) {
    it(G, X), Lt(d, G, X), de && !(e != null && e.initialValues) && Lt(M.value, G, Xe(X));
  }
  function it(G, X, de = !1) {
    Lt(k.value, G, Xe(X)), de && Lt(M.value, G, Xe(X));
  }
  async function St() {
    const G = l(q);
    if (!G)
      return { valid: !0, results: {}, errors: {}, source: "none" };
    s.value = !0;
    const X = Hi(G) || Ln(G) ? await Vz(G, d) : await Nz(G, d, {
      names: S.value,
      bailsMap: $.value
    });
    return s.value = !1, X;
  }
  const Xt = Ce((G, { evt: X }) => {
    Lw(X) && X.target.submit();
  });
  be(() => {
    if (e != null && e.initialErrors && h(e.initialErrors), e != null && e.initialTouched && Ne(e.initialTouched), e != null && e.validateOnMount) {
      ze();
      return;
    }
    V.validateSchema && V.validateSchema("silent");
  }), ht(q) && ce(q, () => {
    var G;
    (G = V.validateSchema) === null || G === void 0 || G.call(V, "validated-only");
  }), Mn(ol, V), process.env.NODE_ENV !== "production" && (Wz(V), ce(() => Object.assign(Object.assign({ errors: _.value }, T.value), { values: d, isSubmitting: r.value, isValidating: s.value, submitCount: i.value }), yr, {
    deep: !0
  }));
  function an(G, X) {
    const de = Wt(X) || X == null ? void 0 : X.label, ge = j(me(G)) || R(G, { label: de }), ke = () => Wt(X) ? X(Tl(ge, Al)) : X || {};
    function Ie() {
      var ut;
      ge.touched = !0, ((ut = ke().validateOnBlur) !== null && ut !== void 0 ? ut : vo().validateOnBlur) && je(me(ge.path));
    }
    function Oe() {
      var ut;
      ((ut = ke().validateOnInput) !== null && ut !== void 0 ? ut : vo().validateOnInput) && he(() => {
        je(me(ge.path));
      });
    }
    function et() {
      var ut;
      ((ut = ke().validateOnChange) !== null && ut !== void 0 ? ut : vo().validateOnChange) && he(() => {
        je(me(ge.path));
      });
    }
    const _t = E(() => {
      const ut = {
        onChange: et,
        onInput: Oe,
        onBlur: Ie
      };
      return Wt(X) ? Object.assign(Object.assign({}, ut), X(Tl(ge, Al)).props || {}) : X != null && X.props ? Object.assign(Object.assign({}, ut), X.props(Tl(ge, Al))) : ut;
    });
    return [ie(G, () => {
      var ut, Tt, Ut;
      return (Ut = (ut = ke().validateOnModelUpdate) !== null && ut !== void 0 ? ut : (Tt = vo()) === null || Tt === void 0 ? void 0 : Tt.validateOnModelUpdate) !== null && Ut !== void 0 ? Ut : !0;
    }), _t];
  }
  function Ae(G) {
    return Array.isArray(G) ? G.map((X) => ie(X, !0)) : ie(G);
  }
  function st(G, X) {
    const [de, ge] = an(G, X);
    function ke() {
      ge.value.onBlur();
    }
    function Ie(et) {
      const _t = Ui(et);
      te(me(G), _t, !1), ge.value.onInput();
    }
    function Oe(et) {
      const _t = Ui(et);
      te(me(G), _t, !1), ge.value.onChange();
    }
    return E(() => Object.assign(Object.assign({}, ge.value), {
      onBlur: ke,
      onInput: Ie,
      onChange: Oe,
      value: de.value
    }));
  }
  function dt(G, X) {
    const [de, ge] = an(G, X), ke = j(me(G));
    function Ie(Oe) {
      de.value = Oe;
    }
    return E(() => {
      const Oe = Wt(X) ? X(Tl(ke, Al)) : X || {};
      return Object.assign({ [Oe.model || "modelValue"]: de.value, [`onUpdate:${Oe.model || "modelValue"}`]: Ie }, ge.value);
    });
  }
  const bt = Object.assign(Object.assign({}, V), { values: Oa(d), handleReset: () => xe(), submitForm: Xt });
  return Mn(gz, bt), bt;
}
function i9(e, t, n, a) {
  const o = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, r = E(() => !zt(t, l(n)));
  function s() {
    const u = e.value;
    return ln(o).reduce((d, c) => {
      const f = o[c];
      return d[c] = u[f]((p) => p[c]), d;
    }, {});
  }
  const i = Qt(s());
  return Me(() => {
    const u = s();
    i.touched = u.touched, i.valid = u.valid, i.pending = u.pending;
  }), E(() => Object.assign(Object.assign({ initialValues: l(n) }, i), { valid: i.valid && !ln(a.value).length, dirty: r.value }));
}
function u9(e, t, n) {
  const a = Jw(n), o = O(a), r = O(Xe(a));
  function s(i, u) {
    u != null && u.force ? (o.value = Xe(i), r.value = Xe(i)) : (o.value = Ts(Xe(o.value) || {}, Xe(i)), r.value = Ts(Xe(r.value) || {}, Xe(i))), u != null && u.updateFields && e.value.forEach((d) => {
      if (d.touched)
        return;
      const f = xt(o.value, me(d.path));
      Lt(t, me(d.path), Xe(f));
    });
  }
  return {
    initialValues: o,
    originalInitialValues: r,
    setInitialValues: s
  };
}
function d9(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const c9 = /* @__PURE__ */ b({
  name: "Form",
  inheritAttrs: !1,
  props: {
    as: {
      type: null,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: "Form"
    }
  },
  setup(e, t) {
    const n = Fn(e, "validationSchema"), a = Fn(e, "keepValues"), { errors: o, errorBag: r, values: s, meta: i, isSubmitting: u, isValidating: d, submitCount: c, controlledValues: f, validate: p, validateField: v, handleReset: m, resetForm: h, handleSubmit: _, setErrors: x, setFieldError: S, setFieldValue: $, setValues: D, setFieldTouched: B, setTouched: k, resetField: M } = l9({
      validationSchema: n.value ? n : void 0,
      initialValues: e.initialValues,
      initialErrors: e.initialErrors,
      initialTouched: e.initialTouched,
      validateOnMount: e.validateOnMount,
      keepValuesOnUnmount: a,
      name: e.name
    }), I = _((W, { evt: j }) => {
      Lw(j) && j.target.submit();
    }, e.onInvalidSubmit), T = e.onSubmit ? _(e.onSubmit, e.onInvalidSubmit) : I;
    function P(W) {
      dv(W) && W.preventDefault(), m(), typeof t.attrs.onReset == "function" && t.attrs.onReset();
    }
    function q(W, j) {
      return _(typeof W == "function" && !j ? W : j, e.onInvalidSubmit)(W);
    }
    function R() {
      return Xe(s);
    }
    function Q() {
      return Xe(i.value);
    }
    function ee() {
      return Xe(o.value);
    }
    function K() {
      return {
        meta: i.value,
        errors: o.value,
        errorBag: r.value,
        values: s,
        isSubmitting: u.value,
        isValidating: d.value,
        submitCount: c.value,
        controlledValues: f.value,
        validate: p,
        validateField: v,
        handleSubmit: q,
        handleReset: m,
        submitForm: I,
        setErrors: x,
        setFieldError: S,
        setFieldValue: $,
        setValues: D,
        setFieldTouched: B,
        setTouched: k,
        resetForm: h,
        resetField: M,
        getValues: R,
        getMeta: Q,
        getErrors: ee
      };
    }
    return t.expose({
      setFieldError: S,
      setErrors: x,
      setFieldValue: $,
      setValues: D,
      setFieldTouched: B,
      setTouched: k,
      resetForm: h,
      validate: p,
      validateField: v,
      resetField: M,
      getValues: R,
      getMeta: Q,
      getErrors: ee,
      values: s,
      meta: i,
      errors: o
    }), function() {
      const j = e.as === "form" ? e.as : e.as ? mt(e.as) : null, J = Yu(j, t, K);
      return j ? Bt(j, Object.assign(Object.assign(Object.assign({}, j === "form" ? {
        // Disables native validation as vee-validate will handle it.
        novalidate: !0
      } : {}), t.attrs), { onSubmit: T, onReset: P }), J) : J;
    };
  }
}), fK = c9;
function f9(e) {
  const t = fv(ol, void 0), n = O([]), a = () => {
  }, o = {
    fields: n,
    remove: a,
    push: a,
    swap: a,
    insert: a,
    update: a,
    replace: a,
    prepend: a,
    move: a
  };
  if (!t)
    return process.env.NODE_ENV !== "production" && Ld("FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly"), o;
  if (!l(e))
    return process.env.NODE_ENV !== "production" && Ld("FieldArray requires a field path to be provided, did you forget to pass the `name` prop?"), o;
  const r = t.fieldArrays.find((B) => l(B.path) === l(e));
  if (r)
    return r;
  let s = 0;
  function i() {
    return xt(t == null ? void 0 : t.values, me(e), []) || [];
  }
  function u() {
    const B = i();
    Array.isArray(B) && (n.value = B.map((k, M) => c(k, M, n.value)), d());
  }
  u();
  function d() {
    const B = n.value.length;
    for (let k = 0; k < B; k++) {
      const M = n.value[k];
      M.isFirst = k === 0, M.isLast = k === B - 1;
    }
  }
  function c(B, k, M) {
    if (M && !Go(k) && M[k])
      return M[k];
    const I = s++;
    return {
      key: I,
      value: $z({
        get() {
          const P = xt(t == null ? void 0 : t.values, me(e), []) || [], q = n.value.findIndex((R) => R.key === I);
          return q === -1 ? B : P[q];
        },
        set(P) {
          const q = n.value.findIndex((R) => R.key === I);
          if (q === -1) {
            process.env.NODE_ENV !== "production" && Ld("Attempting to update a non-existent array item");
            return;
          }
          x(q, P);
        }
      }),
      // will be auto unwrapped
      isFirst: !1,
      isLast: !1
    };
  }
  function f() {
    d(), t == null || t.validate({ mode: "silent" });
  }
  function p(B) {
    const k = me(e), M = xt(t == null ? void 0 : t.values, k);
    if (!M || !Array.isArray(M))
      return;
    const I = [...M];
    I.splice(B, 1);
    const T = k + `[${B}]`;
    t.destroyPath(T), t.unsetInitialValue(T), Lt(t.values, k, I), n.value.splice(B, 1), f();
  }
  function v(B) {
    const k = Xe(B), M = me(e), I = xt(t == null ? void 0 : t.values, M), T = Go(I) ? [] : I;
    if (!Array.isArray(T))
      return;
    const P = [...T];
    P.push(k), t.stageInitialValue(M + `[${P.length - 1}]`, k), Lt(t.values, M, P), n.value.push(c(k)), f();
  }
  function m(B, k) {
    const M = me(e), I = xt(t == null ? void 0 : t.values, M);
    if (!Array.isArray(I) || !(B in I) || !(k in I))
      return;
    const T = [...I], P = [...n.value], q = T[B];
    T[B] = T[k], T[k] = q;
    const R = P[B];
    P[B] = P[k], P[k] = R, Lt(t.values, M, T), n.value = P, d();
  }
  function h(B, k) {
    const M = Xe(k), I = me(e), T = xt(t == null ? void 0 : t.values, I);
    if (!Array.isArray(T) || T.length < B)
      return;
    const P = [...T], q = [...n.value];
    P.splice(B, 0, M), q.splice(B, 0, c(M)), Lt(t.values, I, P), n.value = q, f();
  }
  function _(B) {
    const k = me(e);
    t.stageInitialValue(k, B), Lt(t.values, k, B), u(), f();
  }
  function x(B, k) {
    const M = me(e), I = xt(t == null ? void 0 : t.values, M);
    !Array.isArray(I) || I.length - 1 < B || (Lt(t.values, `${M}[${B}]`, k), t == null || t.validate({ mode: "validated-only" }));
  }
  function S(B) {
    const k = Xe(B), M = me(e), I = xt(t == null ? void 0 : t.values, M), T = Go(I) ? [] : I;
    if (!Array.isArray(T))
      return;
    const P = [k, ...T];
    Lt(t.values, M, P), t.stageInitialValue(M + "[0]", k), n.value.unshift(c(k)), f();
  }
  function $(B, k) {
    const M = me(e), I = xt(t == null ? void 0 : t.values, M), T = Go(I) ? [] : [...I];
    if (!Array.isArray(I) || !(B in I) || !(k in I))
      return;
    const P = [...n.value], q = P[B];
    P.splice(B, 1), P.splice(k, 0, q);
    const R = T[B];
    T.splice(B, 1), T.splice(k, 0, R), Lt(t.values, M, T), n.value = P, f();
  }
  const D = {
    fields: n,
    remove: p,
    push: v,
    swap: m,
    insert: h,
    update: x,
    replace: _,
    prepend: S,
    move: $
  };
  return t.fieldArrays.push(Object.assign({ path: e, reset: u }, D)), ka(() => {
    const B = t.fieldArrays.findIndex((k) => me(k.path) === me(e));
    B >= 0 && t.fieldArrays.splice(B, 1);
  }), ce(i, (B) => {
    const k = n.value.map((M) => M.value);
    zt(B, k) || u();
  }), D;
}
const p9 = /* @__PURE__ */ b({
  name: "FieldArray",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const { push: n, remove: a, swap: o, insert: r, replace: s, update: i, prepend: u, move: d, fields: c } = f9(() => e.name);
    function f() {
      return {
        fields: c.value,
        push: n,
        remove: a,
        swap: o,
        insert: r,
        update: i,
        replace: s,
        prepend: u,
        move: d
      };
    }
    return t.expose({
      push: n,
      remove: a,
      swap: o,
      insert: r,
      update: i,
      replace: s,
      prepend: u,
      move: d
    }), () => Yu(void 0, t, f);
  }
}), pK = p9, v9 = /* @__PURE__ */ b({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const n = vn(ol, void 0), a = E(() => n == null ? void 0 : n.errors.value[e.name]);
    function o() {
      return {
        message: a.value
      };
    }
    return () => {
      if (!a.value)
        return;
      const r = e.as ? mt(e.as) : e.as, s = Yu(r, t, o), i = Object.assign({ role: "alert" }, t.attrs);
      return !r && (Array.isArray(s) || !s) && (s != null && s.length) ? s : (Array.isArray(s) || !s) && !(s != null && s.length) ? Bt(r || "span", i, a.value) : Bt(r, i, s);
    };
  }
}), m9 = v9, Zw = Symbol();
function Xu() {
  const e = vn(Fw), t = vn(Zw);
  if (!e) throw new Error("useFormField should be used within <FormField>");
  const { name: n, errorMessage: a, meta: o } = e, r = t, s = {
    valid: E(() => o.valid),
    isDirty: E(() => o.dirty),
    isTouched: E(() => o.touched),
    error: a
  };
  return {
    id: r,
    name: n,
    formItemId: `${r}-form-item`,
    formDescriptionId: `${r}-form-item-description`,
    formMessageId: `${r}-form-item-message`,
    ...s
  };
}
const vK = /* @__PURE__ */ b({
  __name: "FormControl",
  setup(e) {
    const { error: t, formItemId: n, formDescriptionId: a, formMessageId: o } = Xu();
    return (r, s) => (g(), C(l(vi), {
      id: l(n),
      "aria-describedby": l(t) ? `${l(a)} ${l(o)}` : `${l(a)}`,
      "aria-invalid": !!l(t)
    }, {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "aria-describedby", "aria-invalid"]));
  }
}), h9 = ["id"], mK = /* @__PURE__ */ b({
  __name: "FormDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { formDescriptionId: n } = Xu();
    return (a, o) => (g(), U("p", {
      id: l(n),
      class: ae(l(F)("text-sm text-muted-foreground", t.class))
    }, [
      w(a.$slots, "default")
    ], 10, h9));
  }
}), hK = /* @__PURE__ */ b({
  __name: "FormItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = yt();
    return Mn(Zw, n), (a, o) => (g(), U("div", {
      class: ae(l(F)("space-y-2", t.class))
    }, [
      w(a.$slots, "default")
    ], 2));
  }
}), gK = /* @__PURE__ */ b({
  __name: "FormLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, { error: n, formItemId: a } = Xu();
    return (o, r) => (g(), C(l(qw), {
      class: ae(l(F)(l(n) && "text-destructive", t.class)),
      for: l(a)
    }, {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "for"]));
  }
}), yK = /* @__PURE__ */ b({
  __name: "FormMessage",
  setup(e) {
    const { name: t, formMessageId: n } = Xu();
    return (a, o) => (g(), C(l(m9), {
      id: l(n),
      as: "p",
      name: me(l(t)),
      class: "text-[0.8rem] font-medium text-destructive"
    }, null, 8, ["id", "name"]));
  }
}), bK = /* @__PURE__ */ b({
  __name: "HoverCard",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    openDelay: {},
    closeDelay: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(oT), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _K = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(cT), null, {
      default: y(() => [
        N(l(uT), A(l(a), {
          class: l(F)(
            "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            w(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), wK = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(pT), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qw = /* @__PURE__ */ b({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = Kf(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (r, s) => br((g(), U("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => ht(o) ? o.value = i : null),
      class: ae(
        l(F)(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          n.class
        )
      )
    }, null, 2)), [
      [mg, l(o)]
    ]);
  }
}), xK = /* @__PURE__ */ b({
  __name: "InputGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "input-group",
      role: "group",
      class: ae(
        l(F)(
          "group/input-group relative flex w-full items-center rounded-md border border-input outline-none dark:bg-input/30",
          "h-9 min-w-0 has-[>textarea]:h-auto",
          // Variants based on alignment.
          "has-[>[data-align=inline-start]]:[&>input]:pl-2",
          "has-[>[data-align=inline-end]]:[&>input]:pr-2",
          "has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3",
          "has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3",
          // Focus state.
          "has-[[data-slot=input-group-control]:focus-visible]:ring-1 has-[[data-slot=input-group-control]:focus-visible]:ring-ring",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), g9 = ["data-align"], CK = /* @__PURE__ */ b({
  __name: "InputGroupAddon",
  props: {
    align: { default: "inline-start" },
    class: {}
  },
  setup(e) {
    const t = e;
    function n(a) {
      var s, i;
      const o = a.currentTarget, r = a.target;
      r && r.closest("button") || o && (o != null && o.parentElement) && ((i = (s = o.parentElement) == null ? void 0 : s.querySelector("input")) == null || i.focus());
    }
    return (a, o) => (g(), U("div", {
      role: "group",
      "data-slot": "input-group-addon",
      "data-align": t.align,
      class: ae(l(F)(l(b9)({ align: t.align }), t.class)),
      onClick: n
    }, [
      w(a.$slots, "default")
    ], 10, g9));
  }
}), SK = /* @__PURE__ */ b({
  __name: "InputGroupButton",
  props: {
    variant: { default: "ghost" },
    size: { default: "xs" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Eu), {
      "data-size": t.size,
      variant: t.variant,
      class: ae(l(F)(l(_9)({ size: t.size }), t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-size", "variant", "class"]));
  }
}), $K = /* @__PURE__ */ b({
  __name: "InputGroupInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Qw), {
      "data-slot": "input-group-control",
      class: ae(
        l(F)(
          "flex-1 rounded-none border-0 bg-transparent ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), BK = /* @__PURE__ */ b({
  __name: "InputGroupText",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("span", {
      class: ae(
        l(F)(
          "flex items-center gap-2 text-sm text-muted-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), y9 = /* @__PURE__ */ b({
  __name: "Textarea",
  props: {
    class: {},
    defaultValue: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = Kf(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (r, s) => br((g(), U("textarea", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => ht(o) ? o.value = i : null),
      class: ae(
        l(F)(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          n.class
        )
      )
    }, null, 2)), [
      [mg, l(o)]
    ]);
  }
}), PK = /* @__PURE__ */ b({
  __name: "InputGroupTextarea",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(y9), {
      "data-slot": "input-group-control",
      class: ae(
        l(F)(
          "flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), b9 = en(
  "flex h-auto cursor-text select-none items-center justify-center gap-2 py-1.5 text-sm font-medium text-muted-foreground group-data-[disabled=true]/input-group:opacity-50 [&>kbd]:rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-4",
  {
    variants: {
      align: {
        "inline-start": "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
        "inline-end": "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
        "block-start": "[.border-b]:pb-3 order-first w-full justify-start px-3 pt-3 group-has-[>input]/input-group:pt-2.5",
        "block-end": "[.border-t]:pt-3 order-last w-full justify-start px-3 pb-3 group-has-[>input]/input-group:pb-2.5"
      }
    },
    defaultVariants: {
      align: "inline-start"
    }
  }
), _9 = en("flex items-center gap-2 text-sm shadow-none", {
  variants: {
    size: {
      xs: "h-6 gap-1 rounded-[calc(var(--radius)-5px)] px-2 has-[>svg]:px-2 [&>svg:not([class*='size-'])]:size-3.5",
      sm: "h-8 gap-1.5 rounded-md px-2.5 has-[>svg]:px-2.5",
      "icon-xs": "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
      "icon-sm": "size-8 p-0 has-[>svg]:p-0"
    }
  },
  defaultVariants: {
    size: "xs"
  }
});
function w9(e) {
  return As() ? (Is(e), !0) : !1;
}
function x9(e) {
  if (!ht(e))
    return Qt(e);
  const t = new Proxy({}, {
    get(n, a, o) {
      return l(Reflect.get(e.value, a, o));
    },
    set(n, a, o) {
      return ht(e.value[a]) && !ht(o) ? e.value[a].value = o : e.value[a] = o, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Qt(t);
}
function C9(e) {
  return x9(E(e));
}
function S9(e, ...t) {
  const n = t.flat(), a = n[0];
  return C9(() => Object.fromEntries(typeof a == "function" ? Object.entries(Be(e)).filter(([o, r]) => !a(me(r), o)) : Object.entries(Be(e)).filter((o) => !n.includes(o[0]))));
}
const e1 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const $9 = Object.prototype.toString, B9 = (e) => $9.call(e) === "[object Object]", P9 = () => {
};
function Hd(e) {
  return Array.isArray(e) ? e : [e];
}
function E9(...e) {
  if (e.length !== 1)
    return Fn(...e);
  const t = e[0];
  return typeof t == "function" ? Oa(Ki(() => ({ get: t, set: P9 }))) : O(t);
}
function D9(e, t, n) {
  return ce(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
const Ql = e1 ? window : void 0, At = e1 ? window.document : void 0;
function M9(e) {
  var t;
  const n = me(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
function k9(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), o = E(() => {
    const i = Hd(me(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), r = D9(
    () => {
      var i, u;
      return [
        (u = (i = o.value) == null ? void 0 : i.map((d) => M9(d))) != null ? u : [Ql].filter((d) => d != null),
        Hd(me(o.value ? e[1] : e[0])),
        Hd(l(o.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        me(o.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !(i != null && i.length) || !(u != null && u.length) || !(d != null && d.length))
        return;
      const f = B9(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    r(), n();
  };
  return w9(n), s;
}
function O9(e, t) {
  const n = Zt(t);
  return ce(
    E9(e),
    (a, o) => {
      n.value = o;
    },
    { flush: "sync" }
  ), Oa(n);
}
const T9 = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`, A9 = b({
  props: { fallback: {
    type: String,
    required: !0
  } },
  setup(e) {
    return () => Bt("noscript", { innerHTML: `<style>${e.fallback}</style>` });
  }
}), t1 = Symbol("vue-otp-context");
function I9(e) {
  return [
    setTimeout(e, 0),
    setTimeout(e, 10),
    setTimeout(e, 50)
  ];
}
const R9 = 18, n1 = 40, q9 = `${n1}px`, F9 = [
  "[data-lastpass-icon-root]",
  "com-1password-button",
  "[data-dashlanecreated]",
  '[style$="2147483647 !important;"]'
].join(",");
function V9({ containerRef: e, inputRef: t, pushPasswordManagerStrategy: n, isFocused: a }) {
  const o = O({
    done: !1,
    refocused: !1
  }), r = O(!1), s = O(!1), i = O(!1), u = E(() => n === "none" ? !1 : (n === "increase-width" || n === "experimental-no-flickering") && r.value && s.value), d = () => {
    const p = e.value, v = t.value;
    if (!p || !v || i.value || n === "none") return;
    const m = p, h = m.getBoundingClientRect().left + m.offsetWidth, _ = m.getBoundingClientRect().top + m.offsetHeight / 2, x = h - R9, S = _;
    if (!(document.querySelectorAll(F9).length === 0 && document.elementFromPoint(x, S) === p) && (r.value = !0, i.value = !0, !o.value.refocused && document.activeElement === v)) {
      const $ = [v.selectionStart, v.selectionEnd];
      v.blur(), v.focus(), v.setSelectionRange($[0], $[1]), o.value.refocused = !0;
    }
  }, c = () => {
    const p = e.value;
    !p || n === "none" || (s.value = window.innerWidth - p.getBoundingClientRect().right >= n1);
  };
  let f;
  return be(() => {
    c(), f = setInterval(c, 1e3);
  }), Ze(() => {
    clearInterval(f);
  }), ce([a, t], (p, v, m) => {
    const [h, _] = p, x = h || document.activeElement === _;
    if (n === "none" || !x) return;
    const S = setTimeout(d, 0), $ = setTimeout(d, 2e3), D = setTimeout(d, 5e3), B = setTimeout(() => {
      i.value = !0;
    }, 6e3);
    m(() => {
      clearTimeout(S), clearTimeout($), clearTimeout(D), clearTimeout(B);
    });
  }), {
    hasPWMBadge: r,
    willPushPWMBadge: u,
    PWM_BADGE_SPACE_WIDTH: q9
  };
}
const N9 = { style: {
  position: "absolute",
  inset: "0",
  "pointer-events": "none"
} }, L9 = [
  "value",
  "data-input-otp-placeholder-shown",
  "data-input-otp-mss",
  "data-input-otp-mse",
  "aria-placeholder",
  "pattern"
], z9 = /* @__PURE__ */ b({
  name: "OTPInput",
  inheritAttrs: !1,
  __name: "OTPInput",
  props: /* @__PURE__ */ hv({
    maxlength: {},
    textAlign: { default: "left" },
    inputmode: { default: "numeric" },
    containerClass: {},
    pushPasswordManagerStrategy: { default: "increase-width" },
    noScriptCssFallback: { default: T9 },
    defaultValue: { default: "" },
    pasteTransformer: {},
    accept: {},
    alt: {},
    autocomplete: { default: "one-time-code" },
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [
      Boolean,
      Array,
      Set
    ] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {}
  }, {
    modelValue: { default(e) {
      return e.defaultValue;
    } },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ hv([
    "complete",
    "change",
    "select",
    "input",
    "focus",
    "blur",
    "mouseover",
    "mouseleave",
    "paste"
  ], ["update:modelValue"]),
  setup(e, { expose: t, emit: n }) {
    var P, q, R, Q, ee;
    const a = e, o = n, [r] = h1(e, "modelValue"), s = O9(r), i = E(() => a.pattern ? typeof a.pattern == "string" ? new RegExp(a.pattern) : a.pattern : null), u = Zt(!1), d = Zt(!1), c = Zt(null), f = Zt(null), p = Zt(null), v = Zt(null), m = (q = (P = Ql == null ? void 0 : Ql.CSS) == null ? void 0 : P.supports) == null ? void 0 : q.call(P, "-webkit-touch-callout", "none");
    let h = { prev: [
      (R = p.value) == null ? void 0 : R.selectionStart,
      (Q = p.value) == null ? void 0 : Q.selectionEnd,
      (ee = p.value) == null ? void 0 : ee.selectionDirection
    ] };
    function _(K, W) {
      try {
        K.insertRule(W);
      } catch {
        console.error("input-otp could not insert CSS rule:", W);
      }
    }
    be(() => {
      const K = p.value, W = v.value;
      if (!K || !W) return;
      h.prev = [
        K.selectionStart,
        K.selectionEnd,
        K.selectionDirection ?? "none"
      ];
      const j = k9(At, "selectionchange", J, { capture: !0 });
      function J() {
        if (!K) return;
        if ((At == null ? void 0 : At.activeElement) !== K) {
          c.value = null, f.value = null;
          return;
        }
        const Z = K.selectionStart, pe = K.selectionEnd, $e = K.selectionDirection, Ce = K.maxLength, De = K.value, ue = h.prev;
        let V = -1, te = -1, H;
        if (De.length !== 0 && Z !== null && pe !== null) {
          const _e = Z === pe, we = Z === De.length && De.length < Ce;
          if (_e && !we) {
            const Te = Z;
            if (Te === 0)
              V = 0, te = 1, H = "forward";
            else if (Te === Ce)
              V = Te - 1, te = Te, H = "backward";
            else if (Ce > 1 && De.length > 1) {
              let Ne = 0;
              if (ue[0] !== null && ue[1] !== null) {
                H = Te < ue[1] ? "backward" : "forward";
                const Je = ue[0] === ue[1] && ue[0] < Ce;
                H === "backward" && !Je && (Ne = -1);
              }
              V = Ne + Te, te = Ne + Te + 1;
            }
          }
          V !== -1 && te !== -1 && V !== te && K.setSelectionRange(V, te, H);
        }
        const re = V !== -1 ? V : Z, ie = te !== -1 ? te : pe, L = H ?? $e;
        c.value = re, f.value = ie, h.prev = [
          re,
          ie,
          L
        ];
      }
      if (J(), (At == null ? void 0 : At.activeElement) === K && (d.value = !0), !(At != null && At.getElementById("input-otp-style"))) {
        const Z = At == null ? void 0 : At.createElement("style");
        if (Z.id = "input-otp-style", At == null || At.head.appendChild(Z), Z.sheet) {
          const pe = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
          _(Z.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), _(Z.sheet, `[data-input-otp]:autofill { ${pe} }`), _(Z.sheet, `[data-input-otp]:-webkit-autofill { ${pe} }`), _(Z.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), _(Z.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
        }
      }
      const z = () => {
        W && W.style.setProperty("--root-height", `${K.clientHeight}px`);
      };
      z();
      const Y = new ResizeObserver(z);
      Y.observe(K), Ze(() => {
        j(), Y.disconnect();
      });
    }), ce([r], () => {
      I9(() => {
        var J, z, Y, Z;
        if (!p.value) return;
        (J = p.value) == null || J.dispatchEvent(new Event("input"));
        const K = (z = p.value) == null ? void 0 : z.selectionStart, W = (Y = p.value) == null ? void 0 : Y.selectionEnd, j = (Z = p.value) == null ? void 0 : Z.selectionDirection;
        K !== null && W !== null && (c.value = K ?? null, f.value = W ?? null, h.prev = [
          K,
          W,
          j
        ]);
      });
    }, { immediate: !0 }), Me(() => {
      s.value !== void 0 && r.value !== s.value && s.value.length < a.maxlength && r.value.length === a.maxlength && o("complete", r.value);
    });
    const x = V9({
      containerRef: v,
      inputRef: p,
      pushPasswordManagerStrategy: a.pushPasswordManagerStrategy,
      isFocused: d
    });
    function S(K) {
      if (K.inputType === "insertText" && K.data !== null) {
        const W = K.currentTarget, j = W.selectionStart ?? 0, J = W.selectionEnd ?? 0, z = W.value, Y = (j !== J ? z.slice(0, j) + K.data + z.slice(J) : z.slice(0, j) + K.data + z.slice(j)).slice(0, a.maxlength);
        Y.length > 0 && i.value && !i.value.test(Y) && K.preventDefault();
      }
    }
    function $(K) {
      const W = K.currentTarget.value.slice(0, a.maxlength);
      if (W.length > 0 && i.value && !i.value.test(W)) {
        K.preventDefault();
        return;
      }
      typeof s.value == "string" && W.length < s.value.length && (At == null || At.dispatchEvent(new Event("selectionchange"))), r.value = W, o("input", W);
    }
    function D() {
      const K = p.value;
      if (K) {
        const W = Math.min(K.value.length, a.maxlength - 1), j = K.value.length;
        K.setSelectionRange(W, j), c.value = W, f.value = j;
      }
      d.value = !0;
    }
    function B(K) {
      var Ce, De, ue;
      const W = p.value;
      if (!W || !a.pasteTransformer && (!m || !K.clipboardData || !W)) return;
      const j = (Ce = K == null ? void 0 : K.clipboardData) == null ? void 0 : Ce.getData("text/plain"), J = a != null && a.pasteTransformer ? a.pasteTransformer(j) : j;
      K.preventDefault();
      const z = (De = p.value) == null ? void 0 : De.selectionStart, Y = (ue = p.value) == null ? void 0 : ue.selectionEnd, Z = (z !== Y ? r.value.slice(0, z) + J + r.value.slice(Y) : r.value.slice(0, z) + J + r.value.slice(z)).slice(0, a.maxlength);
      if (Z.length > 0 && i.value && !i.value.test(Z)) return;
      r.value = Z, o("input", Z);
      const pe = Math.min(Z.length, a.maxlength - 1), $e = Z.length;
      W == null || W.setSelectionRange(pe, $e), c.value = pe, f.value = $e;
    }
    const k = Ee(S9(a, "containerClass", "value", "pattern", "defaultValue", "pushPasswordManagerStrategy", "noScriptCssFallback", "modelValue")), M = E(() => ({
      position: "relative",
      cursor: a.disabled ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })), I = E(() => ({
      position: "absolute",
      inset: 0,
      width: x.willPushPWMBadge.value ? `calc(100% + ${x.PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: x.willPushPWMBadge.value ? `inset(0 ${x.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: a.textAlign,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })), T = E(() => ({
      slots: Array.from({ length: Number(a.maxlength) }).map((K, W) => {
        var z;
        const j = d.value && c.value !== null && f.value !== null && (c.value === f.value && W === c.value || W >= c.value && W < f.value), J = r.value[W] !== void 0 ? r.value[W] : null;
        return {
          char: J,
          placeholderChar: J ?? ((z = a == null ? void 0 : a.placeholder) == null ? void 0 : z[W]) ?? null,
          isActive: j,
          hasFakeCaret: j && J === null
        };
      }),
      isFocused: d.value,
      isHovering: !a.disabled && u.value
    }));
    return Mn(t1, T), t(Object.defineProperty({}, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => p
    })), (K, W) => {
      var j;
      return g(), U(Fe, null, [e.noScriptCssFallback !== null ? (g(), C(l(A9), {
        key: 0,
        fallback: e.noScriptCssFallback
      }, null, 8, ["fallback"])) : Pe("v-if", !0), ye("div", {
        ref_key: "containerRef",
        ref: v,
        "data-input-otp-container": "",
        style: vt(M.value),
        class: ae(e.containerClass)
      }, [w(K.$slots, "default", {
        slots: T.value.slots,
        isFocused: d.value,
        isHovering: !e.disabled && u.value
      }), ye("div", N9, [ye("input", A({
        ref_key: "inputRef",
        ref: p,
        value: l(r),
        "data-input-otp": "",
        "data-input-otp-placeholder-shown": l(r).length === 0 || void 0,
        "data-input-otp-mss": c.value,
        "data-input-otp-mse": f.value,
        "aria-placeholder": e.placeholder,
        style: I.value,
        pattern: (j = i.value) == null ? void 0 : j.source
      }, {
        ...K.$attrs,
        ...l(k)
      }, {
        onBeforeinput: S,
        onMouseover: W[0] || (W[0] = (J) => {
          u.value = !0, o("mouseover", J);
        }),
        onMouseleave: W[1] || (W[1] = (J) => {
          u.value = !1, o("mouseleave", J);
        }),
        onPaste: W[2] || (W[2] = (J) => {
          B(J), o("paste", J);
        }),
        onInput: $,
        onFocus: W[3] || (W[3] = (J) => {
          D(), o("focus", J);
        }),
        onBlur: W[4] || (W[4] = (J) => {
          d.value = !1, o("blur", J);
        })
      }), null, 16, L9)])], 6)], 64);
    };
  }
});
var H9 = z9;
function U9() {
  return vn(t1);
}
const EK = /* @__PURE__ */ b({
  __name: "InputOTP",
  props: {
    maxlength: {},
    textAlign: {},
    inputmode: {},
    containerClass: {},
    pushPasswordManagerStrategy: {},
    noScriptCssFallback: {},
    defaultValue: {},
    pasteTransformer: { type: Function },
    accept: {},
    alt: {},
    autocomplete: {},
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [Boolean, Array, Set] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {},
    class: {}
  },
  emits: ["complete", "change", "select", "input", "focus", "blur", "mouseover", "mouseleave", "paste"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(H9), A(l(r), {
      "container-class": l(F)("flex items-center gap-2 has-disabled:opacity-50", n.class),
      "data-slot": "input-otp",
      class: "disabled:cursor-not-allowed"
    }), {
      default: y((u) => [
        w(s.$slots, "default", ne(oe(u)))
      ]),
      _: 3
    }, 16, ["container-class"]));
  }
}), DK = /* @__PURE__ */ b({
  __name: "InputOTPGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), U("div", A({ "data-slot": "input-otp-group" }, l(a), {
      class: l(F)("flex items-center", t.class)
    }), [
      w(o.$slots, "default")
    ], 16));
  }
}), MK = /* @__PURE__ */ b({
  __name: "InputOTPSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const n = Ee(e);
    return (a, o) => (g(), U("div", A({
      "data-slot": "input-otp-separator",
      role: "separator"
    }, l(n)), [
      w(a.$slots, "default", {}, () => [
        N(l(Cp))
      ])
    ], 16));
  }
}), j9 = ["data-active"], W9 = {
  key: 0,
  class: "pointer-events-none absolute inset-0 flex items-center justify-center"
}, kK = /* @__PURE__ */ b({
  __name: "InputOTPSlot",
  props: {
    index: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n), o = U9(), r = E(() => o == null ? void 0 : o.value.slots[t.index]);
    return (s, i) => {
      var u, d, c;
      return g(), U("div", A(l(a), {
        "data-slot": "input-otp-slot",
        "data-active": (u = r.value) == null ? void 0 : u.isActive,
        class: l(F)(
          "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md aria-invalid:border-destructive data-[active=true]:z-10 data-[active=true]:border-ring data-[active=true]:ring-[3px] data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:border-destructive data-[active=true]:aria-invalid:ring-destructive/20 dark:bg-input/30 dark:data-[active=true]:aria-invalid:ring-destructive/40",
          t.class
        )
      }), [
        Re(Ve((d = r.value) == null ? void 0 : d.char) + " ", 1),
        (c = r.value) != null && c.hasFakeCaret ? (g(), U("div", W9, [...i[0] || (i[0] = [
          ye("div", { class: "h-4 w-px animate-caret-blink bg-foreground duration-1000" }, null, -1)
        ])])) : Pe("", !0)
      ], 16, j9);
    };
  }
}), OK = /* @__PURE__ */ b({
  __name: "Item",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" },
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(se), {
      "data-slot": "item",
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(F)(l(G9)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), TK = /* @__PURE__ */ b({
  __name: "ItemActions",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "item-actions",
      class: ae(l(F)("flex items-center gap-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), AK = /* @__PURE__ */ b({
  __name: "ItemContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "item-content",
      class: ae(l(F)("flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), IK = /* @__PURE__ */ b({
  __name: "ItemDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("p", {
      "data-slot": "item-description",
      class: ae(
        l(F)(
          "line-clamp-2 text-sm leading-normal font-normal text-balance text-muted-foreground",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), RK = /* @__PURE__ */ b({
  __name: "ItemFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "item-footer",
      class: ae(l(F)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), qK = /* @__PURE__ */ b({
  __name: "ItemGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      role: "list",
      "data-slot": "item-group",
      class: ae(l(F)("group/item-group flex flex-col", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), FK = /* @__PURE__ */ b({
  __name: "ItemHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "item-header",
      class: ae(l(F)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), K9 = ["data-variant"], VK = /* @__PURE__ */ b({
  __name: "ItemMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "item-media",
      "data-variant": t.variant,
      class: ae(l(F)(l(Y9)({ variant: e.variant }), t.class))
    }, [
      w(n.$slots, "default")
    ], 10, K9));
  }
}), NK = /* @__PURE__ */ b({
  __name: "ItemSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Ou), {
      "data-slot": "item-separator",
      orientation: "horizontal",
      class: ae(l(F)("my-0", t.class))
    }, null, 8, ["class"]));
  }
}), LK = /* @__PURE__ */ b({
  __name: "ItemTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-slot": "item-title",
      class: ae(l(F)("flex w-fit items-center gap-2 text-sm leading-snug font-medium", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), G9 = en(
  "group/item [a]:hover:bg-accent/50 [a]:transition-colors flex flex-wrap items-center rounded-md border border-transparent text-sm outline-none transition-colors duration-100 focus-visible:border-ring focus-visible:ring-1 focus-visible:ring-ring",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border-border",
        muted: "bg-muted/50"
      },
      size: {
        default: "gap-4 p-4 ",
        sm: "gap-2.5 px-4 py-3"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Y9 = en(
  "flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:translate-y-0.5 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "size-8 rounded-sm border bg-muted [&_svg:not([class*='size-'])]:size-4",
        image: "size-10 overflow-hidden rounded-sm [&_img]:size-full [&_img]:object-cover"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), zK = /* @__PURE__ */ b({
  __name: "Kbd",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("kbd", {
      class: ae(
        l(F)(
          "pointer-events-none inline-flex h-5 w-fit min-w-5 items-center justify-center gap-1 rounded-sm bg-muted px-1 font-sans text-xs font-medium text-muted-foreground select-none",
          "[&_svg:not([class*='size-'])]:size-3",
          "[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), HK = /* @__PURE__ */ b({
  __name: "KbdGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("kbd", {
      "data-slot": "kbd-group",
      class: ae(l(F)("inline-flex items-center gap-1", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), UK = /* @__PURE__ */ b({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(_T), A(l(r), {
      class: l(F)(
        "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), X9 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, jK = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(gT), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        ye("span", X9, [
          N(l(o0), null, {
            default: y(() => [
              N(l(Mu), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), WK = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    sideFlip: { type: Boolean },
    align: { default: "start" },
    alignOffset: { default: -4 },
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(r0), null, {
      default: y(() => [
        N(l($T), A(l(a), {
          class: l(F)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            w(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), KK = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(PT), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), GK = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(DT), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), YK = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(OT), {
      class: ae(l(F)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), XK = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(CT), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), JK = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(IT), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), J9 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, ZK = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(qT), A(l(r), {
      class: l(F)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        ye("span", J9, [
          N(l(o0), null, {
            default: y(() => [
              N(l(K0), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), QK = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(VT), A({
      class: l(F)("-mx-1 my-1 h-px bg-muted", t.class)
    }, l(a)), null, 16, ["class"]));
  }
}), eG = /* @__PURE__ */ b({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("span", {
      class: ae(l(F)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), tG = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(LT), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nG = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(r0), null, {
      default: y(() => [
        N(l(HT), A(l(r), {
          class: l(F)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            w(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), aG = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(jT), A(l(a), {
      class: l(F)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default"),
        N(l(To), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), oG = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(KT), A(l(a), {
      class: l(F)(
        "flex cursor-default items-center rounded-sm px-3 py-1 text-sm font-medium outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Z9 = { class: "absolute top-full left-0 flex justify-center" }, Q9 = /* @__PURE__ */ b({
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    align: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), U("div", Z9, [
      N(l(hA), A(l(a), {
        class: l(F)(
          "origin-top-center relative left-[var(--reka-navigation-menu-viewport-left)] mt-1.5 h-[--reka-navigation-menu-viewport-height] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:zoom-in-90 md:w-[--reka-navigation-menu-viewport-width]",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), rG = /* @__PURE__ */ b({
  __name: "NavigationMenu",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    orientation: {},
    delayDuration: {},
    skipDelayDuration: {},
    disableClickTrigger: { type: Boolean },
    disableHoverTrigger: { type: Boolean },
    disablePointerLeaveClose: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(XT), A(l(r), {
      class: l(F)("relative z-10 flex max-w-max flex-1 items-center justify-center", n.class)
    }), {
      default: y(() => [
        w(s.$slots, "default"),
        N(Q9)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sG = /* @__PURE__ */ b({
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(rA), A(l(r), {
      class: l(F)(
        "top-0 left-0 w-full data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 data-[motion^=from-]:animate-in data-[motion^=from-]:fade-in data-[motion^=to-]:animate-out data-[motion^=to-]:fade-out md:absolute md:w-auto",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lG = /* @__PURE__ */ b({
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(lA), A(l(a), {
      class: l(F)(
        "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:animate-in data-[state=visible]:fade-in",
        t.class
      )
    }), {
      default: y(() => [...r[0] || (r[0] = [
        ye("div", { class: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" }, null, -1)
      ])]),
      _: 1
    }, 16, ["class"]));
  }
}), iG = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(tA), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), uG = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const o = qe(e, t);
    return (r, s) => (g(), C(l(uA), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dG = /* @__PURE__ */ b({
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(cA), A(l(a), {
      class: l(F)("group flex flex-1 list-none items-center justify-center gap-x-1", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cG = /* @__PURE__ */ b({
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(vA), A(l(a), {
      class: l(F)(l(eH)(), "group", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default"),
        N(l(rR), {
          class: "relative top-px ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180",
          "aria-hidden": "true"
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), eH = en(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
), fG = /* @__PURE__ */ b({
  __name: "NumberField",
  props: {
    defaultValue: {},
    modelValue: {},
    min: {},
    max: {},
    step: {},
    stepSnapping: { type: Boolean },
    formatOptions: {},
    locale: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    disableWheelChange: { type: Boolean },
    invertWheelChange: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(_A), A(l(r), {
      class: l(F)("grid gap-1.5", n.class)
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pG = /* @__PURE__ */ b({
  __name: "NumberFieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(
        l(F)(
          "relative [&>[data-slot=input]]:has-[[data-slot=decrement]]:pl-5 [&>[data-slot=input]]:has-[[data-slot=increment]]:pr-5",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), vG = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(xA), A({ "data-slot": "decrement" }, l(a), {
      class: l(F)(
        "absolute top-1/2 left-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(Cp), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), mG = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(SA), A({ "data-slot": "increment" }, l(a), {
      class: l(F)(
        "absolute top-1/2 right-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(fR), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hG = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(BA), {
      "data-slot": "input",
      class: ae(
        l(F)(
          "flex h-9 w-full rounded-md border border-input bg-transparent py-1 text-center text-sm shadow-sm transition-colors placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), gG = /* @__PURE__ */ b({
  __name: "Pagination",
  props: {
    page: {},
    defaultPage: {},
    itemsPerPage: {},
    total: {},
    siblingCount: {},
    disabled: { type: Boolean },
    showEdges: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(kA), A({ "data-slot": "pagination" }, l(r), {
      class: l(F)("mx-auto flex w-full justify-center", n.class)
    }), {
      default: y((u) => [
        w(s.$slots, "default", ne(oe(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), yG = /* @__PURE__ */ b({
  __name: "PaginationContent",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(VA), A({ "data-slot": "pagination-content" }, l(n), {
      class: l(F)("flex flex-row items-center gap-1", t.class)
    }), {
      default: y((r) => [
        w(a.$slots, "default", ne(oe(r)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bG = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(EA), A({ "data-slot": "pagination-ellipsis" }, l(n), {
      class: l(F)("flex size-9 items-center justify-center", t.class)
    }), {
      default: y(() => [
        w(a.$slots, "default", {}, () => [
          N(l(G0), { class: "size-4" }),
          o[0] || (o[0] = ye("span", { class: "sr-only" }, "More pages", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _G = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class", "size"), a = Ee(n);
    return (o, r) => (g(), C(l(TA), A({
      "data-slot": "pagination-first",
      class: l(F)(l(rn)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(ku)),
          r[0] || (r[0] = ye("span", { class: "hidden sm:block" }, "First", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), wG = /* @__PURE__ */ b({
  __name: "PaginationItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {},
    size: { default: "icon" },
    class: {},
    isActive: { type: Boolean }
  },
  setup(e) {
    const t = e, n = ve(t, "class", "size", "isActive");
    return (a, o) => (g(), C(l(LA), A({ "data-slot": "pagination-item" }, l(n), {
      class: l(F)(
        l(rn)({
          variant: e.isActive ? "outline" : "ghost",
          size: e.size
        }),
        t.class
      )
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xG = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class", "size"), a = Ee(n);
    return (o, r) => (g(), C(l(IA), A({
      "data-slot": "pagination-last",
      class: l(F)(l(rn)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          r[0] || (r[0] = ye("span", { class: "hidden sm:block" }, "Last", -1)),
          N(l(To))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CG = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class", "size"), a = Ee(n);
    return (o, r) => (g(), C(l(HA), A({
      "data-slot": "pagination-next",
      class: l(F)(l(rn)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          r[0] || (r[0] = ye("span", { class: "hidden sm:block" }, "Next", -1)),
          N(l(To))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), SG = /* @__PURE__ */ b({
  __name: "PaginationPrevious",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class", "size"), a = Ee(n);
    return (o, r) => (g(), C(l(jA), A({
      "data-slot": "pagination-previous",
      class: l(F)(l(rn)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(ku)),
          r[0] || (r[0] = ye("span", { class: "hidden sm:block" }, "Previous", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $G = /* @__PURE__ */ b({
  __name: "PinInput",
  props: {
    modelValue: { default: () => [] },
    defaultValue: {},
    placeholder: {},
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: {},
    dir: {},
    disabled: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(YA), A(l(r), {
      class: l(F)("flex items-center gap-2", n.class)
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), BG = /* @__PURE__ */ b({
  __name: "PinInputGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(se), A(l(a), {
      class: l(F)("flex items-center", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PG = /* @__PURE__ */ b({
  __name: "PinInputSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = Ee(e);
    return (a, o) => (g(), C(l(se), ne(oe(l(n))), {
      default: y(() => [
        w(a.$slots, "default", {}, () => [
          N(l(Cp), { class: "w-2" })
        ])
      ]),
      _: 3
    }, 16));
  }
}), EG = /* @__PURE__ */ b({
  __name: "PinInputSlot",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(JA), A(l(a), {
      class: l(F)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-center text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md focus:relative focus:z-10 focus:ring-2 focus:ring-ring focus:outline-none",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), DG = /* @__PURE__ */ b({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(yB), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), MG = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(bB), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), kG = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(_B), null, {
      default: y(() => [
        N(l(CB), A({ ...l(r), ...s.$attrs }, {
          class: l(F)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            w(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), OG = /* @__PURE__ */ b({
  __name: "Progress",
  props: {
    modelValue: { default: 0 },
    max: {},
    getValueLabel: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(EB), A(n.value, {
      class: l(F)("relative h-2 w-full overflow-hidden rounded-full bg-primary/20", t.class)
    }), {
      default: y(() => [
        N(l(DB), {
          class: "h-full w-full flex-1 bg-primary transition-all",
          style: vt(`transform: translateX(-${100 - (t.modelValue ?? 0)}%);`)
        }, null, 8, ["style"])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), TG = /* @__PURE__ */ b({
  __name: "RadioGroup",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(rI), A({
      class: l(F)("grid gap-2", n.class)
    }, l(r)), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), AG = /* @__PURE__ */ b({
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(uI), A(l(a), {
      class: l(F)(
        "peer aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        N(l(cI), { class: "flex items-center justify-center" }, {
          default: y(() => [
            N(l(Mu), { class: "h-3.5 w-3.5 text-primary" })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), tH = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, IG = /* @__PURE__ */ b({
  __name: "RangeCalendar",
  props: {
    defaultPlaceholder: {},
    defaultValue: {},
    modelValue: {},
    placeholder: {},
    allowNonContiguousRanges: { type: Boolean },
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    maximumDays: {},
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    isDateHighlightable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    disableDaysOutsideCurrentView: { type: Boolean },
    fixedDate: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:validModelValue", "update:placeholder", "update:startValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(TO), A({
      class: l(F)("p-3", n.class)
    }, l(r)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(iH), null, {
          default: y(() => [
            N(l(cH)),
            N(l(uH)),
            N(l(dH))
          ]),
          _: 1
        }),
        ye("div", tH, [
          (g(!0), U(Fe, null, $t(u, (c) => (g(), C(l(oH), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(sH), null, {
                default: y(() => [
                  N(l(rg), null, {
                    default: y(() => [
                      (g(!0), U(Fe, null, $t(d, (f) => (g(), C(l(lH), { key: f }, {
                        default: y(() => [
                          Re(Ve(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(rH), null, {
                default: y(() => [
                  (g(!0), U(Fe, null, $t(c.rows, (f, p) => (g(), C(l(rg), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (g(!0), U(Fe, null, $t(f, (v) => (g(), C(l(nH), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(aH), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), nH = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(IO), A({
      class: l(F)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:bg-accent first:[&:has([data-selected])]:rounded-l-md last:[&:has([data-selected])]:rounded-r-md [&:has([data-selected][data-outside-view])]:bg-accent/50 [&:has([data-selected][data-selection-end])]:rounded-r-md [&:has([data-selected][data-selection-start])]:rounded-l-md",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), aH = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(qO), A({
      class: l(F)(
        l(rn)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal data-[selected]:opacity-100",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selection Start
        "data-[selection-start]:bg-primary data-[selection-start]:text-primary-foreground data-[selection-start]:hover:bg-primary data-[selection-start]:hover:text-primary-foreground data-[selection-start]:focus:bg-primary data-[selection-start]:focus:text-primary-foreground",
        // Selection End
        "data-[selection-end]:bg-primary data-[selection-end]:text-primary-foreground data-[selection-end]:hover:bg-primary data-[selection-end]:hover:text-primary-foreground data-[selection-end]:focus:bg-primary data-[selection-end]:focus:text-primary-foreground",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), oH = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(VO), A({
      class: l(F)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rH = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(LO), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sH = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(HO), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), rg = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(jO), A({
      class: l(F)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lH = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(KO), A({
      class: l(F)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), iH = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(YO), A({
      class: l(F)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uH = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(JO), A({
      class: l(F)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        w(o.$slots, "default", { headingValue: s }, () => [
          Re(Ve(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dH = /* @__PURE__ */ b({
  __name: "RangeCalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(QO), A({
      class: l(F)(
        l(rn)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(To), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cH = /* @__PURE__ */ b({
  __name: "RangeCalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(tT), A({
      class: l(F)(
        l(rn)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(ku), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fH = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, RG = /* @__PURE__ */ b({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    nonce: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(h5), A(l(r), {
      class: l(F)(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 focus-visible:outline-none [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:translate-x-0 [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]>div]:rotate-90",
        n.class
      )
    }), {
      default: y(() => [
        n.withHandle ? (g(), U("div", fH, [
          N(l(lR), { class: "h-2.5 w-2.5" })
        ])) : Pe("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), qG = /* @__PURE__ */ b({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(f5), A(l(r), {
      class: l(F)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pH = /* @__PURE__ */ b({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(OI), A(l(n), {
      class: l(F)(
        "flex touch-none transition-colors select-none",
        e.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        e.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        t.class
      )
    }), {
      default: y(() => [
        N(l(qI), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), FG = /* @__PURE__ */ b({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class");
    return (a, o) => (g(), C(l(vI), A(l(n), {
      class: l(F)("relative overflow-hidden", t.class)
    }), {
      default: y(() => [
        N(l(VI), { class: "h-full w-full rounded-[inherit]" }, {
          default: y(() => [
            w(a.$slots, "default")
          ]),
          _: 3
        }),
        N(pH),
        N(l(yI))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), VG = /* @__PURE__ */ b({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(IB), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), NG = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(r2), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), LG = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(FB), A(l(a), {
      class: l(F)(
        "flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-start text-sm whitespace-nowrap shadow-sm ring-offset-background placeholder:text-muted-foreground focus:ring-1 focus:ring-ring focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 [&>span]:truncate",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default"),
        N(l(s2), { "as-child": "" }, {
          default: y(() => [
            N(l(q6), { class: "h-4 w-4 shrink-0 opacity-50" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), zG = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(VB), null, {
      default: y(() => [
        N(l(KB), A({ ...l(r), ...s.$attrs }, {
          class: l(F)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            e.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: y(() => [
            N(l(mH)),
            N(l(n2), {
              class: ae(
                l(F)(
                  "p-1",
                  e.position === "popper" && "h-[--radix-select-trigger-height] w-full min-w-[--radix-select-trigger-width]"
                )
              )
            }, {
              default: y(() => [
                w(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(hH))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), HG = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(e2), A({
      class: l(F)("w-full p-1", t.class)
    }, n.value), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), vH = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, UG = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(XB), A(l(a), {
      class: l(F)(
        "relative flex w-full cursor-default items-center rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        ye("span", vH, [
          N(l(JB), null, {
            default: y(() => [
              N(l(z0), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        N(l(Ny), null, {
          default: y(() => [
            w(o.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jG = /* @__PURE__ */ b({
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Ny), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), WG = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(t2), {
      class: ae(l(F)("px-2 py-1.5 text-sm font-semibold", t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), KG = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(GB), A(n.value, {
      class: l(F)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), mH = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(a2), A(l(a), {
      class: l(F)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(V6))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hH = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(o2), A(l(a), {
      class: l(F)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(H0))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), gH = /* @__PURE__ */ b({
  __name: "Sheet",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l($f), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), GG = /* @__PURE__ */ b({
  __name: "SheetTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Bf), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), YG = /* @__PURE__ */ b({
  __name: "SheetClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Bo), ne(oe(t)), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yH = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SheetContent",
  props: {
    class: {},
    side: {},
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, side: i, ...u } = n;
      return u;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(Pf), null, {
      default: y(() => [
        N(l(su), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(ru), A({
          class: l(F)(l(bH)({ side: e.side }), n.class)
        }, { ...l(r), ...s.$attrs }), {
          default: y(() => [
            w(s.$slots, "default"),
            N(l(Bo), { class: "absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-none disabled:pointer-events-none data-[state=open]:bg-secondary" }, {
              default: y(() => [
                N(l(Du), { class: "h-4 w-4" })
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), XG = /* @__PURE__ */ b({
  __name: "SheetHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex flex-col gap-y-2 text-center sm:text-left", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), JG = /* @__PURE__ */ b({
  __name: "SheetTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(kf), A({
      class: l(F)("text-lg font-semibold text-foreground", t.class)
    }, n.value), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ZG = /* @__PURE__ */ b({
  __name: "SheetDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(Of), A({
      class: l(F)("text-sm text-muted-foreground", t.class)
    }, n.value), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), QG = /* @__PURE__ */ b({
  __name: "SheetFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), bH = en(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom: "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right: "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm"
      }
    },
    defaultVariants: {
      side: "right"
    }
  }
), _H = "sidebar:state", wH = 60 * 60 * 24 * 7, xH = "16rem", CH = "18rem", SH = "3rem", $H = "b", [Ju, BH] = Ye("Sidebar"), PH = { class: "flex h-full w-full flex-col" }, EH = ["data-state", "data-collapsible", "data-variant", "data-side"], DH = {
  "data-sidebar": "sidebar",
  class: "flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
}, eY = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "Sidebar",
  props: {
    side: { default: "left" },
    variant: { default: "sidebar" },
    collapsible: { default: "offcanvas" },
    class: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a, openMobile: o, setOpenMobile: r } = Ju();
    return (s, i) => e.collapsible === "none" ? (g(), U("div", A({
      key: 0,
      class: l(F)("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", t.class)
    }, s.$attrs), [
      w(s.$slots, "default")
    ], 16)) : l(n) ? (g(), C(gH, A({
      key: 1,
      open: l(o)
    }, s.$attrs, { "onUpdate:open": l(r) }), {
      default: y(() => [
        N(yH, {
          "data-sidebar": "sidebar",
          "data-mobile": "true",
          side: e.side,
          class: "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
          style: vt({
            "--sidebar-width": l(CH)
          })
        }, {
          default: y(() => [
            ye("div", PH, [
              w(s.$slots, "default")
            ])
          ]),
          _: 3
        }, 8, ["side", "style"])
      ]),
      _: 3
    }, 16, ["open", "onUpdate:open"])) : (g(), U("div", {
      key: 2,
      class: "group peer hidden md:block",
      "data-state": l(a),
      "data-collapsible": l(a) === "collapsed" ? e.collapsible : "",
      "data-variant": e.variant,
      "data-side": e.side
    }, [
      ye("div", {
        class: ae(
          l(F)(
            "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            e.variant === "floating" || e.variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )
        )
      }, null, 2),
      ye("div", A({
        class: l(F)(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          e.side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          e.variant === "floating" || e.variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          t.class
        )
      }, s.$attrs), [
        ye("div", DH, [
          w(s.$slots, "default")
        ])
      ], 16)
    ], 8, EH));
  }
}), tY = /* @__PURE__ */ b({
  __name: "SidebarContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-sidebar": "content",
      class: ae(
        l(F)(
          "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), nY = /* @__PURE__ */ b({
  __name: "SidebarFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-sidebar": "footer",
      class: ae(l(F)("flex flex-col gap-2 p-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), aY = /* @__PURE__ */ b({
  __name: "SidebarGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-sidebar": "group",
      class: ae(l(F)("relative flex w-full min-w-0 flex-col p-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), oY = /* @__PURE__ */ b({
  __name: "SidebarGroupAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), {
      "data-sidebar": "group-action",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(F)(
          "absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          // Increases the hit area of the button on mobile.
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), rY = /* @__PURE__ */ b({
  __name: "SidebarGroupContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-sidebar": "group-content",
      class: ae(l(F)("w-full text-sm", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), sY = /* @__PURE__ */ b({
  __name: "SidebarGroupLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), {
      "data-sidebar": "group-label",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(F)(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 ring-sidebar-ring transition-[margin,opa] duration-200 ease-linear outline-none focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          t.class
        )
      )
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), lY = /* @__PURE__ */ b({
  __name: "SidebarHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-sidebar": "header",
      class: ae(l(F)("flex flex-col gap-2 p-2", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), iY = /* @__PURE__ */ b({
  __name: "SidebarInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(Qw, {
      "data-sidebar": "input",
      class: ae(
        l(F)(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          t.class
        )
      )
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), uY = /* @__PURE__ */ b({
  __name: "SidebarInset",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("main", {
      class: ae(
        l(F)(
          "relative flex min-h-svh flex-1 flex-col overflow-x-hidden bg-background",
          "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-0",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), dY = /* @__PURE__ */ b({
  __name: "SidebarMenu",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("ul", {
      "data-sidebar": "menu",
      class: ae(l(F)("flex w-full min-w-0 flex-col gap-1", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), cY = /* @__PURE__ */ b({
  __name: "SidebarMenuAction",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" },
    showOnHover: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), {
      "data-sidebar": "menu-action",
      class: ae(
        l(F)(
          "absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          // Increases the hit area of the button on mobile.
          "after:absolute after:-inset-2 after:md:hidden",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          e.showOnHover && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground data-[state=open]:opacity-100 md:opacity-0",
          t.class
        )
      ),
      as: e.as,
      "as-child": e.asChild
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "as", "as-child"]));
  }
}), fY = /* @__PURE__ */ b({
  __name: "SidebarMenuBadge",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(F)(
          "pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium text-sidebar-foreground tabular-nums select-none",
          "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), sg = /* @__PURE__ */ b({
  __name: "SidebarMenuButtonChild",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), A({
      "data-sidebar": "menu-button",
      "data-size": e.size,
      "data-active": e.isActive,
      class: l(F)(l(OH)({ variant: e.variant, size: e.size }), t.class),
      as: e.as,
      "as-child": e.asChild
    }, n.$attrs), {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-size", "data-active", "class", "as", "as-child"]));
  }
}), pY = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SidebarMenuButton",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    tooltip: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a } = Ju(), o = E(() => {
      const { tooltip: r, ...s } = t;
      return s;
    });
    return (r, s) => e.tooltip ? (g(), C(U0, { key: 1 }, {
      default: y(() => [
        N(W0, { "as-child": "" }, {
          default: y(() => [
            N(sg, ne(oe({ ...o.value, ...r.$attrs })), {
              default: y(() => [
                w(r.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }),
        N(j0, {
          side: "right",
          align: "center",
          hidden: l(a) !== "collapsed" || l(n)
        }, {
          default: y(() => [
            typeof e.tooltip == "string" ? (g(), U(Fe, { key: 0 }, [
              Re(Ve(e.tooltip), 1)
            ], 64)) : (g(), C(mt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        }, 8, ["hidden"])
      ]),
      _: 3
    })) : (g(), C(sg, ne(A({ key: 0 }, { ...o.value, ...r.$attrs })), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vY = /* @__PURE__ */ b({
  __name: "SidebarMenuItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("li", {
      "data-sidebar": "menu-item",
      class: ae(l(F)("group/menu-item relative", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), lg = /* @__PURE__ */ b({
  __name: "Skeleton",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", {
      class: ae(l(F)("animate-pulse rounded-md bg-primary/10", t.class))
    }, null, 2));
  }
}), mY = /* @__PURE__ */ b({
  __name: "SidebarMenuSkeleton",
  props: {
    showIcon: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => `${Math.floor(Math.random() * 40) + 50}%`);
    return (a, o) => (g(), U("div", {
      "data-sidebar": "menu-skeleton",
      class: ae(l(F)("flex h-8 items-center gap-2 rounded-md px-2", t.class))
    }, [
      e.showIcon ? (g(), C(lg, {
        key: 0,
        class: "size-4 rounded-md",
        "data-sidebar": "menu-skeleton-icon"
      })) : Pe("", !0),
      N(lg, {
        class: "h-4 max-w-[--skeleton-width] flex-1",
        "data-sidebar": "menu-skeleton-text",
        style: vt({ "--skeleton-width": n.value })
      }, null, 8, ["style"])
    ], 2));
  }
}), hY = /* @__PURE__ */ b({
  __name: "SidebarMenuSub",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("ul", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(F)(
          "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), gY = /* @__PURE__ */ b({
  __name: "SidebarMenuSubButton",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    size: { default: "md" },
    isActive: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Se), {
      "data-sidebar": "menu-sub-button",
      as: e.as,
      "as-child": e.asChild,
      "data-size": e.size,
      "data-active": e.isActive,
      class: ae(
        l(F)(
          "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground ring-sidebar-ring outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
          "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
          e.size === "sm" && "text-xs",
          e.size === "md" && "text-sm",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-size", "data-active", "class"]));
  }
}), MH = {};
function kH(e, t) {
  return g(), U("li", null, [
    w(e.$slots, "default")
  ]);
}
const yY = /* @__PURE__ */ Oo(MH, [["render", kH]]), bY = /* @__PURE__ */ b({
  __name: "SidebarProvider",
  props: {
    defaultOpen: { type: Boolean, default: !0 },
    open: { type: Boolean, default: void 0 },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = cc("(max-width: 768px)"), r = O(!1), s = Kf(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, document.cookie = `${_H}=${s.value}; path=/; max-age=${wH}`;
    }
    function u(f) {
      r.value = f;
    }
    function d() {
      return o.value ? u(!r.value) : i(!s.value);
    }
    Xr("keydown", (f) => {
      f.key === $H && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = E(() => s.value ? "expanded" : "collapsed");
    return BH({
      state: c,
      open: s,
      setOpen: i,
      isMobile: o,
      openMobile: r,
      setOpenMobile: u,
      toggleSidebar: d
    }), (f, p) => (g(), C(l(tb), { "delay-duration": 0 }, {
      default: y(() => [
        ye("div", {
          style: vt({
            "--sidebar-width": l(xH),
            "--sidebar-width-icon": l(SH)
          }),
          class: ae(
            l(F)(
              "group/sidebar-wrapper flex min-h-svh w-full text-sidebar-foreground has-[[data-variant=inset]]:bg-sidebar",
              n.class
            )
          )
        }, [
          w(f.$slots, "default")
        ], 6)
      ]),
      _: 3
    }));
  }
}), _Y = /* @__PURE__ */ b({
  __name: "SidebarRail",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = Ju();
    return (a, o) => (g(), U("button", {
      "data-sidebar": "rail",
      "aria-label": "Toggle Sidebar",
      tabindex: -1,
      title: "Toggle Sidebar",
      class: ae(
        l(F)(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          t.class
        )
      ),
      onClick: o[0] || (o[0] = //@ts-ignore
      (...r) => l(n) && l(n)(...r))
    }, [
      w(a.$slots, "default")
    ], 2));
  }
}), wY = /* @__PURE__ */ b({
  __name: "SidebarSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(Ou, {
      "data-sidebar": "separator",
      class: ae(l(F)("mx-2 w-auto bg-sidebar-border", t.class))
    }, {
      default: y(() => [
        w(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), xY = /* @__PURE__ */ b({
  __name: "SidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n, isMobile: a } = Ju();
    return (o, r) => (g(), C(Eu, {
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: ae(l(F)("h-9 w-9 touch-manipulation md:h-7 md:w-7", t.class)),
      onClick: l(n)
    }, {
      default: y(() => [
        l(a) ? (g(), C(l(uR), {
          key: 0,
          class: "h-5 w-5"
        })) : (g(), C(l(cR), { key: 1 })),
        r[0] || (r[0] = ye("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"]));
  }
}), OH = en(
  "peer/menu-button flex w-full touch-manipulation items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm md:h-8",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), CY = /* @__PURE__ */ b({
  __name: "Slider",
  props: {
    name: {},
    defaultValue: {},
    modelValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    inverted: { type: Boolean },
    min: {},
    max: {},
    step: {},
    minStepsBetweenThumbs: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(b2), A({
      class: l(F)("relative flex w-full touch-none items-center select-none", n.class)
    }, l(r)), {
      default: y(() => [
        N(l(x2), { class: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20" }, {
          default: y(() => [
            N(l(C2), { class: "absolute h-full bg-primary" })
          ]),
          _: 1
        }),
        (g(!0), U(Fe, null, $t(e.modelValue, (u, d) => (g(), C(l(w2), {
          key: d,
          class: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50"
        }))), 128))
      ]),
      _: 1
    }, 16, ["class"]));
  }
});
let Yc = 1;
var TH = class {
  constructor() {
    Vt(this, "subscribers");
    Vt(this, "toasts");
    Vt(this, "dismissedToasts");
    Vt(this, "subscribe", (e) => (this.subscribers.push(e), () => {
      const t = this.subscribers.indexOf(e);
      this.subscribers.splice(t, 1);
    }));
    Vt(this, "publish", (e) => {
      this.subscribers.forEach((t) => t(e));
    });
    Vt(this, "addToast", (e) => {
      this.publish(e), this.toasts = [...this.toasts, e];
    });
    Vt(this, "create", (e) => {
      var s;
      const { message: t, ...n } = e, a = typeof e.id == "number" || e.id && ((s = e.id) == null ? void 0 : s.length) > 0 ? e.id : Yc++, o = this.toasts.find((i) => i.id === a), r = e.dismissible === void 0 ? !0 : e.dismissible;
      return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a), o ? this.toasts = this.toasts.map((i) => i.id === a ? (this.publish({
        ...i,
        ...e,
        id: a,
        title: t
      }), {
        ...i,
        ...e,
        id: a,
        dismissible: r,
        title: t
      }) : i) : this.addToast({
        title: t,
        ...n,
        dismissible: r,
        id: a
      }), a;
    });
    Vt(this, "dismiss", (e) => (e ? (this.dismissedToasts.add(e), requestAnimationFrame(() => this.subscribers.forEach((t) => t({
      id: e,
      dismiss: !0
    })))) : this.toasts.forEach((t) => {
      this.subscribers.forEach((n) => n({
        id: t.id,
        dismiss: !0
      }));
    }), e));
    Vt(this, "message", (e, t) => this.create({
      ...t,
      message: e,
      type: "default"
    }));
    Vt(this, "error", (e, t) => this.create({
      ...t,
      type: "error",
      message: e
    }));
    Vt(this, "success", (e, t) => this.create({
      ...t,
      type: "success",
      message: e
    }));
    Vt(this, "info", (e, t) => this.create({
      ...t,
      type: "info",
      message: e
    }));
    Vt(this, "warning", (e, t) => this.create({
      ...t,
      type: "warning",
      message: e
    }));
    Vt(this, "loading", (e, t) => this.create({
      ...t,
      type: "loading",
      message: e
    }));
    Vt(this, "promise", (e, t) => {
      if (!t) return;
      let n;
      t.loading !== void 0 && (n = this.create({
        ...t,
        promise: e,
        type: "loading",
        message: t.loading,
        description: typeof t.description != "function" ? t.description : void 0
      }));
      const a = Promise.resolve(e instanceof Function ? e() : e);
      let o = n !== void 0, r;
      const s = a.then(async (u) => {
        if (r = ["resolve", u], Uo(u))
          o = !1, this.create({
            id: n,
            type: "default",
            message: u
          });
        else if (IH(u) && !u.ok) {
          o = !1;
          const c = typeof t.error == "function" ? await t.error(`HTTP error! status: ${u.status}`) : t.error, f = typeof t.description == "function" ? await t.description(`HTTP error! status: ${u.status}`) : t.description, v = typeof c == "object" && !Uo(c) ? c : {
            message: c || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: f,
            ...v
          });
        } else if (u instanceof Error) {
          o = !1;
          const c = typeof t.error == "function" ? await t.error(u) : t.error, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !Uo(c) ? c : {
            message: c || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: f,
            ...v
          });
        } else if (t.success !== void 0) {
          o = !1;
          const c = typeof t.success == "function" ? await t.success(u) : t.success, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !Uo(c) ? c : {
            message: c || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "success",
            description: f,
            ...v
          });
        }
      }).catch(async (u) => {
        if (r = ["reject", u], t.error !== void 0) {
          o = !1;
          const d = typeof t.error == "function" ? await t.error(u) : t.error, c = typeof t.description == "function" ? await t.description(u) : t.description, p = typeof d == "object" && !Uo(d) ? d : {
            message: d || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: c,
            ...p
          });
        }
      }).finally(() => {
        var u;
        o && (this.dismiss(n), n = void 0), (u = t.finally) == null || u.call(t);
      }), i = () => new Promise((u, d) => s.then(() => r[0] === "reject" ? d(r[1]) : u(r[1])).catch(d));
      return typeof n != "string" && typeof n != "number" ? { unwrap: i } : Object.assign(n, { unwrap: i });
    });
    Vt(this, "custom", (e, t) => {
      const n = (t == null ? void 0 : t.id) || Yc++, a = this.toasts.find((r) => r.id === n), o = (t == null ? void 0 : t.dismissible) === void 0 ? !0 : t.dismissible;
      return this.dismissedToasts.has(n) && this.dismissedToasts.delete(n), a ? this.toasts = this.toasts.map((r) => r.id === n ? (this.publish({
        ...r,
        component: e,
        dismissible: o,
        id: n,
        ...t
      }), {
        ...r,
        component: e,
        dismissible: o,
        id: n,
        ...t
      }) : r) : this.addToast({
        component: e,
        dismissible: o,
        id: n,
        ...t
      }), n;
    });
    Vt(this, "getActiveToasts", () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id)));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
const un = new TH();
function AH(e, t) {
  const n = (t == null ? void 0 : t.id) || Yc++;
  return un.create({
    message: e,
    id: n,
    type: "default",
    ...t
  }), n;
}
const IH = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", RH = AH, qH = () => un.toasts, FH = () => un.getActiveToasts();
Object.assign(RH, {
  success: un.success,
  info: un.info,
  warning: un.warning,
  error: un.error,
  custom: un.custom,
  message: un.message,
  promise: un.promise,
  dismiss: un.dismiss,
  loading: un.loading
}, {
  getHistory: qH,
  getToasts: FH
});
function Il(e) {
  return e.label !== void 0;
}
const VH = 3, a1 = "24px", o1 = "16px", ig = 4e3, NH = 356, LH = 14, zH = 45, r1 = 200;
function HH() {
  const e = O(!1);
  return Me(() => {
    const t = () => {
      e.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
  }), { isDocumentHidden: e };
}
function La(...e) {
  return e.filter(Boolean).join(" ");
}
function UH(e) {
  const [t, n] = e.split("-"), a = [];
  return t && a.push(t), n && a.push(n), a;
}
function jH(e, t) {
  const n = {};
  return [e, t].forEach((a, o) => {
    const r = o === 1, s = r ? "--mobile-offset" : "--offset", i = r ? o1 : a1;
    function u(d) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((c) => {
        n[`${s}-${c}`] = typeof d == "number" ? `${d}px` : d;
      });
    }
    typeof a == "number" || typeof a == "string" ? u(a) : typeof a == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((d) => {
      a[d] === void 0 ? n[`${s}-${d}`] = i : n[`${s}-${d}`] = typeof a[d] == "number" ? `${a[d]}px` : a[d];
    }) : u(i);
  }), n;
}
const WH = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded",
  "data-testid"
], KH = [
  "aria-label",
  "data-disabled",
  "data-close-button-position"
];
var GH = /* @__PURE__ */ b({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    closeButtonPosition: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, o = O(null), r = O(null), s = O(!1), i = O(!1), u = O(!1), d = O(!1), c = O(!1), f = O(0), p = O(0), v = O(n.toast.duration || n.duration || ig), m = O(null), h = O(null), _ = E(() => n.index === 0), x = E(() => n.index + 1 <= n.visibleToasts), S = E(() => n.toast.type), $ = E(() => n.toast.dismissible !== !1), D = E(() => n.toast.class || ""), B = E(() => n.descriptionClass || ""), k = E(() => {
      const V = n.toast.position || n.position, H = n.heights.filter((re) => re.position === V).findIndex((re) => re.toastId === n.toast.id);
      return H >= 0 ? H : 0;
    }), M = E(() => {
      const V = n.toast.position || n.position;
      return n.heights.filter((H) => H.position === V).reduce((H, re, ie) => ie >= k.value ? H : H + re.height, 0);
    }), I = E(() => k.value * n.gap + M.value || 0), T = E(() => n.toast.closeButton ?? n.closeButton), P = E(() => n.toast.duration || n.duration || ig), q = O(0), R = O(0), Q = O(null), ee = E(() => n.position.split("-")), K = E(() => ee.value[0]), W = E(() => ee.value[1]), j = E(() => typeof n.toast.title != "string"), J = E(() => typeof n.toast.description != "string"), { isDocumentHidden: z } = HH(), Y = E(() => S.value && S.value === "loading");
    be(() => {
      s.value = !0, v.value = P.value;
    }), Me(async () => {
      if (!s.value || !h.value) return;
      await he();
      const V = h.value, te = V.style.height;
      V.style.height = "auto";
      const H = V.getBoundingClientRect().height;
      V.style.height = te, p.value = H, a("update:height", {
        toastId: n.toast.id,
        height: H,
        position: n.toast.position || n.position
      });
    });
    function Z() {
      i.value = !0, f.value = I.value, setTimeout(() => {
        a("removeToast", n.toast);
      }, r1);
    }
    function pe() {
      var V, te;
      if (Y.value || !$.value) return {};
      Z(), (te = (V = n.toast).onDismiss) == null || te.call(V, n.toast);
    }
    function $e(V) {
      V.button !== 2 && (Y.value || !$.value || (m.value = /* @__PURE__ */ new Date(), f.value = I.value, V.target.setPointerCapture(V.pointerId), V.target.tagName !== "BUTTON" && (u.value = !0, Q.value = {
        x: V.clientX,
        y: V.clientY
      })));
    }
    function Ce() {
      var L, _e, we, Te, Ne, Je, xe;
      if (d.value || !$.value) return;
      Q.value = null;
      const V = Number(((L = h.value) == null ? void 0 : L.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), te = Number(((_e = h.value) == null ? void 0 : _e.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), H = (/* @__PURE__ */ new Date()).getTime() - (((we = m.value) == null ? void 0 : we.getTime()) || 0), re = o.value === "x" ? V : te, ie = Math.abs(re) / H;
      if (Math.abs(re) >= zH || ie > 0.11) {
        f.value = I.value, (Ne = (Te = n.toast).onDismiss) == null || Ne.call(Te, n.toast), o.value === "x" ? r.value = V > 0 ? "right" : "left" : r.value = te > 0 ? "down" : "up", Z(), d.value = !0;
        return;
      } else
        (Je = h.value) == null || Je.style.setProperty("--swipe-amount-x", "0px"), (xe = h.value) == null || xe.style.setProperty("--swipe-amount-y", "0px");
      c.value = !1, u.value = !1, o.value = null;
    }
    function De(V) {
      var we, Te, Ne, Je;
      if (!Q.value || !$.value || (((Te = (we = window == null ? void 0 : window.getSelection()) == null ? void 0 : we.toString()) == null ? void 0 : Te.length) ?? !1)) return;
      const H = V.clientY - Q.value.y, re = V.clientX - Q.value.x, ie = n.swipeDirections ?? UH(n.position);
      !o.value && (Math.abs(re) > 1 || Math.abs(H) > 1) && (o.value = Math.abs(re) > Math.abs(H) ? "x" : "y");
      let L = {
        x: 0,
        y: 0
      };
      const _e = (xe) => 1 / (1.5 + Math.abs(xe) / 20);
      if (o.value === "y") {
        if (ie.includes("top") || ie.includes("bottom")) if (ie.includes("top") && H < 0 || ie.includes("bottom") && H > 0) L.y = H;
        else {
          const xe = H * _e(H);
          L.y = Math.abs(xe) < Math.abs(H) ? xe : H;
        }
      } else if (o.value === "x" && (ie.includes("left") || ie.includes("right")))
        if (ie.includes("left") && re < 0 || ie.includes("right") && re > 0) L.x = re;
        else {
          const xe = re * _e(re);
          L.x = Math.abs(xe) < Math.abs(re) ? xe : re;
        }
      (Math.abs(L.x) > 0 || Math.abs(L.y) > 0) && (c.value = !0), (Ne = h.value) == null || Ne.style.setProperty("--swipe-amount-x", `${L.x}px`), (Je = h.value) == null || Je.style.setProperty("--swipe-amount-y", `${L.y}px`);
    }
    be(() => {
      if (s.value = !0, !h.value) return;
      const V = h.value.getBoundingClientRect().height;
      p.value = V;
      const te = [{
        toastId: n.toast.id,
        height: V,
        position: n.toast.position
      }, ...n.heights];
      a("update:heights", te);
    }), ka(() => {
      h.value && a("removeToast", n.toast);
    }), Me((V) => {
      if (n.toast.promise && S.value === "loading" || n.toast.duration === 1 / 0 || n.toast.type === "loading") return;
      let te;
      const H = () => {
        if (R.value < q.value) {
          const ie = (/* @__PURE__ */ new Date()).getTime() - q.value;
          v.value = v.value - ie;
        }
        R.value = (/* @__PURE__ */ new Date()).getTime();
      }, re = () => {
        v.value !== 1 / 0 && (q.value = (/* @__PURE__ */ new Date()).getTime(), te = setTimeout(() => {
          var ie, L;
          (L = (ie = n.toast).onAutoClose) == null || L.call(ie, n.toast), Z();
        }, v.value));
      };
      n.expanded || n.interacting || z.value ? H() : re(), V(() => {
        clearTimeout(te);
      });
    }), ce(() => n.toast.delete, (V) => {
      var te, H;
      V !== void 0 && V && (Z(), (H = (te = n.toast).onDismiss) == null || H.call(te, n.toast));
    }, { deep: !0 });
    function ue() {
      u.value = !1, o.value = null, Q.value = null;
    }
    return (V, te) => {
      var H, re, ie, L, _e, we, Te, Ne, Je, xe, ze, je, Ke, lt, it, St, Xt, an, Ae, st, dt, bt, G, X, de, ge, ke;
      return g(), U("li", {
        tabindex: "0",
        ref_key: "toastRef",
        ref: h,
        class: ae(l(La)(n.class, D.value, (H = V.classes) == null ? void 0 : H.toast, (re = V.toast.classes) == null ? void 0 : re.toast, (ie = V.classes) == null ? void 0 : ie[S.value], (_e = (L = V.toast) == null ? void 0 : L.classes) == null ? void 0 : _e[S.value])),
        "data-sonner-toast": "",
        "data-rich-colors": V.toast.richColors ?? V.defaultRichColors,
        "data-styled": !(V.toast.component || (we = V.toast) != null && we.unstyled || V.unstyled),
        "data-mounted": s.value,
        "data-promise": !!V.toast.promise,
        "data-swiped": c.value,
        "data-removed": i.value,
        "data-visible": x.value,
        "data-y-position": K.value,
        "data-x-position": W.value,
        "data-index": V.index,
        "data-front": _.value,
        "data-swiping": u.value,
        "data-dismissible": $.value,
        "data-type": S.value,
        "data-invert": V.toast.invert || V.invert,
        "data-swipe-out": d.value,
        "data-swipe-direction": r.value,
        "data-expanded": !!(V.expanded || V.expandByDefault && s.value),
        "data-testid": V.toast.testId,
        style: vt({
          "--index": V.index,
          "--toasts-before": V.index,
          "--z-index": V.toasts.length - V.index,
          "--offset": `${i.value ? f.value : I.value}px`,
          "--initial-height": V.expandByDefault ? "auto" : `${p.value}px`,
          ...V.style,
          ...n.toast.style
        }),
        onDragend: ue,
        onPointerdown: $e,
        onPointerup: Ce,
        onPointermove: De
      }, [T.value && !V.toast.component && S.value !== "loading" ? (g(), U("button", {
        key: 0,
        "aria-label": V.closeButtonAriaLabel || "Close toast",
        "data-disabled": Y.value,
        "data-close-button": "true",
        "data-close-button-position": V.closeButtonPosition,
        class: ae(l(La)((Te = V.classes) == null ? void 0 : Te.closeButton, (Je = (Ne = V.toast) == null ? void 0 : Ne.classes) == null ? void 0 : Je.closeButton)),
        onClick: pe
      }, [(xe = V.icons) != null && xe.close ? (g(), C(mt((ze = V.icons) == null ? void 0 : ze.close), { key: 0 })) : w(V.$slots, "close-icon", { key: 1 })], 10, KH)) : Pe("v-if", !0), V.toast.component ? (g(), C(mt(V.toast.component), A({ key: 1 }, V.toast.componentProps, {
        onCloseToast: pe,
        isPaused: V.$props.expanded || V.$props.interacting || l(z)
      }), null, 16, ["isPaused"])) : (g(), U(Fe, { key: 2 }, [
        S.value !== "default" || V.toast.icon || V.toast.promise ? (g(), U("div", {
          key: 0,
          "data-icon": "",
          class: ae(l(La)((je = V.classes) == null ? void 0 : je.icon, (lt = (Ke = V.toast) == null ? void 0 : Ke.classes) == null ? void 0 : lt.icon))
        }, [V.toast.icon ? (g(), C(mt(V.toast.icon), { key: 0 })) : (g(), U(Fe, { key: 1 }, [S.value === "loading" ? w(V.$slots, "loading-icon", { key: 0 }) : S.value === "success" ? w(V.$slots, "success-icon", { key: 1 }) : S.value === "error" ? w(V.$slots, "error-icon", { key: 2 }) : S.value === "warning" ? w(V.$slots, "warning-icon", { key: 3 }) : S.value === "info" ? w(V.$slots, "info-icon", { key: 4 }) : Pe("v-if", !0)], 64))], 2)) : Pe("v-if", !0),
        ye("div", {
          "data-content": "",
          class: ae(l(La)((it = V.classes) == null ? void 0 : it.content, (Xt = (St = V.toast) == null ? void 0 : St.classes) == null ? void 0 : Xt.content))
        }, [ye("div", {
          "data-title": "",
          class: ae(l(La)((an = V.classes) == null ? void 0 : an.title, (Ae = V.toast.classes) == null ? void 0 : Ae.title))
        }, [j.value ? (g(), C(mt(V.toast.title), ne(A({ key: 0 }, V.toast.componentProps)), null, 16)) : (g(), U(Fe, { key: 1 }, [Re(Ve(V.toast.title), 1)], 64))], 2), V.toast.description ? (g(), U("div", {
          key: 0,
          "data-description": "",
          class: ae(l(La)(V.descriptionClass, B.value, (st = V.classes) == null ? void 0 : st.description, (dt = V.toast.classes) == null ? void 0 : dt.description))
        }, [J.value ? (g(), C(mt(V.toast.description), ne(A({ key: 0 }, V.toast.componentProps)), null, 16)) : (g(), U(Fe, { key: 1 }, [Re(Ve(V.toast.description), 1)], 64))], 2)) : Pe("v-if", !0)], 2),
        V.toast.cancel ? (g(), U("button", {
          key: 1,
          style: vt(V.toast.cancelButtonStyle || V.cancelButtonStyle),
          class: ae(l(La)((bt = V.classes) == null ? void 0 : bt.cancelButton, (G = V.toast.classes) == null ? void 0 : G.cancelButton)),
          "data-button": "",
          "data-cancel": "",
          onClick: te[0] || (te[0] = (Ie) => {
            var Oe, et;
            l(Il)(V.toast.cancel) && $.value && ((et = (Oe = V.toast.cancel).onClick) == null || et.call(Oe, Ie), Z());
          })
        }, Ve(l(Il)(V.toast.cancel) ? (X = V.toast.cancel) == null ? void 0 : X.label : V.toast.cancel), 7)) : Pe("v-if", !0),
        V.toast.action ? (g(), U("button", {
          key: 2,
          style: vt(V.toast.actionButtonStyle || V.actionButtonStyle),
          class: ae(l(La)((de = V.classes) == null ? void 0 : de.actionButton, (ge = V.toast.classes) == null ? void 0 : ge.actionButton)),
          "data-button": "",
          "data-action": "",
          onClick: te[1] || (te[1] = (Ie) => {
            var Oe, et;
            l(Il)(V.toast.action) && ((et = (Oe = V.toast.action).onClick) == null || et.call(Oe, Ie), !Ie.defaultPrevented && Z());
          })
        }, Ve(l(Il)(V.toast.action) ? (ke = V.toast.action) == null ? void 0 : ke.label : V.toast.action), 7)) : Pe("v-if", !0)
      ], 64))], 46, WH);
    };
  }
}), YH = GH, sl = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, o] of t) n[a] = o;
  return n;
};
const XH = {}, JH = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function ZH(e, t) {
  return g(), U("svg", JH, t[0] || (t[0] = [ye("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), ye("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var QH = /* @__PURE__ */ sl(XH, [["render", ZH]]);
const eU = ["data-visible"], tU = { class: "sonner-spinner" };
var nU = /* @__PURE__ */ b({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(e) {
    const t = Array(12).fill(0);
    return (n, a) => (g(), U("div", {
      class: "sonner-loading-wrapper",
      "data-visible": n.visible
    }, [ye("div", tU, [(g(!0), U(Fe, null, $t(l(t), (o) => (g(), U("div", {
      key: `spinner-bar-${o}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, eU));
  }
}), aU = nU;
const oU = {}, rU = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function sU(e, t) {
  return g(), U("svg", rU, t[0] || (t[0] = [ye("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var lU = /* @__PURE__ */ sl(oU, [["render", sU]]);
const iU = {}, uU = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function dU(e, t) {
  return g(), U("svg", uU, t[0] || (t[0] = [ye("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var cU = /* @__PURE__ */ sl(iU, [["render", dU]]);
const fU = {}, pU = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function vU(e, t) {
  return g(), U("svg", pU, t[0] || (t[0] = [ye("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var mU = /* @__PURE__ */ sl(fU, [["render", vU]]);
const hU = {}, gU = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function yU(e, t) {
  return g(), U("svg", gU, t[0] || (t[0] = [ye("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var bU = /* @__PURE__ */ sl(hU, [["render", yU]]);
const _U = ["aria-label"], wU = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position"
], xU = typeof window < "u" && typeof document < "u";
function CU() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const e = document.documentElement.getAttribute("dir");
  return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e;
}
var SU = /* @__PURE__ */ b({
  name: "Toaster",
  inheritAttrs: !1,
  __name: "Toaster",
  props: {
    id: {},
    invert: {
      type: Boolean,
      default: !1
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    closeButtonPosition: { default: "top-left" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: !1
    },
    expand: {
      type: Boolean,
      default: !1
    },
    duration: {},
    gap: { default: LH },
    visibleToasts: { default: VH },
    closeButton: {
      type: Boolean,
      default: !1
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: a1 },
    mobileOffset: { default: o1 },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(e) {
    const t = e, n = g1(), a = O([]), o = E(() => t.id ? a.value.filter((P) => P.toasterId === t.id) : a.value.filter((P) => !P.toasterId));
    function r(P, q) {
      return o.value.filter((R) => !R.position && q === 0 || R.position === P);
    }
    const s = E(() => {
      const P = o.value.filter((q) => q.position).map((q) => q.position);
      return P.length > 0 ? Array.from(new Set([t.position].concat(P))) : [t.position];
    }), i = E(() => {
      const P = {};
      return s.value.forEach((q) => {
        P[q] = a.value.filter((R) => R.position === q);
      }), P;
    }), u = O([]), d = O({}), c = O(!1);
    Me(() => {
      s.value.forEach((P) => {
        P in d.value || (d.value[P] = !1);
      });
    });
    const f = O(t.theme !== "system" ? t.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = O(null), v = O(null), m = O(!1), h = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function _(P) {
      var q;
      (q = a.value.find((R) => R.id === P.id)) != null && q.delete || un.dismiss(P.id), a.value = a.value.filter(({ id: R }) => R !== P.id), setTimeout(() => {
        a.value.find((R) => R.id === P.id) || (u.value = u.value.filter((R) => R.toastId !== P.id));
      }, r1 + 50);
    }
    function x(P) {
      var q, R;
      m.value && !((R = (q = P.currentTarget) == null ? void 0 : q.contains) != null && R.call(q, P.relatedTarget)) && (m.value = !1, v.value && (v.value.focus({ preventScroll: !0 }), v.value = null));
    }
    function S(P) {
      P.target instanceof HTMLElement && P.target.dataset.dismissible === "false" || m.value || (m.value = !0, v.value = P.relatedTarget);
    }
    function $(P) {
      P.target && P.target instanceof HTMLElement && P.target.dataset.dismissible === "false" || (c.value = !0);
    }
    Me((P) => {
      const q = un.subscribe((R) => {
        if (R.dismiss) {
          requestAnimationFrame(() => {
            a.value = a.value.map((Q) => Q.id === R.id ? {
              ...Q,
              delete: !0
            } : Q);
          });
          return;
        }
        he(() => {
          const Q = a.value.findIndex((ee) => ee.id === R.id);
          Q !== -1 ? a.value = [
            ...a.value.slice(0, Q),
            {
              ...a.value[Q],
              ...R
            },
            ...a.value.slice(Q + 1)
          ] : a.value = [R, ...a.value];
        });
      });
      P(q);
    }), Me((P) => {
      if (typeof window > "u") return;
      if (t.theme !== "system") {
        f.value = t.theme;
        return;
      }
      const q = window.matchMedia("(prefers-color-scheme: dark)"), R = (ee) => {
        f.value = ee ? "dark" : "light";
      };
      R(q.matches);
      const Q = (ee) => {
        R(ee.matches);
      };
      try {
        q.addEventListener("change", Q);
      } catch {
        q.addListener(Q);
      }
      P(() => {
        try {
          q.removeEventListener("change", Q);
        } catch {
          q.removeListener(Q);
        }
      });
    }), Me(() => {
      p.value && v.value && (v.value.focus({ preventScroll: !0 }), v.value = null, m.value = !1);
    }), Me(() => {
      a.value.length <= 1 && Object.keys(d.value).forEach((P) => {
        d.value[P] = !1;
      });
    }), Me((P) => {
      function q(R) {
        const Q = t.hotkey.every((W) => R[W] || R.code === W), ee = Array.isArray(p.value) ? p.value[0] : p.value;
        Q && (s.value.forEach((W) => {
          d.value[W] = !0;
        }), ee == null || ee.focus());
        const K = document.activeElement === p.value || (ee == null ? void 0 : ee.contains(document.activeElement));
        R.code === "Escape" && K && s.value.forEach((W) => {
          d.value[W] = !1;
        });
      }
      xU && (document.addEventListener("keydown", q), P(() => {
        document.removeEventListener("keydown", q);
      }));
    });
    function D(P) {
      const q = P.currentTarget, R = q.getAttribute("data-y-position") + "-" + q.getAttribute("data-x-position");
      d.value[R] = !0;
    }
    function B(P) {
      if (!c.value) {
        const q = P.currentTarget, R = q.getAttribute("data-y-position") + "-" + q.getAttribute("data-x-position");
        d.value[R] = !1;
      }
    }
    function k() {
      Object.keys(d.value).forEach((P) => {
        d.value[P] = !1;
      });
    }
    function M() {
      c.value = !1;
    }
    function I(P) {
      u.value = P;
    }
    function T(P) {
      const q = u.value.findIndex((R) => R.toastId === P.toastId);
      if (q !== -1) u.value[q] = P;
      else {
        const R = u.value.findIndex((Q) => Q.position === P.position);
        R !== -1 ? u.value.splice(R, 0, P) : u.value.unshift(P);
      }
    }
    return (P, q) => (g(), U(Fe, null, [Pe(" Remove item from normal navigation flow, only available via hotkey "), ye("section", {
      "aria-label": `${P.containerAriaLabel} ${l(h)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(g(!0), U(Fe, null, $t(s.value, (R, Q) => {
      var ee;
      return g(), U("ol", A({
        key: R,
        ref_for: !0,
        ref_key: "listRef",
        ref: p,
        "data-sonner-toaster": "",
        "data-sonner-theme": f.value,
        class: t.class,
        dir: P.dir === "auto" ? CU() : P.dir,
        tabIndex: -1,
        "data-theme": P.theme,
        "data-rich-colors": P.richColors,
        "data-y-position": R.split("-")[0],
        "data-x-position": R.split("-")[1],
        style: {
          "--front-toast-height": `${((ee = u.value[0]) == null ? void 0 : ee.height) || 0}px`,
          "--width": `${l(NH)}px`,
          "--gap": `${P.gap}px`,
          ...P.style,
          ...l(n).style,
          ...l(jH)(P.offset, P.mobileOffset)
        }
      }, { ref_for: !0 }, P.$attrs, {
        onBlur: x,
        onFocus: S,
        onMouseenter: D,
        onMousemove: D,
        onMouseleave: B,
        onDragend: k,
        onPointerdown: $,
        onPointerup: M
      }), [(g(!0), U(Fe, null, $t(r(R, Q), (K, W) => {
        var j, J, z, Y, Z, pe, $e, Ce, De, ue, V;
        return g(), C(YH, {
          key: K.id,
          heights: u.value,
          icons: P.icons,
          index: W,
          toast: K,
          defaultRichColors: P.richColors,
          duration: ((j = P.toastOptions) == null ? void 0 : j.duration) ?? P.duration,
          class: ae(((J = P.toastOptions) == null ? void 0 : J.class) ?? ""),
          descriptionClass: (z = P.toastOptions) == null ? void 0 : z.descriptionClass,
          invert: P.invert,
          visibleToasts: P.visibleToasts,
          closeButton: ((Y = P.toastOptions) == null ? void 0 : Y.closeButton) ?? P.closeButton,
          interacting: c.value,
          position: R,
          closeButtonPosition: ((Z = P.toastOptions) == null ? void 0 : Z.closeButtonPosition) ?? P.closeButtonPosition,
          style: vt((pe = P.toastOptions) == null ? void 0 : pe.style),
          unstyled: ($e = P.toastOptions) == null ? void 0 : $e.unstyled,
          classes: (Ce = P.toastOptions) == null ? void 0 : Ce.classes,
          cancelButtonStyle: (De = P.toastOptions) == null ? void 0 : De.cancelButtonStyle,
          actionButtonStyle: (ue = P.toastOptions) == null ? void 0 : ue.actionButtonStyle,
          "close-button-aria-label": (V = P.toastOptions) == null ? void 0 : V.closeButtonAriaLabel,
          toasts: i.value[R],
          expandByDefault: P.expand,
          gap: P.gap,
          expanded: d.value[R] || !1,
          swipeDirections: t.swipeDirections,
          "onUpdate:heights": I,
          "onUpdate:height": T,
          onRemoveToast: _
        }, {
          "close-icon": y(() => [w(P.$slots, "close-icon", {}, () => [N(QH)])]),
          "loading-icon": y(() => [w(P.$slots, "loading-icon", {}, () => [N(aU, { visible: K.type === "loading" }, null, 8, ["visible"])])]),
          "success-icon": y(() => [w(P.$slots, "success-icon", {}, () => [N(lU)])]),
          "error-icon": y(() => [w(P.$slots, "error-icon", {}, () => [N(bU)])]),
          "warning-icon": y(() => [w(P.$slots, "warning-icon", {}, () => [N(mU)])]),
          "info-icon": y(() => [w(P.$slots, "info-icon", {}, () => [N(cU)])]),
          _: 2
        }, 1032, [
          "heights",
          "icons",
          "index",
          "toast",
          "defaultRichColors",
          "duration",
          "class",
          "descriptionClass",
          "invert",
          "visibleToasts",
          "closeButton",
          "interacting",
          "position",
          "closeButtonPosition",
          "style",
          "unstyled",
          "classes",
          "cancelButtonStyle",
          "actionButtonStyle",
          "close-button-aria-label",
          "toasts",
          "expandByDefault",
          "gap",
          "expanded",
          "swipeDirections"
        ]);
      }), 128))], 16, wU);
    }), 128))], 8, _U)], 2112));
  }
}), $U = SU;
const SY = /* @__PURE__ */ b({
  __name: "Sonner",
  props: {
    id: {},
    invert: { type: Boolean },
    theme: {},
    position: {},
    closeButtonPosition: {},
    hotkey: {},
    richColors: { type: Boolean },
    expand: { type: Boolean },
    duration: {},
    gap: {},
    visibleToasts: {},
    closeButton: { type: Boolean },
    toastOptions: {},
    class: {},
    style: {},
    offset: {},
    mobileOffset: {},
    dir: {},
    swipeDirections: {},
    icons: {},
    containerAriaLabel: {}
  },
  setup(e) {
    const n = ve(e, "toastOptions");
    return (a, o) => (g(), C(l($U), A({
      class: "toaster group",
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, l(n)), {
      "success-icon": y(() => [
        N(l(sR), { class: "size-4" })
      ]),
      "info-icon": y(() => [
        N(l(iR), { class: "size-4" })
      ]),
      "warning-icon": y(() => [
        N(l(pR), { class: "size-4" })
      ]),
      "error-icon": y(() => [
        N(l(dR), { class: "size-4" })
      ]),
      "loading-icon": y(() => [
        ye("div", null, [
          N(l(Y0), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": y(() => [
        N(l(X0), { class: "size-4" })
      ]),
      _: 1
    }, 16));
  }
}), $Y = /* @__PURE__ */ b({
  __name: "Spinner",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), C(l(Y0), {
      role: "status",
      "aria-label": "Loading",
      class: ae(l(F)("size-4 animate-spin", t.class))
    }, null, 8, ["class"]));
  }
}), BY = /* @__PURE__ */ b({
  __name: "Stepper",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    modelValue: {},
    linear: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(_5), A({
      class: l(F)("flex gap-2", n.class)
    }, l(r)), {
      default: y((u) => [
        w(s.$slots, "default", ne(oe(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PY = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l($5), A(l(a), {
      class: l(F)("text-xs text-muted-foreground", t.class)
    }), {
      default: y((s) => [
        w(o.$slots, "default", ne(oe(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), EY = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(P5), A(l(a), {
      class: l(F)(
        "inline-flex h-8 w-8 items-center justify-center rounded-full text-muted-foreground/50",
        // Disabled
        "group-data-[disabled]:text-muted-foreground group-data-[disabled]:opacity-50",
        // Active
        "group-data-[state=active]:bg-primary group-data-[state=active]:text-primary-foreground",
        // Completed
        "group-data-[state=completed]:bg-accent group-data-[state=completed]:text-accent-foreground",
        t.class
      )
    }), {
      default: y((s) => [
        w(o.$slots, "default", ne(oe(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), DY = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {},
    disabled: { type: Boolean },
    completed: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(C5), A(l(a), {
      class: l(F)("group flex items-center gap-2 data-[disabled]:pointer-events-none", t.class)
    }), {
      default: y((s) => [
        w(o.$slots, "default", ne(oe(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), MY = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(D5), A(l(a), {
      class: l(F)(
        "bg-muted",
        // Disabled
        "group-data-[disabled]:bg-muted group-data-[disabled]:opacity-50",
        // Completed
        "group-data-[state=completed]:bg-accent-foreground",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), kY = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(k5), A(l(a), {
      class: l(F)("text-md font-semibold whitespace-nowrap", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), OY = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(T5), A(l(a), {
      class: l(F)("flex flex-col items-center gap-1 rounded-md p-1 text-center", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), TY = /* @__PURE__ */ b({
  __name: "Switch",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: Boolean },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    id: {},
    value: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:checked"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), r = Le(o, a);
    return (s, i) => (g(), C(l(E2), A(l(r), {
      class: l(F)(
        "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
        n.class
      )
    }), {
      default: y(() => [
        N(l(D2), {
          class: ae(
            l(F)(
              "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
            )
          )
        }, null, 8, ["class"])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), BU = { class: "relative w-full overflow-auto" }, AY = /* @__PURE__ */ b({
  __name: "Table",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("div", BU, [
      ye("table", {
        class: ae(l(F)("w-full caption-bottom text-sm", t.class))
      }, [
        w(n.$slots, "default")
      ], 2)
    ]));
  }
}), IY = /* @__PURE__ */ b({
  __name: "TableBody",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("tbody", {
      class: ae(l(F)("[&_tr:last-child]:border-0", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), PU = /* @__PURE__ */ b({
  __name: "TableCell",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("td", {
      class: ae(
        l(F)(
          "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), RY = /* @__PURE__ */ b({
  __name: "TableHead",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("th", {
      class: ae(
        l(F)(
          "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), qY = /* @__PURE__ */ b({
  __name: "TableHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("thead", {
      class: ae(l(F)("[&_tr]:border-b", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), FY = /* @__PURE__ */ b({
  __name: "TableFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("tfoot", {
      class: ae(l(F)("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), EU = /* @__PURE__ */ b({
  __name: "TableRow",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("tr", {
      class: ae(
        l(F)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", t.class)
      )
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), VY = /* @__PURE__ */ b({
  __name: "TableCaption",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (g(), U("caption", {
      class: ae(l(F)("mt-4 text-sm text-muted-foreground", t.class))
    }, [
      w(n.$slots, "default")
    ], 2));
  }
}), DU = { class: "flex items-center justify-center py-10" }, NY = /* @__PURE__ */ b({
  __name: "TableEmpty",
  props: {
    class: {},
    colspan: { default: 1 }
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(EU, null, {
      default: y(() => [
        N(PU, A({
          class: l(F)("p-4 align-middle text-sm whitespace-nowrap text-foreground", t.class)
        }, n.value), {
          default: y(() => [
            ye("div", DU, [
              w(a.$slots, "default")
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), LY = /* @__PURE__ */ b({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const o = Le(e, t);
    return (r, s) => (g(), C(l(k2), ne(oe(l(o))), {
      default: y(() => [
        w(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zY = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(T2), A({
      class: l(F)(
        "mt-2 ring-offset-background focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none",
        t.class
      )
    }, n.value), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), HY = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...o } = t;
      return o;
    });
    return (a, o) => (g(), C(l(O2), A(n.value, {
      class: l(F)(
        "inline-flex items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        w(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), MU = { class: "truncate" }, UY = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: o, ...r } = t;
      return r;
    }), a = Rt(n);
    return (o, r) => (g(), C(l(A2), A(l(a), {
      class: l(F)(
        "inline-flex items-center justify-center rounded-md px-3 py-1 text-sm font-medium whitespace-nowrap ring-offset-background transition-all focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
        t.class
      )
    }), {
      default: y(() => [
        ye("span", MU, [
          w(o.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jY = /* @__PURE__ */ b({
  __name: "TagsInput",
  props: {
    modelValue: {},
    defaultValue: {},
    addOnPaste: { type: Boolean },
    addOnTab: { type: Boolean },
    addOnBlur: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: {},
    dir: {},
    max: {},
    id: {},
    convertValue: { type: Function },
    displayValue: { type: Function },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "invalid", "addTag", "removeTag"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(R5), A(l(r), {
      class: l(F)(
        "flex flex-wrap items-center gap-2 rounded-md border border-input bg-background px-3 py-1.5 text-sm",
        n.class
      )
    }), {
      default: y(() => [
        w(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), WY = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(F5), A(l(a), {
      class: l(F)("min-h-5 flex-1 bg-transparent px-1 text-sm focus:outline-none", t.class)
    }), null, 16, ["class"]));
  }
}), KY = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(L5), A(l(a), {
      class: l(F)(
        "flex h-5 items-center rounded-md bg-secondary ring-offset-background data-[state=active]:ring-2 data-[state=active]:ring-ring data-[state=active]:ring-offset-2",
        t.class
      )
    }), {
      default: y(() => [
        w(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), GY = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(H5), A(l(a), {
      class: l(F)("mr-1 flex rounded bg-transparent", t.class)
    }), {
      default: y(() => [
        w(o.$slots, "default", {}, () => [
          N(l(X0), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), YY = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = ve(t, "class"), a = Ee(n);
    return (o, r) => (g(), C(l(j5), A(l(a), {
      class: l(F)("rounded bg-transparent px-2 py-0.5 text-sm", t.class)
    }), null, 16, ["class"]));
  }
}), XY = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ve(n, "class", "size", "variant"), r = qe(o, a);
    return (s, i) => (g(), C(l(I0), A(l(r), {
      class: l(F)(l(s1)({ variant: e.variant, size: e.size }), n.class)
    }), {
      default: y((u) => [
        w(s.$slots, "default", ne(oe(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), s1 = en(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 min-w-9 px-2",
        sm: "h-8 min-w-8 px-1.5",
        lg: "h-10 min-w-10 px-2.5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), JY = /* @__PURE__ */ b({
  __name: "ToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {},
    class: {},
    variant: {},
    size: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    Mn("toggleGroup", {
      variant: n.variant,
      size: n.size
    });
    const o = ve(n, "class"), r = qe(o, a);
    return (s, i) => (g(), C(l(G5), A(l(r), {
      class: l(F)("flex items-center justify-center gap-1", n.class)
    }), {
      default: y((u) => [
        w(s.$slots, "default", ne(oe(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ZY = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e, n = vn("toggleGroup"), a = ve(t, "class", "size", "variant"), o = Ee(a);
    return (r, s) => {
      var i, u;
      return g(), C(l(J5), A(l(o), {
        class: l(F)(
          l(s1)({
            variant: ((i = l(n)) == null ? void 0 : i.variant) || e.variant,
            size: ((u = l(n)) == null ? void 0 : u.size) || e.size
          }),
          t.class
        )
      }), {
        default: y((d) => [
          w(r.$slots, "default", ne(oe(d)))
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
});
export {
  ij as Accord,
  Y6 as Accordion,
  X6 as AccordionContent,
  J6 as AccordionItem,
  Z6 as AccordionTrigger,
  dj as Alert,
  cj as AlertDescription,
  tE as AlertDialog,
  Z5 as AlertDialogAction,
  Q5 as AlertDialogCancel,
  nE as AlertDialogContent,
  rE as AlertDialogDescription,
  sE as AlertDialogFooter,
  aE as AlertDialogHeader,
  oE as AlertDialogTitle,
  HU as AlertDialogTrigger,
  fj as AlertTitle,
  pj as AspectRatio,
  vj as Avatar,
  hj as AvatarFallback,
  mj as AvatarImage,
  gj as Badge,
  yj as Breadcrumb,
  bj as BreadcrumbEllipsis,
  _j as BreadcrumbItem,
  wj as BreadcrumbLink,
  xj as BreadcrumbList,
  Cj as BreadcrumbPage,
  Sj as BreadcrumbSeparator,
  Eu as Button,
  $j as ButtonGroup,
  Bj as ButtonGroupSeparator,
  Pj as ButtonGroupText,
  Ej as Calendar,
  gR as CalendarCell,
  yR as CalendarCellTrigger,
  bR as CalendarGrid,
  _R as CalendarGridBody,
  wR as CalendarGridHead,
  Im as CalendarGridRow,
  xR as CalendarHeadCell,
  CR as CalendarHeader,
  SR as CalendarHeading,
  $R as CalendarNextButton,
  BR as CalendarPrevButton,
  PR as Card,
  ER as CardContent,
  Dj as CardDescription,
  Mj as CardFooter,
  DR as CardHeader,
  MR as CardTitle,
  kj as Carousel,
  Oj as CarouselContent,
  Tj as CarouselItem,
  Ij as CarouselNext,
  Aj as CarouselPrevious,
  Rj as ChartCrosshair,
  qj as ChartLegend,
  Fj as ChartSingleTooltip,
  Uc as ChartTooltip,
  Nj as Checkbox,
  Lj as Collapsible,
  zj as CollapsibleContent,
  Hj as CollapsibleTrigger,
  Uj as Combobox,
  jj as ComboboxAnchor,
  KU as ComboboxCancel,
  Wj as ComboboxEmpty,
  Kj as ComboboxGroup,
  Gj as ComboboxInput,
  Yj as ComboboxItem,
  GU as ComboboxItemIndicator,
  Xj as ComboboxList,
  Jj as ComboboxSeparator,
  YU as ComboboxTrigger,
  M7 as Command,
  rW as CommandDialog,
  sW as CommandEmpty,
  lW as CommandGroup,
  iW as CommandInput,
  uW as CommandItem,
  dW as CommandList,
  cW as CommandSeparator,
  fW as CommandShortcut,
  JU as ConfirmDialog,
  pW as ContextMenu,
  vW as ContextMenuCheckboxItem,
  mW as ContextMenuContent,
  hW as ContextMenuGroup,
  gW as ContextMenuItem,
  yW as ContextMenuLabel,
  bW as ContextMenuRadioGroup,
  _W as ContextMenuRadioItem,
  wW as ContextMenuSeparator,
  xW as ContextMenuShortcut,
  CW as ContextMenuSub,
  SW as ContextMenuSubContent,
  $W as ContextMenuSubTrigger,
  BW as ContextMenuTrigger,
  k7 as Dialog,
  Zj as DialogClose,
  O7 as DialogContent,
  nW as DialogDescription,
  oW as DialogFooter,
  eW as DialogHeader,
  aW as DialogScrollContent,
  tW as DialogTitle,
  Qj as DialogTrigger,
  PW as Drawer,
  EW as DrawerClose,
  DW as DrawerContent,
  MW as DrawerDescription,
  kW as DrawerFooter,
  OW as DrawerHeader,
  tz as DrawerOverlay,
  TW as DrawerTitle,
  AW as DrawerTrigger,
  IW as DropdownMenu,
  LW as DropdownMenuCheckboxItem,
  qW as DropdownMenuContent,
  FW as DropdownMenuGroup,
  NW as DropdownMenuItem,
  jW as DropdownMenuLabel,
  rB as DropdownMenuPortal,
  VW as DropdownMenuRadioGroup,
  zW as DropdownMenuRadioItem,
  UW as DropdownMenuSeparator,
  HW as DropdownMenuShortcut,
  WW as DropdownMenuSub,
  GW as DropdownMenuSubContent,
  KW as DropdownMenuSubTrigger,
  RW as DropdownMenuTrigger,
  YW as Empty,
  XW as EmptyContent,
  JW as EmptyDescription,
  ZW as EmptyHeader,
  QW as EmptyMedia,
  eK as EmptyTitle,
  Zw as FORM_ITEM_INJECTION_KEY,
  tK as Field,
  nK as FieldContent,
  aK as FieldDescription,
  oK as FieldError,
  rK as FieldGroup,
  sK as FieldLabel,
  lK as FieldLegend,
  iK as FieldSeparator,
  uK as FieldSet,
  dK as FieldTitle,
  sj as Flasher,
  fK as Form,
  vK as FormControl,
  mK as FormDescription,
  cK as FormField,
  pK as FormFieldArray,
  hK as FormItem,
  gK as FormLabel,
  yK as FormMessage,
  QU as Header,
  lj as Heading,
  bK as HoverCard,
  _K as HoverCardContent,
  wK as HoverCardTrigger,
  Qw as Input,
  xK as InputGroup,
  CK as InputGroupAddon,
  SK as InputGroupButton,
  $K as InputGroupInput,
  BK as InputGroupText,
  PK as InputGroupTextarea,
  EK as InputOTP,
  DK as InputOTPGroup,
  MK as InputOTPSeparator,
  kK as InputOTPSlot,
  OK as Item,
  TK as ItemActions,
  AK as ItemContent,
  IK as ItemDescription,
  RK as ItemFooter,
  qK as ItemGroup,
  FK as ItemHeader,
  VK as ItemMedia,
  NK as ItemSeparator,
  LK as ItemTitle,
  zK as Kbd,
  HK as KbdGroup,
  qw as Label,
  ej as Main,
  UK as Menubar,
  jK as MenubarCheckboxItem,
  WK as MenubarContent,
  KK as MenubarGroup,
  GK as MenubarItem,
  YK as MenubarLabel,
  XK as MenubarMenu,
  JK as MenubarRadioGroup,
  ZK as MenubarRadioItem,
  QK as MenubarSeparator,
  eG as MenubarShortcut,
  tG as MenubarSub,
  nG as MenubarSubContent,
  aG as MenubarSubTrigger,
  oG as MenubarTrigger,
  rG as NavigationMenu,
  sG as NavigationMenuContent,
  lG as NavigationMenuIndicator,
  iG as NavigationMenuItem,
  uG as NavigationMenuLink,
  dG as NavigationMenuList,
  cG as NavigationMenuTrigger,
  Q9 as NavigationMenuViewport,
  fG as NumberField,
  pG as NumberFieldContent,
  vG as NumberFieldDecrement,
  mG as NumberFieldIncrement,
  hG as NumberFieldInput,
  gG as Pagination,
  yG as PaginationContent,
  bG as PaginationEllipsis,
  _G as PaginationFirst,
  wG as PaginationItem,
  xG as PaginationLast,
  CG as PaginationNext,
  SG as PaginationPrevious,
  $G as PinInput,
  BG as PinInputGroup,
  PG as PinInputSeparator,
  EG as PinInputSlot,
  DG as Popover,
  qU as PopoverAnchor,
  kG as PopoverContent,
  MG as PopoverTrigger,
  OG as Progress,
  TG as RadioGroup,
  AG as RadioGroupItem,
  IG as RangeCalendar,
  nH as RangeCalendarCell,
  aH as RangeCalendarCellTrigger,
  oH as RangeCalendarGrid,
  rH as RangeCalendarGridBody,
  sH as RangeCalendarGridHead,
  rg as RangeCalendarGridRow,
  lH as RangeCalendarHeadCell,
  iH as RangeCalendarHeader,
  uH as RangeCalendarHeading,
  dH as RangeCalendarNextButton,
  cH as RangeCalendarPrevButton,
  RG as ResizableHandle,
  XU as ResizablePanel,
  qG as ResizablePanelGroup,
  FG as ScrollArea,
  pH as ScrollBar,
  VG as Select,
  zG as SelectContent,
  HG as SelectGroup,
  UG as SelectItem,
  jG as SelectItemText,
  WG as SelectLabel,
  hH as SelectScrollDownButton,
  mH as SelectScrollUpButton,
  KG as SelectSeparator,
  LG as SelectTrigger,
  NG as SelectValue,
  Ou as Separator,
  gH as Sheet,
  YG as SheetClose,
  yH as SheetContent,
  ZG as SheetDescription,
  QG as SheetFooter,
  XG as SheetHeader,
  JG as SheetTitle,
  GG as SheetTrigger,
  eY as Sidebar,
  tY as SidebarContent,
  nY as SidebarFooter,
  aY as SidebarGroup,
  oY as SidebarGroupAction,
  rY as SidebarGroupContent,
  sY as SidebarGroupLabel,
  lY as SidebarHeader,
  iY as SidebarInput,
  uY as SidebarInset,
  dY as SidebarMenu,
  cY as SidebarMenuAction,
  fY as SidebarMenuBadge,
  pY as SidebarMenuButton,
  vY as SidebarMenuItem,
  mY as SidebarMenuSkeleton,
  hY as SidebarMenuSub,
  gY as SidebarMenuSubButton,
  yY as SidebarMenuSubItem,
  bY as SidebarProvider,
  _Y as SidebarRail,
  wY as SidebarSeparator,
  xY as SidebarTrigger,
  lg as Skeleton,
  CY as Slider,
  SY as Sonner,
  $Y as Spinner,
  BY as Stepper,
  PY as StepperDescription,
  EY as StepperIndicator,
  DY as StepperItem,
  MY as StepperSeparator,
  kY as StepperTitle,
  OY as StepperTrigger,
  TY as Switch,
  AY as Table,
  IY as TableBody,
  VY as TableCaption,
  PU as TableCell,
  NY as TableEmpty,
  FY as TableFooter,
  RY as TableHead,
  qY as TableHeader,
  EU as TableRow,
  LY as Tabs,
  zY as TabsContent,
  HY as TabsList,
  UY as TabsTrigger,
  jY as TagsInput,
  WY as TagsInputInput,
  KY as TagsInputItem,
  GY as TagsInputItemDelete,
  YY as TagsInputItemText,
  y9 as Textarea,
  uj as Tip,
  T6 as Toast,
  rj as ToastAction,
  z6 as ToastClose,
  Am as ToastDescription,
  U6 as ToastProvider,
  H6 as ToastTitle,
  A6 as ToastViewport,
  O6 as Toaster,
  XY as Toggle,
  JY as ToggleGroup,
  ZY as ToggleGroupItem,
  U0 as Tooltip,
  j0 as TooltipContent,
  Q6 as TooltipProvider,
  W0 as TooltipTrigger,
  ZU as TwoColumnLayout,
  tj as TwoColumnLayoutSidebar,
  nj as TwoColumnLayoutSidebarDesktop,
  aj as TwoColumnLayoutSidebarMobile,
  oj as TwoColumnLayoutSidebarTrigger,
  eR as alertVariants,
  tR as avatarVariant,
  nR as badgeVariants,
  mR as buttonGroupVariants,
  rn as buttonVariants,
  F as cn,
  VU as createContext,
  Vj as defaultColors,
  rz as emptyMediaVariants,
  cz as fieldVariants,
  b9 as inputGroupAddonVariants,
  _9 as inputGroupButtonVariants,
  Y9 as itemMediaVariants,
  G9 as itemVariants,
  eH as navigationMenuTriggerStyle,
  TU as preset,
  bH as sheetVariants,
  OH as sidebarMenuButtonVariants,
  P6 as toast,
  j6 as toastVariants,
  s1 as toggleVariants,
  Au as useCarousel,
  n6 as useConfirmDialog,
  W6 as useFlasher,
  zU as useMobileBottomNav,
  NU as useMobileNavigation,
  Ju as useSidebar,
  LU as useSwipeNavigation,
  L0 as useToast,
  FU as valueUpdater
};
