import * as ap from "vue";
import { inject as wn, provide as Kn, Fragment as Ke, shallowRef as ht, readonly as nr, toValue as pe, getCurrentScope as Qo, onScopeDispose as ec, customRef as ui, watch as me, nextTick as Pe, effectScope as Ym, computed as q, watchEffect as Ae, onBeforeUnmount as ar, isRef as mt, reactive as jt, unref as l, getCurrentInstance as Pt, toRef as Hn, ref as O, toRefs as Me, onMounted as Ce, toHandlerKey as r0, camelize as gl, onUnmounted as nt, defineComponent as b, h as en, Comment as o0, mergeProps as A, cloneVNode as s0, createBlock as x, openBlock as h, withCtx as y, renderSlot as _, createVNode as N, createCommentVNode as qe, withKeys as Je, normalizeStyle as dt, Teleport as di, normalizeProps as oe, guardReactiveProps as le, withModifiers as Ye, createElementBlock as W, withDirectives as tc, vShow as l0, createElementVNode as we, toDisplayString as Ne, createTextVNode as Re, markRaw as i0, renderList as Nt, resolveDynamicComponent as kt, watchPostEffect as Xm, shallowReadonly as hr, mergeDefaults as Jm, watchSyncEffect as u0, withMemo as d0, onBeforeMount as c0, toRaw as f0, toHandlers as p0, hasInjectionContext as Zm, onUpdated as v0, normalizeClass as ae, useAttrs as m0, isVNode as lo, createApp as ed, useSlots as h0, vModelText as Qm, mergeModels as rp, useModel as g0 } from "vue";
function eh(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var fu, op;
function y0() {
  if (op) return fu;
  op = 1;
  function e(n, a) {
    return { handler: n, config: a };
  }
  e.withOptions = function(n, a = () => ({})) {
    function r(o) {
      return { handler: n(o), config: a(o) };
    }
    return r.__isOptionsFunction = !0, r;
  };
  var t = e;
  return fu = t, fu;
}
var pu, sp;
function b0() {
  if (sp) return pu;
  sp = 1;
  const e = y0();
  function t(n) {
    return Object.fromEntries(
      Object.entries(n).filter(([a]) => a !== "DEFAULT")
    );
  }
  return pu = e(
    ({ addUtilities: n, matchUtilities: a, theme: r }) => {
      n({
        "@keyframes enter": r("keyframes.enter"),
        "@keyframes exit": r("keyframes.exit"),
        ".animate-in": {
          animationName: "enter",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-enter-opacity": "initial",
          "--tw-enter-scale": "initial",
          "--tw-enter-rotate": "initial",
          "--tw-enter-translate-x": "initial",
          "--tw-enter-translate-y": "initial"
        },
        ".animate-out": {
          animationName: "exit",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-exit-opacity": "initial",
          "--tw-exit-scale": "initial",
          "--tw-exit-rotate": "initial",
          "--tw-exit-translate-x": "initial",
          "--tw-exit-translate-y": "initial"
        }
      }), a(
        {
          "fade-in": (o) => ({ "--tw-enter-opacity": o }),
          "fade-out": (o) => ({ "--tw-exit-opacity": o })
        },
        { values: r("animationOpacity") }
      ), a(
        {
          "zoom-in": (o) => ({ "--tw-enter-scale": o }),
          "zoom-out": (o) => ({ "--tw-exit-scale": o })
        },
        { values: r("animationScale") }
      ), a(
        {
          "spin-in": (o) => ({ "--tw-enter-rotate": o }),
          "spin-out": (o) => ({ "--tw-exit-rotate": o })
        },
        { values: r("animationRotate") }
      ), a(
        {
          "slide-in-from-top": (o) => ({
            "--tw-enter-translate-y": `-${o}`
          }),
          "slide-in-from-bottom": (o) => ({
            "--tw-enter-translate-y": o
          }),
          "slide-in-from-left": (o) => ({
            "--tw-enter-translate-x": `-${o}`
          }),
          "slide-in-from-right": (o) => ({
            "--tw-enter-translate-x": o
          }),
          "slide-out-to-top": (o) => ({
            "--tw-exit-translate-y": `-${o}`
          }),
          "slide-out-to-bottom": (o) => ({
            "--tw-exit-translate-y": o
          }),
          "slide-out-to-left": (o) => ({
            "--tw-exit-translate-x": `-${o}`
          }),
          "slide-out-to-right": (o) => ({
            "--tw-exit-translate-x": o
          })
        },
        { values: r("animationTranslate") }
      ), a(
        { duration: (o) => ({ animationDuration: o }) },
        { values: t(r("animationDuration")) }
      ), a(
        { delay: (o) => ({ animationDelay: o }) },
        { values: r("animationDelay") }
      ), a(
        { ease: (o) => ({ animationTimingFunction: o }) },
        { values: t(r("animationTimingFunction")) }
      ), n({
        ".running": { animationPlayState: "running" },
        ".paused": { animationPlayState: "paused" }
      }), a(
        { "fill-mode": (o) => ({ animationFillMode: o }) },
        { values: r("animationFillMode") }
      ), a(
        { direction: (o) => ({ animationDirection: o }) },
        { values: r("animationDirection") }
      ), a(
        { repeat: (o) => ({ animationIterationCount: o }) },
        { values: r("animationRepeat") }
      );
    },
    {
      theme: {
        extend: {
          animationDelay: ({ theme: n }) => ({
            ...n("transitionDelay")
          }),
          animationDuration: ({ theme: n }) => ({
            0: "0ms",
            ...n("transitionDuration")
          }),
          animationTimingFunction: ({ theme: n }) => ({
            ...n("transitionTimingFunction")
          }),
          animationFillMode: {
            none: "none",
            forwards: "forwards",
            backwards: "backwards",
            both: "both"
          },
          animationDirection: {
            normal: "normal",
            reverse: "reverse",
            alternate: "alternate",
            "alternate-reverse": "alternate-reverse"
          },
          animationOpacity: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("opacity")
          }),
          animationTranslate: ({ theme: n }) => ({
            DEFAULT: "100%",
            ...n("translate")
          }),
          animationScale: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("scale")
          }),
          animationRotate: ({ theme: n }) => ({
            DEFAULT: "30deg",
            ...n("rotate")
          }),
          animationRepeat: {
            0: "0",
            1: "1",
            infinite: "infinite"
          },
          keyframes: {
            enter: {
              from: {
                opacity: "var(--tw-enter-opacity, 1)",
                transform: "translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))"
              }
            },
            exit: {
              to: {
                opacity: "var(--tw-exit-opacity, 1)",
                transform: "translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))"
              }
            }
          }
        }
      }
    }
  ), pu;
}
var _0 = b0();
const w0 = /* @__PURE__ */ eh(_0), cH = {
  darkMode: ["class"],
  safelist: ["dark"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))"
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))"
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))"
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))"
        }
      },
      borderRadius: {
        xl: "calc(var(--radius) + 4px)",
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" }
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }
        },
        "collapsible-down": {
          from: { height: "0" },
          to: { height: "var(--radix-collapsible-content-height)" }
        },
        "collapsible-up": {
          from: { height: "var(--radix-collapsible-content-height)" },
          to: { height: "0" }
        }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "collapsible-down": "collapsible-down 0.2s ease-in-out",
        "collapsible-up": "collapsible-up 0.2s ease-in-out"
      }
    }
  },
  plugins: [w0]
};
function lp(e) {
  return typeof e == "string" ? `'${e}'` : new x0().serialize(e);
}
const x0 = /* @__PURE__ */ (function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(n, a) {
      const r = typeof n, o = typeof a;
      return r === "string" && o === "string" ? n.localeCompare(a) : r === "number" && o === "number" ? n - a : String.prototype.localeCompare.call(this.serialize(n, !0), this.serialize(a, !0));
    }
    serialize(n, a) {
      if (n === null) return "null";
      switch (typeof n) {
        case "string":
          return a ? n : `'${n}'`;
        case "bigint":
          return `${n}n`;
        case "object":
          return this.$object(n);
        case "function":
          return this.$function(n);
      }
      return String(n);
    }
    serializeObject(n) {
      const a = Object.prototype.toString.call(n);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), n);
      const r = n.constructor, o = r === Object || r === void 0 ? "" : r.name;
      if (o !== "" && globalThis[o] === r) return this.serializeBuiltInType(o, n);
      if (typeof n.toJSON == "function") {
        const s = n.toJSON();
        return o + (s !== null && typeof s == "object" ? this.$object(s) : `(${this.serialize(s)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(n));
    }
    serializeBuiltInType(n, a) {
      const r = this["$" + n];
      if (r) return r.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(n, a.entries());
      throw new Error(`Cannot serialize ${n}`);
    }
    serializeObjectEntries(n, a) {
      const r = Array.from(a).sort((s, i) => this.compare(s[0], i[0]));
      let o = `${n}{`;
      for (let s = 0; s < r.length; s++) {
        const [i, u] = r[s];
        o += `${this.serialize(i, !0)}:${this.serialize(u)}`, s < r.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(n) {
      let a = this.#e.get(n);
      return a === void 0 && (this.#e.set(n, `#${this.#e.size}`), a = this.serializeObject(n), this.#e.set(n, a)), a;
    }
    $function(n) {
      const a = Function.prototype.toString.call(n);
      return a.slice(-15) === "[native code] }" ? `${n.name || ""}()[native]` : `${n.name}(${n.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(n) {
      let a = "[";
      for (let r = 0; r < n.length; r++) a += this.serialize(n[r]), r < n.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(n) {
      try {
        return `Date(${n.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(n) {
      return `ArrayBuffer[${new Uint8Array(n).join(",")}]`;
    }
    $Set(n) {
      return `Set${this.$Array(Array.from(n).sort((a, r) => this.compare(a, r)))}`;
    }
    $Map(n) {
      return this.serializeObjectEntries("Map", n.entries());
    }
  }
  for (const t of ["Error", "RegExp", "URL"]) e.prototype["$" + t] = function(n) {
    return `${t}(${n})`;
  };
  for (const t of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join(",")}]`;
  };
  for (const t of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join("n,")}${n.length > 0 ? "n" : ""}]`;
  };
  return e;
})();
function Mn(e, t) {
  return e === t || lp(e) === lp(t);
}
function C0(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function S0(e, t, n) {
  const a = e.findIndex((i) => Mn(i, t)), r = e.findIndex((i) => Mn(i, n));
  if (a === -1 || r === -1) return [];
  const [o, s] = [a, r].sort((i, u) => i - u);
  return e.slice(o, s + 1);
}
const es = typeof document < "u";
function Ar(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e));
}
function Ds(e, t) {
  let n = e;
  const a = t.toString(), r = a.indexOf("."), o = r >= 0 ? a.length - r : 0;
  if (o > 0) {
    const s = 10 ** o;
    n = Math.round(n * s) / s;
  }
  return n;
}
function $0(e, t, n, a) {
  t = Number(t), n = Number(n);
  const r = (e - (Number.isNaN(t) ? 0 : t)) % a;
  let o = Ds(Math.abs(r) * 2 >= a ? e + Math.sign(r) * (a - Math.abs(r)) : e - r, a);
  return Number.isNaN(t) ? !Number.isNaN(n) && o > n && (o = Math.floor(Ds(n / a, a)) * a) : o < t ? o = t : !Number.isNaN(n) && o > n && (o = t + Math.floor(Ds((n - t) / a, a)) * a), o = Ds(o, a), o;
}
function Se(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = wn(a, s);
    if (i || i === null) return i;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (s) => (Kn(a, s), s)];
}
function ot() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function ts(e, t, n) {
  const a = n.originalEvent.target, r = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(r);
}
function Pn(e) {
  return e == null;
}
function yl(e, t) {
  return Pn(e) ? !1 : Array.isArray(e) ? e.some((n) => Mn(n, t)) : Mn(e, t);
}
function nc(e) {
  return e ? e.flatMap((t) => t.type === Ke ? nc(t.children) : [t]) : [];
}
const B0 = ["INPUT", "TEXTAREA"];
function rr(e, t, n, a = {}) {
  if (!t || a.enableIgnoredElement && B0.includes(t.nodeName)) return null;
  const { arrowKeyOptions: r = "both", attributeName: o = "[data-reka-collection-item]", itemsArray: s = [], loop: i = !0, dir: u = "ltr", preventScroll: d = !0, focus: c = !1 } = a, [f, p, v, m, g, w] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ], C = v || m, S = f || p;
  if (!g && !w && (!C && !S || r === "vertical" && S || r === "horizontal" && C)) return null;
  const $ = n ? Array.from(n.querySelectorAll(o)) : s;
  if (!$.length) return null;
  d && e.preventDefault();
  let k = null;
  return S || C ? k = th($, t, {
    goForward: C ? m : u === "ltr" ? f : p,
    loop: i
  }) : g ? k = $.at(0) || null : w && (k = $.at(-1) || null), c && k?.focus(), k;
}
function th(e, t, n, a = e.length) {
  if (--a === 0) return null;
  const r = e.indexOf(t), o = n.goForward ? r + 1 : r - 1;
  if (!n.loop && (o < 0 || o >= e.length)) return null;
  const s = (o + e.length) % e.length, i = e[s];
  return i ? i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false" ? th(e, i, n, a) : i : null;
}
const [ns] = Se("ConfigProvider");
function k0(e, t) {
  var n;
  const a = ht();
  return Ae(() => {
    a.value = e();
  }, {
    ...t,
    flush: (n = void 0) != null ? n : "sync"
  }), nr(a);
}
function va(e) {
  return Qo() ? (ec(e), !0) : !1;
}
function $r() {
  const e = /* @__PURE__ */ new Set(), t = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const s = () => t(o);
      return va(s), {
        off: s
      };
    },
    off: t,
    trigger: (...o) => Promise.all(Array.from(e).map((s) => s(...o))),
    clear: () => {
      e.clear();
    }
  };
}
function P0(e) {
  let t = !1, n;
  const a = Ym(!0);
  return (...r) => (t || (n = a.run(() => e(...r)), t = !0), n);
}
function nh(e) {
  let t = 0, n, a;
  const r = () => {
    t -= 1, a && t <= 0 && (a.stop(), n = void 0, a = void 0);
  };
  return (...o) => (t += 1, a || (a = Ym(!0), n = a.run(() => e(...o))), va(r), n);
}
function D0(e) {
  if (!mt(e))
    return jt(e);
  const t = new Proxy({}, {
    get(n, a, r) {
      return l(Reflect.get(e.value, a, r));
    },
    set(n, a, r) {
      return mt(e.value[a]) && !mt(r) ? e.value[a].value = r : e.value[a] = r, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return jt(t);
}
function ac(e) {
  return D0(q(e));
}
function as(e, ...t) {
  const n = t.flat(), a = n[0];
  return ac(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(pe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
const tn = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const M0 = (e) => typeof e < "u", q0 = (e) => e != null, E0 = Object.prototype.toString, T0 = (e) => E0.call(e) === "[object Object]", bl = () => {
}, ip = /* @__PURE__ */ A0();
function A0() {
  var e, t;
  return tn && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window?.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function ah(e, t) {
  function n(...a) {
    return new Promise((r, o) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(r).catch(o);
    });
  }
  return n;
}
const rh = (e) => e();
function O0(e, t = {}) {
  let n, a, r = bl;
  const o = (u) => {
    clearTimeout(u), r(), r = bl;
  };
  let s;
  return (u) => {
    const d = pe(e), c = pe(t.maxWait);
    return n && o(n), d <= 0 || c !== void 0 && c <= 0 ? (a && (o(a), a = null), Promise.resolve(u())) : new Promise((f, p) => {
      r = t.rejectOnCancel ? p : f, s = u, c && !a && (a = setTimeout(() => {
        n && o(n), a = null, f(s());
      }, c)), n = setTimeout(() => {
        a && o(a), a = null, f(u());
      }, d);
    });
  };
}
function I0(e = rh, t = {}) {
  const {
    initialState: n = "active"
  } = t, a = V0(n === "active");
  function r() {
    a.value = !1;
  }
  function o() {
    a.value = !0;
  }
  const s = (...i) => {
    a.value && e(...i);
  };
  return { isActive: nr(a), pause: r, resume: o, eventFilter: s };
}
function R0(e) {
  return Pt();
}
function tl(e) {
  return Array.isArray(e) ? e : [e];
}
function V0(...e) {
  if (e.length !== 1)
    return Hn(...e);
  const t = e[0];
  return typeof t == "function" ? nr(ui(() => ({ get: t, set: bl }))) : O(t);
}
function rs(e, t = 1e4) {
  return ui((n, a) => {
    let r = pe(e), o;
    const s = () => setTimeout(() => {
      r = pe(e), a();
    }, pe(t));
    return va(() => {
      clearTimeout(o);
    }), {
      get() {
        return n(), r;
      },
      set(i) {
        r = i, a(), clearTimeout(o), o = s();
      }
    };
  });
}
function rc(e, t = 200, n = {}) {
  return ah(
    O0(t, n),
    e
  );
}
function F0(e, t, n = {}) {
  const {
    eventFilter: a = rh,
    ...r
  } = n;
  return me(
    e,
    ah(
      a,
      t
    ),
    r
  );
}
function up(e, t, n = {}) {
  const {
    eventFilter: a,
    initialState: r = "active",
    ...o
  } = n, { eventFilter: s, pause: i, resume: u, isActive: d } = I0(a, { initialState: r });
  return { stop: F0(
    e,
    t,
    {
      ...o,
      eventFilter: s
    }
  ), pause: i, resume: u, isActive: d };
}
function N0(e, t, ...[n]) {
  const {
    flush: a = "sync",
    deep: r = !1,
    immediate: o = !0,
    direction: s = "both",
    transform: i = {}
  } = n || {}, u = [], d = "ltr" in i && i.ltr || ((p) => p), c = "rtl" in i && i.rtl || ((p) => p);
  return (s === "both" || s === "ltr") && u.push(up(
    e,
    (p) => {
      u.forEach((v) => v.pause()), t.value = d(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: r, immediate: o }
  )), (s === "both" || s === "rtl") && u.push(up(
    t,
    (p) => {
      u.forEach((v) => v.pause()), e.value = c(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: r, immediate: o }
  )), () => {
    u.forEach((p) => p.stop());
  };
}
function L0(e, t) {
  R0() && ar(e, t);
}
function oh(e, t, n = {}) {
  const {
    immediate: a = !0,
    immediateCallback: r = !1
  } = n, o = ht(!1);
  let s = null;
  function i() {
    s && (clearTimeout(s), s = null);
  }
  function u() {
    o.value = !1, i();
  }
  function d(...c) {
    r && e(), i(), o.value = !0, s = setTimeout(() => {
      o.value = !1, s = null, e(...c);
    }, pe(t));
  }
  return a && (o.value = !0, tn && d()), va(u), {
    isPending: nr(o),
    start: d,
    stop: u
  };
}
function z0(e, t, n) {
  return me(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
function H0(e, t, n) {
  const a = me(e, (...r) => (Pe(() => a()), t(...r)), n);
  return a;
}
const Ta = tn ? window : void 0;
function Wt(e) {
  var t;
  const n = pe(e);
  return (t = n?.$el) != null ? t : n;
}
function Lt(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), r = q(() => {
    const i = tl(pe(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), o = z0(
    () => {
      var i, u;
      return [
        (u = (i = r.value) == null ? void 0 : i.map((d) => Wt(d))) != null ? u : [Ta].filter((d) => d != null),
        tl(pe(r.value ? e[1] : e[0])),
        tl(l(r.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        pe(r.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !i?.length || !u?.length || !d?.length)
        return;
      const f = T0(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return va(n), s;
}
function oc() {
  const e = ht(!1), t = Pt();
  return t && Ce(() => {
    e.value = !0;
  }, t), e;
}
function sh(e) {
  const t = oc();
  return q(() => (t.value, !!e()));
}
function U0(e, t, n = {}) {
  const { window: a = Ta, ...r } = n;
  let o;
  const s = sh(() => a && "MutationObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = q(() => {
    const p = pe(e), v = tl(p).map(Wt).filter(q0);
    return new Set(v);
  }), d = me(
    () => u.value,
    (p) => {
      i(), s.value && p.size && (o = new MutationObserver(t), p.forEach((v) => o.observe(v, r)));
    },
    { immediate: !0, flush: "post" }
  ), c = () => o?.takeRecords(), f = () => {
    d(), i();
  };
  return va(f), {
    isSupported: s,
    stop: f,
    takeRecords: c
  };
}
function j0(e, t, n = {}) {
  const {
    window: a = Ta,
    document: r = a?.document,
    flush: o = "sync"
  } = n;
  if (!a || !r)
    return bl;
  let s;
  const i = (c) => {
    s?.(), s = c;
  }, u = Ae(() => {
    const c = Wt(e);
    if (c) {
      const { stop: f } = U0(
        r,
        (p) => {
          p.map((m) => [...m.removedNodes]).flat().some((m) => m === c || m.contains(c)) && t(p);
        },
        {
          window: a,
          childList: !0,
          subtree: !0
        }
      );
      i(f);
    }
  }, { flush: o }), d = () => {
    u(), i();
  };
  return va(d), d;
}
function W0(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function G0(...e) {
  let t, n, a = {};
  e.length === 3 ? (t = e[0], n = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], a = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: r = Ta,
    eventName: o = "keydown",
    passive: s = !1,
    dedupe: i = !1
  } = a, u = W0(t);
  return Lt(r, o, (c) => {
    c.repeat && pe(i) || u(c) && n(c);
  }, s);
}
function K0(e = {}) {
  var t;
  const {
    window: n = Ta,
    deep: a = !0,
    triggerOnRemoval: r = !1
  } = e, o = (t = e.document) != null ? t : n?.document, s = () => {
    var d;
    let c = o?.activeElement;
    if (a)
      for (; c?.shadowRoot; )
        c = (d = c?.shadowRoot) == null ? void 0 : d.activeElement;
    return c;
  }, i = ht(), u = () => {
    i.value = s();
  };
  if (n) {
    const d = {
      capture: !0,
      passive: !0
    };
    Lt(
      n,
      "blur",
      (c) => {
        c.relatedTarget === null && u();
      },
      d
    ), Lt(
      n,
      "focus",
      u,
      d
    );
  }
  return r && j0(i, u, { document: o }), u(), i;
}
function Y0(e) {
  return JSON.parse(JSON.stringify(e));
}
function qn(e, t, n = {}) {
  const { window: a = Ta, ...r } = n;
  let o;
  const s = sh(() => a && "ResizeObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = q(() => {
    const f = pe(e);
    return Array.isArray(f) ? f.map((p) => Wt(p)) : [Wt(f)];
  }), d = me(
    u,
    (f) => {
      if (i(), s.value && a) {
        o = new ResizeObserver(t);
        for (const p of f)
          p && o.observe(p, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    i(), d();
  };
  return va(c), {
    isSupported: s,
    stop: c
  };
}
const X0 = "focusin", J0 = "focusout", Z0 = ":focus-within";
function Q0(e, t = {}) {
  const { window: n = Ta } = t, a = q(() => Wt(e)), r = ht(!1), o = q(() => r.value), s = K0(t);
  if (!n || !s.value)
    return { focused: o };
  const i = { passive: !0 };
  return Lt(a, X0, () => r.value = !0, i), Lt(a, J0, () => {
    var u, d, c;
    return r.value = (c = (d = (u = a.value) == null ? void 0 : u.matches) == null ? void 0 : d.call(u, Z0)) != null ? c : !1;
  }, i), { focused: o };
}
function Ve(e, t, n, a = {}) {
  var r, o, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = Pt(), m = n || v?.emit || ((r = v?.$emit) == null ? void 0 : r.bind(v)) || ((s = (o = v?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(v?.proxy));
  let g = d;
  t || (t = "modelValue"), g = g || `update:${t.toString()}`;
  const w = ($) => i ? typeof i == "function" ? i($) : Y0($) : $, C = () => M0(e[t]) ? w(e[t]) : f, S = ($) => {
    p ? p($) && m(g, $) : m(g, $);
  };
  if (u) {
    const $ = C(), k = O($);
    let B = !1;
    return me(
      () => e[t],
      (D) => {
        B || (B = !0, k.value = w(D), Pe(() => B = !1));
      }
    ), me(
      k,
      (D) => {
        !B && (D !== e[t] || c) && S(D);
      },
      { deep: c }
    ), k;
  } else
    return q({
      get() {
        return C();
      },
      set($) {
        S($);
      }
    });
}
function vu(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function td(e, t, n = ".", a) {
  if (!vu(t))
    return td(e, {}, n, a);
  const r = Object.assign({}, t);
  for (const o in e) {
    if (o === "__proto__" || o === "constructor")
      continue;
    const s = e[o];
    s != null && (a && a(r, o, s, n) || (Array.isArray(s) && Array.isArray(r[o]) ? r[o] = [...s, ...r[o]] : vu(s) && vu(r[o]) ? r[o] = td(
      s,
      r[o],
      (n ? `${n}.` : "") + o.toString(),
      a
    ) : r[o] = s));
  }
  return r;
}
function ew(e) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((n, a) => td(n, a, "", e), {})
  );
}
const tw = ew(), nw = nh(() => {
  const e = O(/* @__PURE__ */ new Map()), t = O(), n = q(() => {
    for (const s of e.value.values()) if (s) return !0;
    return !1;
  }), a = ns({ scrollBody: O(!0) });
  let r = null;
  const o = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", ip && r?.(), t.value = void 0;
  };
  return me(n, (s, i) => {
    if (!tn) return;
    if (!s) {
      i && o();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const u = window.innerWidth - document.documentElement.clientWidth, d = {
      padding: u,
      margin: 0
    }, c = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? tw({
      padding: a.scrollBody.value.padding === !0 ? u : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? u : a.scrollBody.value.margin
    }, d) : d : {
      padding: 0,
      margin: 0
    };
    u > 0 && (document.body.style.paddingRight = typeof c.padding == "number" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == "number" ? `${c.margin}px` : String(c.margin), document.documentElement.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), ip && (r = Lt(document, "touchmove", (f) => aw(f), { passive: !1 })), Pe(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function os(e) {
  const t = Math.random().toString(36).substring(2, 7), n = nw();
  n.value.set(t, e ?? !1);
  const a = q({
    get: () => n.value.get(t) ?? !1,
    set: (r) => n.value.set(t, r)
  });
  return L0(() => {
    n.value.delete(t);
  }), a;
}
function lh(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : lh(n);
  }
}
function aw(e) {
  const t = e || window.event, n = t.target;
  return n instanceof Element && lh(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);
}
function Br(e, t) {
  return e - t * Math.floor(e / t);
}
const ih = 1721426;
function Ua(e, t, n, a) {
  t = ss(e, t);
  let r = t - 1, o = -2;
  return n <= 2 ? o = 0 : ka(t) && (o = -1), ih - 1 + 365 * r + Math.floor(r / 4) - Math.floor(r / 100) + Math.floor(r / 400) + Math.floor((367 * n - 362) / 12 + o + a);
}
function ka(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function ss(e, t) {
  return e === "BC" ? 1 - t : t;
}
function ci(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const rw = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class En {
  fromJulianDay(t) {
    let n = t, a = n - ih, r = Math.floor(a / 146097), o = Br(a, 146097), s = Math.floor(o / 36524), i = Br(o, 36524), u = Math.floor(i / 1461), d = Br(i, 1461), c = Math.floor(d / 365), f = r * 400 + s * 100 + u * 4 + c + (s !== 4 && c !== 4 ? 1 : 0), [p, v] = ci(f), m = n - Ua(p, v, 1, 1), g = 2;
    n < Ua(p, v, 3, 1) ? g = 0 : ka(v) && (g = 1);
    let w = Math.floor(((m + g) * 12 + 373) / 367), C = n - Ua(p, v, w, 1) + 1;
    return new xt(p, v, w, C);
  }
  toJulianDay(t) {
    return Ua(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return rw[ka(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return ka(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const ow = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function _t(e, t) {
  return t = Jt(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function sc(e, t) {
  return t = Jt(t, e.calendar), e = nd(e), t = nd(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function Sa(e, t) {
  return lc(e.calendar, t.calendar) && _t(e, t);
}
function dp(e, t) {
  return lc(e.calendar, t.calendar) && sc(e, t);
}
function lc(e, t) {
  var n, a, r, o;
  return (o = (r = (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && r !== void 0 ? r : (a = t.isEqual) === null || a === void 0 ? void 0 : a.call(t, e)) !== null && o !== void 0 ? o : e.identifier === t.identifier;
}
function uh(e, t) {
  return _t(e, ch(t));
}
function dh(e, t, n) {
  let a = e.calendar.toJulianDay(e), r = uw(t), o = Math.ceil(a + 1 - r) % 7;
  return o < 0 && (o += 7), o;
}
function sw(e) {
  return aa(Date.now(), e);
}
function ch(e) {
  return fw(sw(e));
}
function fh(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function lw(e, t) {
  return cp(e) - cp(t);
}
function cp(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let mu = null;
function Wr() {
  return mu == null && (mu = new Intl.DateTimeFormat().resolvedOptions().timeZone), mu;
}
function nd(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function fp(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
const pp = /* @__PURE__ */ new Map(), hu = /* @__PURE__ */ new Map();
function iw(e) {
  if (Intl.Locale) {
    let n = pp.get(e);
    return n || (n = new Intl.Locale(e).maximize().region, n && pp.set(e, n)), n;
  }
  let t = e.split("-")[1];
  return t === "u" ? void 0 : t;
}
function uw(e) {
  let t = hu.get(e);
  if (!t) {
    if (Intl.Locale) {
      let a = new Intl.Locale(e);
      if ("getWeekInfo" in a && (t = a.getWeekInfo(), t))
        return hu.set(e, t), t.firstDay;
    }
    let n = iw(e);
    if (e.includes("-fw-")) {
      let a = e.split("-fw-")[1].split("-")[0];
      a === "mon" ? t = {
        firstDay: 1
      } : a === "tue" ? t = {
        firstDay: 2
      } : a === "wed" ? t = {
        firstDay: 3
      } : a === "thu" ? t = {
        firstDay: 4
      } : a === "fri" ? t = {
        firstDay: 5
      } : a === "sat" ? t = {
        firstDay: 6
      } : t = {
        firstDay: 0
      };
    } else e.includes("-ca-iso8601") ? t = {
      firstDay: 1
    } : t = {
      firstDay: n && ow[n] || 0
    };
    hu.set(e, t);
  }
  return t.firstDay;
}
function Or(e) {
  e = Jt(e, new En());
  let t = ss(e.era, e.year);
  return ph(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function ph(e, t, n, a, r, o, s) {
  let i = /* @__PURE__ */ new Date();
  return i.setUTCHours(a, r, o, s), i.setUTCFullYear(e, t - 1, n), i.getTime();
}
function ad(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === Wr()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: n, month: a, day: r, hour: o, minute: s, second: i } = vh(e, t);
  return ph(n, a, r, o, s, i, 0) - Math.floor(e / 1e3) * 1e3;
}
const vp = /* @__PURE__ */ new Map();
function vh(e, t) {
  let n = vp.get(t);
  n || (n = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), vp.set(t, n));
  let a = n.formatToParts(new Date(e)), r = {};
  for (let o of a) o.type !== "literal" && (r[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: r.era === "BC" || r.era === "B" ? -r.year + 1 : +r.year,
    month: +r.month,
    day: +r.day,
    hour: r.hour === "24" ? 0 : +r.hour,
    minute: +r.minute,
    second: +r.second
  };
}
const mp = 864e5;
function dw(e, t, n, a) {
  return (n === a ? [
    n
  ] : [
    n,
    a
  ]).filter((o) => cw(e, t, o));
}
function cw(e, t, n) {
  let a = vh(n, t);
  return e.year === a.year && e.month === a.month && e.day === a.day && e.hour === a.hour && e.minute === a.minute && e.second === a.second;
}
function na(e, t, n = "compatible") {
  let a = Ir(e);
  if (t === "UTC") return Or(a);
  if (t === Wr() && n === "compatible") {
    a = Jt(a, new En());
    let u = /* @__PURE__ */ new Date(), d = ss(a.era, a.year);
    return u.setFullYear(d, a.month - 1, a.day), u.setHours(a.hour, a.minute, a.second, a.millisecond), u.getTime();
  }
  let r = Or(a), o = ad(r - mp, t), s = ad(r + mp, t), i = dw(a, t, r - o, r - s);
  if (i.length === 1) return i[0];
  if (i.length > 1) switch (n) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return i[0];
    case "later":
      return i[i.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (n) {
    case "earlier":
      return Math.min(r - o, r - s);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(r - o, r - s);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function mh(e, t, n = "compatible") {
  return new Date(na(e, t, n));
}
function aa(e, t) {
  let n = ad(e, t), a = new Date(e + n), r = a.getUTCFullYear(), o = a.getUTCMonth() + 1, s = a.getUTCDate(), i = a.getUTCHours(), u = a.getUTCMinutes(), d = a.getUTCSeconds(), c = a.getUTCMilliseconds();
  return new Vr(r < 1 ? "BC" : "AD", r < 1 ? -r + 1 : r, o, s, t, n, i, u, d, c);
}
function fw(e) {
  return new xt(e.calendar, e.era, e.year, e.month, e.day);
}
function Ir(e, t) {
  let n = 0, a = 0, r = 0, o = 0;
  if ("timeZone" in e) ({ hour: n, minute: a, second: r, millisecond: o } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: n, minute: a, second: r, millisecond: o } = t), new Rr(e.calendar, e.era, e.year, e.month, e.day, n, a, r, o);
}
function Jt(e, t) {
  if (lc(e.calendar, t)) return e;
  let n = t.fromJulianDay(e.calendar.toJulianDay(e)), a = e.copy();
  return a.calendar = t, a.era = n.era, a.year = n.year, a.month = n.month, a.day = n.day, Xa(a), a;
}
function pw(e, t, n) {
  if (e instanceof Vr)
    return e.timeZone === t ? e : mw(e, t);
  let a = na(e, t, n);
  return aa(a, t);
}
function vw(e) {
  let t = Or(e) - e.offset;
  return new Date(t);
}
function mw(e, t) {
  let n = Or(e) - e.offset;
  return Jt(aa(n, t), e.calendar);
}
const io = 36e5;
function fi(e, t) {
  let n = e.copy(), a = "hour" in n ? bw(n, t) : 0;
  rd(n, t.years || 0), n.calendar.balanceYearMonth && n.calendar.balanceYearMonth(n, e), n.month += t.months || 0, od(n), hh(n), n.day += (t.weeks || 0) * 7, n.day += t.days || 0, n.day += a, hw(n), n.calendar.balanceDate && n.calendar.balanceDate(n), n.year < 1 && (n.year = 1, n.month = 1, n.day = 1);
  let r = n.calendar.getYearsInEra(n);
  if (n.year > r) {
    var o, s;
    let u = (o = (s = n.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(s, n);
    n.year = r, n.month = u ? 1 : n.calendar.getMonthsInYear(n), n.day = u ? 1 : n.calendar.getDaysInMonth(n);
  }
  n.month < 1 && (n.month = 1, n.day = 1);
  let i = n.calendar.getMonthsInYear(n);
  return n.month > i && (n.month = i, n.day = n.calendar.getDaysInMonth(n)), n.day = Math.max(1, Math.min(n.calendar.getDaysInMonth(n), n.day)), n;
}
function rd(e, t) {
  var n, a;
  !((n = (a = e.calendar).isInverseEra) === null || n === void 0) && n.call(a, e) && (t = -t), e.year += t;
}
function od(e) {
  for (; e.month < 1; )
    rd(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, rd(e, 1);
}
function hw(e) {
  for (; e.day < 1; )
    e.month--, od(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, od(e);
}
function hh(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function Xa(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), hh(e);
}
function gh(e) {
  let t = {};
  for (let n in e) typeof e[n] == "number" && (t[n] = -e[n]);
  return t;
}
function yh(e, t) {
  return fi(e, gh(t));
}
function ic(e, t) {
  let n = e.copy();
  return t.era != null && (n.era = t.era), t.year != null && (n.year = t.year), t.month != null && (n.month = t.month), t.day != null && (n.day = t.day), Xa(n), n;
}
function _l(e, t) {
  let n = e.copy();
  return t.hour != null && (n.hour = t.hour), t.minute != null && (n.minute = t.minute), t.second != null && (n.second = t.second), t.millisecond != null && (n.millisecond = t.millisecond), yw(n), n;
}
function gw(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = Ms(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = Ms(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = Ms(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = Ms(e.hour, 24), t;
}
function yw(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function Ms(e, t) {
  let n = e % t;
  return n < 0 && (n += t), n;
}
function bw(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, gw(e);
}
function uc(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "era": {
      let i = e.calendar.getEras(), u = i.indexOf(e.era);
      if (u < 0) throw new Error("Invalid era: " + e.era);
      u = ra(u, n, 0, i.length - 1, a?.round), r.era = i[u], Xa(r);
      break;
    }
    case "year":
      var o, s;
      !((o = (s = r.calendar).isInverseEra) === null || o === void 0) && o.call(s, r) && (n = -n), r.year = ra(e.year, n, -1 / 0, 9999, a?.round), r.year === -1 / 0 && (r.year = 1), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, e);
      break;
    case "month":
      r.month = ra(e.month, n, 1, e.calendar.getMonthsInYear(e), a?.round);
      break;
    case "day":
      r.day = ra(e.day, n, 1, e.calendar.getDaysInMonth(e), a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(r), Xa(r), r;
}
function bh(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "hour": {
      let o = e.hour, s = 0, i = 23;
      if (a?.hourCycle === 12) {
        let u = o >= 12;
        s = u ? 12 : 0, i = u ? 23 : 11;
      }
      r.hour = ra(o, n, s, i, a?.round);
      break;
    }
    case "minute":
      r.minute = ra(e.minute, n, 0, 59, a?.round);
      break;
    case "second":
      r.second = ra(e.second, n, 0, 59, a?.round);
      break;
    case "millisecond":
      r.millisecond = ra(e.millisecond, n, 0, 999, a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return r;
}
function ra(e, t, n, a, r = !1) {
  if (r) {
    e += Math.sign(t), e < n && (e = a);
    let o = Math.abs(t);
    t > 0 ? e = Math.ceil(e / o) * o : e = Math.floor(e / o) * o, e > a && (e = n);
  } else
    e += t, e < n ? e = a - (n - e - 1) : e > a && (e = n + (e - a - 1));
  return e;
}
function _h(e, t) {
  let n;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let r = fi(Ir(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    n = na(r, e.timeZone);
  } else
    n = Or(e) - e.offset;
  n += t.milliseconds || 0, n += (t.seconds || 0) * 1e3, n += (t.minutes || 0) * 6e4, n += (t.hours || 0) * 36e5;
  let a = aa(n, e.timeZone);
  return Jt(a, e.calendar);
}
function _w(e, t) {
  return _h(e, gh(t));
}
function ww(e, t, n, a) {
  switch (t) {
    case "hour": {
      let r = 0, o = 23;
      if (a?.hourCycle === 12) {
        let m = e.hour >= 12;
        r = m ? 12 : 0, o = m ? 23 : 11;
      }
      let s = Ir(e), i = Jt(_l(s, {
        hour: r
      }), new En()), u = [
        na(i, e.timeZone, "earlier"),
        na(i, e.timeZone, "later")
      ].filter((m) => aa(m, e.timeZone).day === i.day)[0], d = Jt(_l(s, {
        hour: o
      }), new En()), c = [
        na(d, e.timeZone, "earlier"),
        na(d, e.timeZone, "later")
      ].filter((m) => aa(m, e.timeZone).day === d.day).pop(), f = Or(e) - e.offset, p = Math.floor(f / io), v = f % io;
      return f = ra(p, n, Math.floor(u / io), Math.floor(c / io), a?.round) * io + v, Jt(aa(f, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return bh(e, t, n, a);
    case "era":
    case "year":
    case "month":
    case "day": {
      let r = uc(Ir(e), t, n, a), o = na(r, e.timeZone);
      return Jt(aa(o, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function xw(e, t, n) {
  let a = Ir(e), r = _l(ic(a, t), t);
  if (r.compare(a) === 0) return e;
  let o = na(r, e.timeZone, n);
  return Jt(aa(o, e.timeZone), e.calendar);
}
function Cw(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function wh(e) {
  let t = Jt(e, new En()), n;
  return t.era === "BC" ? n = t.year === 1 ? "0000" : "-" + String(Math.abs(1 - t.year)).padStart(6, "00") : n = String(t.year).padStart(4, "0"), `${n}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function xh(e) {
  return `${wh(e)}T${Cw(e)}`;
}
function Sw(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let n = Math.floor(e / 36e5), a = Math.floor(e % 36e5 / 6e4), r = Math.floor(e % 36e5 % 6e4 / 1e3), o = `${t}${String(n).padStart(2, "0")}:${String(a).padStart(2, "0")}`;
  return r !== 0 && (o += `:${String(r).padStart(2, "0")}`), o;
}
function $w(e) {
  return `${xh(e)}${Sw(e.offset)}[${e.timeZone}]`;
}
function Bw(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function dc(e, t, n) {
  Bw(e, t), t.set(e, n);
}
function cc(e) {
  let t = typeof e[0] == "object" ? e.shift() : new En(), n;
  if (typeof e[0] == "string") n = e.shift();
  else {
    let s = t.getEras();
    n = s[s.length - 1];
  }
  let a = e.shift(), r = e.shift(), o = e.shift();
  return [
    t,
    n,
    a,
    r,
    o
  ];
}
var kw = /* @__PURE__ */ new WeakMap();
class xt {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new xt(this.calendar, this.era, this.year, this.month, this.day) : new xt(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return fi(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return yh(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return ic(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return uc(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return mh(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return wh(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return fh(this, t);
  }
  constructor(...t) {
    dc(this, kw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = cc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, Xa(this);
  }
}
var Pw = /* @__PURE__ */ new WeakMap();
class Rr {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Rr(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new Rr(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return fi(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return yh(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return ic(_l(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return uc(this, t, n, a);
      default:
        return bh(this, t, n, a);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, n) {
    return mh(this, t, n);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return xh(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let n = fh(this, t);
    return n === 0 ? lw(this, Ir(t)) : n;
  }
  constructor(...t) {
    dc(this, Pw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = cc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, Xa(this);
  }
}
var Dw = /* @__PURE__ */ new WeakMap();
class Vr {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Vr(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new Vr(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return _h(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return _w(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, n) {
    return xw(this, t, n);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return ww(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return vw(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return $w(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - pw(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    dc(this, Dw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = cc(t), i = t.shift(), u = t.shift();
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.timeZone = i, this.offset = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, Xa(this);
  }
}
const kr = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], Mw = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], nl = [
  1867,
  1911,
  1925,
  1988,
  2018
], Ca = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function hp(e) {
  const t = kr.findIndex(([n, a, r]) => e.year < n || e.year === n && e.month < a || e.year === n && e.month === a && e.day < r);
  return t === -1 ? kr.length - 1 : t === 0 ? 0 : t - 1;
}
function gu(e) {
  let t = nl[Ca.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new xt(e.year + t, e.month, e.day);
}
class qw extends En {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = hp(n);
    return new xt(this, Ca[a], n.year - nl[a], n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(gu(t));
  }
  balanceDate(t) {
    let n = gu(t), a = hp(n);
    Ca[a] !== t.era && (t.era = Ca[a], t.year = n.year - nl[a]), this.constrainDate(t);
  }
  constrainDate(t) {
    let n = Ca.indexOf(t.era), a = Mw[n];
    if (a != null) {
      let [r, o, s] = a, i = r - nl[n];
      t.year = Math.max(1, Math.min(i, t.year)), t.year === i && (t.month = Math.min(o, t.month), t.month === o && (t.day = Math.min(s, t.day)));
    }
    if (t.year === 1 && n >= 0) {
      let [, r, o] = kr[n];
      t.month = Math.max(r, t.month), t.month === r && (t.day = Math.max(o, t.day));
    }
  }
  getEras() {
    return Ca;
  }
  getYearsInEra(t) {
    let n = Ca.indexOf(t.era), a = kr[n], r = kr[n + 1];
    if (r == null)
      return 9999 - a[0] + 1;
    let o = r[0] - a[0];
    return (t.month < r[1] || t.month === r[1] && t.day < r[2]) && o++, o;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(gu(t));
  }
  getMinimumMonthInYear(t) {
    let n = gp(t);
    return n ? n[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let n = gp(t);
    return n && t.month === n[1] ? n[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function gp(e) {
  if (e.year === 1) {
    let t = Ca.indexOf(e.era);
    return kr[t];
  }
}
const Ch = -543;
class Ew extends En {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ss(n.era, n.year);
    return new xt(this, a - Ch, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(yp(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(yp(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function yp(e) {
  let [t, n] = ci(e.year + Ch);
  return new xt(t, n, e.month, e.day);
}
const wl = 1911;
function Sh(e) {
  return e.era === "minguo" ? e.year + wl : 1 - e.year + wl;
}
function bp(e) {
  let t = e - wl;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class Tw extends En {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ss(n.era, n.year), [r, o] = bp(a);
    return new xt(this, r, o, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(_p(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [n, a] = bp(Sh(t));
    t.era = n, t.year = a;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(_p(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - wl;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function _p(e) {
  let [t, n] = ci(Sh(e));
  return new xt(t, n, e.month, e.day);
}
const wp = 1948320, xp = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class Aw {
  fromJulianDay(t) {
    let n = t - wp, a = 1 + Math.floor((33 * n + 3) / 12053), r = 365 * (a - 1) + Math.floor((8 * a + 21) / 33), o = n - r, s = o < 216 ? Math.floor(o / 31) : Math.floor((o - 6) / 30), i = o - xp[s] + 1;
    return new xt(this, a, s + 1, i);
  }
  toJulianDay(t) {
    let n = wp - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return n += xp[t.month - 1], n += t.day, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || Br(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const yu = 78, Cp = 80;
class Ow extends En {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = n.year - yu, r = t - Ua(n.era, n.year, 1, 1), o;
    r < Cp ? (a--, o = ka(n.year - 1) ? 31 : 30, r += o + 155 + 90 + 10) : (o = ka(n.year) ? 31 : 30, r -= Cp);
    let s, i;
    if (r < o)
      s = 1, i = r + 1;
    else {
      let u = r - o;
      u < 155 ? (s = Math.floor(u / 31) + 2, i = u % 31 + 1) : (u -= 155, s = Math.floor(u / 30) + 7, i = u % 30 + 1);
    }
    return new xt(this, a, s, i);
  }
  toJulianDay(t) {
    let n = t.year + yu, [a, r] = ci(n), o, s;
    return ka(r) ? (o = 31, s = Ua(a, r, 3, 21)) : (o = 30, s = Ua(a, r, 3, 22)), t.month === 1 ? s + t.day - 1 : (s += o + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (s += (t.month - 7) * 30), s += t.day - 1, s);
  }
  getDaysInMonth(t) {
    return t.month === 1 && ka(t.year + yu) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const xl = 1948440, Sp = 1948439, bn = 1300, gr = 1600, Iw = 460322;
function Cl(e, t, n, a) {
  return a + Math.ceil(29.5 * (n - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function $h(e, t, n) {
  let a = Math.floor((30 * (n - t) + 10646) / 10631), r = Math.min(12, Math.ceil((n - (29 + Cl(t, a, 1, 1))) / 29.5) + 1), o = n - Cl(t, a, r, 1) + 1;
  return new xt(e, a, r, o);
}
function $p(e) {
  return (14 + 11 * e) % 30 < 11;
}
class fc {
  fromJulianDay(t) {
    return $h(this, xl, t);
  }
  toJulianDay(t) {
    return Cl(xl, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = 29 + t.month % 2;
    return t.month === 12 && $p(t.year) && n++, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return $p(t.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class Rw extends fc {
  fromJulianDay(t) {
    return $h(this, Sp, t);
  }
  toJulianDay(t) {
    return Cl(Sp, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const Vw = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let sd, Pr;
function al(e) {
  return Iw + Pr[e - bn];
}
function bo(e, t) {
  let n = e - bn, a = 1 << 11 - (t - 1);
  return (sd[n] & a) === 0 ? 29 : 30;
}
function Bp(e, t) {
  let n = al(e);
  for (let a = 1; a < t; a++) n += bo(e, a);
  return n;
}
function kp(e) {
  return Pr[e + 1 - bn] - Pr[e - bn];
}
class Fw extends fc {
  fromJulianDay(t) {
    let n = t - xl, a = al(bn), r = al(gr);
    if (n < a || n > r) return super.fromJulianDay(t);
    {
      let o = bn - 1, s = 1, i = 1;
      for (; i > 0; ) {
        o++, i = n - al(o) + 1;
        let u = kp(o);
        if (i === u) {
          s = 12;
          break;
        } else if (i < u) {
          let d = bo(o, s);
          for (s = 1; i > d; )
            i -= d, s++, d = bo(o, s);
          break;
        }
      }
      return new xt(this, o, s, n - Bp(o, s) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < bn || t.year > gr ? super.toJulianDay(t) : xl + Bp(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < bn || t.year > gr ? super.getDaysInMonth(t) : bo(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < bn || t.year > gr ? super.getDaysInYear(t) : kp(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", sd || (sd = new Uint16Array(Uint8Array.from(atob(Vw), (t) => t.charCodeAt(0)).buffer)), !Pr) {
      Pr = new Uint32Array(gr - bn + 1);
      let t = 0;
      for (let n = bn; n <= gr; n++) {
        Pr[n - bn] = t;
        for (let a = 1; a <= 12; a++) t += bo(n, a);
      }
    }
  }
}
const Pp = 347997, Bh = 1080, kh = 24 * Bh, Nw = 29, Lw = 12 * Bh + 793, zw = Nw * kh + Lw;
function Ha(e) {
  return Br(e * 7 + 1, 19) < 7;
}
function rl(e) {
  let t = Math.floor((235 * e - 234) / 19), n = 12084 + 13753 * t, a = t * 29 + Math.floor(n / 25920);
  return Br(3 * (a + 1), 7) < 3 && (a += 1), a;
}
function Hw(e) {
  let t = rl(e - 1), n = rl(e);
  return rl(e + 1) - n === 356 ? 2 : n - t === 382 ? 1 : 0;
}
function ko(e) {
  return rl(e) + Hw(e);
}
function Ph(e) {
  return ko(e + 1) - ko(e);
}
function Uw(e) {
  let t = Ph(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    // deficient
    case 354:
      return 1;
    // normal
    case 355:
      return 2;
  }
}
function qs(e, t) {
  if (t >= 6 && !Ha(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let n = Uw(e);
  return t === 2 ? n === 2 ? 30 : 29 : t === 3 ? n === 0 ? 29 : 30 : t === 6 ? Ha(e) ? 30 : 0 : 30;
}
class jw {
  fromJulianDay(t) {
    let n = t - Pp, a = n * kh / zw, r = Math.floor((19 * a + 234) / 235) + 1, o = ko(r), s = Math.floor(n - o);
    for (; s < 1; )
      r--, o = ko(r), s = Math.floor(n - o);
    let i = 1, u = 0;
    for (; u < s; )
      u += qs(r, i), i++;
    i--, u -= qs(r, i);
    let d = s - u;
    return new xt(this, r, i, d);
  }
  toJulianDay(t) {
    let n = ko(t.year);
    for (let a = 1; a < t.month; a++) n += qs(t.year, a);
    return n + t.day + Pp;
  }
  getDaysInMonth(t) {
    return qs(t.year, t.month);
  }
  getMonthsInYear(t) {
    return Ha(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return Ph(t.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, n) {
    n.year !== t.year && (Ha(n.year) && !Ha(t.year) && n.month > 6 ? t.month-- : !Ha(n.year) && Ha(t.year) && n.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const ld = 1723856, Dp = 1824665, id = 5500;
function Sl(e, t, n, a) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (n - 1) + a - 1;
}
function pc(e, t) {
  let n = Math.floor(4 * (t - e) / 1461), a = 1 + Math.floor((t - Sl(e, n, 1, 1)) / 30), r = t + 1 - Sl(e, n, a, 1);
  return [
    n,
    a,
    r
  ];
}
function Dh(e) {
  return Math.floor(e % 4 / 3);
}
function Mh(e, t) {
  return t % 13 !== 0 ? 30 : Dh(e) + 5;
}
class vc {
  fromJulianDay(t) {
    let [n, a, r] = pc(ld, t), o = "AM";
    return n <= 0 && (o = "AA", n += id), new xt(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "AA" && (n -= id), Sl(ld, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    return Mh(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + Dh(t.year);
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class Ww extends vc {
  fromJulianDay(t) {
    let [n, a, r] = pc(ld, t);
    return n += id, new xt(this, "AA", n, a, r);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class Gw extends vc {
  fromJulianDay(t) {
    let [n, a, r] = pc(Dp, t), o = "CE";
    return n <= 0 && (o = "BCE", n = 1 - n), new xt(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Sl(Dp, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Mh(n, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function Kw(e) {
  switch (e) {
    case "buddhist":
      return new Ew();
    case "ethiopic":
      return new vc();
    case "ethioaa":
      return new Ww();
    case "coptic":
      return new Gw();
    case "hebrew":
      return new jw();
    case "indian":
      return new Ow();
    case "islamic-civil":
      return new fc();
    case "islamic-tbla":
      return new Rw();
    case "islamic-umalqura":
      return new Fw();
    case "japanese":
      return new qw();
    case "persian":
      return new Aw();
    case "roc":
      return new Tw();
    default:
      return new En();
  }
}
let bu = /* @__PURE__ */ new Map();
class ta {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)}  ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.formatter.formatToParts(t), r = this.formatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return Jw() && (this.resolvedHourCycle || (this.resolvedHourCycle = Zw(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, n = {}) {
    this.formatter = qh(t, n), this.options = n;
  }
}
const Yw = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function qh(e, t = {}) {
  if (typeof t.hour12 == "boolean" && Xw()) {
    t = {
      ...t
    };
    let r = Yw[String(t.hour12)][e.split("-")[0]], o = t.hour12 ? "h12" : "h23";
    t.hourCycle = r ?? o, delete t.hour12;
  }
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : "");
  if (bu.has(n)) return bu.get(n);
  let a = new Intl.DateTimeFormat(e, t);
  return bu.set(n, a), a;
}
let _u = null;
function Xw() {
  return _u == null && (_u = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), _u;
}
let wu = null;
function Jw() {
  return wu == null && (wu = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), wu;
}
function Zw(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = qh(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), a = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), r = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (a === 0 && r === 23) return "h23";
  if (a === 24 && r === 23) return "h24";
  if (a === 0 && r === 11) return "h11";
  if (a === 12 && r === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function $n(e, t = Wr()) {
  return mc(e) ? e.toDate() : e.toDate(t);
}
function Qw(e) {
  return e instanceof Rr;
}
function mc(e) {
  return e instanceof Vr;
}
function e1(e) {
  return Qw(e) || mc(e);
}
function To(e) {
  if (e instanceof Date) {
    const t = e.getFullYear(), n = e.getMonth() + 1;
    return new Date(t, n, 0).getDate();
  } else return e.set({ day: 100 }).day;
}
function Ka(e, t) {
  return e.compare(t) < 0;
}
function ol(e, t) {
  return e.compare(t) > 0;
}
function t1(e, t) {
  return e.compare(t) <= 0;
}
function n1(e, t) {
  return e.compare(t) >= 0;
}
function a1(e, t, n) {
  return n1(e, t) && t1(e, n);
}
function xu(e, t, n) {
  return ol(e, t) && Ka(e, n);
}
function r1(e, t, n) {
  const a = dh(e, n);
  return t > a ? e.subtract({ days: a + 7 - t }) : t === a ? e : e.subtract({ days: a - t });
}
function o1(e, t, n) {
  const a = dh(e, n), r = t === 0 ? 6 : t - 1;
  return a === r ? e : a > r ? e.add({ days: 7 - a + r }) : e.add({ days: r - a });
}
function s1(e, t, n, a, r) {
  if (n === void 0 && a === void 0 && r === void 0) return !0;
  let o = e.add({ days: 1 });
  if ((a?.(o) || n?.(o)) && !r?.(o)) return !1;
  const s = t;
  for (; o.compare(s) < 0; )
    if (o = o.add({ days: 1 }), (a?.(o) || n?.(o)) && !r?.(o)) return !1;
  return !0;
}
function Eh(e) {
  const { defaultValue: t, defaultPlaceholder: n, granularity: a = "day", locale: r = "en" } = e;
  if (Array.isArray(t) && t.length) return t.at(-1).copy();
  if (t && !Array.isArray(t)) return t.copy();
  if (n) return n.copy();
  const o = /* @__PURE__ */ new Date(), s = o.getFullYear(), i = o.getMonth() + 1, u = o.getDate(), d = [
    "hour",
    "minute",
    "second"
  ], c = new ta(r), f = Kw(c.resolvedOptions().calendar);
  return d.includes(a ?? "day") ? Jt(new Rr(s, i, u, 0, 0, 0), f) : Jt(new xt(s, i, u), f);
}
function l1(e, t) {
  const n = [];
  for (let a = 0; a < e.length; a += t) n.push(e.slice(a, a + t));
  return n;
}
function Th(e) {
  const t = e.querySelector("[data-selected]");
  if (t) return t.focus();
  const n = e.querySelector("[data-today]");
  if (n) return n.focus();
  const a = e.querySelector("[data-reka-calendar-day]");
  if (a) return a.focus();
}
function ud(e, t) {
  const n = [];
  let a = e.add({ days: 1 });
  const r = t;
  for (; a.compare(r) < 0; )
    n.push(a), a = a.add({ days: 1 });
  return n;
}
function Cu(e) {
  const { dateObj: t, weekStartsOn: n, fixedWeeks: a, locale: r } = e, o = To(t), s = Array.from({ length: o }, (w, C) => t.set({ day: C + 1 })), i = nd(t), u = fp(t), d = r1(i, n, r), c = o1(u, n, r), f = ud(d.subtract({ days: 1 }), i), p = ud(u, c.add({ days: 1 })), v = f.length + s.length + p.length;
  if (a && v < 42) {
    const w = 42 - v;
    let C = p[p.length - 1];
    C || (C = fp(t));
    const S = Array.from({ length: w }, ($, k) => {
      const B = k + 1;
      return C.add({ days: B });
    });
    p.push(...S);
  }
  const m = f.concat(s, p), g = l1(m, 7);
  return {
    value: t,
    cells: m,
    rows: g
  };
}
function Fa(e) {
  const { numberOfMonths: t, dateObj: n, ...a } = e, r = [];
  if (!t || t === 1)
    return r.push(Cu({
      ...a,
      dateObj: n
    })), r;
  r.push(Cu({
    ...a,
    dateObj: n
  }));
  for (let o = 1; o < t; o++) {
    const s = n.add({ months: o });
    r.push(Cu({
      ...a,
      dateObj: s
    }));
  }
  return r;
}
function i1(e, t = {}) {
  const n = O(e);
  function a() {
    return n.value;
  }
  function r(w) {
    n.value = w;
  }
  function o(w, C) {
    return new ta(n.value, {
      ...t,
      ...C
    }).format(w);
  }
  function s(w, C = !0) {
    return e1(w) && C ? o($n(w), {
      dateStyle: "long",
      timeStyle: "long"
    }) : o($n(w), { dateStyle: "long" });
  }
  function i(w, C = {}) {
    return new ta(n.value, {
      ...t,
      month: "long",
      year: "numeric",
      ...C
    }).format(w);
  }
  function u(w, C = {}) {
    return new ta(n.value, {
      ...t,
      month: "long",
      ...C
    }).format(w);
  }
  function d() {
    const w = ch(Wr());
    return [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12
    ].map((S) => ({
      label: u($n(w.set({ month: S }))),
      value: S
    }));
  }
  function c(w, C = {}) {
    return new ta(n.value, {
      ...t,
      year: "numeric",
      ...C
    }).format(w);
  }
  function f(w, C) {
    return mc(w) ? new ta(n.value, {
      ...t,
      ...C,
      timeZone: w.timeZone
    }).formatToParts($n(w)) : new ta(n.value, {
      ...t,
      ...C
    }).formatToParts($n(w));
  }
  function p(w, C = "narrow") {
    return new ta(n.value, {
      ...t,
      weekday: C
    }).format(w);
  }
  function v(w) {
    const S = new ta(n.value, {
      ...t,
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(w).find(($) => $.type === "dayPeriod")?.value;
    return S === "PM" || S === "p.m." ? "PM" : "AM";
  }
  const m = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function g(w, C, S = {}) {
    const $ = {
      ...m,
      ...S
    }, B = f(w, $).find((D) => D.type === C);
    return B ? B.value : "";
  }
  return {
    setLocale: r,
    getLocale: a,
    fullMonth: u,
    fullYear: c,
    fullMonthAndYear: i,
    toParts: f,
    custom: o,
    part: g,
    dayPeriod: v,
    selectedDate: s,
    dayOfWeek: p,
    getMonths: d
  };
}
function gt(e) {
  const t = ns({ dir: O("ltr") });
  return q(() => e?.value || t.dir?.value || "ltr");
}
function Gt(e) {
  const t = Pt(), n = t?.type.emits, a = {};
  return n?.length || console.warn(`No emitted event found. Please check component: ${t?.type.__name}`), n?.forEach((r) => {
    a[r0(gl(r))] = (...o) => e(r, ...o);
  }), a;
}
function Ah(e) {
  const t = q(() => l(e)), n = q(() => new Intl.Collator("en", {
    usage: "search",
    ...t.value
  }));
  return {
    startsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(0, i.length), i) === 0),
    endsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(-i.length), i) === 0),
    contains: (s, i) => {
      if (i.length === 0) return !0;
      s = s.normalize("NFC"), i = i.normalize("NFC");
      let u = 0;
      const d = i.length;
      for (; u + d <= s.length; u++) {
        const c = s.slice(u, u + d);
        if (n.value.compare(i, c) === 0) return !0;
      }
      return !1;
    }
  };
}
let Su = 0;
function hc() {
  Ae((e) => {
    if (!tn) return;
    const t = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", t[0] ?? Mp()), document.body.insertAdjacentElement("beforeend", t[1] ?? Mp()), Su++, e(() => {
      Su === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((n) => n.remove()), Su--;
    });
  });
}
function Mp() {
  const e = document.createElement("span");
  return e.setAttribute("data-reka-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
function On(e) {
  return q(() => pe(e) ? !!Wt(e)?.closest("form") : !0);
}
function j() {
  const e = Pt(), t = O(), n = q(() => ["#text", "#comment"].includes(t.value?.$el.nodeName) ? t.value?.$el.nextElementSibling : Wt(t)), a = Object.assign({}, e.exposed), r = {};
  for (const s in e.props) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[s]
  });
  if (Object.keys(a).length > 0) for (const s in a) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => a[s]
  });
  Object.defineProperty(r, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = r;
  function o(s) {
    if (t.value = s, !!s && (Object.defineProperty(r, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s instanceof Element ? s : s.$el
    }), !(s instanceof Element) && !Object.hasOwn(s, "$el"))) {
      const i = s.$.exposed, u = Object.assign({}, r);
      for (const d in i) Object.defineProperty(u, d, {
        enumerable: !0,
        configurable: !0,
        get: () => i[d]
      });
      e.exposed = u;
    }
  }
  return {
    forwardRef: o,
    currentRef: t,
    currentElement: n
  };
}
function he(e) {
  const t = Pt(), n = Object.keys(t?.type.props ?? {}).reduce((r, o) => {
    const s = (t?.type.props[o]).default;
    return s !== void 0 && (r[o] = s), r;
  }, {}), a = Hn(e);
  return q(() => {
    const r = {}, o = t?.vnode.props ?? {};
    return Object.keys(o).forEach((s) => {
      r[gl(s)] = o[s];
    }), Object.keys({
      ...n,
      ...r
    }).reduce((s, i) => (a.value[i] !== void 0 && (s[i] = a.value[i]), s), {});
  });
}
function ve(e, t) {
  const n = he(e), a = t ? Gt(t) : {};
  return q(() => ({
    ...n.value,
    ...a
  }));
}
function Oh(e, t) {
  const n = rs(!1, 300);
  va(() => {
    n.value = !1;
  });
  const a = O(null), r = $r();
  function o() {
    a.value = null, n.value = !1;
  }
  function s(i, u) {
    const d = i.currentTarget, c = {
      x: i.clientX,
      y: i.clientY
    }, f = u1(c, d.getBoundingClientRect()), p = d1(c, f), v = c1(u.getBoundingClientRect()), m = p1([...p, ...v]);
    a.value = m, n.value = !0;
  }
  return Ae((i) => {
    if (e.value && t.value) {
      const u = (c) => s(c, t.value), d = (c) => s(c, e.value);
      e.value.addEventListener("pointerleave", u), t.value.addEventListener("pointerleave", d), i(() => {
        e.value?.removeEventListener("pointerleave", u), t.value?.removeEventListener("pointerleave", d);
      });
    }
  }), Ae((i) => {
    if (a.value) {
      const u = (d) => {
        if (!a.value || !(d.target instanceof Element)) return;
        const c = d.target, f = {
          x: d.clientX,
          y: d.clientY
        }, p = e.value?.contains(c) || t.value?.contains(c), v = !f1(f, a.value), m = !!c.closest("[data-grace-area-trigger]");
        p ? o() : (v || m) && (o(), r.trigger());
      };
      e.value?.ownerDocument.addEventListener("pointermove", u), i(() => e.value?.ownerDocument.removeEventListener("pointermove", u));
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: r.on
  };
}
function u1(e, t) {
  const n = Math.abs(t.top - e.y), a = Math.abs(t.bottom - e.y), r = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, a, r, o)) {
    case o:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case a:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function d1(e, t, n = 5) {
  const a = [];
  switch (t) {
    case "top":
      a.push({
        x: e.x - n,
        y: e.y + n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "bottom":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y - n
      });
      break;
    case "left":
      a.push({
        x: e.x + n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "right":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x - n,
        y: e.y + n
      });
      break;
  }
  return a;
}
function c1(e) {
  const { top: t, right: n, bottom: a, left: r } = e;
  return [
    {
      x: r,
      y: t
    },
    {
      x: n,
      y: t
    },
    {
      x: n,
      y: a
    },
    {
      x: r,
      y: a
    }
  ];
}
function f1(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function p1(e) {
  const t = e.slice();
  return t.sort((n, a) => n.x < a.x ? -1 : n.x > a.x ? 1 : n.y < a.y ? -1 : n.y > a.y ? 1 : 0), v1(t);
}
function v1(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) t.pop();
      else break;
    }
    t.push(r);
  }
  t.pop();
  const n = [];
  for (let a = e.length - 1; a >= 0; a--) {
    const r = e[a];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) n.pop();
      else break;
    }
    n.push(r);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var m1 = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, yr = /* @__PURE__ */ new WeakMap(), Es = /* @__PURE__ */ new WeakMap(), Ts = {}, $u = 0, Ih = function(e) {
  return e && (e.host || Ih(e.parentNode));
}, h1 = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var a = Ih(n);
    return a && e.contains(a) ? a : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, g1 = function(e, t, n, a) {
  var r = h1(t, Array.isArray(e) ? e : [e]);
  Ts[n] || (Ts[n] = /* @__PURE__ */ new WeakMap());
  var o = Ts[n], s = [], i = /* @__PURE__ */ new Set(), u = new Set(r), d = function(f) {
    !f || i.has(f) || (i.add(f), d(f.parentNode));
  };
  r.forEach(d);
  var c = function(f) {
    !f || u.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (i.has(p))
        c(p);
      else
        try {
          var v = p.getAttribute(a), m = v !== null && v !== "false", g = (yr.get(p) || 0) + 1, w = (o.get(p) || 0) + 1;
          yr.set(p, g), o.set(p, w), s.push(p), g === 1 && m && Es.set(p, !0), w === 1 && p.setAttribute(n, "true"), m || p.setAttribute(a, "true");
        } catch (C) {
          console.error("aria-hidden: cannot operate on ", p, C);
        }
    });
  };
  return c(t), i.clear(), $u++, function() {
    s.forEach(function(f) {
      var p = yr.get(f) - 1, v = o.get(f) - 1;
      yr.set(f, p), o.set(f, v), p || (Es.has(f) || f.removeAttribute(a), Es.delete(f)), v || f.removeAttribute(n);
    }), $u--, $u || (yr = /* @__PURE__ */ new WeakMap(), yr = /* @__PURE__ */ new WeakMap(), Es = /* @__PURE__ */ new WeakMap(), Ts = {});
  };
}, y1 = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), r = m1(e);
  return r ? (a.push.apply(a, Array.from(r.querySelectorAll("[aria-live], script"))), g1(a, r, n, "aria-hidden")) : function() {
    return null;
  };
};
function ls(e) {
  let t;
  me(() => Wt(e), (n) => {
    n ? t = y1(n) : t && t();
  }), nt(() => {
    t && t();
  });
}
let b1 = 0;
function Ge(e, t = "reka") {
  if (e) return e;
  if ("useId" in ap) return `${t}-${ap.useId?.()}`;
  const n = ns({ useId: void 0 });
  return n.useId ? `${t}-${n.useId()}` : `${t}-${++b1}`;
}
function is() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function gc(e) {
  const t = ns({ locale: O("en") });
  return q(() => e?.value || t.locale?.value || "en");
}
function Rh(e) {
  const t = O(), n = q(() => t.value?.width ?? 0), a = q(() => t.value?.height ?? 0);
  return Ce(() => {
    const r = Wt(e);
    if (r) {
      t.value = {
        width: r.offsetWidth,
        height: r.offsetHeight
      };
      const o = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length) return;
        const i = s[0];
        let u, d;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          u = f.inlineSize, d = f.blockSize;
        } else
          u = r.offsetWidth, d = r.offsetHeight;
        t.value = {
          width: u,
          height: d
        };
      });
      return o.observe(r, { box: "border-box" }), () => o.unobserve(r);
    } else t.value = void 0;
  }), {
    width: n,
    height: a
  };
}
function Vh(e, t) {
  const n = O(e);
  function a(o) {
    return t[n.value][o] ?? n.value;
  }
  return {
    state: n,
    dispatch: (o) => {
      n.value = a(o);
    }
  };
}
function pi(e) {
  const t = rs("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (r, o) => {
      t.value = t.value + r;
      {
        const s = ot(), i = o.map((p) => ({
          ...p,
          textValue: p.value?.textValue ?? p.ref.textContent?.trim() ?? ""
        })), u = i.find((p) => p.ref === s), d = i.map((p) => p.textValue), c = _1(d, t.value, u?.textValue), f = i.find((p) => p.textValue === c);
        return f && f.ref.focus(), f?.ref;
      }
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function yc(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
function _1(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = yc(e, Math.max(o, 0));
  r.length === 1 && (s = s.filter((d) => d !== n));
  const u = s.find((d) => d.toLowerCase().startsWith(r.toLowerCase()));
  return u !== n ? u : void 0;
}
function w1(e, t) {
  const n = O({}), a = O("none"), r = O(e), o = e.value ? "mounted" : "unmounted";
  let s;
  const i = t.value?.ownerDocument.defaultView ?? Ta, { state: u, dispatch: d } = Vh(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), c = (w) => {
    if (tn) {
      const C = new CustomEvent(w, {
        bubbles: !1,
        cancelable: !1
      });
      t.value?.dispatchEvent(C);
    }
  };
  me(e, async (w, C) => {
    const S = C !== w;
    if (await Pe(), S) {
      const $ = a.value, k = As(t.value);
      w ? (d("MOUNT"), c("enter"), k === "none" && c("after-enter")) : k === "none" || k === "undefined" || n.value?.display === "none" ? (d("UNMOUNT"), c("leave"), c("after-leave")) : C && $ !== k ? (d("ANIMATION_OUT"), c("leave")) : (d("UNMOUNT"), c("after-leave"));
    }
  }, { immediate: !0 });
  const f = (w) => {
    const C = As(t.value), S = C.includes(CSS.escape(w.animationName)), $ = u.value === "mounted" ? "enter" : "leave";
    if (w.target === t.value && S && (c(`after-${$}`), d("ANIMATION_END"), !r.value)) {
      const k = t.value.style.animationFillMode;
      t.value.style.animationFillMode = "forwards", s = i?.setTimeout(() => {
        t.value?.style.animationFillMode === "forwards" && (t.value.style.animationFillMode = k);
      });
    }
    w.target === t.value && C === "none" && d("ANIMATION_END");
  }, p = (w) => {
    w.target === t.value && (a.value = As(t.value));
  }, v = me(t, (w, C) => {
    w ? (n.value = getComputedStyle(w), w.addEventListener("animationstart", p), w.addEventListener("animationcancel", f), w.addEventListener("animationend", f)) : (d("ANIMATION_END"), s !== void 0 && i?.clearTimeout(s), C?.removeEventListener("animationstart", p), C?.removeEventListener("animationcancel", f), C?.removeEventListener("animationend", f));
  }, { immediate: !0 }), m = me(u, () => {
    const w = As(t.value);
    a.value = u.value === "mounted" ? w : "none";
  });
  return nt(() => {
    v(), m();
  }), { isPresent: q(() => ["mounted", "unmountSuspended"].includes(u.value)) };
}
function As(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var Ct = b({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: t, expose: n }) {
    const { present: a, forceMount: r } = Me(e), o = O(), { isPresent: s } = w1(a, o);
    n({ present: s });
    let i = t.default({ present: s.value });
    i = nc(i || []);
    const u = Pt();
    if (i && i?.length > 1) {
      const d = u?.parent?.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${d}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((c) => `  - ${c}`).join(`
`)
      ].join(`
`));
    }
    return () => r.value || a.value || s.value ? en(t.default({ present: s.value })[0], { ref: (d) => {
      const c = Wt(d);
      return typeof c?.hasAttribute > "u" || (c?.hasAttribute("data-reka-popper-content-wrapper") ? o.value = c.firstElementChild : o.value = c), c;
    } }) : null;
  }
});
const $l = b({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: t, slots: n }) {
    return () => {
      if (!n.default) return null;
      const a = nc(n.default()), r = a.findIndex((u) => u.type !== o0);
      if (r === -1) return a;
      const o = a[r];
      delete o.props?.ref;
      const s = o.props ? A(t, o.props) : t, i = s0({
        ...o,
        props: {}
      }, s);
      return a.length === 1 ? i : (a[r] = i, a);
    };
  }
}), x1 = [
  "area",
  "img",
  "input"
], X = b({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: t, slots: n }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && x1.includes(a) ? () => en(a, t) : a !== "template" ? () => en(e.as, t, { default: n.default }) : () => en($l, t, { default: n.default });
  }
});
function zt() {
  const e = O(), t = q(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : Wt(e));
  return {
    primitiveElement: e,
    currentElement: t
  };
}
const [Fh, C1] = Se("CollapsibleRoot");
var S1 = /* @__PURE__ */ b({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = Ve(a, "open", n, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), { disabled: s, unmountOnHide: i } = Me(a);
    return C1({
      contentId: "",
      disabled: s,
      open: o,
      unmountOnHide: i,
      onOpenToggle: () => {
        s.value || (o.value = !o.value);
      }
    }), t({ open: o }), j(), (u, d) => (h(), x(l(X), {
      as: u.as,
      "as-child": a.asChild,
      "data-state": l(o) ? "open" : "closed",
      "data-disabled": l(s) ? "" : void 0
    }, {
      default: y(() => [_(u.$slots, "default", { open: l(o) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ]));
  }
}), Nh = S1, $1 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["contentFound"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Fh();
    r.contentId ||= Ge(void 0, "reka-collapsible-content");
    const o = O(), { forwardRef: s, currentElement: i } = j(), u = O(0), d = O(0), c = q(() => r.open.value), f = O(c.value), p = O();
    me(() => [c.value, o.value?.present], async () => {
      await Pe();
      const m = i.value;
      if (!m) return;
      p.value = p.value || {
        transitionDuration: m.style.transitionDuration,
        animationName: m.style.animationName
      }, m.style.transitionDuration = "0s", m.style.animationName = "none";
      const g = m.getBoundingClientRect();
      d.value = g.height, u.value = g.width, f.value || (m.style.transitionDuration = p.value.transitionDuration, m.style.animationName = p.value.animationName);
    }, { immediate: !0 });
    const v = q(() => f.value && r.open.value);
    return Ce(() => {
      requestAnimationFrame(() => {
        f.value = !1;
      });
    }), Lt(i, "beforematch", (m) => {
      requestAnimationFrame(() => {
        r.onOpenToggle(), a("contentFound");
      });
    }), (m, g) => (h(), x(l(Ct), {
      ref_key: "presentRef",
      ref: o,
      present: m.forceMount || l(r).open.value,
      "force-mount": !0
    }, {
      default: y(({ present: w }) => [N(l(X), A(m.$attrs, {
        id: l(r).contentId,
        ref: l(s),
        "as-child": n.asChild,
        as: m.as,
        hidden: w ? void 0 : l(r).unmountOnHide.value ? "" : "until-found",
        "data-state": v.value ? void 0 : l(r).open.value ? "open" : "closed",
        "data-disabled": l(r).disabled?.value ? "" : void 0,
        style: {
          "--reka-collapsible-content-height": `${d.value}px`,
          "--reka-collapsible-content-width": `${u.value}px`
        }
      }), {
        default: y(() => [!l(r).unmountOnHide.value || w ? _(m.$slots, "default", { key: 0 }) : qe("v-if", !0)]),
        _: 2
      }, 1040, [
        "id",
        "as-child",
        "as",
        "hidden",
        "data-state",
        "data-disabled",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Lh = $1, B1 = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Fh();
    return (a, r) => (h(), x(l(X), {
      type: a.as === "button" ? "button" : void 0,
      as: a.as,
      "as-child": t.asChild,
      "aria-controls": l(n).contentId,
      "aria-expanded": l(n).open.value,
      "data-state": l(n).open.value ? "open" : "closed",
      "data-disabled": l(n).disabled?.value ? "" : void 0,
      disabled: l(n).disabled?.value,
      onClick: l(n).onOpenToggle
    }, {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "aria-controls",
      "aria-expanded",
      "data-state",
      "data-disabled",
      "disabled",
      "onClick"
    ]));
  }
}), zh = B1;
function k1({ type: e, defaultValue: t, modelValue: n }) {
  const a = n || t;
  return n !== void 0 || t !== void 0 ? Array.isArray(a) ? "multiple" : "single" : e ?? "single";
}
function P1({ type: e, defaultValue: t, modelValue: n }) {
  return e || k1({
    type: e,
    defaultValue: t,
    modelValue: n
  });
}
function D1({ type: e, defaultValue: t }) {
  return t !== void 0 ? t : e === "single" ? void 0 : [];
}
function Hh(e, t) {
  const n = q(() => P1(e)), a = Ve(e, "modelValue", t, {
    defaultValue: D1(e),
    passive: e.modelValue === void 0,
    deep: !0
  });
  function r(s) {
    if (n.value === "single") a.value = Mn(s, a.value) ? void 0 : s;
    else {
      const i = Array.isArray(a.value) ? [...a.value || []] : [a.value].filter(Boolean);
      if (yl(i, s)) {
        const u = i.findIndex((d) => Mn(d, s));
        i.splice(u, 1);
      } else i.push(s);
      a.value = i;
    }
  }
  const o = q(() => n.value === "single");
  return {
    modelValue: a,
    changeModelValue: r,
    isSingle: o
  };
}
const [vi, M1] = Se("AccordionRoot");
var q1 = /* @__PURE__ */ b({
  __name: "AccordionRoot",
  props: {
    collapsible: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, disabled: o, unmountOnHide: s } = Me(n), i = gt(r), { modelValue: u, changeModelValue: d, isSingle: c } = Hh(n, a), { forwardRef: f, currentElement: p } = j();
    return M1({
      disabled: o,
      direction: i,
      orientation: n.orientation,
      parentElement: p,
      isSingle: c,
      collapsible: n.collapsible,
      modelValue: u,
      changeModelValue: d,
      unmountOnHide: s
    }), (v, m) => (h(), x(l(X), {
      ref: l(f),
      "as-child": v.asChild,
      as: v.as
    }, {
      default: y(() => [_(v.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), E1 = q1, dd = /* @__PURE__ */ (function(e) {
  return e.Open = "open", e.Closed = "closed", e;
})(dd || {});
const [bc, T1] = Se("AccordionItem");
var A1 = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: String,
      required: !0
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = vi(), r = q(() => a.isSingle.value ? n.value === a.modelValue.value : Array.isArray(a.modelValue.value) && a.modelValue.value.includes(n.value)), o = q(() => a.disabled.value || n.disabled), s = q(() => o.value ? "" : void 0), i = q(() => r.value ? dd.Open : dd.Closed);
    t({
      open: r,
      dataDisabled: s
    });
    const { currentRef: u, currentElement: d } = j();
    T1({
      open: r,
      dataState: i,
      disabled: o,
      dataDisabled: s,
      triggerId: "",
      currentRef: u,
      currentElement: d,
      value: q(() => n.value)
    });
    function c(f) {
      const p = f.target;
      if (Array.from(a.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []).findIndex((g) => g === p) === -1) return null;
      rr(f, p, a.parentElement.value, {
        arrowKeyOptions: a.orientation,
        dir: a.direction.value,
        focus: !0
      });
    }
    return (f, p) => (h(), x(l(Nh), {
      "data-orientation": l(a).orientation,
      "data-disabled": s.value,
      "data-state": i.value,
      disabled: o.value,
      open: r.value,
      as: n.as,
      "as-child": n.asChild,
      "unmount-on-hide": n.unmountOnHide ?? l(a).unmountOnHide.value,
      onKeydown: Je(c, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end"
      ])
    }, {
      default: y(() => [_(f.$slots, "default", { open: r.value })]),
      _: 3
    }, 8, [
      "data-orientation",
      "data-disabled",
      "data-state",
      "disabled",
      "open",
      "as",
      "as-child",
      "unmount-on-hide"
    ]));
  }
}), O1 = A1, I1 = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = vi(), a = bc();
    return j(), (r, o) => (h(), x(l(Lh), {
      role: "region",
      "as-child": t.asChild,
      as: r.as,
      "force-mount": t.forceMount,
      "aria-labelledby": l(a).triggerId,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      style: {
        "--reka-accordion-content-width": "var(--reka-collapsible-content-width)",
        "--reka-accordion-content-height": "var(--reka-collapsible-content-height)"
      },
      onContentFound: o[0] || (o[0] = (s) => l(n).changeModelValue(l(a).value.value))
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "force-mount",
      "aria-labelledby",
      "data-state",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), R1 = I1, V1 = /* @__PURE__ */ b({
  __name: "AccordionHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h3"
    }
  },
  setup(e) {
    const t = e, n = vi(), a = bc();
    return j(), (r, o) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-orientation",
      "data-state",
      "data-disabled"
    ]));
  }
}), F1 = V1, N1 = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = vi(), a = bc();
    a.triggerId ||= Ge(void 0, "reka-accordion-trigger");
    function r() {
      const o = n.isSingle.value && a.open.value && !n.collapsible;
      a.disabled.value || o || n.changeModelValue(a.value.value);
    }
    return (o, s) => (h(), x(l(zh), {
      id: l(a).triggerId,
      ref: l(a).currentRef,
      "data-reka-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-disabled": l(a).disabled.value || void 0,
      "aria-expanded": l(a).open.value || !1,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      disabled: l(a).disabled.value,
      onClick: r
    }, {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "aria-disabled",
      "aria-expanded",
      "data-disabled",
      "data-orientation",
      "data-state",
      "disabled"
    ]));
  }
}), L1 = N1;
const [Xn, z1] = Se("DialogRoot");
var H1 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = O(), s = O(), { modal: i } = Me(n);
    return z1({
      open: r,
      modal: i,
      openModal: () => {
        r.value = !0;
      },
      onOpenChange: (u) => {
        r.value = u;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: o,
      contentElement: s
    }), (u, d) => _(u.$slots, "default", {
      open: l(r),
      close: () => r.value = !1
    });
  }
}), mi = H1, U1 = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Xn();
    return (a, r) => (h(), x(l(X), A(t, {
      type: a.as === "button" ? "button" : void 0,
      onClick: r[0] || (r[0] = (o) => l(n).onOpenChange(!1))
    }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), Aa = U1;
const j1 = "dismissableLayer.pointerDownOutside", W1 = "dismissableLayer.focusOutside";
function Uh(e, t) {
  const n = t.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), r = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(n && (a === n || r.indexOf(a) < r.indexOf(n)));
}
function G1(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = O(!1), o = O(() => {
  });
  return Ae((s) => {
    if (!tn || !pe(n)) return;
    const i = async (d) => {
      const c = d.target;
      if (!(!t?.value || !c)) {
        if (Uh(t.value, c)) {
          r.value = !1;
          return;
        }
        if (d.target && !r.value) {
          let p = function() {
            ts(j1, e, f);
          };
          const f = { originalEvent: d };
          d.pointerType === "touch" ? (a.removeEventListener("click", o.value), o.value = p, a.addEventListener("click", o.value, { once: !0 })) : p();
        } else a.removeEventListener("click", o.value);
        r.value = !1;
      }
    }, u = window.setTimeout(() => {
      a.addEventListener("pointerdown", i);
    }, 0);
    s(() => {
      window.clearTimeout(u), a.removeEventListener("pointerdown", i), a.removeEventListener("click", o.value);
    });
  }), { onPointerDownCapture: () => {
    pe(n) && (r.value = !0);
  } };
}
function K1(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = O(!1);
  return Ae((o) => {
    if (!tn || !pe(n)) return;
    const s = async (i) => {
      if (!t?.value) return;
      await Pe(), await Pe();
      const u = i.target;
      !t.value || !u || Uh(t.value, u) || i.target && !r.value && ts(W1, e, { originalEvent: i });
    };
    a.addEventListener("focusin", s), o(() => a.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => {
      pe(n) && (r.value = !0);
    },
    onBlurCapture: () => {
      pe(n) && (r.value = !1);
    }
  };
}
const hn = jt({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  originalBodyPointerEvents: void 0,
  branches: /* @__PURE__ */ new Set()
});
var Y1 = /* @__PURE__ */ b({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = q(() => o.value?.ownerDocument ?? globalThis.document), i = q(() => hn.layersRoot), u = q(() => o.value ? Array.from(i.value).indexOf(o.value) : -1), d = q(() => hn.layersWithOutsidePointerEventsDisabled.size > 0), c = q(() => {
      const v = Array.from(i.value), [m] = [...hn.layersWithOutsidePointerEventsDisabled].slice(-1), g = v.indexOf(m);
      return u.value >= g;
    }), f = G1(async (v) => {
      const m = [...hn.branches].some((g) => g?.contains(v.target));
      !c.value || m || (a("pointerDownOutside", v), a("interactOutside", v), await Pe(), v.defaultPrevented || a("dismiss"));
    }, o), p = K1((v) => {
      [...hn.branches].some((g) => g?.contains(v.target)) || (a("focusOutside", v), a("interactOutside", v), v.defaultPrevented || a("dismiss"));
    }, o);
    return G0("Escape", (v) => {
      u.value === i.value.size - 1 && (a("escapeKeyDown", v), v.defaultPrevented || a("dismiss"));
    }), Ae((v) => {
      o.value && (n.disableOutsidePointerEvents && (hn.layersWithOutsidePointerEventsDisabled.size === 0 && (hn.originalBodyPointerEvents = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), hn.layersWithOutsidePointerEventsDisabled.add(o.value)), i.value.add(o.value), v(() => {
        n.disableOutsidePointerEvents && hn.layersWithOutsidePointerEventsDisabled.size === 1 && !Pn(hn.originalBodyPointerEvents) && (s.value.body.style.pointerEvents = hn.originalBodyPointerEvents);
      }));
    }), Ae((v) => {
      v(() => {
        o.value && (i.value.delete(o.value), hn.layersWithOutsidePointerEventsDisabled.delete(o.value));
      });
    }), (v, m) => (h(), x(l(X), {
      ref: l(r),
      "as-child": v.asChild,
      as: v.as,
      "data-dismissable-layer": "",
      style: dt({ pointerEvents: d.value ? c.value ? "auto" : "none" : void 0 }),
      onFocusCapture: l(p).onFocusCapture,
      onBlurCapture: l(p).onBlurCapture,
      onPointerdownCapture: l(f).onPointerDownCapture
    }, {
      default: y(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), Oa = Y1;
const X1 = P0(() => O([]));
function J1() {
  const e = X1();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && n?.pause(), e.value = qp(e.value, t), e.value.unshift(t);
    },
    remove(t) {
      e.value = qp(e.value, t), e.value[0]?.resume();
    }
  };
}
function qp(e, t) {
  const n = [...e], a = n.indexOf(t);
  return a !== -1 && n.splice(a, 1), n;
}
function Z1(e) {
  return e.filter((t) => t.tagName !== "A");
}
const Bu = "focusScope.autoFocusOnMount", ku = "focusScope.autoFocusOnUnmount", Ep = {
  bubbles: !1,
  cancelable: !0
};
function Q1(e, { select: t = !1 } = {}) {
  const n = ot();
  for (const a of e)
    if (xa(a, { select: t }), ot() !== n) return !0;
}
function ex(e) {
  const t = jh(e), n = Tp(t, e), a = Tp(t.reverse(), e);
  return [n, a];
}
function jh(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Tp(e, t) {
  for (const n of e) if (!tx(n, { upTo: t })) return n;
}
function tx(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function nx(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function xa(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = ot();
    e.focus({ preventScroll: !0 }), e !== n && nx(e) && t && e.select();
  }
}
var ax = /* @__PURE__ */ b({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    trapped: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, { currentRef: r, currentElement: o } = j(), s = O(null), i = J1(), u = jt({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Ae((c) => {
      if (!tn) return;
      const f = o.value;
      if (!n.trapped) return;
      function p(w) {
        if (u.paused || !f) return;
        const C = w.target;
        f.contains(C) ? s.value = C : xa(s.value, { select: !0 });
      }
      function v(w) {
        if (u.paused || !f) return;
        const C = w.relatedTarget;
        C !== null && (f.contains(C) || xa(s.value, { select: !0 }));
      }
      function m(w) {
        f.contains(s.value) || xa(f);
      }
      document.addEventListener("focusin", p), document.addEventListener("focusout", v);
      const g = new MutationObserver(m);
      f && g.observe(f, {
        childList: !0,
        subtree: !0
      }), c(() => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", v), g.disconnect();
      });
    }), Ae(async (c) => {
      const f = o.value;
      if (await Pe(), !f) return;
      i.add(u);
      const p = ot();
      if (!f.contains(p)) {
        const m = new CustomEvent(Bu, Ep);
        f.addEventListener(Bu, (g) => a("mountAutoFocus", g)), f.dispatchEvent(m), m.defaultPrevented || (Q1(Z1(jh(f)), { select: !0 }), ot() === p && xa(f));
      }
      c(() => {
        f.removeEventListener(Bu, (w) => a("mountAutoFocus", w));
        const m = new CustomEvent(ku, Ep), g = (w) => {
          a("unmountAutoFocus", w);
        };
        f.addEventListener(ku, g), f.dispatchEvent(m), setTimeout(() => {
          m.defaultPrevented || xa(p ?? document.body, { select: !0 }), f.removeEventListener(ku, g), i.remove(u);
        }, 0);
      });
    });
    function d(c) {
      if (!n.loop && !n.trapped || u.paused) return;
      const f = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, p = ot();
      if (f && p) {
        const v = c.currentTarget, [m, g] = ex(v);
        m && g ? !c.shiftKey && p === g ? (c.preventDefault(), n.loop && xa(m, { select: !0 })) : c.shiftKey && p === m && (c.preventDefault(), n.loop && xa(g, { select: !0 })) : p === v && c.preventDefault();
      }
    }
    return (c, f) => (h(), x(l(X), {
      ref_key: "currentRef",
      ref: r,
      tabindex: "-1",
      "as-child": c.asChild,
      as: c.as,
      onKeydown: d
    }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), hi = ax;
const rx = "menu.itemSelect", cd = ["Enter", " "], ox = [
  "ArrowDown",
  "PageUp",
  "Home"
], Wh = [
  "ArrowUp",
  "PageDown",
  "End"
], sx = [...ox, ...Wh], lx = {
  ltr: [...cd, "ArrowRight"],
  rtl: [...cd, "ArrowLeft"]
}, ix = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function _c(e) {
  return e ? "open" : "closed";
}
function Bl(e) {
  return e === "indeterminate";
}
function wc(e) {
  return Bl(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function fd(e) {
  const t = ot();
  for (const n of e)
    if (n === t || (n.focus(), ot() !== t)) return;
}
function ux(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function dx(e, t) {
  if (!t) return !1;
  const n = {
    x: e.clientX,
    y: e.clientY
  };
  return ux(n, t);
}
function Ao(e) {
  return e.pointerType === "mouse";
}
var cx = /* @__PURE__ */ b({
  __name: "DialogContentImpl",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xn(), { forwardRef: o, currentElement: s } = j();
    return r.titleId ||= Ge(void 0, "reka-dialog-title"), r.descriptionId ||= Ge(void 0, "reka-dialog-description"), Ce(() => {
      r.contentElement = s, ot() !== document.body && (r.triggerElement.value = ot());
    }), (i, u) => (h(), x(l(hi), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [N(l(Oa), A({
        id: l(r).contentId,
        ref: l(o),
        as: i.as,
        "as-child": i.asChild,
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        role: "dialog",
        "aria-describedby": l(r).descriptionId,
        "aria-labelledby": l(r).titleId,
        "data-state": l(_c)(l(r).open.value)
      }, i.$attrs, {
        onDismiss: u[0] || (u[0] = (d) => l(r).onOpenChange(!1)),
        onEscapeKeyDown: u[1] || (u[1] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[2] || (u[2] = (d) => a("focusOutside", d)),
        onInteractOutside: u[3] || (u[3] = (d) => a("interactOutside", d)),
        onPointerDownOutside: u[4] || (u[4] = (d) => a("pointerDownOutside", d))
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "as",
        "as-child",
        "disable-outside-pointer-events",
        "aria-describedby",
        "aria-labelledby",
        "data-state"
      ])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Gh = cx, fx = /* @__PURE__ */ b({
  __name: "DialogContentModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xn(), o = Gt(a), { forwardRef: s, currentElement: i } = j();
    return ls(i), (u, d) => (h(), x(Gh, A({
      ...n,
      ...l(o)
    }, {
      ref: l(s),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (c.preventDefault(), l(r).triggerElement.value?.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0;
        (f.button === 2 || p) && c.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (c) => {
        c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), px = fx, vx = /* @__PURE__ */ b({
  __name: "DialogContentNonModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    j();
    const o = Xn(), s = O(!1), i = O(!1);
    return (u, d) => (h(), x(Gh, A({
      ...n,
      ...l(r)
    }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (s.value || l(o).triggerElement.value?.focus(), c.preventDefault()), s.value = !1, i.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = (c) => {
        c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const f = c.target;
        l(o).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && i.value && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), mx = vx, hx = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xn(), o = Gt(a), { forwardRef: s } = j();
    return (i, u) => (h(), x(l(Ct), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [l(r).modal.value ? (h(), x(px, A({
        key: 0,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(mx, A({
        key: 1,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), us = hx, gx = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Xn();
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).descriptionId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), gi = gx, yx = /* @__PURE__ */ b({
  __name: "DialogOverlayImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Xn();
    return os(!0), j(), (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": l(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state"
    ]));
  }
}), bx = yx, _x = /* @__PURE__ */ b({
  __name: "DialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Xn(), { forwardRef: n } = j();
    return (a, r) => l(t)?.modal.value ? (h(), x(l(Ct), {
      key: 0,
      present: a.forceMount || l(t).open.value
    }, {
      default: y(() => [N(bx, A(a.$attrs, {
        ref: l(n),
        as: a.as,
        "as-child": a.asChild
      }), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, ["as", "as-child"])]),
      _: 3
    }, 8, ["present"])) : qe("v-if", !0);
  }
}), ds = _x, wx = /* @__PURE__ */ b({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: !1,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = oc();
    return (n, a) => l(t) || n.forceMount ? (h(), x(di, {
      key: 0,
      to: n.to,
      disabled: n.disabled,
      defer: n.defer
    }, [_(n.$slots, "default")], 8, [
      "to",
      "disabled",
      "defer"
    ])) : qe("v-if", !0);
  }
}), Ia = wx, xx = /* @__PURE__ */ b({
  __name: "DialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), yi = xx, Cx = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e, n = Xn();
    return j(), (a, r) => (h(), x(l(X), A(t, { id: l(n).titleId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), bi = Cx, Sx = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Xn(), { forwardRef: a, currentElement: r } = j();
    return n.contentId ||= Ge(void 0, "reka-dialog-content"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), x(l(X), A(t, {
      ref: l(a),
      type: o.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": l(n).open.value || !1,
      "aria-controls": l(n).open.value ? l(n).contentId : void 0,
      "data-state": l(n).open.value ? "open" : "closed",
      onClick: l(n).onOpenToggle
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "onClick"
    ]));
  }
}), _i = Sx, $x = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Aa), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Bx = $x;
const [kx, Px] = Se("AlertDialogContent");
var Dx = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    j();
    const o = O();
    return Px({ onCancelElementChange: (s) => {
      o.value = s;
    } }), (s, i) => (h(), x(l(us), A({
      ...n,
      ...l(r)
    }, {
      role: "alertdialog",
      onPointerDownOutside: i[0] || (i[0] = Ye(() => {
      }, ["prevent"])),
      onInteractOutside: i[1] || (i[1] = Ye(() => {
      }, ["prevent"])),
      onOpenAutoFocus: i[2] || (i[2] = () => {
        Pe(() => {
          o.value?.focus({ preventScroll: !0 });
        });
      })
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Mx = Dx, qx = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = kx(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onCancelElementChange(r.value);
    }), (o, s) => (h(), x(l(Aa), A(t, { ref: l(a) }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ex = qx, Tx = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(gi), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ax = Tx, Ox = /* @__PURE__ */ b({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(ds), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ix = Ox, Rx = /* @__PURE__ */ b({
  __name: "AlertDialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Vx = Rx, Fx = /* @__PURE__ */ b({
  __name: "AlertDialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), x(l(mi), A(l(r), { modal: !0 }), {
      default: y((i) => [_(o.$slots, "default", oe(le(i)))]),
      _: 3
    }, 16));
  }
}), Nx = Fx, Lx = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(bi), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zx = Lx, Hx = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(_i), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ux = Hx, jx = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "AspectRatio",
  props: {
    ratio: {
      type: Number,
      required: !1,
      default: 1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = q(() => 1 / t.ratio * 100);
    return (r, o) => (h(), W("div", {
      style: dt(`position: relative; width: 100%; padding-bottom: ${a.value}%`),
      "data-reka-aspect-ratio-wrapper": ""
    }, [N(l(X), A({
      ref: l(n),
      "as-child": r.asChild,
      as: r.as,
      style: {
        position: "absolute",
        inset: "0px"
      }
    }, r.$attrs), {
      default: y(() => [_(r.$slots, "default", { aspect: a.value })]),
      _: 3
    }, 16, ["as-child", "as"])], 4));
  }
}), Wx = jx;
const [Kh, Gx] = Se("AvatarRoot");
var Kx = /* @__PURE__ */ b({
  __name: "AvatarRoot",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return j(), Gx({ imageLoadingStatus: O("idle") }), (t, n) => (h(), x(l(X), {
      "as-child": t.asChild,
      as: t.as
    }, {
      default: y(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), Yx = Kx, Xx = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Kh();
    j();
    const a = O(t.delayMs === void 0);
    return Ae((r) => {
      if (t.delayMs && tn) {
        const o = window.setTimeout(() => {
          a.value = !0;
        }, t.delayMs);
        r(() => {
          window.clearTimeout(o);
        });
      }
    }), (r, o) => a.value && l(n).imageLoadingStatus.value !== "loaded" ? (h(), x(l(X), {
      key: 0,
      "as-child": r.asChild,
      as: r.as
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"])) : qe("v-if", !0);
  }
}), Jx = Xx;
function Ap(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function Zx(e, { referrerPolicy: t, crossOrigin: n } = {}) {
  const a = O(!1), r = O(null), o = q(() => a.value ? (!r.value && tn && (r.value = new window.Image()), r.value) : null), s = O(Ap(o.value, e.value)), i = (u) => () => {
    a.value && (s.value = u);
  };
  return Ce(() => {
    a.value = !0, Ae((u) => {
      const d = o.value;
      if (!d) return;
      s.value = Ap(d, e.value);
      const c = i("loaded"), f = i("error");
      d.addEventListener("load", c), d.addEventListener("error", f), t?.value && (d.referrerPolicy = t.value), typeof n?.value == "string" && (d.crossOrigin = n.value), u(() => {
        d.removeEventListener("load", c), d.removeEventListener("error", f);
      });
    });
  }), nt(() => {
    a.value = !1;
  }), s;
}
var Qx = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {
      type: String,
      required: !0
    },
    referrerPolicy: {
      type: null,
      required: !1
    },
    crossOrigin: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "img"
    }
  },
  emits: ["loadingStatusChange"],
  setup(e, { emit: t }) {
    const n = e, a = t, { src: r, referrerPolicy: o, crossOrigin: s } = Me(n);
    j();
    const i = Kh(), u = Zx(r, {
      referrerPolicy: o,
      crossOrigin: s
    });
    return me(u, (d) => {
      a("loadingStatusChange", d), d !== "idle" && (i.imageLoadingStatus.value = d);
    }, { immediate: !0 }), (d, c) => tc((h(), x(l(X), {
      role: "img",
      "as-child": d.asChild,
      as: d.as,
      src: l(r),
      "referrer-policy": l(o)
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "src",
      "referrer-policy"
    ])), [[l0, l(u) === "loaded"]]);
  }
}), eC = Qx;
function tC(e) {
  function t(a) {
    return Array.isArray(e.date.value) ? e.date.value.some((r) => _t(r, a)) : e.date.value ? _t(e.date.value, a) : !1;
  }
  const n = q(() => {
    if (Array.isArray(e.date.value)) {
      if (!e.date.value.length) return !1;
      for (const a of e.date.value)
        if (e.isDateDisabled?.(a) || e.isDateUnavailable?.(a)) return !0;
    } else {
      if (!e.date.value) return !1;
      if (e.isDateDisabled?.(e.date.value) || e.isDateUnavailable?.(e.date.value)) return !0;
    }
    return !1;
  });
  return {
    isDateSelected: t,
    isInvalid: n
  };
}
function nC(e, t) {
  const n = t(e), a = n.compare(e), r = {};
  return a >= 7 && (r.day = 1), a >= To(e) && (r.month = 1), n.set({ ...r });
}
function aC(e, t) {
  const n = t(e), a = e.compare(n), r = {};
  return a >= 7 && (r.day = 35), a >= To(e) && (r.month = 13), n.set({ ...r });
}
function rC(e, t) {
  return t(e);
}
function oC(e, t) {
  return t(e);
}
function Yh(e) {
  const t = i1(e.locale.value), n = q(() => {
    const g = { calendar: e.placeholder.value.calendar.identifier };
    return e.placeholder.value.calendar.identifier === "gregory" && e.placeholder.value.era === "BC" && (g.era = "short"), g;
  }), a = O(Fa({
    dateObj: e.placeholder.value,
    weekStartsOn: e.weekStartsOn.value,
    locale: e.locale.value,
    fixedWeeks: e.fixedWeeks.value,
    numberOfMonths: e.numberOfMonths.value
  })), r = q(() => a.value.map((g) => g.value));
  function o(g) {
    return !r.value.some((w) => dp(g, w));
  }
  const s = (g) => {
    if (!e.maxValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const w = a.value[a.value.length - 1].value;
    if (!g && !e.nextPage.value) {
      const S = w.add({ months: 1 }).set({ day: 1 });
      return ol(S, e.maxValue.value);
    }
    const C = nC(w, g || e.nextPage.value);
    return ol(C, e.maxValue.value);
  }, i = (g) => {
    if (!e.minValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const w = a.value[0].value;
    if (!g && !e.prevPage.value) {
      const S = w.subtract({ months: 1 }).set({ day: 35 });
      return Ka(S, e.minValue.value);
    }
    const C = aC(w, g || e.prevPage.value);
    return Ka(C, e.minValue.value);
  };
  function u(g) {
    return !!(e.isDateDisabled?.(g) || e.disabled.value || e.maxValue.value && ol(g, e.maxValue.value) || e.minValue.value && Ka(g, e.minValue.value));
  }
  const d = (g) => !!e.isDateUnavailable?.(g), c = q(() => a.value.length ? a.value[0].rows[0].map((g) => t.dayOfWeek($n(g), e.weekdayFormat.value)) : []), f = (g) => {
    const w = a.value[0].value;
    if (!g && !e.nextPage.value) {
      const k = w.add({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), B = Fa({
        dateObj: k,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = B, e.placeholder.value = B[0].value.set({ day: 1 });
      return;
    }
    const C = rC(w, g || e.nextPage.value), S = Fa({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!g) {
      const k = S[0].value.compare(w);
      k >= To(w) && ($.day = 1), k >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  }, p = (g) => {
    const w = a.value[0].value;
    if (!g && !e.prevPage.value) {
      const k = w.subtract({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), B = Fa({
        dateObj: k,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = B, e.placeholder.value = B[0].value.set({ day: 1 });
      return;
    }
    const C = oC(w, g || e.prevPage.value), S = Fa({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!g) {
      const k = w.compare(S[0].value);
      k >= To(w) && ($.day = 1), k >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  };
  me(e.placeholder, (g) => {
    r.value.some((w) => dp(w, g)) || (a.value = Fa({
      dateObj: g,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    }));
  }), me([
    e.locale,
    e.weekStartsOn,
    e.fixedWeeks,
    e.numberOfMonths
  ], () => {
    a.value = Fa({
      dateObj: e.placeholder.value,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
  });
  const v = q(() => {
    if (!a.value.length) return "";
    if (e.locale.value !== t.getLocale() && t.setLocale(e.locale.value), a.value.length === 1) {
      const D = a.value[0].value;
      return `${t.fullMonthAndYear($n(D), n.value)}`;
    }
    const g = $n(a.value[0].value), w = $n(a.value[a.value.length - 1].value), C = t.fullMonth(g, n.value), S = t.fullMonth(w, n.value), $ = t.fullYear(g, n.value), k = t.fullYear(w, n.value);
    return $ === k ? `${C} - ${S} ${k}` : `${C} ${$} - ${S} ${k}`;
  }), m = q(() => `${e.calendarLabel.value ?? "Event Date"}, ${v.value}`);
  return {
    isDateDisabled: u,
    isDateUnavailable: d,
    isNextButtonDisabled: s,
    isPrevButtonDisabled: i,
    grid: a,
    weekdays: c,
    visibleView: r,
    isOutsideVisibleView: o,
    formatter: t,
    nextPage: f,
    prevPage: p,
    headingValue: v,
    fullCalendarLabel: m
  };
}
const sC = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, lC = {
  role: "heading",
  "aria-level": "2"
}, [Gr, iC] = Se("CalendarRoot");
var uC = /* @__PURE__ */ b({
  __name: "CalendarRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, multiple: f, minValue: p, maxValue: v, numberOfMonths: m, preventDeselect: g, isDateDisabled: w, isDateUnavailable: C, calendarLabel: S, defaultValue: $, nextPage: k, prevPage: B, dir: D, locale: P, disableDaysOutsideCurrentView: E } = Me(n), { primitiveElement: T, currentElement: M } = zt(), I = gc(P), F = gt(D), J = Ve(n, "modelValue", a, {
      defaultValue: $.value,
      passive: n.modelValue === void 0
    }), ne = Eh({
      defaultPlaceholder: n.placeholder,
      defaultValue: J.value,
      locale: n.locale
    }), Q = Ve(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ne.copy(),
      passive: n.placeholder === void 0
    });
    function G(L) {
      Q.value = L.copy();
    }
    const { fullCalendarLabel: H, headingValue: U, isDateDisabled: se, isDateUnavailable: ee, isNextButtonDisabled: de, isPrevButtonDisabled: fe, weekdays: _e, isOutsideVisibleView: ye, nextPage: Te, prevPage: ce, formatter: V, grid: te } = Yh({
      locale: I,
      placeholder: Q,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: m,
      minValue: p,
      maxValue: v,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: w.value,
      isDateUnavailable: C.value,
      calendarLabel: S,
      nextPage: k,
      prevPage: B
    }), { isInvalid: z, isDateSelected: re } = tC({
      date: J,
      isDateDisabled: se,
      isDateUnavailable: ee
    });
    me(J, (L) => {
      if (Array.isArray(L) && L.length) {
        const be = L[L.length - 1];
        be && !Sa(Q.value, be) && G(be);
      } else !Array.isArray(L) && L && !Sa(Q.value, L) && G(L);
    });
    function ie(L) {
      if (f.value) {
        if (!J.value) J.value = [L.copy()];
        else if (Array.isArray(J.value)) {
          if (J.value.findIndex((xe) => _t(xe, L)) === -1) J.value = [...J.value, L];
          else if (!g.value) {
            const xe = J.value.filter((Fe) => !_t(Fe, L));
            if (!xe.length) {
              Q.value = L.copy(), J.value = void 0;
              return;
            }
            J.value = xe.map((Fe) => Fe.copy());
          }
        }
      } else {
        if (!J.value) {
          J.value = L.copy();
          return;
        }
        !g.value && Sa(J.value, L) ? (Q.value = L.copy(), J.value = void 0) : J.value = L.copy();
      }
    }
    return Ce(() => {
      s.value && Th(M.value);
    }), iC({
      isDateUnavailable: ee,
      dir: F,
      isDateDisabled: se,
      locale: I,
      formatter: V,
      modelValue: J,
      placeholder: Q,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: te,
      weekDays: _e,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      multiple: f,
      numberOfMonths: m,
      readonly: o,
      preventDeselect: g,
      fullCalendarLabel: H,
      headingValue: U,
      isInvalid: z,
      isDateSelected: re,
      isNextButtonDisabled: de,
      isPrevButtonDisabled: fe,
      isOutsideVisibleView: ye,
      nextPage: Te,
      prevPage: ce,
      parentElement: M,
      onPlaceholderChange: G,
      onDateChange: ie,
      disableDaysOutsideCurrentView: E,
      minValue: p,
      maxValue: v
    }), (L, be) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: T,
      as: L.as,
      "as-child": L.asChild,
      "aria-label": l(H),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(z) ? "" : void 0,
      dir: l(F)
    }, {
      default: y(() => [_(L.$slots, "default", {
        date: l(Q),
        grid: l(te),
        weekDays: l(_e),
        weekStartsOn: l(u),
        locale: l(I),
        fixedWeeks: l(c),
        modelValue: l(J)
      }), we("div", sC, [we("div", lC, Ne(l(H)), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), dC = uC, cC = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = Gr();
    return (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isDateSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), fC = cC, pC = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = is(), a = Gr(), { primitiveElement: r } = zt(), o = q(() => t.day.day.toLocaleString(a.locale.value)), s = q(() => a.formatter.custom($n(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), i = q(() => a.isDateUnavailable?.(t.day) ?? !1), u = q(() => uh(t.day, Wr())), d = q(() => !sc(t.day, t.month)), c = q(() => a.isOutsideVisibleView(t.day)), f = q(() => a.isDateDisabled(t.day) || a.disableDaysOutsideCurrentView.value && d.value), p = q(() => !a.disabled.value && _t(t.day, a.placeholder.value)), v = q(() => a.isDateSelected(t.day));
    function m(C) {
      a.readonly.value || a.isDateDisabled(C) || a.isDateUnavailable?.(C) || a.onDateChange(C);
    }
    function g() {
      f.value || m(t.day);
    }
    function w(C) {
      if (f.value) return;
      C.preventDefault(), C.stopPropagation();
      const S = a.parentElement.value, $ = 7, k = a.dir.value === "rtl" ? -1 : 1;
      switch (C.code) {
        case n.ARROW_RIGHT:
          B(t.day, k);
          break;
        case n.ARROW_LEFT:
          B(t.day, -k);
          break;
        case n.ARROW_UP:
          B(t.day, -$);
          break;
        case n.ARROW_DOWN:
          B(t.day, $);
          break;
        case n.ENTER:
        case n.SPACE_CODE:
          m(t.day);
      }
      function B(D, P) {
        const E = D.add({ days: P });
        if (a.minValue.value && E.compare(a.minValue.value) < 0 || a.maxValue.value && E.compare(a.maxValue.value) > 0) return;
        const T = S.querySelector(`[data-value='${E.toString()}']:not([data-outside-view])`);
        if (!T) {
          if (P > 0) {
            if (a.isNextButtonDisabled()) return;
            a.nextPage();
          } else {
            if (a.isPrevButtonDisabled()) return;
            a.prevPage();
          }
          Pe(() => {
            B(D, P);
          });
          return;
        }
        if (T && T.hasAttribute("data-disabled")) return B(E, P);
        a.onPlaceholderChange(E), T?.focus();
      }
    }
    return (C, S) => (h(), x(l(X), A({
      ref_key: "primitiveElement",
      ref: r
    }, t, {
      role: "button",
      "aria-label": s.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-disabled": f.value || i.value ? !0 : void 0,
      "data-selected": v.value ? !0 : void 0,
      "data-value": C.day.toString(),
      "data-disabled": f.value ? "" : void 0,
      "data-unavailable": i.value ? "" : void 0,
      "data-today": u.value ? "" : void 0,
      "data-outside-view": d.value ? "" : void 0,
      "data-outside-visible-view": c.value ? "" : void 0,
      "data-focused": p.value ? "" : void 0,
      tabindex: p.value ? 0 : d.value || f.value ? void 0 : -1,
      onClick: g,
      onKeydown: [Je(w, [
        "up",
        "down",
        "left",
        "right",
        "space",
        "enter"
      ]), S[0] || (S[0] = Je(Ye(() => {
      }, ["prevent"]), ["enter"]))]
    }), {
      default: y(() => [_(C.$slots, "default", {
        dayValue: o.value,
        disabled: f.value,
        today: u.value,
        selected: v.value,
        outsideView: d.value,
        outsideVisibleView: c.value,
        unavailable: i.value
      }, () => [Re(Ne(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-disabled",
      "data-selected",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-outside-visible-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), vC = pC, mC = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = Gr(), a = q(() => n.disabled.value ? !0 : void 0), r = q(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), x(l(X), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), hC = mC, gC = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), yC = gC, bC = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _C = bC, wC = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xC = wC, CC = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), SC = CC, $C = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), BC = $C, kC = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Gr();
    return (a, r) => (h(), x(l(X), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Ne(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), PC = kC, DC = /* @__PURE__ */ b({
  __name: "CalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = q(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = Gr();
    return (r, o) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), MC = DC, qC = /* @__PURE__ */ b({
  __name: "CalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = q(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = Gr();
    return (r, o) => (h(), x(l(X), {
      "aria-label": "Previous page",
      as: t.as,
      "as-child": t.asChild,
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), EC = qC;
const Op = "data-reka-collection-item";
function st(e = {}) {
  const { key: t = "", isProvider: n = !1 } = e, a = `${t}CollectionProvider`;
  let r;
  if (n) {
    const c = O(/* @__PURE__ */ new Map());
    r = {
      collectionRef: O(),
      itemMap: c
    }, Kn(a, r);
  } else r = wn(a);
  const o = (c = !1) => {
    const f = r.collectionRef.value;
    if (!f) return [];
    const p = Array.from(f.querySelectorAll(`[${Op}]`)), m = Array.from(r.itemMap.value.values()).sort((g, w) => p.indexOf(g.ref) - p.indexOf(w.ref));
    return c ? m : m.filter((g) => g.ref.dataset.disabled !== "");
  }, s = b({
    name: "CollectionSlot",
    setup(c, { slots: f }) {
      const { primitiveElement: p, currentElement: v } = zt();
      return me(v, () => {
        r.collectionRef.value = v.value;
      }), () => en($l, { ref: p }, f);
    }
  }), i = b({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(c, { slots: f, attrs: p }) {
      const { primitiveElement: v, currentElement: m } = zt();
      return Ae((g) => {
        if (m.value) {
          const w = i0(m.value);
          r.itemMap.value.set(w, {
            ref: m.value,
            value: c.value
          }), g(() => r.itemMap.value.delete(w));
        }
      }), () => en($l, {
        ...p,
        [Op]: "",
        ref: v
      }, f);
    }
  }), u = q(() => Array.from(r.itemMap.value.values())), d = q(() => r.itemMap.value.size);
  return {
    getItems: o,
    reactiveItems: u,
    itemMapSize: d,
    CollectionSlot: s,
    CollectionItem: i
  };
}
const TC = "rovingFocusGroup.onEntryFocus", AC = {
  bubbles: !1,
  cancelable: !0
}, OC = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function IC(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Xh(e, t, n) {
  const a = IC(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return OC[a];
}
function Jh(e, t = !1) {
  const n = ot();
  for (const a of e)
    if (a === n || (a.focus({ preventScroll: t }), ot() !== n)) return;
}
function RC(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
const [VC, FC] = Se("RovingFocusGroup");
var NC = /* @__PURE__ */ b({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { loop: o, orientation: s, dir: i } = Me(a), u = gt(i), d = Ve(a, "currentTabStopId", r, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), c = O(!1), f = O(!1), p = O(0), { getItems: v, CollectionSlot: m } = st({ isProvider: !0 });
    function g(C) {
      const S = !f.value;
      if (C.currentTarget && C.target === C.currentTarget && S && !c.value) {
        const $ = new CustomEvent(TC, AC);
        if (C.currentTarget.dispatchEvent($), r("entryFocus", $), !$.defaultPrevented) {
          const k = v().map((T) => T.ref).filter((T) => T.dataset.disabled !== ""), B = k.find((T) => T.getAttribute("data-active") === ""), D = k.find((T) => T.getAttribute("data-highlighted") === ""), P = k.find((T) => T.id === d.value), E = [
            B,
            D,
            P,
            ...k
          ].filter(Boolean);
          Jh(E, a.preventScrollOnEntryFocus);
        }
      }
      f.value = !1;
    }
    function w() {
      setTimeout(() => {
        f.value = !1;
      }, 1);
    }
    return t({ getItems: v }), FC({
      loop: o,
      dir: u,
      orientation: s,
      currentTabStopId: d,
      onItemFocus: (C) => {
        d.value = C;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        p.value++;
      },
      onFocusableItemRemove: () => {
        p.value--;
      }
    }), (C, S) => (h(), x(l(m), null, {
      default: y(() => [N(l(X), {
        tabindex: c.value || p.value === 0 ? -1 : 0,
        "data-orientation": l(s),
        as: C.as,
        "as-child": C.asChild,
        dir: l(u),
        style: { outline: "none" },
        onMousedown: S[0] || (S[0] = ($) => f.value = !0),
        onMouseup: w,
        onFocus: g,
        onBlur: S[1] || (S[1] = ($) => c.value = !1)
      }, {
        default: y(() => [_(C.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), cs = NC, LC = /* @__PURE__ */ b({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = VC(), a = Ge(), r = q(() => t.tabStopId || a), o = q(() => n.currentTabStopId.value === r.value), { getItems: s, CollectionItem: i } = st();
    Ce(() => {
      t.focusable && n.onFocusableItemAdd();
    }), nt(() => {
      t.focusable && n.onFocusableItemRemove();
    });
    function u(d) {
      if (d.key === "Tab" && d.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (d.target !== d.currentTarget) return;
      const c = Xh(d, n.orientation.value, n.dir.value);
      if (c !== void 0) {
        if (d.metaKey || d.ctrlKey || d.altKey || !t.allowShiftKey && d.shiftKey) return;
        d.preventDefault();
        let f = [...s().map((p) => p.ref).filter((p) => p.dataset.disabled !== "")];
        if (c === "last") f.reverse();
        else if (c === "prev" || c === "next") {
          c === "prev" && f.reverse();
          const p = f.indexOf(d.currentTarget);
          f = n.loop.value ? RC(f, p + 1) : f.slice(p + 1);
        }
        Pe(() => Jh(f));
      }
    }
    return (d, c) => (h(), x(l(i), null, {
      default: y(() => [N(l(X), {
        tabindex: o.value ? 0 : -1,
        "data-orientation": l(n).orientation.value,
        "data-active": d.active ? "" : void 0,
        "data-disabled": d.focusable ? void 0 : "",
        as: d.as,
        "as-child": d.asChild,
        onMousedown: c[0] || (c[0] = (f) => {
          d.focusable ? l(n).onItemFocus(r.value) : f.preventDefault();
        }),
        onFocus: c[1] || (c[1] = (f) => l(n).onItemFocus(r.value)),
        onKeydown: u
      }, {
        default: y(() => [_(d.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), fs = LC, zC = /* @__PURE__ */ b({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-hidden": t.feature === "focusable" ? "true" : void 0,
      "data-hidden": t.feature === "fully-hidden" ? "" : void 0,
      tabindex: t.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: y(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), wi = zC, HC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = zt(), r = q(() => t.checked ?? t.value);
    return me(r, (o, s) => {
      if (!a.value) return;
      const i = a.value, u = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(u, "value").set;
      if (c && o !== s) {
        const f = new Event("input", { bubbles: !0 }), p = new Event("change", { bubbles: !0 });
        c.call(i, o), i.dispatchEvent(f), i.dispatchEvent(p);
      }
    }), (o, s) => (h(), x(wi, A({
      ref_key: "primitiveElement",
      ref: n
    }, {
      ...t,
      ...o.$attrs
    }, { as: "input" }), null, 16));
  }
}), Ip = HC, UC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, n = q(() => typeof t.value == "object" && Array.isArray(t.value) && t.value.length === 0 && t.required), a = q(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" || t.value === null || t.value === void 0 ? [{
      name: t.name,
      value: t.value
    }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((r, o) => typeof r == "object" ? Object.entries(r).map(([s, i]) => ({
      name: `${t.name}[${o}][${s}]`,
      value: i
    })) : {
      name: `${t.name}[${o}]`,
      value: r
    }) : t.value !== null && typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([r, o]) => ({
      name: `${t.name}[${r}]`,
      value: o
    })) : []);
    return (r, o) => (h(), W(Ke, null, [qe(" We render single input if it's required "), n.value ? (h(), x(Ip, A({ key: r.name }, {
      ...t,
      ...r.$attrs
    }, {
      name: r.name,
      value: r.value
    }), null, 16, ["name", "value"])) : (h(!0), W(Ke, { key: 1 }, Nt(a.value, (s) => (h(), x(Ip, A({ key: s.name }, { ref_for: !0 }, {
      ...t,
      ...r.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), In = UC;
const [jC] = Se("CheckboxGroupRoot");
function kl(e) {
  return e === "indeterminate";
}
function Zh(e) {
  return kl(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
const [WC, GC] = Se("CheckboxRoot");
var KC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultValue: {
      type: [Boolean, String],
      required: !1
    },
    modelValue: {
      type: [
        Boolean,
        String,
        null
      ],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: null,
      required: !1,
      default: "on"
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = jC(null), i = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), u = q(() => s?.disabled.value || n.disabled), d = q(() => Pn(s?.modelValue.value) ? i.value === "indeterminate" ? "indeterminate" : i.value : yl(s.modelValue.value, n.value));
    function c() {
      if (Pn(s?.modelValue.value))
        i.value = kl(i.value) ? !0 : !i.value;
      else {
        const v = [...s.modelValue.value || []];
        if (yl(v, n.value)) {
          const m = v.findIndex((g) => Mn(g, n.value));
          v.splice(m, 1);
        } else v.push(n.value);
        s.modelValue.value = v;
      }
    }
    const f = On(o), p = q(() => n.id && o.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return GC({
      disabled: u,
      state: d
    }), (v, m) => (h(), x(kt(l(s)?.rovingFocus.value ? l(fs) : l(X)), A(v.$attrs, {
      id: v.id,
      ref: l(r),
      role: "checkbox",
      "as-child": v.asChild,
      as: v.as,
      type: v.as === "button" ? "button" : void 0,
      "aria-checked": l(kl)(d.value) ? "mixed" : d.value,
      "aria-required": v.required,
      "aria-label": v.$attrs["aria-label"] || p.value,
      "data-state": l(Zh)(d.value),
      "data-disabled": u.value ? "" : void 0,
      disabled: u.value,
      focusable: l(s)?.rovingFocus.value ? !u.value : void 0,
      onKeydown: Je(Ye(() => {
      }, ["prevent"]), ["enter"]),
      onClick: c
    }), {
      default: y(() => [_(v.$slots, "default", {
        modelValue: l(i),
        state: d.value
      }), l(f) && v.name && !l(s) ? (h(), x(l(In), {
        key: 0,
        type: "checkbox",
        checked: !!d.value,
        name: v.name,
        value: v.value,
        disabled: u.value,
        required: v.required
      }, null, 8, [
        "checked",
        "name",
        "value",
        "disabled",
        "required"
      ])) : qe("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "as-child",
      "as",
      "type",
      "aria-checked",
      "aria-required",
      "aria-label",
      "data-state",
      "data-disabled",
      "disabled",
      "focusable",
      "onKeydown"
    ]));
  }
}), YC = KC, XC = /* @__PURE__ */ b({
  __name: "CheckboxIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = WC();
    return (a, r) => (h(), x(l(Ct), { present: a.forceMount || l(kl)(l(n).state.value) || l(n).state.value === !0 }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "data-state": l(Zh)(l(n).state.value),
        "data-disabled": l(n).disabled.value ? "" : void 0,
        style: { pointerEvents: "none" },
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), JC = XC;
const [Qh, ZC] = Se("PopperRoot");
var QC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = O();
    return ZC({
      anchor: t,
      onAnchorChange: (n) => t.value = n
    }), (n, a) => _(n.$slots, "default");
  }
}), or = QC, eS = /* @__PURE__ */ b({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = Qh();
    return Xm(() => {
      r.onAnchorChange(t.reference ?? a.value);
    }), (o, s) => (h(), x(l(X), {
      ref: l(n),
      as: o.as,
      "as-child": o.asChild
    }, {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), sr = eS;
const tS = {
  key: 0,
  d: "M0 0L6 6L12 0"
}, nS = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
var aS = /* @__PURE__ */ b({
  __name: "Arrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, {
      width: n.width,
      height: n.height,
      viewBox: n.asChild ? void 0 : "0 0 12 6",
      preserveAspectRatio: n.asChild ? void 0 : "none"
    }), {
      default: y(() => [_(n.$slots, "default", {}, () => [n.rounded ? (h(), W("path", nS)) : (h(), W("path", tS))])]),
      _: 3
    }, 16, [
      "width",
      "height",
      "viewBox",
      "preserveAspectRatio"
    ]));
  }
}), rS = aS;
function oS(e) {
  return e !== null;
}
function sS(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: a, middlewareData: r } = t, s = r.arrow?.centerOffset !== 0, i = s ? 0 : e.arrowWidth, u = s ? 0 : e.arrowHeight, [d, c] = pd(n), f = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[c], p = (r.arrow?.x ?? 0) + i / 2, v = (r.arrow?.y ?? 0) + u / 2;
      let m = "", g = "";
      return d === "bottom" ? (m = s ? f : `${p}px`, g = `${-u}px`) : d === "top" ? (m = s ? f : `${p}px`, g = `${a.floating.height + u}px`) : d === "right" ? (m = `${-u}px`, g = s ? f : `${v}px`) : d === "left" && (m = `${a.floating.width + u}px`, g = s ? f : `${v}px`), { data: {
        x: m,
        y: g
      } };
    }
  };
}
function pd(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
const lS = ["top", "right", "bottom", "left"], Ma = Math.min, dn = Math.max, Pl = Math.round, Os = Math.floor, jn = (e) => ({
  x: e,
  y: e
}), iS = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, uS = {
  start: "end",
  end: "start"
};
function vd(e, t, n) {
  return dn(e, Ma(t, n));
}
function ia(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ua(e) {
  return e.split("-")[0];
}
function Kr(e) {
  return e.split("-")[1];
}
function xc(e) {
  return e === "x" ? "y" : "x";
}
function Cc(e) {
  return e === "y" ? "height" : "width";
}
const dS = /* @__PURE__ */ new Set(["top", "bottom"]);
function Un(e) {
  return dS.has(ua(e)) ? "y" : "x";
}
function Sc(e) {
  return xc(Un(e));
}
function cS(e, t, n) {
  n === void 0 && (n = !1);
  const a = Kr(e), r = Sc(e), o = Cc(r);
  let s = r === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = Dl(s)), [s, Dl(s)];
}
function fS(e) {
  const t = Dl(e);
  return [md(e), t, md(t)];
}
function md(e) {
  return e.replace(/start|end/g, (t) => uS[t]);
}
const Rp = ["left", "right"], Vp = ["right", "left"], pS = ["top", "bottom"], vS = ["bottom", "top"];
function mS(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? Vp : Rp : t ? Rp : Vp;
    case "left":
    case "right":
      return t ? pS : vS;
    default:
      return [];
  }
}
function hS(e, t, n, a) {
  const r = Kr(e);
  let o = mS(ua(e), n === "start", a);
  return r && (o = o.map((s) => s + "-" + r), t && (o = o.concat(o.map(md)))), o;
}
function Dl(e) {
  return e.replace(/left|right|bottom|top/g, (t) => iS[t]);
}
function gS(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function eg(e) {
  return typeof e != "number" ? gS(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Ml(e) {
  const {
    x: t,
    y: n,
    width: a,
    height: r
  } = e;
  return {
    width: a,
    height: r,
    top: n,
    left: t,
    right: t + a,
    bottom: n + r,
    x: t,
    y: n
  };
}
function Fp(e, t, n) {
  let {
    reference: a,
    floating: r
  } = e;
  const o = Un(t), s = Sc(t), i = Cc(s), u = ua(t), d = o === "y", c = a.x + a.width / 2 - r.width / 2, f = a.y + a.height / 2 - r.height / 2, p = a[i] / 2 - r[i] / 2;
  let v;
  switch (u) {
    case "top":
      v = {
        x: c,
        y: a.y - r.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: a.y + a.height
      };
      break;
    case "right":
      v = {
        x: a.x + a.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: a.x - r.width,
        y: f
      };
      break;
    default:
      v = {
        x: a.x,
        y: a.y
      };
  }
  switch (Kr(t)) {
    case "start":
      v[s] -= p * (n && d ? -1 : 1);
      break;
    case "end":
      v[s] += p * (n && d ? -1 : 1);
      break;
  }
  return v;
}
const yS = async (e, t, n) => {
  const {
    placement: a = "bottom",
    strategy: r = "absolute",
    middleware: o = [],
    platform: s
  } = n, i = o.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: c,
    y: f
  } = Fp(d, a, u), p = a, v = {}, m = 0;
  for (let g = 0; g < i.length; g++) {
    const {
      name: w,
      fn: C
    } = i[g], {
      x: S,
      y: $,
      data: k,
      reset: B
    } = await C({
      x: c,
      y: f,
      initialPlacement: a,
      placement: p,
      strategy: r,
      middlewareData: v,
      rects: d,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = S ?? c, f = $ ?? f, v = {
      ...v,
      [w]: {
        ...v[w],
        ...k
      }
    }, B && m <= 50 && (m++, typeof B == "object" && (B.placement && (p = B.placement), B.rects && (d = B.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : B.rects), {
      x: c,
      y: f
    } = Fp(d, p, u)), g = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: r,
    middlewareData: v
  };
};
async function Oo(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: a,
    y: r,
    platform: o,
    rects: s,
    elements: i,
    strategy: u
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: v = 0
  } = ia(t, e), m = eg(v), w = i[p ? f === "floating" ? "reference" : "floating" : f], C = Ml(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(w))) == null || n ? w : w.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(i.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: u
  })), S = f === "floating" ? {
    x: a,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, $ = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(i.floating)), k = await (o.isElement == null ? void 0 : o.isElement($)) ? await (o.getScale == null ? void 0 : o.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, B = Ml(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: S,
    offsetParent: $,
    strategy: u
  }) : S);
  return {
    top: (C.top - B.top + m.top) / k.y,
    bottom: (B.bottom - C.bottom + m.bottom) / k.y,
    left: (C.left - B.left + m.left) / k.x,
    right: (B.right - C.right + m.right) / k.x
  };
}
const bS = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: a,
      placement: r,
      rects: o,
      platform: s,
      elements: i,
      middlewareData: u
    } = t, {
      element: d,
      padding: c = 0
    } = ia(e, t) || {};
    if (d == null)
      return {};
    const f = eg(c), p = {
      x: n,
      y: a
    }, v = Sc(r), m = Cc(v), g = await s.getDimensions(d), w = v === "y", C = w ? "top" : "left", S = w ? "bottom" : "right", $ = w ? "clientHeight" : "clientWidth", k = o.reference[m] + o.reference[v] - p[v] - o.floating[m], B = p[v] - o.reference[v], D = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d));
    let P = D ? D[$] : 0;
    (!P || !await (s.isElement == null ? void 0 : s.isElement(D))) && (P = i.floating[$] || o.floating[m]);
    const E = k / 2 - B / 2, T = P / 2 - g[m] / 2 - 1, M = Ma(f[C], T), I = Ma(f[S], T), F = M, J = P - g[m] - I, ne = P / 2 - g[m] / 2 + E, Q = vd(F, ne, J), G = !u.arrow && Kr(r) != null && ne !== Q && o.reference[m] / 2 - (ne < F ? M : I) - g[m] / 2 < 0, H = G ? ne < F ? ne - F : ne - J : 0;
    return {
      [v]: p[v] + H,
      data: {
        [v]: Q,
        centerOffset: ne - Q - H,
        ...G && {
          alignmentOffset: H
        }
      },
      reset: G
    };
  }
}), _S = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        middlewareData: o,
        rects: s,
        initialPlacement: i,
        platform: u,
        elements: d
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: g = !0,
        ...w
      } = ia(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const C = ua(r), S = Un(i), $ = ua(i) === i, k = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)), B = p || ($ || !g ? [Dl(i)] : fS(i)), D = m !== "none";
      !p && D && B.push(...hS(i, g, m, k));
      const P = [i, ...B], E = await Oo(t, w), T = [];
      let M = ((a = o.flip) == null ? void 0 : a.overflows) || [];
      if (c && T.push(E[C]), f) {
        const ne = cS(r, s, k);
        T.push(E[ne[0]], E[ne[1]]);
      }
      if (M = [...M, {
        placement: r,
        overflows: T
      }], !T.every((ne) => ne <= 0)) {
        var I, F;
        const ne = (((I = o.flip) == null ? void 0 : I.index) || 0) + 1, Q = P[ne];
        if (Q && (!(f === "alignment" ? S !== Un(Q) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        M.every((U) => Un(U.placement) === S ? U.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ne,
              overflows: M
            },
            reset: {
              placement: Q
            }
          };
        let G = (F = M.filter((H) => H.overflows[0] <= 0).sort((H, U) => H.overflows[1] - U.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!G)
          switch (v) {
            case "bestFit": {
              var J;
              const H = (J = M.filter((U) => {
                if (D) {
                  const se = Un(U.placement);
                  return se === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  se === "y";
                }
                return !0;
              }).map((U) => [U.placement, U.overflows.filter((se) => se > 0).reduce((se, ee) => se + ee, 0)]).sort((U, se) => U[1] - se[1])[0]) == null ? void 0 : J[0];
              H && (G = H);
              break;
            }
            case "initialPlacement":
              G = i;
              break;
          }
        if (r !== G)
          return {
            reset: {
              placement: G
            }
          };
      }
      return {};
    }
  };
};
function Np(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Lp(e) {
  return lS.some((t) => e[t] >= 0);
}
const wS = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: a = "referenceHidden",
        ...r
      } = ia(e, t);
      switch (a) {
        case "referenceHidden": {
          const o = await Oo(t, {
            ...r,
            elementContext: "reference"
          }), s = Np(o, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Lp(s)
            }
          };
        }
        case "escaped": {
          const o = await Oo(t, {
            ...r,
            altBoundary: !0
          }), s = Np(o, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Lp(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, tg = /* @__PURE__ */ new Set(["left", "top"]);
async function xS(e, t) {
  const {
    placement: n,
    platform: a,
    elements: r
  } = e, o = await (a.isRTL == null ? void 0 : a.isRTL(r.floating)), s = ua(n), i = Kr(n), u = Un(n) === "y", d = tg.has(s) ? -1 : 1, c = o && u ? -1 : 1, f = ia(t, e);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return i && typeof m == "number" && (v = i === "end" ? m * -1 : m), u ? {
    x: v * c,
    y: p * d
  } : {
    x: p * d,
    y: v * c
  };
}
const CS = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, a;
      const {
        x: r,
        y: o,
        placement: s,
        middlewareData: i
      } = t, u = await xS(t, e);
      return s === ((n = i.offset) == null ? void 0 : n.placement) && (a = i.arrow) != null && a.alignmentOffset ? {} : {
        x: r + u.x,
        y: o + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, SS = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: a,
        placement: r
      } = t, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: i = {
          fn: (w) => {
            let {
              x: C,
              y: S
            } = w;
            return {
              x: C,
              y: S
            };
          }
        },
        ...u
      } = ia(e, t), d = {
        x: n,
        y: a
      }, c = await Oo(t, u), f = Un(ua(r)), p = xc(f);
      let v = d[p], m = d[f];
      if (o) {
        const w = p === "y" ? "top" : "left", C = p === "y" ? "bottom" : "right", S = v + c[w], $ = v - c[C];
        v = vd(S, v, $);
      }
      if (s) {
        const w = f === "y" ? "top" : "left", C = f === "y" ? "bottom" : "right", S = m + c[w], $ = m - c[C];
        m = vd(S, m, $);
      }
      const g = i.fn({
        ...t,
        [p]: v,
        [f]: m
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - a,
          enabled: {
            [p]: o,
            [f]: s
          }
        }
      };
    }
  };
}, $S = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: a,
        placement: r,
        rects: o,
        middlewareData: s
      } = t, {
        offset: i = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = ia(e, t), c = {
        x: n,
        y: a
      }, f = Un(r), p = xc(f);
      let v = c[p], m = c[f];
      const g = ia(i, t), w = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (u) {
        const $ = p === "y" ? "height" : "width", k = o.reference[p] - o.floating[$] + w.mainAxis, B = o.reference[p] + o.reference[$] - w.mainAxis;
        v < k ? v = k : v > B && (v = B);
      }
      if (d) {
        var C, S;
        const $ = p === "y" ? "width" : "height", k = tg.has(ua(r)), B = o.reference[f] - o.floating[$] + (k && ((C = s.offset) == null ? void 0 : C[f]) || 0) + (k ? 0 : w.crossAxis), D = o.reference[f] + o.reference[$] + (k ? 0 : ((S = s.offset) == null ? void 0 : S[f]) || 0) - (k ? w.crossAxis : 0);
        m < B ? m = B : m > D && (m = D);
      }
      return {
        [p]: v,
        [f]: m
      };
    }
  };
}, BS = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        rects: o,
        platform: s,
        elements: i
      } = t, {
        apply: u = () => {
        },
        ...d
      } = ia(e, t), c = await Oo(t, d), f = ua(r), p = Kr(r), v = Un(r) === "y", {
        width: m,
        height: g
      } = o.floating;
      let w, C;
      f === "top" || f === "bottom" ? (w = f, C = p === (await (s.isRTL == null ? void 0 : s.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (C = f, w = p === "end" ? "top" : "bottom");
      const S = g - c.top - c.bottom, $ = m - c.left - c.right, k = Ma(g - c[w], S), B = Ma(m - c[C], $), D = !t.middlewareData.shift;
      let P = k, E = B;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (E = $), (a = t.middlewareData.shift) != null && a.enabled.y && (P = S), D && !p) {
        const M = dn(c.left, 0), I = dn(c.right, 0), F = dn(c.top, 0), J = dn(c.bottom, 0);
        v ? E = m - 2 * (M !== 0 || I !== 0 ? M + I : dn(c.left, c.right)) : P = g - 2 * (F !== 0 || J !== 0 ? F + J : dn(c.top, c.bottom));
      }
      await u({
        ...t,
        availableWidth: E,
        availableHeight: P
      });
      const T = await s.getDimensions(i.floating);
      return m !== T.width || g !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function xi() {
  return typeof window < "u";
}
function lr(e) {
  return $c(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function fn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Jn(e) {
  var t;
  return (t = ($c(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function $c(e) {
  return xi() ? e instanceof Node || e instanceof fn(e).Node : !1;
}
function Tn(e) {
  return xi() ? e instanceof Element || e instanceof fn(e).Element : !1;
}
function Yn(e) {
  return xi() ? e instanceof HTMLElement || e instanceof fn(e).HTMLElement : !1;
}
function zp(e) {
  return !xi() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof fn(e).ShadowRoot;
}
const kS = /* @__PURE__ */ new Set(["inline", "contents"]);
function ps(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: a,
    display: r
  } = An(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !kS.has(r);
}
const PS = /* @__PURE__ */ new Set(["table", "td", "th"]);
function DS(e) {
  return PS.has(lr(e));
}
const MS = [":popover-open", ":modal"];
function Ci(e) {
  return MS.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const qS = ["transform", "translate", "scale", "rotate", "perspective"], ES = ["transform", "translate", "scale", "rotate", "perspective", "filter"], TS = ["paint", "layout", "strict", "content"];
function Bc(e) {
  const t = kc(), n = Tn(e) ? An(e) : e;
  return qS.some((a) => n[a] ? n[a] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ES.some((a) => (n.willChange || "").includes(a)) || TS.some((a) => (n.contain || "").includes(a));
}
function AS(e) {
  let t = qa(e);
  for (; Yn(t) && !Fr(t); ) {
    if (Bc(t))
      return t;
    if (Ci(t))
      return null;
    t = qa(t);
  }
  return null;
}
function kc() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const OS = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Fr(e) {
  return OS.has(lr(e));
}
function An(e) {
  return fn(e).getComputedStyle(e);
}
function Si(e) {
  return Tn(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function qa(e) {
  if (lr(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    zp(e) && e.host || // Fallback.
    Jn(e)
  );
  return zp(t) ? t.host : t;
}
function ng(e) {
  const t = qa(e);
  return Fr(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Yn(t) && ps(t) ? t : ng(t);
}
function Io(e, t, n) {
  var a;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const r = ng(e), o = r === ((a = e.ownerDocument) == null ? void 0 : a.body), s = fn(r);
  if (o) {
    const i = hd(s);
    return t.concat(s, s.visualViewport || [], ps(r) ? r : [], i && n ? Io(i) : []);
  }
  return t.concat(r, Io(r, [], n));
}
function hd(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function ag(e) {
  const t = An(e);
  let n = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const r = Yn(e), o = r ? e.offsetWidth : n, s = r ? e.offsetHeight : a, i = Pl(n) !== o || Pl(a) !== s;
  return i && (n = o, a = s), {
    width: n,
    height: a,
    $: i
  };
}
function Pc(e) {
  return Tn(e) ? e : e.contextElement;
}
function Dr(e) {
  const t = Pc(e);
  if (!Yn(t))
    return jn(1);
  const n = t.getBoundingClientRect(), {
    width: a,
    height: r,
    $: o
  } = ag(t);
  let s = (o ? Pl(n.width) : n.width) / a, i = (o ? Pl(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: s,
    y: i
  };
}
const IS = /* @__PURE__ */ jn(0);
function rg(e) {
  const t = fn(e);
  return !kc() || !t.visualViewport ? IS : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function RS(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== fn(e) ? !1 : t;
}
function Ja(e, t, n, a) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = Pc(e);
  let s = jn(1);
  t && (a ? Tn(a) && (s = Dr(a)) : s = Dr(e));
  const i = RS(o, n, a) ? rg(o) : jn(0);
  let u = (r.left + i.x) / s.x, d = (r.top + i.y) / s.y, c = r.width / s.x, f = r.height / s.y;
  if (o) {
    const p = fn(o), v = a && Tn(a) ? fn(a) : a;
    let m = p, g = hd(m);
    for (; g && a && v !== m; ) {
      const w = Dr(g), C = g.getBoundingClientRect(), S = An(g), $ = C.left + (g.clientLeft + parseFloat(S.paddingLeft)) * w.x, k = C.top + (g.clientTop + parseFloat(S.paddingTop)) * w.y;
      u *= w.x, d *= w.y, c *= w.x, f *= w.y, u += $, d += k, m = fn(g), g = hd(m);
    }
  }
  return Ml({
    width: c,
    height: f,
    x: u,
    y: d
  });
}
function $i(e, t) {
  const n = Si(e).scrollLeft;
  return t ? t.left + n : Ja(Jn(e)).left + n;
}
function og(e, t) {
  const n = e.getBoundingClientRect(), a = n.left + t.scrollLeft - $i(e, n), r = n.top + t.scrollTop;
  return {
    x: a,
    y: r
  };
}
function VS(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: a,
    strategy: r
  } = e;
  const o = r === "fixed", s = Jn(a), i = t ? Ci(t.floating) : !1;
  if (a === s || i && o)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = jn(1);
  const c = jn(0), f = Yn(a);
  if ((f || !f && !o) && ((lr(a) !== "body" || ps(s)) && (u = Si(a)), Yn(a))) {
    const v = Ja(a);
    d = Dr(a), c.x = v.x + a.clientLeft, c.y = v.y + a.clientTop;
  }
  const p = s && !f && !o ? og(s, u) : jn(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - u.scrollLeft * d.x + c.x + p.x,
    y: n.y * d.y - u.scrollTop * d.y + c.y + p.y
  };
}
function FS(e) {
  return Array.from(e.getClientRects());
}
function NS(e) {
  const t = Jn(e), n = Si(e), a = e.ownerDocument.body, r = dn(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), o = dn(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let s = -n.scrollLeft + $i(e);
  const i = -n.scrollTop;
  return An(a).direction === "rtl" && (s += dn(t.clientWidth, a.clientWidth) - r), {
    width: r,
    height: o,
    x: s,
    y: i
  };
}
const Hp = 25;
function LS(e, t) {
  const n = fn(e), a = Jn(e), r = n.visualViewport;
  let o = a.clientWidth, s = a.clientHeight, i = 0, u = 0;
  if (r) {
    o = r.width, s = r.height;
    const c = kc();
    (!c || c && t === "fixed") && (i = r.offsetLeft, u = r.offsetTop);
  }
  const d = $i(a);
  if (d <= 0) {
    const c = a.ownerDocument, f = c.body, p = getComputedStyle(f), v = c.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0, m = Math.abs(a.clientWidth - f.clientWidth - v);
    m <= Hp && (o -= m);
  } else d <= Hp && (o += d);
  return {
    width: o,
    height: s,
    x: i,
    y: u
  };
}
const zS = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function HS(e, t) {
  const n = Ja(e, !0, t === "fixed"), a = n.top + e.clientTop, r = n.left + e.clientLeft, o = Yn(e) ? Dr(e) : jn(1), s = e.clientWidth * o.x, i = e.clientHeight * o.y, u = r * o.x, d = a * o.y;
  return {
    width: s,
    height: i,
    x: u,
    y: d
  };
}
function Up(e, t, n) {
  let a;
  if (t === "viewport")
    a = LS(e, n);
  else if (t === "document")
    a = NS(Jn(e));
  else if (Tn(t))
    a = HS(t, n);
  else {
    const r = rg(e);
    a = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return Ml(a);
}
function sg(e, t) {
  const n = qa(e);
  return n === t || !Tn(n) || Fr(n) ? !1 : An(n).position === "fixed" || sg(n, t);
}
function US(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let a = Io(e, [], !1).filter((i) => Tn(i) && lr(i) !== "body"), r = null;
  const o = An(e).position === "fixed";
  let s = o ? qa(e) : e;
  for (; Tn(s) && !Fr(s); ) {
    const i = An(s), u = Bc(s);
    !u && i.position === "fixed" && (r = null), (o ? !u && !r : !u && i.position === "static" && !!r && zS.has(r.position) || ps(s) && !u && sg(e, s)) ? a = a.filter((c) => c !== s) : r = i, s = qa(s);
  }
  return t.set(e, a), a;
}
function jS(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: a,
    strategy: r
  } = e;
  const s = [...n === "clippingAncestors" ? Ci(t) ? [] : US(t, this._c) : [].concat(n), a], i = s[0], u = s.reduce((d, c) => {
    const f = Up(t, c, r);
    return d.top = dn(f.top, d.top), d.right = Ma(f.right, d.right), d.bottom = Ma(f.bottom, d.bottom), d.left = dn(f.left, d.left), d;
  }, Up(t, i, r));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function WS(e) {
  const {
    width: t,
    height: n
  } = ag(e);
  return {
    width: t,
    height: n
  };
}
function GS(e, t, n) {
  const a = Yn(t), r = Jn(t), o = n === "fixed", s = Ja(e, !0, o, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = jn(0);
  function d() {
    u.x = $i(r);
  }
  if (a || !a && !o)
    if ((lr(t) !== "body" || ps(r)) && (i = Si(t)), a) {
      const v = Ja(t, !0, o, t);
      u.x = v.x + t.clientLeft, u.y = v.y + t.clientTop;
    } else r && d();
  o && !a && r && d();
  const c = r && !a && !o ? og(r, i) : jn(0), f = s.left + i.scrollLeft - u.x - c.x, p = s.top + i.scrollTop - u.y - c.y;
  return {
    x: f,
    y: p,
    width: s.width,
    height: s.height
  };
}
function Pu(e) {
  return An(e).position === "static";
}
function jp(e, t) {
  if (!Yn(e) || An(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Jn(e) === n && (n = n.ownerDocument.body), n;
}
function lg(e, t) {
  const n = fn(e);
  if (Ci(e))
    return n;
  if (!Yn(e)) {
    let r = qa(e);
    for (; r && !Fr(r); ) {
      if (Tn(r) && !Pu(r))
        return r;
      r = qa(r);
    }
    return n;
  }
  let a = jp(e, t);
  for (; a && DS(a) && Pu(a); )
    a = jp(a, t);
  return a && Fr(a) && Pu(a) && !Bc(a) ? n : a || AS(e) || n;
}
const KS = async function(e) {
  const t = this.getOffsetParent || lg, n = this.getDimensions, a = await n(e.floating);
  return {
    reference: GS(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function YS(e) {
  return An(e).direction === "rtl";
}
const XS = {
  convertOffsetParentRelativeRectToViewportRelativeRect: VS,
  getDocumentElement: Jn,
  getClippingRect: jS,
  getOffsetParent: lg,
  getElementRects: KS,
  getClientRects: FS,
  getDimensions: WS,
  getScale: Dr,
  isElement: Tn,
  isRTL: YS
};
function ig(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function JS(e, t) {
  let n = null, a;
  const r = Jn(e);
  function o() {
    var i;
    clearTimeout(a), (i = n) == null || i.disconnect(), n = null;
  }
  function s(i, u) {
    i === void 0 && (i = !1), u === void 0 && (u = 1), o();
    const d = e.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: v
    } = d;
    if (i || t(), !p || !v)
      return;
    const m = Os(f), g = Os(r.clientWidth - (c + p)), w = Os(r.clientHeight - (f + v)), C = Os(c), $ = {
      rootMargin: -m + "px " + -g + "px " + -w + "px " + -C + "px",
      threshold: dn(0, Ma(1, u)) || 1
    };
    let k = !0;
    function B(D) {
      const P = D[0].intersectionRatio;
      if (P !== u) {
        if (!k)
          return s();
        P ? s(!1, P) : a = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      P === 1 && !ig(d, e.getBoundingClientRect()) && s(), k = !1;
    }
    try {
      n = new IntersectionObserver(B, {
        ...$,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(B, $);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function ZS(e, t, n, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = a, d = Pc(e), c = r || o ? [...d ? Io(d) : [], ...Io(t)] : [];
  c.forEach((C) => {
    r && C.addEventListener("scroll", n, {
      passive: !0
    }), o && C.addEventListener("resize", n);
  });
  const f = d && i ? JS(d, n) : null;
  let p = -1, v = null;
  s && (v = new ResizeObserver((C) => {
    let [S] = C;
    S && S.target === d && v && (v.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var $;
      ($ = v) == null || $.observe(t);
    })), n();
  }), d && !u && v.observe(d), v.observe(t));
  let m, g = u ? Ja(e) : null;
  u && w();
  function w() {
    const C = Ja(e);
    g && !ig(g, C) && n(), g = C, m = requestAnimationFrame(w);
  }
  return n(), () => {
    var C;
    c.forEach((S) => {
      r && S.removeEventListener("scroll", n), o && S.removeEventListener("resize", n);
    }), f?.(), (C = v) == null || C.disconnect(), v = null, u && cancelAnimationFrame(m);
  };
}
const QS = CS, e$ = SS, Wp = _S, t$ = BS, n$ = wS, a$ = bS, r$ = $S, o$ = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), r = {
    platform: XS,
    ...n
  }, o = {
    ...r.platform,
    _c: a
  };
  return yS(e, t, {
    ...r,
    platform: o
  });
};
function s$(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function gd(e) {
  if (s$(e)) {
    const t = e.$el;
    return $c(t) && lr(t) === "#comment" ? null : t;
  }
  return e;
}
function xr(e) {
  return typeof e == "function" ? e() : l(e);
}
function l$(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = gd(xr(e.element));
      return n == null ? {} : a$({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
function ug(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Gp(e, t) {
  const n = ug(e);
  return Math.round(t * n) / n;
}
function i$(e, t, n) {
  n === void 0 && (n = {});
  const a = n.whileElementsMounted, r = q(() => {
    var P;
    return (P = xr(n.open)) != null ? P : !0;
  }), o = q(() => xr(n.middleware)), s = q(() => {
    var P;
    return (P = xr(n.placement)) != null ? P : "bottom";
  }), i = q(() => {
    var P;
    return (P = xr(n.strategy)) != null ? P : "absolute";
  }), u = q(() => {
    var P;
    return (P = xr(n.transform)) != null ? P : !0;
  }), d = q(() => gd(e.value)), c = q(() => gd(t.value)), f = O(0), p = O(0), v = O(i.value), m = O(s.value), g = ht({}), w = O(!1), C = q(() => {
    const P = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return P;
    const E = Gp(c.value, f.value), T = Gp(c.value, p.value);
    return u.value ? {
      ...P,
      transform: "translate(" + E + "px, " + T + "px)",
      ...ug(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: E + "px",
      top: T + "px"
    };
  });
  let S;
  function $() {
    if (d.value == null || c.value == null)
      return;
    const P = r.value;
    o$(d.value, c.value, {
      middleware: o.value,
      placement: s.value,
      strategy: i.value
    }).then((E) => {
      f.value = E.x, p.value = E.y, v.value = E.strategy, m.value = E.placement, g.value = E.middlewareData, w.value = P !== !1;
    });
  }
  function k() {
    typeof S == "function" && (S(), S = void 0);
  }
  function B() {
    if (k(), a === void 0) {
      $();
      return;
    }
    if (d.value != null && c.value != null) {
      S = a(d.value, c.value, $);
      return;
    }
  }
  function D() {
    r.value || (w.value = !1);
  }
  return me([o, s, i, r], $, {
    flush: "sync"
  }), me([d, c], B, {
    flush: "sync"
  }), me(r, D, {
    flush: "sync"
  }), Qo() && ec(k), {
    x: hr(f),
    y: hr(p),
    strategy: hr(v),
    placement: hr(m),
    middlewareData: hr(g),
    isPositioned: hr(w),
    floatingStyles: C,
    update: $
  };
}
const dg = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [u$, d$] = Se("PopperContent");
var c$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ Jm({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...dg }),
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Qh(), { forwardRef: o, currentElement: s } = j(), i = O(), u = O(), { width: d, height: c } = Rh(u), f = q(() => n.side + (n.align !== "center" ? `-${n.align}` : "")), p = q(() => typeof n.collisionPadding == "number" ? n.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...n.collisionPadding
    }), v = q(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = q(() => ({
      padding: p.value,
      boundary: v.value.filter(oS),
      altBoundary: v.value.length > 0
    })), g = q(() => ({
      mainAxis: n.sideFlip,
      crossAxis: n.alignFlip
    })), w = k0(() => [
      QS({
        mainAxis: n.sideOffset + c.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && Wp({
        ...m.value,
        ...g.value
      }),
      n.avoidCollisions && e$({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? r$() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && Wp({
        ...m.value,
        ...g.value
      }),
      t$({
        ...m.value,
        apply: ({ elements: F, rects: J, availableWidth: ne, availableHeight: Q }) => {
          const { width: G, height: H } = J.reference, U = F.floating.style;
          U.setProperty("--reka-popper-available-width", `${ne}px`), U.setProperty("--reka-popper-available-height", `${Q}px`), U.setProperty("--reka-popper-anchor-width", `${G}px`), U.setProperty("--reka-popper-anchor-height", `${H}px`);
        }
      }),
      u.value && l$({
        element: u.value,
        padding: n.arrowPadding
      }),
      sS({
        arrowWidth: d.value,
        arrowHeight: c.value
      }),
      n.hideWhenDetached && n$({
        strategy: "referenceHidden",
        ...m.value
      })
    ]), C = q(() => n.reference ?? r.anchor.value), { floatingStyles: S, placement: $, isPositioned: k, middlewareData: B } = i$(C, i, {
      strategy: n.positionStrategy,
      placement: f,
      whileElementsMounted: (...F) => ZS(...F, {
        layoutShift: !n.disableUpdateOnLayoutShift,
        animationFrame: n.updatePositionStrategy === "always"
      }),
      middleware: w
    }), D = q(() => pd($.value)[0]), P = q(() => pd($.value)[1]);
    Xm(() => {
      k.value && a("placed");
    });
    const E = q(() => B.value.arrow?.centerOffset !== 0), T = O("");
    Ae(() => {
      s.value && (T.value = window.getComputedStyle(s.value).zIndex);
    });
    const M = q(() => B.value.arrow?.x ?? 0), I = q(() => B.value.arrow?.y ?? 0);
    return d$({
      placedSide: D,
      onArrowChange: (F) => u.value = F,
      arrowX: M,
      arrowY: I,
      shouldHideArrow: E
    }), (F, J) => (h(), W("div", {
      ref_key: "floatingRef",
      ref: i,
      "data-reka-popper-content-wrapper": "",
      style: dt({
        ...l(S),
        transform: l(k) ? l(S).transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: T.value,
        "--reka-popper-transform-origin": [l(B).transformOrigin?.x, l(B).transformOrigin?.y].join(" "),
        ...l(B).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [N(l(X), A({ ref: l(o) }, F.$attrs, {
      "as-child": n.asChild,
      as: F.as,
      "data-side": D.value,
      "data-align": P.value,
      style: { animation: l(k) ? void 0 : "none" }
    }), {
      default: y(() => [_(F.$slots, "default")]),
      _: 3
    }, 16, [
      "as-child",
      "as",
      "data-side",
      "data-align",
      "style"
    ])], 4));
  }
}), Yr = c$;
const f$ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var p$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {
      type: Number,
      required: !1
    },
    height: {
      type: Number,
      required: !1
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = u$(), a = q(() => f$[n.placedSide.value]);
    return (r, o) => (h(), W("span", {
      ref: (s) => {
        l(n).onArrowChange(s);
      },
      style: dt({
        position: "absolute",
        left: l(n).arrowX?.value ? `${l(n).arrowX?.value}px` : void 0,
        top: l(n).arrowY?.value ? `${l(n).arrowY?.value}px` : void 0,
        [a.value]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[l(n).placedSide.value],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[l(n).placedSide.value],
        visibility: l(n).shouldHideArrow.value ? "hidden" : void 0
      })
    }, [N(rS, A(r.$attrs, {
      ref: l(t),
      style: { display: "block" },
      as: r.as,
      "as-child": r.asChild,
      rounded: r.rounded,
      width: r.width,
      height: r.height
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "rounded",
      "width",
      "height"
    ])], 4));
  }
}), v$ = p$, m$ = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: t } = j();
    return (n, a) => (h(), x(l(sr), {
      "as-child": "",
      reference: n.reference
    }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "as-child": n.asChild,
        as: n.as
      }, n.$attrs), {
        default: y(() => [_(n.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), h$ = m$;
function g$(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => Po(a, t, n)) : Po(e, t, n);
}
function Po(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : Mn(e, t);
}
const [Bi, y$] = Se("ListboxRoot");
var b$ = /* @__PURE__ */ b({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { multiple: o, highlightOnHover: s, orientation: i, disabled: u, selectionBehavior: d, dir: c } = Me(a), { getItems: f } = st({ isProvider: !0 }), { handleTypeaheadSearch: p } = pi(), { primitiveElement: v, currentElement: m } = zt(), g = is(), w = gt(c), C = On(m), S = O(), $ = O(!1), k = O(!0), B = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (o.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function D(V) {
      if ($.value = !0, a.multiple) {
        const te = Array.isArray(B.value) ? [...B.value] : [], z = te.findIndex((re) => Po(re, V, a.by));
        a.selectionBehavior === "toggle" ? (z === -1 ? te.push(V) : te.splice(z, 1), B.value = te) : (B.value = [V], S.value = V);
      } else a.selectionBehavior === "toggle" && Po(B.value, V, a.by) ? B.value = void 0 : B.value = V;
      setTimeout(() => {
        $.value = !1;
      }, 1);
    }
    const P = O(null), E = O(null), T = O(!1), M = O(!1), I = $r(), F = $r(), J = $r();
    function ne() {
      return f().map((V) => V.ref).filter((V) => V.dataset.disabled !== "");
    }
    function Q(V, te = !0) {
      if (!V) return;
      P.value = V, k.value && P.value.focus(), te && P.value.scrollIntoView({ block: "nearest" });
      const z = f().find((re) => re.ref === V);
      r("highlight", z);
    }
    function G(V) {
      if (T.value) J.trigger(V);
      else {
        const te = f().find((z) => Po(z.value, V, a.by));
        te && (P.value = te.ref, Q(te.ref));
      }
    }
    function H(V) {
      P.value && P.value.isConnected && (V.preventDefault(), V.stopPropagation(), M.value || P.value.click());
    }
    function U(V) {
      if (k.value) {
        if ($.value = !0, T.value) F.trigger(V);
        else {
          const te = V.altKey || V.ctrlKey || V.metaKey;
          if (te && V.key === "a" && o.value) {
            const z = f(), re = z.map((ie) => ie.value);
            B.value = [...re], V.preventDefault(), Q(z[z.length - 1].ref);
          } else if (!te) {
            const z = p(V.key, f());
            z && Q(z);
          }
        }
        setTimeout(() => {
          $.value = !1;
        }, 1);
      }
    }
    function se() {
      M.value = !0;
    }
    function ee() {
      Pe(() => {
        M.value = !1;
      });
    }
    function de() {
      Pe(() => {
        const V = new KeyboardEvent("keydown", { key: "PageUp" });
        ye(V);
      });
    }
    function fe(V) {
      const te = P.value;
      te?.isConnected && (E.value = te), P.value = null, r("leave", V);
    }
    function _e(V) {
      const te = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if (V.currentTarget?.dispatchEvent(te), r("entryFocus", te), !te.defaultPrevented)
        if (E.value) Q(E.value);
        else {
          const z = ne()?.[0];
          Q(z);
        }
    }
    function ye(V) {
      const te = Xh(V, i.value, w.value);
      if (!te) return;
      let z = ne();
      if (P.value) {
        if (te === "last") z.reverse();
        else if (te === "prev" || te === "next") {
          te === "prev" && z.reverse();
          const re = z.indexOf(P.value);
          z = z.slice(re + 1);
        }
        Te(V, z[0]);
      }
      if (z.length) {
        const re = !P.value && te === "prev" ? z.length - 1 : 0;
        Q(z[re]);
      }
      if (T.value) return F.trigger(V);
    }
    function Te(V, te) {
      if (!(T.value || a.selectionBehavior !== "replace" || !o.value || !Array.isArray(B.value) || (V.altKey || V.ctrlKey || V.metaKey) && !V.shiftKey) && V.shiftKey) {
        const re = f().filter((be) => be.ref.dataset.disabled !== "");
        let ie = re.find((be) => be.ref === te)?.value;
        if (V.key === g.END ? ie = re[re.length - 1].value : V.key === g.HOME && (ie = re[0].value), !ie || !S.value) return;
        const L = S0(re.map((be) => be.value), S.value, ie);
        B.value = L;
      }
    }
    async function ce(V) {
      if (await Pe(), T.value) I.trigger(V);
      else {
        const te = ne(), z = te.find((re) => re.dataset.state === "checked");
        z ? Q(z) : te.length && Q(te[0]);
      }
    }
    return me(B, () => {
      $.value || Pe(() => {
        ce();
      });
    }, {
      immediate: !0,
      deep: !0
    }), t({
      highlightedElement: P,
      highlightItem: G,
      highlightFirstItem: de,
      highlightSelected: ce,
      getItems: f
    }), y$({
      modelValue: B,
      onValueChange: D,
      multiple: o,
      orientation: i,
      dir: w,
      disabled: u,
      highlightOnHover: s,
      highlightedElement: P,
      isVirtual: T,
      virtualFocusHook: I,
      virtualKeydownHook: F,
      virtualHighlightHook: J,
      by: a.by,
      firstValue: S,
      selectionBehavior: d,
      focusable: k,
      onLeave: fe,
      onEnter: _e,
      changeHighlight: Q,
      onKeydownEnter: H,
      onKeydownNavigation: ye,
      onKeydownTypeAhead: U,
      onCompositionStart: se,
      onCompositionEnd: ee,
      highlightFirstItem: de
    }), (V, te) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: v,
      as: V.as,
      "as-child": V.asChild,
      dir: l(w),
      "data-disabled": l(u) ? "" : void 0,
      onPointerleave: fe,
      onFocusout: te[0] || (te[0] = async (z) => {
        const re = z.relatedTarget || z.target;
        await Pe(), P.value && l(m) && !l(m).contains(re) && fe(z);
      })
    }, {
      default: y(() => [_(V.$slots, "default", { modelValue: l(B) }), l(C) && V.name ? (h(), x(l(In), {
        key: 0,
        name: V.name,
        value: l(B),
        disabled: l(u),
        required: V.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : qe("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), cg = b$, _$ = /* @__PURE__ */ b({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: t } = st(), n = Bi(), a = rs(!1, 10);
    return (r, o) => (h(), x(l(t), null, {
      default: y(() => [N(l(X), {
        role: "listbox",
        as: r.as,
        "as-child": r.asChild,
        tabindex: l(n).focusable.value ? l(n).highlightedElement.value ? "-1" : "0" : "-1",
        "aria-orientation": l(n).orientation.value,
        "aria-multiselectable": !!l(n).multiple.value,
        "data-orientation": l(n).orientation.value,
        onMousedown: o[0] || (o[0] = Ye((s) => a.value = !0, ["left"])),
        onFocus: o[1] || (o[1] = (s) => {
          l(a) || l(n).onEnter(s);
        }),
        onKeydown: [
          o[2] || (o[2] = Je((s) => {
            l(n).orientation.value === "vertical" && (s.key === "ArrowLeft" || s.key === "ArrowRight") || l(n).orientation.value === "horizontal" && (s.key === "ArrowUp" || s.key === "ArrowDown") || (s.preventDefault(), l(n).focusable.value && l(n).onKeydownNavigation(s));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          Je(l(n).onKeydownEnter, ["enter"]),
          l(n).onKeydownTypeAhead
        ]
      }, {
        default: y(() => [_(r.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), fg = _$, w$ = /* @__PURE__ */ b({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "modelValue", t, {
      defaultValue: "",
      passive: n.modelValue === void 0
    }), o = Bi(), { primitiveElement: s, currentElement: i } = zt(), u = q(() => n.disabled || o.disabled.value || !1), d = O();
    return u0(() => d.value = o.highlightedElement.value?.id), Ce(() => {
      o.focusable.value = !1, setTimeout(() => {
        n.autoFocus && i.value?.focus();
      }, 1);
    }), nt(() => {
      o.focusable.value = !0;
    }), (c, f) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: s,
      as: c.as,
      "as-child": c.asChild,
      value: l(r),
      disabled: u.value ? "" : void 0,
      "data-disabled": u.value ? "" : void 0,
      "aria-disabled": u.value ?? void 0,
      "aria-activedescendant": d.value,
      type: "text",
      onKeydown: [Je(Ye(l(o).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), Je(l(o).onKeydownEnter, ["enter"])],
      onInput: f[0] || (f[0] = (p) => {
        r.value = p.target.value, l(o).highlightFirstItem();
      }),
      onCompositionstart: l(o).onCompositionStart,
      onCompositionend: l(o).onCompositionEnd
    }, {
      default: y(() => [_(c.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), pg = w$;
const [x$, C$] = Se("ListboxGroup");
var S$ = /* @__PURE__ */ b({
  __name: "ListboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-listbox-group");
    return C$({ id: n }), (a, r) => (h(), x(l(X), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), vg = S$, $$ = /* @__PURE__ */ b({
  __name: "ListboxGroupLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = x$({ id: "" });
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).id }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), B$ = $$;
const k$ = "listbox.select", [P$, D$] = Se("ListboxItem");
var M$ = /* @__PURE__ */ b({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ge(void 0, "reka-listbox-item"), { CollectionItem: o } = st(), { forwardRef: s, currentElement: i } = j(), u = Bi(), d = q(() => i.value === u.highlightedElement.value), c = q(() => g$(u.modelValue.value, n.value, u.by)), f = q(() => u.disabled.value || n.disabled);
    async function p(m) {
      a("select", m), !m?.defaultPrevented && !f.value && m && (u.onValueChange(n.value), u.changeHighlight(i.value));
    }
    function v(m) {
      const g = {
        originalEvent: m,
        value: n.value
      };
      ts(k$, p, g);
    }
    return D$({ isSelected: c }), (m, g) => (h(), x(l(o), { value: m.value }, {
      default: y(() => [d0([d.value, c.value], () => N(l(X), A({ id: l(r) }, m.$attrs, {
        ref: l(s),
        role: "option",
        tabindex: l(u).focusable.value ? d.value ? "0" : "-1" : -1,
        "aria-selected": c.value,
        as: m.as,
        "as-child": m.asChild,
        disabled: f.value ? "" : void 0,
        "data-disabled": f.value ? "" : void 0,
        "data-highlighted": d.value ? "" : void 0,
        "data-state": c.value ? "checked" : "unchecked",
        onClick: v,
        onKeydown: Je(Ye(v, ["prevent"]), ["space"]),
        onPointermove: g[0] || (g[0] = () => {
          l(u).highlightedElement.value !== l(i) && l(u).highlightOnHover.value && !l(u).focusable.value && l(u).changeHighlight(l(i), !1);
        })
      }), {
        default: y(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), g, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), mg = M$, q$ = /* @__PURE__ */ b({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = P$();
    return (a, r) => l(n).isSelected.value ? (h(), x(l(X), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : qe("v-if", !0);
  }
}), E$ = q$;
const [ma, T$] = Se("ComboboxRoot");
var A$ = /* @__PURE__ */ b({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    resetModelValueOnClear: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1,
      default: !0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { primitiveElement: o, currentElement: s } = zt(), { multiple: i, disabled: u, ignoreFilter: d, resetSearchTermOnSelect: c, openOnFocus: f, openOnClick: p, dir: v, resetModelValueOnClear: m, highlightOnHover: g } = Me(a), w = gt(v), C = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (i.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), S = Ve(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function $(G) {
      S.value = G, J.value = "", G ? (await Pe(), o.value?.highlightSelected(), B.value = !0, P.value?.focus()) : (B.value = !1, setTimeout(() => {
        !G && a.resetSearchTermOnBlur && k.trigger();
      }, 1));
    }
    const k = $r(), B = O(!1), D = O(!1), P = O(), E = O(), T = q(() => o.value?.highlightedElement ?? void 0), M = O(/* @__PURE__ */ new Map()), I = O(/* @__PURE__ */ new Map()), { contains: F } = Ah({ sensitivity: "base" }), J = O(""), ne = q((G) => {
      if (!J.value || a.ignoreFilter || D.value) return {
        count: M.value.size,
        items: G?.items ?? /* @__PURE__ */ new Map(),
        groups: G?.groups ?? new Set(I.value.keys())
      };
      let H = 0;
      const U = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Set();
      for (const [ee, de] of M.value) {
        const fe = F(de, J.value);
        U.set(ee, fe ? 1 : 0), fe && H++;
      }
      for (const [ee, de] of I.value) for (const fe of de) if (U.get(fe) > 0) {
        se.add(ee);
        break;
      }
      return {
        count: H,
        items: U,
        groups: se
      };
    }), Q = Pt();
    return Ce(() => {
      Q?.exposed && (Q.exposed.highlightItem = o.value?.highlightItem, Q.exposed.highlightFirstItem = o.value?.highlightFirstItem, Q.exposed.highlightSelected = o.value?.highlightSelected);
    }), t({
      filtered: ne,
      highlightedElement: T,
      highlightItem: o.value?.highlightItem,
      highlightFirstItem: o.value?.highlightFirstItem,
      highlightSelected: o.value?.highlightSelected
    }), T$({
      modelValue: C,
      multiple: i,
      disabled: u,
      open: S,
      onOpenChange: $,
      contentId: "",
      isUserInputted: B,
      isVirtual: D,
      inputElement: P,
      highlightedElement: T,
      onInputElementChange: (G) => P.value = G,
      triggerElement: E,
      onTriggerElementChange: (G) => E.value = G,
      parentElement: s,
      resetSearchTermOnSelect: c,
      onResetSearchTerm: k.on,
      allItems: M,
      allGroups: I,
      filterSearch: J,
      filterState: ne,
      ignoreFilter: d,
      openOnFocus: f,
      openOnClick: p,
      resetModelValueOnClear: m
    }), (G, H) => (h(), x(l(or), null, {
      default: y(() => [N(l(cg), A({
        ref_key: "primitiveElement",
        ref: o
      }, G.$attrs, {
        modelValue: l(C),
        "onUpdate:modelValue": H[0] || (H[0] = (U) => mt(C) ? C.value = U : null),
        style: { pointerEvents: l(S) ? "auto" : void 0 },
        as: G.as,
        "as-child": G.asChild,
        dir: l(w),
        multiple: l(i),
        name: G.name,
        required: G.required,
        disabled: l(u),
        "highlight-on-hover": l(g),
        by: a.by,
        onHighlight: H[1] || (H[1] = (U) => r("highlight", U))
      }), {
        default: y(() => [_(G.$slots, "default", {
          open: l(S),
          modelValue: l(C)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "highlight-on-hover",
        "by"
      ])]),
      _: 3
    }));
  }
}), O$ = A$;
const [fH, I$] = Se("ComboboxContent");
var R$ = /* @__PURE__ */ b({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { position: r } = Me(n), o = ma(), { forwardRef: s, currentElement: i } = j();
    os(n.bodyLock), ls(o.parentElement);
    const u = q(() => n.position === "popper" ? n : {}), d = he(u.value), c = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    I$({ position: r });
    const f = O(!1);
    return Ce(() => {
      o.inputElement.value && (f.value = i.value.contains(o.inputElement.value), f.value && o.inputElement.value.focus());
    }), nt(() => {
      const p = ot();
      f.value && (!p || p === document.body) && o.triggerElement.value?.focus();
    }), (p, v) => (h(), x(l(fg), { "as-child": "" }, {
      default: y(() => [N(l(Oa), {
        "as-child": "",
        "disable-outside-pointer-events": p.disableOutsidePointerEvents,
        onDismiss: v[0] || (v[0] = (m) => l(o).onOpenChange(!1)),
        onFocusOutside: v[1] || (v[1] = (m) => {
          l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("focusOutside", m);
        }),
        onInteractOutside: v[2] || (v[2] = (m) => a("interactOutside", m)),
        onEscapeKeyDown: v[3] || (v[3] = (m) => a("escapeKeyDown", m)),
        onPointerDownOutside: v[4] || (v[4] = (m) => {
          l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("pointerDownOutside", m);
        })
      }, {
        default: y(() => [(h(), x(kt(l(r) === "popper" ? l(Yr) : l(X)), A({
          ...p.$attrs,
          ...l(d)
        }, {
          id: l(o).contentId,
          ref: l(s),
          "data-state": l(o).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...l(r) === "popper" ? c : {}
          }
        }), {
          default: y(() => [_(p.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), V$ = R$, F$ = /* @__PURE__ */ b({
  __name: "ComboboxCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = ma();
    function a() {
      n.filterSearch.value = "", n.inputElement.value && (n.inputElement.value.value = "", n.inputElement.value.focus()), n.resetModelValueOnClear?.value && (n.modelValue.value = n.multiple.value ? [] : null);
    }
    return (r, o) => (h(), x(l(X), A({ type: r.as === "button" ? "button" : void 0 }, t, {
      tabindex: "-1",
      onClick: a
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), pH = F$, N$ = /* @__PURE__ */ b({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), { forwardRef: o } = j(), s = ma();
    return s.contentId ||= Ge(void 0, "reka-combobox-content"), (i, u) => (h(), x(l(Ct), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(V$, A({
        ...l(r),
        ...i.$attrs
      }, { ref: l(o) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), L$ = N$, z$ = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ma(), a = q(() => n.ignoreFilter.value ? n.allItems.value.size === 0 : n.filterState.value.count === 0);
    return (r, o) => a.value ? (h(), x(l(X), oe(A({ key: 0 }, t)), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[0] || (o[0] = Re("No options"))])]),
      _: 3
    }, 16)) : qe("v-if", !0);
  }
}), H$ = z$;
const [hg, U$] = Se("ComboboxGroup");
var j$ = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-combobox-group"), a = ma(), r = q(() => a.ignoreFilter.value ? !0 : a.filterSearch.value ? a.filterState.value.groups.has(n) : !0), o = U$({
      id: n,
      labelId: ""
    });
    return Ce(() => {
      a.allGroups.value.has(n) || a.allGroups.value.set(n, /* @__PURE__ */ new Set());
    }), nt(() => {
      a.allGroups.value.delete(n);
    }), (s, i) => (h(), x(l(vg), A({
      id: l(n),
      "aria-labelledby": l(o).labelId
    }, t, { hidden: r.value ? void 0 : !0 }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "hidden"
    ]));
  }
}), W$ = j$, G$ = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ma(), o = Bi(), { primitiveElement: s, currentElement: i } = zt(), u = Ve(n, "modelValue", a, { passive: n.modelValue === void 0 });
    Ce(() => {
      i.value && r.onInputElementChange(i.value);
    });
    function d(m) {
      r.open.value || r.onOpenChange(!0);
    }
    function c(m) {
      const g = m.target;
      r.open.value ? r.filterSearch.value = g.value : (r.onOpenChange(!0), Pe(() => {
        g.value && (r.filterSearch.value = g.value, o.highlightFirstItem());
      }));
    }
    function f() {
      r.openOnFocus.value && !r.open.value && r.onOpenChange(!0);
    }
    function p() {
      r.openOnClick.value && !r.open.value && r.onOpenChange(!0);
    }
    function v() {
      const m = r.modelValue.value;
      n.displayValue ? u.value = n.displayValue(m) : !r.multiple.value && m && !Array.isArray(m) && typeof m != "object" ? u.value = m.toString() : u.value = "", Pe(() => {
        u.value = u.value;
      });
    }
    return r.onResetSearchTerm(() => {
      v();
    }), me(r.modelValue, async () => {
      !r.isUserInputted.value && r.resetSearchTermOnSelect.value && v();
    }, {
      immediate: !0,
      deep: !0
    }), me(r.filterState, (m, g) => {
      !r.isVirtual.value && g.count === 0 && o.highlightFirstItem();
    }), (m, g) => (h(), x(l(pg), {
      ref_key: "primitiveElement",
      ref: s,
      modelValue: l(u),
      "onUpdate:modelValue": g[0] || (g[0] = (w) => mt(u) ? u.value = w : null),
      as: m.as,
      "as-child": m.asChild,
      "auto-focus": m.autoFocus,
      disabled: m.disabled,
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: p,
      onInput: c,
      onKeydown: Je(Ye(d, ["prevent"]), ["down", "up"]),
      onFocus: f
    }, {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), K$ = G$, Y$ = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ge(void 0, "reka-combobox-item"), o = ma(), s = hg(null), { primitiveElement: i, currentElement: u } = zt();
    if (n.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const d = q(() => {
      if (o.isVirtual.value || o.ignoreFilter.value || !o.filterSearch.value) return !0;
      {
        const c = o.filterState.value.items.get(r);
        return c === void 0 ? !0 : c > 0;
      }
    });
    return Ce(() => {
      o.allItems.value.set(r, n.textValue || u.value.textContent || u.value.innerText);
      const c = s?.id;
      c && (o.allGroups.value.has(c) ? o.allGroups.value.get(c)?.add(r) : o.allGroups.value.set(c, /* @__PURE__ */ new Set([r])));
    }), nt(() => {
      o.allItems.value.delete(r);
    }), (c, f) => d.value ? (h(), x(l(mg), A({ key: 0 }, n, {
      id: l(r),
      ref_key: "primitiveElement",
      ref: i,
      disabled: l(o).disabled.value || c.disabled,
      onSelect: f[0] || (f[0] = (p) => {
        a("select", p), !p.defaultPrevented && !l(o).multiple.value && !c.disabled && !l(o).disabled.value && (p.preventDefault(), l(o).onOpenChange(!1), l(o).modelValue.value = n.value);
      })
    }), {
      default: y(() => [_(c.$slots, "default", {}, () => [Re(Ne(c.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : qe("v-if", !0);
  }
}), X$ = Y$, J$ = /* @__PURE__ */ b({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(E$), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), vH = J$, Z$ = /* @__PURE__ */ b({
  __name: "ComboboxLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = hg({
      id: "",
      labelId: ""
    });
    return n.labelId ||= Ge(void 0, "reka-combobox-group-label"), (a, r) => (h(), x(l(X), A(t, { id: l(n).labelId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Q$ = Z$, eB = /* @__PURE__ */ b({
  __name: "ComboboxPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), tB = eB, nB = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), aB = nB, rB = /* @__PURE__ */ b({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = ma(), o = q(() => t.disabled || r.disabled.value || !1);
    return Ce(() => {
      a.value && r.onTriggerElementChange(a.value);
    }), (s, i) => (h(), x(l(X), A(t, {
      ref: l(n),
      type: s.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "data-state": l(r).open.value ? "open" : "closed",
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "aria-disabled": o.value ?? void 0,
      onClick: i[0] || (i[0] = (u) => l(r).onOpenChange(!l(r).open.value))
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), mH = rB;
function ki(e) {
  const t = ns({ nonce: O() });
  return q(() => e?.value || t.nonce?.value);
}
var oB = /* @__PURE__ */ b({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), { nonce: a } = Me(t), r = ki(a), o = ma();
    return (s, i) => (h(), W(Ke, null, [N(l(X), A({
      ...s.$attrs,
      ...t
    }, {
      ref: l(n),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: l(o).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["style"]), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: y(() => i[0] || (i[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), sB = oB, lB = /* @__PURE__ */ b({
  __name: "MenuAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(sr), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Pi = lB;
function iB() {
  const e = O(!1);
  return Ce(() => {
    Lt("keydown", () => {
      e.value = !0;
    }, {
      capture: !0,
      passive: !0
    }), Lt(["pointerdown", "pointermove"], () => {
      e.value = !1;
    }, {
      capture: !0,
      passive: !0
    });
  }), e;
}
const uB = nh(iB), [ir, gg] = Se(["MenuRoot", "MenuSub"], "MenuContext"), [vs, dB] = Se("MenuRoot");
var cB = /* @__PURE__ */ b({
  __name: "MenuRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r, dir: o } = Me(n), s = gt(o), i = Ve(n, "open", a), u = O(), d = uB();
    return gg({
      open: i,
      onOpenChange: (c) => {
        i.value = c;
      },
      content: u,
      onContentChange: (c) => {
        u.value = c;
      }
    }), dB({
      onClose: () => {
        i.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: s,
      modal: r
    }), (c, f) => (h(), x(l(or), null, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }));
  }
}), Dc = cB;
const [Mc, fB] = Se("MenuContent");
var pB = /* @__PURE__ */ b({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ Jm({
    loop: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    disableOutsideScroll: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...dg }),
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ir(), o = vs(), { trapFocus: s, disableOutsidePointerEvents: i, loop: u } = Me(n);
    hc(), os(i.value);
    const d = O(""), c = O(0), f = O(0), p = O(null), v = O("right"), m = O(0), g = O(null), w = O(), { forwardRef: C, currentElement: S } = j(), { handleTypeaheadSearch: $ } = pi();
    me(S, (T) => {
      r.onContentChange(T);
    }), nt(() => {
      window.clearTimeout(c.value);
    });
    function k(T) {
      return v.value === p.value?.side && dx(T, p.value?.area);
    }
    async function B(T) {
      a("openAutoFocus", T), !T.defaultPrevented && (T.preventDefault(), S.value?.focus({ preventScroll: !0 }));
    }
    function D(T) {
      if (T.defaultPrevented) return;
      const I = T.target.closest("[data-reka-menu-content]") === T.currentTarget, F = T.ctrlKey || T.altKey || T.metaKey, J = T.key.length === 1, ne = rr(T, ot(), S.value, {
        loop: u.value,
        arrowKeyOptions: "vertical",
        dir: o?.dir.value,
        focus: !0,
        attributeName: "[data-reka-collection-item]:not([data-disabled])"
      });
      if (ne) return ne?.focus();
      if (T.code === "Space") return;
      const Q = w.value?.getItems() ?? [];
      if (I && (T.key === "Tab" && T.preventDefault(), !F && J && $(T.key, Q)), T.target !== S.value || !sx.includes(T.key)) return;
      T.preventDefault();
      const G = [...Q.map((H) => H.ref)];
      Wh.includes(T.key) && G.reverse(), fd(G);
    }
    function P(T) {
      T?.currentTarget?.contains?.(T.target) || (window.clearTimeout(c.value), d.value = "");
    }
    function E(T) {
      if (!Ao(T)) return;
      const M = T.target, I = m.value !== T.clientX;
      if (T?.currentTarget?.contains(M) && I) {
        const F = T.clientX > m.value ? "right" : "left";
        v.value = F, m.value = T.clientX;
      }
    }
    return fB({
      onItemEnter: (T) => !!k(T),
      onItemLeave: (T) => {
        k(T) || (S.value?.focus(), g.value = null);
      },
      onTriggerLeave: (T) => !!k(T),
      searchRef: d,
      pointerGraceTimerRef: f,
      onPointerGraceIntentChange: (T) => {
        p.value = T;
      }
    }), (T, M) => (h(), x(l(hi), {
      "as-child": "",
      trapped: l(s),
      onMountAutoFocus: B,
      onUnmountAutoFocus: M[7] || (M[7] = (I) => a("closeAutoFocus", I))
    }, {
      default: y(() => [N(l(Oa), {
        "as-child": "",
        "disable-outside-pointer-events": l(i),
        onEscapeKeyDown: M[2] || (M[2] = (I) => a("escapeKeyDown", I)),
        onPointerDownOutside: M[3] || (M[3] = (I) => a("pointerDownOutside", I)),
        onFocusOutside: M[4] || (M[4] = (I) => a("focusOutside", I)),
        onInteractOutside: M[5] || (M[5] = (I) => a("interactOutside", I)),
        onDismiss: M[6] || (M[6] = (I) => a("dismiss"))
      }, {
        default: y(() => [N(l(cs), {
          ref_key: "rovingFocusGroupRef",
          ref: w,
          "current-tab-stop-id": g.value,
          "onUpdate:currentTabStopId": M[0] || (M[0] = (I) => g.value = I),
          "as-child": "",
          orientation: "vertical",
          dir: l(o).dir.value,
          loop: l(u),
          onEntryFocus: M[1] || (M[1] = (I) => {
            a("entryFocus", I), l(o).isUsingKeyboardRef.value || I.preventDefault();
          })
        }, {
          default: y(() => [N(l(Yr), {
            ref: l(C),
            role: "menu",
            as: T.as,
            "as-child": T.asChild,
            "aria-orientation": "vertical",
            "data-reka-menu-content": "",
            "data-state": l(_c)(l(r).open.value),
            dir: l(o).dir.value,
            side: T.side,
            "side-offset": T.sideOffset,
            align: T.align,
            "align-offset": T.alignOffset,
            "avoid-collisions": T.avoidCollisions,
            "collision-boundary": T.collisionBoundary,
            "collision-padding": T.collisionPadding,
            "arrow-padding": T.arrowPadding,
            "prioritize-position": T.prioritizePosition,
            "position-strategy": T.positionStrategy,
            "update-position-strategy": T.updatePositionStrategy,
            sticky: T.sticky,
            "hide-when-detached": T.hideWhenDetached,
            reference: T.reference,
            onKeydown: D,
            onBlur: P,
            onPointermove: E
          }, {
            default: y(() => [_(T.$slots, "default")]),
            _: 3
          }, 8, [
            "as",
            "as-child",
            "data-state",
            "dir",
            "side",
            "side-offset",
            "align",
            "align-offset",
            "avoid-collisions",
            "collision-boundary",
            "collision-padding",
            "arrow-padding",
            "prioritize-position",
            "position-strategy",
            "update-position-strategy",
            "sticky",
            "hide-when-detached",
            "reference"
          ])]),
          _: 3
        }, 8, [
          "current-tab-stop-id",
          "dir",
          "loop"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), qc = pB, vB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Mc(), { forwardRef: a } = j(), { CollectionItem: r } = st(), o = O(!1);
    async function s(u) {
      u.defaultPrevented || Ao(u) && (t.disabled ? n.onItemLeave(u) : n.onItemEnter(u) || u.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function i(u) {
      await Pe(), !u.defaultPrevented && Ao(u) && n.onItemLeave(u);
    }
    return (u, d) => (h(), x(l(r), { value: { textValue: u.textValue } }, {
      default: y(() => [N(l(X), A({
        ref: l(a),
        role: "menuitem",
        tabindex: "-1"
      }, u.$attrs, {
        as: u.as,
        "as-child": u.asChild,
        "aria-disabled": u.disabled || void 0,
        "data-disabled": u.disabled ? "" : void 0,
        "data-highlighted": o.value ? "" : void 0,
        onPointermove: s,
        onPointerleave: i,
        onFocus: d[0] || (d[0] = async (c) => {
          await Pe(), !(c.defaultPrevented || u.disabled) && (o.value = !0);
        }),
        onBlur: d[1] || (d[1] = async (c) => {
          await Pe(), !c.defaultPrevented && (o.value = !1);
        })
      }), {
        default: y(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-disabled",
        "data-disabled",
        "data-highlighted"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), yg = vB, mB = /* @__PURE__ */ b({
  __name: "MenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = vs(), i = Mc(), u = O(!1);
    async function d() {
      const c = o.value;
      if (!n.disabled && c) {
        const f = new CustomEvent(rx, {
          bubbles: !0,
          cancelable: !0
        });
        a("select", f), await Pe(), f.defaultPrevented ? u.value = !1 : s.onClose();
      }
    }
    return (c, f) => (h(), x(yg, A(n, {
      ref: l(r),
      onClick: d,
      onPointerdown: f[0] || (f[0] = () => {
        u.value = !0;
      }),
      onPointerup: f[1] || (f[1] = async (p) => {
        await Pe(), !p.defaultPrevented && (u.value || p.currentTarget?.click());
      }),
      onKeydown: f[2] || (f[2] = async (p) => {
        const v = l(i).searchRef.value !== "";
        c.disabled || v && p.key === " " || l(cd).includes(p.key) && (p.currentTarget.click(), p.preventDefault());
      })
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ms = mB;
const [hB, bg] = Se(["MenuCheckboxItem", "MenuRadioItem"], "MenuItemIndicatorContext");
var gB = /* @__PURE__ */ b({
  __name: "MenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = hB({ modelValue: O(!1) });
    return (n, a) => (h(), x(l(Ct), { present: n.forceMount || l(Bl)(l(t).modelValue.value) || l(t).modelValue.value === !0 }, {
      default: y(() => [N(l(X), {
        as: n.as,
        "as-child": n.asChild,
        "data-state": l(wc)(l(t).modelValue.value)
      }, {
        default: y(() => [_(n.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Ec = gB, yB = /* @__PURE__ */ b({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = as(n, ["modelValue"]), o = he(r), s = Ve(n, "modelValue", a);
    return bg({ modelValue: s }), (i, u) => (h(), x(ms, A({ role: "menuitemcheckbox" }, l(o), {
      "aria-checked": l(Bl)(l(s)) ? "mixed" : l(s),
      "data-state": l(wc)(l(s)),
      onSelect: u[0] || (u[0] = async (d) => {
        a("select", d), l(Bl)(l(s)) ? s.value = !0 : s.value = !l(s);
      })
    }), {
      default: y(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Tc = yB, bB = /* @__PURE__ */ b({
  __name: "MenuRootContentModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ve(n, a), o = ir(), { forwardRef: s, currentElement: i } = j();
    return ls(i), (u, d) => (h(), x(qc, A(l(r), {
      ref: l(s),
      "trap-focus": l(o).open.value,
      "disable-outside-pointer-events": l(o).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (c) => l(o).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = Ye((c) => a("focusOutside", c), ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), _B = bB, wB = /* @__PURE__ */ b({
  __name: "MenuRootContentNonModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), o = ir();
    return (s, i) => (h(), x(qc, A(l(r), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (u) => l(o).onOpenChange(!1))
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xB = wB, CB = /* @__PURE__ */ b({
  __name: "MenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), o = ir(), s = vs();
    return (i, u) => (h(), x(l(Ct), { present: i.forceMount || l(o).open.value }, {
      default: y(() => [l(s).modal.value ? (h(), x(_B, oe(A({ key: 0 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(xB, oe(A({ key: 1 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), Ac = CB, SB = /* @__PURE__ */ b({
  __name: "MenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({ role: "group" }, t), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Di = SB, $B = /* @__PURE__ */ b({
  __name: "MenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Oc = $B, BB = /* @__PURE__ */ b({
  __name: "MenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ic = BB;
const [kB, PB] = Se("MenuRadioGroup");
var DB = /* @__PURE__ */ b({
  __name: "MenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = as(n, ["modelValue"]), o = he(r), s = Ve(n, "modelValue", a);
    return PB({
      modelValue: s,
      onValueChange: (i) => {
        s.value = i;
      }
    }), (i, u) => (h(), x(Di, oe(le(l(o))), {
      default: y(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16));
  }
}), Rc = DB, MB = /* @__PURE__ */ b({
  __name: "MenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = as(n, ["value"]), o = he(r), { value: s } = Me(n), i = kB(), u = q(() => i.modelValue.value === s?.value);
    return bg({ modelValue: u }), (d, c) => (h(), x(ms, A({ role: "menuitemradio" }, l(o), {
      "aria-checked": u.value,
      "data-state": l(wc)(u.value),
      onSelect: c[0] || (c[0] = async (f) => {
        a("select", f), l(i).onValueChange(l(s));
      })
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Vc = MB, qB = /* @__PURE__ */ b({
  __name: "MenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Fc = qB;
const [_g, EB] = Se("MenuSub");
var TB = /* @__PURE__ */ b({
  __name: "MenuSub",
  props: { open: {
    type: Boolean,
    required: !1,
    default: void 0
  } },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      defaultValue: !1,
      passive: n.open === void 0
    }), o = ir(), s = O(), i = O();
    return Ae((u) => {
      o?.open.value === !1 && (r.value = !1), u(() => r.value = !1);
    }), gg({
      open: r,
      onOpenChange: (u) => {
        r.value = u;
      },
      content: i,
      onContentChange: (u) => {
        i.value = u;
      }
    }), EB({
      triggerId: "",
      contentId: "",
      trigger: s,
      onTriggerChange: (u) => {
        s.value = u;
      }
    }), (u, d) => (h(), x(l(or), null, {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }));
  }
}), Nc = TB, AB = /* @__PURE__ */ b({
  __name: "MenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1,
      default: !0
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), o = ir(), s = vs(), i = _g(), { forwardRef: u, currentElement: d } = j();
    return i.contentId ||= Ge(void 0, "reka-menu-sub-content"), (c, f) => (h(), x(l(Ct), { present: c.forceMount || l(o).open.value }, {
      default: y(() => [N(qc, A(l(r), {
        id: l(i).contentId,
        ref: l(u),
        "aria-labelledby": l(i).triggerId,
        align: "start",
        side: l(s).dir.value === "rtl" ? "left" : "right",
        "disable-outside-pointer-events": !1,
        "disable-outside-scroll": !1,
        "trap-focus": !1,
        onOpenAutoFocus: f[0] || (f[0] = Ye((p) => {
          l(s).isUsingKeyboardRef.value && l(d)?.focus();
        }, ["prevent"])),
        onCloseAutoFocus: f[1] || (f[1] = Ye(() => {
        }, ["prevent"])),
        onFocusOutside: f[2] || (f[2] = (p) => {
          p.defaultPrevented || p.target !== l(i).trigger.value && l(o).onOpenChange(!1);
        }),
        onEscapeKeyDown: f[3] || (f[3] = (p) => {
          l(s).onClose(), p.preventDefault();
        }),
        onKeydown: f[4] || (f[4] = (p) => {
          const v = p.currentTarget?.contains(p.target), m = l(ix)[l(s).dir.value].includes(p.key);
          v && m && (l(o).onOpenChange(!1), l(i).trigger.value?.focus(), p.preventDefault());
        })
      }), {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "side"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Lc = AB, OB = /* @__PURE__ */ b({
  __name: "MenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ir(), a = vs(), r = _g(), o = Mc(), s = O(null);
    r.triggerId ||= Ge(void 0, "reka-menu-sub-trigger");
    function i() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    nt(() => {
      i();
    });
    function u(f) {
      !Ao(f) || o.onItemEnter(f) || !t.disabled && !n.open.value && !s.value && (o.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), i();
      }, 100));
    }
    async function d(f) {
      if (!Ao(f)) return;
      i();
      const p = n.content.value?.getBoundingClientRect();
      if (p?.width) {
        const v = n.content.value?.dataset.side, m = v === "right", g = m ? -5 : 5, w = p[m ? "left" : "right"], C = p[m ? "right" : "left"];
        o.onPointerGraceIntentChange({
          area: [
            {
              x: f.clientX + g,
              y: f.clientY
            },
            {
              x: w,
              y: p.top
            },
            {
              x: C,
              y: p.top
            },
            {
              x: C,
              y: p.bottom
            },
            {
              x: w,
              y: p.bottom
            }
          ],
          side: v
        }), window.clearTimeout(o.pointerGraceTimerRef.value), o.pointerGraceTimerRef.value = window.setTimeout(() => o.onPointerGraceIntentChange(null), 300);
      } else {
        if (o.onTriggerLeave(f)) return;
        o.onPointerGraceIntentChange(null);
      }
    }
    async function c(f) {
      const p = o.searchRef.value !== "";
      t.disabled || p && f.key === " " || lx[a.dir.value].includes(f.key) && (n.onOpenChange(!0), await Pe(), n.content.value?.focus(), f.preventDefault());
    }
    return (f, p) => (h(), x(Pi, { "as-child": "" }, {
      default: y(() => [N(yg, A(t, {
        id: l(r).triggerId,
        ref: (v) => {
          l(r)?.onTriggerChange(v?.$el);
        },
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(r).contentId,
        "data-state": l(_c)(l(n).open.value),
        onClick: p[0] || (p[0] = async (v) => {
          t.disabled || v.defaultPrevented || (v.currentTarget.focus(), l(n).open.value || l(n).onOpenChange(!0));
        }),
        onPointermove: u,
        onPointerleave: d,
        onKeydown: c
      }), {
        default: y(() => [_(f.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-expanded",
        "aria-controls",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), zc = OB, IB = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(Tc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), RB = IB;
const [wg, VB] = Se("ContextMenuRoot");
var FB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuRoot",
  props: {
    pressOpenDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, modal: o, pressOpenDelay: s } = Me(n);
    j();
    const i = gt(r), u = O(!1), d = O();
    return VB({
      open: u,
      onOpenChange: (c) => {
        u.value = c;
      },
      dir: i,
      modal: o,
      triggerElement: d,
      pressOpenDelay: s
    }), me(u, (c) => {
      a("update:open", c);
    }), (c, f) => (h(), x(l(Dc), {
      open: u.value,
      "onUpdate:open": f[0] || (f[0] = (p) => u.value = p),
      dir: l(i),
      modal: l(o)
    }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), NB = FB, LB = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const o = wg(), s = O(!1);
    return (i, u) => (h(), x(l(Ac), A(l(r), {
      side: "right",
      "side-offset": 2,
      align: "start",
      "update-position-strategy": "always",
      style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        !d.defaultPrevented && s.value && d.preventDefault(), s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        d.detail.originalEvent.button === 2 && d.target === l(o).triggerElement.value && d.preventDefault(), !d.defaultPrevented && !l(o).modal.value && (s.value = !0);
      })
    }), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zB = LB, HB = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Di), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), UB = HB, jB = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(ms), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), WB = jB, GB = /* @__PURE__ */ b({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Ec), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xg = GB, KB = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Oc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), YB = KB, XB = /* @__PURE__ */ b({
  __name: "ContextMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ic), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), JB = XB, ZB = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(Rc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), QB = ZB, ek = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(Vc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), tk = ek, nk = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Fc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ak = nk, rk = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (o, s) => (h(), x(l(Nc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), ok = rk, sk = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), x(l(Lc), A(l(r), { style: {
      "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), lk = sk, ik = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(zc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), uk = ik;
function Kp(e) {
  return e.pointerType !== "mouse";
}
var dk = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { disabled: n } = Me(t), { forwardRef: a, currentElement: r } = j(), o = wg(), s = O({
      x: 0,
      y: 0
    }), i = q(() => ({ getBoundingClientRect: () => ({
      width: 0,
      height: 0,
      left: s.value.x,
      right: s.value.x,
      top: s.value.y,
      bottom: s.value.y,
      ...s.value
    }) })), u = O(0);
    function d() {
      window.clearTimeout(u.value);
    }
    function c(m) {
      s.value = {
        x: m.clientX,
        y: m.clientY
      }, o.onOpenChange(!0);
    }
    async function f(m) {
      n.value || (await Pe(), m.defaultPrevented || (d(), c(m), m.preventDefault()));
    }
    async function p(m) {
      n.value || (await Pe(), Kp(m) && !m.defaultPrevented && (d(), u.value = window.setTimeout(() => c(m), o.pressOpenDelay.value)));
    }
    async function v(m) {
      n.value || (await Pe(), Kp(m) && !m.defaultPrevented && d());
    }
    return Ce(() => {
      r.value && (o.triggerElement.value = r.value);
    }), (m, g) => (h(), W(Ke, null, [N(l(Pi), {
      as: "template",
      reference: i.value
    }, null, 8, ["reference"]), N(l(X), A({
      ref: l(a),
      as: m.as,
      "as-child": m.asChild,
      "data-state": l(o).open.value ? "open" : "closed",
      "data-disabled": l(n) ? "" : void 0,
      style: {
        WebkitTouchCallout: "none",
        pointerEvents: "auto"
      }
    }, m.$attrs, {
      onContextmenu: f,
      onPointerdown: p,
      onPointermove: v,
      onPointercancel: v,
      onPointerup: v
    }), {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ])], 64));
  }
}), ck = dk;
const [Xr, fk] = Se("PopoverRoot");
var pk = /* @__PURE__ */ b({
  __name: "PopoverRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r } = Me(n), o = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = O(), i = O(!1);
    return fk({
      contentId: "",
      triggerId: "",
      modal: r,
      open: o,
      onOpenChange: (u) => {
        o.value = u;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      triggerElement: s,
      hasCustomAnchor: i
    }), (u, d) => (h(), x(l(or), null, {
      default: y(() => [_(u.$slots, "default", {
        open: l(o),
        close: () => o.value = !1
      })]),
      _: 3
    }));
  }
}), vk = pk, mk = /* @__PURE__ */ b({
  __name: "PopoverAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Xr();
    return c0(() => {
      n.hasCustomAnchor.value = !0;
    }), nt(() => {
      n.hasCustomAnchor.value = !1;
    }), (a, r) => (h(), x(l(sr), oe(le(t)), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), hH = mk, hk = /* @__PURE__ */ b({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(as(n, "trapFocus", "disableOutsidePointerEvents")), { forwardRef: o } = j(), s = Xr();
    return hc(), (i, u) => (h(), x(l(hi), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [N(l(Oa), {
        "as-child": "",
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        onPointerDownOutside: u[0] || (u[0] = (d) => a("pointerDownOutside", d)),
        onInteractOutside: u[1] || (u[1] = (d) => a("interactOutside", d)),
        onEscapeKeyDown: u[2] || (u[2] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[3] || (u[3] = (d) => a("focusOutside", d)),
        onDismiss: u[4] || (u[4] = (d) => l(s).onOpenChange(!1))
      }, {
        default: y(() => [N(l(Yr), A(l(r), {
          id: l(s).contentId,
          ref: l(o),
          "data-state": l(s).open.value ? "open" : "closed",
          "aria-labelledby": l(s).triggerId,
          style: {
            "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
            "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
            "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
          },
          role: "dialog"
        }), {
          default: y(() => [_(i.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "aria-labelledby"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Cg = hk, gk = /* @__PURE__ */ b({
  __name: "PopoverContentModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xr(), o = O(!1);
    os(!0);
    const s = ve(n, a), { forwardRef: i, currentElement: u } = j();
    return ls(u), (d, c) => (h(), x(Cg, A(l(s), {
      ref: l(i),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: c[0] || (c[0] = Ye((f) => {
        a("closeAutoFocus", f), o.value || l(r).triggerElement.value?.focus();
      }, ["prevent"])),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        a("pointerDownOutside", f);
        const p = f.detail.originalEvent, v = p.button === 0 && p.ctrlKey === !0, m = p.button === 2 || v;
        o.value = m;
      }),
      onFocusOutside: c[2] || (c[2] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), yk = gk, bk = /* @__PURE__ */ b({
  __name: "PopoverContentNonModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xr(), o = O(!1), s = O(!1), i = ve(n, a);
    return (u, d) => (h(), x(Cg, A(l(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        a("closeAutoFocus", c), c.defaultPrevented || (o.value || l(r).triggerElement.value?.focus(), c.preventDefault()), o.value = !1, s.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = async (c) => {
        a("interactOutside", c), c.defaultPrevented || (o.value = !0, c.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const f = c.target;
        l(r).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && s.value && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _k = bk, wk = /* @__PURE__ */ b({
  __name: "PopoverContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xr(), o = ve(n, a), { forwardRef: s } = j();
    return r.contentId ||= Ge(void 0, "reka-popover-content"), (i, u) => (h(), x(l(Ct), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [l(r).modal.value ? (h(), x(yk, A({ key: 0 }, l(o), { ref: l(s) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(_k, A({ key: 1 }, l(o), { ref: l(s) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), xk = wk, Ck = /* @__PURE__ */ b({
  __name: "PopoverPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Sk = Ck, $k = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Xr(), { forwardRef: a, currentElement: r } = j();
    return n.triggerId ||= Ge(void 0, "reka-popover-trigger"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), x(kt(l(n).hasCustomAnchor.value ? l(X) : l(sr)), { "as-child": "" }, {
      default: y(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).contentId,
        "data-state": l(n).open.value ? "open" : "closed",
        as: o.as,
        "as-child": t.asChild,
        onClick: l(n).onOpenToggle
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "aria-expanded",
        "aria-controls",
        "data-state",
        "as",
        "as-child",
        "onClick"
      ])]),
      _: 3
    }));
  }
}), Bk = $k;
function kk(e) {
  const t = q(() => e.start.value ? !!e.isDateDisabled(e.start.value) : !1), n = q(() => e.end.value ? !!e.isDateDisabled(e.end.value) : !1), a = q(() => t.value || n.value ? !1 : !!(e.start.value && e.end.value && Ka(e.end.value, e.start.value))), r = (p) => e.start.value ? _t(e.start.value, p) : !1, o = (p) => e.end.value ? _t(e.end.value, p) : !1, s = (p) => e.start.value && _t(e.start.value, p) || e.end.value && _t(e.end.value, p) ? !0 : e.end.value && e.start.value ? xu(p, e.start.value, e.end.value) : !1, i = (p) => {
    if (e.isDateDisabled(p)) return !0;
    if (e.maximumDays?.value) {
      if (e.start.value && e.end.value) {
        if (e.fixedDate.value) {
          const v = ud(e.start.value, e.end.value).length;
          if (v <= e.maximumDays.value) {
            const m = e.maximumDays.value - v - 1, g = e.start.value.subtract({ days: m }), w = e.end.value.add({ days: m });
            return !xu(p, g, w);
          }
        }
        return !1;
      }
      if (e.start.value) {
        const v = e.start.value.add({ days: e.maximumDays.value }), m = e.start.value.subtract({ days: e.maximumDays.value });
        return !xu(p, m, v);
      }
    }
    return !e.start.value || e.end.value || _t(e.start.value, p), !1;
  }, u = (p) => !!e.isDateHighlightable?.(p), d = q(() => {
    if (e.start.value && e.end.value && !e.fixedDate.value || !e.start.value || !e.focusedValue.value) return null;
    const p = Ka(e.start.value, e.focusedValue.value), v = p ? e.start.value : e.focusedValue.value, m = p ? e.focusedValue.value : e.start.value;
    if (_t(v, m)) return {
      start: v,
      end: m
    };
    if (e.maximumDays?.value && !e.end.value) {
      const w = p ? v.add({ days: e.maximumDays.value - 1 }) : v.subtract({ days: e.maximumDays.value });
      return {
        start: v,
        end: w
      };
    }
    return s1(v, m, e.allowNonContiguousRanges.value ? () => !1 : e.isDateUnavailable, i, e.isDateHighlightable) ? {
      start: v,
      end: m
    } : null;
  });
  return {
    isInvalid: a,
    isSelected: s,
    isDateHighlightable: u,
    highlightedRange: d,
    isSelectionStart: r,
    isSelectionEnd: o,
    isHighlightedStart: (p) => !d.value || !d.value.start ? !1 : _t(d.value.start, p),
    isHighlightedEnd: (p) => !d.value || !d.value.end ? !1 : _t(d.value.end, p),
    isDateDisabled: i
  };
}
const Pk = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, Dk = {
  role: "heading",
  "aria-level": "2"
}, [Jr, Mk] = Se("RangeCalendarRoot");
var qk = /* @__PURE__ */ b({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: Object,
      required: !1,
      default: () => ({
        start: void 0,
        end: void 0
      })
    },
    modelValue: {
      type: [Object, null],
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    allowNonContiguousRanges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maximumDays: {
      type: Number,
      required: !1,
      default: void 0
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateHighlightable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    fixedDate: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: [
    "update:modelValue",
    "update:validModelValue",
    "update:placeholder",
    "update:startValue"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, numberOfMonths: f, preventDeselect: p, isDateUnavailable: v, isDateHighlightable: m, isDateDisabled: g, calendarLabel: w, maxValue: C, minValue: S, dir: $, locale: k, nextPage: B, prevPage: D, allowNonContiguousRanges: P, disableDaysOutsideCurrentView: E, fixedDate: T, maximumDays: M } = Me(n), { primitiveElement: I, currentElement: F } = zt(), J = gt($), ne = gc(k), Q = O(), G = O(), H = O(!1), U = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: n.modelValue === void 0
    }), se = O(U.value);
    me(se, (Ie) => {
      a("update:validModelValue", Ie);
    });
    const ee = Eh({
      defaultPlaceholder: n.placeholder,
      defaultValue: U.value.start,
      locale: n.locale
    }), de = O(U.value.start), fe = O(U.value.end), _e = Ve(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ee.copy(),
      passive: n.placeholder === void 0
    });
    function ye(Ie) {
      _e.value = Ie.copy();
    }
    const { fullCalendarLabel: Te, headingValue: ce, isDateDisabled: V, isDateUnavailable: te, isNextButtonDisabled: z, isPrevButtonDisabled: re, grid: ie, weekdays: L, isOutsideVisibleView: be, nextPage: xe, prevPage: Fe, formatter: Xe } = Yh({
      locale: ne,
      placeholder: _e,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: f,
      minValue: S,
      maxValue: C,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: g.value,
      isDateUnavailable: v.value,
      calendarLabel: w,
      nextPage: B,
      prevPage: D
    }), { isInvalid: lt, isSelected: ke, isDateHighlightable: Le, highlightedRange: Ue, isSelectionStart: We, isSelectionEnd: it, isHighlightedStart: ut, isHighlightedEnd: St, isDateDisabled: on } = kk({
      start: de,
      end: fe,
      isDateDisabled: V,
      isDateUnavailable: te,
      isDateHighlightable: m.value,
      focusedValue: G,
      allowNonContiguousRanges: P,
      fixedDate: T,
      maximumDays: M
    });
    me(U, (Ie, Mt) => {
      (!Mt?.start && Ie?.start || !Ie || !Ie.start || de.value && !Sa(Ie.start, de.value)) && (de.value = Ie?.start?.copy?.()), (!Mt?.end && Ie.end || !Ie || !Ie.end || fe.value && !Sa(Ie.end, fe.value)) && (fe.value = Ie?.end?.copy?.());
    }), me(de, (Ie) => {
      Ie && !Sa(Ie, _e.value) && ye(Ie), a("update:startValue", Ie);
    }), me([de, fe], ([Ie, Mt]) => {
      const Ut = U.value;
      if (!(Ut && Ut.start && Ut.end && Ie && Mt && Sa(Ut.start, Ie) && Sa(Ut.end, Mt)))
        if (H.value = !0, Mt && Ie) {
          const Ot = Ka(Mt, Ie) ? {
            start: Mt.copy(),
            end: Ie.copy()
          } : {
            start: Ie.copy(),
            end: Mt.copy()
          };
          U.value = {
            start: Ot.start,
            end: Ot.end
          }, H.value = !1, se.value = {
            start: Ot.start.copy(),
            end: Ot.end.copy()
          };
        } else U.value = Ie ? {
          start: Ie.copy(),
          end: void 0
        } : {
          start: Mt?.copy(),
          end: void 0
        };
    });
    const mn = is();
    return Lt("keydown", (Ie) => {
      Ie.key === mn.ESCAPE && H.value && (de.value = se.value.start?.copy(), fe.value = se.value.end?.copy());
    }), Mk({
      isDateUnavailable: te,
      isDateHighlightable: Le,
      startValue: de,
      endValue: fe,
      formatter: Xe,
      modelValue: U,
      placeholder: _e,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: ie,
      weekDays: L,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      numberOfMonths: f,
      readonly: o,
      preventDeselect: p,
      fullCalendarLabel: Te,
      headingValue: ce,
      isInvalid: lt,
      isDateDisabled: on,
      allowNonContiguousRanges: P,
      highlightedRange: Ue,
      focusedValue: G,
      lastPressedDateValue: Q,
      isSelected: ke,
      isSelectionEnd: it,
      isSelectionStart: We,
      isNextButtonDisabled: z,
      isPrevButtonDisabled: re,
      isOutsideVisibleView: be,
      nextPage: xe,
      prevPage: Fe,
      parentElement: F,
      onPlaceholderChange: ye,
      locale: ne,
      dir: J,
      isHighlightedStart: ut,
      isHighlightedEnd: St,
      disableDaysOutsideCurrentView: E,
      fixedDate: T,
      maximumDays: M,
      minValue: S,
      maxValue: C
    }), Ce(() => {
      s.value && Th(F.value);
    }), (Ie, Mt) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: I,
      as: Ie.as,
      "as-child": Ie.asChild,
      "aria-label": l(Te),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(lt) ? "" : void 0,
      dir: l(J)
    }, {
      default: y(() => [we("div", Pk, [we("div", Dk, Ne(l(Te)), 1)]), _(Ie.$slots, "default", {
        date: l(_e),
        grid: l(ie),
        weekDays: l(L),
        weekStartsOn: l(u),
        locale: l(ne),
        fixedWeeks: l(c),
        modelValue: l(U)
      })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), Ek = qk, Tk = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = Jr();
    return (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), Ak = Tk, Ok = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Jr(), a = is(), { primitiveElement: r } = zt(), o = q(() => n.formatter.custom($n(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), s = q(() => n.isDateUnavailable?.(t.day) ?? !1), i = q(() => n.isSelected(t.day)), u = q(() => n.isSelectionStart(t.day)), d = q(() => n.isSelectionEnd(t.day)), c = q(() => n.isHighlightedStart(t.day)), f = q(() => n.isHighlightedEnd(t.day)), p = q(() => n.highlightedRange.value ? a1(t.day, n.highlightedRange.value.start, n.highlightedRange.value.end) : !1), v = q(() => n.allowNonContiguousRanges.value), m = q(() => uh(t.day, Wr())), g = q(() => !sc(t.day, t.month)), w = q(() => n.isOutsideVisibleView(t.day)), C = q(() => n.isDateDisabled(t.day) || n.disableDaysOutsideCurrentView.value && g.value), S = q(() => t.day.day.toLocaleString(n.locale.value)), $ = q(() => !n.disabled.value && _t(t.day, n.placeholder.value));
    function k(E, T) {
      if (!n.readonly.value && !(n.isDateDisabled(T) || n.isDateUnavailable?.(T))) {
        if (n.lastPressedDateValue.value = T.copy(), n.startValue.value && n.highlightedRange.value === null) {
          if (_t(T, n.startValue.value) && !n.preventDeselect.value && !n.endValue.value) {
            n.startValue.value = void 0, n.onPlaceholderChange(T);
            return;
          } else if (!n.endValue.value) {
            E.preventDefault(), n.lastPressedDateValue.value && _t(n.lastPressedDateValue.value, T) && (n.startValue.value = T.copy());
            return;
          }
        }
        if (n.startValue.value && n.endValue.value && _t(n.startValue.value, n.endValue.value) && _t(n.startValue.value, T) && !n.preventDeselect.value) {
          n.startValue.value = void 0, n.endValue.value = void 0, n.onPlaceholderChange(T);
          return;
        }
        n.startValue.value ? n.endValue.value ? n.endValue.value && n.startValue.value && (n.fixedDate.value ? n.fixedDate.value === "start" ? T.compare(n.startValue.value) < 0 ? n.startValue.value = T.copy() : n.endValue.value = T.copy() : n.fixedDate.value === "end" && (T.compare(n.endValue.value) > 0 ? n.endValue.value = T.copy() : n.startValue.value = T.copy()) : (n.endValue.value = void 0, n.startValue.value = T.copy())) : n.endValue.value = T.copy() : n.startValue.value = T.copy();
      }
    }
    function B(E) {
      C.value || k(E, t.day);
    }
    function D() {
      C.value || n.isDateUnavailable?.(t.day) || (n.focusedValue.value = t.day.copy());
    }
    function P(E) {
      if (C.value) return;
      E.preventDefault(), E.stopPropagation();
      const T = n.parentElement.value, M = 7, I = n.dir.value === "rtl" ? -1 : 1;
      switch (E.code) {
        case a.ARROW_RIGHT:
          F(t.day, I);
          break;
        case a.ARROW_LEFT:
          F(t.day, -I);
          break;
        case a.ARROW_UP:
          F(t.day, -M);
          break;
        case a.ARROW_DOWN:
          F(t.day, M);
          break;
        case a.ENTER:
        case a.SPACE_CODE:
          k(E, t.day);
      }
      function F(J, ne) {
        const Q = J.add({ days: ne });
        if (n.minValue.value && Q.compare(n.minValue.value) < 0 || n.maxValue.value && Q.compare(n.maxValue.value) > 0) return;
        const G = T.querySelector(`[data-value='${Q.toString()}']:not([data-outside-view])`);
        if (!G) {
          if (ne > 0) {
            if (n.isNextButtonDisabled()) return;
            n.nextPage();
          } else {
            if (n.isPrevButtonDisabled()) return;
            n.prevPage();
          }
          Pe(() => {
            F(J, ne);
          });
          return;
        }
        if (G && G.hasAttribute("data-disabled")) return F(Q, ne);
        n.onPlaceholderChange(Q), G?.focus();
      }
    }
    return (E, T) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: r,
      as: E.as,
      "as-child": E.asChild,
      role: "button",
      "aria-label": o.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-pressed": i.value && (v.value || !s.value) ? !0 : void 0,
      "aria-disabled": C.value || s.value ? !0 : void 0,
      "data-highlighted": p.value && (v.value || !s.value) ? "" : void 0,
      "data-selection-start": u.value ? !0 : void 0,
      "data-selection-end": d.value ? !0 : void 0,
      "data-highlighted-start": c.value ? !0 : void 0,
      "data-highlighted-end": f.value ? !0 : void 0,
      "data-selected": i.value && (v.value || !s.value) ? !0 : void 0,
      "data-outside-visible-view": w.value ? "" : void 0,
      "data-value": E.day.toString(),
      "data-disabled": C.value ? "" : void 0,
      "data-unavailable": s.value ? "" : void 0,
      "data-today": m.value ? "" : void 0,
      "data-outside-view": g.value ? "" : void 0,
      "data-focused": $.value ? "" : void 0,
      tabindex: $.value ? 0 : g.value || C.value ? void 0 : -1,
      onClick: B,
      onFocusin: D,
      onMouseenter: D,
      onKeydown: Je(P, [
        "up",
        "down",
        "left",
        "right",
        "enter",
        "space"
      ])
    }, {
      default: y(() => [_(E.$slots, "default", {
        dayValue: S.value,
        disabled: C.value,
        today: m.value,
        selected: i.value,
        outsideView: g.value,
        outsideVisibleView: w.value,
        unavailable: s.value,
        highlighted: p.value && (v.value || !s.value),
        highlightedStart: c.value,
        highlightedEnd: f.value,
        selectionStart: u.value,
        selectionEnd: d.value
      }, () => [Re(Ne(S.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "aria-pressed",
      "aria-disabled",
      "data-highlighted",
      "data-selection-start",
      "data-selection-end",
      "data-highlighted-start",
      "data-highlighted-end",
      "data-selected",
      "data-outside-visible-view",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), Ik = Ok, Rk = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = Jr(), a = q(() => n.disabled.value ? !0 : void 0), r = q(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), x(l(X), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), Vk = Rk, Fk = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Nk = Fk, Lk = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zk = Lk, Hk = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Uk = Hk, jk = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Wk = jk, Gk = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Kk = Gk, Yk = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Jr();
    return (a, r) => (h(), x(l(X), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Ne(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), Xk = Yk, Jk = /* @__PURE__ */ b({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = q(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = Jr();
    return (r, o) => (h(), x(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), Zk = Jk, Qk = /* @__PURE__ */ b({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = q(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = Jr();
    return (r, o) => (h(), x(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Previous page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), eP = Qk, tP = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(Tc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nP = tP;
const [Sg, aP] = Se("DropdownMenuRoot");
var rP = /* @__PURE__ */ b({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = O(), { modal: s, dir: i } = Me(n), u = gt(i);
    return aP({
      open: r,
      onOpenChange: (d) => {
        r.value = d;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      triggerId: "",
      triggerElement: o,
      contentId: "",
      modal: s,
      dir: u
    }), (d, c) => (h(), x(l(Dc), {
      open: l(r),
      "onUpdate:open": c[0] || (c[0] = (f) => mt(r) ? r.value = f : null),
      dir: l(u),
      modal: l(s)
    }, {
      default: y(() => [_(d.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), oP = rP, sP = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const o = Sg(), s = O(!1);
    function i(u) {
      u.defaultPrevented || (s.value || setTimeout(() => {
        o.triggerElement.value?.focus();
      }, 0), s.value = !1, u.preventDefault());
    }
    return o.contentId ||= Ge(void 0, "reka-dropdown-menu-content"), (u, d) => (h(), x(l(Ac), A(l(r), {
      id: l(o).contentId,
      "aria-labelledby": l(o)?.triggerId,
      style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: i,
      onInteractOutside: d[0] || (d[0] = (c) => {
        if (c.defaultPrevented) return;
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, v = f.button === 2 || p;
        (!l(o).modal.value || v) && (s.value = !0), l(o).triggerElement.value?.contains(c.target) && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), lP = sP, iP = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Di), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), uP = iP, dP = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(ms), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), cP = dP, fP = /* @__PURE__ */ b({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Ec), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $g = fP, pP = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Oc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), vP = pP, mP = /* @__PURE__ */ b({
  __name: "DropdownMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ic), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), hP = mP, gP = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(Rc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), yP = gP, bP = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), x(l(Vc), oe(le(l(r))), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _P = bP, wP = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Fc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xP = wP, CP = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      passive: n.open === void 0,
      defaultValue: n.defaultOpen ?? !1
    });
    return j(), (o, s) => (h(), x(l(Nc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), SP = CP, $P = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), x(l(Lc), A(l(r), { style: {
      "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), BP = $P, kP = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(zc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), PP = kP, DP = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Sg(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.triggerElement = r;
    }), n.triggerId ||= Ge(void 0, "reka-dropdown-menu-trigger"), (o, s) => (h(), x(l(Pi), { "as-child": "" }, {
      default: y(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "as-child": t.asChild,
        as: o.as,
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).open.value ? l(n).contentId : void 0,
        "data-disabled": o.disabled ? "" : void 0,
        disabled: o.disabled,
        "data-state": l(n).open.value ? "open" : "closed",
        onClick: s[0] || (s[0] = async (i) => {
          !o.disabled && i.button === 0 && i.ctrlKey === !1 && (l(n)?.onOpenToggle(), await Pe(), l(n).open.value && i.preventDefault());
        }),
        onKeydown: s[1] || (s[1] = Je((i) => {
          o.disabled || (["Enter", " "].includes(i.key) && l(n).onOpenToggle(), i.key === "ArrowDown" && l(n).onOpenChange(!0), [
            "Enter",
            " ",
            "ArrowDown"
          ].includes(i.key) && i.preventDefault());
        }, [
          "enter",
          "space",
          "arrow-down"
        ]))
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as-child",
        "as",
        "aria-expanded",
        "aria-controls",
        "data-disabled",
        "disabled",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), MP = DP;
const [Hc, qP] = Se("HoverCardRoot");
var EP = /* @__PURE__ */ b({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    openDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    closeDelay: {
      type: Number,
      required: !1,
      default: 300
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { openDelay: r, closeDelay: o } = Me(n);
    j();
    const s = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = O(0), u = O(0), d = O(!1), c = O(!1), f = O(!1), p = O();
    function v() {
      clearTimeout(u.value), i.value = window.setTimeout(() => s.value = !0, r.value);
    }
    function m() {
      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => s.value = !1, o.value));
    }
    function g() {
      s.value = !1;
    }
    return qP({
      open: s,
      onOpenChange(w) {
        s.value = w;
      },
      onOpen: v,
      onClose: m,
      onDismiss: g,
      hasSelectionRef: d,
      isPointerDownOnContentRef: c,
      isPointerInTransitRef: f,
      triggerElement: p
    }), (w, C) => (h(), x(l(or), null, {
      default: y(() => [_(w.$slots, "default", { open: l(s) })]),
      _: 3
    }));
  }
}), TP = EP;
function yd(e) {
  return (t) => t.pointerType === "touch" ? void 0 : e();
}
function AP(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
var OP = /* @__PURE__ */ b({
  __name: "HoverCardContentImpl",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(n), { forwardRef: o, currentElement: s } = j(), i = Hc(), { isPointerInTransit: u, onPointerExit: d } = Oh(i.triggerElement, s);
    N0(i.isPointerInTransitRef, u, { direction: "rtl" }), d(() => {
      i.onClose();
    });
    const c = O(!1);
    let f;
    Ae((v) => {
      if (c.value) {
        const m = document.body;
        f = m.style.userSelect || m.style.webkitUserSelect, m.style.userSelect = "none", m.style.webkitUserSelect = "none", v(() => {
          m.style.userSelect = f, m.style.webkitUserSelect = f;
        });
      }
    });
    function p() {
      c.value = !1, i.isPointerDownOnContentRef.value = !1, Pe(() => {
        document.getSelection()?.toString() !== "" && (i.hasSelectionRef.value = !0);
      });
    }
    return Ce(() => {
      s.value && (document.addEventListener("pointerup", p), AP(s.value).forEach((m) => m.setAttribute("tabindex", "-1")));
    }), nt(() => {
      document.removeEventListener("pointerup", p), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;
    }), (v, m) => (h(), x(l(Oa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: m[1] || (m[1] = (g) => a("escapeKeyDown", g)),
      onPointerDownOutside: m[2] || (m[2] = (g) => a("pointerDownOutside", g)),
      onFocusOutside: m[3] || (m[3] = Ye((g) => a("focusOutside", g), ["prevent"])),
      onDismiss: l(i).onDismiss
    }, {
      default: y(() => [N(l(Yr), A({
        ...l(r),
        ...v.$attrs
      }, {
        ref: l(o),
        "data-state": l(i).open.value ? "open" : "closed",
        style: {
          userSelect: c.value ? "text" : void 0,
          WebkitUserSelect: c.value ? "text" : void 0,
          "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
          "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
          "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onPointerdown: m[0] || (m[0] = (g) => {
          g.currentTarget.contains(g.target) && (c.value = !0), l(i).hasSelectionRef.value = !1, l(i).isPointerDownOnContentRef.value = !0;
        })
      }), {
        default: y(() => [_(v.$slots, "default")]),
        _: 3
      }, 16, ["data-state", "style"])]),
      _: 3
    }, 8, ["onDismiss"]));
  }
}), IP = OP, RP = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), { forwardRef: o } = j(), s = Hc();
    return (i, u) => (h(), x(l(Ct), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(IP, A(l(r), {
        ref: l(o),
        onPointerenter: u[0] || (u[0] = (d) => l(yd)(l(s).onOpen)(d))
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), VP = RP, FP = /* @__PURE__ */ b({
  __name: "HoverCardPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), NP = FP, LP = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  setup(e) {
    const { forwardRef: t, currentElement: n } = j(), a = Hc();
    a.triggerElement = n;
    function r() {
      setTimeout(() => {
        !a.isPointerInTransitRef.value && !a.open.value && a.onClose();
      }, 0);
    }
    return (o, s) => (h(), x(l(sr), {
      "as-child": "",
      reference: o.reference
    }, {
      default: y(() => [N(l(X), {
        ref: l(t),
        "as-child": o.asChild,
        as: o.as,
        "data-state": l(a).open.value ? "open" : "closed",
        "data-grace-area-trigger": "",
        onPointerenter: s[0] || (s[0] = (i) => l(yd)(l(a).onOpen)(i)),
        onPointerleave: s[1] || (s[1] = (i) => l(yd)(r)(i)),
        onFocus: s[2] || (s[2] = (i) => l(a).onOpen()),
        onBlur: s[3] || (s[3] = (i) => l(a).onClose())
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "data-state"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), zP = LP, HP = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "label"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { onMousedown: a[0] || (a[0] = (r) => {
      !r.defaultPrevented && r.detail > 1 && r.preventDefault();
    }) }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), UP = HP, jP = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(Tc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), WP = jP;
const [Mi, GP] = Se("MenubarRoot");
var KP = /* @__PURE__ */ b({
  __name: "MenubarRoot",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r } = j(), { CollectionSlot: o } = st({
      key: "Menubar",
      isProvider: !0
    }), s = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), i = O(null), { dir: u, loop: d } = Me(n), c = gt(u);
    return GP({
      modelValue: s,
      dir: c,
      loop: d,
      onMenuOpen: (f) => {
        s.value = f, i.value = f;
      },
      onMenuClose: () => {
        s.value = "";
      },
      onMenuToggle: (f) => {
        s.value = s.value ? "" : f, i.value = f;
      }
    }), (f, p) => (h(), x(l(o), null, {
      default: y(() => [N(l(cs), {
        "current-tab-stop-id": i.value,
        "onUpdate:currentTabStopId": p[0] || (p[0] = (v) => i.value = v),
        orientation: "horizontal",
        loop: l(d),
        dir: l(c),
        "as-child": ""
      }, {
        default: y(() => [N(l(X), {
          ref: l(r),
          role: "menubar"
        }, {
          default: y(() => [_(f.$slots, "default", { modelValue: l(s) })]),
          _: 3
        }, 512)]),
        _: 3
      }, 8, [
        "current-tab-stop-id",
        "loop",
        "dir"
      ])]),
      _: 3
    }));
  }
}), YP = KP;
const [Uc, XP] = Se("MenubarMenu");
var JP = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: { value: {
    type: String,
    required: !1
  } },
  setup(e) {
    const n = Ge(e.value), a = Mi();
    j();
    const r = O(), o = O(!1), s = q(() => a.modelValue.value === n);
    return me(s, () => {
      s.value || (o.value = !1);
    }), XP({
      value: n,
      triggerElement: r,
      triggerId: n,
      contentId: "",
      wasKeyboardTriggerOpenRef: o
    }), (i, u) => (h(), x(l(Dc), {
      open: s.value,
      modal: !1,
      dir: l(a).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || l(a).onMenuClose();
      })
    }, {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), ZP = JP, QP = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const o = Mi(), s = Uc();
    s.contentId ||= Ge(void 0, "reka-menubar-content");
    const { getItems: i } = st({ key: "Menubar" }), u = O(!1);
    function d(c) {
      const p = c.target.hasAttribute("data-reka-menubar-subtrigger"), m = (o.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!m && p) return;
      let w = i().filter(($) => $.ref.dataset.disabled !== "").map(($) => $.ref.dataset.value);
      m && w.reverse();
      const C = w.indexOf(s.value);
      w = o.loop.value ? yc(w, C + 1) : w.slice(C + 1);
      const [S] = w;
      S && o.onMenuOpen(S);
    }
    return (c, f) => (h(), x(l(Ac), A(l(r), {
      id: l(s).contentId,
      "data-reka-menubar-content": "",
      "aria-labelledby": l(s).triggerId,
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (p) => {
        !l(o).modelValue.value && !u.value && l(s).triggerElement.value?.focus(), u.value = !1, p.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (p) => {
        const v = p.target;
        l(i)().filter((g) => g.ref.dataset.disabled !== "").some((g) => g.ref.contains(v)) && p.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (p) => {
        u.value = !0;
      }),
      onEntryFocus: f[3] || (f[3] = (p) => {
        l(s).wasKeyboardTriggerOpenRef.value || p.preventDefault();
      }),
      onKeydown: Je(d, ["arrow-right", "arrow-left"])
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), eD = QP, tD = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Di), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nD = tD, aD = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(ms), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rD = aD, oD = /* @__PURE__ */ b({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Ec), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Bg = oD, sD = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Oc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), lD = sD, iD = /* @__PURE__ */ b({
  __name: "MenubarPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ic), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), kg = iD, uD = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), x(l(Rc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), dD = uD, cD = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), x(l(Vc), oe(le(l(r))), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), fD = cD, pD = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Fc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), vD = pD, mD = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    return (o, s) => (h(), x(l(Nc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), hD = mD, gD = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const { getItems: o } = st({ key: "Menubar" }), s = Mi(), i = Uc();
    function u(d) {
      if (d.target.hasAttribute("data-reka-menubar-subtrigger")) return;
      let p = o().filter((g) => g.ref.dataset.disabled !== "").map((g) => g.ref.dataset.value);
      const v = p.indexOf(i.value);
      p = s.loop.value ? yc(p, v + 1) : p.slice(v + 1);
      const [m] = p;
      m && s.onMenuOpen(m);
    }
    return (d, c) => (h(), x(l(Lc), A(l(r), {
      "data-reka-menubar-content": "",
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onKeydown: Je(u, ["arrow-right"])
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), yD = gD, bD = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(zc), A(t, { "data-reka-menubar-subtrigger": "" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _D = bD, wD = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = Mi(), n = Uc(), { forwardRef: a, currentElement: r } = j(), { CollectionItem: o } = st({ key: "Menubar" }), s = O(!1), i = q(() => t.modelValue.value === n.value);
    return Ce(() => {
      n.triggerElement = r;
    }), (u, d) => (h(), x(l(fs), {
      "as-child": "",
      focusable: !u.disabled,
      "tab-stop-id": l(n).value
    }, {
      default: y(() => [N(l(o), null, {
        default: y(() => [N(l(Pi), { "as-child": "" }, {
          default: y(() => [N(l(X), {
            id: l(n).triggerId,
            ref: l(a),
            as: u.as,
            "as-child": u.asChild,
            type: u.as === "button" ? "button" : void 0,
            role: "menuitem",
            "aria-haspopup": "menu",
            "aria-expanded": i.value,
            "aria-controls": i.value ? l(n).contentId : void 0,
            "data-highlighted": s.value ? "" : void 0,
            "data-state": i.value ? "open" : "closed",
            "data-disabled": u.disabled ? "" : void 0,
            disabled: u.disabled,
            "data-value": l(n).value,
            onPointerdown: d[0] || (d[0] = (c) => {
              !u.disabled && c.button === 0 && c.ctrlKey === !1 && (l(t).onMenuOpen(l(n).value), i.value || c.preventDefault());
            }),
            onPointerenter: d[1] || (d[1] = () => {
              l(t).modelValue.value && !i.value && (l(t).onMenuOpen(l(n).value), l(r)?.focus());
            }),
            onKeydown: d[2] || (d[2] = Je((c) => {
              u.disabled || (["Enter", " "].includes(c.key) && l(t).onMenuToggle(l(n).value), c.key === "ArrowDown" && l(t).onMenuOpen(l(n).value), [
                "Enter",
                " ",
                "ArrowDown"
              ].includes(c.key) && (l(n).wasKeyboardTriggerOpenRef.value = !0, c.preventDefault()));
            }, [
              "enter",
              "space",
              "arrow-down"
            ])),
            onFocus: d[3] || (d[3] = (c) => s.value = !0),
            onBlur: d[4] || (d[4] = (c) => s.value = !1)
          }, {
            default: y(() => [_(u.$slots, "default")]),
            _: 3
          }, 8, [
            "id",
            "as",
            "as-child",
            "type",
            "aria-expanded",
            "aria-controls",
            "data-highlighted",
            "data-state",
            "data-disabled",
            "disabled",
            "data-value"
          ])]),
          _: 3
        })]),
        _: 3
      })]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), xD = wD;
const [ur, CD] = Se(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var SD = /* @__PURE__ */ b({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: void 0
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: 200
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableClickTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableHoverTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disablePointerLeaveClose: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "modelValue", t, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), o = O(""), { forwardRef: s, currentElement: i } = j(), u = O(), d = O(), c = O(), { getItems: f, CollectionSlot: p } = st({
      key: "NavigationMenu",
      isProvider: !0
    }), { delayDuration: v, skipDelayDuration: m, dir: g, disableClickTrigger: w, disableHoverTrigger: C, unmountOnHide: S } = Me(n), $ = gt(g), k = rs(!1, m), B = q(() => r.value !== "" || k.value ? 150 : v.value), D = rc((P) => {
      typeof P == "string" && (o.value = r.value, r.value = P);
    }, B);
    return Ae(() => {
      if (!r.value) return;
      const P = f().map((E) => E.ref);
      c.value = P.find((E) => E.id.includes(r.value));
    }), CD({
      isRootMenu: !0,
      modelValue: r,
      previousValue: o,
      baseId: Ge(void 0, "reka-navigation-menu"),
      disableClickTrigger: w,
      disableHoverTrigger: C,
      dir: $,
      unmountOnHide: S,
      orientation: n.orientation,
      rootNavigationMenu: i,
      indicatorTrack: u,
      activeTrigger: c,
      onIndicatorTrackChange: (P) => {
        u.value = P;
      },
      viewport: d,
      onViewportChange: (P) => {
        d.value = P;
      },
      onTriggerEnter: (P) => {
        D(P);
      },
      onTriggerLeave: () => {
        k.value = !0, D("");
      },
      onContentEnter: () => {
        D();
      },
      onContentLeave: () => {
        n.disablePointerLeaveClose || D("");
      },
      onItemSelect: (P) => {
        o.value = r.value, r.value = P;
      },
      onItemDismiss: () => {
        o.value = r.value, r.value = "";
      }
    }), (P, E) => (h(), x(l(p), null, {
      default: y(() => [N(l(X), {
        ref: l(s),
        "aria-label": "Main",
        as: P.as,
        "as-child": P.asChild,
        "data-orientation": P.orientation,
        dir: l($),
        "data-reka-navigation-menu": ""
      }, {
        default: y(() => [_(P.$slots, "default", { modelValue: l(r) })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-orientation",
        "dir"
      ])]),
      _: 3
    }));
  }
}), $D = SD;
function qi(e) {
  return e ? "open" : "closed";
}
function Pg(e, t) {
  return `${e}-trigger-${t}`;
}
function jc(e, t) {
  return `${e}-content-${t}`;
}
const BD = "navigationMenu.linkSelect", sl = "navigationMenu.rootContentDismiss";
function bd(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Dg(e) {
  const t = ot();
  return e.some((n) => n === t ? !0 : (n.focus(), ot() !== t));
}
function kD(e) {
  return e.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    e.forEach((t) => {
      const n = t.dataset.tabindex;
      t.setAttribute("tabindex", n);
    });
  };
}
function Mg(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
const [Wc, PD] = Se("NavigationMenuItem");
var DD = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  setup(e) {
    const t = e;
    j();
    const { getItems: n } = st({ key: "NavigationMenu" }), a = ur(), r = Ge(t.value), o = O(), s = O(), i = jc(a.baseId, r);
    let u = () => ({});
    const d = O(!1);
    async function c(m = "start") {
      const g = document.getElementById(i);
      if (g) {
        u();
        const w = bd(g);
        w.length && Dg(m === "start" ? w : w.reverse());
      }
    }
    function f() {
      const m = document.getElementById(i);
      if (m) {
        const g = bd(m);
        g.length && (u = kD(g));
      }
    }
    PD({
      value: r,
      contentId: i,
      triggerRef: o,
      focusProxyRef: s,
      wasEscapeCloseRef: d,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function p() {
      a.onItemDismiss(), o.value?.focus();
    }
    function v(m) {
      const g = ot();
      if (m.keyCode === 32 || m.key === "Enter") if (a.modelValue.value === r) {
        p(), m.preventDefault();
        return;
      } else {
        m.target.click(), m.preventDefault();
        return;
      }
      const w = n().filter((S) => S.ref.parentElement?.hasAttribute("data-menu-item")).map((S) => S.ref);
      if (!w.includes(g)) return;
      const C = rr(m, g, void 0, {
        itemsArray: w,
        loop: !1
      });
      C && C?.focus(), m.preventDefault(), m.stopPropagation();
    }
    return (m, g) => (h(), x(l(X), {
      "as-child": m.asChild,
      as: m.as,
      "data-menu-item": "",
      onKeydown: Je(v, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end",
        "space"
      ])
    }, {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), MD = DD, qD = /* @__PURE__ */ b({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = ur(), u = Wc(), d = Pg(i.baseId, u.value), c = jc(i.baseId, u.value), f = O(null), p = q(() => {
      const S = r().map((E) => E.ref.id.split("trigger-")[1]);
      i.dir.value === "rtl" && S.reverse();
      const $ = S.indexOf(i.modelValue.value), k = S.indexOf(i.previousValue.value), B = u.value === i.modelValue.value, D = k === S.indexOf(u.value);
      if (!B && !D) return f.value;
      const P = (() => {
        if ($ !== k) {
          if (B && k !== -1) return $ > k ? "from-end" : "from-start";
          if (D && $ !== -1) return $ > k ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = P, P;
    });
    function v(S) {
      if (a("focusOutside", S), a("interactOutside", S), S.detail.originalEvent.target.hasAttribute("data-navigation-menu-trigger") && S.preventDefault(), !S.defaultPrevented) {
        u.onContentFocusOutside();
        const k = S.target;
        i.rootNavigationMenu?.value?.contains(k) && S.preventDefault();
      }
    }
    function m(S) {
      if (a("pointerDownOutside", S), !S.defaultPrevented) {
        const $ = S.target, k = r().some((D) => D.ref.contains($)), B = i.isRootMenu && i.viewport.value?.contains($);
        (k || B || !i.isRootMenu) && S.preventDefault();
      }
    }
    Ae((S) => {
      const $ = s.value;
      if (i.isRootMenu && $) {
        const k = () => {
          i.onItemDismiss(), u.onRootContentClose(), $.contains(ot()) && u.triggerRef.value?.focus();
        };
        $.addEventListener(sl, k), S(() => $.removeEventListener(sl, k));
      }
    });
    function g(S) {
      a("escapeKeyDown", S), S.defaultPrevented || (i.onItemDismiss(), u.triggerRef?.value?.focus(), u.wasEscapeCloseRef.value = !0);
    }
    function w(S) {
      if (S.target.closest("[data-reka-navigation-menu]") !== i.rootNavigationMenu.value) return;
      const $ = S.altKey || S.ctrlKey || S.metaKey, k = S.key === "Tab" && !$, B = bd(S.currentTarget);
      if (k) {
        const P = ot(), E = B.findIndex((I) => I === P), M = S.shiftKey ? B.slice(0, E).reverse() : B.slice(E + 1, B.length);
        if (Dg(M)) S.preventDefault();
        else {
          u.focusProxyRef.value?.focus();
          return;
        }
      }
      rr(S, ot(), void 0, {
        itemsArray: B,
        loop: !1,
        enableIgnoredElement: !0
      })?.focus();
    }
    function C() {
      const S = new Event(sl, {
        bubbles: !0,
        cancelable: !0
      });
      s.value?.dispatchEvent(S);
    }
    return (S, $) => (h(), x(l(Oa), A({
      id: l(c),
      ref: l(o),
      "aria-labelledby": l(d),
      "data-motion": p.value,
      "data-state": l(qi)(l(i).modelValue.value === l(u).value),
      "data-orientation": l(i).orientation
    }, n, {
      onKeydown: w,
      onEscapeKeyDown: g,
      onPointerDownOutside: m,
      onFocusOutside: v,
      onDismiss: C
    }), {
      default: y(() => [_(S.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "data-motion",
      "data-state",
      "data-orientation"
    ]));
  }
}), ED = qD, TD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ve(as(n, "forceMount"), a), { forwardRef: o } = j(), s = ur(), i = Wc(), u = q(() => i.value === s.modelValue.value), d = q(() => s.viewport.value && !s.modelValue.value && s.previousValue.value ? s.previousValue.value === i.value : !1);
    return (c, f) => (h(), x(di, {
      to: l(tn) && l(s).viewport.value ? l(s).viewport.value : "body",
      disabled: l(tn) && l(s).viewport.value ? !l(s).viewport.value : !0
    }, [N(l(Ct), {
      present: c.forceMount || u.value || d.value,
      "force-mount": !l(s).unmountOnHide.value
    }, {
      default: y(({ present: p }) => [N(ED, A({
        ref: l(o),
        "data-state": l(qi)(u.value),
        style: { pointerEvents: !u.value && l(s).isRootMenu ? "none" : void 0 }
      }, {
        ...c.$attrs,
        ...l(r)
      }, {
        hidden: !p,
        onPointerenter: f[0] || (f[0] = (v) => l(s).onContentEnter(l(i).value)),
        onPointerleave: f[1] || (f[1] = (v) => l(Mg)(() => l(s).onContentLeave())(v)),
        onPointerDownOutside: f[2] || (f[2] = (v) => a("pointerDownOutside", v)),
        onFocusOutside: f[3] || (f[3] = (v) => a("focusOutside", v)),
        onInteractOutside: f[4] || (f[4] = (v) => a("interactOutside", v))
      }), {
        default: y(() => [_(c.$slots, "default")]),
        _: 2
      }, 1040, [
        "data-state",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"])], 8, ["to", "disabled"]));
  }
}), AD = TD, OD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = ur(), r = O(), o = q(() => a.orientation === "horizontal"), s = q(() => !!a.modelValue.value), { activeTrigger: i } = a;
    function u() {
      i.value && (r.value = {
        size: o.value ? i.value.offsetWidth : i.value.offsetHeight,
        position: o.value ? i.value.offsetLeft : i.value.offsetTop
      });
    }
    return Ae(() => {
      a.modelValue.value && u();
    }), qn(i, u), qn(a.indicatorTrack, u), (d, c) => l(a).indicatorTrack.value ? (h(), x(di, {
      key: 0,
      to: l(a).indicatorTrack.value
    }, [N(l(Ct), { present: d.forceMount || s.value }, {
      default: y(() => [N(l(X), A({
        ref: l(n),
        "aria-hidden": "true",
        "data-state": s.value ? "visible" : "hidden",
        "data-orientation": l(a).orientation,
        "as-child": t.asChild,
        as: d.as,
        style: { ...r.value ? {
          "--reka-navigation-menu-indicator-size": `${r.value.size}px`,
          "--reka-navigation-menu-indicator-position": `${r.value.position}px`
        } : {} }
      }, d.$attrs), {
        default: y(() => [_(d.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }, 8, ["present"])], 8, ["to"])) : qe("v-if", !0);
  }
}), ID = OD, RD = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { CollectionItem: r } = st({ key: "NavigationMenu" });
    j();
    async function o(s) {
      const i = new CustomEvent(BD, {
        bubbles: !0,
        cancelable: !0,
        detail: { originalEvent: s }
      });
      if (a("select", i), !i.defaultPrevented && !s.metaKey) {
        const u = new CustomEvent(sl, {
          bubbles: !0,
          cancelable: !0
        });
        s.target?.dispatchEvent(u);
      }
    }
    return (s, i) => (h(), x(l(r), null, {
      default: y(() => [N(l(X), {
        as: s.as,
        "data-active": s.active ? "" : void 0,
        "aria-current": s.active ? "page" : void 0,
        "as-child": n.asChild,
        onClick: o
      }, {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "data-active",
        "aria-current",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), VD = RD, FD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  setup(e) {
    const t = e, n = ur(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onIndicatorTrackChange(r.value);
    }), (o, s) => (h(), x(l(X), {
      ref: l(a),
      style: { position: "relative" }
    }, {
      default: y(() => [N(l(X), A(o.$attrs, {
        "as-child": t.asChild,
        as: o.as,
        "data-orientation": l(n).orientation
      }), {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-orientation"
      ])]),
      _: 3
    }, 512));
  }
}), ND = FD;
const LD = ["aria-owns"];
var zD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = ur(), a = Wc(), { CollectionItem: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = O(""), u = O(""), d = rs(!1, 300), c = O(!1), f = q(() => a.value === n.modelValue.value);
    Ce(() => {
      a.triggerRef = s, i.value = Pg(n.baseId, a.value), u.value = jc(n.baseId, a.value);
    });
    function p() {
      n.disableHoverTrigger.value || (c.value = !1, a.wasEscapeCloseRef.value = !1);
    }
    function v($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled || c.value || a.wasEscapeCloseRef.value || d.value) return;
        n.onTriggerEnter(a.value), d.value = !0;
      }
    }
    function m($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled) return;
        n.onTriggerLeave(), d.value = !1;
      }
    }
    function g($) {
      (!("pointerType" in $) || $.pointerType === "mouse") && n.disableClickTrigger.value || d.value || (f.value ? n.onItemSelect("") : n.onItemSelect(a.value), c.value = f.value);
    }
    function w($) {
      const B = {
        horizontal: "ArrowDown",
        vertical: n.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight"
      }[n.orientation];
      f.value && $.key === B && (a.onEntryKeyDown(), $.preventDefault(), $.stopPropagation());
    }
    function C($) {
      a.focusProxyRef.value = Wt($);
    }
    function S($) {
      const k = document.getElementById(a.contentId), B = $.relatedTarget, D = B === s.value, P = k?.contains(B);
      (D || !P) && a.onFocusProxyEnter(D ? "start" : "end");
    }
    return ($, k) => (h(), W(Ke, null, [N(l(r), null, {
      default: y(() => [N(l(X), A({
        id: i.value,
        ref: l(o),
        disabled: $.disabled,
        "data-disabled": $.disabled ? "" : void 0,
        "data-state": l(qi)(f.value),
        "data-navigation-menu-trigger": "",
        "aria-expanded": f.value,
        "aria-controls": u.value,
        "as-child": t.asChild,
        as: $.as
      }, $.$attrs, {
        onPointerenter: p,
        onPointermove: v,
        onPointerleave: m,
        onClick: g,
        onKeydown: w
      }), {
        default: y(() => [_($.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "disabled",
        "data-disabled",
        "data-state",
        "aria-expanded",
        "aria-controls",
        "as-child",
        "as"
      ])]),
      _: 3
    }), f.value ? (h(), W(Ke, { key: 0 }, [N(l(wi), {
      ref: C,
      "aria-hidden": "true",
      tabindex: 0,
      onFocus: S
    }), l(n).viewport ? (h(), W("span", {
      key: 0,
      "aria-owns": u.value
    }, null, 8, LD)) : qe("v-if", !0)], 64)) : qe("v-if", !0)], 64));
  }
}), HD = zD, UD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    align: {
      type: String,
      required: !1,
      default: "center"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = ur(), { activeTrigger: o, rootNavigationMenu: s, modelValue: i } = r, u = O(), d = O(), c = q(() => !!r.modelValue.value);
    me(a, () => {
      r.onViewportChange(a.value);
    });
    const f = O();
    me([i, c], () => {
      Pe(() => {
        a.value && requestAnimationFrame(() => {
          const v = a.value?.querySelector("[data-state=open]");
          f.value = v;
        });
      });
    }, { immediate: !0 });
    function p() {
      if (f.value && o.value && s.value) {
        const v = document.documentElement.offsetWidth, m = document.documentElement.offsetHeight, g = s.value.getBoundingClientRect(), w = o.value.getBoundingClientRect(), { offsetWidth: C, offsetHeight: S } = f.value, $ = w.left - g.left, k = w.top - g.top;
        let B = null, D = null;
        switch (t.align) {
          case "start":
            B = $, D = k;
            break;
          case "end":
            B = $ - C + w.width, D = k - S + w.height;
            break;
          default:
            B = $ - C / 2 + w.width / 2, D = k - S / 2 + w.height / 2;
        }
        const P = 10;
        B + g.left < P && (B = P - g.left);
        const E = B + g.left + C;
        E > v - P && (B -= E - v + P, B < P - g.left && (B = P - g.left)), D + g.top < P && (D = P - g.top);
        const T = D + g.top + S;
        T > m - P && (D -= T - m + P, D < P - g.top && (D = P - g.top)), B = Math.round(B), D = Math.round(D), d.value = {
          left: B,
          top: D
        };
      }
    }
    return qn(f, () => {
      f.value && (u.value = {
        width: f.value.offsetWidth,
        height: f.value.offsetHeight
      }, p());
    }), qn([globalThis.document?.body, s], () => {
      p();
    }), (v, m) => (h(), x(l(Ct), {
      present: v.forceMount || c.value,
      "force-mount": !l(r).unmountOnHide.value,
      onAfterLeave: m[2] || (m[2] = () => {
        u.value = void 0, d.value = void 0;
      })
    }, {
      default: y(({ present: g }) => [N(l(X), A(v.$attrs, {
        ref: l(n),
        as: v.as,
        "as-child": v.asChild,
        "data-state": l(qi)(c.value),
        "data-orientation": l(r).orientation,
        style: {
          pointerEvents: !c.value && l(r).isRootMenu ? "none" : void 0,
          "--reka-navigation-menu-viewport-width": u.value ? `${u.value?.width}px` : void 0,
          "--reka-navigation-menu-viewport-height": u.value ? `${u.value?.height}px` : void 0,
          "--reka-navigation-menu-viewport-left": d.value ? `${d.value?.left}px` : void 0,
          "--reka-navigation-menu-viewport-top": d.value ? `${d.value?.top}px` : void 0
        },
        hidden: !g,
        onPointerenter: m[0] || (m[0] = (w) => l(r).onContentEnter(l(r).modelValue.value)),
        onPointerleave: m[1] || (m[1] = (w) => l(Mg)(() => l(r).onContentLeave())(w))
      }), {
        default: y(() => [_(v.$slots, "default")]),
        _: 2
      }, 1040, [
        "as",
        "as-child",
        "data-state",
        "data-orientation",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"]));
  }
}), jD = UD;
let Du = /* @__PURE__ */ new Map(), _d = !1;
try {
  _d = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let ql = !1;
try {
  ql = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const qg = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
class Eg {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let n = "";
    if (!_d && this.options.signDisplay != null ? n = GD(this.numberFormatter, this.options.signDisplay, t) : n = this.numberFormatter.format(t), this.options.style === "unit" && !ql) {
      var a;
      let { unit: r, unitDisplay: o = "short", locale: s } = this.resolvedOptions();
      if (!r) return n;
      let i = (a = qg[r]) === null || a === void 0 ? void 0 : a[o];
      n += i[s] || i.default;
    }
    return n;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, n) {
    if (typeof this.numberFormatter.formatRange == "function") return this.numberFormatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)}  ${this.format(n)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.numberFormatter.formatRangeToParts == "function") return this.numberFormatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.numberFormatter.formatToParts(t), r = this.numberFormatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !_d && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !ql && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, n = {}) {
    this.numberFormatter = WD(t, n), this.options = n;
  }
}
function WD(e, t = {}) {
  let { numberingSystem: n } = t;
  if (n && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${n}`), t.style === "unit" && !ql) {
    var a;
    let { unit: s, unitDisplay: i = "short" } = t;
    if (!s) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((a = qg[s]) === null || a === void 0) && a[i])) throw new Error(`Unsupported unit ${s} with unitDisplay = ${i}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let r = e + (t ? Object.entries(t).sort((s, i) => s[0] < i[0] ? -1 : 1).join() : "");
  if (Du.has(r)) return Du.get(r);
  let o = new Intl.NumberFormat(e, t);
  return Du.set(r, o), o;
}
function GD(e, t, n) {
  if (t === "auto") return e.format(n);
  if (t === "never") return e.format(Math.abs(n));
  {
    let a = !1;
    if (t === "always" ? a = n > 0 || Object.is(n, 0) : t === "exceptZero" && (Object.is(n, -0) || Object.is(n, 0) ? n = Math.abs(n) : a = n > 0), a) {
      let r = e.format(-n), o = e.format(n), s = r.replace(o, "").replace(/\u200e|\u061C/, "");
      return [
        ...s
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), r.replace(o, "!!!").replace(s, "+").replace("!!!", o);
    } else return e.format(n);
  }
}
const KD = new RegExp("^.*\\(.*\\).*$"), YD = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
class Tg {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return Mu(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, n, a) {
    return Mu(this.locale, this.options, t).isValidPartialNumber(t, n, a);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return Mu(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, n = {}) {
    this.locale = t, this.options = n;
  }
}
const Yp = /* @__PURE__ */ new Map();
function Mu(e, t, n) {
  let a = Xp(e, t);
  if (!e.includes("-nu-") && !a.isValidPartialNumber(n)) {
    for (let r of YD) if (r !== a.options.numberingSystem) {
      let o = Xp(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + r, t);
      if (o.isValidPartialNumber(n)) return o;
    }
  }
  return a;
}
function Xp(e, t) {
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : ""), a = Yp.get(n);
  return a || (a = new XD(e, t), Yp.set(n, a)), a;
}
class XD {
  parse(t) {
    let n = this.sanitize(t);
    if (this.symbols.group && (n = br(n, this.symbols.group, "")), this.symbols.decimal && (n = n.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (n = n.replace(this.symbols.minusSign, "-")), n = n.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let s = n.indexOf("-");
      n = n.replace("-", ""), n = n.replace("+", "");
      let i = n.indexOf(".");
      i === -1 && (i = n.length), n = n.replace(".", ""), i - 2 === 0 ? n = `0.${n}` : i - 2 === -1 ? n = `0.0${n}` : i - 2 === -2 ? n = "0.00" : n = `${n.slice(0, i - 2)}.${n.slice(i - 2)}`, s > -1 && (n = `-${n}`);
    }
    let a = n ? +n : NaN;
    if (isNaN(a)) return NaN;
    if (this.options.style === "percent") {
      var r, o;
      let s = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((r = this.options.minimumFractionDigits) !== null && r !== void 0 ? r : 0) + 2, 20),
        maximumFractionDigits: Math.min(((o = this.options.maximumFractionDigits) !== null && o !== void 0 ? o : 0) + 2, 20)
      };
      return new Tg(this.locale, s).parse(new Eg(this.locale, s).format(a));
    }
    return this.options.currencySign === "accounting" && KD.test(t) && (a = -1 * a), a;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("", this.symbols.decimal)), this.symbols.group && (t = br(t, ".", this.symbols.group))), this.symbols.group === "" && t.includes("'") && (t = br(t, "'", this.symbols.group)), this.options.locale === "fr-FR" && this.symbols.group && (t = br(t, " ", this.symbols.group), t = br(t, /\u00A0/g, this.symbols.group)), t;
  }
  isValidPartialNumber(t, n = -1 / 0, a = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && n < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && a > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = br(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, n = {}) {
    this.locale = t, n.roundingIncrement !== 1 && n.roundingIncrement != null && (n.maximumFractionDigits == null && n.minimumFractionDigits == null ? (n.maximumFractionDigits = 0, n.minimumFractionDigits = 0) : n.maximumFractionDigits == null ? n.maximumFractionDigits = n.minimumFractionDigits : n.minimumFractionDigits == null && (n.minimumFractionDigits = n.maximumFractionDigits)), this.formatter = new Intl.NumberFormat(t, n), this.options = this.formatter.resolvedOptions(), this.symbols = ZD(t, this.formatter, this.options, n);
    var a, r;
    this.options.style === "percent" && (((a = this.options.minimumFractionDigits) !== null && a !== void 0 ? a : 0) > 18 || ((r = this.options.maximumFractionDigits) !== null && r !== void 0 ? r : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const Jp = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), JD = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function ZD(e, t, n, a) {
  var r, o, s, i;
  let u = new Intl.NumberFormat(e, {
    ...n,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  }), d = u.formatToParts(-10000.111), c = u.formatToParts(10000.111), f = JD.map((M) => u.formatToParts(M));
  var p;
  let v = (p = (r = d.find((M) => M.type === "minusSign")) === null || r === void 0 ? void 0 : r.value) !== null && p !== void 0 ? p : "-", m = (o = c.find((M) => M.type === "plusSign")) === null || o === void 0 ? void 0 : o.value;
  !m && (a?.signDisplay === "exceptZero" || a?.signDisplay === "always") && (m = "+");
  let w = (s = new Intl.NumberFormat(e, {
    ...n,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((M) => M.type === "decimal")) === null || s === void 0 ? void 0 : s.value, C = (i = d.find((M) => M.type === "group")) === null || i === void 0 ? void 0 : i.value, S = d.filter((M) => !Jp.has(M.type)).map((M) => Zp(M.value)), $ = f.flatMap((M) => M.filter((I) => !Jp.has(I.type)).map((I) => Zp(I.value))), k = [
    .../* @__PURE__ */ new Set([
      ...S,
      ...$
    ])
  ].sort((M, I) => I.length - M.length), B = k.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${k.join("|")}|[\\p{White_Space}]`, "gu"), D = [
    ...new Intl.NumberFormat(n.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), P = new Map(D.map((M, I) => [
    M,
    I
  ])), E = new RegExp(`[${D.join("")}]`, "g");
  return {
    minusSign: v,
    plusSign: m,
    decimal: w,
    group: C,
    literals: B,
    numeral: E,
    index: (M) => String(P.get(M))
  };
}
function br(e, t, n) {
  return e.replaceAll ? e.replaceAll(t, n) : e.split(t).join(n);
}
function Zp(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Ag(e) {
  const { disabled: t } = e, n = O(), a = $r(), r = () => window.clearTimeout(n.value), o = (p) => {
    r(), !t.value && (a.trigger(), n.value = window.setTimeout(() => {
      o(60);
    }, p));
  }, s = () => {
    o(400);
  }, i = () => {
    r();
  }, u = O(!1), d = q(() => Wt(e.target)), c = (p) => {
    p.button !== 0 || u.value || (p.preventDefault(), u.value = !0, s());
  }, f = () => {
    u.value = !1, i();
  };
  return tn && (Lt(d || window, "pointerdown", c), Lt(window, "pointerup", f), Lt(window, "pointercancel", f)), {
    isPressed: u,
    onTrigger: a.on
  };
}
function Qp(e, t = O({})) {
  return ac(() => new Eg(e.value, t.value));
}
function QD(e, t = O({})) {
  return ac(() => new Tg(e.value, t.value));
}
function ev(e, t, n) {
  let a = e === "+" ? t + n : t - n;
  if (t % 1 !== 0 || n % 1 !== 0) {
    const r = t.toString().split("."), o = n.toString().split("."), s = r[1] && r[1].length || 0, i = o[1] && o[1].length || 0, u = 10 ** Math.max(s, i);
    t = Math.round(t * u), n = Math.round(n * u), a = e === "+" ? t + n : t - n, a /= u;
  }
  return a;
}
const [Gc, eM] = Se("NumberFieldRoot");
var tM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NumberFieldRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: void 0
    },
    modelValue: {
      type: [Number, null],
      required: !1
    },
    min: {
      type: Number,
      required: !1
    },
    max: {
      type: Number,
      required: !1
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    stepSnapping: {
      type: Boolean,
      required: !1,
      default: !0
    },
    formatOptions: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    readonly: {
      type: Boolean,
      required: !1
    },
    disableWheelChange: {
      type: Boolean,
      required: !1
    },
    invertWheelChange: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, disableWheelChange: s, invertWheelChange: i, min: u, max: d, step: c, stepSnapping: f, formatOptions: p, id: v, locale: m } = Me(n), g = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { primitiveElement: w, currentElement: C } = zt(), S = gc(m), $ = On(C), k = O(), B = q(() => !Pn(g.value) && (U(g.value) === u.value || u.value && !isNaN(g.value) ? ev("-", g.value, c.value) < u.value : !1)), D = q(() => !Pn(g.value) && (U(g.value) === d.value || d.value && !isNaN(g.value) ? ev("+", g.value, c.value) > d.value : !1));
    function P(ee, de = 1) {
      if (k.value?.focus(), n.disabled || n.readonly) return;
      const fe = F.parse(k.value?.value ?? "");
      isNaN(fe) ? g.value = u.value ?? 0 : ee === "increase" ? g.value = U(fe + (c.value ?? 1) * de) : g.value = U(fe - (c.value ?? 1) * de);
    }
    function E(ee = 1) {
      P("increase", ee);
    }
    function T(ee = 1) {
      P("decrease", ee);
    }
    function M(ee) {
      ee === "min" && u.value !== void 0 ? g.value = U(u.value) : ee === "max" && d.value !== void 0 && (g.value = U(d.value));
    }
    const I = Qp(S, p), F = QD(S, p), J = q(() => I.resolvedOptions().maximumFractionDigits > 0 ? "decimal" : "numeric"), ne = Qp(S, p), Q = q(() => Pn(g.value) || isNaN(g.value) ? "" : ne.format(g.value));
    function G(ee) {
      return F.isValidPartialNumber(ee, u.value, d.value);
    }
    function H(ee) {
      k.value && (k.value.value = ee);
    }
    function U(ee) {
      let de;
      return c.value === void 0 || isNaN(c.value) || !f.value ? de = Ar(ee, u.value, d.value) : de = $0(ee, u.value, d.value, c.value), de = F.parse(I.format(de)), de;
    }
    function se(ee) {
      const de = F.parse(ee);
      return g.value = isNaN(de) ? void 0 : U(de), ee.length ? (isNaN(de), H(Q.value)) : H(ee);
    }
    return eM({
      modelValue: g,
      handleDecrease: T,
      handleIncrease: E,
      handleMinMaxValue: M,
      inputMode: J,
      inputEl: k,
      onInputElement: (ee) => k.value = ee,
      textValue: Q,
      validate: G,
      applyInputValue: se,
      disabled: r,
      readonly: o,
      disableWheelChange: s,
      invertWheelChange: i,
      max: d,
      min: u,
      isDecreaseDisabled: B,
      isIncreaseDisabled: D,
      id: v
    }), (ee, de) => (h(), x(l(X), A(ee.$attrs, {
      ref_key: "primitiveElement",
      ref: w,
      role: "group",
      as: ee.as,
      "as-child": ee.asChild,
      "data-disabled": l(r) ? "" : void 0,
      "data-readonly": l(o) ? "" : void 0
    }), {
      default: y(() => [_(ee.$slots, "default", {
        modelValue: l(g),
        textValue: Q.value
      }), l($) && ee.name ? (h(), x(l(In), {
        key: 0,
        type: "text",
        value: l(g),
        name: ee.name,
        disabled: l(r),
        readonly: l(o),
        required: ee.required
      }, null, 8, [
        "value",
        "name",
        "disabled",
        "readonly",
        "required"
      ])) : qe("v-if", !0)]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-disabled",
      "data-readonly"
    ]));
  }
}), nM = tM, aM = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Gc(), a = q(() => n.disabled?.value || n.readonly.value || t.disabled || n.isDecreaseDisabled.value), { primitiveElement: r, currentElement: o } = zt(), { isPressed: s, onTrigger: i } = Ag({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleDecrease();
    }), (u, d) => (h(), x(l(X), A(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Decrease",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), rM = aM, oM = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Gc(), a = q(() => n.disabled?.value || n.readonly.value || t.disabled || n.isIncreaseDisabled.value), { primitiveElement: r, currentElement: o } = zt(), { isPressed: s, onTrigger: i } = Ag({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleIncrease();
    }), (u, d) => (h(), x(l(X), A(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Increase",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), sM = oM, lM = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = zt(), r = Gc();
    function o(u) {
      r.disableWheelChange.value || u.target === ot() && (Math.abs(u.deltaY) <= Math.abs(u.deltaX) || (u.preventDefault(), u.deltaY > 0 ? r.invertWheelChange.value ? r.handleDecrease() : r.handleIncrease() : u.deltaY < 0 && (r.invertWheelChange.value ? r.handleIncrease() : r.handleDecrease())));
    }
    Ce(() => {
      r.onInputElement(a.value);
    });
    const s = O(r.textValue.value);
    me(() => r.textValue.value, () => {
      s.value = r.textValue.value;
    }, {
      immediate: !0,
      deep: !0
    });
    function i() {
      requestAnimationFrame(() => {
        s.value = r.textValue.value;
      });
    }
    return (u, d) => (h(), x(l(X), A(t, {
      id: l(r).id.value,
      ref_key: "primitiveElement",
      ref: n,
      value: s.value,
      role: "spinbutton",
      type: "text",
      tabindex: "0",
      inputmode: l(r).inputMode.value,
      disabled: l(r).disabled.value ? "" : void 0,
      "data-disabled": l(r).disabled.value ? "" : void 0,
      readonly: l(r).readonly.value ? "" : void 0,
      "data-readonly": l(r).readonly.value ? "" : void 0,
      autocomplete: "off",
      autocorrect: "off",
      spellcheck: "false",
      "aria-roledescription": "Number field",
      "aria-valuenow": l(r).modelValue.value,
      "aria-valuemin": l(r).min.value,
      "aria-valuemax": l(r).max.value,
      onKeydown: [
        d[0] || (d[0] = Je(Ye((c) => l(r).handleIncrease(), ["prevent"]), ["up"])),
        d[1] || (d[1] = Je(Ye((c) => l(r).handleDecrease(), ["prevent"]), ["down"])),
        d[2] || (d[2] = Je(Ye((c) => l(r).handleIncrease(10), ["prevent"]), ["page-up"])),
        d[3] || (d[3] = Je(Ye((c) => l(r).handleDecrease(10), ["prevent"]), ["page-down"])),
        d[4] || (d[4] = Je(Ye((c) => l(r).handleMinMaxValue("min"), ["prevent"]), ["home"])),
        d[5] || (d[5] = Je(Ye((c) => l(r).handleMinMaxValue("max"), ["prevent"]), ["end"])),
        d[8] || (d[8] = Je((c) => l(r).applyInputValue(c.target?.value), ["enter"]))
      ],
      onWheel: o,
      onBeforeinput: d[6] || (d[6] = (c) => {
        const f = c.target;
        let p = f.value.slice(0, f.selectionStart ?? void 0) + (c.data ?? "") + f.value.slice(f.selectionEnd ?? void 0);
        l(r).validate(p) || c.preventDefault();
      }),
      onInput: d[7] || (d[7] = (c) => {
        const f = c.target;
        s.value = f.value;
      }),
      onChange: i,
      onBlur: d[9] || (d[9] = (c) => l(r).applyInputValue(c.target?.value))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "value",
      "inputmode",
      "disabled",
      "data-disabled",
      "readonly",
      "data-readonly",
      "aria-valuenow",
      "aria-valuemin",
      "aria-valuemax"
    ]));
  }
}), iM = lM, uM = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { "data-type": "ellipsis" }), {
      default: y(() => [_(n.$slots, "default", {}, () => [a[0] || (a[0] = Re(""))])]),
      _: 3
    }, 16));
  }
}), dM = uM;
const [Zr, cM] = Se("PaginationRoot");
var fM = /* @__PURE__ */ b({
  __name: "PaginationRoot",
  props: {
    page: {
      type: Number,
      required: !1
    },
    defaultPage: {
      type: Number,
      required: !1,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      required: !0
    },
    total: {
      type: Number,
      required: !1,
      default: 0
    },
    siblingCount: {
      type: Number,
      required: !1,
      default: 2
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    showEdges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, { siblingCount: r, disabled: o, showEdges: s } = Me(n);
    j();
    const i = Ve(n, "page", a, {
      defaultValue: n.defaultPage,
      passive: n.page === void 0
    }), u = q(() => Math.max(1, Math.ceil(n.total / (n.itemsPerPage || 1))));
    return cM({
      page: i,
      onPageChange(d) {
        i.value = d;
      },
      pageCount: u,
      siblingCount: r,
      disabled: o,
      showEdges: s
    }), (d, c) => (h(), x(l(X), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: y(() => [_(d.$slots, "default", {
        page: l(i),
        pageCount: u.value
      })]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), pM = fM, vM = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Zr();
    j();
    const a = q(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "First Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("First page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), mM = vM, hM = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Zr();
    j();
    const a = q(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Last Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).pageCount.value))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Last page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), gM = hM;
function ga(e, t) {
  const n = t - e + 1;
  return Array.from({ length: n }, (a, r) => r + e);
}
function yM(e) {
  return e.map((t) => typeof t == "number" ? {
    type: "page",
    value: t
  } : { type: "ellipsis" });
}
const Is = "ellipsis";
function bM(e, t, n, a) {
  const o = t, s = Math.max(e - n, 1), i = Math.min(e + n, o);
  if (a) {
    const d = Math.min(2 * n + 5, t) - 2, c = s > 3 && Math.abs(o - d - 1 + 1) > 2 && Math.abs(s - 1) > 2, f = i < o - 2 && Math.abs(o - d) > 2 && Math.abs(o - i) > 2;
    if (!c && f)
      return [
        ...ga(1, d),
        Is,
        o
      ];
    if (c && !f) {
      const v = ga(o - d + 1, o);
      return [
        1,
        Is,
        ...v
      ];
    }
    if (c && f) {
      const v = ga(s, i);
      return [
        1,
        Is,
        ...v,
        Is,
        o
      ];
    }
    return ga(1, o);
  } else {
    const u = n * 2 + 1;
    return t < u ? ga(1, o) : e <= n + 1 ? ga(1, u) : t - e <= n ? ga(t - u + 1, o) : ga(s, i);
  }
}
var _M = /* @__PURE__ */ b({
  __name: "PaginationList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zr(), a = q(() => yM(bM(n.page.value, n.pageCount.value, n.siblingCount.value, n.showEdges.value)));
    return (r, o) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(r.$slots, "default", { items: a.value })]),
      _: 3
    }, 16));
  }
}), wM = _M, xM = /* @__PURE__ */ b({
  __name: "PaginationListItem",
  props: {
    value: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zr(), a = q(() => n.page.value === t.value), r = q(() => n.disabled.value);
    return (o, s) => (h(), x(l(X), A(t, {
      "data-type": "page",
      "aria-label": `Page ${o.value}`,
      "aria-current": a.value ? "page" : void 0,
      "data-selected": a.value ? "true" : void 0,
      disabled: r.value,
      type: o.as === "button" ? "button" : void 0,
      onClick: s[0] || (s[0] = (i) => !r.value && l(n).onPageChange(o.value))
    }), {
      default: y(() => [_(o.$slots, "default", {}, () => [Re(Ne(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-current",
      "data-selected",
      "disabled",
      "type"
    ]));
  }
}), CM = xM, SM = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zr(), a = q(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Next Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value + 1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Next page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), $M = SM, BM = /* @__PURE__ */ b({
  __name: "PaginationPrev",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zr(), a = q(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Previous Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value - 1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Prev page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), kM = BM;
const [PM, DM] = Se("PinInputRoot");
var MM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PinInputRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    mask: {
      type: Boolean,
      required: !1
    },
    otp: {
      type: Boolean,
      required: !1
    },
    type: {
      type: null,
      required: !1,
      default: "text"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, { mask: r, otp: o, placeholder: s, type: i, disabled: u, dir: d } = Me(n), { forwardRef: c } = j(), f = gt(d), p = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? [],
      passive: !0,
      deep: !0
    }), v = q(() => Array.isArray(p.value) ? [...p.value] : []), m = O(/* @__PURE__ */ new Set());
    function g(S) {
      m.value.add(S);
    }
    const w = q(() => n.type === "number"), C = q(() => v.value.filter(($) => !!$ || w.value && $ === 0).length === m.value.size);
    return me(p, () => {
      C.value && a("complete", p.value);
    }, { deep: !0 }), DM({
      modelValue: p,
      currentModelValue: v,
      mask: r,
      otp: o,
      placeholder: s,
      type: i,
      dir: f,
      disabled: u,
      isCompleted: C,
      inputElements: m,
      onInputElementChange: g,
      isNumericMode: w
    }), (S, $) => (h(), x(l(X), A(S.$attrs, {
      ref: l(c),
      dir: l(f),
      "data-complete": C.value ? "" : void 0,
      "data-disabled": l(u) ? "" : void 0
    }), {
      default: y(() => [_(S.$slots, "default", { modelValue: l(p) }), N(In, {
        id: S.id,
        as: "input",
        feature: "focusable",
        tabindex: "-1",
        value: v.value.join(""),
        name: S.name ?? "",
        disabled: l(u),
        required: S.required,
        onFocus: $[0] || ($[0] = (k) => Array.from(m.value)?.[0]?.focus())
      }, null, 8, [
        "id",
        "value",
        "name",
        "disabled",
        "required"
      ])]),
      _: 3
    }, 16, [
      "dir",
      "data-complete",
      "data-disabled"
    ]));
  }
}), qM = MM, EM = /* @__PURE__ */ b({
  __name: "PinInputInput",
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = PM(), a = q(() => Array.from(n.inputElements.value)), r = q(() => n.currentModelValue.value[t.index]), o = q(() => t.disabled || n.disabled.value), s = q(() => n.otp.value), i = q(() => n.mask.value), { primitiveElement: u, currentElement: d } = zt();
    function c(B) {
      const D = B.target;
      if ((B.data?.length ?? 0) > 1) {
        S(D.value);
        return;
      }
      if (n.isNumericMode.value && !/^\d*$/.test(D.value)) {
        D.value = D.value.replace(/\D/g, "");
        return;
      }
      D.value = B.data || D.value.slice(-1), k(t.index, D.value);
      const P = a.value[t.index + 1];
      P && P.focus();
    }
    function f() {
      const B = d.value;
      Pe(() => {
        B && !B.value && (B.placeholder = n.placeholder.value);
      });
    }
    function p(B) {
      rr(B, ot(), void 0, {
        itemsArray: a.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: "horizontal",
        dir: n.dir.value
      });
    }
    function v(B) {
      if (B.preventDefault(), B.target.value) k(t.index, "");
      else {
        const E = a.value[t.index - 1];
        E && (E.focus(), k(t.index - 1, ""));
      }
    }
    function m(B) {
      B.key === "Delete" && (B.preventDefault(), k(t.index, ""));
    }
    function g(B) {
      const D = B.target;
      D.setSelectionRange(1, 1), D.value || (D.placeholder = ""), setTimeout(() => {
        D.value || (D.placeholder = "");
      });
    }
    function w(B) {
      f();
    }
    function C(B) {
      B.preventDefault();
      const D = B.clipboardData;
      if (!D) return;
      const P = D.getData("text");
      S(P);
    }
    function S(B) {
      const D = [...n.currentModelValue.value], P = B.length >= a.value.length ? 0 : t.index, E = Math.min(P + B.length, a.value.length);
      for (let T = P; T < E; T++) {
        const M = a.value[T], I = B[T - P];
        n.isNumericMode.value && !/^\d*$/.test(I) || (D[T] = I, M.focus());
      }
      n.modelValue.value = D, a.value[E]?.focus();
    }
    function $(B) {
      let D = B.length - 1;
      for (; D >= 0 && B[D] === ""; )
        B.pop(), D--;
      return B;
    }
    function k(B, D) {
      const P = [...n.currentModelValue.value];
      if (n.isNumericMode.value) {
        const E = +D;
        D === "" || isNaN(E) ? delete P[B] : P[B] = E;
      } else P[B] = D;
      n.modelValue.value = $(P);
    }
    return me(r, () => {
      r.value || f();
    }), Ce(() => {
      n.onInputElementChange(d.value);
    }), nt(() => {
      n.inputElements?.value.delete(d.value);
    }), (B, D) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: u,
      autocapitalize: "none",
      as: B.as,
      "as-child": B.asChild,
      autocomplete: s.value ? "one-time-code" : "false",
      type: i.value ? "password" : "text",
      inputmode: l(n).isNumericMode.value ? "numeric" : "text",
      pattern: l(n).isNumericMode.value ? "[0-9]*" : void 0,
      placeholder: l(n).placeholder.value,
      value: r.value,
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "data-complete": l(n).isCompleted.value ? "" : void 0,
      "aria-label": `pin input ${B.index + 1} of ${a.value.length}`,
      onInput: D[0] || (D[0] = (P) => c(P)),
      onKeydown: [
        Je(p, [
          "left",
          "right",
          "up",
          "down",
          "home",
          "end"
        ]),
        Je(v, ["backspace"]),
        Je(m, ["delete"])
      ],
      onFocus: g,
      onBlur: w,
      onPaste: C
    }, {
      default: y(() => [_(B.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "autocomplete",
      "type",
      "inputmode",
      "pattern",
      "placeholder",
      "value",
      "disabled",
      "data-disabled",
      "data-complete",
      "aria-label"
    ]));
  }
}), TM = EM;
const Ro = 100, [AM, OM] = Se("ProgressRoot"), El = (e) => typeof e == "number";
function IM(e, t) {
  return Pn(e) || El(e) && !Number.isNaN(e) && e <= t && e >= 0 ? e : (console.error(`Invalid prop \`value\` of value \`${e}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Ro} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function RM(e) {
  return El(e) && !Number.isNaN(e) && e > 0 ? e : (console.error(`Invalid prop \`max\` of value \`${e}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Ro}\`.`), Ro);
}
var VM = /* @__PURE__ */ b({
  __name: "ProgressRoot",
  props: {
    modelValue: {
      type: [Number, null],
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: Ro
    },
    getValueLabel: {
      type: Function,
      required: !1,
      default: (e, t) => El(e) ? `${Math.round(e / t * Ro)}%` : void 0
    },
    getValueText: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:max"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "modelValue", a, { passive: n.modelValue === void 0 }), o = Ve(n, "max", a, { passive: n.max === void 0 });
    me(() => r.value, async (i) => {
      const u = IM(i, n.max);
      u !== i && (await Pe(), r.value = u);
    }, { immediate: !0 }), me(() => n.max, (i) => {
      const u = RM(n.max);
      u !== i && (o.value = u);
    }, { immediate: !0 });
    const s = q(() => Pn(r.value) ? "indeterminate" : r.value === o.value ? "complete" : "loading");
    return OM({
      modelValue: r,
      max: o,
      progressState: s
    }), (i, u) => (h(), x(l(X), {
      "as-child": i.asChild,
      as: i.as,
      "aria-valuemax": l(o),
      "aria-valuemin": 0,
      "aria-valuenow": El(l(r)) ? l(r) : void 0,
      "aria-valuetext": i.getValueText?.(l(r), l(o)),
      "aria-label": i.getValueLabel(l(r), l(o)),
      role: "progressbar",
      "data-state": s.value,
      "data-value": l(r) ?? void 0,
      "data-max": l(o)
    }, {
      default: y(() => [_(i.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "aria-valuemax",
      "aria-valuenow",
      "aria-valuetext",
      "aria-label",
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), FM = VM, NM = /* @__PURE__ */ b({
  __name: "ProgressIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = AM();
    return j(), (a, r) => (h(), x(l(X), A(t, {
      "data-state": l(n).progressState.value,
      "data-value": l(n).modelValue?.value ?? void 0,
      "data-max": l(n).max.value
    }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, [
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), LM = NM;
const zM = "radio.select";
function HM(e, t, n) {
  ts(zM, n, {
    originalEvent: e,
    value: t
  });
}
var UM = /* @__PURE__ */ b({
  __name: "Radio",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:checked", "select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ve(n, "checked", a, { passive: n.checked === void 0 }), { value: o } = Me(n), { forwardRef: s, currentElement: i } = j(), u = On(i), d = q(() => n.id && i.value ? document.querySelector(`[for="${n.id}"]`)?.innerText ?? n.value : void 0);
    function c(f) {
      n.disabled || HM(f, n.value, (p) => {
        a("select", p), !p?.defaultPrevented && (r.value = !0, u.value && p.stopPropagation());
      });
    }
    return (f, p) => (h(), x(l(X), A(f.$attrs, {
      id: f.id,
      ref: l(s),
      role: "radio",
      type: f.as === "button" ? "button" : void 0,
      as: f.as,
      "aria-checked": l(r),
      "aria-label": d.value,
      "as-child": f.asChild,
      disabled: f.disabled ? "" : void 0,
      "data-state": l(r) ? "checked" : "unchecked",
      "data-disabled": f.disabled ? "" : void 0,
      value: l(o),
      required: f.required,
      name: f.name,
      onClick: Ye(c, ["stop"])
    }), {
      default: y(() => [_(f.$slots, "default", { checked: l(r) }), l(u) && f.name ? (h(), x(l(In), {
        key: 0,
        type: "radio",
        tabindex: "-1",
        value: l(o),
        checked: !!l(r),
        name: f.name,
        disabled: f.disabled,
        required: f.required
      }, null, 8, [
        "value",
        "checked",
        "name",
        "disabled",
        "required"
      ])) : qe("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "as",
      "aria-checked",
      "aria-label",
      "as-child",
      "disabled",
      "data-state",
      "data-disabled",
      "value",
      "required",
      "name"
    ]));
  }
}), jM = UM;
const [WM, GM] = Se("RadioGroupRoot");
var KM = /* @__PURE__ */ b({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { disabled: i, loop: u, orientation: d, name: c, required: f, dir: p } = Me(n), v = gt(p), m = On(o);
    return GM({
      modelValue: s,
      changeModelValue: (g) => {
        s.value = g;
      },
      disabled: i,
      loop: u,
      orientation: d,
      name: c?.value,
      required: f
    }), (g, w) => (h(), x(l(cs), {
      "as-child": "",
      orientation: l(d),
      dir: l(v),
      loop: l(u)
    }, {
      default: y(() => [N(l(X), {
        ref: l(r),
        role: "radiogroup",
        "data-disabled": l(i) ? "" : void 0,
        "as-child": g.asChild,
        as: g.as,
        "aria-orientation": l(d),
        "aria-required": l(f),
        dir: l(v)
      }, {
        default: y(() => [_(g.$slots, "default", { modelValue: l(s) }), l(m) && l(c) ? (h(), x(l(In), {
          key: 0,
          required: l(f),
          disabled: l(i),
          value: l(s),
          name: l(c)
        }, null, 8, [
          "required",
          "disabled",
          "value",
          "name"
        ])) : qe("v-if", !0)]),
        _: 3
      }, 8, [
        "data-disabled",
        "as-child",
        "as",
        "aria-orientation",
        "aria-required",
        "dir"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), YM = KM;
const [XM, JM] = Se("RadioGroupItem");
var ZM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = WM(), i = q(() => s.disabled.value || n.disabled), u = q(() => s.required.value || n.required), d = q(() => Mn(s.modelValue?.value, n.value));
    JM({
      disabled: i,
      checked: d
    });
    const c = O(!1), f = [
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ];
    Lt("keydown", (v) => {
      f.includes(v.key) && (c.value = !0);
    }), Lt("keyup", () => {
      c.value = !1;
    });
    function p() {
      setTimeout(() => {
        c.value && o.value?.click();
      }, 0);
    }
    return (v, m) => (h(), x(l(fs), {
      checked: d.value,
      disabled: i.value,
      "as-child": "",
      focusable: !i.value,
      active: d.value
    }, {
      default: y(() => [N(jM, A({
        ...v.$attrs,
        ...n
      }, {
        ref: l(r),
        checked: d.value,
        required: u.value,
        disabled: i.value,
        "onUpdate:checked": m[0] || (m[0] = (g) => l(s).changeModelValue(v.value)),
        onSelect: m[1] || (m[1] = (g) => a("select", g)),
        onKeydown: m[2] || (m[2] = Je(Ye(() => {
        }, ["prevent"]), ["enter"])),
        onFocus: p
      }), {
        default: y(() => [_(v.$slots, "default", {
          checked: d.value,
          required: u.value,
          disabled: i.value
        })]),
        _: 3
      }, 16, [
        "checked",
        "required",
        "disabled"
      ])]),
      _: 3
    }, 8, [
      "checked",
      "disabled",
      "focusable",
      "active"
    ]));
  }
}), QM = ZM, eq = /* @__PURE__ */ b({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = XM();
    return (a, r) => (h(), x(l(Ct), { present: a.forceMount || l(n).checked.value }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "data-state": l(n).checked.value ? "checked" : "unchecked",
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), tq = eq;
const [xn, nq] = Se("ScrollAreaRoot");
var aq = /* @__PURE__ */ b({
  __name: "ScrollAreaRoot",
  props: {
    type: {
      type: String,
      required: !1,
      default: "hover"
    },
    dir: {
      type: String,
      required: !1
    },
    scrollHideDelay: {
      type: Number,
      required: !1,
      default: 600
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = O(0), r = O(0), o = O(), s = O(), i = O(), u = O(), d = O(!1), c = O(!1), { type: f, dir: p, scrollHideDelay: v } = Me(n), m = gt(p);
    function g() {
      o.value?.scrollTo({ top: 0 });
    }
    function w() {
      o.value?.scrollTo({
        top: 0,
        left: 0
      });
    }
    t({
      viewport: o,
      scrollTop: g,
      scrollTopLeft: w
    });
    const { forwardRef: C, currentElement: S } = j();
    return nq({
      type: f,
      dir: m,
      scrollHideDelay: v,
      scrollArea: S,
      viewport: o,
      onViewportChange: ($) => {
        o.value = $ || void 0;
      },
      content: s,
      onContentChange: ($) => {
        s.value = $;
      },
      scrollbarX: i,
      scrollbarXEnabled: d,
      scrollbarY: u,
      scrollbarYEnabled: c,
      onScrollbarXChange: ($) => {
        i.value = $ || void 0;
      },
      onScrollbarYChange: ($) => {
        u.value = $ || void 0;
      },
      onScrollbarXEnabledChange: ($) => {
        d.value = $;
      },
      onScrollbarYEnabledChange: ($) => {
        c.value = $;
      },
      onCornerWidthChange: ($) => {
        a.value = $;
      },
      onCornerHeightChange: ($) => {
        r.value = $;
      }
    }), ($, k) => (h(), x(l(X), {
      ref: l(C),
      "as-child": n.asChild,
      as: $.as,
      dir: l(m),
      style: dt({
        position: "relative",
        "--reka-scroll-area-corner-width": `${a.value}px`,
        "--reka-scroll-area-corner-height": `${r.value}px`
      })
    }, {
      default: y(() => [_($.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "dir",
      "style"
    ]));
  }
}), rq = aq, oq = /* @__PURE__ */ b({
  __name: "ScrollAreaCornerImpl",
  setup(e) {
    const t = xn(), n = O(0), a = O(0), r = q(() => !!n.value && !!a.value);
    function o() {
      const i = t.scrollbarX.value?.offsetHeight || 0;
      t.onCornerHeightChange(i), a.value = i;
    }
    function s() {
      const i = t.scrollbarY.value?.offsetWidth || 0;
      t.onCornerWidthChange(i), n.value = i;
    }
    return qn(t.scrollbarX.value, o), qn(t.scrollbarY.value, s), me(() => t.scrollbarX.value, o), me(() => t.scrollbarY.value, s), (i, u) => r.value ? (h(), x(l(X), A({
      key: 0,
      style: {
        width: `${n.value}px`,
        height: `${a.value}px`,
        position: "absolute",
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: 0
      }
    }, i.$parent?.$props), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, ["style"])) : qe("v-if", !0);
  }
}), sq = oq, lq = /* @__PURE__ */ b({
  __name: "ScrollAreaCorner",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = xn(), r = q(() => !!a.scrollbarX.value && !!a.scrollbarY.value), o = q(() => a.type.value !== "scroll" && r.value);
    return (s, i) => o.value ? (h(), x(sq, A({ key: 0 }, t, { ref: l(n) }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16)) : qe("v-if", !0);
  }
}), iq = lq;
function Og(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function Ei(e) {
  const t = Ig(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, a = (e.scrollbar.size - n) * t;
  return Math.max(a, 18);
}
function Ig(e, t) {
  const n = e / t;
  return Number.isNaN(n) ? 0 : n;
}
function uq(e, t = () => {
}) {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, a = 0;
  return (function r() {
    const o = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, s = n.left !== o.left, i = n.top !== o.top;
    (s || i) && t(), n = o, a = window.requestAnimationFrame(r);
  })(), () => window.cancelAnimationFrame(a);
}
function tv(e, t, n = "ltr") {
  const a = Ei(t), r = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - r, s = t.content - t.viewport, i = o - a, u = n === "ltr" ? [0, s] : [s * -1, 0], d = Ar(e, u[0], u[1]);
  return Og([0, s], [0, i])(d);
}
function Rs(e) {
  return e ? Number.parseInt(e, 10) : 0;
}
function dq(e, t, n, a = "ltr") {
  const r = Ei(n), o = r / 2, s = t || o, i = r - s, u = n.scrollbar.paddingStart + s, d = n.scrollbar.size - n.scrollbar.paddingEnd - i, c = n.content - n.viewport, f = a === "ltr" ? [0, c] : [c * -1, 0];
  return Og([u, d], f)(e);
}
function nv(e, t) {
  return e > 0 && e < t;
}
var cq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarX",
  setup(e) {
    const t = xn(), n = Ai(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarXChange(r.value);
    });
    const o = q(() => n.sizes.value);
    return (s, i) => (h(), x(Vg, {
      ref: l(a),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: dt({
        bottom: 0,
        left: l(t).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
        right: l(t).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
        "--reka-scroll-area-thumb-width": o.value ? `${l(Ei)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.x))
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), fq = cq, pq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarY",
  setup(e) {
    const t = xn(), n = Ai(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarYChange(r.value);
    });
    const o = q(() => n.sizes.value);
    return (s, i) => (h(), x(Vg, {
      ref: l(a),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: dt({
        top: 0,
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--reka-scroll-area-corner-height)",
        "--reka-scroll-area-thumb-height": o.value ? `${l(Ei)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.y))
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), vq = pq, mq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarAuto",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = xn(), n = Ti(), { forwardRef: a } = j(), r = O(!1), o = rc(() => {
      if (t.viewport.value) {
        const s = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        r.value = n.isHorizontal.value ? s : i;
      }
    }, 10);
    return Ce(() => o()), qn(t.viewport, o), qn(t.content, o), (s, i) => (h(), x(l(Ct), { present: s.forceMount || r.value }, {
      default: y(() => [N(Kc, A(s.$attrs, {
        ref: l(a),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), Rg = mq, hq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = xn(), { forwardRef: n } = j();
    let a;
    const r = O(!1);
    function o() {
      window.clearTimeout(a), r.value = !0;
    }
    function s() {
      a = window.setTimeout(() => {
        r.value = !1;
      }, t.scrollHideDelay.value);
    }
    return Ce(() => {
      const i = t.scrollArea.value;
      i && (i.addEventListener("pointerenter", o), i.addEventListener("pointerleave", s));
    }), nt(() => {
      const i = t.scrollArea.value;
      i && (window.clearTimeout(a), i.removeEventListener("pointerenter", o), i.removeEventListener("pointerleave", s));
    }), (i, u) => (h(), x(l(Ct), { present: i.forceMount || r.value }, {
      default: y(() => [N(Rg, A(i.$attrs, {
        ref: l(n),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), gq = hq, yq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarScroll",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = xn(), n = Ti(), { forwardRef: a } = j(), { state: r, dispatch: o } = Vh("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }), s = q(() => r.value !== "hidden");
    Ae((u) => {
      if (r.value === "idle") {
        const d = window.setTimeout(() => o("HIDE"), t.scrollHideDelay.value);
        u(() => {
          window.clearTimeout(d);
        });
      }
    });
    const i = rc(() => o("SCROLL_END"), 100);
    return Ae((u) => {
      const d = t.viewport.value, c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (d) {
        let f = d[c];
        const p = () => {
          const v = d[c];
          f !== v && (o("SCROLL"), i()), f = v;
        };
        d.addEventListener("scroll", p), u(() => {
          d.removeEventListener("scroll", p);
        });
      }
    }), (u, d) => (h(), x(l(Ct), { present: u.forceMount || s.value }, {
      default: y(() => [N(Kc, A(u.$attrs, {
        ref: l(a),
        "data-state": s.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), bq = yq;
const [Ti, _q] = Se("ScrollAreaScrollbar");
var wq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = xn(), r = q(() => t.orientation === "horizontal");
    me(r, () => {
      r.value ? a.onScrollbarXEnabledChange(!0) : a.onScrollbarYEnabledChange(!0);
    }, { immediate: !0 }), nt(() => {
      a.onScrollbarXEnabledChange(!1), a.onScrollbarYEnabledChange(!1);
    });
    const { orientation: o, forceMount: s, asChild: i, as: u } = Me(t);
    return _q({
      orientation: o,
      forceMount: s,
      isHorizontal: r,
      as: u,
      asChild: i
    }), (d, c) => l(a).type.value === "hover" ? (h(), x(gq, A({ key: 0 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "scroll" ? (h(), x(bq, A({ key: 1 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "auto" ? (h(), x(Rg, A({ key: 2 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "always" ? (h(), x(Kc, A({ key: 3 }, d.$attrs, {
      ref: l(n),
      "data-state": "visible"
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16)) : qe("v-if", !0);
  }
}), xq = wq;
const [Ai, Cq] = Se("ScrollAreaScrollbarVisible");
var Sq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarVisible",
  setup(e) {
    const t = xn(), n = Ti(), { forwardRef: a } = j(), r = O({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    }), o = q(() => {
      const C = Ig(r.value.viewport, r.value.content);
      return C > 0 && C < 1;
    }), s = O(), i = O(0);
    function u(C, S) {
      if (v.value) {
        const $ = t.viewport.value.scrollLeft + C.deltaY;
        t.viewport.value.scrollLeft = $, nv($, S) && C.preventDefault();
      } else {
        const $ = t.viewport.value.scrollTop + C.deltaY;
        t.viewport.value.scrollTop = $, nv($, S) && C.preventDefault();
      }
    }
    function d(C, S) {
      v.value ? i.value = S.x : i.value = S.y;
    }
    function c(C) {
      i.value = 0;
    }
    function f(C) {
      r.value = C;
    }
    function p(C, S) {
      return dq(C, i.value, r.value, S);
    }
    const v = q(() => n.isHorizontal.value);
    function m(C) {
      v.value ? t.viewport.value.scrollLeft = p(C, t.dir.value) : t.viewport.value.scrollTop = p(C);
    }
    function g() {
      if (v.value) {
        if (t.viewport.value && s.value) {
          const C = t.viewport.value.scrollLeft, S = tv(C, r.value, t.dir.value);
          s.value.style.transform = `translate3d(${S}px, 0, 0)`;
        }
      } else if (t.viewport.value && s.value) {
        const C = t.viewport.value.scrollTop, S = tv(C, r.value);
        s.value.style.transform = `translate3d(0, ${S}px, 0)`;
      }
    }
    function w(C) {
      s.value = C;
    }
    return Cq({
      sizes: r,
      hasThumb: o,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: c,
      handleSizeChange: f,
      onThumbPositionChange: g,
      onThumbChange: w,
      onDragScroll: m
    }), (C, S) => v.value ? (h(), x(fq, A({ key: 0 }, C.$attrs, { ref: l(a) }), {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 16)) : (h(), x(vq, A({ key: 1 }, C.$attrs, { ref: l(a) }), {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Kc = Sq, $q = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarImpl",
  props: { isHorizontal: {
    type: Boolean,
    required: !0
  } },
  emits: [
    "onDragScroll",
    "onWheelScroll",
    "onThumbPointerDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = xn(), o = Ai(), s = Ti(), { forwardRef: i, currentElement: u } = j(), d = O(""), c = O();
    function f(C) {
      if (c.value) {
        const S = C.clientX - c.value?.left, $ = C.clientY - c.value?.top;
        a("onDragScroll", {
          x: S,
          y: $
        });
      }
    }
    function p(C) {
      C.button === 0 && (C.target.setPointerCapture(C.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", r.viewport && (r.viewport.value.style.scrollBehavior = "auto"), f(C));
    }
    function v(C) {
      f(C);
    }
    function m(C) {
      const S = C.target;
      S.hasPointerCapture(C.pointerId) && S.releasePointerCapture(C.pointerId), document.body.style.webkitUserSelect = d.value, r.viewport && (r.viewport.value.style.scrollBehavior = ""), c.value = void 0;
    }
    function g(C) {
      const S = C.target, $ = u.value?.contains(S), k = o.sizes.value.content - o.sizes.value.viewport;
      $ && o.handleWheelScroll(C, k);
    }
    Ce(() => {
      document.addEventListener("wheel", g, { passive: !1 });
    }), nt(() => {
      document.removeEventListener("wheel", g);
    });
    function w() {
      u.value && (n.isHorizontal ? o.handleSizeChange({
        content: r.viewport.value?.scrollWidth ?? 0,
        viewport: r.viewport.value?.offsetWidth ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: Rs(getComputedStyle(u.value).paddingLeft),
          paddingEnd: Rs(getComputedStyle(u.value).paddingRight)
        }
      }) : o.handleSizeChange({
        content: r.viewport.value?.scrollHeight ?? 0,
        viewport: r.viewport.value?.offsetHeight ?? 0,
        scrollbar: {
          size: u.value?.clientHeight ?? 0,
          paddingStart: Rs(getComputedStyle(u.value).paddingTop),
          paddingEnd: Rs(getComputedStyle(u.value).paddingBottom)
        }
      }), o.onThumbPositionChange());
    }
    return qn(u, w), qn(r.content, w), (C, S) => (h(), x(l(X), {
      ref: l(i),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: l(s).as.value,
      "as-child": l(s).asChild.value,
      onPointerdown: p,
      onPointermove: v,
      onPointerup: m
    }, {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Vg = $q, Bq = /* @__PURE__ */ b({
  __name: "ScrollAreaThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = xn(), a = Ai();
    function r(p) {
      const m = p.target.getBoundingClientRect(), g = p.clientX - m.left, w = p.clientY - m.top;
      a.handleThumbDown(p, {
        x: g,
        y: w
      });
    }
    function o(p) {
      a.handleThumbUp(p);
    }
    const { forwardRef: s, currentElement: i } = j(), u = O(), d = q(() => n.viewport.value);
    function c() {
      if (!u.value) {
        const p = uq(d.value, a.onThumbPositionChange);
        u.value = p, a.onThumbPositionChange();
      }
    }
    const f = q(() => a.sizes.value);
    return H0(f, () => {
      a.onThumbChange(i.value), d.value && (a.onThumbPositionChange(), d.value.addEventListener("scroll", c));
    }), nt(() => {
      d.value.removeEventListener("scroll", c), n.viewport.value?.removeEventListener("scroll", c);
    }), (p, v) => (h(), x(l(X), {
      ref: l(s),
      "data-state": l(a).hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--reka-scroll-area-thumb-width)",
        height: "var(--reka-scroll-area-thumb-height)"
      },
      "as-child": t.asChild,
      as: p.as,
      onPointerdown: r,
      onPointerup: o
    }, {
      default: y(() => [_(p.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "as-child",
      "as"
    ]));
  }
}), kq = Bq, Pq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, { nonce: a } = Me(n), r = ki(a), o = xn(), s = O();
    Ce(() => {
      o.onViewportChange(s.value), o.onContentChange(u.value);
    }), t({ viewportElement: s });
    const { forwardRef: i, currentElement: u } = j();
    return (d, c) => (h(), W(Ke, null, [we("div", A({
      ref_key: "viewportElement",
      ref: s,
      "data-reka-scroll-area-viewport": "",
      style: {
        overflowX: l(o).scrollbarXEnabled.value ? "scroll" : "hidden",
        overflowY: l(o).scrollbarYEnabled.value ? "scroll" : "hidden"
      }
    }, d.$attrs, { tabindex: 0 }), [N(l(X), {
      ref: l(i),
      style: dt({ minWidth: l(o).scrollbarXEnabled.value ? "fit-content" : void 0 }),
      "as-child": n.asChild,
      as: d.as
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "style",
      "as-child",
      "as"
    ])], 16), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: y(() => c[0] || (c[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), Dq = Pq;
const Mq = [
  " ",
  "Enter",
  "ArrowUp",
  "ArrowDown"
], qq = [" ", "Enter"], Cn = 10;
function Vo(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => wd(a, t, n)) : wd(e, t, n);
}
function wd(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : Mn(e, t);
}
function Eq(e) {
  return e == null || e === "" || Array.isArray(e) && e.length === 0;
}
const Tq = {
  key: 0,
  value: ""
}, [Ra, Fg] = Se("SelectRoot");
var Aq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1,
      default: void 0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    autocomplete: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { required: r, disabled: o, multiple: s, dir: i } = Me(n), u = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? (s.value ? [] : void 0),
      passive: n.modelValue === void 0,
      deep: !0
    }), d = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), c = O(), f = O(), p = O({
      x: 0,
      y: 0
    }), v = q(() => s.value && Array.isArray(u.value) ? u.value?.length === 0 : Pn(u.value));
    st({ isProvider: !0 });
    const m = gt(i), g = On(c), w = O(/* @__PURE__ */ new Set()), C = q(() => Array.from(w.value).map((k) => k.value).join(";"));
    function S(k) {
      if (s.value) {
        const B = Array.isArray(u.value) ? [...u.value] : [], D = B.findIndex((P) => wd(P, k, n.by));
        D === -1 ? B.push(k) : B.splice(D, 1), u.value = [...B];
      } else u.value = k;
    }
    function $(k) {
      return Array.from(w.value).find((B) => Vo(k, B.value, n.by));
    }
    return Fg({
      triggerElement: c,
      onTriggerChange: (k) => {
        c.value = k;
      },
      valueElement: f,
      onValueElementChange: (k) => {
        f.value = k;
      },
      contentId: "",
      modelValue: u,
      onValueChange: S,
      by: n.by,
      open: d,
      multiple: s,
      required: r,
      onOpenChange: (k) => {
        d.value = k;
      },
      dir: m,
      triggerPointerDownPosRef: p,
      disabled: o,
      isEmptyModelValue: v,
      optionsSet: w,
      onOptionAdd: (k) => {
        const B = $(k.value);
        B && w.value.delete(B), w.value.add(k);
      },
      onOptionRemove: (k) => {
        const B = $(k.value);
        B && w.value.delete(B);
      }
    }), (k, B) => (h(), x(l(or), null, {
      default: y(() => [_(k.$slots, "default", {
        modelValue: l(u),
        open: l(d)
      }), l(g) ? (h(), x(Rq, {
        key: C.value,
        "aria-hidden": "true",
        tabindex: "-1",
        multiple: l(s),
        required: l(r),
        name: k.name,
        autocomplete: k.autocomplete,
        disabled: l(o),
        value: l(u)
      }, {
        default: y(() => [l(Pn)(l(u)) ? (h(), W("option", Tq)) : qe("v-if", !0), (h(!0), W(Ke, null, Nt(Array.from(w.value), (D) => (h(), W("option", A({ key: D.value ?? "" }, { ref_for: !0 }, D), null, 16))), 128))]),
        _: 1
      }, 8, [
        "multiple",
        "required",
        "name",
        "autocomplete",
        "disabled",
        "value"
      ])) : qe("v-if", !0)]),
      _: 3
    }));
  }
}), Oq = Aq, Iq = /* @__PURE__ */ b({
  __name: "BubbleSelect",
  props: {
    autocomplete: {
      type: String,
      required: !1
    },
    autofocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    form: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    size: {
      type: Number,
      required: !1
    },
    value: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = O(), a = Ra();
    me(() => t.value, (o, s) => {
      const i = window.HTMLSelectElement.prototype, d = Object.getOwnPropertyDescriptor(i, "value").set;
      if (o !== s && d && n.value) {
        const c = new Event("change", { bubbles: !0 });
        d.call(n.value, o), n.value.dispatchEvent(c);
      }
    });
    function r(o) {
      a.onValueChange(o.target.value);
    }
    return (o, s) => (h(), x(l(wi), { "as-child": "" }, {
      default: y(() => [we("select", A({
        ref_key: "selectElement",
        ref: n
      }, t, { onInput: r }), [_(o.$slots, "default")], 16)]),
      _: 3
    }));
  }
}), Rq = Iq, Vq = /* @__PURE__ */ b({
  __name: "SelectPopperPosition",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: Cn
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(Yr), A(l(n), { style: {
      boxSizing: "border-box",
      "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-select-content-available-width": "var(--reka-popper-available-width)",
      "--reka-select-content-available-height": "var(--reka-popper-available-height)",
      "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Fq = Vq;
const Nq = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [dr, Ng] = Se("SelectContent");
var Lq = /* @__PURE__ */ b({
  __name: "SelectContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "item-aligned"
    },
    bodyLock: {
      type: Boolean,
      required: !1,
      default: !0
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ra();
    hc(), os(n.bodyLock);
    const { CollectionSlot: o, getItems: s } = st(), i = O();
    ls(i);
    const { search: u, handleTypeaheadSearch: d } = pi(), c = O(), f = O(), p = O(), v = O(!1), m = O(!1), g = O(!1);
    function w() {
      f.value && i.value && fd([f.value, i.value]);
    }
    me(v, () => {
      w();
    });
    const { onOpenChange: C, triggerPointerDownPosRef: S } = r;
    Ae((D) => {
      if (!i.value) return;
      let P = {
        x: 0,
        y: 0
      };
      const E = (M) => {
        P = {
          x: Math.abs(Math.round(M.pageX) - (S.value?.x ?? 0)),
          y: Math.abs(Math.round(M.pageY) - (S.value?.y ?? 0))
        };
      }, T = (M) => {
        M.pointerType !== "touch" && (P.x <= 10 && P.y <= 10 ? M.preventDefault() : i.value?.contains(M.target) || C(!1), document.removeEventListener("pointermove", E), S.value = null);
      };
      S.value !== null && (document.addEventListener("pointermove", E), document.addEventListener("pointerup", T, {
        capture: !0,
        once: !0
      })), D(() => {
        document.removeEventListener("pointermove", E), document.removeEventListener("pointerup", T, { capture: !0 });
      });
    });
    function $(D) {
      const P = D.ctrlKey || D.altKey || D.metaKey;
      if (D.key === "Tab" && D.preventDefault(), !P && D.key.length === 1 && d(D.key, s()), [
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End"
      ].includes(D.key)) {
        let T = [...s().map((M) => M.ref)];
        if (["ArrowUp", "End"].includes(D.key) && (T = T.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(D.key)) {
          const M = D.target, I = T.indexOf(M);
          T = T.slice(I + 1);
        }
        setTimeout(() => fd(T)), D.preventDefault();
      }
    }
    const k = q(() => n.position === "popper" ? n : {}), B = he(k.value);
    return Ng({
      content: i,
      viewport: c,
      onViewportChange: (D) => {
        c.value = D;
      },
      itemRefCallback: (D, P, E) => {
        const T = !m.value && !E, M = Vo(r.modelValue.value, P, r.by);
        if (r.multiple.value) {
          if (g.value) return;
          (M || T) && (f.value = D, M && (g.value = !0));
        } else (M || T) && (f.value = D);
        T && (m.value = !0);
      },
      selectedItem: f,
      selectedItemText: p,
      onItemLeave: () => {
        i.value?.focus();
      },
      itemTextRefCallback: (D, P, E) => {
        const T = !m.value && !E;
        (Vo(r.modelValue.value, P, r.by) || T) && (p.value = D);
      },
      focusSelectedItem: w,
      position: n.position,
      isPositioned: v,
      searchRef: u
    }), (D, P) => (h(), x(l(o), null, {
      default: y(() => [N(l(hi), {
        "as-child": "",
        onMountAutoFocus: P[6] || (P[6] = Ye(() => {
        }, ["prevent"])),
        onUnmountAutoFocus: P[7] || (P[7] = (E) => {
          a("closeAutoFocus", E), !E.defaultPrevented && (l(r).triggerElement.value?.focus({ preventScroll: !0 }), E.preventDefault());
        })
      }, {
        default: y(() => [N(l(Oa), {
          "as-child": "",
          "disable-outside-pointer-events": D.disableOutsidePointerEvents,
          onFocusOutside: P[2] || (P[2] = Ye(() => {
          }, ["prevent"])),
          onDismiss: P[3] || (P[3] = (E) => l(r).onOpenChange(!1)),
          onEscapeKeyDown: P[4] || (P[4] = (E) => a("escapeKeyDown", E)),
          onPointerDownOutside: P[5] || (P[5] = (E) => a("pointerDownOutside", E))
        }, {
          default: y(() => [(h(), x(kt(D.position === "popper" ? Fq : jq), A({
            ...D.$attrs,
            ...l(B)
          }, {
            id: l(r).contentId,
            ref: (E) => {
              const T = l(Wt)(E);
              T?.hasAttribute("data-reka-popper-content-wrapper") ? i.value = T.firstElementChild : i.value = T;
            },
            role: "listbox",
            "data-state": l(r).open.value ? "open" : "closed",
            dir: l(r).dir.value,
            style: {
              display: "flex",
              flexDirection: "column",
              outline: "none"
            },
            onContextmenu: P[0] || (P[0] = Ye(() => {
            }, ["prevent"])),
            onPlaced: P[1] || (P[1] = (E) => v.value = !0),
            onKeydown: $
          }), {
            default: y(() => [_(D.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "data-state",
            "dir",
            "onKeydown"
          ]))]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      })]),
      _: 3
    }));
  }
}), zq = Lq;
const [Yc, Hq] = Se("SelectItemAlignedPosition");
var Uq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st(), o = Ra(), s = dr(), i = O(!1), u = O(!0), d = O(), { forwardRef: c, currentElement: f } = j(), { viewport: p, selectedItem: v, selectedItemText: m, focusSelectedItem: g } = s;
    function w() {
      if (o.triggerElement.value && o.valueElement.value && d.value && f.value && p?.value && v?.value && m?.value) {
        const $ = o.triggerElement.value.getBoundingClientRect(), k = f.value.getBoundingClientRect(), B = o.valueElement.value.getBoundingClientRect(), D = m.value.getBoundingClientRect();
        if (o.dir.value !== "rtl") {
          const V = D.left - k.left, te = B.left - V, z = $.left - te, re = $.width + z, ie = Math.max(re, k.width), L = window.innerWidth - Cn, be = Ar(te, Cn, Math.max(Cn, L - ie));
          d.value.style.minWidth = `${re}px`, d.value.style.left = `${be}px`;
        } else {
          const V = k.right - D.right, te = window.innerWidth - B.right - V, z = window.innerWidth - $.right - te, re = $.width + z, ie = Math.max(re, k.width), L = window.innerWidth - Cn, be = Ar(te, Cn, Math.max(Cn, L - ie));
          d.value.style.minWidth = `${re}px`, d.value.style.right = `${be}px`;
        }
        const P = r().map((V) => V.ref), E = window.innerHeight - Cn * 2, T = p.value.scrollHeight, M = window.getComputedStyle(f.value), I = Number.parseInt(M.borderTopWidth, 10), F = Number.parseInt(M.paddingTop, 10), J = Number.parseInt(M.borderBottomWidth, 10), ne = Number.parseInt(M.paddingBottom, 10), Q = I + F + T + ne + J, G = Math.min(v.value.offsetHeight * 5, Q), H = window.getComputedStyle(p.value), U = Number.parseInt(H.paddingTop, 10), se = Number.parseInt(H.paddingBottom, 10), ee = $.top + $.height / 2 - Cn, de = E - ee, fe = v.value.offsetHeight / 2, _e = v.value.offsetTop + fe, ye = I + F + _e, Te = Q - ye;
        if (ye <= ee) {
          const V = v.value === P[P.length - 1];
          d.value.style.bottom = "0px";
          const te = f.value.clientHeight - p.value.offsetTop - p.value.offsetHeight, z = Math.max(de, fe + (V ? se : 0) + te + J), re = ye + z;
          d.value.style.height = `${re}px`;
        } else {
          const V = v.value === P[0];
          d.value.style.top = "0px";
          const z = Math.max(ee, I + p.value.offsetTop + (V ? U : 0) + fe) + Te;
          d.value.style.height = `${z}px`, p.value.scrollTop = ye - ee + p.value.offsetTop;
        }
        d.value.style.margin = `${Cn}px 0`, d.value.style.minHeight = `${G}px`, d.value.style.maxHeight = `${E}px`, a("placed"), requestAnimationFrame(() => i.value = !0);
      }
    }
    const C = O("");
    Ce(async () => {
      await Pe(), w(), f.value && (C.value = window.getComputedStyle(f.value).zIndex);
    });
    function S($) {
      $ && u.value === !0 && (w(), g?.(), u.value = !1);
    }
    return qn(o.triggerElement, () => {
      w();
    }), Hq({
      contentWrapper: d,
      shouldExpandOnScrollRef: i,
      onScrollButtonChange: S
    }), ($, k) => (h(), W("div", {
      ref_key: "contentWrapperElement",
      ref: d,
      style: dt({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: C.value
      })
    }, [N(l(X), A({
      ref: l(c),
      style: {
        boxSizing: "border-box",
        maxHeight: "100%"
      }
    }, {
      ...$.$attrs,
      ...n
    }), {
      default: y(() => [_($.$slots, "default")]),
      _: 3
    }, 16)], 4));
  }
}), jq = Uq, Wq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectProvider",
  props: { context: {
    type: Object,
    required: !0
  } },
  setup(e) {
    return Fg(e.context), Ng(Nq), (n, a) => _(n.$slots, "default");
  }
}), Gq = Wq;
const Kq = { key: 1 };
var Yq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, r = ve(n, t), o = Ra(), s = O();
    Ce(() => {
      s.value = new DocumentFragment();
    });
    const i = O(), u = q(() => n.forceMount || o.open.value), d = O(u.value);
    return me(u, () => {
      setTimeout(() => d.value = u.value);
    }), (c, f) => u.value || d.value || i.value?.present ? (h(), x(l(Ct), {
      key: 0,
      ref_key: "presenceRef",
      ref: i,
      present: u.value
    }, {
      default: y(() => [N(zq, oe(le({
        ...l(r),
        ...c.$attrs
      })), {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"])) : s.value ? (h(), W("div", Kq, [(h(), x(di, { to: s.value }, [N(Gq, { context: l(o) }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["context"])], 8, ["to"]))])) : qe("v-if", !0);
  }
}), Xq = Yq;
const [Jq, Zq] = Se("SelectGroup");
var Qq = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-select-group");
    return Zq({ id: n }), (a, r) => (h(), x(l(X), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), eE = Qq, tE = /* @__PURE__ */ b({
  __name: "SelectIcon",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), x(l(X), {
      "aria-hidden": "true",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: y(() => [_(t.$slots, "default", {}, () => [n[0] || (n[0] = Re(""))])]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), nE = tE;
const [Lg, aE] = Se("SelectItem");
var rE = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = Me(n), o = Ra(), s = dr(), { forwardRef: i, currentElement: u } = j(), { CollectionItem: d } = st(), c = q(() => Vo(o.modelValue?.value, n.value, o.by)), f = O(!1), p = O(n.textValue ?? ""), v = Ge(void 0, "reka-select-item-text"), m = "select.select";
    async function g(k) {
      if (k.defaultPrevented) return;
      const B = {
        originalEvent: k,
        value: n.value
      };
      ts(m, w, B);
    }
    async function w(k) {
      await Pe(), a("select", k), !k.defaultPrevented && (r.value || (o.onValueChange(n.value), o.multiple.value || o.onOpenChange(!1)));
    }
    async function C(k) {
      await Pe(), !k.defaultPrevented && (r.value ? s.onItemLeave?.() : k.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function S(k) {
      await Pe(), !k.defaultPrevented && k.currentTarget === ot() && s.onItemLeave?.();
    }
    async function $(k) {
      await Pe(), !(k.defaultPrevented || s.searchRef?.value !== "" && k.key === " ") && (qq.includes(k.key) && g(k), k.key === " " && k.preventDefault());
    }
    if (n.value === "") throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    return Ce(() => {
      u.value && s.itemRefCallback(u.value, n.value, n.disabled);
    }), aE({
      value: n.value,
      disabled: r,
      textId: v,
      isSelected: c,
      onItemTextChange: (k) => {
        p.value = ((p.value || k?.textContent) ?? "").trim();
      }
    }), (k, B) => (h(), x(l(d), { value: { textValue: p.value } }, {
      default: y(() => [N(l(X), {
        ref: l(i),
        role: "option",
        "aria-labelledby": l(v),
        "data-highlighted": f.value ? "" : void 0,
        "aria-selected": c.value,
        "data-state": c.value ? "checked" : "unchecked",
        "aria-disabled": l(r) || void 0,
        "data-disabled": l(r) ? "" : void 0,
        tabindex: l(r) ? void 0 : -1,
        as: k.as,
        "as-child": k.asChild,
        onFocus: B[0] || (B[0] = (D) => f.value = !0),
        onBlur: B[1] || (B[1] = (D) => f.value = !1),
        onPointerup: g,
        onPointerdown: B[2] || (B[2] = (D) => {
          D.currentTarget.focus({ preventScroll: !0 });
        }),
        onTouchend: B[3] || (B[3] = Ye(() => {
        }, ["prevent", "stop"])),
        onPointermove: C,
        onPointerleave: S,
        onKeydown: $
      }, {
        default: y(() => [_(k.$slots, "default")]),
        _: 3
      }, 8, [
        "aria-labelledby",
        "data-highlighted",
        "aria-selected",
        "data-state",
        "aria-disabled",
        "data-disabled",
        "tabindex",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), oE = rE, sE = /* @__PURE__ */ b({
  __name: "SelectItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Lg();
    return (a, r) => l(n).isSelected.value ? (h(), x(l(X), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : qe("v-if", !0);
  }
}), lE = sE, iE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Ra(), a = dr(), r = Lg(), { forwardRef: o, currentElement: s } = j(), i = q(() => ({
      value: r.value,
      disabled: r.disabled.value,
      textContent: s.value?.textContent ?? r.value?.toString() ?? ""
    }));
    return Ce(() => {
      s.value && (r.onItemTextChange(s.value), a.itemTextRefCallback(s.value, r.value, r.disabled.value), n.onOptionAdd(i.value));
    }), nt(() => {
      n.onOptionRemove(i.value);
    }), (u, d) => (h(), x(l(X), A({
      id: l(r).textId,
      ref: l(o)
    }, {
      ...t,
      ...u.$attrs
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), zg = iE, uE = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Jq({ id: "" });
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).id }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), dE = uE, cE = /* @__PURE__ */ b({
  __name: "SelectPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), fE = cE, pE = /* @__PURE__ */ b({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(e, { emit: t }) {
    const n = t, { getItems: a } = st(), r = dr(), o = O(null);
    function s() {
      o.value !== null && (window.clearInterval(o.value), o.value = null);
    }
    Ae(() => {
      a().map((c) => c.ref).find((c) => c === ot())?.scrollIntoView({ block: "nearest" });
    });
    function i() {
      o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    function u() {
      r.onItemLeave?.(), o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    return ar(() => s()), (d, c) => (h(), x(l(X), A({
      "aria-hidden": "true",
      style: { flexShrink: 0 }
    }, d.$parent?.$props, {
      onPointerdown: i,
      onPointermove: u,
      onPointerleave: c[0] || (c[0] = () => {
        s();
      })
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Hg = pE, vE = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = dr(), n = t.position === "item-aligned" ? Yc() : void 0, { forwardRef: a, currentElement: r } = j(), o = O(!1);
    return Ae((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          const d = i.scrollHeight - i.clientHeight;
          o.value = Math.ceil(i.scrollTop) < d;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), me(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), x(Hg, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : qe("v-if", !0);
  }
}), mE = vE, hE = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = dr(), n = t.position === "item-aligned" ? Yc() : void 0, { forwardRef: a, currentElement: r } = j(), o = O(!1);
    return Ae((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          o.value = i.scrollTop > 0;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), me(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), x(Hg, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : qe("v-if", !0);
  }
}), gE = hE, yE = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({ "aria-hidden": "true" }, t), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bE = yE, _E = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Ra(), { forwardRef: a, currentElement: r } = j(), o = q(() => n.disabled?.value || t.disabled);
    n.contentId ||= Ge(void 0, "reka-select-content"), Ce(() => {
      n.onTriggerChange(r.value);
    });
    const { getItems: s } = st(), { search: i, handleTypeaheadSearch: u, resetTypeahead: d } = pi();
    function c() {
      o.value || (n.onOpenChange(!0), d());
    }
    function f(p) {
      c(), n.triggerPointerDownPosRef.value = {
        x: Math.round(p.pageX),
        y: Math.round(p.pageY)
      };
    }
    return (p, v) => (h(), x(l(sr), {
      "as-child": "",
      reference: p.reference
    }, {
      default: y(() => [N(l(X), {
        ref: l(a),
        role: "combobox",
        type: p.as === "button" ? "button" : void 0,
        "aria-controls": l(n).contentId,
        "aria-expanded": l(n).open.value || !1,
        "aria-required": l(n).required?.value,
        "aria-autocomplete": "none",
        disabled: o.value,
        dir: l(n)?.dir.value,
        "data-state": l(n)?.open.value ? "open" : "closed",
        "data-disabled": o.value ? "" : void 0,
        "data-placeholder": l(Eq)(l(n).modelValue?.value) ? "" : void 0,
        "as-child": p.asChild,
        as: p.as,
        onClick: v[0] || (v[0] = (m) => {
          m?.currentTarget?.focus();
        }),
        onPointerdown: v[1] || (v[1] = (m) => {
          if (m.pointerType === "touch") return m.preventDefault();
          const g = m.target;
          g.hasPointerCapture(m.pointerId) && g.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && (f(m), m.preventDefault());
        }),
        onPointerup: v[2] || (v[2] = Ye((m) => {
          m.pointerType === "touch" && f(m);
        }, ["prevent"])),
        onKeydown: v[3] || (v[3] = (m) => {
          const g = l(i) !== "";
          !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && g && m.key === " " || (l(u)(m.key, l(s)()), l(Mq).includes(m.key) && (c(), m.preventDefault()));
        })
      }, {
        default: y(() => [_(p.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "aria-controls",
        "aria-expanded",
        "aria-required",
        "disabled",
        "dir",
        "data-state",
        "data-disabled",
        "data-placeholder",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), wE = _E, xE = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = Ra();
    Ce(() => {
      r.valueElement = a;
    });
    const o = q(() => {
      let i = [];
      const u = Array.from(r.optionsSet.value), d = (c) => u.find((f) => Vo(c, f.value, r.by));
      return Array.isArray(r.modelValue.value) ? i = r.modelValue.value.map((c) => d(c)?.textContent ?? "") : i = [d(r.modelValue.value)?.textContent ?? ""], i.filter(Boolean);
    }), s = q(() => o.value.length ? o.value.join(", ") : t.placeholder);
    return (i, u) => (h(), x(l(X), {
      ref: l(n),
      as: i.as,
      "as-child": i.asChild,
      style: { pointerEvents: "none" },
      "data-placeholder": o.value.length ? void 0 : t.placeholder
    }, {
      default: y(() => [_(i.$slots, "default", {
        selectedLabel: o.value,
        modelValue: l(r).modelValue.value
      }, () => [Re(Ne(s.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-placeholder"
    ]));
  }
}), CE = xE, SE = /* @__PURE__ */ b({
  __name: "SelectViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { nonce: n } = Me(t), a = ki(n), r = dr(), o = r.position === "item-aligned" ? Yc() : void 0, { forwardRef: s, currentElement: i } = j();
    Ce(() => {
      r?.onViewportChange(i.value);
    });
    const u = O(0);
    function d(c) {
      const f = c.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: v } = o ?? {};
      if (p?.value && v?.value) {
        const m = Math.abs(u.value - f.scrollTop);
        if (m > 0) {
          const g = window.innerHeight - Cn * 2, w = Number.parseFloat(v.value.style.minHeight), C = Number.parseFloat(v.value.style.height), S = Math.max(w, C);
          if (S < g) {
            const $ = S + m, k = Math.min(g, $), B = $ - k;
            v.value.style.height = `${k}px`, v.value.style.bottom === "0px" && (f.scrollTop = B > 0 ? B : 0, v.value.style.justifyContent = "flex-end");
          }
        }
      }
      u.value = f.scrollTop;
    }
    return (c, f) => (h(), W(Ke, null, [N(l(X), A({
      ref: l(s),
      "data-reka-select-viewport": "",
      role: "presentation"
    }, {
      ...c.$attrs,
      ...t
    }, {
      style: {
        position: "relative",
        flex: 1,
        overflow: "hidden auto"
      },
      onScroll: d
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16), N(l(X), {
      as: "style",
      nonce: l(a)
    }, {
      default: y(() => f[0] || (f[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), $E = SE, BE = /* @__PURE__ */ b({
  __name: "BaseSeparator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ["horizontal", "vertical"];
    function a(i) {
      return n.includes(i);
    }
    const r = q(() => a(t.orientation) ? t.orientation : "horizontal"), o = q(() => r.value === "vertical" ? t.orientation : void 0), s = q(() => t.decorative ? { role: "none" } : {
      "aria-orientation": o.value,
      role: "separator"
    });
    return (i, u) => (h(), x(l(X), A({
      as: i.as,
      "as-child": i.asChild,
      "data-orientation": r.value
    }, s.value), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-orientation"
    ]));
  }
}), kE = BE, PE = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(kE, oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Xc = PE;
function DE(e = [], t, n) {
  const a = [...e];
  return a[n] = t, a.sort((r, o) => r - o);
}
function Ug(e, t, n) {
  const o = 100 / (n - t) * (e - t);
  return Ar(o, 0, 100);
}
function ME(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function qE(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((r) => Math.abs(r - t)), a = Math.min(...n);
  return n.indexOf(a);
}
function EE(e, t, n) {
  const a = e / 2, o = Jc([0, 50], [0, a]);
  return (a - o(t) * n) * n;
}
function TE(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function AE(e, t) {
  if (t > 0) {
    const n = TE(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Jc(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function OE(e) {
  return (String(e).split(".")[1] || "").length;
}
function IE(e, t) {
  const n = 10 ** t;
  return Math.round(e * n) / n;
}
const jg = ["PageUp", "PageDown"], Wg = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
], Gg = {
  "from-left": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-right": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowRight"
  ],
  "from-bottom": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-top": [
    "Home",
    "PageUp",
    "ArrowUp",
    "ArrowLeft"
  ]
}, [Kg, Yg] = Se(["SliderVertical", "SliderHorizontal"]);
var RE = /* @__PURE__ */ b({
  __name: "SliderHorizontal",
  props: {
    dir: {
      type: String,
      required: !1
    },
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, dir: s, inverted: i } = Me(n), { forwardRef: u, currentElement: d } = j(), c = Qr(), f = O(), p = O(), v = q(() => s?.value !== "rtl" && !i.value || s?.value !== "ltr" && i.value);
    function m(S, $) {
      const k = p.value || d.value.getBoundingClientRect(), B = [...c.thumbElements.value][c.valueIndexToChangeRef.value], D = c.thumbAlignment.value === "contain" ? B.clientWidth : 0;
      !f.value && !$ && c.thumbAlignment.value === "contain" && (f.value = S.clientX - B.getBoundingClientRect().left);
      const P = [0, k.width - D], E = v.value ? [o.value, r.value] : [r.value, o.value], T = Jc(P, E);
      p.value = k;
      const M = $ ? S.clientX - k.left - D / 2 : S.clientX - k.left - (f.value ?? 0);
      return T(M);
    }
    const g = q(() => v.value ? "left" : "right"), w = q(() => v.value ? "right" : "left"), C = q(() => v.value ? 1 : -1);
    return Yg({
      startEdge: g,
      endEdge: w,
      direction: C,
      size: "width"
    }), (S, $) => (h(), x(Xg, {
      ref: l(u),
      dir: l(s),
      "data-orientation": "horizontal",
      style: dt({ "--reka-slider-thumb-transform": !v.value && l(c).thumbAlignment.value === "overflow" ? "translateX(50%)" : "translateX(-50%)" }),
      onSlideStart: $[0] || ($[0] = (k) => {
        const B = m(k, !0);
        a("slideStart", B);
      }),
      onSlideMove: $[1] || ($[1] = (k) => {
        const B = m(k);
        a("slideMove", B);
      }),
      onSlideEnd: $[2] || ($[2] = () => {
        p.value = void 0, f.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: $[3] || ($[3] = (k) => {
        const B = v.value ? "from-left" : "from-right", D = l(Gg)[B].includes(k.key);
        a("stepKeyDown", k, D ? -1 : 1);
      }),
      onEndKeyDown: $[4] || ($[4] = (k) => a("endKeyDown", k)),
      onHomeKeyDown: $[5] || ($[5] = (k) => a("homeKeyDown", k))
    }, {
      default: y(() => [_(S.$slots, "default")]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), VE = RE, FE = /* @__PURE__ */ b({
  __name: "SliderVertical",
  props: {
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, inverted: s } = Me(n), i = Qr(), { forwardRef: u, currentElement: d } = j(), c = O(), f = O(), p = q(() => !s.value);
    function v(C, S) {
      const $ = f.value || d.value.getBoundingClientRect(), k = [...i.thumbElements.value][i.valueIndexToChangeRef.value], B = i.thumbAlignment.value === "contain" ? k.clientHeight : 0;
      !c.value && !S && i.thumbAlignment.value === "contain" && (c.value = C.clientY - k.getBoundingClientRect().top);
      const D = [0, $.height - B], P = p.value ? [r.value, o.value] : [o.value, r.value], E = Jc(D, P), T = S ? C.clientY - $.top - B / 2 : C.clientY - $.top - (c.value ?? 0);
      return f.value = $, E(T);
    }
    const m = q(() => p.value ? "bottom" : "top"), g = q(() => p.value ? "top" : "bottom"), w = q(() => p.value ? 1 : -1);
    return Yg({
      startEdge: m,
      endEdge: g,
      direction: w,
      size: "height"
    }), (C, S) => (h(), x(Xg, {
      ref: l(u),
      "data-orientation": "vertical",
      style: dt({ "--reka-slider-thumb-transform": !p.value && l(i).thumbAlignment.value === "overflow" ? "translateY(-50%)" : "translateY(50%)" }),
      onSlideStart: S[0] || (S[0] = ($) => {
        const k = v($, !0);
        a("slideStart", k);
      }),
      onSlideMove: S[1] || (S[1] = ($) => {
        const k = v($);
        a("slideMove", k);
      }),
      onSlideEnd: S[2] || (S[2] = () => {
        f.value = void 0, c.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: S[3] || (S[3] = ($) => {
        const k = p.value ? "from-bottom" : "from-top", B = l(Gg)[k].includes($.key);
        a("stepKeyDown", $, B ? -1 : 1);
      }),
      onEndKeyDown: S[4] || (S[4] = ($) => a("endKeyDown", $)),
      onHomeKeyDown: S[5] || (S[5] = ($) => a("homeKeyDown", $))
    }, {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), NE = FE;
const [Qr, LE] = Se("SliderRoot");
var zE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    defaultValue: {
      type: Array,
      required: !1,
      default: () => [0]
    },
    modelValue: {
      type: [Array, null],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    inverted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    min: {
      type: Number,
      required: !1,
      default: 0
    },
    max: {
      type: Number,
      required: !1,
      default: 100
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    minStepsBetweenThumbs: {
      type: Number,
      required: !1,
      default: 0
    },
    thumbAlignment: {
      type: String,
      required: !1,
      default: "contain"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, { min: r, max: o, step: s, minStepsBetweenThumbs: i, orientation: u, disabled: d, thumbAlignment: c, dir: f } = Me(n), p = gt(f), { forwardRef: v, currentElement: m } = j(), g = On(m), { CollectionSlot: w } = st({ isProvider: !0 }), C = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), S = q(() => Array.isArray(C.value) ? [...C.value] : []), $ = O(0), k = O(S.value);
    function B(M) {
      const I = qE(S.value, M);
      E(M, I);
    }
    function D(M) {
      E(M, $.value);
    }
    function P() {
      const M = k.value[$.value];
      S.value[$.value] !== M && a("valueCommit", f0(S.value));
    }
    function E(M, I, { commit: F } = { commit: !1 }) {
      const J = OE(s.value), ne = IE(Math.round((M - r.value) / s.value) * s.value + r.value, J), Q = Ar(ne, r.value, o.value), G = DE(S.value, Q, I);
      if (AE(G, i.value * s.value)) {
        $.value = G.indexOf(Q);
        const H = String(G) !== String(C.value);
        H && F && a("valueCommit", G), H && (T.value[$.value]?.focus(), C.value = G);
      }
    }
    const T = O([]);
    return LE({
      modelValue: C,
      currentModelValue: S,
      valueIndexToChangeRef: $,
      thumbElements: T,
      orientation: u,
      min: r,
      max: o,
      disabled: d,
      thumbAlignment: c
    }), (M, I) => (h(), x(l(w), null, {
      default: y(() => [(h(), x(kt(l(u) === "horizontal" ? VE : NE), A(M.$attrs, {
        ref: l(v),
        "as-child": M.asChild,
        as: M.as,
        min: l(r),
        max: l(o),
        dir: l(p),
        inverted: M.inverted,
        "aria-disabled": l(d),
        "data-disabled": l(d) ? "" : void 0,
        onPointerdown: I[0] || (I[0] = () => {
          l(d) || (k.value = S.value);
        }),
        onSlideStart: I[1] || (I[1] = (F) => !l(d) && B(F)),
        onSlideMove: I[2] || (I[2] = (F) => !l(d) && D(F)),
        onSlideEnd: I[3] || (I[3] = (F) => !l(d) && P()),
        onHomeKeyDown: I[4] || (I[4] = (F) => !l(d) && E(l(r), 0, { commit: !0 })),
        onEndKeyDown: I[5] || (I[5] = (F) => !l(d) && E(l(o), S.value.length - 1, { commit: !0 })),
        onStepKeyDown: I[6] || (I[6] = (F, J) => {
          if (!l(d)) {
            const G = l(jg).includes(F.key) || F.shiftKey && l(Wg).includes(F.key) ? 10 : 1, H = $.value, U = S.value[H], se = l(s) * G * J;
            E(U + se, H, { commit: !0 });
          }
        })
      }), {
        default: y(() => [_(M.$slots, "default", { modelValue: l(C) }), l(g) && M.name ? (h(), x(l(In), {
          key: 0,
          type: "number",
          value: l(C),
          name: M.name,
          required: M.required,
          disabled: l(d),
          step: l(s)
        }, null, 8, [
          "value",
          "name",
          "required",
          "disabled",
          "step"
        ])) : qe("v-if", !0)]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "min",
        "max",
        "dir",
        "inverted",
        "aria-disabled",
        "data-disabled"
      ]))]),
      _: 3
    }));
  }
}), HE = zE, UE = /* @__PURE__ */ b({
  __name: "SliderImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  emits: [
    "slideStart",
    "slideMove",
    "slideEnd",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Qr();
    return (o, s) => (h(), x(l(X), A({ "data-slider-impl": "" }, n, {
      onKeydown: s[0] || (s[0] = (i) => {
        i.key === "Home" ? (a("homeKeyDown", i), i.preventDefault()) : i.key === "End" ? (a("endKeyDown", i), i.preventDefault()) : l(jg).concat(l(Wg)).includes(i.key) && (a("stepKeyDown", i), i.preventDefault());
      }),
      onPointerdown: s[1] || (s[1] = (i) => {
        const u = i.target;
        u.setPointerCapture(i.pointerId), i.preventDefault(), l(r).thumbElements.value.includes(u) ? u.focus() : a("slideStart", i);
      }),
      onPointermove: s[2] || (s[2] = (i) => {
        i.target.hasPointerCapture(i.pointerId) && a("slideMove", i);
      }),
      onPointerup: s[3] || (s[3] = (i) => {
        const u = i.target;
        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), a("slideEnd", i));
      })
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Xg = UE, jE = /* @__PURE__ */ b({
  __name: "SliderRange",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = Qr(), n = Kg();
    j();
    const a = q(() => t.currentModelValue.value.map((s) => Ug(s, t.min.value, t.max.value))), r = q(() => t.currentModelValue.value.length > 1 ? Math.min(...a.value) : 0), o = q(() => 100 - Math.max(...a.value, 0));
    return (s, i) => (h(), x(l(X), {
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      "as-child": s.asChild,
      as: s.as,
      style: dt({
        [l(n).startEdge.value]: `${r.value}%`,
        [l(n).endEdge.value]: `${o.value}%`
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, [
      "data-disabled",
      "data-orientation",
      "as-child",
      "as",
      "style"
    ]));
  }
}), WE = jE, GE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Qr(), a = Kg(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = q(() => n.modelValue?.value?.[t.index]), u = q(() => i.value === void 0 ? 0 : Ug(i.value, n.min.value ?? 0, n.max.value ?? 100)), d = q(() => ME(t.index, n.modelValue?.value?.length ?? 0)), c = Rh(o), f = q(() => c[a.size].value), p = q(() => n.thumbAlignment.value === "overflow" || !f.value ? 0 : EE(f.value, u.value, a.direction.value)), v = oc();
    return Ce(() => {
      n.thumbElements.value.push(o.value);
    }), nt(() => {
      const m = n.thumbElements.value.findIndex((g) => g === o.value) ?? -1;
      n.thumbElements.value.splice(m, 1);
    }), (m, g) => (h(), x(l(s), null, {
      default: y(() => [N(l(X), A(m.$attrs, {
        ref: l(r),
        role: "slider",
        tabindex: l(n).disabled.value ? void 0 : 0,
        "aria-label": m.$attrs["aria-label"] || d.value,
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "data-orientation": l(n).orientation.value,
        "aria-valuenow": i.value,
        "aria-valuemin": l(n).min.value,
        "aria-valuemax": l(n).max.value,
        "aria-orientation": l(n).orientation.value,
        "as-child": m.asChild,
        as: m.as,
        style: {
          transform: "var(--reka-slider-thumb-transform)",
          position: "absolute",
          [l(a).startEdge.value]: `calc(${u.value}% + ${p.value}px)`,
          display: !l(v) && i.value === void 0 ? "none" : void 0
        },
        onFocus: g[0] || (g[0] = () => {
          l(n).valueIndexToChangeRef.value = m.index;
        })
      }), {
        default: y(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "tabindex",
        "aria-label",
        "data-disabled",
        "data-orientation",
        "aria-valuenow",
        "aria-valuemin",
        "aria-valuemax",
        "aria-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }));
  }
}), KE = GE, YE = /* @__PURE__ */ b({
  __name: "SliderThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { getItems: n } = st(), { forwardRef: a, currentElement: r } = j(), o = q(() => r.value ? n(!0).findIndex((s) => s.ref === r.value) : -1);
    return (s, i) => (h(), x(KE, A({ ref: l(a) }, t, { index: o.value }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["index"]));
  }
}), XE = YE, JE = /* @__PURE__ */ b({
  __name: "SliderTrack",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = Qr();
    return j(), (n, a) => (h(), x(l(X), {
      "as-child": n.asChild,
      as: n.as,
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), ZE = JE;
function He(e, t = "Assertion failed!") {
  if (!e)
    throw console.error(t), new Error(t);
}
function Jg(e, t = document) {
  if (!es) return null;
  if (t instanceof HTMLElement && t?.dataset?.panelGroupId === e) return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function Oi(e, t = document) {
  if (!es) return null;
  const n = t.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return n || null;
}
function Zg(e, t, n = document) {
  return es ? Fo(e, n).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === t) ?? null : null;
}
function Fo(e, t = document) {
  return es ? Array.from(t.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function QE(e, t, n, a = document) {
  const r = Oi(t, a), o = Fo(e, a), s = r ? o.indexOf(r) : -1, i = n[s]?.id ?? null, u = n[s + 1]?.id ?? null;
  return [i, u];
}
function Qg(e) {
  return e.type === "keydown";
}
function ey(e) {
  return e.type.startsWith("mouse");
}
function ty(e) {
  return e.type.startsWith("touch");
}
function Ii(e) {
  if (ey(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (ty(e)) {
    const t = e.touches[0];
    if (t && t.clientX && t.clientY) return {
      x: t.clientX,
      y: t.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function ny(e, t) {
  const n = e === "horizontal", { x: a, y: r } = Ii(t);
  return n ? a : r;
}
function eT(e, t, n, a, r) {
  const o = n === "horizontal", s = Oi(t, r);
  He(s);
  const i = s.getAttribute("data-panel-group-id");
  He(i);
  const { initialCursorPosition: u } = a, d = ny(n, e), c = Jg(i, r);
  He(c);
  const f = c.getBoundingClientRect(), p = o ? f.width : f.height;
  return (d - u) / p * 100;
}
function tT(e, t, n, a, r, o) {
  if (Qg(e)) {
    const s = n === "horizontal";
    let i = 0;
    e.shiftKey ? i = 100 : i = r ?? 10;
    let u = 0;
    switch (e.key) {
      case "ArrowDown":
        u = s ? 0 : i;
        break;
      case "ArrowLeft":
        u = s ? -i : 0;
        break;
      case "ArrowRight":
        u = s ? i : 0;
        break;
      case "ArrowUp":
        u = s ? 0 : -i;
        break;
      case "End":
        u = 100;
        break;
      case "Home":
        u = -100;
        break;
    }
    return u;
  } else
    return a == null ? 0 : eT(e, t, n, a, o);
}
function nT({ layout: e, panelsArray: t, pivotIndices: n }) {
  let a = 0, r = 100, o = 0, s = 0;
  const i = n[0];
  He(i != null), t.forEach((f, p) => {
    const { constraints: v } = f, { maxSize: m = 100, minSize: g = 0 } = v;
    p === i ? (a = g, r = m) : (o += g, s += m);
  });
  const u = Math.min(r, 100 - o), d = Math.max(a, 100 - s), c = e[i];
  return {
    valueMax: u,
    valueMin: d,
    valueNow: c
  };
}
function aT({ panelDataArray: e }) {
  const t = Array.from({ length: e.length }), n = e.map((o) => o.constraints);
  let a = 0, r = 100;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    He(s);
    const { defaultSize: i } = s;
    i != null && (a++, t[o] = i, r -= i);
  }
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    He(s);
    const { defaultSize: i } = s;
    if (i != null) continue;
    const u = e.length - a, d = r / u;
    a++, t[o] = d, r -= d;
  }
  return t;
}
function uo(e, t, n) {
  t.forEach((a, r) => {
    const o = e[r];
    He(o);
    const { callbacks: s, constraints: i, id: u } = o, { collapsedSize: d = 0, collapsible: c } = i, f = n[u];
    if (f == null || a !== f) {
      n[u] = a;
      const { onCollapse: p, onExpand: v, onResize: m } = s;
      m && m(a, f), c && (p || v) && (v && (f == null || f === d) && a !== d && v(), p && (f == null || f !== d) && a === d && p());
    }
  });
}
function rT(e, t = 10) {
  let n = null;
  return (...r) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...r);
    }, t);
  };
}
const Zc = 10;
function No(e, t, n = Zc) {
  e = Number.parseFloat(e.toFixed(n)), t = Number.parseFloat(t.toFixed(n));
  const a = e - t;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function sn(e, t, n) {
  return No(e, t, n) === 0;
}
function Cr({ panelConstraints: e, panelIndex: t, size: n }) {
  const a = e[t];
  He(a != null);
  const { collapsedSize: r = 0, collapsible: o, maxSize: s = 100, minSize: i = 0 } = a;
  if (No(n, i) < 0) if (o) {
    const u = (r + i) / 2;
    No(n, u) < 0 ? n = r : n = i;
  } else n = i;
  return n = Math.min(s, n), n = Number.parseFloat(n.toFixed(Zc)), n;
}
function Vs(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function _o({ delta: e, layout: t, panelConstraints: n, pivotIndices: a, trigger: r }) {
  if (sn(e, 0)) return t;
  const o = [...t], [s, i] = a;
  He(s != null), He(i != null);
  let u = 0;
  if (r === "keyboard") {
    {
      const c = e < 0 ? i : s, f = n[c];
      if (He(f), f.collapsible) {
        const p = t[c];
        He(p != null);
        const v = n[c];
        He(v);
        const { collapsedSize: m = 0, minSize: g = 0 } = v;
        if (sn(p, m)) {
          const w = g - p;
          No(w, Math.abs(e)) > 0 && (e = e < 0 ? 0 - w : w);
        }
      }
    }
    {
      const c = e < 0 ? s : i, f = n[c];
      He(f);
      const { collapsible: p } = f;
      if (p) {
        const v = t[c];
        He(v != null);
        const m = n[c];
        He(m);
        const { collapsedSize: g = 0, minSize: w = 0 } = m;
        if (sn(v, w)) {
          const C = v - g;
          No(C, Math.abs(e)) > 0 && (e = e < 0 ? 0 - C : C);
        }
      }
    }
  }
  {
    const c = e < 0 ? 1 : -1;
    let f = e < 0 ? i : s, p = 0;
    for (; ; ) {
      const m = t[f];
      He(m != null);
      const w = Cr({
        panelConstraints: n,
        panelIndex: f,
        size: 100
      }) - m;
      if (p += w, f += c, f < 0 || f >= n.length) break;
    }
    const v = Math.min(Math.abs(e), Math.abs(p));
    e = e < 0 ? 0 - v : v;
  }
  {
    let f = e < 0 ? s : i;
    for (; f >= 0 && f < n.length; ) {
      const p = Math.abs(e) - Math.abs(u), v = t[f];
      He(v != null);
      const m = v - p, g = Cr({
        panelConstraints: n,
        panelIndex: f,
        size: m
      });
      if (!sn(v, g) && (u += v - g, o[f] = g, u.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? f-- : f++;
    }
  }
  if (sn(u, 0)) return t;
  {
    const c = e < 0 ? i : s, f = t[c];
    He(f != null);
    const p = f + u, v = Cr({
      panelConstraints: n,
      panelIndex: c,
      size: p
    });
    if (o[c] = v, !sn(v, p)) {
      let m = p - v, w = e < 0 ? i : s;
      for (; w >= 0 && w < n.length; ) {
        const C = o[w];
        He(C != null);
        const S = C + m, $ = Cr({
          panelConstraints: n,
          panelIndex: w,
          size: S
        });
        if (sn(C, $) || (m -= $ - C, o[w] = $), sn(m, 0)) break;
        e > 0 ? w-- : w++;
      }
    }
  }
  const d = o.reduce((c, f) => f + c, 0);
  return sn(d, 100) ? o : t;
}
function ay(e, t, n) {
  const a = Zg(e, t, n);
  return a != null ? [a, a + 1] : [-1, -1];
}
function oT(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function sT(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: ov(e),
    b: ov(t)
  };
  let a;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), a = e;
  He(a);
  const r = {
    a: rv(av(n.a)),
    b: rv(av(n.b))
  };
  if (r.a === r.b) {
    const o = a.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let i = o.length;
    for (; i--; ) {
      const u = o[i];
      if (u === s.a) return 1;
      if (u === s.b) return -1;
    }
  }
  return Math.sign(r.a - r.b);
}
const lT = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function iT(e) {
  const t = getComputedStyle(ry(e)).display;
  return t === "flex" || t === "inline-flex";
}
function uT(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || iT(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || lT.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function av(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (He(n), uT(n)) return n;
  }
  return null;
}
function rv(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function ov(e) {
  const t = [];
  for (; e; )
    t.push(e), e = ry(e);
  return t;
}
function ry(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
const oy = 1, sy = 2, ly = 4, iy = 8;
function dT() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const cT = dT() === "coarse", Ea = [];
let Ri = !1;
const $a = /* @__PURE__ */ new Map(), Vi = /* @__PURE__ */ new Map(), Lo = /* @__PURE__ */ new Set();
function fT(e, t, n, a, r, o) {
  const { ownerDocument: s } = t, i = {
    direction: n,
    element: t,
    hitAreaMargins: a,
    nonce: r,
    setResizeHandlerState: o
  }, u = $a.get(s) ?? 0;
  return $a.set(s, u + 1), Lo.add(i), Tl(), function() {
    Vi.delete(e), Lo.delete(i);
    const c = $a.get(s) ?? 1;
    $a.set(s, c - 1), Tl(), dy(), c === 1 && $a.delete(s);
  };
}
function Fs(e) {
  const { target: t } = e, { x: n, y: a } = Ii(e);
  Ri = !0, Qc({
    target: t,
    x: n,
    y: a
  }), Tl(), Ea.length > 0 && (ef("down", e), e.preventDefault());
}
function ya(e) {
  const { x: t, y: n } = Ii(e);
  if (!Ri) {
    const { target: a } = e;
    Qc({
      target: a,
      x: t,
      y: n
    });
  }
  ef("move", e), uy(), Ea.length > 0 && e.preventDefault();
}
function ba(e) {
  const { target: t } = e, { x: n, y: a } = Ii(e);
  Vi.clear(), Ri = !1, Ea.length > 0 && e.preventDefault(), ef("up", e), Qc({
    target: t,
    x: n,
    y: a
  }), uy(), Tl();
}
function Qc({ target: e, x: t, y: n }) {
  Ea.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), Lo.forEach((r) => {
    const { element: o, hitAreaMargins: s } = r, i = o.getBoundingClientRect(), { bottom: u, left: d, right: c, top: f } = i, p = cT ? s.coarse : s.fine;
    if (t >= d - p && t <= c + p && n >= f - p && n <= u + p) {
      if (a !== null && o !== a && !o.contains(a) && !a.contains(o) && sT(a, o) > 0) {
        let m = a, g = !1;
        for (; m && !m.contains(o); ) {
          if (oT(m.getBoundingClientRect(), i)) {
            g = !0;
            break;
          }
          m = m.parentElement;
        }
        if (g) return;
      }
      Ea.push(r);
    }
  });
}
function qu(e, t) {
  Vi.set(e, t);
}
function uy() {
  let e = !1, t = !1, n;
  Ea.forEach((r) => {
    const { direction: o, nonce: s } = r;
    o.value === "horizontal" ? e = !0 : t = !0, n = s.value;
  });
  let a = 0;
  Vi.forEach((r) => {
    a |= r;
  }), e && t ? Eu("intersection", a, n) : e ? Eu("horizontal", a, n) : t ? Eu("vertical", a, n) : dy();
}
function Tl() {
  $a.forEach((e, t) => {
    const { body: n } = t;
    n.removeEventListener("contextmenu", ba), n.removeEventListener("mousedown", Fs), n.removeEventListener("mouseleave", ya), n.removeEventListener("mousemove", ya), n.removeEventListener("touchmove", ya), n.removeEventListener("touchstart", Fs);
  }), window.removeEventListener("mouseup", ba), window.removeEventListener("touchcancel", ba), window.removeEventListener("touchend", ba), Lo.size > 0 && (Ri ? (Ea.length > 0 && $a.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("contextmenu", ba), n.addEventListener("mouseleave", ya), n.addEventListener("mousemove", ya), n.addEventListener("touchmove", ya, { passive: !1 }));
  }), window.addEventListener("mouseup", ba), window.addEventListener("touchcancel", ba), window.addEventListener("touchend", ba)) : $a.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("mousedown", Fs), n.addEventListener("mousemove", ya), n.addEventListener("touchmove", ya, { passive: !1 }), n.addEventListener("touchstart", Fs));
  }));
}
function ef(e, t) {
  Lo.forEach((n) => {
    const { setResizeHandlerState: a } = n, r = Ea.includes(n);
    a(e, r, t);
  });
}
let xd = null, Ba = null;
function pT(e, t) {
  if (t) {
    const n = (t & oy) !== 0, a = (t & sy) !== 0, r = (t & ly) !== 0, o = (t & iy) !== 0;
    if (n) return r ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (a) return r ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (r) return "s-resize";
    if (o) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function dy() {
  Ba !== null && (document.head.removeChild(Ba), xd = null, Ba = null);
}
function Eu(e, t, n) {
  const a = pT(e, t);
  xd !== a && (xd = a, Ba === null && (Ba = document.createElement("style"), n && (Ba.nonce = n), document.head.appendChild(Ba)), Ba.innerHTML = `*{cursor: ${a}!important;}`);
}
function vT({ defaultSize: e, dragState: t, layout: n, panelData: a, panelIndex: r, precision: o = 3 }) {
  const s = n[r];
  let i;
  return s == null ? i = e !== void 0 ? e.toPrecision(o) : "1" : a.length === 1 ? i = "1" : i = s.toPrecision(o), {
    flexBasis: 0,
    flexGrow: i,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: t !== null ? "none" : void 0
  };
}
function mT({ layout: e, panelConstraints: t }) {
  const n = [...e], a = n.reduce((o, s) => o + s, 0);
  if (n.length !== t.length) throw new Error(`Invalid ${t.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!sn(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${n.map((o) => `${o}%`).join(", ")}. Layout normalization will be applied.`);
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      He(s != null);
      const i = 100 / a * s;
      n[o] = i;
    }
  }
  let r = 0;
  for (let o = 0; o < t.length; o++) {
    const s = n[o];
    He(s != null);
    const i = Cr({
      panelConstraints: t,
      panelIndex: o,
      size: s
    });
    s !== i && (r += s - i, n[o] = i);
  }
  if (!sn(r, 0)) for (let o = 0; o < t.length; o++) {
    const s = n[o];
    He(s != null);
    const i = s + r, u = Cr({
      panelConstraints: t,
      panelIndex: o,
      size: i
    });
    if (s !== u && (r -= u - s, n[o] = u, sn(r, 0)))
      break;
  }
  return n;
}
function hT({ eagerValuesRef: e, groupId: t, layout: n, panelDataArray: a, panelGroupElement: r, setLayout: o }) {
  Ae((s) => {
    const i = r.value;
    if (!i) return;
    const u = Fo(t, i);
    for (let d = 0; d < a.length - 1; d++) {
      const { valueMax: c, valueMin: f, valueNow: p } = nT({
        layout: n.value,
        panelsArray: a,
        pivotIndices: [d, d + 1]
      }), v = u[d];
      if (v != null) {
        const m = a[d];
        He(m), v.setAttribute("aria-controls", m.id), v.setAttribute("aria-valuemax", `${Math.round(c)}`), v.setAttribute("aria-valuemin", `${Math.round(f)}`), v.setAttribute("aria-valuenow", p != null ? `${Math.round(p)}` : "");
      }
    }
    s(() => {
      u.forEach((d) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    });
  }), Ae((s) => {
    const i = r.value;
    if (!i) return;
    const u = e.value;
    He(u);
    const { panelDataArray: d } = u, c = Jg(t, i);
    He(c != null, `No group found for id "${t}"`);
    const f = Fo(t, i);
    He(f);
    const p = f.map((v) => {
      const m = v.getAttribute("data-panel-resize-handle-id");
      He(m);
      const [g, w] = QE(t, m, d, i);
      if (g == null || w == null) return () => {
      };
      const C = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const $ = d.findIndex((k) => k.id === g);
              if ($ >= 0) {
                const k = d[$];
                He(k);
                const B = n.value[$], { collapsedSize: D = 0, collapsible: P, minSize: E = 0 } = k.constraints;
                if (B != null && P) {
                  const T = _o({
                    delta: sn(B, D) ? E - D : D - B,
                    layout: n.value,
                    panelConstraints: d.map((M) => M.constraints),
                    pivotIndices: ay(t, m, i),
                    trigger: "keyboard"
                  });
                  n.value !== T && o(T);
                }
              }
              break;
            }
          }
      };
      return v.addEventListener("keydown", C), () => {
        v.removeEventListener("keydown", C);
      };
    });
    s(() => {
      p.forEach((v) => v());
    });
  });
}
function sv(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function cy(e) {
  return `reka:${e}`;
}
function fy(e) {
  return e.map((t) => {
    const { constraints: n, id: a, idIsFromProps: r, order: o } = t;
    return r ? a : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function py(e, t) {
  try {
    const n = cy(e), a = t.getItem(n);
    if (a) {
      const r = JSON.parse(a);
      if (typeof r == "object" && r != null) return r;
    }
  } catch {
  }
  return null;
}
function gT(e, t, n) {
  const a = py(e, n) ?? {}, r = fy(t);
  return a[r] ?? null;
}
function yT(e, t, n, a, r) {
  const o = cy(e), s = fy(t), i = py(e, r) ?? {};
  i[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: a
  };
  try {
    r.setItem(o, JSON.stringify(i));
  } catch (u) {
    console.error(u);
  }
}
const bT = 100, wo = {
  getItem: (e) => (sv(wo), wo.getItem(e)),
  setItem: (e, t) => {
    sv(wo), wo.setItem(e, t);
  }
}, [vy, _T] = Se("PanelGroup");
var wT = /* @__PURE__ */ b({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => wo
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = {}, { direction: o } = Me(n), s = Ge(n.id, "reka-splitter-group"), i = gt(), { forwardRef: u, currentElement: d } = j(), c = O(null), f = O([]), p = O({}), v = O(/* @__PURE__ */ new Map()), m = O(0), g = q(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: c.value,
      id: s,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), w = O({
      layout: f.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), C = (H) => f.value = H;
    hT({
      eagerValuesRef: w,
      groupId: s,
      layout: f,
      panelDataArray: w.value.panelDataArray,
      setLayout: C,
      panelGroupElement: d
    }), Ae(() => {
      const { panelDataArray: H } = w.value, { autoSaveId: U } = n;
      if (U) {
        if (f.value.length === 0 || f.value.length !== H.length) return;
        let se = r[U];
        se || (se = rT(yT, bT), r[U] = se);
        const ee = [...H], de = new Map(v.value);
        se(U, ee, de, f.value, n.storage);
      }
    });
    function S(H, U) {
      const { panelDataArray: se } = w.value, ee = Q(se, H);
      return vT({
        defaultSize: U,
        dragState: c.value,
        layout: f.value,
        panelData: se,
        panelIndex: ee
      });
    }
    function $(H) {
      const { panelDataArray: U } = w.value;
      U.push(H), U.sort((se, ee) => {
        const de = se.order, fe = ee.order;
        return de == null && fe == null ? 0 : de == null ? -1 : fe == null ? 1 : de - fe;
      }), w.value.panelDataArrayChanged = !0;
    }
    me(() => w.value.panelDataArrayChanged, () => {
      if (w.value.panelDataArrayChanged) {
        w.value.panelDataArrayChanged = !1;
        const { autoSaveId: H, storage: U } = g.value, { layout: se, panelDataArray: ee } = w.value;
        let de = null;
        if (H) {
          const _e = gT(H, ee, U);
          _e && (v.value = new Map(Object.entries(_e.expandToSizes)), de = _e.layout);
        }
        de === null && (de = aT({ panelDataArray: ee }));
        const fe = mT({
          layout: de,
          panelConstraints: ee.map((_e) => _e.constraints)
        });
        C0(se, fe) || (C(fe), w.value.layout = fe, a("layout", fe), uo(ee, fe, p.value));
      }
    });
    function k(H) {
      return function(se) {
        se.preventDefault();
        const ee = d.value;
        if (!ee) return () => null;
        const { direction: de, dragState: fe, id: _e, keyboardResizeBy: ye } = g.value, { layout: Te, panelDataArray: ce } = w.value, { initialLayout: V } = fe ?? {}, te = ay(_e, H, ee);
        let z = tT(se, H, de, fe, ye, ee);
        if (z === 0) return;
        const re = de === "horizontal";
        i.value === "rtl" && re && (z = -z);
        const ie = ce.map((xe) => xe.constraints), L = _o({
          delta: z,
          layout: V ?? Te,
          panelConstraints: ie,
          pivotIndices: te,
          trigger: Qg(se) ? "keyboard" : "mouse-or-touch"
        }), be = !Vs(Te, L);
        (ey(se) || ty(se)) && m.value !== z && (m.value = z, be ? qu(H, 0) : re ? qu(H, z < 0 ? oy : sy) : qu(H, z < 0 ? ly : iy)), be && (C(L), w.value.layout = L, a("layout", L), uo(ce, L, p.value));
      };
    }
    function B(H, U) {
      const { layout: se, panelDataArray: ee } = w.value, de = ee.map((V) => V.constraints), { panelSize: fe, pivotIndices: _e } = G(ee, H, se);
      He(fe != null);
      const Te = Q(ee, H) === ee.length - 1 ? fe - U : U - fe, ce = _o({
        delta: Te,
        layout: se,
        panelConstraints: de,
        pivotIndices: _e,
        trigger: "imperative-api"
      });
      Vs(se, ce) || (C(ce), w.value.layout = ce, a("layout", ce), uo(ee, ce, p.value));
    }
    function D(H, U) {
      const { layout: se, panelDataArray: ee } = w.value, de = Q(ee, H);
      ee[de] = H, w.value.panelDataArrayChanged = !0;
      const { collapsedSize: fe = 0, collapsible: _e } = U, { collapsedSize: ye = 0, collapsible: Te, maxSize: ce = 100, minSize: V = 0 } = H.constraints, { panelSize: te } = G(ee, H, se);
      te !== null && (_e && Te && te === fe ? fe !== ye && B(H, ye) : te < V ? B(H, V) : te > ce && B(H, ce));
    }
    function P(H, U) {
      const { direction: se } = g.value, { layout: ee } = w.value;
      if (!d.value) return;
      const de = Oi(H, d.value);
      He(de);
      const fe = ny(se, U);
      c.value = {
        dragHandleId: H,
        dragHandleRect: de.getBoundingClientRect(),
        initialCursorPosition: fe,
        initialLayout: ee
      };
    }
    function E() {
      c.value = null;
    }
    function T(H) {
      const { panelDataArray: U } = w.value, se = Q(U, H);
      se >= 0 && (U.splice(se, 1), delete p.value[H.id], w.value.panelDataArrayChanged = !0);
    }
    function M(H) {
      const { layout: U, panelDataArray: se } = w.value;
      if (H.constraints.collapsible) {
        const ee = se.map((ye) => ye.constraints), { collapsedSize: de = 0, panelSize: fe, pivotIndices: _e } = G(se, H, U);
        if (He(fe != null, `Panel size not found for panel "${H.id}"`), fe !== de) {
          v.value.set(H.id, fe);
          const Te = Q(se, H) === se.length - 1 ? fe - de : de - fe, ce = _o({
            delta: Te,
            layout: U,
            panelConstraints: ee,
            pivotIndices: _e,
            trigger: "imperative-api"
          });
          Vs(U, ce) || (C(ce), w.value.layout = ce, a("layout", ce), uo(se, ce, p.value));
        }
      }
    }
    function I(H) {
      const { layout: U, panelDataArray: se } = w.value;
      if (H.constraints.collapsible) {
        const ee = se.map((Te) => Te.constraints), { collapsedSize: de = 0, panelSize: fe, minSize: _e = 0, pivotIndices: ye } = G(se, H, U);
        if (fe === de) {
          const Te = v.value.get(H.id), ce = Te != null && Te >= _e ? Te : _e, te = Q(se, H) === se.length - 1 ? fe - ce : ce - fe, z = _o({
            delta: te,
            layout: U,
            panelConstraints: ee,
            pivotIndices: ye,
            trigger: "imperative-api"
          });
          Vs(U, z) || (C(z), w.value.layout = z, a("layout", z), uo(se, z, p.value));
        }
      }
    }
    function F(H) {
      const { layout: U, panelDataArray: se } = w.value, { panelSize: ee } = G(se, H, U);
      return He(ee != null, `Panel size not found for panel "${H.id}"`), ee;
    }
    function J(H) {
      const { layout: U, panelDataArray: se } = w.value, { collapsedSize: ee = 0, collapsible: de, panelSize: fe } = G(se, H, U);
      return de ? fe === void 0 ? H.constraints.defaultSize === H.constraints.collapsedSize : fe === ee : !1;
    }
    function ne(H) {
      const { layout: U, panelDataArray: se } = w.value, { collapsedSize: ee = 0, collapsible: de, panelSize: fe } = G(se, H, U);
      return He(fe != null, `Panel size not found for panel "${H.id}"`), !de || fe > ee;
    }
    _T({
      direction: o,
      dragState: c.value,
      groupId: s,
      reevaluatePanelConstraints: D,
      registerPanel: $,
      registerResizeHandle: k,
      resizePanel: B,
      startDragging: P,
      stopDragging: E,
      unregisterPanel: T,
      panelGroupElement: d,
      collapsePanel: M,
      expandPanel: I,
      isPanelCollapsed: J,
      isPanelExpanded: ne,
      getPanelSize: F,
      getPanelStyle: S
    });
    function Q(H, U) {
      return H.findIndex((se) => se === U || se.id === U.id);
    }
    function G(H, U, se) {
      const ee = Q(H, U), fe = ee === H.length - 1 ? [ee - 1, ee] : [ee, ee + 1], _e = se[ee];
      return {
        ...U.constraints,
        panelSize: _e,
        pivotIndices: fe
      };
    }
    return (H, U) => (h(), x(l(X), {
      ref: l(u),
      as: H.as,
      "as-child": H.asChild,
      style: dt({
        display: "flex",
        flexDirection: l(o) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": l(o),
      "data-panel-group-id": l(s)
    }, {
      default: y(() => [_(H.$slots, "default", { layout: f.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), xT = wT, CT = /* @__PURE__ */ b({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, o = vy();
    if (o === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: s, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: f, groupId: p, reevaluatePanelConstraints: v, registerPanel: m, unregisterPanel: g } = o, w = Ge(a.id, "reka-splitter-panel"), C = q(() => ({
      callbacks: {
        onCollapse: () => r("collapse"),
        onExpand: () => r("expand"),
        onResize: (...E) => r("resize", ...E)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(Zc)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: w,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    me(() => C.value.constraints, (E, T) => {
      (T.collapsedSize !== E.collapsedSize || T.collapsible !== E.collapsible || T.maxSize !== E.maxSize || T.minSize !== E.minSize) && v(C.value, T);
    }, { deep: !0 }), Ce(() => {
      m(C.value);
    }), nt(() => {
      g(C.value);
    });
    const S = q(() => d(C.value, a.defaultSize)), $ = q(() => c(C.value)), k = q(() => !$.value);
    function B() {
      s(C.value);
    }
    function D() {
      i(C.value);
    }
    function P(E) {
      f(C.value, E);
    }
    return t({
      collapse: B,
      expand: D,
      getSize() {
        return u(C.value);
      },
      resize: P,
      isCollapsed: $,
      isExpanded: k
    }), (E, T) => (h(), x(l(X), {
      id: l(w),
      style: dt(S.value),
      as: E.as,
      "as-child": E.asChild,
      "data-panel": "",
      "data-panel-collapsible": E.collapsible || void 0,
      "data-panel-group-id": l(p),
      "data-panel-id": l(w),
      "data-panel-size": Number.parseFloat(`${S.value.flexGrow}`).toFixed(1),
      "data-state": E.collapsible ? $.value ? "collapsed" : "expanded" : void 0
    }, {
      default: y(() => [_(E.$slots, "default", {
        isCollapsed: $.value,
        isExpanded: k.value,
        expand: D,
        collapse: B,
        resize: P
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), gH = CT;
function ST({ disabled: e, handleId: t, resizeHandler: n, panelGroupElement: a }) {
  Ae((r) => {
    const o = a.value;
    if (e.value || n.value === null || o === null) return;
    const s = Oi(t, o);
    if (s == null) return;
    const i = (u) => {
      if (!u.defaultPrevented)
        switch (u.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            u.preventDefault(), n.value?.(u);
            break;
          }
          case "F6": {
            u.preventDefault();
            const d = s.getAttribute("data-panel-group-id");
            He(d);
            const c = Fo(d, o), f = Zg(d, t, o);
            He(f !== null);
            const p = u.shiftKey ? f > 0 ? f - 1 : c.length - 1 : f + 1 < c.length ? f + 1 : 0;
            c[p].focus();
            break;
          }
        }
    };
    s.addEventListener("keydown", i), r(() => {
      s.removeEventListener("keydown", i);
    });
  });
}
var $T = /* @__PURE__ */ b({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), { disabled: s } = Me(n), i = vy();
    if (i === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: u, groupId: d, registerResizeHandle: c, startDragging: f, stopDragging: p, panelGroupElement: v } = i, m = Ge(n.id, "reka-splitter-resize-handle"), g = O("inactive"), w = O(!1), C = O(null), { nonce: S } = Me(n), $ = ki(S);
    return me(s, () => {
      es && (s.value ? C.value = null : C.value = c(m));
    }, { immediate: !0 }), Ae((k) => {
      if (s.value || C.value === null) return;
      const B = o.value;
      if (!B) return;
      He(B);
      const D = (P, E, T) => {
        if (E) switch (P) {
          case "down": {
            g.value = "drag", f(m, T), a("dragging", !0);
            break;
          }
          case "move": {
            g.value !== "drag" && (g.value = "hover"), C.value?.(T);
            break;
          }
          case "up": {
            g.value = "hover", p(), a("dragging", !1);
            break;
          }
        }
        else g.value = "inactive";
      };
      k(fT(m, B, u, {
        coarse: n.hitAreaMargins?.coarse ?? 15,
        fine: n.hitAreaMargins?.fine ?? 5
      }, $, D));
    }), ST({
      disabled: s,
      resizeHandler: C,
      handleId: m,
      panelGroupElement: v
    }), (k, B) => (h(), x(l(X), {
      id: l(m),
      ref: l(r),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: k.as,
      "as-child": k.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: k.tabindex,
      "data-state": g.value,
      "data-disabled": l(s) ? "" : void 0,
      "data-orientation": l(u),
      "data-panel-group-id": l(d),
      "data-resize-handle-active": g.value === "drag" ? "pointer" : w.value ? "keyboard" : void 0,
      "data-resize-handle-state": g.value,
      "data-panel-resize-handle-enabled": !l(s),
      "data-panel-resize-handle-id": l(m),
      onBlur: B[0] || (B[0] = (D) => w.value = !1),
      onFocus: B[1] || (B[1] = (D) => w.value = !1)
    }, {
      default: y(() => [_(k.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), BT = $T;
const kT = {
  "aria-live": "polite",
  "aria-atomic": "true",
  role: "status",
  style: {
    transform: "translateX(-100%)",
    position: "absolute",
    pointerEvents: "none",
    opacity: 0,
    margin: 0
  }
}, [tf, PT] = Se("StepperRoot");
var DT = /* @__PURE__ */ b({
  __name: "StepperRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: 1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    modelValue: {
      type: Number,
      required: !1
    },
    linear: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { dir: o, orientation: s, linear: i } = Me(a), u = gt(o), d = O(/* @__PURE__ */ new Set()), c = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue,
      passive: a.modelValue === void 0
    }), f = q(() => Array.from(d.value)), p = q(() => c.value === 1), v = q(() => c.value === f.value.length), m = q(() => d.value.size);
    function g(E) {
      E > m.value || E < 1 || d.value.size && f.value[E] && f.value[E].getAttribute("disabled") || i.value && E > (c.value ?? 1) + 1 || (c.value = E);
    }
    function w() {
      g((c.value ?? 1) + 1);
    }
    function C() {
      g((c.value ?? 1) - 1);
    }
    function S() {
      return (c.value ?? 1) < m.value;
    }
    function $() {
      return (c.value ?? 1) > 1;
    }
    const k = O(null), B = O(null), D = q(() => k.value ? k.value.getAttribute("disabled") === "" : !0), P = q(() => B.value ? B.value.getAttribute("disabled") === "" : !0);
    return me(c, async () => {
      await Pe(() => {
        k.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, B.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), me(f, async () => {
      await Pe(() => {
        k.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, B.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), PT({
      modelValue: c,
      changeModelValue: (E) => {
        c.value = E;
      },
      orientation: s,
      dir: u,
      linear: i,
      totalStepperItems: d
    }), t({
      goToStep: g,
      nextStep: w,
      prevStep: C,
      modelValue: c,
      totalSteps: m,
      isNextDisabled: D,
      isPrevDisabled: P,
      isFirstStep: p,
      isLastStep: v,
      hasNext: S,
      hasPrev: $
    }), j(), (E, T) => (h(), x(l(X), {
      role: "group",
      "aria-label": "progress",
      as: E.as,
      "as-child": E.asChild,
      "data-linear": l(i) ? "" : void 0,
      "data-orientation": E.orientation
    }, {
      default: y(() => [_(E.$slots, "default", {
        modelValue: l(c),
        totalSteps: d.value.size,
        isNextDisabled: D.value,
        isPrevDisabled: P.value,
        isFirstStep: p.value,
        isLastStep: v.value,
        goToStep: g,
        nextStep: w,
        prevStep: C,
        hasNext: S,
        hasPrev: $
      }), we("div", kT, " Step " + Ne(l(c)) + " of " + Ne(d.value.size), 1)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-linear",
      "data-orientation"
    ]));
  }
}), MT = DT;
const [hs, qT] = Se("StepperItem");
var ET = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    completed: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { disabled: n, step: a, completed: r } = Me(t), { forwardRef: o } = j(), s = tf(), i = Ge(void 0, "reka-stepper-item-title"), u = Ge(void 0, "reka-stepper-item-description"), d = q(() => r.value ? "completed" : s.modelValue.value === a.value ? "active" : s.modelValue.value > a.value ? "completed" : "inactive"), c = q(() => n.value ? !1 : s.linear.value ? a.value <= s.modelValue.value || a.value === s.modelValue.value + 1 : !0);
    return qT({
      titleId: i,
      descriptionId: u,
      state: d,
      disabled: n,
      step: a,
      isFocusable: c
    }), (f, p) => (h(), x(l(X), {
      ref: l(o),
      as: f.as,
      "as-child": f.asChild,
      "aria-current": d.value === "active" ? "true" : void 0,
      "data-state": d.value,
      disabled: l(n) || !c.value ? "" : void 0,
      "data-disabled": l(n) || !c.value ? "" : void 0,
      "data-orientation": l(s).orientation.value
    }, {
      default: y(() => [_(f.$slots, "default", { state: d.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-current",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), TT = ET, AT = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = hs();
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).descriptionId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), OT = AT, IT = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = hs();
    return j(), (a, r) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(a.$slots, "default", { step: l(n).step.value }, () => [Re(" Step " + Ne(l(n).step.value), 1)])]),
      _: 3
    }, 16));
  }
}), RT = IT, VT = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {
      type: String,
      required: !1
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = tf(), a = hs();
    return j(), (r, o) => (h(), x(l(Xc), A(t, {
      decorative: "",
      orientation: l(n).orientation.value,
      "data-state": l(a).state.value
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["orientation", "data-state"]));
  }
}), FT = VT, NT = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h4"
    }
  },
  setup(e) {
    const t = e, n = hs();
    return j(), (a, r) => (h(), x(l(X), A(t, { id: l(n).titleId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), LT = NT, zT = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = tf(), n = hs(), a = is(), r = q(() => Array.from(t.totalStepperItems.value));
    function o(d) {
      if (!n.disabled.value) {
        if (t.linear.value) {
          if ((n.step.value <= t.modelValue.value || n.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {
            t.changeModelValue(n.step.value);
            return;
          }
        } else if (d.ctrlKey === !1) {
          t.changeModelValue(n.step.value);
          return;
        }
        d.preventDefault();
      }
    }
    function s(d) {
      d.preventDefault(), !n.disabled.value && ((d.key === a.ENTER || d.key === a.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(n.step.value), [
        a.ARROW_LEFT,
        a.ARROW_RIGHT,
        a.ARROW_UP,
        a.ARROW_DOWN
      ].includes(d.key) && rr(d, ot(), void 0, {
        itemsArray: r.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: t.orientation.value,
        dir: t.dir.value
      }));
    }
    const { forwardRef: i, currentElement: u } = j();
    return Ce(() => {
      t.totalStepperItems.value.add(u.value);
    }), nt(() => {
      t.totalStepperItems.value.delete(u.value);
    }), (d, c) => (h(), x(l(X), {
      ref: l(i),
      type: d.as === "button" ? "button" : void 0,
      as: d.as,
      "as-child": d.asChild,
      "data-state": l(n).state.value,
      disabled: l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-disabled": l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      tabindex: l(n).isFocusable.value ? 0 : -1,
      "aria-describedby": l(n).descriptionId,
      "aria-labelledby": l(n).titleId,
      onMousedown: Ye(o, ["left"]),
      onKeydown: Je(s, [
        "enter",
        "space",
        "left",
        "right",
        "up",
        "down"
      ])
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation",
      "tabindex",
      "aria-describedby",
      "aria-labelledby"
    ]));
  }
}), HT = zT;
const [UT, jT] = Se("SwitchRoot");
var WT = /* @__PURE__ */ b({
  __name: "SwitchRoot",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    value: {
      type: String,
      required: !1,
      default: "on"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = Me(n), o = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function s() {
      r.value || (o.value = !o.value);
    }
    const { forwardRef: i, currentElement: u } = j(), d = On(u), c = q(() => n.id && u.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return jT({
      modelValue: o,
      toggleCheck: s,
      disabled: r
    }), (f, p) => (h(), x(l(X), A(f.$attrs, {
      id: f.id,
      ref: l(i),
      role: "switch",
      type: f.as === "button" ? "button" : void 0,
      value: f.value,
      "aria-label": f.$attrs["aria-label"] || c.value,
      "aria-checked": l(o),
      "aria-required": f.required,
      "data-state": l(o) ? "checked" : "unchecked",
      "data-disabled": l(r) ? "" : void 0,
      "as-child": f.asChild,
      as: f.as,
      disabled: l(r),
      onClick: s,
      onKeydown: Je(Ye(s, ["prevent"]), ["enter"])
    }), {
      default: y(() => [_(f.$slots, "default", { modelValue: l(o) }), l(d) && f.name ? (h(), x(l(In), {
        key: 0,
        type: "checkbox",
        name: f.name,
        disabled: l(r),
        required: f.required,
        value: f.value,
        checked: !!l(o)
      }, null, 8, [
        "name",
        "disabled",
        "required",
        "value",
        "checked"
      ])) : qe("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "value",
      "aria-label",
      "aria-checked",
      "aria-required",
      "data-state",
      "data-disabled",
      "as-child",
      "as",
      "disabled",
      "onKeydown"
    ]));
  }
}), GT = WT, KT = /* @__PURE__ */ b({
  __name: "SwitchThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = UT();
    return j(), (n, a) => (h(), x(l(X), {
      "data-state": l(t).modelValue?.value ? "checked" : "unchecked",
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "as-child": n.asChild,
      as: n.as
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "data-disabled",
      "as-child",
      "as"
    ]));
  }
}), YT = KT;
const [nf, XT] = Se("TabsRoot");
var JT = /* @__PURE__ */ b({
  __name: "TabsRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    activationMode: {
      type: String,
      required: !1,
      default: "automatic"
    },
    modelValue: {
      type: null,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { orientation: r, unmountOnHide: o, dir: s } = Me(n), i = gt(s);
    j();
    const u = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), d = O();
    return XT({
      modelValue: u,
      changeModelValue: (c) => {
        u.value = c;
      },
      orientation: r,
      dir: i,
      unmountOnHide: o,
      activationMode: n.activationMode,
      baseId: Ge(void 0, "reka-tabs"),
      tabsList: d
    }), (c, f) => (h(), x(l(X), {
      dir: l(i),
      "data-orientation": l(r),
      "as-child": c.asChild,
      as: c.as
    }, {
      default: y(() => [_(c.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, [
      "dir",
      "data-orientation",
      "as-child",
      "as"
    ]));
  }
}), ZT = JT;
function my(e, t) {
  return `${e}-trigger-${t}`;
}
function hy(e, t) {
  return `${e}-content-${t}`;
}
var QT = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = nf(), r = q(() => my(a.baseId, t.value)), o = q(() => hy(a.baseId, t.value)), s = q(() => t.value === a.modelValue.value), i = O(s.value);
    return Ce(() => {
      requestAnimationFrame(() => {
        i.value = !1;
      });
    }), (u, d) => (h(), x(l(Ct), {
      present: u.forceMount || s.value,
      "force-mount": ""
    }, {
      default: y(({ present: c }) => [N(l(X), {
        id: o.value,
        ref: l(n),
        "as-child": u.asChild,
        as: u.as,
        role: "tabpanel",
        "data-state": s.value ? "active" : "inactive",
        "data-orientation": l(a).orientation.value,
        "aria-labelledby": r.value,
        hidden: !c,
        tabindex: "0",
        style: dt({ animationDuration: i.value ? "0s" : void 0 })
      }, {
        default: y(() => [!l(a).unmountOnHide.value || c ? _(u.$slots, "default", { key: 0 }) : qe("v-if", !0)]),
        _: 2
      }, 1032, [
        "id",
        "as-child",
        "as",
        "data-state",
        "data-orientation",
        "aria-labelledby",
        "hidden",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), eA = QT, tA = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { loop: n } = Me(t), { forwardRef: a, currentElement: r } = j(), o = nf();
    return o.tabsList = r, (s, i) => (h(), x(l(cs), {
      "as-child": "",
      orientation: l(o).orientation.value,
      dir: l(o).dir.value,
      loop: l(n)
    }, {
      default: y(() => [N(l(X), {
        ref: l(a),
        role: "tablist",
        "as-child": s.asChild,
        as: s.as,
        "aria-orientation": l(o).orientation.value
      }, {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "aria-orientation"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), nA = tA, aA = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = nf(), r = q(() => my(a.baseId, t.value)), o = q(() => hy(a.baseId, t.value)), s = q(() => t.value === a.modelValue.value);
    return (i, u) => (h(), x(l(fs), {
      "as-child": "",
      focusable: !i.disabled,
      active: s.value
    }, {
      default: y(() => [N(l(X), {
        id: r.value,
        ref: l(n),
        role: "tab",
        type: i.as === "button" ? "button" : void 0,
        as: i.as,
        "as-child": i.asChild,
        "aria-selected": s.value ? "true" : "false",
        "aria-controls": o.value,
        "data-state": s.value ? "active" : "inactive",
        disabled: i.disabled,
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": l(a).orientation.value,
        onMousedown: u[0] || (u[0] = Ye((d) => {
          !i.disabled && d.ctrlKey === !1 ? l(a).changeModelValue(i.value) : d.preventDefault();
        }, ["left"])),
        onKeydown: u[1] || (u[1] = Je((d) => l(a).changeModelValue(i.value), ["enter", "space"])),
        onFocus: u[2] || (u[2] = () => {
          const d = l(a).activationMode !== "manual";
          !s.value && !i.disabled && d && l(a).changeModelValue(i.value);
        })
      }, {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as",
        "as-child",
        "aria-selected",
        "aria-controls",
        "data-state",
        "disabled",
        "data-disabled",
        "data-orientation"
      ])]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), rA = aA;
const [af, oA] = Se("TagsInputRoot");
var sA = /* @__PURE__ */ b({
  __name: "TagsInputRoot",
  props: {
    modelValue: {
      type: [Array, null],
      required: !1
    },
    defaultValue: {
      type: Array,
      required: !1,
      default: () => []
    },
    addOnPaste: {
      type: Boolean,
      required: !1
    },
    addOnTab: {
      type: Boolean,
      required: !1
    },
    addOnBlur: {
      type: Boolean,
      required: !1
    },
    duplicate: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    delimiter: {
      type: null,
      required: !1,
      default: ","
    },
    dir: {
      type: String,
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: 0
    },
    id: {
      type: String,
      required: !1
    },
    convertValue: {
      type: Function,
      required: !1
    },
    displayValue: {
      type: Function,
      required: !1,
      default: (e) => e.toString()
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "invalid",
    "addTag",
    "removeTag"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { addOnPaste: r, disabled: o, delimiter: s, max: i, id: u, dir: d, addOnBlur: c, addOnTab: f } = Me(n), p = gt(d), v = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: !0,
      deep: !0
    }), { forwardRef: m, currentElement: g } = j(), { focused: w } = Q0(g), C = On(g), { getItems: S, CollectionSlot: $ } = st({ isProvider: !0 }), k = O(), B = O(!1), D = q(() => Array.isArray(v.value) ? [...v.value] : []);
    function P(E) {
      if (E !== -1) {
        const T = S().filter((M) => M.ref.dataset.disabled !== "");
        v.value = v.value.filter((M, I) => I !== E), a("removeTag", T[E].value);
      }
    }
    return oA({
      modelValue: v,
      onAddValue: (E) => {
        const T = [...D.value], M = T.length > 0 && typeof T[0] == "object", I = T.length > 0 && typeof n.defaultValue[0] == "object";
        if ((M || I) && typeof n.convertValue != "function") throw new Error("You must provide a `convertValue` function when using objects as values.");
        const F = n.convertValue ? n.convertValue(E) : E;
        if (T.length >= i.value && i.value)
          return a("invalid", F), !1;
        if (n.duplicate)
          return v.value = [...T, F], a("addTag", F), !0;
        if (T.includes(F))
          B.value = !0;
        else return v.value = [...T, F], a("addTag", F), !0;
        return a("invalid", F), !1;
      },
      onRemoveValue: P,
      onInputKeydown: (E) => {
        const T = E.target, M = S().map((F) => F.ref).filter((F) => F.dataset.disabled !== "");
        if (!M.length) return;
        const I = M.at(-1);
        switch (E.key) {
          case "Delete":
          case "Backspace": {
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (k.value) {
              const F = M.findIndex((J) => J === k.value);
              P(F), k.value = k.value === I ? M.at(F - 1) : M.at(F + 1), E.preventDefault();
            } else E.key === "Backspace" && (k.value = I, E.preventDefault());
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const F = E.key === "ArrowRight" && p.value === "ltr" || E.key === "ArrowLeft" && p.value === "rtl", J = !F;
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (J && !k.value)
              k.value = I, E.preventDefault();
            else if (F && I && k.value === I)
              k.value = void 0, E.preventDefault();
            else if (k.value) {
              const ne = rr(E, k.value, void 0, {
                itemsArray: M,
                loop: !1,
                dir: p.value
              });
              ne && (k.value = ne), E.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            k.value && E.preventDefault();
            break;
          }
          default:
            k.value = void 0;
        }
      },
      selectedElement: k,
      isInvalidInput: B,
      addOnPaste: r,
      addOnBlur: c,
      addOnTab: f,
      dir: p,
      disabled: o,
      delimiter: s,
      max: i,
      id: u,
      displayValue: n.displayValue
    }), (E, T) => (h(), x(l($), null, {
      default: y(() => [N(l(X), {
        ref: l(m),
        dir: l(p),
        as: E.as,
        "as-child": E.asChild,
        "data-invalid": B.value ? "" : void 0,
        "data-disabled": l(o) ? "" : void 0,
        "data-focused": l(w) ? "" : void 0
      }, {
        default: y(() => [_(E.$slots, "default", { modelValue: l(v) }), l(C) && E.name ? (h(), x(l(In), {
          key: 0,
          name: E.name,
          value: l(v),
          required: E.required,
          disabled: l(o)
        }, null, 8, [
          "name",
          "value",
          "required",
          "disabled"
        ])) : qe("v-if", !0)]),
        _: 3
      }, 8, [
        "dir",
        "as",
        "as-child",
        "data-invalid",
        "data-disabled",
        "data-focused"
      ])]),
      _: 3
    }));
  }
}), lA = sA, iA = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    maxLength: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = af(), { forwardRef: a, currentElement: r } = j();
    function o(v) {
      if (n.selectedElement.value = void 0, !n.addOnBlur.value) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = "");
    }
    function s(v) {
      n.addOnTab.value && c(v);
    }
    const i = O(!1);
    function u() {
      i.value = !0;
    }
    function d() {
      Pe(() => {
        i.value = !1;
      });
    }
    async function c(v) {
      if (i.value || (await Pe(), v.defaultPrevented)) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = ""), v.preventDefault();
    }
    function f(v) {
      if (n.isInvalidInput.value = !1, v.data === null) return;
      const m = n.delimiter.value;
      if (m === v.data || m instanceof RegExp && m.test(v.data)) {
        const w = v.target;
        if (w.value = w.value.replace(m, ""), w.value.trim() === "") {
          w.value = "";
          return;
        }
        n.onAddValue(w.value) && (w.value = "");
      }
    }
    function p(v) {
      if (n.addOnPaste.value) {
        v.preventDefault();
        const m = v.clipboardData;
        if (!m) return;
        const g = m.getData("text");
        n.delimiter.value ? g.split(n.delimiter.value).forEach((C) => {
          n.onAddValue(C);
        }) : n.onAddValue(g);
      }
    }
    return Ce(() => {
      const v = r.value.nodeName === "INPUT" ? r.value : r.value.querySelector("input");
      v && setTimeout(() => {
        t.autoFocus && v?.focus();
      }, 1);
    }), (v, m) => (h(), x(l(X), {
      id: l(n).id?.value,
      ref: l(a),
      type: "text",
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      as: v.as,
      "as-child": v.asChild,
      maxlength: v.maxLength,
      placeholder: v.placeholder,
      disabled: l(n).disabled.value,
      "data-invalid": l(n).isInvalidInput.value ? "" : void 0,
      onInput: f,
      onKeydown: [
        Je(c, ["enter"]),
        Je(s, ["tab"]),
        l(n).onInputKeydown
      ],
      onBlur: o,
      onCompositionstart: u,
      onCompositionend: d,
      onPaste: p
    }, {
      default: y(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "maxlength",
      "placeholder",
      "disabled",
      "data-invalid",
      "onKeydown"
    ]));
  }
}), uA = iA;
const [gy, dA] = Se("TagsInputItem");
var cA = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { value: n } = Me(t), a = af(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = q(() => a.selectedElement.value === o.value), u = q(() => t.disabled || a.disabled.value), d = dA({
      value: n,
      isSelected: i,
      disabled: u,
      textId: "",
      displayValue: q(() => a.displayValue(n.value))
    });
    return (c, f) => (h(), x(l(s), { value: l(n) }, {
      default: y(() => [N(l(X), {
        ref: l(r),
        as: c.as,
        "as-child": c.asChild,
        "aria-labelledby": l(d).textId,
        "aria-current": i.value,
        "data-disabled": u.value ? "" : void 0,
        "data-state": i.value ? "active" : "inactive"
      }, {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-labelledby",
        "aria-current",
        "data-disabled",
        "data-state"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), fA = cA, pA = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = af(), a = gy(), r = q(() => a.disabled?.value || n.disabled.value);
    function o() {
      if (r.value) return;
      const s = n.modelValue.value.findIndex((i) => Mn(i, a.value.value));
      n.onRemoveValue(s);
    }
    return (s, i) => (h(), x(l(X), A({ tabindex: "-1" }, t, {
      "aria-labelledby": l(a).textId,
      "aria-current": l(a).isSelected.value,
      "data-state": l(a).isSelected.value ? "active" : "inactive",
      "data-disabled": r.value ? "" : void 0,
      type: s.as === "button" ? "button" : void 0,
      onClick: o
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-labelledby",
      "aria-current",
      "data-state",
      "data-disabled",
      "type"
    ]));
  }
}), vA = pA, mA = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = gy();
    return j(), n.textId ||= Ge(void 0, "reka-tags-input-item-text"), (a, r) => (h(), x(l(X), A(t, { id: l(n).textId }), {
      default: y(() => [_(a.$slots, "default", {}, () => [Re(Ne(l(n).displayValue.value), 1)])]),
      _: 3
    }, 16, ["id"]));
  }
}), hA = mA;
const [yy, gA] = Se("ToggleGroupRoot");
var yA = /* @__PURE__ */ b({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: {
      type: Boolean,
      required: !1,
      default: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { loop: r, rovingFocus: o, disabled: s, dir: i } = Me(n), u = gt(i), { forwardRef: d, currentElement: c } = j(), { modelValue: f, changeModelValue: p, isSingle: v } = Hh(n, a), m = On(c);
    return gA({
      isSingle: v,
      modelValue: f,
      changeModelValue: p,
      dir: u,
      orientation: n.orientation,
      loop: r,
      rovingFocus: o,
      disabled: s
    }), (g, w) => (h(), x(kt(l(o) ? l(cs) : l(X)), {
      "as-child": "",
      orientation: l(o) ? g.orientation : void 0,
      dir: l(u),
      loop: l(o) ? l(r) : void 0
    }, {
      default: y(() => [N(l(X), {
        ref: l(d),
        role: "group",
        "as-child": g.asChild,
        as: g.as
      }, {
        default: y(() => [_(g.$slots, "default", { modelValue: l(f) }), l(m) && g.name ? (h(), x(In, {
          key: 0,
          name: g.name,
          required: g.required,
          value: l(f)
        }, null, 8, [
          "name",
          "required",
          "value"
        ])) : qe("v-if", !0)]),
        _: 3
      }, 8, ["as-child", "as"])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), bA = yA, _A = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = yy(null), i = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function u() {
      i.value = !i.value;
    }
    const d = q(() => i.value ? "on" : "off"), c = On(o);
    return (f, p) => (h(), x(l(X), {
      ref: l(r),
      type: f.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: f.as,
      "aria-pressed": l(i),
      "data-state": d.value,
      "data-disabled": f.disabled ? "" : void 0,
      disabled: f.disabled,
      onClick: u
    }, {
      default: y(() => [_(f.$slots, "default", {
        modelValue: l(i),
        disabled: f.disabled,
        pressed: l(i),
        state: d.value
      }), l(c) && f.name && !l(s) ? (h(), x(In, {
        key: 0,
        type: "checkbox",
        name: f.name,
        value: l(i),
        required: f.required
      }, null, 8, [
        "name",
        "value",
        "required"
      ])) : qe("v-if", !0)]),
      _: 3
    }, 8, [
      "type",
      "as-child",
      "as",
      "aria-pressed",
      "data-state",
      "data-disabled",
      "disabled"
    ]));
  }
}), by = _A, wA = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = yy(), a = q(() => n.disabled?.value || t.disabled), r = q(() => yl(n.modelValue.value, t.value)), { forwardRef: o } = j();
    return (s, i) => (h(), x(kt(l(n).rovingFocus.value ? l(fs) : l(X)), A({ "as-child": "" }, l(n).rovingFocus.value ? {
      focusable: !a.value,
      active: r.value
    } : {}), {
      default: y(() => [N(l(by), A(t, {
        ref: l(o),
        disabled: a.value,
        "model-value": r.value,
        "onUpdate:modelValue": i[0] || (i[0] = (u) => l(n).changeModelValue(s.value))
      }), {
        default: y((u) => [_(s.$slots, "default", oe(le(u)))]),
        _: 3
      }, 16, ["disabled", "model-value"])]),
      _: 3
    }, 16));
  }
}), xA = wA, CA = /* @__PURE__ */ b({
  __name: "TooltipArrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(v$), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), SA = CA;
const [rf, $A] = Se("TooltipProvider");
var BA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: {
      type: Number,
      required: !1,
      default: 700
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(e) {
    const t = e, { delayDuration: n, skipDelayDuration: a, disableHoverableContent: r, disableClosingTrigger: o, ignoreNonKeyboardFocus: s, disabled: i } = Me(t);
    j();
    const u = O(!0), d = O(!1), { start: c, stop: f } = oh(() => {
      u.value = !0;
    }, a, { immediate: !1 });
    return $A({
      isOpenDelayed: u,
      delayDuration: n,
      onOpen() {
        f(), u.value = !1;
      },
      onClose() {
        c();
      },
      isPointerInTransitRef: d,
      disableHoverableContent: r,
      disableClosingTrigger: o,
      disabled: i,
      ignoreNonKeyboardFocus: s
    }), (p, v) => _(p.$slots, "default");
  }
}), of = BA;
const _y = "tooltip.open", [Fi, kA] = Se("TooltipRoot");
var PA = /* @__PURE__ */ b({
  __name: "TooltipRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: void 0
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = rf(), o = q(() => n.disableHoverableContent ?? r.disableHoverableContent.value), s = q(() => n.disableClosingTrigger ?? r.disableClosingTrigger.value), i = q(() => n.disabled ?? r.disabled.value), u = q(() => n.delayDuration ?? r.delayDuration.value), d = q(() => n.ignoreNonKeyboardFocus ?? r.ignoreNonKeyboardFocus.value), c = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    me(c, ($) => {
      r.onClose && ($ ? (r.onOpen(), document.dispatchEvent(new CustomEvent(_y))) : r.onClose());
    });
    const f = O(!1), p = O(), v = q(() => c.value ? f.value ? "delayed-open" : "instant-open" : "closed"), { start: m, stop: g } = oh(() => {
      f.value = !0, c.value = !0;
    }, u, { immediate: !1 });
    function w() {
      g(), f.value = !1, c.value = !0;
    }
    function C() {
      g(), c.value = !1;
    }
    function S() {
      m();
    }
    return kA({
      contentId: "",
      open: c,
      stateAttribute: v,
      trigger: p,
      onTriggerChange($) {
        p.value = $;
      },
      onTriggerEnter() {
        r.isOpenDelayed.value ? S() : w();
      },
      onTriggerLeave() {
        o.value ? C() : g();
      },
      onOpen: w,
      onClose: C,
      disableHoverableContent: o,
      disableClosingTrigger: s,
      disabled: i,
      ignoreNonKeyboardFocus: d
    }), ($, k) => (h(), x(l(or), null, {
      default: y(() => [_($.$slots, "default", { open: l(c) })]),
      _: 3
    }));
  }
}), DA = PA, MA = /* @__PURE__ */ b({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    align: {
      type: null,
      required: !1,
      default: "center"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    arrowPadding: {
      type: Number,
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Fi(), { forwardRef: o, currentElement: s } = j(), i = q(() => n.ariaLabel || s.value?.textContent), u = q(() => {
      const { ariaLabel: d, ...c } = n;
      return c;
    });
    return Ce(() => {
      Lt(window, "scroll", (d) => {
        d.target?.contains(r.trigger.value) && r.onClose();
      }), Lt(window, _y, r.onClose);
    }), (d, c) => (h(), x(l(Oa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: c[0] || (c[0] = (f) => a("escapeKeyDown", f)),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        l(r).disableClosingTrigger.value && l(r).trigger.value?.contains(f.target) && f.preventDefault(), a("pointerDownOutside", f);
      }),
      onFocusOutside: c[2] || (c[2] = Ye(() => {
      }, ["prevent"])),
      onDismiss: c[3] || (c[3] = (f) => l(r).onClose())
    }, {
      default: y(() => [N(l(Yr), A({
        ref: l(o),
        "data-state": l(r).stateAttribute.value
      }, {
        ...d.$attrs,
        ...u.value
      }, { style: {
        "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
        "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
        "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: y(() => [_(d.$slots, "default"), N(l(wi), {
          id: l(r).contentId,
          role: "tooltip"
        }, {
          default: y(() => [Re(Ne(i.value), 1)]),
          _: 1
        }, 8, ["id"])]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }));
  }
}), wy = MA, qA = /* @__PURE__ */ b({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  setup(e) {
    const n = he(e), { forwardRef: a, currentElement: r } = j(), { trigger: o, onClose: s } = Fi(), i = rf(), { isPointerInTransit: u, onPointerExit: d } = Oh(o, r);
    return i.isPointerInTransitRef = u, d(() => {
      s();
    }), (c, f) => (h(), x(wy, A({ ref: l(a) }, l(n)), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), EA = qA, TA = /* @__PURE__ */ b({
  __name: "TooltipContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Fi(), o = ve(n, a), { forwardRef: s } = j();
    return (i, u) => (h(), x(l(Ct), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [(h(), x(kt(l(r).disableHoverableContent.value ? wy : EA), A({ ref: l(s) }, l(o)), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), AA = TA, OA = /* @__PURE__ */ b({
  __name: "TooltipPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ia), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), IA = OA, RA = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Fi(), a = rf();
    n.contentId ||= Ge(void 0, "reka-tooltip-content");
    const { forwardRef: r, currentElement: o } = j(), s = O(!1), i = O(!1), u = q(() => n.disabled.value ? {} : {
      click: g,
      focus: v,
      pointermove: f,
      pointerleave: p,
      pointerdown: c,
      blur: m
    });
    Ce(() => {
      n.onTriggerChange(o.value);
    });
    function d() {
      setTimeout(() => {
        s.value = !1;
      }, 1);
    }
    function c() {
      n.open && !n.disableClosingTrigger.value && n.onClose(), s.value = !0, document.addEventListener("pointerup", d, { once: !0 });
    }
    function f(w) {
      w.pointerType !== "touch" && !i.value && !a.isPointerInTransitRef.value && (n.onTriggerEnter(), i.value = !0);
    }
    function p() {
      n.onTriggerLeave(), i.value = !1;
    }
    function v(w) {
      s.value || n.ignoreNonKeyboardFocus.value && !w.target.matches?.(":focus-visible") || n.onOpen();
    }
    function m() {
      n.onClose();
    }
    function g() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (w, C) => (h(), x(l(sr), {
      "as-child": "",
      reference: w.reference
    }, {
      default: y(() => [N(l(X), A({
        ref: l(r),
        "aria-describedby": l(n).open.value ? l(n).contentId : void 0,
        "data-state": l(n).stateAttribute.value,
        as: w.as,
        "as-child": t.asChild,
        "data-grace-area-trigger": ""
      }, p0(u.value)), {
        default: y(() => [_(w.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-describedby",
        "data-state",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), VA = RA;
function xy(e) {
  var t, n, a = "";
  if (typeof e == "string" || typeof e == "number") a += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = xy(e[t])) && (a && (a += " "), a += n);
  } else for (n in e) e[n] && (a && (a += " "), a += n);
  return a;
}
function Cy() {
  for (var e, t, n = 0, a = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = xy(e)) && (a && (a += " "), a += t);
  return a;
}
const FA = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let a = 0; a < e.length; a++)
    n[a] = e[a];
  for (let a = 0; a < t.length; a++)
    n[e.length + a] = t[a];
  return n;
}, NA = (e, t) => ({
  classGroupId: e,
  validator: t
}), Sy = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), Al = "-", lv = [], LA = "arbitrary..", zA = (e) => {
  const t = UA(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: a
  } = e;
  return {
    getClassGroupId: (s) => {
      if (s.startsWith("[") && s.endsWith("]"))
        return HA(s);
      const i = s.split(Al), u = i[0] === "" && i.length > 1 ? 1 : 0;
      return $y(i, u, t);
    },
    getConflictingClassGroupIds: (s, i) => {
      if (i) {
        const u = a[s], d = n[s];
        return u ? d ? FA(d, u) : u : d || lv;
      }
      return n[s] || lv;
    }
  };
}, $y = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const r = e[t], o = n.nextPart.get(r);
  if (o) {
    const d = $y(e, t + 1, o);
    if (d) return d;
  }
  const s = n.validators;
  if (s === null)
    return;
  const i = t === 0 ? e.join(Al) : e.slice(t).join(Al), u = s.length;
  for (let d = 0; d < u; d++) {
    const c = s[d];
    if (c.validator(i))
      return c.classGroupId;
  }
}, HA = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), a = t.slice(0, n);
  return a ? LA + a : void 0;
})(), UA = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return jA(n, t);
}, jA = (e, t) => {
  const n = Sy();
  for (const a in e) {
    const r = e[a];
    sf(r, n, a, t);
  }
  return n;
}, sf = (e, t, n, a) => {
  const r = e.length;
  for (let o = 0; o < r; o++) {
    const s = e[o];
    WA(s, t, n, a);
  }
}, WA = (e, t, n, a) => {
  if (typeof e == "string") {
    GA(e, t, n);
    return;
  }
  if (typeof e == "function") {
    KA(e, t, n, a);
    return;
  }
  YA(e, t, n, a);
}, GA = (e, t, n) => {
  const a = e === "" ? t : By(t, e);
  a.classGroupId = n;
}, KA = (e, t, n, a) => {
  if (XA(e)) {
    sf(e(a), t, n, a);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(NA(n, e));
}, YA = (e, t, n, a) => {
  const r = Object.entries(e), o = r.length;
  for (let s = 0; s < o; s++) {
    const [i, u] = r[s];
    sf(u, By(t, i), n, a);
  }
}, By = (e, t) => {
  let n = e;
  const a = t.split(Al), r = a.length;
  for (let o = 0; o < r; o++) {
    const s = a[o];
    let i = n.nextPart.get(s);
    i || (i = Sy(), n.nextPart.set(s, i)), n = i;
  }
  return n;
}, XA = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, JA = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
  const r = (o, s) => {
    n[o] = s, t++, t > e && (t = 0, a = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let s = n[o];
      if (s !== void 0)
        return s;
      if ((s = a[o]) !== void 0)
        return r(o, s), s;
    },
    set(o, s) {
      o in n ? n[o] = s : r(o, s);
    }
  };
}, Cd = "!", iv = ":", ZA = [], uv = (e, t, n, a, r) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: a,
  isExternal: r
}), QA = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let a = (r) => {
    const o = [];
    let s = 0, i = 0, u = 0, d;
    const c = r.length;
    for (let g = 0; g < c; g++) {
      const w = r[g];
      if (s === 0 && i === 0) {
        if (w === iv) {
          o.push(r.slice(u, g)), u = g + 1;
          continue;
        }
        if (w === "/") {
          d = g;
          continue;
        }
      }
      w === "[" ? s++ : w === "]" ? s-- : w === "(" ? i++ : w === ")" && i--;
    }
    const f = o.length === 0 ? r : r.slice(u);
    let p = f, v = !1;
    f.endsWith(Cd) ? (p = f.slice(0, -1), v = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      f.startsWith(Cd) && (p = f.slice(1), v = !0)
    );
    const m = d && d > u ? d - u : void 0;
    return uv(o, v, p, m);
  };
  if (t) {
    const r = t + iv, o = a;
    a = (s) => s.startsWith(r) ? o(s.slice(r.length)) : uv(ZA, !1, s, void 0, !0);
  }
  if (n) {
    const r = a;
    a = (o) => n({
      className: o,
      parseClassName: r
    });
  }
  return a;
}, e2 = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, a) => {
    t.set(n, 1e6 + a);
  }), (n) => {
    const a = [];
    let r = [];
    for (let o = 0; o < n.length; o++) {
      const s = n[o], i = s[0] === "[", u = t.has(s);
      i || u ? (r.length > 0 && (r.sort(), a.push(...r), r = []), a.push(s)) : r.push(s);
    }
    return r.length > 0 && (r.sort(), a.push(...r)), a;
  };
}, t2 = (e) => ({
  cache: JA(e.cacheSize),
  parseClassName: QA(e),
  sortModifiers: e2(e),
  ...zA(e)
}), n2 = /\s+/, a2 = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: a,
    getConflictingClassGroupIds: r,
    sortModifiers: o
  } = t, s = [], i = e.trim().split(n2);
  let u = "";
  for (let d = i.length - 1; d >= 0; d -= 1) {
    const c = i[d], {
      isExternal: f,
      modifiers: p,
      hasImportantModifier: v,
      baseClassName: m,
      maybePostfixModifierPosition: g
    } = n(c);
    if (f) {
      u = c + (u.length > 0 ? " " + u : u);
      continue;
    }
    let w = !!g, C = a(w ? m.substring(0, g) : m);
    if (!C) {
      if (!w) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      if (C = a(m), !C) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      w = !1;
    }
    const S = p.length === 0 ? "" : p.length === 1 ? p[0] : o(p).join(":"), $ = v ? S + Cd : S, k = $ + C;
    if (s.indexOf(k) > -1)
      continue;
    s.push(k);
    const B = r(C, w);
    for (let D = 0; D < B.length; ++D) {
      const P = B[D];
      s.push($ + P);
    }
    u = c + (u.length > 0 ? " " + u : u);
  }
  return u;
}, r2 = (...e) => {
  let t = 0, n, a, r = "";
  for (; t < e.length; )
    (n = e[t++]) && (a = ky(n)) && (r && (r += " "), r += a);
  return r;
}, ky = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let a = 0; a < e.length; a++)
    e[a] && (t = ky(e[a])) && (n && (n += " "), n += t);
  return n;
}, o2 = (e, ...t) => {
  let n, a, r, o;
  const s = (u) => {
    const d = t.reduce((c, f) => f(c), e());
    return n = t2(d), a = n.cache.get, r = n.cache.set, o = i, i(u);
  }, i = (u) => {
    const d = a(u);
    if (d)
      return d;
    const c = a2(u, n);
    return r(u, c), c;
  };
  return o = s, (...u) => o(r2(...u));
}, s2 = [], Bt = (e) => {
  const t = (n) => n[e] || s2;
  return t.isThemeGetter = !0, t;
}, Py = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, Dy = /^\((?:(\w[\w-]*):)?(.+)\)$/i, l2 = /^\d+\/\d+$/, i2 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, u2 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, d2 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, c2 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, f2 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, _r = (e) => l2.test(e), ze = (e) => !!e && !Number.isNaN(Number(e)), _a = (e) => !!e && Number.isInteger(Number(e)), Tu = (e) => e.endsWith("%") && ze(e.slice(0, -1)), Qn = (e) => i2.test(e), p2 = () => !0, v2 = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  u2.test(e) && !d2.test(e)
), My = () => !1, m2 = (e) => c2.test(e), h2 = (e) => f2.test(e), g2 = (e) => !$e(e) && !Be(e), y2 = (e) => eo(e, Ty, My), $e = (e) => Py.test(e), Na = (e) => eo(e, Ay, v2), Au = (e) => eo(e, C2, ze), dv = (e) => eo(e, qy, My), b2 = (e) => eo(e, Ey, h2), Ns = (e) => eo(e, Oy, m2), Be = (e) => Dy.test(e), co = (e) => to(e, Ay), _2 = (e) => to(e, S2), cv = (e) => to(e, qy), w2 = (e) => to(e, Ty), x2 = (e) => to(e, Ey), Ls = (e) => to(e, Oy, !0), eo = (e, t, n) => {
  const a = Py.exec(e);
  return a ? a[1] ? t(a[1]) : n(a[2]) : !1;
}, to = (e, t, n = !1) => {
  const a = Dy.exec(e);
  return a ? a[1] ? t(a[1]) : n : !1;
}, qy = (e) => e === "position" || e === "percentage", Ey = (e) => e === "image" || e === "url", Ty = (e) => e === "length" || e === "size" || e === "bg-size", Ay = (e) => e === "length", C2 = (e) => e === "number", S2 = (e) => e === "family-name", Oy = (e) => e === "shadow", $2 = () => {
  const e = Bt("color"), t = Bt("font"), n = Bt("text"), a = Bt("font-weight"), r = Bt("tracking"), o = Bt("leading"), s = Bt("breakpoint"), i = Bt("container"), u = Bt("spacing"), d = Bt("radius"), c = Bt("shadow"), f = Bt("inset-shadow"), p = Bt("text-shadow"), v = Bt("drop-shadow"), m = Bt("blur"), g = Bt("perspective"), w = Bt("aspect"), C = Bt("ease"), S = Bt("animate"), $ = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], k = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], B = () => [...k(), Be, $e], D = () => ["auto", "hidden", "clip", "visible", "scroll"], P = () => ["auto", "contain", "none"], E = () => [Be, $e, u], T = () => [_r, "full", "auto", ...E()], M = () => [_a, "none", "subgrid", Be, $e], I = () => ["auto", {
    span: ["full", _a, Be, $e]
  }, _a, Be, $e], F = () => [_a, "auto", Be, $e], J = () => ["auto", "min", "max", "fr", Be, $e], ne = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], Q = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], G = () => ["auto", ...E()], H = () => [_r, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...E()], U = () => [e, Be, $e], se = () => [...k(), cv, dv, {
    position: [Be, $e]
  }], ee = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], de = () => ["auto", "cover", "contain", w2, y2, {
    size: [Be, $e]
  }], fe = () => [Tu, co, Na], _e = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    d,
    Be,
    $e
  ], ye = () => ["", ze, co, Na], Te = () => ["solid", "dashed", "dotted", "double"], ce = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], V = () => [ze, Tu, cv, dv], te = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    m,
    Be,
    $e
  ], z = () => ["none", ze, Be, $e], re = () => ["none", ze, Be, $e], ie = () => [ze, Be, $e], L = () => [_r, "full", ...E()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Qn],
      breakpoint: [Qn],
      color: [p2],
      container: [Qn],
      "drop-shadow": [Qn],
      ease: ["in", "out", "in-out"],
      font: [g2],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Qn],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Qn],
      shadow: [Qn],
      spacing: ["px", ze],
      text: [Qn],
      "text-shadow": [Qn],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", _r, $e, Be, w]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [ze, $e, Be, i]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": $()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": $()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: B()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: D()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": D()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": D()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: P()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": P()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": P()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: T()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": T()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": T()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: T()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: T()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: T()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: T()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: T()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: T()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [_a, "auto", Be, $e]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [_r, "full", "auto", i, ...E()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [ze, _r, "auto", "initial", "none", $e]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", ze, Be, $e]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", ze, Be, $e]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [_a, "first", "last", "none", Be, $e]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": M()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: I()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": F()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": F()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": M()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: I()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": F()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": F()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": J()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": J()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: E()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": E()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": E()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ne(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...Q(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...Q()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ne()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ne()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...Q(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...Q()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: E()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: E()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: E()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: E()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: E()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: E()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: E()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: E()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: E()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: G()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: G()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: G()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: G()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: G()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: G()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: G()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: G()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: G()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": E()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": E()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: H()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [i, "screen", ...H()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          i,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...H()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          i,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...H()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...H()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...H()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...H()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, co, Na]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [a, Be, Au]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Tu, $e]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [_2, $e, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [r, Be, $e]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [ze, "none", Be, Au]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...E()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Be, $e]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", Be, $e]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: U()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: U()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Te(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [ze, "from-font", "auto", Be, Na]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: U()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [ze, "auto", Be, $e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: E()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Be, $e]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Be, $e]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: se()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ee()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: de()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, _a, Be, $e],
          radial: ["", Be, $e],
          conic: [_a, Be, $e]
        }, x2, b2]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: U()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: fe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: fe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: fe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: U()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: U()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: U()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: _e()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": _e()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": _e()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": _e()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": _e()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": _e()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": _e()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": _e()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": _e()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": _e()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": _e()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": _e()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": _e()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": _e()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": _e()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ye()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ye()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ye()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ye()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ye()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ye()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ye()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ye()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ye()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ye()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ye()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Te(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...Te(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: U()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": U()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": U()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": U()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": U()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": U()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": U()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": U()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": U()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: U()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...Te(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [ze, Be, $e]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", ze, co, Na]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: U()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          Ls,
          Ns
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: U()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", f, Ls, Ns]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": U()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ye()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: U()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [ze, Na]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": U()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ye()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": U()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", p, Ls, Ns]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": U()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [ze, Be, $e]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...ce(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": ce()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [ze]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": V()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": V()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": U()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": U()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": V()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": V()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": U()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": U()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": V()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": V()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": U()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": U()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": V()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": V()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": U()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": U()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": V()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": V()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": U()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": U()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": V()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": V()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": U()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": U()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": V()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": V()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": U()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": U()
      }],
      "mask-image-radial": [{
        "mask-radial": [Be, $e]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": V()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": V()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": U()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": U()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": k()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [ze]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": V()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": V()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": U()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": U()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: se()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: ee()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: de()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", Be, $e]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Be,
          $e
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: te()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [ze, Be, $e]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [ze, Be, $e]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          v,
          Ls,
          Ns
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": U()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", ze, Be, $e]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [ze, Be, $e]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", ze, Be, $e]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [ze, Be, $e]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", ze, Be, $e]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Be,
          $e
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": te()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [ze, Be, $e]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [ze, Be, $e]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", ze, Be, $e]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [ze, Be, $e]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", ze, Be, $e]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [ze, Be, $e]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [ze, Be, $e]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", ze, Be, $e]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": E()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": E()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": E()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Be, $e]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [ze, "initial", Be, $e]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", C, Be, $e]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [ze, Be, $e]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", S, Be, $e]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [g, Be, $e]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": B()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: z()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": z()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": z()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": z()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: re()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": re()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": re()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": re()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: ie()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": ie()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": ie()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [Be, $e, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: B()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: L()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": L()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": L()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": L()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: U()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: U()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Be, $e]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": E()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": E()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": E()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": E()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": E()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": E()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": E()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": E()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": E()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": E()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": E()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": E()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": E()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": E()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": E()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": E()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": E()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": E()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Be, $e]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...U()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [ze, co, Na, Au]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...U()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, B2 = /* @__PURE__ */ o2($2);
function R(...e) {
  return B2(Cy(e));
}
function yH(e, t) {
  t.value = typeof e == "function" ? e(t.value) : e;
}
function bH(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = wn(a, s);
    if (i || i === null) return i;
    throw new Error(
      `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`
    );
  }, (s) => (Kn(a, s), s)];
}
function k2(e, t, n = {}) {
  let a, r, o, s = !0;
  const i = () => {
    s = !0, o();
  };
  me(e, i, {
    flush: "sync",
    ...n
  });
  const u = typeof t == "function" ? t : t.get, d = typeof t == "function" ? void 0 : t.set, c = ui((f, p) => (r = f, o = p, {
    get() {
      return s && (a = u(a), s = !1), r(), a;
    },
    set(v) {
      d?.(v);
    }
  }));
  return c.trigger = i, c;
}
const Mr = /* @__PURE__ */ new WeakMap(), Iy = /* @__NO_SIDE_EFFECTS__ */ (...e) => {
  var t;
  const n = e[0], a = (t = Pt()) === null || t === void 0 ? void 0 : t.proxy, r = a ?? Qo();
  if (r == null && !Zm()) throw new Error("injectLocal must be called in setup");
  return r && Mr.has(r) && n in Mr.get(r) ? Mr.get(r)[n] : wn(...e);
};
function P2(e, t) {
  var n;
  const a = (n = Pt()) === null || n === void 0 ? void 0 : n.proxy, r = a ?? Qo();
  if (r == null) throw new Error("provideLocal must be called in setup");
  Mr.has(r) || Mr.set(r, /* @__PURE__ */ Object.create(null));
  const o = Mr.get(r);
  return o[e] = t, Kn(e, t);
}
// @__NO_SIDE_EFFECTS__
function D2(e, t) {
  const n = Symbol(e.name || "InjectionState"), a = void 0;
  return [(...s) => {
    const i = e(...s);
    return P2(n, i), i;
  }, () => /* @__PURE__ */ Iy(n, a)];
}
const Ry = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const M2 = (e) => typeof e < "u", q2 = Object.prototype.toString, E2 = (e) => q2.call(e) === "[object Object]";
function fv(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function Ou(e) {
  return Array.isArray(e) ? e : [e];
}
function T2(e) {
  return mt(e) ? jt(new Proxy({}, {
    get(t, n, a) {
      return l(Reflect.get(e.value, n, a));
    },
    set(t, n, a) {
      return mt(e.value[n]) && !mt(a) ? e.value[n].value = a : e.value[n] = a, !0;
    },
    deleteProperty(t, n) {
      return Reflect.deleteProperty(e.value, n);
    },
    has(t, n) {
      return Reflect.has(e.value, n);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  })) : jt(e);
}
function A2(e) {
  return T2(q(e));
}
function Z(e, ...t) {
  const n = t.flat(), a = n[0];
  return A2(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(pe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
function O2(e, t, n) {
  return me(e, t, {
    ...n,
    immediate: !0
  });
}
const Vy = Ry ? window : void 0, Fy = Ry ? window.document : void 0;
function Ny(e) {
  var t;
  const n = pe(e);
  return (t = n?.$el) !== null && t !== void 0 ? t : n;
}
function qr(...e) {
  const t = (a, r, o, s) => (a.addEventListener(r, o, s), () => a.removeEventListener(r, o, s)), n = q(() => {
    const a = Ou(pe(e[0])).filter((r) => r != null);
    return a.every((r) => typeof r != "string") ? a : void 0;
  });
  return O2(() => {
    var a, r;
    return [
      (a = (r = n.value) === null || r === void 0 ? void 0 : r.map((o) => Ny(o))) !== null && a !== void 0 ? a : [Vy].filter((o) => o != null),
      Ou(pe(n.value ? e[1] : e[0])),
      Ou(l(n.value ? e[2] : e[1])),
      pe(n.value ? e[3] : e[2])
    ];
  }, ([a, r, o, s], i, u) => {
    if (!a?.length || !r?.length || !o?.length) return;
    const d = E2(s) ? { ...s } : s, c = a.flatMap((f) => r.flatMap((p) => o.map((v) => t(f, p, v, d))));
    u(() => {
      c.forEach((f) => f());
    });
  }, { flush: "post" });
}
// @__NO_SIDE_EFFECTS__
function I2() {
  const e = ht(!1), t = Pt();
  return t && Ce(() => {
    e.value = !0;
  }, t), e;
}
// @__NO_SIDE_EFFECTS__
function R2(e) {
  const t = /* @__PURE__ */ I2();
  return q(() => (t.value, !!e()));
}
const V2 = /* @__PURE__ */ Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function F2() {
  const e = Zm() ? /* @__PURE__ */ Iy(V2, null) : null;
  return typeof e == "number" ? e : void 0;
}
function Ol(e, t = {}) {
  const { window: n = Vy, ssrWidth: a = /* @__PURE__ */ F2() } = t, r = /* @__PURE__ */ R2(() => n && "matchMedia" in n && typeof n.matchMedia == "function"), o = ht(typeof a == "number"), s = ht(), i = ht(!1), u = (d) => {
    i.value = d.matches;
  };
  return Ae(() => {
    if (o.value) {
      o.value = !r.value, i.value = pe(e).split(",").some((d) => {
        const c = d.includes("not all"), f = d.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), p = d.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let v = !!(f || p);
        return f && v && (v = a >= fv(f[1])), p && v && (v = a <= fv(p[1])), c ? !v : v;
      });
      return;
    }
    r.value && (s.value = n.matchMedia(pe(e)), i.value = s.value.matches);
  }), qr(s, "change", u, { passive: !0 }), q(() => i.value);
}
function N2(e) {
  return JSON.parse(JSON.stringify(e));
}
function L2(e) {
  const t = Pt(), n = k2(() => null, () => e ? Ny(e) : t.proxy.$el);
  return v0(n.trigger), Ce(n.trigger), n;
}
function z2(e, t = {}) {
  const { threshold: n = 50, onSwipe: a, onSwipeEnd: r, onSwipeStart: o, passive: s = !0 } = t, i = jt({
    x: 0,
    y: 0
  }), u = jt({
    x: 0,
    y: 0
  }), d = q(() => i.x - u.x), c = q(() => i.y - u.y), { max: f, abs: p } = Math, v = q(() => f(p(d.value), p(c.value)) >= n), m = ht(!1), g = q(() => v.value ? p(d.value) > p(c.value) ? d.value > 0 ? "left" : "right" : c.value > 0 ? "up" : "down" : "none"), w = (P) => [P.touches[0].clientX, P.touches[0].clientY], C = (P, E) => {
    i.x = P, i.y = E;
  }, S = (P, E) => {
    u.x = P, u.y = E;
  }, $ = {
    passive: s,
    capture: !s
  }, k = (P) => {
    m.value && r?.(P, g.value), m.value = !1;
  }, B = [
    qr(e, "touchstart", (P) => {
      if (P.touches.length !== 1) return;
      const [E, T] = w(P);
      C(E, T), S(E, T), o?.(P);
    }, $),
    qr(e, "touchmove", (P) => {
      if (P.touches.length !== 1) return;
      const [E, T] = w(P);
      S(E, T), $.capture && !$.passive && Math.abs(d.value) > Math.abs(c.value) && P.preventDefault(), !m.value && v.value && (m.value = !0), m.value && a?.(P);
    }, $),
    qr(e, ["touchend", "touchcancel"], k, $)
  ];
  return {
    isSwiping: m,
    direction: g,
    coordsStart: i,
    coordsEnd: u,
    lengthX: d,
    lengthY: c,
    stop: () => B.forEach((P) => P())
  };
}
// @__NO_SIDE_EFFECTS__
function Ni(e, t, n, a = {}) {
  var r, o;
  const { clone: s = !1, passive: i = !1, eventName: u, deep: d = !1, defaultValue: c, shouldEmit: f } = a, p = Pt(), v = n || p?.emit || (p == null || (r = p.$emit) === null || r === void 0 ? void 0 : r.bind(p)) || (p == null || (o = p.proxy) === null || o === void 0 || (o = o.$emit) === null || o === void 0 ? void 0 : o.bind(p?.proxy));
  let m = u;
  t || (t = "modelValue"), m = m || `update:${t.toString()}`;
  const g = (S) => s ? typeof s == "function" ? s(S) : N2(S) : S, w = () => M2(e[t]) ? g(e[t]) : c, C = (S) => {
    f ? f(S) && v(m, S) : v(m, S);
  };
  if (i) {
    const S = O(w());
    let $ = !1;
    return me(() => e[t], (k) => {
      $ || ($ = !0, S.value = g(k), Pe(() => $ = !1));
    }), me(S, (k) => {
      !$ && (k !== e[t] || d) && C(k);
    }, { deep: d }), S;
  } else return q({
    get() {
      return w();
    },
    set(S) {
      C(S);
    }
  });
}
function _H() {
  const e = Ol("(max-width: 768px)"), t = Ol("(min-width: 769px) and (max-width: 1024px)"), n = O(!1);
  Ce(() => {
    n.value = "ontouchstart" in window || navigator.maxTouchPoints > 0;
  });
  const a = q(() => e.value || t.value);
  return {
    isMobile: e,
    isTablet: t,
    isTouchDevice: n,
    isSmallScreen: a
  };
}
function wH(e, t = {}) {
  const { threshold: n = 50, enabled: a = !0, onSwipeLeft: r, onSwipeRight: o } = t, { direction: s, lengthX: i } = z2(e, {
    passive: !0,
    onSwipeEnd() {
      a && Math.abs(i.value) >= n && (s.value === "left" && r ? r() : s.value === "right" && o && o());
    }
  });
  return {
    direction: s,
    lengthX: i
  };
}
function xH() {
  const e = O(!0);
  let t = 0, n = !1;
  const a = () => {
    n || (window.requestAnimationFrame(() => {
      const r = window.scrollY, o = r - t;
      o > 10 && r > 100 ? e.value = !1 : o < -10 && (e.value = !0), t = r, n = !1;
    }), n = !0);
  };
  return Ce(() => {
    window.addEventListener("scroll", a, { passive: !0 });
  }), nt(() => {
    window.removeEventListener("scroll", a);
  }), {
    isVisible: e
  };
}
const H2 = /* @__PURE__ */ b({
  __name: "AlertDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(Nx), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pv = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, vv = Cy, an = (e, t) => (n) => {
  var a;
  if (t?.variants == null) return vv(e, n?.class, n?.className);
  const { variants: r, defaultVariants: o } = t, s = Object.keys(r).map((d) => {
    const c = n?.[d], f = o?.[d];
    if (c === null) return null;
    const p = pv(c) || pv(f);
    return r[d][p];
  }), i = n && Object.entries(n).reduce((d, c) => {
    let [f, p] = c;
    return p === void 0 || (d[f] = p), d;
  }, {}), u = t == null || (a = t.compoundVariants) === null || a === void 0 ? void 0 : a.reduce((d, c) => {
    let { class: f, className: p, ...v } = c;
    return Object.entries(v).every((m) => {
      let [g, w] = m;
      return Array.isArray(w) ? w.includes({
        ...o,
        ...i
      }[g]) : {
        ...o,
        ...i
      }[g] === w;
    }) ? [
      ...d,
      f,
      p
    ] : d;
  }, []);
  return vv(e, s, u, n?.class, n?.className);
}, gs = /* @__PURE__ */ b({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-slot": "button",
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(R)(l(Kt)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Kt = an(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        xs: "h-7 rounded px-2",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), U2 = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Bx), A(l(n), {
      class: l(R)(l(Kt)(), t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), j2 = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Ex), A(l(n), {
      class: l(R)(l(Kt)({ variant: "outline" }), "mt-2 sm:mt-0", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), W2 = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(Vx), null, {
      default: y(() => [
        N(l(Ix), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(Mx), A(l(o), {
          class: l(R)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), G2 = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Ax), A(l(n), {
      class: l(R)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), K2 = /* @__PURE__ */ b({
  __name: "AlertDialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Y2 = /* @__PURE__ */ b({
  __name: "AlertDialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("flex flex-col gap-y-2 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), X2 = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(zx), A(l(n), {
      class: l(R)("text-lg font-semibold", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CH = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ux), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), SH = /* @__PURE__ */ b({
  __name: "ConfirmDialog",
  setup(e) {
    const { isOpen: t, close: n, cancelButton: a, actionButton: r, title: o, description: s, variant: i } = Q2();
    return (u, d) => (h(), x(l(H2), { open: l(t) }, {
      default: y(() => [
        N(l(W2), {
          onEscapeKeyDown: l(n),
          onPointerDownOutside: l(n)
        }, {
          default: y(() => [
            N(l(Y2), null, {
              default: y(() => [
                N(l(X2), null, {
                  default: y(() => [
                    Re(Ne(l(o)), 1)
                  ]),
                  _: 1
                }),
                N(l(G2), null, {
                  default: y(() => [
                    Re(Ne(l(s)), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            N(l(K2), null, {
              default: y(() => [
                N(l(j2), {
                  onClick: l(a).handler
                }, {
                  default: y(() => [
                    Re(Ne(l(a).label ?? "Cancel"), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                N(l(U2), {
                  variant: l(i),
                  onClick: l(r).handler
                }, {
                  default: y(() => [
                    Re(Ne(l(r).label ?? "Confirm"), 1)
                  ]),
                  _: 1
                }, 8, ["variant", "onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onEscapeKeyDown", "onPointerDownOutside"])
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), lf = O(!1), Ly = O(""), zy = O(""), Hy = O(null), Uy = O({
  label: void 0,
  handler: () => {
  }
}), jy = O({
  label: void 0,
  handler: () => {
  }
}), J2 = (e) => {
  Ly.value = e.title, zy.value = e.description, Hy.value = e.variant, Uy.value = mv(e.cancelAction), jy.value = mv(e.action), Z2();
}, mv = (e) => typeof e == "string" ? {
  label: e,
  handler: ll
} : typeof e == "function" ? {
  label: void 0,
  handler: e
} : typeof e == "object" && e !== void 0 ? {
  label: e.label ?? void 0,
  handler: e.handler ?? ll
} : {
  label: void 0,
  handler: ll
}, ll = () => {
  lf.value = !1;
}, Z2 = () => {
  lf.value = !0;
};
function Q2() {
  return {
    confirmDialog: (e) => J2(e),
    title: Ly,
    description: zy,
    variant: Hy,
    isOpen: lf,
    close: ll,
    cancelButton: Uy,
    actionButton: jy
  };
}
const cr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t)
    n[a] = r;
  return n;
}, eO = {}, tO = { class: "h-full bg-background dark:text-white" };
function nO(e, t) {
  return h(), W("div", tO, [
    _(e.$slots, "default")
  ]);
}
const $H = /* @__PURE__ */ cr(eO, [["render", nO]]), aO = {}, rO = { class: "sticky top-0 z-50 flex h-16 shrink-0 items-center gap-x-4 bg-background/60 px-4 backdrop-blur sm:gap-x-6 sm:px-6 lg:px-8" };
function oO(e, t) {
  return h(), W("header", rO, [
    _(e.$slots, "default")
  ]);
}
const BH = /* @__PURE__ */ cr(aO, [["render", oO]]), sO = {}, lO = { class: "px-4 py-6 sm:px-6 lg:px-8 lg:pl-72" };
function iO(e, t) {
  return h(), W("main", lO, [
    _(e.$slots, "default")
  ]);
}
const kH = /* @__PURE__ */ cr(sO, [["render", iO]]), uO = {};
function dO(e, t) {
  return _(e.$slots, "default");
}
const PH = /* @__PURE__ */ cr(uO, [["render", dO]]), cO = {}, fO = { class: "hidden px-6 py-6 lg:fixed lg:inset-y-0 lg:top-16 lg:z-50 lg:flex lg:w-72 lg:flex-col" }, pO = { class: "gap-y-5 overflow-y-auto" };
function vO(e, t) {
  return h(), W("div", fO, [
    we("div", pO, [
      _(e.$slots, "default")
    ])
  ]);
}
const DH = /* @__PURE__ */ cr(cO, [["render", vO]]), mO = {};
function hO(e, t) {
  return _(e.$slots, "default");
}
const MH = /* @__PURE__ */ cr(mO, [["render", hO]]);
const hv = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), gO = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, a) => a ? a.toUpperCase() : n.toLowerCase()
), yO = (e) => {
  const t = gO(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, bO = (...e) => e.filter((t, n, a) => !!t && t.trim() !== "" && a.indexOf(t) === n).join(" ").trim(), gv = (e) => e === "";
var fo = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const _O = ({
  name: e,
  iconNode: t,
  absoluteStrokeWidth: n,
  "absolute-stroke-width": a,
  strokeWidth: r,
  "stroke-width": o,
  size: s = fo.width,
  color: i = fo.stroke,
  ...u
}, { slots: d }) => en(
  "svg",
  {
    ...fo,
    ...u,
    width: s,
    height: s,
    stroke: i,
    "stroke-width": gv(n) || gv(a) || n === !0 || a === !0 ? Number(r || o || fo["stroke-width"]) * 24 / Number(s) : r || o || fo["stroke-width"],
    class: bO(
      "lucide",
      u.class,
      ...e ? [`lucide-${hv(yO(e))}-icon`, `lucide-${hv(e)}`] : ["lucide-icon"]
    )
  },
  [...t.map((c) => en(...c)), ...d.default ? [d.default()] : []]
);
const yt = (e, t) => (n, { slots: a, attrs: r }) => en(
  _O,
  {
    ...r,
    ...n,
    iconNode: t,
    name: e
  },
  a
);
const wO = yt("arrow-left", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
const xO = yt("arrow-right", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
const no = yt("check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
const Li = yt("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
const zi = yt("chevron-left", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
const Va = yt("chevron-right", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
const CO = yt("chevron-up", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }]
]);
const Wy = yt("circle-check", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
const uf = yt("circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
const Gy = yt("ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
const SO = yt("grip-vertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
const Ky = yt("info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
const df = yt("loader-circle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
const $O = yt("menu", [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
]);
const cf = yt("minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
const Yy = yt("octagon-x", [
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  [
    "path",
    {
      d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z",
      key: "2d38gg"
    }
  ],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
const Xy = yt("panel-left", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
const BO = yt("plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
const kO = yt("search", [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
]);
const Jy = yt("triangle-alert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
const ao = yt("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), PO = {
  type: "button",
  class: "-m-2.5 p-2.5 lg:hidden"
}, qH = /* @__PURE__ */ b({
  __name: "TwoColumnLayoutSidebarTrigger",
  setup(e) {
    return (t, n) => (h(), W("button", PO, [
      n[0] || (n[0] = we("span", { class: "sr-only" }, "Open sidebar", -1)),
      N(l($O), {
        class: "h-6 w-6",
        "aria-hidden": "true"
      })
    ]));
  }
}), yv = "sidebar_state", DO = 3600 * 24 * 7, MO = "18rem", qO = "3rem", EH = "18rem", EO = "b", [ys, TO] = Se("CollapsibleTwoColumnLayout"), AO = ["data-state", "data-collapsible"], TH = /* @__PURE__ */ b({
  __name: "CollapsibleTwoColumnLayout",
  props: {
    defaultOpen: { type: Boolean, default: !Fy?.cookie.includes(`${yv}=false`) },
    open: { type: Boolean, default: void 0 },
    collapsible: { default: "icon" },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ol("(max-width: 1023px)"), o = O(!1), s = /* @__PURE__ */ Ni(n, "open", a, {
      defaultValue: n.defaultOpen ?? !0,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, n.collapsible !== "none" && (document.cookie = `${yv}=${s.value}; path=/; max-age=${DO}`);
    }
    function u(f) {
      o.value = f;
    }
    function d() {
      return r.value ? u(!o.value) : i(!s.value);
    }
    n.collapsible !== "none" && qr("keydown", (f) => {
      f.key === EO && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = q(() => s.value ? "expanded" : "collapsed");
    return TO({
      state: c,
      open: s,
      setOpen: i,
      isMobile: r,
      openMobile: o,
      setOpenMobile: u,
      toggleSidebar: d,
      collapsible: n.collapsible
    }), (f, p) => (h(), x(l(of), { "delay-duration": 0 }, {
      default: y(() => [
        we("div", A({
          style: {
            "--collapsible-sidebar-width": l(MO),
            "--collapsible-sidebar-width-icon": l(qO)
          },
          class: l(R)("group/collapsible-layout h-full bg-background dark:text-white", n.class),
          "data-state": c.value,
          "data-collapsible": e.collapsible
        }, f.$attrs), [
          _(f.$slots, "default")
        ], 16, AO)
      ]),
      _: 3
    }));
  }
}), OO = ["data-state", "data-collapsible"], IO = { class: "flex-1 overflow-y-auto" }, AH = /* @__PURE__ */ b({
  __name: "CollapsibleSidebarDesktop",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = ys(), o = q(() => r === "icon" && n.value === "collapsed");
    return (s, i) => l(a) ? qe("", !0) : (h(), W("div", {
      key: 0,
      class: ae(
        l(R)(
          "fixed inset-y-0 top-16 z-50 flex flex-col px-6 py-6 transition-[width] duration-200 ease-linear",
          o.value ? "w-[var(--collapsible-sidebar-width-icon)] px-2" : "w-[var(--collapsible-sidebar-width)]",
          t.class
        )
      ),
      "data-state": l(n),
      "data-collapsible": l(r)
    }, [
      we("div", IO, [
        _(s.$slots, "default")
      ])
    ], 10, OO));
  }
}), RO = ["data-state"], OH = /* @__PURE__ */ b({
  __name: "CollapsibleMain",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = ys(), o = q(() => r === "icon" && n.value === "collapsed");
    return (s, i) => (h(), W("main", {
      class: ae(
        l(R)(
          "px-4 py-6 transition-[padding-left] duration-200 ease-linear sm:px-6 lg:px-8",
          !l(a) && (o.value ? "lg:pl-[var(--collapsible-sidebar-width-icon)]" : "lg:pl-[var(--collapsible-sidebar-width)]"),
          t.class
        )
      ),
      "data-state": l(n)
    }, [
      _(s.$slots, "default")
    ], 10, RO));
  }
}), IH = /* @__PURE__ */ b({
  __name: "CollapsibleSidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n, collapsible: a } = ys();
    return (r, o) => l(a) !== "none" ? (h(), x(l(gs), {
      key: 0,
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: ae(l(R)("h-7 w-7", t.class)),
      onClick: l(n)
    }, {
      default: y(() => [
        N(l(Xy), { class: "h-5 w-5" }),
        o[0] || (o[0] = we("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"])) : qe("", !0);
  }
}), RH = /* @__PURE__ */ b({
  __name: "Tip",
  props: {
    tooltip: {},
    indicator: { type: Boolean },
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(VO), null, {
      default: y(() => [
        N(l(ff), oe(le(l(r))), {
          default: y(() => [
            N(l(vf), {
              class: ae(e.indicator ? "underline decoration-dotted underline-offset-4" : "")
            }, {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(pf), oe(le(o.$attrs)), {
              default: y(() => [
                _(o.$slots, "tooltip", {}, () => [
                  Re(Ne(e.tooltip), 1)
                ])
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), ff = /* @__PURE__ */ b({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(DA), A({ "data-slot": "tooltip" }, l(r)), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), pf = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(IA), null, {
      default: y(() => [
        N(l(AA), A({ "data-slot": "tooltip-content" }, { ...l(o), ...s.$attrs }, {
          class: l(R)(
            "z-50 w-fit animate-in rounded-md bg-foreground px-3 py-1.5 text-xs text-balance text-background fade-in-0 zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(SA), { class: "z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] bg-foreground fill-foreground" })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), VO = /* @__PURE__ */ b({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 0 },
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(of), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vf = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(VA), A({ "data-slot": "tooltip-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), FO = ["data-active", "data-collapsed"], NO = ["data-active", "data-collapsed"], VH = /* @__PURE__ */ b({
  __name: "CollapsibleMenuButton",
  props: {
    tooltip: {},
    active: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = ys(), o = q(() => r === "icon" && n.value === "collapsed"), s = q(() => t.tooltip && o.value && !a.value);
    return (i, u) => s.value ? (h(), x(l(ff), { key: 0 }, {
      default: y(() => [
        N(l(vf), { "as-child": "" }, {
          default: y(() => [
            we("button", {
              type: "button",
              class: ae(
                l(R)(
                  "flex w-full items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors",
                  "hover:bg-accent hover:text-accent-foreground",
                  e.active && "bg-accent text-accent-foreground",
                  o.value && "justify-center px-2",
                  t.class
                )
              ),
              "data-active": e.active,
              "data-collapsed": o.value
            }, [
              _(i.$slots, "default")
            ], 10, FO)
          ]),
          _: 3
        }),
        N(l(pf), {
          side: "right",
          align: "center"
        }, {
          default: y(() => [
            typeof e.tooltip == "string" ? (h(), W(Ke, { key: 0 }, [
              Re(Ne(e.tooltip), 1)
            ], 64)) : (h(), x(kt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        })
      ]),
      _: 3
    })) : (h(), W("button", {
      key: 1,
      type: "button",
      class: ae(
        l(R)(
          "flex w-full items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors",
          "hover:bg-accent hover:text-accent-foreground",
          e.active && "bg-accent text-accent-foreground",
          o.value && "justify-center px-2",
          t.class
        )
      ),
      "data-active": e.active,
      "data-collapsed": o.value
    }, [
      _(i.$slots, "default")
    ], 10, NO));
  }
}), LO = {
  key: 0,
  class: "mb-2 block px-3 text-xs font-semibold tracking-wider text-muted-foreground uppercase"
}, FH = /* @__PURE__ */ b({
  __name: "CollapsibleMenuGroup",
  props: {
    label: {},
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = ys(), o = q(
      () => r === "icon" && n.value === "collapsed" && !a.value
    );
    return (s, i) => (h(), W("div", {
      class: ae(l(R)("space-y-1", t.class))
    }, [
      e.label && !o.value ? (h(), W("span", LO, Ne(e.label), 1)) : qe("", !0),
      _(s.$slots, "default")
    ], 2));
  }
});
let Sd = 1;
var zO = class {
  subscribers;
  toasts;
  dismissedToasts;
  constructor() {
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
  subscribe = (e) => (this.subscribers.push(e), () => {
    const t = this.subscribers.indexOf(e);
    this.subscribers.splice(t, 1);
  });
  publish = (e) => {
    this.subscribers.forEach((t) => t(e));
  };
  addToast = (e) => {
    this.publish(e), this.toasts = [...this.toasts, e];
  };
  create = (e) => {
    const { message: t, ...n } = e, a = typeof e.id == "number" || e.id && e.id?.length > 0 ? e.id : Sd++, r = this.toasts.find((s) => s.id === a), o = e.dismissible === void 0 ? !0 : e.dismissible;
    return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a), r ? this.toasts = this.toasts.map((s) => s.id === a ? (this.publish({
      ...s,
      ...e,
      id: a,
      title: t
    }), {
      ...s,
      ...e,
      id: a,
      dismissible: o,
      title: t
    }) : s) : this.addToast({
      title: t,
      ...n,
      dismissible: o,
      id: a
    }), a;
  };
  dismiss = (e) => (e ? (this.dismissedToasts.add(e), requestAnimationFrame(() => this.subscribers.forEach((t) => t({
    id: e,
    dismiss: !0
  })))) : this.toasts.forEach((t) => {
    this.subscribers.forEach((n) => n({
      id: t.id,
      dismiss: !0
    }));
  }), e);
  message = (e, t) => this.create({
    ...t,
    message: e,
    type: "default"
  });
  error = (e, t) => this.create({
    ...t,
    type: "error",
    message: e
  });
  success = (e, t) => this.create({
    ...t,
    type: "success",
    message: e
  });
  info = (e, t) => this.create({
    ...t,
    type: "info",
    message: e
  });
  warning = (e, t) => this.create({
    ...t,
    type: "warning",
    message: e
  });
  loading = (e, t) => this.create({
    ...t,
    type: "loading",
    message: e
  });
  promise = (e, t) => {
    if (!t) return;
    let n;
    t.loading !== void 0 && (n = this.create({
      ...t,
      promise: e,
      type: "loading",
      message: t.loading,
      description: typeof t.description != "function" ? t.description : void 0
    }));
    const a = Promise.resolve(e instanceof Function ? e() : e);
    let r = n !== void 0, o;
    const s = a.then(async (u) => {
      if (o = ["resolve", u], lo(u))
        r = !1, this.create({
          id: n,
          type: "default",
          message: u
        });
      else if (UO(u) && !u.ok) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(`HTTP error! status: ${u.status}`) : t.error, f = typeof t.description == "function" ? await t.description(`HTTP error! status: ${u.status}`) : t.description, v = typeof c == "object" && !lo(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (u instanceof Error) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(u) : t.error, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !lo(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (t.success !== void 0) {
        r = !1;
        const c = typeof t.success == "function" ? await t.success(u) : t.success, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !lo(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "success",
          description: f,
          ...v
        });
      }
    }).catch(async (u) => {
      if (o = ["reject", u], t.error !== void 0) {
        r = !1;
        const d = typeof t.error == "function" ? await t.error(u) : t.error, c = typeof t.description == "function" ? await t.description(u) : t.description, p = typeof d == "object" && !lo(d) ? d : {
          message: d || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: c,
          ...p
        });
      }
    }).finally(() => {
      r && (this.dismiss(n), n = void 0), t.finally?.();
    }), i = () => new Promise((u, d) => s.then(() => o[0] === "reject" ? d(o[1]) : u(o[1])).catch(d));
    return typeof n != "string" && typeof n != "number" ? { unwrap: i } : Object.assign(n, { unwrap: i });
  };
  custom = (e, t) => {
    const n = t?.id || Sd++, a = this.toasts.find((o) => o.id === n), r = t?.dismissible === void 0 ? !0 : t.dismissible;
    return this.dismissedToasts.has(n) && this.dismissedToasts.delete(n), a ? this.toasts = this.toasts.map((o) => o.id === n ? (this.publish({
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), {
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }) : o) : this.addToast({
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), n;
  };
  getActiveToasts = () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id));
};
const Xt = new zO();
function HO(e, t) {
  const n = t?.id || Sd++;
  return Xt.create({
    message: e,
    id: n,
    type: "default",
    ...t
  }), n;
}
const UO = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", jO = HO, WO = () => Xt.toasts, GO = () => Xt.getActiveToasts(), zs = Object.assign(jO, {
  success: Xt.success,
  info: Xt.info,
  warning: Xt.warning,
  error: Xt.error,
  custom: Xt.custom,
  message: Xt.message,
  promise: Xt.promise,
  dismiss: Xt.dismiss,
  loading: Xt.loading
}, {
  getHistory: WO,
  getToasts: GO
});
function Hs(e) {
  return e.label !== void 0;
}
const KO = 3, Zy = "24px", Qy = "16px", bv = 4e3, YO = 356, XO = 14, JO = 45, eb = 200;
function ZO() {
  const e = O(!1);
  return Ae(() => {
    const t = () => {
      e.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
  }), { isDocumentHidden: e };
}
function wa(...e) {
  return e.filter(Boolean).join(" ");
}
function QO(e) {
  const [t, n] = e.split("-"), a = [];
  return t && a.push(t), n && a.push(n), a;
}
function eI(e, t) {
  const n = {};
  return [e, t].forEach((a, r) => {
    const o = r === 1, s = o ? "--mobile-offset" : "--offset", i = o ? Qy : Zy;
    function u(d) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((c) => {
        n[`${s}-${c}`] = typeof d == "number" ? `${d}px` : d;
      });
    }
    typeof a == "number" || typeof a == "string" ? u(a) : typeof a == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((d) => {
      a[d] === void 0 ? n[`${s}-${d}`] = i : n[`${s}-${d}`] = typeof a[d] == "number" ? `${a[d]}px` : a[d];
    }) : u(i);
  }), n;
}
const tI = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded",
  "data-testid"
], nI = [
  "aria-label",
  "data-disabled",
  "data-close-button-position"
];
var aI = /* @__PURE__ */ b({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    closeButtonPosition: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = O(null), o = O(null), s = O(!1), i = O(!1), u = O(!1), d = O(!1), c = O(!1), f = O(0), p = O(0), v = O(n.toast.duration || n.duration || bv), m = O(null), g = O(null), w = q(() => n.index === 0), C = q(() => n.index + 1 <= n.visibleToasts), S = q(() => n.toast.type), $ = q(() => n.toast.dismissible !== !1), k = q(() => n.toast.class || ""), B = q(() => n.descriptionClass || ""), D = q(() => {
      const V = n.toast.position || n.position, z = n.heights.filter((re) => re.position === V).findIndex((re) => re.toastId === n.toast.id);
      return z >= 0 ? z : 0;
    }), P = q(() => {
      const V = n.toast.position || n.position;
      return n.heights.filter((z) => z.position === V).reduce((z, re, ie) => ie >= D.value ? z : z + re.height, 0);
    }), E = q(() => D.value * n.gap + P.value || 0), T = q(() => n.toast.closeButton ?? n.closeButton), M = q(() => n.toast.duration || n.duration || bv), I = O(0), F = O(0), J = O(null), ne = q(() => n.position.split("-")), Q = q(() => ne.value[0]), G = q(() => ne.value[1]), H = q(() => typeof n.toast.title != "string"), U = q(() => typeof n.toast.description != "string"), { isDocumentHidden: se } = ZO(), ee = q(() => S.value && S.value === "loading");
    Ce(() => {
      s.value = !0, v.value = M.value;
    }), Ae(async () => {
      if (!s.value || !g.value) return;
      await Pe();
      const V = g.value, te = V.style.height;
      V.style.height = "auto";
      const z = V.getBoundingClientRect().height;
      V.style.height = te, p.value = z, a("update:height", {
        toastId: n.toast.id,
        height: z,
        position: n.toast.position || n.position
      });
    });
    function de() {
      i.value = !0, f.value = E.value, setTimeout(() => {
        a("removeToast", n.toast);
      }, eb);
    }
    function fe() {
      if (ee.value || !$.value) return {};
      de(), n.toast.onDismiss?.(n.toast);
    }
    function _e(V) {
      V.button !== 2 && (ee.value || !$.value || (m.value = /* @__PURE__ */ new Date(), f.value = E.value, V.target.setPointerCapture(V.pointerId), V.target.tagName !== "BUTTON" && (u.value = !0, J.value = {
        x: V.clientX,
        y: V.clientY
      })));
    }
    function ye() {
      if (d.value || !$.value) return;
      J.value = null;
      const V = Number(g.value?.style.getPropertyValue("--swipe-amount-x").replace("px", "") || 0), te = Number(g.value?.style.getPropertyValue("--swipe-amount-y").replace("px", "") || 0), z = (/* @__PURE__ */ new Date()).getTime() - (m.value?.getTime() || 0), re = r.value === "x" ? V : te, ie = Math.abs(re) / z;
      if (Math.abs(re) >= JO || ie > 0.11) {
        f.value = E.value, n.toast.onDismiss?.(n.toast), r.value === "x" ? o.value = V > 0 ? "right" : "left" : o.value = te > 0 ? "down" : "up", de(), d.value = !0;
        return;
      } else
        g.value?.style.setProperty("--swipe-amount-x", "0px"), g.value?.style.setProperty("--swipe-amount-y", "0px");
      c.value = !1, u.value = !1, r.value = null;
    }
    function Te(V) {
      if (!J.value || !$.value || (window?.getSelection()?.toString()?.length ?? !1)) return;
      const z = V.clientY - J.value.y, re = V.clientX - J.value.x, ie = n.swipeDirections ?? QO(n.position);
      !r.value && (Math.abs(re) > 1 || Math.abs(z) > 1) && (r.value = Math.abs(re) > Math.abs(z) ? "x" : "y");
      let L = {
        x: 0,
        y: 0
      };
      const be = (xe) => 1 / (1.5 + Math.abs(xe) / 20);
      if (r.value === "y") {
        if (ie.includes("top") || ie.includes("bottom")) if (ie.includes("top") && z < 0 || ie.includes("bottom") && z > 0) L.y = z;
        else {
          const xe = z * be(z);
          L.y = Math.abs(xe) < Math.abs(z) ? xe : z;
        }
      } else if (r.value === "x" && (ie.includes("left") || ie.includes("right")))
        if (ie.includes("left") && re < 0 || ie.includes("right") && re > 0) L.x = re;
        else {
          const xe = re * be(re);
          L.x = Math.abs(xe) < Math.abs(re) ? xe : re;
        }
      (Math.abs(L.x) > 0 || Math.abs(L.y) > 0) && (c.value = !0), g.value?.style.setProperty("--swipe-amount-x", `${L.x}px`), g.value?.style.setProperty("--swipe-amount-y", `${L.y}px`);
    }
    Ce(() => {
      if (s.value = !0, !g.value) return;
      const V = g.value.getBoundingClientRect().height;
      p.value = V;
      const te = [{
        toastId: n.toast.id,
        height: V,
        position: n.toast.position
      }, ...n.heights];
      a("update:heights", te);
    }), ar(() => {
      g.value && a("removeToast", n.toast);
    }), Ae((V) => {
      if (n.toast.promise && S.value === "loading" || n.toast.duration === 1 / 0 || n.toast.type === "loading") return;
      let te;
      const z = () => {
        if (F.value < I.value) {
          const ie = (/* @__PURE__ */ new Date()).getTime() - I.value;
          v.value = v.value - ie;
        }
        F.value = (/* @__PURE__ */ new Date()).getTime();
      }, re = () => {
        v.value !== 1 / 0 && (I.value = (/* @__PURE__ */ new Date()).getTime(), te = setTimeout(() => {
          n.toast.onAutoClose?.(n.toast), de();
        }, v.value));
      };
      n.expanded || n.interacting || se.value ? z() : re(), V(() => {
        clearTimeout(te);
      });
    }), me(() => n.toast.delete, (V) => {
      V !== void 0 && V && (de(), n.toast.onDismiss?.(n.toast));
    }, { deep: !0 });
    function ce() {
      u.value = !1, r.value = null, J.value = null;
    }
    return (V, te) => (h(), W("li", {
      tabindex: "0",
      ref_key: "toastRef",
      ref: g,
      class: ae(l(wa)(n.class, k.value, V.classes?.toast, V.toast.classes?.toast, V.classes?.[S.value], V.toast?.classes?.[S.value])),
      "data-sonner-toast": "",
      "data-rich-colors": V.toast.richColors ?? V.defaultRichColors,
      "data-styled": !(V.toast.component || V.toast?.unstyled || V.unstyled),
      "data-mounted": s.value,
      "data-promise": !!V.toast.promise,
      "data-swiped": c.value,
      "data-removed": i.value,
      "data-visible": C.value,
      "data-y-position": Q.value,
      "data-x-position": G.value,
      "data-index": V.index,
      "data-front": w.value,
      "data-swiping": u.value,
      "data-dismissible": $.value,
      "data-type": S.value,
      "data-invert": V.toast.invert || V.invert,
      "data-swipe-out": d.value,
      "data-swipe-direction": o.value,
      "data-expanded": !!(V.expanded || V.expandByDefault && s.value),
      "data-testid": V.toast.testId,
      style: dt({
        "--index": V.index,
        "--toasts-before": V.index,
        "--z-index": V.toasts.length - V.index,
        "--offset": `${i.value ? f.value : E.value}px`,
        "--initial-height": V.expandByDefault ? "auto" : `${p.value}px`,
        ...V.style,
        ...n.toast.style
      }),
      onDragend: ce,
      onPointerdown: _e,
      onPointerup: ye,
      onPointermove: Te
    }, [T.value && !V.toast.component && S.value !== "loading" ? (h(), W("button", {
      key: 0,
      "aria-label": V.closeButtonAriaLabel || "Close toast",
      "data-disabled": ee.value,
      "data-close-button": "true",
      "data-close-button-position": V.closeButtonPosition,
      class: ae(l(wa)(V.classes?.closeButton, V.toast?.classes?.closeButton)),
      onClick: fe
    }, [V.icons?.close ? (h(), x(kt(V.icons?.close), { key: 0 })) : _(V.$slots, "close-icon", { key: 1 })], 10, nI)) : qe("v-if", !0), V.toast.component ? (h(), x(kt(V.toast.component), A({ key: 1 }, V.toast.componentProps, {
      onCloseToast: fe,
      isPaused: V.$props.expanded || V.$props.interacting || l(se)
    }), null, 16, ["isPaused"])) : (h(), W(Ke, { key: 2 }, [
      S.value !== "default" || V.toast.icon || V.toast.promise ? (h(), W("div", {
        key: 0,
        "data-icon": "",
        class: ae(l(wa)(V.classes?.icon, V.toast?.classes?.icon))
      }, [V.toast.icon ? (h(), x(kt(V.toast.icon), { key: 0 })) : (h(), W(Ke, { key: 1 }, [S.value === "loading" ? _(V.$slots, "loading-icon", { key: 0 }) : S.value === "success" ? _(V.$slots, "success-icon", { key: 1 }) : S.value === "error" ? _(V.$slots, "error-icon", { key: 2 }) : S.value === "warning" ? _(V.$slots, "warning-icon", { key: 3 }) : S.value === "info" ? _(V.$slots, "info-icon", { key: 4 }) : qe("v-if", !0)], 64))], 2)) : qe("v-if", !0),
      we("div", {
        "data-content": "",
        class: ae(l(wa)(V.classes?.content, V.toast?.classes?.content))
      }, [we("div", {
        "data-title": "",
        class: ae(l(wa)(V.classes?.title, V.toast.classes?.title))
      }, [H.value ? (h(), x(kt(V.toast.title), oe(A({ key: 0 }, V.toast.componentProps)), null, 16)) : (h(), W(Ke, { key: 1 }, [Re(Ne(V.toast.title), 1)], 64))], 2), V.toast.description ? (h(), W("div", {
        key: 0,
        "data-description": "",
        class: ae(l(wa)(V.descriptionClass, B.value, V.classes?.description, V.toast.classes?.description))
      }, [U.value ? (h(), x(kt(V.toast.description), oe(A({ key: 0 }, V.toast.componentProps)), null, 16)) : (h(), W(Ke, { key: 1 }, [Re(Ne(V.toast.description), 1)], 64))], 2)) : qe("v-if", !0)], 2),
      V.toast.cancel ? (h(), W("button", {
        key: 1,
        style: dt(V.toast.cancelButtonStyle || V.cancelButtonStyle),
        class: ae(l(wa)(V.classes?.cancelButton, V.toast.classes?.cancelButton)),
        "data-button": "",
        "data-cancel": "",
        onClick: te[0] || (te[0] = (z) => {
          l(Hs)(V.toast.cancel) && $.value && (V.toast.cancel.onClick?.(z), de());
        })
      }, Ne(l(Hs)(V.toast.cancel) ? V.toast.cancel?.label : V.toast.cancel), 7)) : qe("v-if", !0),
      V.toast.action ? (h(), W("button", {
        key: 2,
        style: dt(V.toast.actionButtonStyle || V.actionButtonStyle),
        class: ae(l(wa)(V.classes?.actionButton, V.toast.classes?.actionButton)),
        "data-button": "",
        "data-action": "",
        onClick: te[1] || (te[1] = (z) => {
          l(Hs)(V.toast.action) && (V.toast.action.onClick?.(z), !z.defaultPrevented && de());
        })
      }, Ne(l(Hs)(V.toast.action) ? V.toast.action?.label : V.toast.action), 7)) : qe("v-if", !0)
    ], 64))], 46, tI));
  }
}), rI = aI, bs = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t) n[a] = r;
  return n;
};
const oI = {}, sI = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function lI(e, t) {
  return h(), W("svg", sI, t[0] || (t[0] = [we("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), we("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var iI = /* @__PURE__ */ bs(oI, [["render", lI]]);
const uI = ["data-visible"], dI = { class: "sonner-spinner" };
var cI = /* @__PURE__ */ b({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(e) {
    const t = Array(12).fill(0);
    return (n, a) => (h(), W("div", {
      class: "sonner-loading-wrapper",
      "data-visible": n.visible
    }, [we("div", dI, [(h(!0), W(Ke, null, Nt(l(t), (r) => (h(), W("div", {
      key: `spinner-bar-${r}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, uI));
  }
}), fI = cI;
const pI = {}, vI = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function mI(e, t) {
  return h(), W("svg", vI, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var hI = /* @__PURE__ */ bs(pI, [["render", mI]]);
const gI = {}, yI = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function bI(e, t) {
  return h(), W("svg", yI, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var _I = /* @__PURE__ */ bs(gI, [["render", bI]]);
const wI = {}, xI = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function CI(e, t) {
  return h(), W("svg", xI, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var SI = /* @__PURE__ */ bs(wI, [["render", CI]]);
const $I = {}, BI = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function kI(e, t) {
  return h(), W("svg", BI, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var PI = /* @__PURE__ */ bs($I, [["render", kI]]);
const DI = ["aria-label"], MI = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position"
], qI = typeof window < "u" && typeof document < "u";
function EI() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const e = document.documentElement.getAttribute("dir");
  return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e;
}
var TI = /* @__PURE__ */ b({
  name: "Toaster",
  inheritAttrs: !1,
  __name: "Toaster",
  props: {
    id: {},
    invert: {
      type: Boolean,
      default: !1
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    closeButtonPosition: { default: "top-left" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: !1
    },
    expand: {
      type: Boolean,
      default: !1
    },
    duration: {},
    gap: { default: XO },
    visibleToasts: { default: KO },
    closeButton: {
      type: Boolean,
      default: !1
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: Zy },
    mobileOffset: { default: Qy },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(e) {
    const t = e, n = m0(), a = O([]), r = q(() => t.id ? a.value.filter((M) => M.toasterId === t.id) : a.value.filter((M) => !M.toasterId));
    function o(M, I) {
      return r.value.filter((F) => !F.position && I === 0 || F.position === M);
    }
    const s = q(() => {
      const M = r.value.filter((I) => I.position).map((I) => I.position);
      return M.length > 0 ? Array.from(new Set([t.position].concat(M))) : [t.position];
    }), i = q(() => {
      const M = {};
      return s.value.forEach((I) => {
        M[I] = a.value.filter((F) => F.position === I);
      }), M;
    }), u = O([]), d = O({}), c = O(!1);
    Ae(() => {
      s.value.forEach((M) => {
        M in d.value || (d.value[M] = !1);
      });
    });
    const f = O(t.theme !== "system" ? t.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = O(null), v = O(null), m = O(!1), g = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function w(M) {
      a.value.find((I) => I.id === M.id)?.delete || Xt.dismiss(M.id), a.value = a.value.filter(({ id: I }) => I !== M.id), setTimeout(() => {
        a.value.find((I) => I.id === M.id) || (u.value = u.value.filter((I) => I.toastId !== M.id));
      }, eb + 50);
    }
    function C(M) {
      m.value && !M.currentTarget?.contains?.(M.relatedTarget) && (m.value = !1, v.value && (v.value.focus({ preventScroll: !0 }), v.value = null));
    }
    function S(M) {
      M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || m.value || (m.value = !0, v.value = M.relatedTarget);
    }
    function $(M) {
      M.target && M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || (c.value = !0);
    }
    Ae((M) => {
      const I = Xt.subscribe((F) => {
        if (F.dismiss) {
          requestAnimationFrame(() => {
            a.value = a.value.map((J) => J.id === F.id ? {
              ...J,
              delete: !0
            } : J);
          });
          return;
        }
        Pe(() => {
          const J = a.value.findIndex((ne) => ne.id === F.id);
          J !== -1 ? a.value = [
            ...a.value.slice(0, J),
            {
              ...a.value[J],
              ...F
            },
            ...a.value.slice(J + 1)
          ] : a.value = [F, ...a.value];
        });
      });
      M(I);
    }), Ae((M) => {
      if (typeof window > "u") return;
      if (t.theme !== "system") {
        f.value = t.theme;
        return;
      }
      const I = window.matchMedia("(prefers-color-scheme: dark)"), F = (ne) => {
        f.value = ne ? "dark" : "light";
      };
      F(I.matches);
      const J = (ne) => {
        F(ne.matches);
      };
      try {
        I.addEventListener("change", J);
      } catch {
        I.addListener(J);
      }
      M(() => {
        try {
          I.removeEventListener("change", J);
        } catch {
          I.removeListener(J);
        }
      });
    }), Ae(() => {
      p.value && v.value && (v.value.focus({ preventScroll: !0 }), v.value = null, m.value = !1);
    }), Ae(() => {
      a.value.length <= 1 && Object.keys(d.value).forEach((M) => {
        d.value[M] = !1;
      });
    }), Ae((M) => {
      function I(F) {
        const J = t.hotkey.every((G) => F[G] || F.code === G), ne = Array.isArray(p.value) ? p.value[0] : p.value;
        J && (s.value.forEach((G) => {
          d.value[G] = !0;
        }), ne?.focus());
        const Q = document.activeElement === p.value || ne?.contains(document.activeElement);
        F.code === "Escape" && Q && s.value.forEach((G) => {
          d.value[G] = !1;
        });
      }
      qI && (document.addEventListener("keydown", I), M(() => {
        document.removeEventListener("keydown", I);
      }));
    });
    function k(M) {
      const I = M.currentTarget, F = I.getAttribute("data-y-position") + "-" + I.getAttribute("data-x-position");
      d.value[F] = !0;
    }
    function B(M) {
      if (!c.value) {
        const I = M.currentTarget, F = I.getAttribute("data-y-position") + "-" + I.getAttribute("data-x-position");
        d.value[F] = !1;
      }
    }
    function D() {
      Object.keys(d.value).forEach((M) => {
        d.value[M] = !1;
      });
    }
    function P() {
      c.value = !1;
    }
    function E(M) {
      u.value = M;
    }
    function T(M) {
      const I = u.value.findIndex((F) => F.toastId === M.toastId);
      if (I !== -1) u.value[I] = M;
      else {
        const F = u.value.findIndex((J) => J.position === M.position);
        F !== -1 ? u.value.splice(F, 0, M) : u.value.unshift(M);
      }
    }
    return (M, I) => (h(), W(Ke, null, [qe(" Remove item from normal navigation flow, only available via hotkey "), we("section", {
      "aria-label": `${M.containerAriaLabel} ${l(g)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(h(!0), W(Ke, null, Nt(s.value, (F, J) => (h(), W("ol", A({
      key: F,
      ref_for: !0,
      ref_key: "listRef",
      ref: p,
      "data-sonner-toaster": "",
      "data-sonner-theme": f.value,
      class: t.class,
      dir: M.dir === "auto" ? EI() : M.dir,
      tabIndex: -1,
      "data-theme": M.theme,
      "data-rich-colors": M.richColors,
      "data-y-position": F.split("-")[0],
      "data-x-position": F.split("-")[1],
      style: {
        "--front-toast-height": `${u.value[0]?.height || 0}px`,
        "--width": `${l(YO)}px`,
        "--gap": `${M.gap}px`,
        ...M.style,
        ...l(n).style,
        ...l(eI)(M.offset, M.mobileOffset)
      }
    }, { ref_for: !0 }, M.$attrs, {
      onBlur: C,
      onFocus: S,
      onMouseenter: k,
      onMousemove: k,
      onMouseleave: B,
      onDragend: D,
      onPointerdown: $,
      onPointerup: P
    }), [(h(!0), W(Ke, null, Nt(o(F, J), (ne, Q) => (h(), x(rI, {
      key: ne.id,
      heights: u.value,
      icons: M.icons,
      index: Q,
      toast: ne,
      defaultRichColors: M.richColors,
      duration: M.toastOptions?.duration ?? M.duration,
      class: ae(M.toastOptions?.class ?? ""),
      descriptionClass: M.toastOptions?.descriptionClass,
      invert: M.invert,
      visibleToasts: M.visibleToasts,
      closeButton: M.toastOptions?.closeButton ?? M.closeButton,
      interacting: c.value,
      position: F,
      closeButtonPosition: M.toastOptions?.closeButtonPosition ?? M.closeButtonPosition,
      style: dt(M.toastOptions?.style),
      unstyled: M.toastOptions?.unstyled,
      classes: M.toastOptions?.classes,
      cancelButtonStyle: M.toastOptions?.cancelButtonStyle,
      actionButtonStyle: M.toastOptions?.actionButtonStyle,
      "close-button-aria-label": M.toastOptions?.closeButtonAriaLabel,
      toasts: i.value[F],
      expandByDefault: M.expand,
      gap: M.gap,
      expanded: d.value[F] || !1,
      swipeDirections: t.swipeDirections,
      "onUpdate:heights": E,
      "onUpdate:height": T,
      onRemoveToast: w
    }, {
      "close-icon": y(() => [_(M.$slots, "close-icon", {}, () => [N(iI)])]),
      "loading-icon": y(() => [_(M.$slots, "loading-icon", {}, () => [N(fI, { visible: ne.type === "loading" }, null, 8, ["visible"])])]),
      "success-icon": y(() => [_(M.$slots, "success-icon", {}, () => [N(hI)])]),
      "error-icon": y(() => [_(M.$slots, "error-icon", {}, () => [N(PI)])]),
      "warning-icon": y(() => [_(M.$slots, "warning-icon", {}, () => [N(SI)])]),
      "info-icon": y(() => [_(M.$slots, "info-icon", {}, () => [N(_I)])]),
      _: 2
    }, 1032, [
      "heights",
      "icons",
      "index",
      "toast",
      "defaultRichColors",
      "duration",
      "class",
      "descriptionClass",
      "invert",
      "visibleToasts",
      "closeButton",
      "interacting",
      "position",
      "closeButtonPosition",
      "style",
      "unstyled",
      "classes",
      "cancelButtonStyle",
      "actionButtonStyle",
      "close-button-aria-label",
      "toasts",
      "expandByDefault",
      "gap",
      "expanded",
      "swipeDirections"
    ]))), 128))], 16, MI))), 128))], 8, DI)], 2112));
  }
}), tb = TI;
function AI(e, t) {
  return Object.entries(e).map(([n, a]) => t === "key" ? n : t === "both" ? `${n}: ${a}` : a).join(`
`);
}
function OI() {
  return {
    info: (e) => {
      zs.info("FYI", {
        description: e
      });
    },
    success: (e) => {
      zs.success("Success", {
        description: e
      });
    },
    warning: (e) => {
      zs.warning("Warning", {
        description: e
      });
    },
    error: (e, t = "value") => {
      zs.error("Oh snap! Some errors were encountered.", {
        description: AI(e, t)
      });
    }
  };
}
const NH = /* @__PURE__ */ b({
  __name: "Flasher",
  props: {
    class: {},
    info: {},
    success: {},
    warning: {},
    errors: {},
    objectFormat: { default: "value" }
  },
  setup(e) {
    const t = e, {
      info: n,
      success: a,
      warning: r,
      error: o
    } = OI();
    return me(
      () => t.info,
      (s) => {
        s && n(t.info);
      },
      {
        immediate: !0
      }
    ), me(
      () => t.success,
      (s) => {
        s && a(t.success);
      },
      { immediate: !0 }
    ), me(
      () => t.warning,
      (s) => {
        s && r(t.warning);
      },
      { immediate: !0 }
    ), me(
      () => t.errors,
      () => {
        t.errors !== void 0 && Object.keys(t.errors).length > 0 && o(t.errors, t.objectFormat);
      }
    ), (s, i) => (h(), x(l(tb), {
      class: ae(l(R)("toaster group", t.class)),
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          success: "group-[.toaster]:border-success",
          error: "group-[.toaster]:border-destructive",
          warning: "group-[.toaster]:border-warning",
          info: "group-[.toaster]:border-primary",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, {
      "success-icon": y(() => [
        N(l(Wy), { class: "size-4 text-success" })
      ]),
      "info-icon": y(() => [
        N(l(Ky), { class: "size-4 text-primary" })
      ]),
      "warning-icon": y(() => [
        N(l(Jy), { class: "size-4 text-warning" })
      ]),
      "error-icon": y(() => [
        N(l(Yy), { class: "size-4 text-destructive" })
      ]),
      "loading-icon": y(() => [
        we("div", null, [
          N(l(df), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": y(() => [
        N(l(ao), { class: "size-4" })
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), II = { class: "flex items-center justify-between space-y-2" }, RI = { class: "flex items-center space-x-2" }, LH = /* @__PURE__ */ b({
  __name: "Heading",
  props: {
    as: { default: "h2" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", II, [
      (h(), x(kt(e.as), {
        class: ae(l(R)("text-3xl font-bold tracking-tight", t.class))
      }, {
        default: y(() => [
          _(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])),
      we("div", RI, [
        _(n.$slots, "actions")
      ])
    ]));
  }
}), VI = /* @__PURE__ */ b({
  __name: "Accordion",
  props: {
    collapsible: { type: Boolean },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(E1), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zH = /* @__PURE__ */ b({
  __name: "Accord",
  props: {
    content: {},
    collapsible: { type: Boolean, default: !0 },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: { default: "single" },
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(VI, oe(le(l(r))), {
      default: y(() => [
        (h(!0), W(Ke, null, Nt(e.content, (i, u) => (h(), x(l(NI), {
          key: u,
          value: "item-" + u
        }, {
          default: y(() => [
            N(l(LI), null, {
              default: y(() => [
                _(o.$slots, u + ".title", { item: i }, () => [
                  Re(Ne(i.title), 1)
                ])
              ]),
              _: 2
            }, 1024),
            N(l(FI), null, {
              default: y(() => [
                _(o.$slots, u + ".content", { item: i }, () => [
                  Re(Ne(i.content), 1)
                ])
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1032, ["value"]))), 128))
      ]),
      _: 3
    }, 16));
  }
}), FI = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(R1), A(l(n), { class: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down" }), {
      default: y(() => [
        we("div", {
          class: ae(l(R)("pt-0 pb-4", t.class))
        }, [
          _(a.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16));
  }
}), NI = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(O1), A(l(a), {
      class: l(R)("border-b", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), LI = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(F1), { class: "flex" }, {
      default: y(() => [
        N(l(L1), A(l(n), {
          class: l(R)(
            "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
            t.class
          )
        }), {
          default: y(() => [
            _(a.$slots, "default"),
            _(a.$slots, "icon", {}, () => [
              N(l(Li), { class: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), HH = /* @__PURE__ */ b({
  __name: "Alert",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)(l(zI)({ variant: e.variant }), t.class)),
      role: "alert"
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), UH = /* @__PURE__ */ b({
  __name: "AlertDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("text-sm [&_p]:leading-relaxed", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), jH = /* @__PURE__ */ b({
  __name: "AlertTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("h5", {
      class: ae(l(R)("mb-1 leading-none font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), zI = an(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), WH = /* @__PURE__ */ b({
  __name: "AspectRatio",
  props: {
    ratio: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Wx), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), GH = /* @__PURE__ */ b({
  __name: "Avatar",
  props: {
    class: {},
    size: { default: "sm" },
    shape: { default: "circle" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Yx), {
      class: ae(l(R)(l(HI)({ size: e.size, shape: e.shape }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), KH = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Jx), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), YH = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {},
    referrerPolicy: {},
    crossOrigin: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(eC), A(t, { class: "h-full w-full object-cover" }), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), HI = an(
  "inline-flex items-center justify-center font-normal text-foreground select-none shrink-0 bg-secondary overflow-hidden",
  {
    variants: {
      size: {
        sm: "h-10 w-10 text-xs",
        base: "h-16 w-16 text-2xl",
        lg: "h-32 w-32 text-5xl"
      },
      shape: {
        circle: "rounded-full",
        square: "rounded-md"
      }
    }
  }
), XH = /* @__PURE__ */ b({
  __name: "Badge",
  props: {
    variant: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)(l(UI)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), UI = an(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        success: "border-transparent bg-success text-success-foreground shadow hover:bg-success/80",
        warning: "border-transparent bg-warning text-warning-foreground shadow hover:bg-warning/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), JH = /* @__PURE__ */ b({
  __name: "Breadcrumb",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("nav", {
      "aria-label": "breadcrumb",
      class: ae(t.class)
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), ZH = /* @__PURE__ */ b({
  __name: "BreadcrumbEllipsis",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(R)("flex h-9 w-9 items-center justify-center", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(Gy), { class: "h-4 w-4" })
      ]),
      a[0] || (a[0] = we("span", { class: "sr-only" }, "More", -1))
    ], 2));
  }
}), QH = /* @__PURE__ */ b({
  __name: "BreadcrumbItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("li", {
      class: ae(l(R)("inline-flex items-center gap-1.5", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), e7 = /* @__PURE__ */ b({
  __name: "BreadcrumbLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(R)("transition-colors hover:text-foreground", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), t7 = /* @__PURE__ */ b({
  __name: "BreadcrumbList",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("ol", {
      class: ae(
        l(R)(
          "flex flex-wrap items-center gap-1.5 text-sm break-words text-muted-foreground sm:gap-2.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), n7 = /* @__PURE__ */ b({
  __name: "BreadcrumbPage",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      role: "link",
      "aria-disabled": "true",
      "aria-current": "page",
      class: ae(l(R)("font-normal text-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), a7 = /* @__PURE__ */ b({
  __name: "BreadcrumbSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("li", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(R)("[&>svg]:size-3.5", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(Va))
      ])
    ], 2));
  }
}), jI = ["data-orientation"], r7 = /* @__PURE__ */ b({
  __name: "ButtonGroup",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      class: ae(l(R)(l(WI)({ orientation: t.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, jI));
  }
}), Hi = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Xc), A({ "data-slot": "separator" }, l(n), {
      class: l(R)(
        "shrink-0 bg-border data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), o7 = /* @__PURE__ */ b({
  __name: "ButtonGroupSeparator",
  props: {
    orientation: { default: "vertical" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Hi), A({ "data-slot": "button-group-separator" }, l(n), {
      orientation: t.orientation,
      class: l(R)("relative !m-0 self-stretch bg-input data-[orientation=vertical]:h-auto", t.class)
    }), null, 16, ["orientation", "class"]));
  }
}), s7 = /* @__PURE__ */ b({
  __name: "ButtonGroupText",
  props: {
    class: {},
    orientation: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(R)(
          "flex items-center gap-2 rounded-md border bg-muted px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as", "as-child", "class"]));
  }
}), WI = an(
  "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*:focus-visible]:relative [&>*:focus-visible]:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  {
    variants: {
      orientation: {
        horizontal: "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
        vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
      }
    },
    defaultVariants: {
      orientation: "horizontal"
    }
  }
), GI = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, l7 = /* @__PURE__ */ b({
  __name: "Calendar",
  props: {
    defaultValue: {},
    defaultPlaceholder: {},
    placeholder: {},
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    modelValue: {},
    multiple: { type: Boolean },
    disableDaysOutsideCurrentView: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(dC), A({
      class: l(R)("p-3", n.class)
    }, l(o)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(e3), null, {
          default: y(() => [
            N(l(a3)),
            N(l(t3)),
            N(l(n3))
          ]),
          _: 1
        }),
        we("div", GI, [
          (h(!0), W(Ke, null, Nt(u, (c) => (h(), x(l(XI), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(ZI), null, {
                default: y(() => [
                  N(l(_v), null, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Nt(d, (f) => (h(), x(l(QI), { key: f }, {
                        default: y(() => [
                          Re(Ne(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(JI), null, {
                default: y(() => [
                  (h(!0), W(Ke, null, Nt(c.rows, (f, p) => (h(), x(l(_v), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Nt(f, (v) => (h(), x(l(KI), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(YI), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), KI = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(fC), A({
      class: l(R)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:rounded-md [&:has([data-selected])]:bg-accent [&:has([data-selected][data-outside-view])]:bg-accent/50",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), YI = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(vC), A({
      class: l(R)(
        l(Kt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selected
        "data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:opacity-100 data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:bg-accent/50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), XI = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(hC), A({
      class: l(R)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), JI = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(yC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ZI = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(_C), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _v = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(xC), A({
      class: l(R)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), QI = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(SC), A({
      class: l(R)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), e3 = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(BC), A({
      class: l(R)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), t3 = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(PC), A({
      class: l(R)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(Ne(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), n3 = /* @__PURE__ */ b({
  __name: "CalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(MC), A({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Va), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), a3 = /* @__PURE__ */ b({
  __name: "CalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(EC), A({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), r3 = /* @__PURE__ */ b({
  __name: "Card",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("rounded-xl border bg-card text-card-foreground shadow", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), o3 = /* @__PURE__ */ b({
  __name: "CardContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), i7 = /* @__PURE__ */ b({
  __name: "CardDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      class: ae(l(R)("text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), u7 = /* @__PURE__ */ b({
  __name: "CardFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("flex items-center p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), s3 = /* @__PURE__ */ b({
  __name: "CardHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("flex flex-col gap-y-1.5 p-6", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), l3 = /* @__PURE__ */ b({
  __name: "CardTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("h3", {
      class: ae(l(R)("leading-none font-semibold tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
});
function i3(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function wv(e) {
  return i3(e) || Array.isArray(e);
}
function u3() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function mf(e, t) {
  const n = Object.keys(e), a = Object.keys(t);
  if (n.length !== a.length) return !1;
  const r = JSON.stringify(Object.keys(e.breakpoints || {})), o = JSON.stringify(Object.keys(t.breakpoints || {}));
  return r !== o ? !1 : n.every((s) => {
    const i = e[s], u = t[s];
    return typeof i == "function" ? `${i}` == `${u}` : !wv(i) || !wv(u) ? i === u : mf(i, u);
  });
}
function xv(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function d3(e, t) {
  if (e.length !== t.length) return !1;
  const n = xv(e), a = xv(t);
  return n.every((r, o) => {
    const s = a[o];
    return mf(r, s);
  });
}
function hf(e) {
  return typeof e == "number";
}
function $d(e) {
  return typeof e == "string";
}
function Ui(e) {
  return typeof e == "boolean";
}
function Cv(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function vt(e) {
  return Math.abs(e);
}
function gf(e) {
  return Math.sign(e);
}
function Do(e, t) {
  return vt(e - t);
}
function c3(e, t) {
  if (e === 0 || t === 0 || vt(e) <= vt(t)) return 0;
  const n = Do(vt(e), vt(t));
  return vt(n / e);
}
function f3(e) {
  return Math.round(e * 100) / 100;
}
function zo(e) {
  return Ho(e).map(Number);
}
function Dn(e) {
  return e[_s(e)];
}
function _s(e) {
  return Math.max(0, e.length - 1);
}
function yf(e, t) {
  return t === _s(e);
}
function Sv(e, t = 0) {
  return Array.from(Array(e), (n, a) => t + a);
}
function Ho(e) {
  return Object.keys(e);
}
function nb(e, t) {
  return [e, t].reduce((n, a) => (Ho(a).forEach((r) => {
    const o = n[r], s = a[r], i = Cv(o) && Cv(s);
    n[r] = i ? nb(o, s) : s;
  }), n), {});
}
function Bd(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function p3(e, t) {
  const n = {
    start: a,
    center: r,
    end: o
  };
  function a() {
    return 0;
  }
  function r(u) {
    return o(u) / 2;
  }
  function o(u) {
    return t - u;
  }
  function s(u, d) {
    return $d(e) ? n[e](u) : e(t, u, d);
  }
  return {
    measure: s
  };
}
function Uo() {
  let e = [];
  function t(r, o, s, i = {
    passive: !0
  }) {
    let u;
    if ("addEventListener" in r)
      r.addEventListener(o, s, i), u = () => r.removeEventListener(o, s, i);
    else {
      const d = r;
      d.addListener(s), u = () => d.removeListener(s);
    }
    return e.push(u), a;
  }
  function n() {
    e = e.filter((r) => r());
  }
  const a = {
    add: t,
    clear: n
  };
  return a;
}
function v3(e, t, n, a) {
  const r = Uo(), o = 1e3 / 60;
  let s = null, i = 0, u = 0;
  function d() {
    r.add(e, "visibilitychange", () => {
      e.hidden && m();
    });
  }
  function c() {
    v(), r.clear();
  }
  function f(w) {
    if (!u) return;
    s || (s = w, n(), n());
    const C = w - s;
    for (s = w, i += C; i >= o; )
      n(), i -= o;
    const S = i / o;
    a(S), u && (u = t.requestAnimationFrame(f));
  }
  function p() {
    u || (u = t.requestAnimationFrame(f));
  }
  function v() {
    t.cancelAnimationFrame(u), s = null, i = 0, u = 0;
  }
  function m() {
    s = null, i = 0;
  }
  return {
    init: d,
    destroy: c,
    start: p,
    stop: v,
    update: n,
    render: a
  };
}
function m3(e, t) {
  const n = t === "rtl", a = e === "y", r = a ? "y" : "x", o = a ? "x" : "y", s = !a && n ? -1 : 1, i = c(), u = f();
  function d(m) {
    const {
      height: g,
      width: w
    } = m;
    return a ? g : w;
  }
  function c() {
    return a ? "top" : n ? "right" : "left";
  }
  function f() {
    return a ? "bottom" : n ? "left" : "right";
  }
  function p(m) {
    return m * s;
  }
  return {
    scroll: r,
    cross: o,
    startEdge: i,
    endEdge: u,
    measureSize: d,
    direction: p
  };
}
function Za(e = 0, t = 0) {
  const n = vt(e - t);
  function a(d) {
    return d < e;
  }
  function r(d) {
    return d > t;
  }
  function o(d) {
    return a(d) || r(d);
  }
  function s(d) {
    return o(d) ? a(d) ? e : t : d;
  }
  function i(d) {
    return n ? d - n * Math.ceil((d - t) / n) : d;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: s,
    reachedAny: o,
    reachedMax: r,
    reachedMin: a,
    removeOffset: i
  };
}
function ab(e, t, n) {
  const {
    constrain: a
  } = Za(0, e), r = e + 1;
  let o = s(t);
  function s(p) {
    return n ? vt((r + p) % r) : a(p);
  }
  function i() {
    return o;
  }
  function u(p) {
    return o = s(p), f;
  }
  function d(p) {
    return c().set(i() + p);
  }
  function c() {
    return ab(e, i(), n);
  }
  const f = {
    get: i,
    set: u,
    add: d,
    clone: c
  };
  return f;
}
function h3(e, t, n, a, r, o, s, i, u, d, c, f, p, v, m, g, w, C, S) {
  const {
    cross: $,
    direction: k
  } = e, B = ["INPUT", "SELECT", "TEXTAREA"], D = {
    passive: !1
  }, P = Uo(), E = Uo(), T = Za(50, 225).constrain(v.measure(20)), M = {
    mouse: 300,
    touch: 400
  }, I = {
    mouse: 500,
    touch: 600
  }, F = m ? 43 : 25;
  let J = !1, ne = 0, Q = 0, G = !1, H = !1, U = !1, se = !1;
  function ee(L) {
    if (!S) return;
    function be(Fe) {
      (Ui(S) || S(L, Fe)) && ce(Fe);
    }
    const xe = t;
    P.add(xe, "dragstart", (Fe) => Fe.preventDefault(), D).add(xe, "touchmove", () => {
    }, D).add(xe, "touchend", () => {
    }).add(xe, "touchstart", be).add(xe, "mousedown", be).add(xe, "touchcancel", te).add(xe, "contextmenu", te).add(xe, "click", z, !0);
  }
  function de() {
    P.clear(), E.clear();
  }
  function fe() {
    const L = se ? n : t;
    E.add(L, "touchmove", V, D).add(L, "touchend", te).add(L, "mousemove", V, D).add(L, "mouseup", te);
  }
  function _e(L) {
    const be = L.nodeName || "";
    return B.includes(be);
  }
  function ye() {
    return (m ? I : M)[se ? "mouse" : "touch"];
  }
  function Te(L, be) {
    const xe = f.add(gf(L) * -1), Fe = c.byDistance(L, !m).distance;
    return m || vt(L) < T ? Fe : w && be ? Fe * 0.5 : c.byIndex(xe.get(), 0).distance;
  }
  function ce(L) {
    const be = Bd(L, a);
    se = be, U = m && be && !L.buttons && J, J = Do(r.get(), s.get()) >= 2, !(be && L.button !== 0) && (_e(L.target) || (G = !0, o.pointerDown(L), d.useFriction(0).useDuration(0), r.set(s), fe(), ne = o.readPoint(L), Q = o.readPoint(L, $), p.emit("pointerDown")));
  }
  function V(L) {
    if (!Bd(L, a) && L.touches.length >= 2) return te(L);
    const xe = o.readPoint(L), Fe = o.readPoint(L, $), Xe = Do(xe, ne), lt = Do(Fe, Q);
    if (!H && !se && (!L.cancelable || (H = Xe > lt, !H)))
      return te(L);
    const ke = o.pointerMove(L);
    Xe > g && (U = !0), d.useFriction(0.3).useDuration(0.75), i.start(), r.add(k(ke)), L.preventDefault();
  }
  function te(L) {
    const xe = c.byDistance(0, !1).index !== f.get(), Fe = o.pointerUp(L) * ye(), Xe = Te(k(Fe), xe), lt = c3(Fe, Xe), ke = F - 10 * lt, Le = C + lt / 50;
    H = !1, G = !1, E.clear(), d.useDuration(ke).useFriction(Le), u.distance(Xe, !m), se = !1, p.emit("pointerUp");
  }
  function z(L) {
    U && (L.stopPropagation(), L.preventDefault(), U = !1);
  }
  function re() {
    return G;
  }
  return {
    init: ee,
    destroy: de,
    pointerDown: re
  };
}
function g3(e, t) {
  let a, r;
  function o(f) {
    return f.timeStamp;
  }
  function s(f, p) {
    const m = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (Bd(f, t) ? f : f.touches[0])[m];
  }
  function i(f) {
    return a = f, r = f, s(f);
  }
  function u(f) {
    const p = s(f) - s(r), v = o(f) - o(a) > 170;
    return r = f, v && (a = f), p;
  }
  function d(f) {
    if (!a || !r) return 0;
    const p = s(r) - s(a), v = o(f) - o(a), m = o(f) - o(r) > 170, g = p / v;
    return v && !m && vt(g) > 0.1 ? g : 0;
  }
  return {
    pointerDown: i,
    pointerMove: u,
    pointerUp: d,
    readPoint: s
  };
}
function y3() {
  function e(n) {
    const {
      offsetTop: a,
      offsetLeft: r,
      offsetWidth: o,
      offsetHeight: s
    } = n;
    return {
      top: a,
      right: r + o,
      bottom: a + s,
      left: r,
      width: o,
      height: s
    };
  }
  return {
    measure: e
  };
}
function b3(e) {
  function t(a) {
    return e * (a / 100);
  }
  return {
    measure: t
  };
}
function _3(e, t, n, a, r, o, s) {
  const i = [e].concat(a);
  let u, d, c = [], f = !1;
  function p(w) {
    return r.measureSize(s.measure(w));
  }
  function v(w) {
    if (!o) return;
    d = p(e), c = a.map(p);
    function C(S) {
      for (const $ of S) {
        if (f) return;
        const k = $.target === e, B = a.indexOf($.target), D = k ? d : c[B], P = p(k ? e : a[B]);
        if (vt(P - D) >= 0.5) {
          w.reInit(), t.emit("resize");
          break;
        }
      }
    }
    u = new ResizeObserver((S) => {
      (Ui(o) || o(w, S)) && C(S);
    }), n.requestAnimationFrame(() => {
      i.forEach((S) => u.observe(S));
    });
  }
  function m() {
    f = !0, u && u.disconnect();
  }
  return {
    init: v,
    destroy: m
  };
}
function w3(e, t, n, a, r, o) {
  let s = 0, i = 0, u = r, d = o, c = e.get(), f = 0;
  function p() {
    const D = a.get() - e.get(), P = !u;
    let E = 0;
    return P ? (s = 0, n.set(a), e.set(a), E = D) : (n.set(e), s += D / u, s *= d, c += s, e.add(s), E = c - f), i = gf(E), f = c, B;
  }
  function v() {
    const D = a.get() - t.get();
    return vt(D) < 1e-3;
  }
  function m() {
    return u;
  }
  function g() {
    return i;
  }
  function w() {
    return s;
  }
  function C() {
    return $(r);
  }
  function S() {
    return k(o);
  }
  function $(D) {
    return u = D, B;
  }
  function k(D) {
    return d = D, B;
  }
  const B = {
    direction: g,
    duration: m,
    velocity: w,
    seek: p,
    settled: v,
    useBaseFriction: S,
    useBaseDuration: C,
    useFriction: k,
    useDuration: $
  };
  return B;
}
function x3(e, t, n, a, r) {
  const o = r.measure(10), s = r.measure(50), i = Za(0.1, 0.99);
  let u = !1;
  function d() {
    return !(u || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function c(v) {
    if (!d()) return;
    const m = e.reachedMin(t.get()) ? "min" : "max", g = vt(e[m] - t.get()), w = n.get() - t.get(), C = i.constrain(g / s);
    n.subtract(w * C), !v && vt(w) < o && (n.set(e.constrain(n.get())), a.useDuration(25).useBaseFriction());
  }
  function f(v) {
    u = !v;
  }
  return {
    shouldConstrain: d,
    constrain: c,
    toggleActive: f
  };
}
function C3(e, t, n, a, r) {
  const o = Za(-t + e, 0), s = f(), i = c(), u = p();
  function d(m, g) {
    return Do(m, g) <= 1;
  }
  function c() {
    const m = s[0], g = Dn(s), w = s.lastIndexOf(m), C = s.indexOf(g) + 1;
    return Za(w, C);
  }
  function f() {
    return n.map((m, g) => {
      const {
        min: w,
        max: C
      } = o, S = o.constrain(m), $ = !g, k = yf(n, g);
      return $ ? C : k || d(w, S) ? w : d(C, S) ? C : S;
    }).map((m) => parseFloat(m.toFixed(3)));
  }
  function p() {
    if (t <= e + r) return [o.max];
    if (a === "keepSnaps") return s;
    const {
      min: m,
      max: g
    } = i;
    return s.slice(m, g);
  }
  return {
    snapsContained: u,
    scrollContainLimit: i
  };
}
function S3(e, t, n) {
  const a = t[0], r = n ? a - e : Dn(t);
  return {
    limit: Za(r, a)
  };
}
function $3(e, t, n, a) {
  const o = t.min + 0.1, s = t.max + 0.1, {
    reachedMin: i,
    reachedMax: u
  } = Za(o, s);
  function d(p) {
    return p === 1 ? u(n.get()) : p === -1 ? i(n.get()) : !1;
  }
  function c(p) {
    if (!d(p)) return;
    const v = e * (p * -1);
    a.forEach((m) => m.add(v));
  }
  return {
    loop: c
  };
}
function B3(e) {
  const {
    max: t,
    length: n
  } = e;
  function a(o) {
    const s = o - t;
    return n ? s / -n : 0;
  }
  return {
    get: a
  };
}
function k3(e, t, n, a, r) {
  const {
    startEdge: o,
    endEdge: s
  } = e, {
    groupSlides: i
  } = r, u = f().map(t.measure), d = p(), c = v();
  function f() {
    return i(a).map((g) => Dn(g)[s] - g[0][o]).map(vt);
  }
  function p() {
    return a.map((g) => n[o] - g[o]).map((g) => -vt(g));
  }
  function v() {
    return i(d).map((g) => g[0]).map((g, w) => g + u[w]);
  }
  return {
    snaps: d,
    snapsAligned: c
  };
}
function P3(e, t, n, a, r, o) {
  const {
    groupSlides: s
  } = r, {
    min: i,
    max: u
  } = a, d = c();
  function c() {
    const p = s(o), v = !e || t === "keepSnaps";
    return n.length === 1 ? [o] : v ? p : p.slice(i, u).map((m, g, w) => {
      const C = !g, S = yf(w, g);
      if (C) {
        const $ = Dn(w[0]) + 1;
        return Sv($);
      }
      if (S) {
        const $ = _s(o) - Dn(w)[0] + 1;
        return Sv($, Dn(w)[0]);
      }
      return m;
    });
  }
  return {
    slideRegistry: d
  };
}
function D3(e, t, n, a, r) {
  const {
    reachedAny: o,
    removeOffset: s,
    constrain: i
  } = a;
  function u(m) {
    return m.concat().sort((g, w) => vt(g) - vt(w))[0];
  }
  function d(m) {
    const g = e ? s(m) : i(m), w = t.map((S, $) => ({
      diff: c(S - g, 0),
      index: $
    })).sort((S, $) => vt(S.diff) - vt($.diff)), {
      index: C
    } = w[0];
    return {
      index: C,
      distance: g
    };
  }
  function c(m, g) {
    const w = [m, m + n, m - n];
    if (!e) return m;
    if (!g) return u(w);
    const C = w.filter((S) => gf(S) === g);
    return C.length ? u(C) : Dn(w) - n;
  }
  function f(m, g) {
    const w = t[m] - r.get(), C = c(w, g);
    return {
      index: m,
      distance: C
    };
  }
  function p(m, g) {
    const w = r.get() + m, {
      index: C,
      distance: S
    } = d(w), $ = !e && o(w);
    if (!g || $) return {
      index: C,
      distance: m
    };
    const k = t[C] - S, B = m + c(k, 0);
    return {
      index: C,
      distance: B
    };
  }
  return {
    byDistance: p,
    byIndex: f,
    shortcut: c
  };
}
function M3(e, t, n, a, r, o, s) {
  function i(f) {
    const p = f.distance, v = f.index !== t.get();
    o.add(p), p && (a.duration() ? e.start() : (e.update(), e.render(1), e.update())), v && (n.set(t.get()), t.set(f.index), s.emit("select"));
  }
  function u(f, p) {
    const v = r.byDistance(f, p);
    i(v);
  }
  function d(f, p) {
    const v = t.clone().set(f), m = r.byIndex(v.get(), p);
    i(m);
  }
  return {
    distance: u,
    index: d
  };
}
function q3(e, t, n, a, r, o, s, i) {
  const u = {
    passive: !0,
    capture: !0
  };
  let d = 0;
  function c(v) {
    if (!i) return;
    function m(g) {
      if ((/* @__PURE__ */ new Date()).getTime() - d > 10) return;
      s.emit("slideFocusStart"), e.scrollLeft = 0;
      const S = n.findIndex(($) => $.includes(g));
      hf(S) && (r.useDuration(0), a.index(S, 0), s.emit("slideFocus"));
    }
    o.add(document, "keydown", f, !1), t.forEach((g, w) => {
      o.add(g, "focus", (C) => {
        (Ui(i) || i(v, C)) && m(w);
      }, u);
    });
  }
  function f(v) {
    v.code === "Tab" && (d = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: c
  };
}
function xo(e) {
  let t = e;
  function n() {
    return t;
  }
  function a(u) {
    t = s(u);
  }
  function r(u) {
    t += s(u);
  }
  function o(u) {
    t -= s(u);
  }
  function s(u) {
    return hf(u) ? u : u.get();
  }
  return {
    get: n,
    set: a,
    add: r,
    subtract: o
  };
}
function rb(e, t) {
  const n = e.scroll === "x" ? s : i, a = t.style;
  let r = null, o = !1;
  function s(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function i(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function u(p) {
    if (o) return;
    const v = f3(e.direction(p));
    v !== r && (a.transform = n(v), r = v);
  }
  function d(p) {
    o = !p;
  }
  function c() {
    o || (a.transform = "", t.getAttribute("style") || t.removeAttribute("style"));
  }
  return {
    clear: c,
    to: u,
    toggleActive: d
  };
}
function E3(e, t, n, a, r, o, s, i, u) {
  const c = zo(r), f = zo(r).reverse(), p = C().concat(S());
  function v(P, E) {
    return P.reduce((T, M) => T - r[M], E);
  }
  function m(P, E) {
    return P.reduce((T, M) => v(T, E) > 0 ? T.concat([M]) : T, []);
  }
  function g(P) {
    return o.map((E, T) => ({
      start: E - a[T] + 0.5 + P,
      end: E + t - 0.5 + P
    }));
  }
  function w(P, E, T) {
    const M = g(E);
    return P.map((I) => {
      const F = T ? 0 : -n, J = T ? n : 0, ne = T ? "end" : "start", Q = M[I][ne];
      return {
        index: I,
        loopPoint: Q,
        slideLocation: xo(-1),
        translate: rb(e, u[I]),
        target: () => i.get() > Q ? F : J
      };
    });
  }
  function C() {
    const P = s[0], E = m(f, P);
    return w(E, n, !1);
  }
  function S() {
    const P = t - s[0] - 1, E = m(c, P);
    return w(E, -n, !0);
  }
  function $() {
    return p.every(({
      index: P
    }) => {
      const E = c.filter((T) => T !== P);
      return v(E, t) <= 0.1;
    });
  }
  function k() {
    p.forEach((P) => {
      const {
        target: E,
        translate: T,
        slideLocation: M
      } = P, I = E();
      I !== M.get() && (T.to(I), M.set(I));
    });
  }
  function B() {
    p.forEach((P) => P.translate.clear());
  }
  return {
    canLoop: $,
    clear: B,
    loop: k,
    loopPoints: p
  };
}
function T3(e, t, n) {
  let a, r = !1;
  function o(u) {
    if (!n) return;
    function d(c) {
      for (const f of c)
        if (f.type === "childList") {
          u.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    a = new MutationObserver((c) => {
      r || (Ui(n) || n(u, c)) && d(c);
    }), a.observe(e, {
      childList: !0
    });
  }
  function s() {
    a && a.disconnect(), r = !0;
  }
  return {
    init: o,
    destroy: s
  };
}
function A3(e, t, n, a) {
  const r = {};
  let o = null, s = null, i, u = !1;
  function d() {
    i = new IntersectionObserver((m) => {
      u || (m.forEach((g) => {
        const w = t.indexOf(g.target);
        r[w] = g;
      }), o = null, s = null, n.emit("slidesInView"));
    }, {
      root: e.parentElement,
      threshold: a
    }), t.forEach((m) => i.observe(m));
  }
  function c() {
    i && i.disconnect(), u = !0;
  }
  function f(m) {
    return Ho(r).reduce((g, w) => {
      const C = parseInt(w), {
        isIntersecting: S
      } = r[C];
      return (m && S || !m && !S) && g.push(C), g;
    }, []);
  }
  function p(m = !0) {
    if (m && o) return o;
    if (!m && s) return s;
    const g = f(m);
    return m && (o = g), m || (s = g), g;
  }
  return {
    init: d,
    destroy: c,
    get: p
  };
}
function O3(e, t, n, a, r, o) {
  const {
    measureSize: s,
    startEdge: i,
    endEdge: u
  } = e, d = n[0] && r, c = m(), f = g(), p = n.map(s), v = w();
  function m() {
    if (!d) return 0;
    const S = n[0];
    return vt(t[i] - S[i]);
  }
  function g() {
    if (!d) return 0;
    const S = o.getComputedStyle(Dn(a));
    return parseFloat(S.getPropertyValue(`margin-${u}`));
  }
  function w() {
    return n.map((S, $, k) => {
      const B = !$, D = yf(k, $);
      return B ? p[$] + c : D ? p[$] + f : k[$ + 1][i] - S[i];
    }).map(vt);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: v,
    startGap: c,
    endGap: f
  };
}
function I3(e, t, n, a, r, o, s, i, u) {
  const {
    startEdge: d,
    endEdge: c,
    direction: f
  } = e, p = hf(n);
  function v(C, S) {
    return zo(C).filter(($) => $ % S === 0).map(($) => C.slice($, $ + S));
  }
  function m(C) {
    return C.length ? zo(C).reduce((S, $, k) => {
      const B = Dn(S) || 0, D = B === 0, P = $ === _s(C), E = r[d] - o[B][d], T = r[d] - o[$][c], M = !a && D ? f(s) : 0, I = !a && P ? f(i) : 0, F = vt(T - I - (E + M));
      return k && F > t + u && S.push($), P && S.push(C.length), S;
    }, []).map((S, $, k) => {
      const B = Math.max(k[$ - 1] || 0);
      return C.slice(B, S);
    }) : [];
  }
  function g(C) {
    return p ? v(C, n) : m(C);
  }
  return {
    groupSlides: g
  };
}
function R3(e, t, n, a, r, o, s) {
  const {
    align: i,
    axis: u,
    direction: d,
    startIndex: c,
    loop: f,
    duration: p,
    dragFree: v,
    dragThreshold: m,
    inViewThreshold: g,
    slidesToScroll: w,
    skipSnaps: C,
    containScroll: S,
    watchResize: $,
    watchSlides: k,
    watchDrag: B,
    watchFocus: D
  } = o, P = 2, E = y3(), T = E.measure(t), M = n.map(E.measure), I = m3(u, d), F = I.measureSize(T), J = b3(F), ne = p3(i, F), Q = !f && !!S, G = f || !!S, {
    slideSizes: H,
    slideSizesWithGaps: U,
    startGap: se,
    endGap: ee
  } = O3(I, T, M, n, G, r), de = I3(I, F, w, f, T, M, se, ee, P), {
    snaps: fe,
    snapsAligned: _e
  } = k3(I, ne, T, M, de), ye = -Dn(fe) + Dn(U), {
    snapsContained: Te,
    scrollContainLimit: ce
  } = C3(F, ye, _e, S, P), V = Q ? Te : _e, {
    limit: te
  } = S3(ye, V, f), z = ab(_s(V), c, f), re = z.clone(), ie = zo(n), L = ({
    dragHandler: Ot,
    scrollBody: K,
    scrollBounds: Y,
    options: {
      loop: ue
    }
  }) => {
    ue || Y.constrain(Ot.pointerDown()), K.seek();
  }, be = ({
    scrollBody: Ot,
    translate: K,
    location: Y,
    offsetLocation: ue,
    previousLocation: ge,
    scrollLooper: De,
    slideLooper: Oe,
    dragHandler: Ee,
    animation: rt,
    eventHandler: ct,
    scrollBounds: qt,
    options: {
      loop: at
    }
  }, $t) => {
    const It = Ot.settled(), Yt = !qt.shouldConstrain(), ha = at ? It : It && Yt, mr = ha && !Ee.pointerDown();
    mr && rt.stop();
    const so = Y.get() * $t + ge.get() * (1 - $t);
    ue.set(so), at && (De.loop(Ot.direction()), Oe.loop()), K.to(ue.get()), mr && ct.emit("settle"), ha || ct.emit("scroll");
  }, xe = v3(a, r, () => L(Ut), (Ot) => be(Ut, Ot)), Fe = 0.68, Xe = V[z.get()], lt = xo(Xe), ke = xo(Xe), Le = xo(Xe), Ue = xo(Xe), We = w3(lt, Le, ke, Ue, p, Fe), it = D3(f, V, ye, te, Ue), ut = M3(xe, z, re, We, it, Ue, s), St = B3(te), on = Uo(), mn = A3(t, n, s, g), {
    slideRegistry: Ie
  } = P3(Q, S, V, ce, de, ie), Mt = q3(e, n, Ie, ut, We, on, s, D), Ut = {
    ownerDocument: a,
    ownerWindow: r,
    eventHandler: s,
    containerRect: T,
    slideRects: M,
    animation: xe,
    axis: I,
    dragHandler: h3(I, e, a, r, Ue, g3(I, r), lt, xe, ut, We, it, z, s, J, v, m, C, Fe, B),
    eventStore: on,
    percentOfView: J,
    index: z,
    indexPrevious: re,
    limit: te,
    location: lt,
    offsetLocation: Le,
    previousLocation: ke,
    options: o,
    resizeHandler: _3(t, s, r, n, I, $, E),
    scrollBody: We,
    scrollBounds: x3(te, Le, Ue, We, J),
    scrollLooper: $3(ye, te, Le, [lt, Le, ke, Ue]),
    scrollProgress: St,
    scrollSnapList: V.map(St.get),
    scrollSnaps: V,
    scrollTarget: it,
    scrollTo: ut,
    slideLooper: E3(I, F, ye, H, U, fe, V, Le, n),
    slideFocus: Mt,
    slidesHandler: T3(t, s, k),
    slidesInView: mn,
    slideIndexes: ie,
    slideRegistry: Ie,
    slidesToScroll: de,
    target: Ue,
    translate: rb(I, t)
  };
  return Ut;
}
function V3() {
  let e = {}, t;
  function n(d) {
    t = d;
  }
  function a(d) {
    return e[d] || [];
  }
  function r(d) {
    return a(d).forEach((c) => c(t, d)), u;
  }
  function o(d, c) {
    return e[d] = a(d).concat([c]), u;
  }
  function s(d, c) {
    return e[d] = a(d).filter((f) => f !== c), u;
  }
  function i() {
    e = {};
  }
  const u = {
    init: n,
    emit: r,
    off: s,
    on: o,
    clear: i
  };
  return u;
}
const F3 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function N3(e) {
  function t(o, s) {
    return nb(o, s || {});
  }
  function n(o) {
    const s = o.breakpoints || {}, i = Ho(s).filter((u) => e.matchMedia(u).matches).map((u) => s[u]).reduce((u, d) => t(u, d), {});
    return t(o, i);
  }
  function a(o) {
    return o.map((s) => Ho(s.breakpoints || {})).reduce((s, i) => s.concat(i), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: a
  };
}
function L3(e) {
  let t = [];
  function n(o, s) {
    return t = s.filter(({
      options: i
    }) => e.optionsAtMedia(i).active !== !1), t.forEach((i) => i.init(o, e)), s.reduce((i, u) => Object.assign(i, {
      [u.name]: u
    }), {});
  }
  function a() {
    t = t.filter((o) => o.destroy());
  }
  return {
    init: n,
    destroy: a
  };
}
function Il(e, t, n) {
  const a = e.ownerDocument, r = a.defaultView, o = N3(r), s = L3(o), i = Uo(), u = V3(), {
    mergeOptions: d,
    optionsAtMedia: c,
    optionsMediaQueries: f
  } = o, {
    on: p,
    off: v,
    emit: m
  } = u, g = I;
  let w = !1, C, S = d(F3, Il.globalOptions), $ = d(S), k = [], B, D, P;
  function E() {
    const {
      container: ie,
      slides: L
    } = $;
    D = ($d(ie) ? e.querySelector(ie) : ie) || e.children[0];
    const xe = $d(L) ? D.querySelectorAll(L) : L;
    P = [].slice.call(xe || D.children);
  }
  function T(ie) {
    const L = R3(e, D, P, a, r, ie, u);
    if (ie.loop && !L.slideLooper.canLoop()) {
      const be = Object.assign({}, ie, {
        loop: !1
      });
      return T(be);
    }
    return L;
  }
  function M(ie, L) {
    w || (S = d(S, ie), $ = c(S), k = L || k, E(), C = T($), f([S, ...k.map(({
      options: be
    }) => be)]).forEach((be) => i.add(be, "change", I)), $.active && (C.translate.to(C.location.get()), C.animation.init(), C.slidesInView.init(), C.slideFocus.init(re), C.eventHandler.init(re), C.resizeHandler.init(re), C.slidesHandler.init(re), C.options.loop && C.slideLooper.loop(), D.offsetParent && P.length && C.dragHandler.init(re), B = s.init(re, k)));
  }
  function I(ie, L) {
    const be = de();
    F(), M(d({
      startIndex: be
    }, ie), L), u.emit("reInit");
  }
  function F() {
    C.dragHandler.destroy(), C.eventStore.clear(), C.translate.clear(), C.slideLooper.clear(), C.resizeHandler.destroy(), C.slidesHandler.destroy(), C.slidesInView.destroy(), C.animation.destroy(), s.destroy(), i.clear();
  }
  function J() {
    w || (w = !0, i.clear(), F(), u.emit("destroy"), u.clear());
  }
  function ne(ie, L, be) {
    !$.active || w || (C.scrollBody.useBaseFriction().useDuration(L === !0 ? 0 : $.duration), C.scrollTo.index(ie, be || 0));
  }
  function Q(ie) {
    const L = C.index.add(1).get();
    ne(L, ie, -1);
  }
  function G(ie) {
    const L = C.index.add(-1).get();
    ne(L, ie, 1);
  }
  function H() {
    return C.index.add(1).get() !== de();
  }
  function U() {
    return C.index.add(-1).get() !== de();
  }
  function se() {
    return C.scrollSnapList;
  }
  function ee() {
    return C.scrollProgress.get(C.offsetLocation.get());
  }
  function de() {
    return C.index.get();
  }
  function fe() {
    return C.indexPrevious.get();
  }
  function _e() {
    return C.slidesInView.get();
  }
  function ye() {
    return C.slidesInView.get(!1);
  }
  function Te() {
    return B;
  }
  function ce() {
    return C;
  }
  function V() {
    return e;
  }
  function te() {
    return D;
  }
  function z() {
    return P;
  }
  const re = {
    canScrollNext: H,
    canScrollPrev: U,
    containerNode: te,
    internalEngine: ce,
    destroy: J,
    off: v,
    on: p,
    emit: m,
    plugins: Te,
    previousScrollSnap: fe,
    reInit: g,
    rootNode: V,
    scrollNext: Q,
    scrollPrev: G,
    scrollProgress: ee,
    scrollSnapList: se,
    scrollTo: ne,
    selectedScrollSnap: de,
    slideNodes: z,
    slidesInView: _e,
    slidesNotInView: ye
  };
  return M(t, n), setTimeout(() => u.emit("init"), 0), re;
}
Il.globalOptions = void 0;
function bf(e = {}, t = []) {
  const n = mt(e), a = mt(t);
  let r = n ? e.value : e, o = a ? t.value : t;
  const s = ht(), i = ht();
  function u() {
    i.value && i.value.reInit(r, o);
  }
  return Ce(() => {
    !u3() || !s.value || (Il.globalOptions = bf.globalOptions, i.value = Il(s.value, r, o));
  }), ar(() => {
    i.value && i.value.destroy();
  }), n && me(e, (d) => {
    mf(r, d) || (r = d, u());
  }), a && me(t, (d) => {
    d3(o, d) || (o = d, u());
  }), [s, i];
}
bf.globalOptions = void 0;
const [z3, H3] = /* @__PURE__ */ D2(
  ({ opts: e, orientation: t, plugins: n }, a) => {
    const [r, o] = bf(
      {
        ...e,
        axis: t === "horizontal" ? "x" : "y"
      },
      n
    );
    function s() {
      o.value?.scrollPrev();
    }
    function i() {
      o.value?.scrollNext();
    }
    const u = O(!1), d = O(!1);
    function c(f) {
      u.value = f?.canScrollNext() || !1, d.value = f?.canScrollPrev() || !1;
    }
    return Ce(() => {
      o.value && (o.value?.on("init", c), o.value?.on("reInit", c), o.value?.on("select", c), a("init-api", o.value));
    }), {
      carouselRef: r,
      carouselApi: o,
      canScrollPrev: d,
      canScrollNext: u,
      scrollPrev: s,
      scrollNext: i,
      orientation: t
    };
  }
);
function ji() {
  const e = H3();
  if (!e) throw new Error("useCarousel must be used within a <Carousel />");
  return e;
}
const d7 = /* @__PURE__ */ b({
  __name: "Carousel",
  props: {
    opts: {},
    plugins: {},
    orientation: { default: "horizontal" },
    class: {}
  },
  emits: ["init-api"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, {
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    } = z3(a, r);
    t({
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    });
    function p(v) {
      const m = a.orientation === "vertical" ? "ArrowUp" : "ArrowLeft", g = a.orientation === "vertical" ? "ArrowDown" : "ArrowRight";
      if (v.key === m) {
        v.preventDefault(), f();
        return;
      }
      v.key === g && (v.preventDefault(), c());
    }
    return (v, m) => (h(), W("div", {
      class: ae(l(R)("relative", a.class)),
      role: "region",
      "aria-roledescription": "carousel",
      tabindex: "0",
      onKeydown: p
    }, [
      _(v.$slots, "default", {
        canScrollNext: l(o),
        canScrollPrev: l(s),
        carouselApi: l(i),
        carouselRef: l(u),
        orientation: l(d),
        scrollNext: l(c),
        scrollPrev: l(f)
      })
    ], 34));
  }
}), c7 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CarouselContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { carouselRef: n, orientation: a } = ji();
    return (r, o) => (h(), W("div", {
      ref_key: "carouselRef",
      ref: n,
      class: "overflow-hidden"
    }, [
      we("div", A({
        class: l(R)("flex", l(a) === "horizontal" ? "-ml-4" : "-mt-4 flex-col", t.class)
      }, r.$attrs), [
        _(r.$slots, "default")
      ], 16)
    ], 512));
  }
}), f7 = /* @__PURE__ */ b({
  __name: "CarouselItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n } = ji();
    return (a, r) => (h(), W("div", {
      role: "group",
      "aria-roledescription": "slide",
      class: ae(
        l(R)(
          "min-w-0 shrink-0 grow-0 basis-full",
          l(n) === "horizontal" ? "pl-4" : "pt-4",
          t.class
        )
      )
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), p7 = /* @__PURE__ */ b({
  __name: "CarouselPrevious",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollPrev: a, scrollPrev: r } = ji();
    return (o, s) => (h(), x(l(gs), {
      disabled: !l(a),
      class: ae(
        l(R)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -left-12 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: y(() => [
        _(o.$slots, "default", {}, () => [
          N(l(wO), { class: "size-4 text-current" }),
          s[0] || (s[0] = we("span", { class: "sr-only" }, "Previous Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
}), v7 = /* @__PURE__ */ b({
  __name: "CarouselNext",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollNext: a, scrollNext: r } = ji();
    return (o, s) => (h(), x(l(gs), {
      disabled: !l(a),
      class: ae(
        l(R)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -right-12 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: y(() => [
        _(o.$slots, "default", {}, () => [
          N(l(xO), { class: "size-4 text-current" }),
          s[0] || (s[0] = we("span", { class: "sr-only" }, "Next Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
});
var kd = "http://www.w3.org/1999/xhtml";
const $v = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: kd,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Wi(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), $v.hasOwnProperty(t) ? { space: $v[t], local: e } : e;
}
function U3(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === kd && t.documentElement.namespaceURI === kd ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function j3(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function ob(e) {
  var t = Wi(e);
  return (t.local ? j3 : U3)(t);
}
function W3() {
}
function _f(e) {
  return e == null ? W3 : function() {
    return this.querySelector(e);
  };
}
function G3(e) {
  typeof e != "function" && (e = _f(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = new Array(s), u, d, c = 0; c < s; ++c)
      (u = o[c]) && (d = e.call(u, u.__data__, c, o)) && ("__data__" in u && (d.__data__ = u.__data__), i[c] = d);
  return new vn(a, this._parents);
}
function K3(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Y3() {
  return [];
}
function sb(e) {
  return e == null ? Y3 : function() {
    return this.querySelectorAll(e);
  };
}
function X3(e) {
  return function() {
    return K3(e.apply(this, arguments));
  };
}
function J3(e) {
  typeof e == "function" ? e = X3(e) : e = sb(e);
  for (var t = this._groups, n = t.length, a = [], r = [], o = 0; o < n; ++o)
    for (var s = t[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && (a.push(e.call(u, u.__data__, d, s)), r.push(u));
  return new vn(a, r);
}
function lb(e) {
  return function() {
    return this.matches(e);
  };
}
function ib(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Z3 = Array.prototype.find;
function Q3(e) {
  return function() {
    return Z3.call(this.children, e);
  };
}
function eR() {
  return this.firstElementChild;
}
function tR(e) {
  return this.select(e == null ? eR : Q3(typeof e == "function" ? e : ib(e)));
}
var nR = Array.prototype.filter;
function aR() {
  return Array.from(this.children);
}
function rR(e) {
  return function() {
    return nR.call(this.children, e);
  };
}
function oR(e) {
  return this.selectAll(e == null ? aR : rR(typeof e == "function" ? e : ib(e)));
}
function sR(e) {
  typeof e != "function" && (e = lb(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new vn(a, this._parents);
}
function ub(e) {
  return new Array(e.length);
}
function lR() {
  return new vn(this._enter || this._groups.map(ub), this._parents);
}
function Rl(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Rl.prototype = {
  constructor: Rl,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function iR(e) {
  return function() {
    return e;
  };
}
function uR(e, t, n, a, r, o) {
  for (var s = 0, i, u = t.length, d = o.length; s < d; ++s)
    (i = t[s]) ? (i.__data__ = o[s], a[s] = i) : n[s] = new Rl(e, o[s]);
  for (; s < u; ++s)
    (i = t[s]) && (r[s] = i);
}
function dR(e, t, n, a, r, o, s) {
  var i, u, d = /* @__PURE__ */ new Map(), c = t.length, f = o.length, p = new Array(c), v;
  for (i = 0; i < c; ++i)
    (u = t[i]) && (p[i] = v = s.call(u, u.__data__, i, t) + "", d.has(v) ? r[i] = u : d.set(v, u));
  for (i = 0; i < f; ++i)
    v = s.call(e, o[i], i, o) + "", (u = d.get(v)) ? (a[i] = u, u.__data__ = o[i], d.delete(v)) : n[i] = new Rl(e, o[i]);
  for (i = 0; i < c; ++i)
    (u = t[i]) && d.get(p[i]) === u && (r[i] = u);
}
function cR(e) {
  return e.__data__;
}
function fR(e, t) {
  if (!arguments.length) return Array.from(this, cR);
  var n = t ? dR : uR, a = this._parents, r = this._groups;
  typeof e != "function" && (e = iR(e));
  for (var o = r.length, s = new Array(o), i = new Array(o), u = new Array(o), d = 0; d < o; ++d) {
    var c = a[d], f = r[d], p = f.length, v = pR(e.call(c, c && c.__data__, d, a)), m = v.length, g = i[d] = new Array(m), w = s[d] = new Array(m), C = u[d] = new Array(p);
    n(c, f, g, w, C, v, t);
    for (var S = 0, $ = 0, k, B; S < m; ++S)
      if (k = g[S]) {
        for (S >= $ && ($ = S + 1); !(B = w[$]) && ++$ < m; ) ;
        k._next = B || null;
      }
  }
  return s = new vn(s, a), s._enter = i, s._exit = u, s;
}
function pR(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function vR() {
  return new vn(this._exit || this._groups.map(ub), this._parents);
}
function mR(e, t, n) {
  var a = this.enter(), r = this, o = this.exit();
  return typeof e == "function" ? (a = e(a), a && (a = a.selection())) : a = a.append(e + ""), t != null && (r = t(r), r && (r = r.selection())), n == null ? o.remove() : n(o), a && r ? a.merge(r).order() : r;
}
function hR(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, a = t._groups, r = n.length, o = a.length, s = Math.min(r, o), i = new Array(r), u = 0; u < s; ++u)
    for (var d = n[u], c = a[u], f = d.length, p = i[u] = new Array(f), v, m = 0; m < f; ++m)
      (v = d[m] || c[m]) && (p[m] = v);
  for (; u < r; ++u)
    i[u] = n[u];
  return new vn(i, this._parents);
}
function gR() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var a = e[t], r = a.length - 1, o = a[r], s; --r >= 0; )
      (s = a[r]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
  return this;
}
function yR(e) {
  e || (e = bR);
  function t(f, p) {
    return f && p ? e(f.__data__, p.__data__) : !f - !p;
  }
  for (var n = this._groups, a = n.length, r = new Array(a), o = 0; o < a; ++o) {
    for (var s = n[o], i = s.length, u = r[o] = new Array(i), d, c = 0; c < i; ++c)
      (d = s[c]) && (u[c] = d);
    u.sort(t);
  }
  return new vn(r, this._parents).order();
}
function bR(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function _R() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function wR() {
  return Array.from(this);
}
function xR() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length; r < o; ++r) {
      var s = a[r];
      if (s) return s;
    }
  return null;
}
function CR() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function SR() {
  return !this.node();
}
function $R(e) {
  for (var t = this._groups, n = 0, a = t.length; n < a; ++n)
    for (var r = t[n], o = 0, s = r.length, i; o < s; ++o)
      (i = r[o]) && e.call(i, i.__data__, o, r);
  return this;
}
function BR(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function kR(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function PR(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function DR(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function MR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function qR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function ER(e, t) {
  var n = Wi(e);
  if (arguments.length < 2) {
    var a = this.node();
    return n.local ? a.getAttributeNS(n.space, n.local) : a.getAttribute(n);
  }
  return this.each((t == null ? n.local ? kR : BR : typeof t == "function" ? n.local ? qR : MR : n.local ? DR : PR)(n, t));
}
function db(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function TR(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function AR(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function OR(e, t, n) {
  return function() {
    var a = t.apply(this, arguments);
    a == null ? this.style.removeProperty(e) : this.style.setProperty(e, a, n);
  };
}
function IR(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? TR : typeof t == "function" ? OR : AR)(e, t, n ?? "")) : Nr(this.node(), e);
}
function Nr(e, t) {
  return e.style.getPropertyValue(t) || db(e).getComputedStyle(e, null).getPropertyValue(t);
}
function RR(e) {
  return function() {
    delete this[e];
  };
}
function VR(e, t) {
  return function() {
    this[e] = t;
  };
}
function FR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function NR(e, t) {
  return arguments.length > 1 ? this.each((t == null ? RR : typeof t == "function" ? FR : VR)(e, t)) : this.node()[e];
}
function cb(e) {
  return e.trim().split(/^|\s+/);
}
function wf(e) {
  return e.classList || new fb(e);
}
function fb(e) {
  this._node = e, this._names = cb(e.getAttribute("class") || "");
}
fb.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function pb(e, t) {
  for (var n = wf(e), a = -1, r = t.length; ++a < r; ) n.add(t[a]);
}
function vb(e, t) {
  for (var n = wf(e), a = -1, r = t.length; ++a < r; ) n.remove(t[a]);
}
function LR(e) {
  return function() {
    pb(this, e);
  };
}
function zR(e) {
  return function() {
    vb(this, e);
  };
}
function HR(e, t) {
  return function() {
    (t.apply(this, arguments) ? pb : vb)(this, e);
  };
}
function UR(e, t) {
  var n = cb(e + "");
  if (arguments.length < 2) {
    for (var a = wf(this.node()), r = -1, o = n.length; ++r < o; ) if (!a.contains(n[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? HR : t ? LR : zR)(n, t));
}
function jR() {
  this.textContent = "";
}
function WR(e) {
  return function() {
    this.textContent = e;
  };
}
function GR(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function KR(e) {
  return arguments.length ? this.each(e == null ? jR : (typeof e == "function" ? GR : WR)(e)) : this.node().textContent;
}
function YR() {
  this.innerHTML = "";
}
function XR(e) {
  return function() {
    this.innerHTML = e;
  };
}
function JR(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function ZR(e) {
  return arguments.length ? this.each(e == null ? YR : (typeof e == "function" ? JR : XR)(e)) : this.node().innerHTML;
}
function QR() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function eV() {
  return this.each(QR);
}
function tV() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function nV() {
  return this.each(tV);
}
function aV(e) {
  var t = typeof e == "function" ? e : ob(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function rV() {
  return null;
}
function oV(e, t) {
  var n = typeof e == "function" ? e : ob(e), a = t == null ? rV : typeof t == "function" ? t : _f(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), a.apply(this, arguments) || null);
  });
}
function sV() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function lV() {
  return this.each(sV);
}
function iV() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function uV() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function dV(e) {
  return this.select(e ? uV : iV);
}
function cV(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function fV(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function pV(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", a = t.indexOf(".");
    return a >= 0 && (n = t.slice(a + 1), t = t.slice(0, a)), { type: t, name: n };
  });
}
function vV(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, a = -1, r = t.length, o; n < r; ++n)
        o = t[n], (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++a] = o;
      ++a ? t.length = a : delete this.__on;
    }
  };
}
function mV(e, t, n) {
  return function() {
    var a = this.__on, r, o = fV(t);
    if (a) {
      for (var s = 0, i = a.length; s < i; ++s)
        if ((r = a[s]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = o, r.options = n), r.value = t;
          return;
        }
    }
    this.addEventListener(e.type, o, n), r = { type: e.type, name: e.name, value: t, listener: o, options: n }, a ? a.push(r) : this.__on = [r];
  };
}
function hV(e, t, n) {
  var a = pV(e + ""), r, o = a.length, s;
  if (arguments.length < 2) {
    var i = this.node().__on;
    if (i) {
      for (var u = 0, d = i.length, c; u < d; ++u)
        for (r = 0, c = i[u]; r < o; ++r)
          if ((s = a[r]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (i = t ? mV : vV, r = 0; r < o; ++r) this.each(i(a[r], t, n));
  return this;
}
function mb(e, t, n) {
  var a = db(e), r = a.CustomEvent;
  typeof r == "function" ? r = new r(t, n) : (r = a.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r);
}
function gV(e, t) {
  return function() {
    return mb(this, e, t);
  };
}
function yV(e, t) {
  return function() {
    return mb(this, e, t.apply(this, arguments));
  };
}
function bV(e, t) {
  return this.each((typeof t == "function" ? yV : gV)(e, t));
}
function* _V() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length, s; r < o; ++r)
      (s = a[r]) && (yield s);
}
var hb = [null];
function vn(e, t) {
  this._groups = e, this._parents = t;
}
function ws() {
  return new vn([[document.documentElement]], hb);
}
function wV() {
  return this;
}
vn.prototype = ws.prototype = {
  constructor: vn,
  select: G3,
  selectAll: J3,
  selectChild: tR,
  selectChildren: oR,
  filter: sR,
  data: fR,
  enter: lR,
  exit: vR,
  join: mR,
  merge: hR,
  selection: wV,
  order: gR,
  sort: yR,
  call: _R,
  nodes: wR,
  node: xR,
  size: CR,
  empty: SR,
  each: $R,
  attr: ER,
  style: IR,
  property: NR,
  classed: UR,
  text: KR,
  html: ZR,
  raise: eV,
  lower: nV,
  append: aV,
  insert: oV,
  remove: lV,
  clone: dV,
  datum: cV,
  on: hV,
  dispatch: bV,
  [Symbol.iterator]: _V
};
function Da(e) {
  return typeof e == "string" ? new vn([[document.querySelector(e)]], [document.documentElement]) : new vn([[e]], hb);
}
function xV(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Vl(e, t) {
  if (e = xV(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var a = n.createSVGPoint();
      return a.x = e.clientX, a.y = e.clientY, a = a.matrixTransform(t.getScreenCTM().inverse()), [a.x, a.y];
    }
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect();
      return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
var Mo;
(function(e) {
  e[e.SVG = 0] = "SVG", e[e.HTML = 1] = "HTML";
})(Mo || (Mo = {}));
var Pd;
(function(e) {
  e.Fit = "fit", e.Extend = "extend", e.FitWidth = "fit_width";
})(Pd || (Pd = {}));
function qo(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function CV(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function xf(e) {
  let t, n, a;
  e.length !== 2 ? (t = qo, n = (i, u) => qo(e(i), u), a = (i, u) => e(i) - u) : (t = e === qo || e === CV ? e : SV, n = e, a = e);
  function r(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) < 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function o(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) <= 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function s(i, u, d = 0, c = i.length) {
    const f = r(i, u, d, c - 1);
    return f > d && a(i[f - 1], u) > -a(i[f], u) ? f - 1 : f;
  }
  return { left: r, center: s, right: o };
}
function SV() {
  return 0;
}
function gb(e) {
  return e === null ? NaN : +e;
}
const yb = xf(qo), xs = yb.right, $V = yb.left;
xf(gb).center;
class Bv extends Map {
  constructor(t, n = PV) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [a, r] of t) this.set(a, r);
  }
  get(t) {
    return super.get(kv(this, t));
  }
  has(t) {
    return super.has(kv(this, t));
  }
  set(t, n) {
    return super.set(BV(this, t), n);
  }
  delete(t) {
    return super.delete(kV(this, t));
  }
}
function kv({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : n;
}
function BV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : (e.set(a, n), n);
}
function kV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) && (n = e.get(a), e.delete(a)), n;
}
function PV(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const DV = Math.sqrt(50), MV = Math.sqrt(10), qV = Math.sqrt(2);
function Fl(e, t, n) {
  const a = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(a)), o = a / Math.pow(10, r), s = o >= DV ? 10 : o >= MV ? 5 : o >= qV ? 2 : 1;
  let i, u, d;
  return r < 0 ? (d = Math.pow(10, -r) / s, i = Math.round(e * d), u = Math.round(t * d), i / d < e && ++i, u / d > t && --u, d = -d) : (d = Math.pow(10, r) * s, i = Math.round(e / d), u = Math.round(t / d), i * d < e && ++i, u * d > t && --u), u < i && 0.5 <= n && n < 2 ? Fl(e, t, n * 2) : [i, u, d];
}
function Dd(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const a = t < e, [r, o, s] = a ? Fl(t, e, n) : Fl(e, t, n);
  if (!(o >= r)) return [];
  const i = o - r + 1, u = new Array(i);
  if (a)
    if (s < 0) for (let d = 0; d < i; ++d) u[d] = (o - d) / -s;
    else for (let d = 0; d < i; ++d) u[d] = (o - d) * s;
  else if (s < 0) for (let d = 0; d < i; ++d) u[d] = (r + d) / -s;
  else for (let d = 0; d < i; ++d) u[d] = (r + d) * s;
  return u;
}
function Md(e, t, n) {
  return t = +t, e = +e, n = +n, Fl(e, t, n)[2];
}
function qd(e, t, n) {
  t = +t, e = +e, n = +n;
  const a = t < e, r = a ? Md(t, e, n) : Md(e, t, n);
  return (a ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function Pv(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Dv(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function EV(e, t, n = gb) {
  if (!(!(a = e.length) || isNaN(t = +t))) {
    if (t <= 0 || a < 2) return +n(e[0], 0, e);
    if (t >= 1) return +n(e[a - 1], a - 1, e);
    var a, r = (a - 1) * t, o = Math.floor(r), s = +n(e[o], o, e), i = +n(e[o + 1], o + 1, e);
    return s + (i - s) * (r - o);
  }
}
function TV(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var a = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++a < r; )
    o[a] = e + a * n;
  return o;
}
function AV(e, t, n) {
  var a = {}, r = a.noTrailing, o = r === void 0 ? !1 : r, s = a.noLeading, i = s === void 0 ? !1 : s, u = a.debounceMode, d = u === void 0 ? void 0 : u, c, f = !1, p = 0;
  function v() {
    c && clearTimeout(c);
  }
  function m(w) {
    var C = w || {}, S = C.upcomingOnly, $ = S === void 0 ? !1 : S;
    v(), f = !$;
  }
  function g() {
    for (var w = arguments.length, C = new Array(w), S = 0; S < w; S++)
      C[S] = arguments[S];
    var $ = this, k = Date.now() - p;
    if (f)
      return;
    function B() {
      p = Date.now(), t.apply($, C);
    }
    function D() {
      c = void 0;
    }
    !i && d && !c && B(), v(), d === void 0 && k > e ? i ? (p = Date.now(), o || (c = setTimeout(d ? D : B, e))) : B() : o !== !0 && (c = setTimeout(d ? D : B, d === void 0 ? e - k : e));
  }
  return g.cancel = m, g;
}
var oa;
(function(e) {
  e.Left = "left", e.Right = "right", e.Auto = "auto";
})(oa || (oa = {}));
const Eo = (e) => typeof e == "number", Cf = (e) => typeof e == "function", Sf = (e) => Array.isArray(e), OV = (e) => e instanceof Object, Nl = (e) => e.constructor.name !== "Function" && e.constructor.name !== "Object", Mv = (e) => OV(e) && !Sf(e) && !Cf(e) && !Nl(e), Ed = (e, t, n = [], a = /* @__PURE__ */ new Set()) => {
  if (Array.isArray(e)) {
    if (!Array.isArray(t) || e.length !== t.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (let r = 0; r < e.length; r++)
      if (!Ed(e[r], t[r], n, a))
        return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (typeof e == "object" && e !== null && t !== null) {
    if (typeof t != "object")
      return !1;
    if (e === t)
      return !0;
    const r = Object.keys(e).filter((s) => !n.includes(s)), o = Object.keys(t).filter((s) => !n.includes(s));
    if (r.length !== o.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (const s of r)
      if (!Ed(e[s], t[s], n, a))
        return !1;
    return !0;
  }
  return e === t;
}, Ll = (e, t = /* @__PURE__ */ new Map()) => {
  if (typeof e != "object" || e === null)
    return e;
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof Array) {
    const n = [];
    t.set(e, n);
    for (const a of e)
      n.push(t.has(a) ? t.get(a) : Ll(a, t));
    return n;
  }
  if (Nl(e))
    return e;
  if (e instanceof Object) {
    const n = {};
    t.set(e, n);
    const a = e;
    return Object.keys(e).reduce((r, o) => (r[o] = t.has(a[o]) ? t.get(a[o]) : Ll(a[o], t), r), n), n;
  }
  return e;
}, Gi = (e, t, n = /* @__PURE__ */ new Map()) => {
  if (!e || !t || e === t)
    return e;
  const a = Nl(e) ? e : Ll(e);
  return n.has(t) ? n.get(t) : (n.set(t, a), Object.keys(t).forEach((r) => {
    r === "__proto__" || r === "constructor" || (Mv(e[r]) && Mv(t[r]) ? a[r] = Gi(e[r], t[r], n) : Nl(t) ? a[r] = t : a[r] = Ll(t[r]));
  }), a);
}, bb = (e, t) => (e = Object.assign({}, e), t.forEach((n) => delete e[n]), e), zl = (e, t, n) => AV(t, e);
function _b(e, t, n) {
  return Cf(t) ? t(e, n) : t;
}
function wb(e, t, n) {
  return _b(e, t, n);
}
function cn(e, t, n) {
  return _b(e, t, n);
}
function qv(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function IV(e, t, ...n) {
  const a = [];
  let r = 0, o = 0;
  for (const s of n) {
    const i = cn(e, s, t) || 0;
    i >= 0 ? a.push(r += i) : a.push(o += i);
  }
  return a;
}
function RV(e, ...t) {
  return e ? Dv(e, (a, r) => Dv(t, (o) => cn(a, o, r))) : void 0;
}
function VV(e, ...t) {
  return e ? Pv(e, (a, r) => Pv(t, (o) => cn(a, o, r))) : void 0;
}
function Iu(e, ...t) {
  return [RV(e, ...t), VV(e, ...t)];
}
function Hl(e, t, n, a = oa.Auto) {
  if (e.length <= 1)
    return e[0];
  const o = e.map((u, d) => [u, d]).sort(([u, d], [c, f]) => cn(u, n, d) - cn(c, n, f)), s = o.map(([u, d]) => cn(u, n, d)), i = a === oa.Right ? $V(s, t, 0, e.length - 1) : xs(s, t, 1, e.length);
  return a === oa.Right ? o[i][0] : a === oa.Left ? o[i - 1][0] : t - s[i - 1] > s[i] - t ? o[i][0] : o[i - 1][0];
}
function FV(e, t, n, a = !1) {
  if (!n)
    return [];
  const r = e.filter((o, s) => {
    const i = cn(o, n, s);
    return i >= t[0] && i <= t[1];
  });
  if (a) {
    if (r.length === 0) {
      const f = Hl(e, t[0], n, oa.Left), p = Hl(e, t[1], n, oa.Right);
      return [f, p].filter(Boolean);
    }
    const o = r[0], s = r[r.length - 1], i = e.findIndex((f) => f === o), u = e.findIndex((f) => f === s), d = Math.max(0, i - 1), c = Math.min(e.length - 1, u + 1);
    return e.slice(d, c + 1);
  }
  return r;
}
const NV = (e) => e == null ? [] : Array.isArray(e) ? e : [e];
function LV(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function zV(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var HV = /* @__PURE__ */ (function() {
  function e(n) {
    var a = this;
    this._insertTag = function(r) {
      var o;
      a.tags.length === 0 ? a.insertionPoint ? o = a.insertionPoint.nextSibling : a.prepend ? o = a.container.firstChild : o = a.before : o = a.tags[a.tags.length - 1].nextSibling, a.container.insertBefore(r, o), a.tags.push(r);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(a) {
    a.forEach(this._insertTag);
  }, t.insert = function(a) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(zV(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = LV(r);
      try {
        o.insertRule(a, o.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(a));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(a) {
      var r;
      return (r = a.parentNode) == null ? void 0 : r.removeChild(a);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), Ht = "-ms-", Ul = "-moz-", Qe = "-webkit-", xb = "comm", $f = "rule", Bf = "decl", UV = "@import", Cb = "@keyframes", jV = "@layer", WV = Math.abs, Ki = String.fromCharCode, GV = Object.assign;
function KV(e, t) {
  return Vt(e, 0) ^ 45 ? (((t << 2 ^ Vt(e, 0)) << 2 ^ Vt(e, 1)) << 2 ^ Vt(e, 2)) << 2 ^ Vt(e, 3) : 0;
}
function Sb(e) {
  return e.trim();
}
function YV(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function tt(e, t, n) {
  return e.replace(t, n);
}
function Td(e, t) {
  return e.indexOf(t);
}
function Vt(e, t) {
  return e.charCodeAt(t) | 0;
}
function jo(e, t, n) {
  return e.slice(t, n);
}
function zn(e) {
  return e.length;
}
function kf(e) {
  return e.length;
}
function Us(e, t) {
  return t.push(e), e;
}
function XV(e, t) {
  return e.map(t).join("");
}
var Yi = 1, Lr = 1, $b = 0, nn = 0, wt = 0, ro = "";
function Xi(e, t, n, a, r, o, s) {
  return { value: e, root: t, parent: n, type: a, props: r, children: o, line: Yi, column: Lr, length: s, return: "" };
}
function po(e, t) {
  return GV(Xi("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function JV() {
  return wt;
}
function ZV() {
  return wt = nn > 0 ? Vt(ro, --nn) : 0, Lr--, wt === 10 && (Lr = 1, Yi--), wt;
}
function pn() {
  return wt = nn < $b ? Vt(ro, nn++) : 0, Lr++, wt === 10 && (Lr = 1, Yi++), wt;
}
function Wn() {
  return Vt(ro, nn);
}
function il() {
  return nn;
}
function Cs(e, t) {
  return jo(ro, e, t);
}
function Wo(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Bb(e) {
  return Yi = Lr = 1, $b = zn(ro = e), nn = 0, [];
}
function kb(e) {
  return ro = "", e;
}
function ul(e) {
  return Sb(Cs(nn - 1, Ad(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function QV(e) {
  for (; (wt = Wn()) && wt < 33; )
    pn();
  return Wo(e) > 2 || Wo(wt) > 3 ? "" : " ";
}
function eF(e, t) {
  for (; --t && pn() && !(wt < 48 || wt > 102 || wt > 57 && wt < 65 || wt > 70 && wt < 97); )
    ;
  return Cs(e, il() + (t < 6 && Wn() == 32 && pn() == 32));
}
function Ad(e) {
  for (; pn(); )
    switch (wt) {
      // ] ) " '
      case e:
        return nn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Ad(wt);
        break;
      // (
      case 40:
        e === 41 && Ad(e);
        break;
      // \
      case 92:
        pn();
        break;
    }
  return nn;
}
function tF(e, t) {
  for (; pn() && e + wt !== 57; )
    if (e + wt === 84 && Wn() === 47)
      break;
  return "/*" + Cs(t, nn - 1) + "*" + Ki(e === 47 ? e : pn());
}
function nF(e) {
  for (; !Wo(Wn()); )
    pn();
  return Cs(e, nn);
}
function aF(e) {
  return kb(dl("", null, null, null, [""], e = Bb(e), 0, [0], e));
}
function dl(e, t, n, a, r, o, s, i, u) {
  for (var d = 0, c = 0, f = s, p = 0, v = 0, m = 0, g = 1, w = 1, C = 1, S = 0, $ = "", k = r, B = o, D = a, P = $; w; )
    switch (m = S, S = pn()) {
      // (
      case 40:
        if (m != 108 && Vt(P, f - 1) == 58) {
          Td(P += tt(ul(S), "&", "&\f"), "&\f") != -1 && (C = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        P += ul(S);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        P += QV(m);
        break;
      // \
      case 92:
        P += eF(il() - 1, 7);
        continue;
      // /
      case 47:
        switch (Wn()) {
          case 42:
          case 47:
            Us(rF(tF(pn(), il()), t, n), u);
            break;
          default:
            P += "/";
        }
        break;
      // {
      case 123 * g:
        i[d++] = zn(P) * C;
      // } ; \0
      case 125 * g:
      case 59:
      case 0:
        switch (S) {
          // \0 }
          case 0:
          case 125:
            w = 0;
          // ;
          case 59 + c:
            C == -1 && (P = tt(P, /\f/g, "")), v > 0 && zn(P) - f && Us(v > 32 ? Tv(P + ";", a, n, f - 1) : Tv(tt(P, " ", "") + ";", a, n, f - 2), u);
            break;
          // @ ;
          case 59:
            P += ";";
          // { rule/at-rule
          default:
            if (Us(D = Ev(P, t, n, d, c, r, i, $, k = [], B = [], f), o), S === 123)
              if (c === 0)
                dl(P, t, D, D, k, o, f, i, B);
              else
                switch (p === 99 && Vt(P, 3) === 110 ? 100 : p) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    dl(e, D, D, a && Us(Ev(e, D, D, 0, 0, r, i, $, r, k = [], f), B), r, B, f, i, a ? k : B);
                    break;
                  default:
                    dl(P, D, D, D, [""], B, 0, i, B);
                }
        }
        d = c = v = 0, g = C = 1, $ = P = "", f = s;
        break;
      // :
      case 58:
        f = 1 + zn(P), v = m;
      default:
        if (g < 1) {
          if (S == 123)
            --g;
          else if (S == 125 && g++ == 0 && ZV() == 125)
            continue;
        }
        switch (P += Ki(S), S * g) {
          // &
          case 38:
            C = c > 0 ? 1 : (P += "\f", -1);
            break;
          // ,
          case 44:
            i[d++] = (zn(P) - 1) * C, C = 1;
            break;
          // @
          case 64:
            Wn() === 45 && (P += ul(pn())), p = Wn(), c = f = zn($ = P += nF(il())), S++;
            break;
          // -
          case 45:
            m === 45 && zn(P) == 2 && (g = 0);
        }
    }
  return o;
}
function Ev(e, t, n, a, r, o, s, i, u, d, c) {
  for (var f = r - 1, p = r === 0 ? o : [""], v = kf(p), m = 0, g = 0, w = 0; m < a; ++m)
    for (var C = 0, S = jo(e, f + 1, f = WV(g = s[m])), $ = e; C < v; ++C)
      ($ = Sb(g > 0 ? p[C] + " " + S : tt(S, /&\f/g, p[C]))) && (u[w++] = $);
  return Xi(e, t, n, r === 0 ? $f : i, u, d, c);
}
function rF(e, t, n) {
  return Xi(e, t, n, xb, Ki(JV()), jo(e, 2, -2), 0);
}
function Tv(e, t, n, a) {
  return Xi(e, t, n, Bf, jo(e, 0, a), jo(e, a + 1, -1), a);
}
function Er(e, t) {
  for (var n = "", a = kf(e), r = 0; r < a; r++)
    n += t(e[r], r, e, t) || "";
  return n;
}
function oF(e, t, n, a) {
  switch (e.type) {
    case jV:
      if (e.children.length) break;
    case UV:
    case Bf:
      return e.return = e.return || e.value;
    case xb:
      return "";
    case Cb:
      return e.return = e.value + "{" + Er(e.children, a) + "}";
    case $f:
      e.value = e.props.join(",");
  }
  return zn(n = Er(e.children, a)) ? e.return = e.value + "{" + n + "}" : "";
}
function sF(e) {
  var t = kf(e);
  return function(n, a, r, o) {
    for (var s = "", i = 0; i < t; i++)
      s += e[i](n, a, r, o) || "";
    return s;
  };
}
function lF(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function iF(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var uF = function(t, n, a) {
  for (var r = 0, o = 0; r = o, o = Wn(), r === 38 && o === 12 && (n[a] = 1), !Wo(o); )
    pn();
  return Cs(t, nn);
}, dF = function(t, n) {
  var a = -1, r = 44;
  do
    switch (Wo(r)) {
      case 0:
        r === 38 && Wn() === 12 && (n[a] = 1), t[a] += uF(nn - 1, n, a);
        break;
      case 2:
        t[a] += ul(r);
        break;
      case 4:
        if (r === 44) {
          t[++a] = Wn() === 58 ? "&\f" : "", n[a] = t[a].length;
          break;
        }
      // fallthrough
      default:
        t[a] += Ki(r);
    }
  while (r = pn());
  return t;
}, cF = function(t, n) {
  return kb(dF(Bb(t), n));
}, Av = /* @__PURE__ */ new WeakMap(), fF = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, a = t.parent, r = t.column === a.column && t.line === a.line; a.type !== "rule"; )
      if (a = a.parent, !a) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Av.get(a)) && !r) {
      Av.set(t, !0);
      for (var o = [], s = cF(n, o), i = a.props, u = 0, d = 0; u < s.length; u++)
        for (var c = 0; c < i.length; c++, d++)
          t.props[d] = o[u] ? s[u].replace(/&\f/g, i[c]) : i[c] + " " + s[u];
    }
  }
}, pF = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function Pb(e, t) {
  switch (KV(e, t)) {
    // color-adjust
    case 5103:
      return Qe + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Qe + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Qe + e + Ul + e + Ht + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return Qe + e + Ht + e + e;
    // order
    case 6165:
      return Qe + e + Ht + "flex-" + e + e;
    // align-items
    case 5187:
      return Qe + e + tt(e, /(\w+).+(:[^]+)/, Qe + "box-$1$2" + Ht + "flex-$1$2") + e;
    // align-self
    case 5443:
      return Qe + e + Ht + "flex-item-" + tt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return Qe + e + Ht + "flex-line-pack" + tt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return Qe + e + Ht + tt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return Qe + e + Ht + tt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return Qe + "box-" + tt(e, "-grow", "") + Qe + e + Ht + tt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return Qe + tt(e, /([^-])(transform)/g, "$1" + Qe + "$2") + e;
    // cursor
    case 6187:
      return tt(tt(tt(e, /(zoom-|grab)/, Qe + "$1"), /(image-set)/, Qe + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return tt(e, /(image-set\([^]*)/, Qe + "$1$`$1");
    // justify-content
    case 4968:
      return tt(tt(e, /(.+:)(flex-)?(.*)/, Qe + "box-pack:$3" + Ht + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Qe + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return tt(e, /(.+)-inline(.+)/, Qe + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (zn(e) - 1 - t > 6) switch (Vt(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (Vt(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return tt(e, /(.+:)(.+)-([^]+)/, "$1" + Qe + "$2-$3$1" + Ul + (Vt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Td(e, "stretch") ? Pb(tt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (Vt(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (Vt(e, zn(e) - 3 - (~Td(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return tt(e, ":", ":" + Qe) + e;
        // (inline-)?fl(e)x
        case 101:
          return tt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Qe + (Vt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Qe + "$2$3$1" + Ht + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (Vt(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return Qe + e + Ht + tt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return Qe + e + Ht + tt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return Qe + e + Ht + tt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return Qe + e + Ht + e + e;
  }
  return e;
}
var vF = function(t, n, a, r) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Bf:
      t.return = Pb(t.value, t.length);
      break;
    case Cb:
      return Er([po(t, {
        value: tt(t.value, "@", "@" + Qe)
      })], r);
    case $f:
      if (t.length) return XV(t.props, function(o) {
        switch (YV(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Er([po(t, {
              props: [tt(o, /:(read-\w+)/, ":" + Ul + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return Er([po(t, {
              props: [tt(o, /:(plac\w+)/, ":" + Qe + "input-$1")]
            }), po(t, {
              props: [tt(o, /:(plac\w+)/, ":" + Ul + "$1")]
            }), po(t, {
              props: [tt(o, /:(plac\w+)/, Ht + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, mF = [vF], hF = function(t) {
  var n = t.key;
  if (n === "css") {
    var a = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(a, function(g) {
      var w = g.getAttribute("data-emotion");
      w.indexOf(" ") !== -1 && (document.head.appendChild(g), g.setAttribute("data-s", ""));
    });
  }
  var r = t.stylisPlugins || mF, o = {}, s, i = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(g) {
      for (var w = g.getAttribute("data-emotion").split(" "), C = 1; C < w.length; C++)
        o[w[C]] = !0;
      i.push(g);
    }
  );
  var u, d = [fF, pF];
  {
    var c, f = [oF, lF(function(g) {
      c.insert(g);
    })], p = sF(d.concat(r, f)), v = function(w) {
      return Er(aF(w), p);
    };
    u = function(w, C, S, $) {
      c = S, v(w ? w + "{" + C.styles + "}" : C.styles), $ && (m.inserted[C.name] = !0);
    };
  }
  var m = {
    key: n,
    sheet: new HV({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return m.sheet.hydrate(i), m;
};
function gF(e) {
  for (var t = 0, n, a = 0, r = e.length; r >= 4; ++a, r -= 4)
    n = e.charCodeAt(a) & 255 | (e.charCodeAt(++a) & 255) << 8 | (e.charCodeAt(++a) & 255) << 16 | (e.charCodeAt(++a) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (r) {
    case 3:
      t ^= (e.charCodeAt(a + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(a + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(a) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var yF = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, bF = /[A-Z]|^ms/g, _F = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Db = function(t) {
  return t.charCodeAt(1) === 45;
}, Ov = function(t) {
  return t != null && typeof t != "boolean";
}, Ru = /* @__PURE__ */ iF(function(e) {
  return Db(e) ? e : e.replace(bF, "-$&").toLowerCase();
}), Iv = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(_F, function(a, r, o) {
          return Pa = {
            name: r,
            styles: o,
            next: Pa
          }, r;
        });
  }
  return yF[t] !== 1 && !Db(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function jl(e, t, n) {
  if (n == null)
    return "";
  var a = n;
  if (a.__emotion_styles !== void 0)
    return a;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var r = n;
      if (r.anim === 1)
        return Pa = {
          name: r.name,
          styles: r.styles,
          next: Pa
        }, r.name;
      var o = n;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            Pa = {
              name: s.name,
              styles: s.styles,
              next: Pa
            }, s = s.next;
        var i = o.styles + ";";
        return i;
      }
      return wF(e, t, n);
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function wF(e, t, n) {
  var a = "";
  if (Array.isArray(n))
    for (var r = 0; r < n.length; r++)
      a += jl(e, t, n[r]) + ";";
  else
    for (var o in n) {
      var s = n[o];
      if (typeof s != "object") {
        var i = s;
        t != null && t[i] !== void 0 ? a += o + "{" + t[i] + "}" : Ov(i) && (a += Ru(o) + ":" + Iv(o, i) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var u = 0; u < s.length; u++)
          Ov(s[u]) && (a += Ru(o) + ":" + Iv(o, s[u]) + ";");
      else {
        var d = jl(e, t, s);
        switch (o) {
          case "animation":
          case "animationName": {
            a += Ru(o) + ":" + d + ";";
            break;
          }
          default:
            a += o + "{" + d + "}";
        }
      }
    }
  return a;
}
var Rv = /label:\s*([^\s;{]+)\s*(;|$)/g, Pa;
function Vu(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var a = !0, r = "";
  Pa = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    a = !1, r += jl(n, t, o);
  else {
    var s = o;
    r += s[0];
  }
  for (var i = 1; i < e.length; i++)
    if (r += jl(n, t, e[i]), a) {
      var u = o;
      r += u[i];
    }
  Rv.lastIndex = 0;
  for (var d = "", c; (c = Rv.exec(r)) !== null; )
    d += "-" + c[1];
  var f = gF(r) + d;
  return {
    name: f,
    styles: r,
    next: Pa
  };
}
function Mb(e, t, n) {
  var a = "";
  return n.split(" ").forEach(function(r) {
    e[r] !== void 0 ? t.push(e[r] + ";") : r && (a += r + " ");
  }), a;
}
var xF = function(t, n, a) {
  var r = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[r] === void 0 && (t.registered[r] = n.styles);
}, CF = function(t, n, a) {
  xF(t, n);
  var r = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + r : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function Vv(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function Fv(e, t, n) {
  var a = [], r = Mb(e, a, n);
  return a.length < 2 ? n : r + t(a);
}
var SF = function(t) {
  var n = hF(t);
  n.sheet.speedy = function(i) {
    this.isSpeedy = i;
  }, n.compat = !0;
  var a = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Vu(d, n.registered, void 0);
    return CF(n, f), n.key + "-" + f.name;
  }, r = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Vu(d, n.registered), p = "animation-" + f.name;
    return Vv(n, {
      name: f.name,
      styles: "@keyframes " + p + "{" + f.styles + "}"
    }), p;
  }, o = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Vu(d, n.registered);
    Vv(n, f);
  }, s = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    return Fv(n.registered, a, $F(d));
  };
  return {
    css: a,
    cx: s,
    injectGlobal: o,
    keyframes: r,
    hydrate: function(u) {
      u.forEach(function(d) {
        n.inserted[d] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: Mb.bind(null, n.registered),
    merge: Fv.bind(null, n.registered, a)
  };
}, $F = function e(t) {
  for (var n = "", a = 0; a < t.length; a++) {
    var r = t[a];
    if (r != null) {
      var o = void 0;
      switch (typeof r) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(r))
            o = e(r);
          else {
            o = "";
            for (var s in r)
              r[s] && s && (o && (o += " "), o += s);
          }
          break;
        }
        default:
          o = r;
      }
      o && (n && (n += " "), n += o);
    }
  }
  return n;
}, qb = SF({
  key: "css"
}), Pf = qb.injectGlobal, rn = qb.css, Fu, Nv;
function BF() {
  return Nv || (Nv = 1, Fu = function(t, n) {
    n || (n = [0, ""]), t = String(t);
    var a = parseFloat(t, 10);
    return n[0] = a, n[1] = t.match(/[\d.\-\+]*\s*(.*)/)[1] || "", n;
  }), Fu;
}
var Nu, Lv;
function kF() {
  if (Lv) return Nu;
  Lv = 1;
  var e = BF();
  Nu = r;
  var t = a("in", document.body);
  function n(o, s) {
    var i = e(getComputedStyle(o).getPropertyValue(s));
    return i[0] * r(i[1], o);
  }
  function a(o, s) {
    var i = document.createElement("div");
    i.style.height = "128" + o, s.appendChild(i);
    var u = n(i, "height") / 128;
    return s.removeChild(i), u;
  }
  function r(o, s) {
    if (!o) return null;
    switch (s = s || document.body, o = (o + "" || "px").trim().toLowerCase(), (s === window || s === document) && (s = document.body), o) {
      case "%":
        return s.clientHeight / 100;
      case "ch":
      case "ex":
        return a(o, s);
      case "em":
        return n(s, "font-size");
      case "rem":
        return n(document.body, "font-size");
      case "vw":
        return window.innerWidth / 100;
      case "vh":
        return window.innerHeight / 100;
      case "vmin":
        return Math.min(window.innerWidth, window.innerHeight) / 100;
      case "vmax":
        return Math.max(window.innerWidth, window.innerHeight) / 100;
      case "in":
        return t;
      case "cm":
        return t / 2.54;
      case "mm":
        return t / 25.4;
      case "pt":
        return t / 72;
      case "pc":
        return t / 6;
      case "px":
        return 1;
    }
    var i = e(o);
    if (!isNaN(i[0]) && i[1]) {
      var u = r(i[1], s);
      return typeof u == "number" ? i[0] * u : null;
    }
    return null;
  }
  return Nu;
}
var PF = kF();
const Od = /* @__PURE__ */ eh(PF);
function DF() {
  const e = () => Math.floor((1 + crypto.getRandomValues(new Uint32Array(1))[0]) * 65536).toString(16).substring(1);
  return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`;
}
function Df(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Eb(e, t) {
  var n = Object.create(e.prototype);
  for (var a in t) n[a] = t[a];
  return n;
}
function Ss() {
}
var Go = 0.7, Wl = 1 / Go, Tr = "\\s*([+-]?\\d+)\\s*", Ko = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Gn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", MF = /^#([0-9a-f]{3,8})$/, qF = new RegExp(`^rgb\\(${Tr},${Tr},${Tr}\\)$`), EF = new RegExp(`^rgb\\(${Gn},${Gn},${Gn}\\)$`), TF = new RegExp(`^rgba\\(${Tr},${Tr},${Tr},${Ko}\\)$`), AF = new RegExp(`^rgba\\(${Gn},${Gn},${Gn},${Ko}\\)$`), OF = new RegExp(`^hsl\\(${Ko},${Gn},${Gn}\\)$`), IF = new RegExp(`^hsla\\(${Ko},${Gn},${Gn},${Ko}\\)$`), zv = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Df(Ss, Qa, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Hv,
  // Deprecated! Use color.formatHex.
  formatHex: Hv,
  formatHex8: RF,
  formatHsl: VF,
  formatRgb: Uv,
  toString: Uv
});
function Hv() {
  return this.rgb().formatHex();
}
function RF() {
  return this.rgb().formatHex8();
}
function VF() {
  return Tb(this).formatHsl();
}
function Uv() {
  return this.rgb().formatRgb();
}
function Qa(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = MF.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? jv(t) : n === 3 ? new Zt(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? js(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? js(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = qF.exec(e)) ? new Zt(t[1], t[2], t[3], 1) : (t = EF.exec(e)) ? new Zt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = TF.exec(e)) ? js(t[1], t[2], t[3], t[4]) : (t = AF.exec(e)) ? js(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = OF.exec(e)) ? Kv(t[1], t[2] / 100, t[3] / 100, 1) : (t = IF.exec(e)) ? Kv(t[1], t[2] / 100, t[3] / 100, t[4]) : zv.hasOwnProperty(e) ? jv(zv[e]) : e === "transparent" ? new Zt(NaN, NaN, NaN, 0) : null;
}
function jv(e) {
  return new Zt(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function js(e, t, n, a) {
  return a <= 0 && (e = t = n = NaN), new Zt(e, t, n, a);
}
function FF(e) {
  return e instanceof Ss || (e = Qa(e)), e ? (e = e.rgb(), new Zt(e.r, e.g, e.b, e.opacity)) : new Zt();
}
function Id(e, t, n, a) {
  return arguments.length === 1 ? FF(e) : new Zt(e, t, n, a ?? 1);
}
function Zt(e, t, n, a) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +a;
}
Df(Zt, Id, Eb(Ss, {
  brighter(e) {
    return e = e == null ? Wl : Math.pow(Wl, e), new Zt(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Go : Math.pow(Go, e), new Zt(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Zt(Ya(this.r), Ya(this.g), Ya(this.b), Gl(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Wv,
  // Deprecated! Use color.formatHex.
  formatHex: Wv,
  formatHex8: NF,
  formatRgb: Gv,
  toString: Gv
}));
function Wv() {
  return `#${ja(this.r)}${ja(this.g)}${ja(this.b)}`;
}
function NF() {
  return `#${ja(this.r)}${ja(this.g)}${ja(this.b)}${ja((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Gv() {
  const e = Gl(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Ya(this.r)}, ${Ya(this.g)}, ${Ya(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Gl(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Ya(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function ja(e) {
  return e = Ya(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Kv(e, t, n, a) {
  return a <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Bn(e, t, n, a);
}
function Tb(e) {
  if (e instanceof Bn) return new Bn(e.h, e.s, e.l, e.opacity);
  if (e instanceof Ss || (e = Qa(e)), !e) return new Bn();
  if (e instanceof Bn) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, a = e.b / 255, r = Math.min(t, n, a), o = Math.max(t, n, a), s = NaN, i = o - r, u = (o + r) / 2;
  return i ? (t === o ? s = (n - a) / i + (n < a) * 6 : n === o ? s = (a - t) / i + 2 : s = (t - n) / i + 4, i /= u < 0.5 ? o + r : 2 - o - r, s *= 60) : i = u > 0 && u < 1 ? 0 : s, new Bn(s, i, u, e.opacity);
}
function LF(e, t, n, a) {
  return arguments.length === 1 ? Tb(e) : new Bn(e, t, n, a ?? 1);
}
function Bn(e, t, n, a) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +a;
}
Df(Bn, LF, Eb(Ss, {
  brighter(e) {
    return e = e == null ? Wl : Math.pow(Wl, e), new Bn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Go : Math.pow(Go, e), new Bn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, a = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - a;
    return new Zt(
      Lu(e >= 240 ? e - 240 : e + 120, r, a),
      Lu(e, r, a),
      Lu(e < 120 ? e + 240 : e - 120, r, a),
      this.opacity
    );
  },
  clamp() {
    return new Bn(Yv(this.h), Ws(this.s), Ws(this.l), Gl(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Gl(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Yv(this.h)}, ${Ws(this.s) * 100}%, ${Ws(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Yv(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Ws(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Lu(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const zF = globalThis?.UNOVIS_COLORS || ["#4D8CFD", "#FF6B7E", "#F4B83E", "#A6CC74", "#00C19A", "#6859BE"], Ab = (e) => `--vis-${Eo(e) ? `color${e % zF.length}` : e}`, Yo = 10, HF = [
  { id: "stripes-diagonal", svg: '<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="#000"/>' },
  { id: "dots", svg: '<path d="m0-1.5a1 1 0 010 3m10-3a1 1 0 000 3M5 3.5a1 1 0 010 3 1 1 0 010-3M0 8.5 a1 1 0 010 3m10-3a1 1 0 000 3" fill"#000"/>' },
  { id: "stripes-vertical", svg: '<path d="M 5,-1 L5,11" stroke="#000"/>' },
  { id: "crosshatch", svg: '<path d="M0 0L10 10ZM10 0L0 10Z" stroke="#000"/>' },
  { id: "waves", svg: '<path d="M0 4Q2.5 1 5 4 7.5 7 10 4v2Q7.5 9 5 6 2.5 3 0 6Z" fill="#000"/>' },
  { id: "circles", svg: '<circle cx="5" cy="5" r="3" stroke="#000" fill="#fff"/>' }
], UF = [
  { id: "circle", marker: '<circle cx="5" cy="5" r="5"/>', dashArray: [] },
  { id: "triangle", marker: '<path d="M5,0 L10,9 L0,9Z">', dashArray: [9, 1] },
  { id: "diamond", marker: '<path d="M 0 5 L5 0 L 10 5 L 5 10 L 0 5Z">', dashArray: [2] },
  { id: "arrow", marker: '<path d="M4 0 0 0 6 5 0 10 4 10 10 5Z">', dashArray: [2, 3, 8, 3] },
  { id: "square", marker: '<rect x="1" y="1" width="8" height="8"/>', dashArray: [6] },
  { id: "star", marker: '<path d="m2 9 3-9 3 9L0 3h10Z"/>', dashArray: [1, 6] }
];
function Ob(e) {
  return `vis-${`pattern-${e.svg ? "fill" : "marker"}`}-${e.id}`;
}
const jF = (e) => `<mask id="${Ob(e)}">
    <pattern id="${e.id}" viewBox="0 0 10 10" width="${Yo}" height="${Yo}" patternUnits="userSpaceOnUse">
      <rect width="100%" height="100%" fill="#fff"/>
      ${e.svg}
    </pattern>
    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#${e.id})"/>
  </mask>`, WF = (e, t) => `<marker id="${Ob(e)}"
    fill="var(${Ab(t)})"
    markerUnits="userSpaceOnUse"
    refX="5"
    refY="5"
    markerWidth="${Yo}"
    markerHeight="${Yo}">
    ${e.marker}
  </marker>`;
function GF() {
  const e = HF.map(jF).concat(UF.map(WF)).join(""), t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.style.position = "fixed", t.style.zIndex = "-99999999", t.innerHTML = `<defs>${e}</defs>`, document.body.appendChild(t);
}
typeof window < "u" && GF();
var KF = { value: () => {
} };
function Ib() {
  for (var e = 0, t = arguments.length, n = {}, a; e < t; ++e) {
    if (!(a = arguments[e] + "") || a in n || /[\s.]/.test(a)) throw new Error("illegal type: " + a);
    n[a] = [];
  }
  return new cl(n);
}
function cl(e) {
  this._ = e;
}
function YF(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var a = "", r = n.indexOf(".");
    if (r >= 0 && (a = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: a };
  });
}
cl.prototype = Ib.prototype = {
  constructor: cl,
  on: function(e, t) {
    var n = this._, a = YF(e + "", n), r, o = -1, s = a.length;
    if (arguments.length < 2) {
      for (; ++o < s; ) if ((r = (e = a[o]).type) && (r = XF(n[r], e.name))) return r;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++o < s; )
      if (r = (e = a[o]).type) n[r] = Xv(n[r], e.name, t);
      else if (t == null) for (r in n) n[r] = Xv(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new cl(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0) for (var n = new Array(r), a = 0, r, o; a < r; ++a) n[a] = arguments[a + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (o = this._[e], a = 0, r = o.length; a < r; ++a) o[a].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
  }
};
function XF(e, t) {
  for (var n = 0, a = e.length, r; n < a; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function Xv(e, t, n) {
  for (var a = 0, r = e.length; a < r; ++a)
    if (e[a].name === t) {
      e[a] = KF, e = e.slice(0, a).concat(e.slice(a + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var zr = 0, Co = 0, vo = 0, Rb = 1e3, Kl, So, Yl = 0, er = 0, Ji = 0, Xo = typeof performance == "object" && performance.now ? performance : Date, Vb = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Mf() {
  return er || (Vb(JF), er = Xo.now() + Ji);
}
function JF() {
  er = 0;
}
function Xl() {
  this._call = this._time = this._next = null;
}
Xl.prototype = Fb.prototype = {
  constructor: Xl,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Mf() : +n) + (t == null ? 0 : +t), !this._next && So !== this && (So ? So._next = this : Kl = this, So = this), this._call = e, this._time = n, Rd();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Rd());
  }
};
function Fb(e, t, n) {
  var a = new Xl();
  return a.restart(e, t, n), a;
}
function ZF() {
  Mf(), ++zr;
  for (var e = Kl, t; e; )
    (t = er - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --zr;
}
function Jv() {
  er = (Yl = Xo.now()) + Ji, zr = Co = 0;
  try {
    ZF();
  } finally {
    zr = 0, eN(), er = 0;
  }
}
function QF() {
  var e = Xo.now(), t = e - Yl;
  t > Rb && (Ji -= t, Yl = e);
}
function eN() {
  for (var e, t = Kl, n, a = 1 / 0; t; )
    t._call ? (a > t._time && (a = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Kl = n);
  So = e, Rd(a);
}
function Rd(e) {
  if (!zr) {
    Co && (Co = clearTimeout(Co));
    var t = e - er;
    t > 24 ? (e < 1 / 0 && (Co = setTimeout(Jv, e - Xo.now() - Ji)), vo && (vo = clearInterval(vo))) : (vo || (Yl = Xo.now(), vo = setInterval(QF, Rb)), zr = 1, Vb(Jv));
  }
}
function Zv(e, t, n) {
  var a = new Xl();
  return t = t == null ? 0 : +t, a.restart((r) => {
    a.stop(), e(r + t);
  }, t, n), a;
}
var tN = Ib("start", "end", "cancel", "interrupt"), nN = [], Nb = 0, Qv = 1, Vd = 2, fl = 3, em = 4, Fd = 5, pl = 6;
function Zi(e, t, n, a, r, o) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  aN(e, n, {
    name: t,
    index: a,
    // For context during callback.
    group: r,
    // For context during callback.
    on: tN,
    tween: nN,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: Nb
  });
}
function qf(e, t) {
  var n = Rn(e, t);
  if (n.state > Nb) throw new Error("too late; already scheduled");
  return n;
}
function Zn(e, t) {
  var n = Rn(e, t);
  if (n.state > fl) throw new Error("too late; already running");
  return n;
}
function Rn(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function aN(e, t, n) {
  var a = e.__transition, r;
  a[t] = n, n.timer = Fb(o, 0, n.time);
  function o(d) {
    n.state = Qv, n.timer.restart(s, n.delay, n.time), n.delay <= d && s(d - n.delay);
  }
  function s(d) {
    var c, f, p, v;
    if (n.state !== Qv) return u();
    for (c in a)
      if (v = a[c], v.name === n.name) {
        if (v.state === fl) return Zv(s);
        v.state === em ? (v.state = pl, v.timer.stop(), v.on.call("interrupt", e, e.__data__, v.index, v.group), delete a[c]) : +c < t && (v.state = pl, v.timer.stop(), v.on.call("cancel", e, e.__data__, v.index, v.group), delete a[c]);
      }
    if (Zv(function() {
      n.state === fl && (n.state = em, n.timer.restart(i, n.delay, n.time), i(d));
    }), n.state = Vd, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Vd) {
      for (n.state = fl, r = new Array(p = n.tween.length), c = 0, f = -1; c < p; ++c)
        (v = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (r[++f] = v);
      r.length = f + 1;
    }
  }
  function i(d) {
    for (var c = d < n.duration ? n.ease.call(null, d / n.duration) : (n.timer.restart(u), n.state = Fd, 1), f = -1, p = r.length; ++f < p; )
      r[f].call(e, c);
    n.state === Fd && (n.on.call("end", e, e.__data__, n.index, n.group), u());
  }
  function u() {
    n.state = pl, n.timer.stop(), delete a[t];
    for (var d in a) return;
    delete e.__transition;
  }
}
function Lb(e, t) {
  var n = e.__transition, a, r, o = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((a = n[s]).name !== t) {
        o = !1;
        continue;
      }
      r = a.state > Vd && a.state < Fd, a.state = pl, a.timer.stop(), a.on.call(r ? "interrupt" : "cancel", e, e.__data__, a.index, a.group), delete n[s];
    }
    o && delete e.__transition;
  }
}
function rN(e) {
  return this.each(function() {
    Lb(this, e);
  });
}
const Ef = (e) => () => e;
function oN(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function sN(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(a) {
    return Math.pow(e + a * t, n);
  };
}
function lN(e) {
  return (e = +e) == 1 ? zb : function(t, n) {
    return n - t ? sN(t, n, e) : Ef(isNaN(t) ? n : t);
  };
}
function zb(e, t) {
  var n = t - e;
  return n ? oN(e, n) : Ef(isNaN(e) ? t : e);
}
const Jl = (function e(t) {
  var n = lN(t);
  function a(r, o) {
    var s = n((r = Id(r)).r, (o = Id(o)).r), i = n(r.g, o.g), u = n(r.b, o.b), d = zb(r.opacity, o.opacity);
    return function(c) {
      return r.r = s(c), r.g = i(c), r.b = u(c), r.opacity = d(c), r + "";
    };
  }
  return a.gamma = e, a;
})(1);
function iN(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, a = t.slice(), r;
  return function(o) {
    for (r = 0; r < n; ++r) a[r] = e[r] * (1 - o) + t[r] * o;
    return a;
  };
}
function uN(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function dN(e, t) {
  var n = t ? t.length : 0, a = e ? Math.min(n, e.length) : 0, r = new Array(a), o = new Array(n), s;
  for (s = 0; s < a; ++s) r[s] = oo(e[s], t[s]);
  for (; s < n; ++s) o[s] = t[s];
  return function(i) {
    for (s = 0; s < a; ++s) o[s] = r[s](i);
    return o;
  };
}
function cN(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(a) {
    return n.setTime(e * (1 - a) + t * a), n;
  };
}
function Sn(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function fN(e, t) {
  var n = {}, a = {}, r;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in e ? n[r] = oo(e[r], t[r]) : a[r] = t[r];
  return function(o) {
    for (r in n) a[r] = n[r](o);
    return a;
  };
}
var Nd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, zu = new RegExp(Nd.source, "g");
function pN(e) {
  return function() {
    return e;
  };
}
function vN(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Hb(e, t) {
  var n = Nd.lastIndex = zu.lastIndex = 0, a, r, o, s = -1, i = [], u = [];
  for (e = e + "", t = t + ""; (a = Nd.exec(e)) && (r = zu.exec(t)); )
    (o = r.index) > n && (o = t.slice(n, o), i[s] ? i[s] += o : i[++s] = o), (a = a[0]) === (r = r[0]) ? i[s] ? i[s] += r : i[++s] = r : (i[++s] = null, u.push({ i: s, x: Sn(a, r) })), n = zu.lastIndex;
  return n < t.length && (o = t.slice(n), i[s] ? i[s] += o : i[++s] = o), i.length < 2 ? u[0] ? vN(u[0].x) : pN(t) : (t = u.length, function(d) {
    for (var c = 0, f; c < t; ++c) i[(f = u[c]).i] = f.x(d);
    return i.join("");
  });
}
function oo(e, t) {
  var n = typeof t, a;
  return t == null || n === "boolean" ? Ef(t) : (n === "number" ? Sn : n === "string" ? (a = Qa(t)) ? (t = a, Jl) : Hb : t instanceof Qa ? Jl : t instanceof Date ? cN : uN(t) ? iN : Array.isArray(t) ? dN : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? fN : Sn)(e, t);
}
function Tf(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var tm = 180 / Math.PI, Ld = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Ub(e, t, n, a, r, o) {
  var s, i, u;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (u = e * n + t * a) && (n -= e * u, a -= t * u), (i = Math.sqrt(n * n + a * a)) && (n /= i, a /= i, u /= i), e * a < t * n && (e = -e, t = -t, u = -u, s = -s), {
    translateX: r,
    translateY: o,
    rotate: Math.atan2(t, e) * tm,
    skewX: Math.atan(u) * tm,
    scaleX: s,
    scaleY: i
  };
}
var Gs;
function mN(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Ld : Ub(t.a, t.b, t.c, t.d, t.e, t.f);
}
function hN(e) {
  return e == null || (Gs || (Gs = document.createElementNS("http://www.w3.org/2000/svg", "g")), Gs.setAttribute("transform", e), !(e = Gs.transform.baseVal.consolidate())) ? Ld : (e = e.matrix, Ub(e.a, e.b, e.c, e.d, e.e, e.f));
}
function jb(e, t, n, a) {
  function r(d) {
    return d.length ? d.pop() + " " : "";
  }
  function o(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var g = v.push("translate(", null, t, null, n);
      m.push({ i: g - 4, x: Sn(d, f) }, { i: g - 2, x: Sn(c, p) });
    } else (f || p) && v.push("translate(" + f + t + p + n);
  }
  function s(d, c, f, p) {
    d !== c ? (d - c > 180 ? c += 360 : c - d > 180 && (d += 360), p.push({ i: f.push(r(f) + "rotate(", null, a) - 2, x: Sn(d, c) })) : c && f.push(r(f) + "rotate(" + c + a);
  }
  function i(d, c, f, p) {
    d !== c ? p.push({ i: f.push(r(f) + "skewX(", null, a) - 2, x: Sn(d, c) }) : c && f.push(r(f) + "skewX(" + c + a);
  }
  function u(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var g = v.push(r(v) + "scale(", null, ",", null, ")");
      m.push({ i: g - 4, x: Sn(d, f) }, { i: g - 2, x: Sn(c, p) });
    } else (f !== 1 || p !== 1) && v.push(r(v) + "scale(" + f + "," + p + ")");
  }
  return function(d, c) {
    var f = [], p = [];
    return d = e(d), c = e(c), o(d.translateX, d.translateY, c.translateX, c.translateY, f, p), s(d.rotate, c.rotate, f, p), i(d.skewX, c.skewX, f, p), u(d.scaleX, d.scaleY, c.scaleX, c.scaleY, f, p), d = c = null, function(v) {
      for (var m = -1, g = p.length, w; ++m < g; ) f[(w = p[m]).i] = w.x(v);
      return f.join("");
    };
  };
}
var gN = jb(mN, "px, ", "px)", "deg)"), yN = jb(hN, ", ", ")", ")");
function bN(e, t) {
  t === void 0 && (t = e, e = oo);
  for (var n = 0, a = t.length - 1, r = t[0], o = new Array(a < 0 ? 0 : a); n < a; ) o[n] = e(r, r = t[++n]);
  return function(s) {
    var i = Math.max(0, Math.min(a - 1, Math.floor(s *= a)));
    return o[i](s - i);
  };
}
function _N(e, t) {
  var n, a;
  return function() {
    var r = Zn(this, e), o = r.tween;
    if (o !== n) {
      a = n = o;
      for (var s = 0, i = a.length; s < i; ++s)
        if (a[s].name === t) {
          a = a.slice(), a.splice(s, 1);
          break;
        }
    }
    r.tween = a;
  };
}
function wN(e, t, n) {
  var a, r;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = Zn(this, e), s = o.tween;
    if (s !== a) {
      r = (a = s).slice();
      for (var i = { name: t, value: n }, u = 0, d = r.length; u < d; ++u)
        if (r[u].name === t) {
          r[u] = i;
          break;
        }
      u === d && r.push(i);
    }
    o.tween = r;
  };
}
function xN(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var a = Rn(this.node(), n).tween, r = 0, o = a.length, s; r < o; ++r)
      if ((s = a[r]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? _N : wN)(n, e, t));
}
function Af(e, t, n) {
  var a = e._id;
  return e.each(function() {
    var r = Zn(this, a);
    (r.value || (r.value = {}))[t] = n.apply(this, arguments);
  }), function(r) {
    return Rn(r, a).value[t];
  };
}
function Wb(e, t) {
  var n;
  return (typeof t == "number" ? Sn : t instanceof Qa ? Jl : (n = Qa(t)) ? (t = n, Jl) : Hb)(e, t);
}
function CN(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function SN(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function $N(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttribute(e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function BN(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function kN(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function PN(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function DN(e, t) {
  var n = Wi(e), a = n === "transform" ? yN : Wb;
  return this.attrTween(e, typeof t == "function" ? (n.local ? PN : kN)(n, a, Af(this, "attr." + e, t)) : t == null ? (n.local ? SN : CN)(n) : (n.local ? BN : $N)(n, a, t));
}
function MN(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function qN(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function EN(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && qN(e, o)), n;
  }
  return r._value = t, r;
}
function TN(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && MN(e, o)), n;
  }
  return r._value = t, r;
}
function AN(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var a = Wi(e);
  return this.tween(n, (a.local ? EN : TN)(a, t));
}
function ON(e, t) {
  return function() {
    qf(this, e).delay = +t.apply(this, arguments);
  };
}
function IN(e, t) {
  return t = +t, function() {
    qf(this, e).delay = t;
  };
}
function RN(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? ON : IN)(t, e)) : Rn(this.node(), t).delay;
}
function VN(e, t) {
  return function() {
    Zn(this, e).duration = +t.apply(this, arguments);
  };
}
function FN(e, t) {
  return t = +t, function() {
    Zn(this, e).duration = t;
  };
}
function NN(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? VN : FN)(t, e)) : Rn(this.node(), t).duration;
}
function LN(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    Zn(this, e).ease = t;
  };
}
function zN(e) {
  var t = this._id;
  return arguments.length ? this.each(LN(t, e)) : Rn(this.node(), t).ease;
}
function HN(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    Zn(this, e).ease = n;
  };
}
function UN(e) {
  if (typeof e != "function") throw new Error();
  return this.each(HN(this._id, e));
}
function jN(e) {
  typeof e != "function" && (e = lb(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new da(a, this._parents, this._name, this._id);
}
function WN(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, a = t.length, r = n.length, o = Math.min(a, r), s = new Array(a), i = 0; i < o; ++i)
    for (var u = t[i], d = n[i], c = u.length, f = s[i] = new Array(c), p, v = 0; v < c; ++v)
      (p = u[v] || d[v]) && (f[v] = p);
  for (; i < a; ++i)
    s[i] = t[i];
  return new da(s, this._parents, this._name, this._id);
}
function GN(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function KN(e, t, n) {
  var a, r, o = GN(t) ? qf : Zn;
  return function() {
    var s = o(this, e), i = s.on;
    i !== a && (r = (a = i).copy()).on(t, n), s.on = r;
  };
}
function YN(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Rn(this.node(), n).on.on(e) : this.each(KN(n, e, t));
}
function XN(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function JN() {
  return this.on("end.remove", XN(this._id));
}
function ZN(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = _f(e));
  for (var a = this._groups, r = a.length, o = new Array(r), s = 0; s < r; ++s)
    for (var i = a[s], u = i.length, d = o[s] = new Array(u), c, f, p = 0; p < u; ++p)
      (c = i[p]) && (f = e.call(c, c.__data__, p, i)) && ("__data__" in c && (f.__data__ = c.__data__), d[p] = f, Zi(d[p], t, n, p, d, Rn(c, n)));
  return new da(o, this._parents, t, n);
}
function QN(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = sb(e));
  for (var a = this._groups, r = a.length, o = [], s = [], i = 0; i < r; ++i)
    for (var u = a[i], d = u.length, c, f = 0; f < d; ++f)
      if (c = u[f]) {
        for (var p = e.call(c, c.__data__, f, u), v, m = Rn(c, n), g = 0, w = p.length; g < w; ++g)
          (v = p[g]) && Zi(v, t, n, g, p, m);
        o.push(p), s.push(c);
      }
  return new da(o, s, t, n);
}
var e5 = ws.prototype.constructor;
function t5() {
  return new e5(this._groups, this._parents);
}
function n5(e, t) {
  var n, a, r;
  return function() {
    var o = Nr(this, e), s = (this.style.removeProperty(e), Nr(this, e));
    return o === s ? null : o === n && s === a ? r : r = t(n = o, a = s);
  };
}
function Gb(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function a5(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = Nr(this, e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function r5(e, t, n) {
  var a, r, o;
  return function() {
    var s = Nr(this, e), i = n(this), u = i + "";
    return i == null && (u = i = (this.style.removeProperty(e), Nr(this, e))), s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i));
  };
}
function o5(e, t) {
  var n, a, r, o = "style." + t, s = "end." + o, i;
  return function() {
    var u = Zn(this, e), d = u.on, c = u.value[o] == null ? i || (i = Gb(t)) : void 0;
    (d !== n || r !== c) && (a = (n = d).copy()).on(s, r = c), u.on = a;
  };
}
function s5(e, t, n) {
  var a = (e += "") == "transform" ? gN : Wb;
  return t == null ? this.styleTween(e, n5(e, a)).on("end.style." + e, Gb(e)) : typeof t == "function" ? this.styleTween(e, r5(e, a, Af(this, "style." + e, t))).each(o5(this._id, e)) : this.styleTween(e, a5(e, a, t), n).on("end.style." + e, null);
}
function l5(e, t, n) {
  return function(a) {
    this.style.setProperty(e, t.call(this, a), n);
  };
}
function i5(e, t, n) {
  var a, r;
  function o() {
    var s = t.apply(this, arguments);
    return s !== r && (a = (r = s) && l5(e, s, n)), a;
  }
  return o._value = t, o;
}
function u5(e, t, n) {
  var a = "style." + (e += "");
  if (arguments.length < 2) return (a = this.tween(a)) && a._value;
  if (t == null) return this.tween(a, null);
  if (typeof t != "function") throw new Error();
  return this.tween(a, i5(e, t, n ?? ""));
}
function d5(e) {
  return function() {
    this.textContent = e;
  };
}
function c5(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function f5(e) {
  return this.tween("text", typeof e == "function" ? c5(Af(this, "text", e)) : d5(e == null ? "" : e + ""));
}
function p5(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function v5(e) {
  var t, n;
  function a() {
    var r = e.apply(this, arguments);
    return r !== n && (t = (n = r) && p5(r)), t;
  }
  return a._value = e, a;
}
function m5(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, v5(e));
}
function h5() {
  for (var e = this._name, t = this._id, n = Kb(), a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      if (u = s[d]) {
        var c = Rn(u, t);
        Zi(u, e, n, d, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new da(a, this._parents, e, n);
}
function g5() {
  var e, t, n = this, a = n._id, r = n.size();
  return new Promise(function(o, s) {
    var i = { value: s }, u = { value: function() {
      --r === 0 && o();
    } };
    n.each(function() {
      var d = Zn(this, a), c = d.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(i), t._.interrupt.push(i), t._.end.push(u)), d.on = t;
    }), r === 0 && o();
  });
}
var y5 = 0;
function da(e, t, n, a) {
  this._groups = e, this._parents = t, this._name = n, this._id = a;
}
function Kb() {
  return ++y5;
}
var ea = ws.prototype;
da.prototype = {
  constructor: da,
  select: ZN,
  selectAll: QN,
  selectChild: ea.selectChild,
  selectChildren: ea.selectChildren,
  filter: jN,
  merge: WN,
  selection: t5,
  transition: h5,
  call: ea.call,
  nodes: ea.nodes,
  node: ea.node,
  size: ea.size,
  empty: ea.empty,
  each: ea.each,
  on: YN,
  attr: DN,
  attrTween: AN,
  style: s5,
  styleTween: u5,
  text: f5,
  textTween: m5,
  remove: JN,
  tween: xN,
  delay: RN,
  duration: NN,
  ease: zN,
  easeVarying: UN,
  end: g5,
  [Symbol.iterator]: ea[Symbol.iterator]
};
const nm = (e) => +e;
function b5(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var _5 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: b5
};
function w5(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function x5(e) {
  var t, n;
  e instanceof da ? (t = e._id, e = e._name) : (t = Kb(), (n = _5).time = Mf(), e = e == null ? null : e + "");
  for (var a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && Zi(u, e, t, d, s, n || w5(u, t));
  return new da(a, this._parents, e, t);
}
ws.prototype.interrupt = rN;
ws.prototype.transition = x5;
function Hu(e, t, n) {
  if (e.nodes().forEach((a) => Lb(a)), t) {
    const a = e.transition().duration(t);
    return n && a.ease(n), a;
  } else
    return e;
}
class Yb {
  constructor(t) {
    this.data = t;
  }
  get data() {
    return this._data;
  }
  set data(t) {
    this._data = t;
  }
}
function Vn(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Xb(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const am = /* @__PURE__ */ Symbol("implicit");
function Of() {
  var e = new Bv(), t = [], n = [], a = am;
  function r(o) {
    let s = e.get(o);
    if (s === void 0) {
      if (a !== am) return a;
      e.set(o, s = t.push(o) - 1);
    }
    return n[s % n.length];
  }
  return r.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new Bv();
    for (const s of o)
      e.has(s) || e.set(s, t.push(s) - 1);
    return r;
  }, r.range = function(o) {
    return arguments.length ? (n = Array.from(o), r) : n.slice();
  }, r.unknown = function(o) {
    return arguments.length ? (a = o, r) : a;
  }, r.copy = function() {
    return Of(t, n).unknown(a);
  }, Vn.apply(r, arguments), r;
}
function If() {
  var e = Of().unknown(void 0), t = e.domain, n = e.range, a = 0, r = 1, o, s, i = !1, u = 0, d = 0, c = 0.5;
  delete e.unknown;
  function f() {
    var p = t().length, v = r < a, m = v ? r : a, g = v ? a : r;
    o = (g - m) / Math.max(1, p - u + d * 2), i && (o = Math.floor(o)), m += (g - m - o * (p - u)) * c, s = o * (1 - u), i && (m = Math.round(m), s = Math.round(s));
    var w = TV(p).map(function(C) {
      return m + o * C;
    });
    return n(v ? w.reverse() : w);
  }
  return e.domain = function(p) {
    return arguments.length ? (t(p), f()) : t();
  }, e.range = function(p) {
    return arguments.length ? ([a, r] = p, a = +a, r = +r, f()) : [a, r];
  }, e.rangeRound = function(p) {
    return [a, r] = p, a = +a, r = +r, i = !0, f();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return o;
  }, e.round = function(p) {
    return arguments.length ? (i = !!p, f()) : i;
  }, e.padding = function(p) {
    return arguments.length ? (u = Math.min(1, d = +p), f()) : u;
  }, e.paddingInner = function(p) {
    return arguments.length ? (u = Math.min(1, p), f()) : u;
  }, e.paddingOuter = function(p) {
    return arguments.length ? (d = +p, f()) : d;
  }, e.align = function(p) {
    return arguments.length ? (c = Math.max(0, Math.min(1, p)), f()) : c;
  }, e.copy = function() {
    return If(t(), [a, r]).round(i).paddingInner(u).paddingOuter(d).align(c);
  }, Vn.apply(f(), arguments);
}
function Jb(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return Jb(t());
  }, e;
}
function C5() {
  return Jb(If.apply(null, arguments).paddingInner(1));
}
function S5(e) {
  return function() {
    return e;
  };
}
function zd(e) {
  return +e;
}
var rm = [0, 1];
function Qt(e) {
  return e;
}
function Hd(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : S5(isNaN(t) ? NaN : 0.5);
}
function $5(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(a) {
    return Math.max(e, Math.min(t, a));
  };
}
function B5(e, t, n) {
  var a = e[0], r = e[1], o = t[0], s = t[1];
  return r < a ? (a = Hd(r, a), o = n(s, o)) : (a = Hd(a, r), o = n(o, s)), function(i) {
    return o(a(i));
  };
}
function k5(e, t, n) {
  var a = Math.min(e.length, t.length) - 1, r = new Array(a), o = new Array(a), s = -1;
  for (e[a] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < a; )
    r[s] = Hd(e[s], e[s + 1]), o[s] = n(t[s], t[s + 1]);
  return function(i) {
    var u = xs(e, i, 1, a) - 1;
    return o[u](r[u](i));
  };
}
function $s(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function Qi() {
  var e = rm, t = rm, n = oo, a, r, o, s = Qt, i, u, d;
  function c() {
    var p = Math.min(e.length, t.length);
    return s !== Qt && (s = $5(e[0], e[p - 1])), i = p > 2 ? k5 : B5, u = d = null, f;
  }
  function f(p) {
    return p == null || isNaN(p = +p) ? o : (u || (u = i(e.map(a), t, n)))(a(s(p)));
  }
  return f.invert = function(p) {
    return s(r((d || (d = i(t, e.map(a), Sn)))(p)));
  }, f.domain = function(p) {
    return arguments.length ? (e = Array.from(p, zd), c()) : e.slice();
  }, f.range = function(p) {
    return arguments.length ? (t = Array.from(p), c()) : t.slice();
  }, f.rangeRound = function(p) {
    return t = Array.from(p), n = Tf, c();
  }, f.clamp = function(p) {
    return arguments.length ? (s = p ? !0 : Qt, c()) : s !== Qt;
  }, f.interpolate = function(p) {
    return arguments.length ? (n = p, c()) : n;
  }, f.unknown = function(p) {
    return arguments.length ? (o = p, f) : o;
  }, function(p, v) {
    return a = p, r = v, c();
  };
}
function Zb() {
  return Qi()(Qt, Qt);
}
function P5(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Zl(e, t) {
  if (!isFinite(e) || e === 0) return null;
  var n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e"), a = e.slice(0, n);
  return [
    a.length > 1 ? a[0] + a.slice(2) : a,
    +e.slice(n + 1)
  ];
}
function Hr(e) {
  return e = Zl(Math.abs(e)), e ? e[1] : NaN;
}
function D5(e, t) {
  return function(n, a) {
    for (var r = n.length, o = [], s = 0, i = e[0], u = 0; r > 0 && i > 0 && (u + i + 1 > a && (i = Math.max(1, a - u)), o.push(n.substring(r -= i, r + i)), !((u += i + 1) > a)); )
      i = e[s = (s + 1) % e.length];
    return o.reverse().join(t);
  };
}
function M5(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var q5 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Jo(e) {
  if (!(t = q5.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new Rf({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Jo.prototype = Rf.prototype;
function Rf(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
Rf.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function E5(e) {
  e: for (var t = e.length, n = 1, a = -1, r; n < t; ++n)
    switch (e[n]) {
      case ".":
        a = r = n;
        break;
      case "0":
        a === 0 && (a = n), r = n;
        break;
      default:
        if (!+e[n]) break e;
        a > 0 && (a = 0);
        break;
    }
  return a > 0 ? e.slice(0, a) + e.slice(r + 1) : e;
}
var Ql;
function T5(e, t) {
  var n = Zl(e, t);
  if (!n) return Ql = void 0, e.toPrecision(t);
  var a = n[0], r = n[1], o = r - (Ql = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, s = a.length;
  return o === s ? a : o > s ? a + new Array(o - s + 1).join("0") : o > 0 ? a.slice(0, o) + "." + a.slice(o) : "0." + new Array(1 - o).join("0") + Zl(e, Math.max(0, t + o - 1))[0];
}
function om(e, t) {
  var n = Zl(e, t);
  if (!n) return e + "";
  var a = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + a : a.length > r + 1 ? a.slice(0, r + 1) + "." + a.slice(r + 1) : a + new Array(r - a.length + 2).join("0");
}
const sm = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: P5,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => om(e * 100, t),
  r: om,
  s: T5,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function lm(e) {
  return e;
}
var im = Array.prototype.map, um = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function A5(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? lm : D5(im.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", a = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? lm : M5(im.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", i = e.minus === void 0 ? "" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function d(f, p) {
    f = Jo(f);
    var v = f.fill, m = f.align, g = f.sign, w = f.symbol, C = f.zero, S = f.width, $ = f.comma, k = f.precision, B = f.trim, D = f.type;
    D === "n" ? ($ = !0, D = "g") : sm[D] || (k === void 0 && (k = 12), B = !0, D = "g"), (C || v === "0" && m === "=") && (C = !0, v = "0", m = "=");
    var P = (p && p.prefix !== void 0 ? p.prefix : "") + (w === "$" ? n : w === "#" && /[boxX]/.test(D) ? "0" + D.toLowerCase() : ""), E = (w === "$" ? a : /[%p]/.test(D) ? s : "") + (p && p.suffix !== void 0 ? p.suffix : ""), T = sm[D], M = /[defgprs%]/.test(D);
    k = k === void 0 ? 6 : /[gprs]/.test(D) ? Math.max(1, Math.min(21, k)) : Math.max(0, Math.min(20, k));
    function I(F) {
      var J = P, ne = E, Q, G, H;
      if (D === "c")
        ne = T(F) + ne, F = "";
      else {
        F = +F;
        var U = F < 0 || 1 / F < 0;
        if (F = isNaN(F) ? u : T(Math.abs(F), k), B && (F = E5(F)), U && +F == 0 && g !== "+" && (U = !1), J = (U ? g === "(" ? g : i : g === "-" || g === "(" ? "" : g) + J, ne = (D === "s" && !isNaN(F) && Ql !== void 0 ? um[8 + Ql / 3] : "") + ne + (U && g === "(" ? ")" : ""), M) {
          for (Q = -1, G = F.length; ++Q < G; )
            if (H = F.charCodeAt(Q), 48 > H || H > 57) {
              ne = (H === 46 ? r + F.slice(Q + 1) : F.slice(Q)) + ne, F = F.slice(0, Q);
              break;
            }
        }
      }
      $ && !C && (F = t(F, 1 / 0));
      var se = J.length + F.length + ne.length, ee = se < S ? new Array(S - se + 1).join(v) : "";
      switch ($ && C && (F = t(ee + F, ee.length ? S - ne.length : 1 / 0), ee = ""), m) {
        case "<":
          F = J + F + ne + ee;
          break;
        case "=":
          F = J + ee + F + ne;
          break;
        case "^":
          F = ee.slice(0, se = ee.length >> 1) + J + F + ne + ee.slice(se);
          break;
        default:
          F = ee + J + F + ne;
          break;
      }
      return o(F);
    }
    return I.toString = function() {
      return f + "";
    }, I;
  }
  function c(f, p) {
    var v = Math.max(-8, Math.min(8, Math.floor(Hr(p) / 3))) * 3, m = Math.pow(10, -v), g = d((f = Jo(f), f.type = "f", f), { suffix: um[8 + v / 3] });
    return function(w) {
      return g(m * w);
    };
  }
  return {
    format: d,
    formatPrefix: c
  };
}
var Ks, Vf, Qb;
O5({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function O5(e) {
  return Ks = A5(e), Vf = Ks.format, Qb = Ks.formatPrefix, Ks;
}
function I5(e) {
  return Math.max(0, -Hr(Math.abs(e)));
}
function R5(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Hr(t) / 3))) * 3 - Hr(Math.abs(e)));
}
function V5(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Hr(t) - Hr(e)) + 1;
}
function F5(e, t, n, a) {
  var r = qd(e, t, n), o;
  switch (a = Jo(a ?? ",f"), a.type) {
    case "s": {
      var s = Math.max(Math.abs(e), Math.abs(t));
      return a.precision == null && !isNaN(o = R5(r, s)) && (a.precision = o), Qb(a, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      a.precision == null && !isNaN(o = V5(r, Math.max(Math.abs(e), Math.abs(t)))) && (a.precision = o - (a.type === "e"));
      break;
    }
    case "f":
    case "%": {
      a.precision == null && !isNaN(o = I5(r)) && (a.precision = o - (a.type === "%") * 2);
      break;
    }
  }
  return Vf(a);
}
function fr(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var a = t();
    return Dd(a[0], a[a.length - 1], n ?? 10);
  }, e.tickFormat = function(n, a) {
    var r = t();
    return F5(r[0], r[r.length - 1], n ?? 10, a);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var a = t(), r = 0, o = a.length - 1, s = a[r], i = a[o], u, d, c = 10;
    for (i < s && (d = s, s = i, i = d, d = r, r = o, o = d); c-- > 0; ) {
      if (d = Md(s, i, n), d === u)
        return a[r] = s, a[o] = i, t(a);
      if (d > 0)
        s = Math.floor(s / d) * d, i = Math.ceil(i / d) * d;
      else if (d < 0)
        s = Math.ceil(s * d) / d, i = Math.floor(i * d) / d;
      else
        break;
      u = d;
    }
    return e;
  }, e;
}
function e_() {
  var e = Zb();
  return e.copy = function() {
    return $s(e, e_());
  }, Vn.apply(e, arguments), fr(e);
}
function t_(e) {
  var t;
  function n(a) {
    return a == null || isNaN(a = +a) ? t : a;
  }
  return n.invert = n, n.domain = n.range = function(a) {
    return arguments.length ? (e = Array.from(a, zd), n) : e.slice();
  }, n.unknown = function(a) {
    return arguments.length ? (t = a, n) : t;
  }, n.copy = function() {
    return t_(e).unknown(t);
  }, e = arguments.length ? Array.from(e, zd) : [0, 1], fr(n);
}
function n_(e, t) {
  e = e.slice();
  var n = 0, a = e.length - 1, r = e[n], o = e[a], s;
  return o < r && (s = n, n = a, a = s, s = r, r = o, o = s), e[n] = t.floor(r), e[a] = t.ceil(o), e;
}
function dm(e) {
  return Math.log(e);
}
function cm(e) {
  return Math.exp(e);
}
function N5(e) {
  return -Math.log(-e);
}
function L5(e) {
  return -Math.exp(-e);
}
function z5(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function H5(e) {
  return e === 10 ? z5 : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function U5(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function fm(e) {
  return (t, n) => -e(-t, n);
}
function j5(e) {
  const t = e(dm, cm), n = t.domain;
  let a = 10, r, o;
  function s() {
    return r = U5(a), o = H5(a), n()[0] < 0 ? (r = fm(r), o = fm(o), e(N5, L5)) : e(dm, cm), t;
  }
  return t.base = function(i) {
    return arguments.length ? (a = +i, s()) : a;
  }, t.domain = function(i) {
    return arguments.length ? (n(i), s()) : n();
  }, t.ticks = (i) => {
    const u = n();
    let d = u[0], c = u[u.length - 1];
    const f = c < d;
    f && ([d, c] = [c, d]);
    let p = r(d), v = r(c), m, g;
    const w = i == null ? 10 : +i;
    let C = [];
    if (!(a % 1) && v - p < w) {
      if (p = Math.floor(p), v = Math.ceil(v), d > 0) {
        for (; p <= v; ++p)
          for (m = 1; m < a; ++m)
            if (g = p < 0 ? m / o(-p) : m * o(p), !(g < d)) {
              if (g > c) break;
              C.push(g);
            }
      } else for (; p <= v; ++p)
        for (m = a - 1; m >= 1; --m)
          if (g = p > 0 ? m / o(-p) : m * o(p), !(g < d)) {
            if (g > c) break;
            C.push(g);
          }
      C.length * 2 < w && (C = Dd(d, c, w));
    } else
      C = Dd(p, v, Math.min(v - p, w)).map(o);
    return f ? C.reverse() : C;
  }, t.tickFormat = (i, u) => {
    if (i == null && (i = 10), u == null && (u = a === 10 ? "s" : ","), typeof u != "function" && (!(a % 1) && (u = Jo(u)).precision == null && (u.trim = !0), u = Vf(u)), i === 1 / 0) return u;
    const d = Math.max(1, a * i / t.ticks().length);
    return (c) => {
      let f = c / o(Math.round(r(c)));
      return f * a < a - 0.5 && (f *= a), f <= d ? u(c) : "";
    };
  }, t.nice = () => n(n_(n(), {
    floor: (i) => o(Math.floor(r(i))),
    ceil: (i) => o(Math.ceil(r(i)))
  })), t;
}
function a_() {
  const e = j5(Qi()).domain([1, 10]);
  return e.copy = () => $s(e, a_()).base(e.base()), Vn.apply(e, arguments), e;
}
function pm(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function vm(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function W5(e) {
  var t = 1, n = e(pm(t), vm(t));
  return n.constant = function(a) {
    return arguments.length ? e(pm(t = +a), vm(t)) : t;
  }, fr(n);
}
function r_() {
  var e = W5(Qi());
  return e.copy = function() {
    return $s(e, r_()).constant(e.constant());
  }, Vn.apply(e, arguments);
}
function mm(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function G5(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function K5(e) {
  return e < 0 ? -e * e : e * e;
}
function Y5(e) {
  var t = e(Qt, Qt), n = 1;
  function a() {
    return n === 1 ? e(Qt, Qt) : n === 0.5 ? e(G5, K5) : e(mm(n), mm(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, a()) : n;
  }, fr(t);
}
function Ff() {
  var e = Y5(Qi());
  return e.copy = function() {
    return $s(e, Ff()).exponent(e.exponent());
  }, Vn.apply(e, arguments), e;
}
function X5() {
  return Ff.apply(null, arguments).exponent(0.5);
}
function o_() {
  var e = [], t = [], n = [], a;
  function r() {
    var s = 0, i = Math.max(1, t.length);
    for (n = new Array(i - 1); ++s < i; ) n[s - 1] = EV(e, s / i);
    return o;
  }
  function o(s) {
    return s == null || isNaN(s = +s) ? a : t[xs(n, s)];
  }
  return o.invertExtent = function(s) {
    var i = t.indexOf(s);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? n[i - 1] : e[0],
      i < n.length ? n[i] : e[e.length - 1]
    ];
  }, o.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of s) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort(qo), r();
  }, o.range = function(s) {
    return arguments.length ? (t = Array.from(s), r()) : t.slice();
  }, o.unknown = function(s) {
    return arguments.length ? (a = s, o) : a;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return o_().domain(e).range(t).unknown(a);
  }, Vn.apply(o, arguments);
}
function s_() {
  var e = 0, t = 1, n = 1, a = [0.5], r = [0, 1], o;
  function s(u) {
    return u != null && u <= u ? r[xs(a, u, 0, n)] : o;
  }
  function i() {
    var u = -1;
    for (a = new Array(n); ++u < n; ) a[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return s;
  }
  return s.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, i()) : [e, t];
  }, s.range = function(u) {
    return arguments.length ? (n = (r = Array.from(u)).length - 1, i()) : r.slice();
  }, s.invertExtent = function(u) {
    var d = r.indexOf(u);
    return d < 0 ? [NaN, NaN] : d < 1 ? [e, a[0]] : d >= n ? [a[n - 1], t] : [a[d - 1], a[d]];
  }, s.unknown = function(u) {
    return arguments.length && (o = u), s;
  }, s.thresholds = function() {
    return a.slice();
  }, s.copy = function() {
    return s_().domain([e, t]).range(r).unknown(o);
  }, Vn.apply(fr(s), arguments);
}
function l_() {
  var e = [0.5], t = [0, 1], n, a = 1;
  function r(o) {
    return o != null && o <= o ? t[xs(e, o, 0, a)] : n;
  }
  return r.domain = function(o) {
    return arguments.length ? (e = Array.from(o), a = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(o) {
    return arguments.length ? (t = Array.from(o), a = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(o) {
    var s = t.indexOf(o);
    return [e[s - 1], e[s]];
  }, r.unknown = function(o) {
    return arguments.length ? (n = o, r) : n;
  }, r.copy = function() {
    return l_().domain(e).range(t).unknown(n);
  }, Vn.apply(r, arguments);
}
const Uu = /* @__PURE__ */ new Date(), ju = /* @__PURE__ */ new Date();
function Dt(e, t, n, a) {
  function r(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return r.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), r.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), r.round = (o) => {
    const s = r(o), i = r.ceil(o);
    return o - s < i - o ? s : i;
  }, r.offset = (o, s) => (t(o = /* @__PURE__ */ new Date(+o), s == null ? 1 : Math.floor(s)), o), r.range = (o, s, i) => {
    const u = [];
    if (o = r.ceil(o), i = i == null ? 1 : Math.floor(i), !(o < s) || !(i > 0)) return u;
    let d;
    do
      u.push(d = /* @__PURE__ */ new Date(+o)), t(o, i), e(o);
    while (d < o && o < s);
    return u;
  }, r.filter = (o) => Dt((s) => {
    if (s >= s) for (; e(s), !o(s); ) s.setTime(s - 1);
  }, (s, i) => {
    if (s >= s)
      if (i < 0) for (; ++i <= 0; )
        for (; t(s, -1), !o(s); )
          ;
      else for (; --i >= 0; )
        for (; t(s, 1), !o(s); )
          ;
  }), n && (r.count = (o, s) => (Uu.setTime(+o), ju.setTime(+s), e(Uu), e(ju), Math.floor(n(Uu, ju))), r.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(a ? (s) => a(s) % o === 0 : (s) => r.count(0, s) % o === 0) : r)), r;
}
const ei = Dt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
ei.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Dt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : ei);
ei.range;
const sa = 1e3, _n = sa * 60, la = _n * 60, ca = la * 24, Nf = ca * 7, hm = ca * 30, Wu = ca * 365, Wa = Dt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * sa);
}, (e, t) => (t - e) / sa, (e) => e.getUTCSeconds());
Wa.range;
const Lf = Dt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * sa);
}, (e, t) => {
  e.setTime(+e + t * _n);
}, (e, t) => (t - e) / _n, (e) => e.getMinutes());
Lf.range;
const zf = Dt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * _n);
}, (e, t) => (t - e) / _n, (e) => e.getUTCMinutes());
zf.range;
const Hf = Dt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * sa - e.getMinutes() * _n);
}, (e, t) => {
  e.setTime(+e + t * la);
}, (e, t) => (t - e) / la, (e) => e.getHours());
Hf.range;
const Uf = Dt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * la);
}, (e, t) => (t - e) / la, (e) => e.getUTCHours());
Uf.range;
const Bs = Dt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * _n) / ca,
  (e) => e.getDate() - 1
);
Bs.range;
const eu = Dt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / ca, (e) => e.getUTCDate() - 1);
eu.range;
const i_ = Dt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / ca, (e) => Math.floor(e / ca));
i_.range;
function pr(e) {
  return Dt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * _n) / Nf);
}
const tu = pr(0), ti = pr(1), J5 = pr(2), Z5 = pr(3), Ur = pr(4), Q5 = pr(5), e6 = pr(6);
tu.range;
ti.range;
J5.range;
Z5.range;
Ur.range;
Q5.range;
e6.range;
function vr(e) {
  return Dt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / Nf);
}
const nu = vr(0), ni = vr(1), t6 = vr(2), n6 = vr(3), jr = vr(4), a6 = vr(5), r6 = vr(6);
nu.range;
ni.range;
t6.range;
n6.range;
jr.range;
a6.range;
r6.range;
const jf = Dt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
jf.range;
const Wf = Dt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
Wf.range;
const fa = Dt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
fa.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
fa.range;
const pa = Dt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
pa.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
pa.range;
function u_(e, t, n, a, r, o) {
  const s = [
    [Wa, 1, sa],
    [Wa, 5, 5 * sa],
    [Wa, 15, 15 * sa],
    [Wa, 30, 30 * sa],
    [o, 1, _n],
    [o, 5, 5 * _n],
    [o, 15, 15 * _n],
    [o, 30, 30 * _n],
    [r, 1, la],
    [r, 3, 3 * la],
    [r, 6, 6 * la],
    [r, 12, 12 * la],
    [a, 1, ca],
    [a, 2, 2 * ca],
    [n, 1, Nf],
    [t, 1, hm],
    [t, 3, 3 * hm],
    [e, 1, Wu]
  ];
  function i(d, c, f) {
    const p = c < d;
    p && ([d, c] = [c, d]);
    const v = f && typeof f.range == "function" ? f : u(d, c, f), m = v ? v.range(d, +c + 1) : [];
    return p ? m.reverse() : m;
  }
  function u(d, c, f) {
    const p = Math.abs(c - d) / f, v = xf(([, , w]) => w).right(s, p);
    if (v === s.length) return e.every(qd(d / Wu, c / Wu, f));
    if (v === 0) return ei.every(Math.max(qd(d, c, f), 1));
    const [m, g] = s[p / s[v - 1][2] < s[v][2] / p ? v - 1 : v];
    return m.every(g);
  }
  return [i, u];
}
const [o6, s6] = u_(pa, Wf, nu, i_, Uf, zf), [l6, i6] = u_(fa, jf, tu, Bs, Hf, Lf);
function Gu(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Ku(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function mo(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function u6(e) {
  var t = e.dateTime, n = e.date, a = e.time, r = e.periods, o = e.days, s = e.shortDays, i = e.months, u = e.shortMonths, d = ho(r), c = go(r), f = ho(o), p = go(o), v = ho(s), m = go(s), g = ho(i), w = go(i), C = ho(u), S = go(u), $ = {
    a: H,
    A: U,
    b: se,
    B: ee,
    c: null,
    d: xm,
    e: xm,
    f: E6,
    g: z6,
    G: U6,
    H: D6,
    I: M6,
    j: q6,
    L: d_,
    m: T6,
    M: A6,
    p: de,
    q: fe,
    Q: $m,
    s: Bm,
    S: O6,
    u: I6,
    U: R6,
    V: V6,
    w: F6,
    W: N6,
    x: null,
    X: null,
    y: L6,
    Y: H6,
    Z: j6,
    "%": Sm
  }, k = {
    a: _e,
    A: ye,
    b: Te,
    B: ce,
    c: null,
    d: Cm,
    e: Cm,
    f: Y6,
    g: oL,
    G: lL,
    H: W6,
    I: G6,
    j: K6,
    L: f_,
    m: X6,
    M: J6,
    p: V,
    q: te,
    Q: $m,
    s: Bm,
    S: Z6,
    u: Q6,
    U: eL,
    V: tL,
    w: nL,
    W: aL,
    x: null,
    X: null,
    y: rL,
    Y: sL,
    Z: iL,
    "%": Sm
  }, B = {
    a: M,
    A: I,
    b: F,
    B: J,
    c: ne,
    d: _m,
    e: _m,
    f: $6,
    g: bm,
    G: ym,
    H: wm,
    I: wm,
    j: w6,
    L: S6,
    m: _6,
    M: x6,
    p: T,
    q: b6,
    Q: k6,
    s: P6,
    S: C6,
    u: v6,
    U: m6,
    V: h6,
    w: p6,
    W: g6,
    x: Q,
    X: G,
    y: bm,
    Y: ym,
    Z: y6,
    "%": B6
  };
  $.x = D(n, $), $.X = D(a, $), $.c = D(t, $), k.x = D(n, k), k.X = D(a, k), k.c = D(t, k);
  function D(z, re) {
    return function(ie) {
      var L = [], be = -1, xe = 0, Fe = z.length, Xe, lt, ke;
      for (ie instanceof Date || (ie = /* @__PURE__ */ new Date(+ie)); ++be < Fe; )
        z.charCodeAt(be) === 37 && (L.push(z.slice(xe, be)), (lt = gm[Xe = z.charAt(++be)]) != null ? Xe = z.charAt(++be) : lt = Xe === "e" ? " " : "0", (ke = re[Xe]) && (Xe = ke(ie, lt)), L.push(Xe), xe = be + 1);
      return L.push(z.slice(xe, be)), L.join("");
    };
  }
  function P(z, re) {
    return function(ie) {
      var L = mo(1900, void 0, 1), be = E(L, z, ie += "", 0), xe, Fe;
      if (be != ie.length) return null;
      if ("Q" in L) return new Date(L.Q);
      if ("s" in L) return new Date(L.s * 1e3 + ("L" in L ? L.L : 0));
      if (re && !("Z" in L) && (L.Z = 0), "p" in L && (L.H = L.H % 12 + L.p * 12), L.m === void 0 && (L.m = "q" in L ? L.q : 0), "V" in L) {
        if (L.V < 1 || L.V > 53) return null;
        "w" in L || (L.w = 1), "Z" in L ? (xe = Ku(mo(L.y, 0, 1)), Fe = xe.getUTCDay(), xe = Fe > 4 || Fe === 0 ? ni.ceil(xe) : ni(xe), xe = eu.offset(xe, (L.V - 1) * 7), L.y = xe.getUTCFullYear(), L.m = xe.getUTCMonth(), L.d = xe.getUTCDate() + (L.w + 6) % 7) : (xe = Gu(mo(L.y, 0, 1)), Fe = xe.getDay(), xe = Fe > 4 || Fe === 0 ? ti.ceil(xe) : ti(xe), xe = Bs.offset(xe, (L.V - 1) * 7), L.y = xe.getFullYear(), L.m = xe.getMonth(), L.d = xe.getDate() + (L.w + 6) % 7);
      } else ("W" in L || "U" in L) && ("w" in L || (L.w = "u" in L ? L.u % 7 : "W" in L ? 1 : 0), Fe = "Z" in L ? Ku(mo(L.y, 0, 1)).getUTCDay() : Gu(mo(L.y, 0, 1)).getDay(), L.m = 0, L.d = "W" in L ? (L.w + 6) % 7 + L.W * 7 - (Fe + 5) % 7 : L.w + L.U * 7 - (Fe + 6) % 7);
      return "Z" in L ? (L.H += L.Z / 100 | 0, L.M += L.Z % 100, Ku(L)) : Gu(L);
    };
  }
  function E(z, re, ie, L) {
    for (var be = 0, xe = re.length, Fe = ie.length, Xe, lt; be < xe; ) {
      if (L >= Fe) return -1;
      if (Xe = re.charCodeAt(be++), Xe === 37) {
        if (Xe = re.charAt(be++), lt = B[Xe in gm ? re.charAt(be++) : Xe], !lt || (L = lt(z, ie, L)) < 0) return -1;
      } else if (Xe != ie.charCodeAt(L++))
        return -1;
    }
    return L;
  }
  function T(z, re, ie) {
    var L = d.exec(re.slice(ie));
    return L ? (z.p = c.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function M(z, re, ie) {
    var L = v.exec(re.slice(ie));
    return L ? (z.w = m.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function I(z, re, ie) {
    var L = f.exec(re.slice(ie));
    return L ? (z.w = p.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function F(z, re, ie) {
    var L = C.exec(re.slice(ie));
    return L ? (z.m = S.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function J(z, re, ie) {
    var L = g.exec(re.slice(ie));
    return L ? (z.m = w.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function ne(z, re, ie) {
    return E(z, t, re, ie);
  }
  function Q(z, re, ie) {
    return E(z, n, re, ie);
  }
  function G(z, re, ie) {
    return E(z, a, re, ie);
  }
  function H(z) {
    return s[z.getDay()];
  }
  function U(z) {
    return o[z.getDay()];
  }
  function se(z) {
    return u[z.getMonth()];
  }
  function ee(z) {
    return i[z.getMonth()];
  }
  function de(z) {
    return r[+(z.getHours() >= 12)];
  }
  function fe(z) {
    return 1 + ~~(z.getMonth() / 3);
  }
  function _e(z) {
    return s[z.getUTCDay()];
  }
  function ye(z) {
    return o[z.getUTCDay()];
  }
  function Te(z) {
    return u[z.getUTCMonth()];
  }
  function ce(z) {
    return i[z.getUTCMonth()];
  }
  function V(z) {
    return r[+(z.getUTCHours() >= 12)];
  }
  function te(z) {
    return 1 + ~~(z.getUTCMonth() / 3);
  }
  return {
    format: function(z) {
      var re = D(z += "", $);
      return re.toString = function() {
        return z;
      }, re;
    },
    parse: function(z) {
      var re = P(z += "", !1);
      return re.toString = function() {
        return z;
      }, re;
    },
    utcFormat: function(z) {
      var re = D(z += "", k);
      return re.toString = function() {
        return z;
      }, re;
    },
    utcParse: function(z) {
      var re = P(z += "", !0);
      return re.toString = function() {
        return z;
      }, re;
    }
  };
}
var gm = { "-": "", _: " ", 0: "0" }, At = /^\s*\d+/, d6 = /^%/, c6 = /[\\^$*+?|[\]().{}]/g;
function Ze(e, t, n) {
  var a = e < 0 ? "-" : "", r = (a ? -e : e) + "", o = r.length;
  return a + (o < n ? new Array(n - o + 1).join(t) + r : r);
}
function f6(e) {
  return e.replace(c6, "\\$&");
}
function ho(e) {
  return new RegExp("^(?:" + e.map(f6).join("|") + ")", "i");
}
function go(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function p6(e, t, n) {
  var a = At.exec(t.slice(n, n + 1));
  return a ? (e.w = +a[0], n + a[0].length) : -1;
}
function v6(e, t, n) {
  var a = At.exec(t.slice(n, n + 1));
  return a ? (e.u = +a[0], n + a[0].length) : -1;
}
function m6(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.U = +a[0], n + a[0].length) : -1;
}
function h6(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.V = +a[0], n + a[0].length) : -1;
}
function g6(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.W = +a[0], n + a[0].length) : -1;
}
function ym(e, t, n) {
  var a = At.exec(t.slice(n, n + 4));
  return a ? (e.y = +a[0], n + a[0].length) : -1;
}
function bm(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), n + a[0].length) : -1;
}
function y6(e, t, n) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), n + a[0].length) : -1;
}
function b6(e, t, n) {
  var a = At.exec(t.slice(n, n + 1));
  return a ? (e.q = a[0] * 3 - 3, n + a[0].length) : -1;
}
function _6(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.m = a[0] - 1, n + a[0].length) : -1;
}
function _m(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.d = +a[0], n + a[0].length) : -1;
}
function w6(e, t, n) {
  var a = At.exec(t.slice(n, n + 3));
  return a ? (e.m = 0, e.d = +a[0], n + a[0].length) : -1;
}
function wm(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.H = +a[0], n + a[0].length) : -1;
}
function x6(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.M = +a[0], n + a[0].length) : -1;
}
function C6(e, t, n) {
  var a = At.exec(t.slice(n, n + 2));
  return a ? (e.S = +a[0], n + a[0].length) : -1;
}
function S6(e, t, n) {
  var a = At.exec(t.slice(n, n + 3));
  return a ? (e.L = +a[0], n + a[0].length) : -1;
}
function $6(e, t, n) {
  var a = At.exec(t.slice(n, n + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), n + a[0].length) : -1;
}
function B6(e, t, n) {
  var a = d6.exec(t.slice(n, n + 1));
  return a ? n + a[0].length : -1;
}
function k6(e, t, n) {
  var a = At.exec(t.slice(n));
  return a ? (e.Q = +a[0], n + a[0].length) : -1;
}
function P6(e, t, n) {
  var a = At.exec(t.slice(n));
  return a ? (e.s = +a[0], n + a[0].length) : -1;
}
function xm(e, t) {
  return Ze(e.getDate(), t, 2);
}
function D6(e, t) {
  return Ze(e.getHours(), t, 2);
}
function M6(e, t) {
  return Ze(e.getHours() % 12 || 12, t, 2);
}
function q6(e, t) {
  return Ze(1 + Bs.count(fa(e), e), t, 3);
}
function d_(e, t) {
  return Ze(e.getMilliseconds(), t, 3);
}
function E6(e, t) {
  return d_(e, t) + "000";
}
function T6(e, t) {
  return Ze(e.getMonth() + 1, t, 2);
}
function A6(e, t) {
  return Ze(e.getMinutes(), t, 2);
}
function O6(e, t) {
  return Ze(e.getSeconds(), t, 2);
}
function I6(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function R6(e, t) {
  return Ze(tu.count(fa(e) - 1, e), t, 2);
}
function c_(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Ur(e) : Ur.ceil(e);
}
function V6(e, t) {
  return e = c_(e), Ze(Ur.count(fa(e), e) + (fa(e).getDay() === 4), t, 2);
}
function F6(e) {
  return e.getDay();
}
function N6(e, t) {
  return Ze(ti.count(fa(e) - 1, e), t, 2);
}
function L6(e, t) {
  return Ze(e.getFullYear() % 100, t, 2);
}
function z6(e, t) {
  return e = c_(e), Ze(e.getFullYear() % 100, t, 2);
}
function H6(e, t) {
  return Ze(e.getFullYear() % 1e4, t, 4);
}
function U6(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Ur(e) : Ur.ceil(e), Ze(e.getFullYear() % 1e4, t, 4);
}
function j6(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ze(t / 60 | 0, "0", 2) + Ze(t % 60, "0", 2);
}
function Cm(e, t) {
  return Ze(e.getUTCDate(), t, 2);
}
function W6(e, t) {
  return Ze(e.getUTCHours(), t, 2);
}
function G6(e, t) {
  return Ze(e.getUTCHours() % 12 || 12, t, 2);
}
function K6(e, t) {
  return Ze(1 + eu.count(pa(e), e), t, 3);
}
function f_(e, t) {
  return Ze(e.getUTCMilliseconds(), t, 3);
}
function Y6(e, t) {
  return f_(e, t) + "000";
}
function X6(e, t) {
  return Ze(e.getUTCMonth() + 1, t, 2);
}
function J6(e, t) {
  return Ze(e.getUTCMinutes(), t, 2);
}
function Z6(e, t) {
  return Ze(e.getUTCSeconds(), t, 2);
}
function Q6(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function eL(e, t) {
  return Ze(nu.count(pa(e) - 1, e), t, 2);
}
function p_(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? jr(e) : jr.ceil(e);
}
function tL(e, t) {
  return e = p_(e), Ze(jr.count(pa(e), e) + (pa(e).getUTCDay() === 4), t, 2);
}
function nL(e) {
  return e.getUTCDay();
}
function aL(e, t) {
  return Ze(ni.count(pa(e) - 1, e), t, 2);
}
function rL(e, t) {
  return Ze(e.getUTCFullYear() % 100, t, 2);
}
function oL(e, t) {
  return e = p_(e), Ze(e.getUTCFullYear() % 100, t, 2);
}
function sL(e, t) {
  return Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function lL(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? jr(e) : jr.ceil(e), Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function iL() {
  return "+0000";
}
function Sm() {
  return "%";
}
function $m(e) {
  return +e;
}
function Bm(e) {
  return Math.floor(+e / 1e3);
}
var wr, v_, m_;
uL({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function uL(e) {
  return wr = u6(e), v_ = wr.format, wr.parse, m_ = wr.utcFormat, wr.utcParse, wr;
}
function dL(e) {
  return new Date(e);
}
function cL(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Gf(e, t, n, a, r, o, s, i, u, d) {
  var c = Zb(), f = c.invert, p = c.domain, v = d(".%L"), m = d(":%S"), g = d("%I:%M"), w = d("%I %p"), C = d("%a %d"), S = d("%b %d"), $ = d("%B"), k = d("%Y");
  function B(D) {
    return (u(D) < D ? v : i(D) < D ? m : s(D) < D ? g : o(D) < D ? w : a(D) < D ? r(D) < D ? C : S : n(D) < D ? $ : k)(D);
  }
  return c.invert = function(D) {
    return new Date(f(D));
  }, c.domain = function(D) {
    return arguments.length ? p(Array.from(D, cL)) : p().map(dL);
  }, c.ticks = function(D) {
    var P = p();
    return e(P[0], P[P.length - 1], D ?? 10);
  }, c.tickFormat = function(D, P) {
    return P == null ? B : d(P);
  }, c.nice = function(D) {
    var P = p();
    return (!D || typeof D.range != "function") && (D = t(P[0], P[P.length - 1], D ?? 10)), D ? p(n_(P, D)) : c;
  }, c.copy = function() {
    return $s(c, Gf(e, t, n, a, r, o, s, i, u, d));
  }, c;
}
function fL() {
  return Vn.apply(Gf(l6, i6, fa, jf, tu, Bs, Hf, Lf, Wa, v_).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function pL() {
  return Vn.apply(Gf(o6, s6, pa, Wf, nu, eu, Uf, zf, Wa, m_).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function vL() {
  var e = 0, t = 1, n, a, r, o, s = Qt, i = !1, u;
  function d(f) {
    return f == null || isNaN(f = +f) ? u : s(r === 0 ? 0.5 : (f = (o(f) - n) * r, i ? Math.max(0, Math.min(1, f)) : f));
  }
  d.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = o(e = +e), a = o(t = +t), r = n === a ? 0 : 1 / (a - n), d) : [e, t];
  }, d.clamp = function(f) {
    return arguments.length ? (i = !!f, d) : i;
  }, d.interpolator = function(f) {
    return arguments.length ? (s = f, d) : s;
  };
  function c(f) {
    return function(p) {
      var v, m;
      return arguments.length ? ([v, m] = p, s = f(v, m), d) : [s(0), s(1)];
    };
  }
  return d.range = c(oo), d.rangeRound = c(Tf), d.unknown = function(f) {
    return arguments.length ? (u = f, d) : u;
  }, function(f) {
    return o = f, n = f(e), a = f(t), r = n === a ? 0 : 1 / (a - n), d;
  };
}
function h_(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function g_() {
  var e = fr(vL()(Qt));
  return e.copy = function() {
    return h_(e, g_());
  }, Xb.apply(e, arguments);
}
function mL() {
  var e = 0, t = 0.5, n = 1, a = 1, r, o, s, i, u, d = Qt, c, f = !1, p;
  function v(g) {
    return isNaN(g = +g) ? p : (g = 0.5 + ((g = +c(g)) - o) * (a * g < a * o ? i : u), d(f ? Math.max(0, Math.min(1, g)) : g));
  }
  v.domain = function(g) {
    return arguments.length ? ([e, t, n] = g, r = c(e = +e), o = c(t = +t), s = c(n = +n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v) : [e, t, n];
  }, v.clamp = function(g) {
    return arguments.length ? (f = !!g, v) : f;
  }, v.interpolator = function(g) {
    return arguments.length ? (d = g, v) : d;
  };
  function m(g) {
    return function(w) {
      var C, S, $;
      return arguments.length ? ([C, S, $] = w, d = bN(g, [C, S, $]), v) : [d(0), d(0.5), d(1)];
    };
  }
  return v.range = m(oo), v.rangeRound = m(Tf), v.unknown = function(g) {
    return arguments.length ? (p = g, v) : p;
  }, function(g) {
    return c = g, r = g(e), o = g(t), s = g(n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v;
  };
}
function y_() {
  var e = fr(mL()(Qt));
  return e.copy = function() {
    return h_(e, y_());
  }, Xb.apply(e, arguments);
}
const km = {
  scaleLinear: e_,
  scalePow: Ff,
  scaleSqrt: X5,
  scaleLog: a_,
  scaleSymlog: r_,
  scaleIdentity: t_,
  scaleTime: fL,
  scaleUtc: pL,
  scaleSequential: g_,
  scaleDiverging: y_,
  scaleQuantize: s_,
  scaleQuantile: o_,
  scaleThreshold: l_,
  scaleOrdinal: Of,
  scaleBand: If,
  scalePoint: C5
};
var Nn;
(function(e) {
  e.X = "x", e.Y = "y";
})(Nn || (Nn = {}));
const b_ = {
  duration: 600,
  events: {},
  attributes: {}
};
class hL {
  constructor(t = Mo.SVG) {
    var n, a;
    this.type = Mo.SVG, this.datamodel = new Yb(), this.sizing = Pd.Fit, this.events = {}, this._defaultConfig = b_, this._width = 400, this._height = 200, this._containerWidth = void 0, this._containerHeight = void 0, this._containerMargin = { top: 0, bottom: 0, left: 0, right: 0 }, this._setUpComponentEventsThrottled = zl(this._setUpComponentEvents, 500), this._setCustomAttributesThrottled = zl(this._setCustomAttributes, 500), t === Mo.SVG ? this.element = document.createElementNS("http://www.w3.org/2000/svg", "g") : this.element = document.createElement("div"), this.uid = DF(), this.g = Da(this.element);
    const r = (a = (n = this.constructor) === null || n === void 0 ? void 0 : n.selectors) === null || a === void 0 ? void 0 : a.root;
    r && this.g.attr("class", r);
  }
  /** Set the container margin. Called automatically by containers. */
  setContainerMargin(t) {
    this._containerMargin = t;
  }
  setConfig(t) {
    this.prevConfig = this.config, this.config = Gi(this._defaultConfig, t);
  }
  setData(t) {
    this.datamodel.data = t;
  }
  setSize(t, n, a, r) {
    isFinite(t) && (this._width = t), isFinite(n) && (this._height = n), isFinite(a) && (this._containerWidth = a), isFinite(r) && (this._containerHeight = r);
  }
  render(t = this.config.duration) {
    this._render(t);
    const n = "animating";
    t && (this.g.attr(n, ""), this.g.transition(n).duration(t).on("end interrupt", () => {
      this.g.attr(n, null);
    })), this._setUpComponentEventsThrottled(), this._setCustomAttributesThrottled();
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _render(t = this.config.duration) {
  }
  _setCustomAttributes() {
    const t = this.config.attributes;
    Object.keys(t).forEach((n) => {
      Object.keys(t[n]).forEach((a) => {
        this.g.selectAll(`.${n}`).attr(a, t[n][a]);
      });
    });
  }
  _setUpComponentEvents() {
    this._bindEvents(this.events), this._bindEvents(this.config.events, ".user");
  }
  _bindEvents(t = this.events, n = "") {
    Object.keys(t).forEach((a) => {
      Object.keys(t[a]).forEach((r) => {
        const o = this.g.selectAll(`.${a}`);
        o.on(r + n, (s, i) => {
          const u = o.nodes(), d = u.indexOf(s.currentTarget), c = t[a][r];
          return c?.(i, s, d, u);
        });
      });
    });
  }
  destroy() {
    var t;
    (t = this.g) === null || t === void 0 || t.remove(), this.element = void 0;
  }
  isDestroyed() {
    return !this.element;
  }
}
class gL extends Yb {
  constructor(t) {
    super(t);
  }
  get data() {
    var t;
    return (t = this._data) !== null && t !== void 0 ? t : [];
  }
  set data(t) {
    Array.isArray(t) && (this._data = t);
  }
}
const __ = Object.assign(Object.assign({}, b_), { x: void 0, y: void 0, id: (e, t) => {
  var n;
  return (n = e.id) !== null && n !== void 0 ? n : `${t}`;
}, color: (e) => e.color, xScale: void 0, yScale: void 0, excludeFromDomainCalculation: !1 });
class yL extends hL {
  constructor() {
    super(...arguments), this.datamodel = new gL(), this.clippable = !0, this.stacked = !1, this._defaultConfig = __, this._xScale = km.scaleLinear(), this._yScale = km.scaleLinear();
  }
  get xScale() {
    return this.config.xScale || this._xScale;
  }
  get yScale() {
    return this.config.yScale || this._yScale;
  }
  setConfig(t) {
    var n, a;
    !((n = this.config) === null || n === void 0) && n.xScale && (t.xScale = this.config.xScale), !((a = this.config) === null || a === void 0) && a.yScale && (t.yScale = this.config.yScale), super.setConfig(t);
  }
  setScaleDomain(t, n) {
    var a, r;
    t === Nn.X && ((a = this._xScale) === null || a === void 0 || a.domain(n)), t === Nn.Y && ((r = this._yScale) === null || r === void 0 || r.domain(n));
  }
  setScaleRange(t, n) {
    var a, r;
    t === Nn.X && ((a = this._xScale) === null || a === void 0 || a.range(n)), t === Nn.Y && ((r = this._yScale) === null || r === void 0 || r.range(n));
  }
  setScale(t, n) {
    n && t === Nn.X && (this._xScale = n), n && t === Nn.Y && (this._yScale = n);
  }
  getDataExtent(t, n) {
    const { config: a, datamodel: r } = this;
    switch (t) {
      case Nn.X:
        return this.getXDataExtent();
      case Nn.Y:
        return this.getYDataExtent(n);
      default:
        return Iu(r.data, a[t]);
    }
  }
  getXDataExtent() {
    const { config: t, datamodel: n } = this;
    return Iu(n.data, t.x);
  }
  /** Some components override this method to provide custom data extent calculation */
  getYDataExtent(t) {
    const { config: n, datamodel: a } = this, r = this.xScale.domain(), o = t ? FV(a.data, r, n.x, !0) : a.data, s = Sf(n.y) ? n.y : [n.y];
    return Iu(o, ...s);
  }
}
var et;
(function(e) {
  e.Top = "top", e.Bottom = "bottom", e.Left = "left", e.Right = "right", e.Center = "center", e.Auto = "auto";
})(et || (et = {}));
var Pm;
(function(e) {
  e.Absolute = "absolute", e.Fixed = "fixed";
})(Pm || (Pm = {}));
var Dm;
(function(e) {
  e.Inside = "inside", e.Outside = "outside", e.Center = "center";
})(Dm || (Dm = {}));
var Mm;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(Mm || (Mm = {}));
const bL = {
  components: [],
  container: void 0,
  followCursor: !0,
  allowHover: !1,
  horizontalPlacement: et.Auto,
  horizontalShift: 0,
  verticalPlacement: et.Top,
  verticalShift: 0,
  attributes: {},
  triggers: {},
  className: void 0,
  showDelay: void 0,
  hideDelay: void 0
}, au = rn`
  label: tooltip;
  display: inline-block;
  left: 0;
  bottom: 0;
  min-width: max-content;
  position: absolute;
  opacity: 0;
  transition: opacity;
  transition-duration: var(--vis-tooltip-transition-duration);
  z-index: 999999;
  padding: var(--vis-tooltip-padding);
  color: var(--vis-tooltip-text-color);
  border-radius: var(--vis-tooltip-border-radius);
  box-shadow: var(--vis-tooltip-box-shadow);
  border: solid 1px var(--vis-tooltip-border-color);
  background-color: var(--vis-tooltip-background-color);
  backdrop-filter: var(--vis-tooltip-backdrop-filter);
`, _L = au, wL = Pf`
  :root {
    --vis-tooltip-background-color: rgba(255, 255, 255, 0.95);
    --vis-tooltip-border-color: #e5e9f7;
    --vis-tooltip-text-color: #000;
    --vis-tooltip-shadow-color: rgba(172, 179, 184, 0.35);
    --vis-tooltip-backdrop-filter: none;
    --vis-tooltip-padding: 10px 15px;
    --vis-tooltip-border-radius: 5px;
    --vis-tooltip-transition-duration: 300ms;
    --vis-tooltip-box-shadow: none;

    --vis-dark-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-dark-tooltip-text-color: #e5e9f7;
    --vis-dark-tooltip-border-color: var(--vis-color-grey);
    --vis-dark-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }

  body.theme-dark ${`.${au}`} {
    --vis-tooltip-background-color: var(--vis-dark-tooltip-background-color);
    --vis-tooltip-text-color: var(--vis-dark-tooltip-text-color);
    --vis-tooltip-border-color: var(--vis-dark-tooltip-border-color);
    --vis-tooltip-shadow-color: var(--vis-dark-tooltip-shadow-color);
  }

  body.theme-dark {
    --vis-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-tooltip-text-color: #e5e9f7;
    --vis-tooltip-border-color: var(--vis-color-grey);
    --vis-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }
`, w_ = rn`
  bottom: unset;
  position: fixed;
`, vl = rn`
  opacity: 1;
`, ml = rn`
  display: none;
`, x_ = rn`
  label: non-interactive;
  pointer-events: none;
  user-select: none;
`, xL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hidden: ml,
  nonInteractive: x_,
  positionFixed: w_,
  root: au,
  show: vl,
  tooltip: _L,
  variables: wL
}, Symbol.toStringTag, { value: "Module" }));
class C_ {
  constructor(t = {}) {
    this._defaultConfig = bL, this.config = this._defaultConfig, this._setUpEventsThrottled = zl(this._setUpEvents, 500), this._setContainerPositionThrottled = zl(this._setContainerPosition, 500), this._isShown = !1, this.element = document.createElement("div"), this.div = Da(this.element).attr("class", au).classed(vl, !1).classed(ml, !0), this.setConfig(t), this.components = this.config.components, this._mutationObserver = new MutationObserver(() => {
      this._isShown && (!this.config.followCursor && this._hoveredElement ? this.placeByElement(this._hoveredElement) : this._position && this.place({ x: this._position[0], y: this._position[1] }));
    }), this._mutationObserver.observe(this.div.node(), { childList: !0, subtree: !0 });
  }
  setConfig(t) {
    var n;
    this.prevConfig = this.config, this.config = Gi(this._defaultConfig, t), this.prevConfig.horizontalPlacement !== this.config.horizontalPlacement && this.overrideHorizontalPlacement(void 0), this.config.container && this.config.container !== ((n = this.prevConfig) === null || n === void 0 ? void 0 : n.container) && this.setContainer(this.config.container), this._setUpAttributes();
  }
  setContainer(t) {
    var n;
    (n = this.element.parentNode) === null || n === void 0 || n.removeChild(this.element), this._container = t, this._container.appendChild(this.element), this._setContainerPositionThrottled();
  }
  getContainer() {
    return this._container;
  }
  hasContainer() {
    return !!this._container && this._container.isConnected;
  }
  setComponents(t) {
    this.components = t;
  }
  update() {
    this._container && this._setUpEventsThrottled();
  }
  /** Show the tooltip immediately by providing content and position */
  show(t, n) {
    this.render(t), this.place(n);
  }
  _hide() {
    this.div.classed(vl, !1).on("transitionend", () => {
      this.div.classed(ml, !this._isShown);
    }), this._isShown = !1;
  }
  /** Hides the tooltip after `hideDelay` */
  hide() {
    window.clearTimeout(this._showDelayTimeoutId), this.config.hideDelay ? (window.clearTimeout(this._hideDelayTimeoutId), this._hideDelayTimeoutId = setTimeout(() => this._hide(), this.config.hideDelay)) : this._hide();
  }
  _display() {
    window.clearTimeout(this._hideDelayTimeoutId), this.div.classed(ml, !1).classed(vl, !0), this._isShown = !0;
  }
  /** Simply display the tooltip with its previous content on position, taking into account `showDelay` */
  display() {
    this._isShown || (this.config.showDelay ? (window.clearTimeout(this._showDelayTimeoutId), this._showDelayTimeoutId = setTimeout(() => {
      this._display(), this.place({ x: this._position[0], y: this._position[1] });
    }, this.config.showDelay)) : this._display());
  }
  place(t) {
    if (this._position = [t.x, t.y], !this.hasContainer()) {
      console.warn("Unovis | Tooltip: Container was not set or is not initialized yet");
      return;
    }
    const { config: n } = this, a = this.element.offsetWidth, r = this.element.offsetHeight, o = this._overriddenHorizontalPlacement || (n.horizontalPlacement === et.Auto ? et.Center : n.horizontalPlacement), s = n.verticalPlacement === et.Auto ? t.y - r < 0 ? et.Bottom : et.Top : n.verticalPlacement, i = 5, u = o === et.Left ? -a - i - n.horizontalShift : o === et.Center ? -a / 2 : i + n.horizontalShift, d = s === et.Bottom ? i + n.verticalShift : s === et.Center ? -r / 2 : -i - n.verticalShift - r, [c, f] = this._constraintPosToContainer(t.x + u, t.y + d, a, r);
    this._applyPosition(c, f, r);
  }
  placeByElement(t) {
    const { config: n } = this;
    this._hoveredElement = t;
    const a = 5, r = this.element.offsetWidth, o = this.element.offsetHeight, s = this.isContainerBody(), i = s ? window.innerWidth : this._container.scrollWidth, u = t.getBoundingClientRect(), d = s ? [u.x, u.y] : Vl({
      clientX: u.x,
      clientY: u.y,
      pageX: u.x,
      pageY: u.y
    }, this._container), c = this._overriddenHorizontalPlacement || (n.horizontalPlacement === et.Auto ? d[0] - r < 0 ? et.Right : d[0] + r > i ? et.Left : et.Center : n.horizontalPlacement);
    let f = 0;
    switch (c) {
      case et.Left:
        f = -r - a - n.horizontalShift;
        break;
      case et.Right:
        f = u.width + a + n.horizontalShift;
        break;
      case et.Center:
      default:
        f = (-r + u.width) / 2;
        break;
    }
    const p = n.verticalPlacement === et.Auto ? c !== et.Center ? et.Center : d[1] - o < 0 ? et.Bottom : et.Top : n.verticalPlacement;
    let v = -o;
    switch (p) {
      case et.Center:
        v += (o + u.height) / 2;
        break;
      case et.Bottom:
        v += o + u.height + a + n.verticalShift;
        break;
      case et.Top:
      default:
        v += -a - n.verticalShift;
        break;
    }
    const [m, g] = this._constraintPosToContainer(d[0] + f, d[1] + v, r, o);
    this._applyPosition(m, g, o);
  }
  isContainerBody() {
    return this._container === document.body;
  }
  /** Allows to override the horizontal placement of the tooltip which is useful when you want to define custom positioning behavior.
   * This method has been added for Crosshair to allow it position tooltip left or right of the crosshair line
   * (see the `_showTooltip` method of the Crosshair component).
   */
  overrideHorizontalPlacement(t) {
    this._overriddenHorizontalPlacement = t;
  }
  render(t) {
    var n;
    const { config: a, prevConfig: r } = this;
    t instanceof HTMLElement ? this.div.select(":first-child").node() !== t && this.div.html("").append(() => t) : t !== null && this.div.html(t || ""), this.div.classed((n = a.className) !== null && n !== void 0 ? n : "", !!a.className).classed(x_, !a.allowHover), r?.className && r.className !== a.className && this.div.classed(r.className, !1), this.display();
  }
  _applyPosition(t, n, a) {
    const r = this.isContainerBody(), o = r ? window.innerHeight : this._container.scrollHeight;
    this.div.classed(w_, r).style("top", r ? `${n}px` : "unset").style("bottom", r ? "unset" : `${o - n - a}px`).style("left", `${t}px`);
  }
  _constraintPosToContainer(t, n, a, r) {
    const o = this.isContainerBody(), s = o ? window.innerHeight : this._container.scrollHeight, i = o ? window.innerWidth : this._container.scrollWidth, u = 10, d = t > i - a - u, c = t < u, f = d ? i - a - u : c ? u : t, p = 10, v = n > s - r - p, m = n < p, g = v ? s - r - p : m ? p : n;
    return [
      i < a ? 0 : f,
      s < r ? 0 : g
    ];
  }
  _setContainerPosition() {
    var t;
    this._container !== document.body && ((t = getComputedStyle(this._container)) === null || t === void 0 ? void 0 : t.position) === "static" && (this._container.style.position = "relative");
  }
  _setUpEvents() {
    const { config: t } = this;
    this.components.forEach((n) => {
      const a = Da(n.element);
      a.on("mousemove.tooltip", (r) => {
        const { config: o } = this, s = r.composedPath && r.composedPath() || r.path || [r.target];
        for (const i of Object.keys(o.triggers)) {
          const u = o.triggers[i];
          if (!u)
            continue;
          const d = a.selectAll(`.${i}`).nodes();
          for (const c of s) {
            if (c === a.node())
              break;
            if (c.classList.contains(i)) {
              const f = d.indexOf(c), p = Da(c).datum(), v = u(p, f, d), [m, g] = this.isContainerBody() ? [r.clientX, r.clientY] : Vl(r, this._container);
              v === null ? this.hide() : (this.render(v), o.followCursor ? this.place({ x: m, y: g }) : this.placeByElement(c)), r.stopPropagation();
              return;
            }
          }
        }
        this._isShown && this.hide();
      }).on("mouseleave.tooltip", (r) => {
        r.stopPropagation(), this.hide();
      });
    }), t.allowHover ? this.div.on("mouseenter.tooltip", this._display.bind(this)).on("mouseleave.tooltip", this.hide.bind(this)) : this.div.on("mouseenter.tooltip", null).on("mouseleave.tooltip", null);
  }
  _setUpAttributes() {
    const t = this.config.attributes;
    t && Object.keys(t).forEach((n) => {
      this.div.attr(n, t[n]);
    });
  }
  destroy() {
    var t;
    this._mutationObserver.disconnect(), window.clearTimeout(this._hideDelayTimeoutId), window.clearTimeout(this._showDelayTimeoutId), (t = this.div) === null || t === void 0 || t.remove();
  }
}
C_.selectors = xL;
function Ys(e) {
  return function() {
    return e;
  };
}
const S_ = Math.cos, ai = Math.sin, Fn = Math.sqrt, ri = Math.PI, ru = 2 * ri, Ud = Math.PI, jd = 2 * Ud, za = 1e-6, CL = jd - za;
function $_(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function SL(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return $_;
  const n = 10 ** t;
  return function(a) {
    this._ += a[0];
    for (let r = 1, o = a.length; r < o; ++r)
      this._ += Math.round(arguments[r] * n) / n + a[r];
  };
}
class $L {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? $_ : SL(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, a, r) {
    this._append`Q${+t},${+n},${this._x1 = +a},${this._y1 = +r}`;
  }
  bezierCurveTo(t, n, a, r, o, s) {
    this._append`C${+t},${+n},${+a},${+r},${this._x1 = +o},${this._y1 = +s}`;
  }
  arcTo(t, n, a, r, o) {
    if (t = +t, n = +n, a = +a, r = +r, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let s = this._x1, i = this._y1, u = a - t, d = r - n, c = s - t, f = i - n, p = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > za) if (!(Math.abs(f * u - d * c) > za) || !o)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let v = a - s, m = r - i, g = u * u + d * d, w = v * v + m * m, C = Math.sqrt(g), S = Math.sqrt(p), $ = o * Math.tan((Ud - Math.acos((g + p - w) / (2 * C * S))) / 2), k = $ / S, B = $ / C;
      Math.abs(k - 1) > za && this._append`L${t + k * c},${n + k * f}`, this._append`A${o},${o},0,0,${+(f * v > c * m)},${this._x1 = t + B * u},${this._y1 = n + B * d}`;
    }
  }
  arc(t, n, a, r, o, s) {
    if (t = +t, n = +n, a = +a, s = !!s, a < 0) throw new Error(`negative radius: ${a}`);
    let i = a * Math.cos(r), u = a * Math.sin(r), d = t + i, c = n + u, f = 1 ^ s, p = s ? r - o : o - r;
    this._x1 === null ? this._append`M${d},${c}` : (Math.abs(this._x1 - d) > za || Math.abs(this._y1 - c) > za) && this._append`L${d},${c}`, a && (p < 0 && (p = p % jd + jd), p > CL ? this._append`A${a},${a},0,1,${f},${t - i},${n - u}A${a},${a},0,1,${f},${this._x1 = d},${this._y1 = c}` : p > za && this._append`A${a},${a},0,${+(p >= Ud)},${f},${this._x1 = t + a * Math.cos(o)},${this._y1 = n + a * Math.sin(o)}`);
  }
  rect(t, n, a, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${a = +a}v${+r}h${-a}Z`;
  }
  toString() {
    return this._;
  }
}
function BL(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const a = Math.floor(n);
      if (!(a >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = a;
    }
    return e;
  }, () => new $L(t);
}
const B_ = {
  draw(e, t) {
    const n = Fn(t / ri);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, ru);
  }
}, kL = {
  draw(e, t) {
    const n = Fn(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, k_ = Fn(1 / 3), PL = k_ * 2, DL = {
  draw(e, t) {
    const n = Fn(t / PL), a = n * k_;
    e.moveTo(0, -n), e.lineTo(a, 0), e.lineTo(0, n), e.lineTo(-a, 0), e.closePath();
  }
}, ML = {
  draw(e, t) {
    const n = Fn(t), a = -n / 2;
    e.rect(a, a, n, n);
  }
}, qL = 0.8908130915292852, P_ = ai(ri / 10) / ai(7 * ri / 10), EL = ai(ru / 10) * P_, TL = -S_(ru / 10) * P_, AL = {
  draw(e, t) {
    const n = Fn(t * qL), a = EL * n, r = TL * n;
    e.moveTo(0, -n), e.lineTo(a, r);
    for (let o = 1; o < 5; ++o) {
      const s = ru * o / 5, i = S_(s), u = ai(s);
      e.lineTo(u * n, -i * n), e.lineTo(i * a - u * r, u * a + i * r);
    }
    e.closePath();
  }
}, Yu = Fn(3), OL = {
  draw(e, t) {
    const n = -Fn(t / (Yu * 3));
    e.moveTo(0, n * 2), e.lineTo(-Yu * n, -n), e.lineTo(Yu * n, -n), e.closePath();
  }
}, gn = -0.5, yn = Fn(3) / 2, Wd = 1 / Fn(12), IL = (Wd / 2 + 1) * 3, RL = {
  draw(e, t) {
    const n = Fn(t / IL), a = n / 2, r = n * Wd, o = a, s = n * Wd + n, i = -o, u = s;
    e.moveTo(a, r), e.lineTo(o, s), e.lineTo(i, u), e.lineTo(gn * a - yn * r, yn * a + gn * r), e.lineTo(gn * o - yn * s, yn * o + gn * s), e.lineTo(gn * i - yn * u, yn * i + gn * u), e.lineTo(gn * a + yn * r, gn * r - yn * a), e.lineTo(gn * o + yn * s, gn * s - yn * o), e.lineTo(gn * i + yn * u, gn * u - yn * i), e.closePath();
  }
};
function VL(e, t) {
  let n = null, a = BL(r);
  e = typeof e == "function" ? e : Ys(e || B_), t = typeof t == "function" ? t : Ys(t === void 0 ? 64 : +t);
  function r() {
    let o;
    if (n || (n = o = a()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null;
  }
  return r.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Ys(o), r) : e;
  }, r.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Ys(+o), r) : t;
  }, r.context = function(o) {
    return arguments.length ? (n = o ?? null, r) : n;
  }, r;
}
function $o(e, t, n, a) {
  return Array.isArray(t) && isFinite(n) ? t[n % t.length] : wb(e, t, n) || (Eo(n) ? `var(${Ab(n)})` : null);
}
var Ln;
(function(e) {
  e.Circle = "circle", e.Cross = "cross", e.Diamond = "diamond", e.Square = "square", e.Star = "star", e.Triangle = "triangle", e.Wye = "wye";
})(Ln || (Ln = {}));
const FL = {
  [Ln.Circle]: B_,
  [Ln.Cross]: kL,
  [Ln.Diamond]: DL,
  [Ln.Square]: ML,
  [Ln.Star]: AL,
  [Ln.Triangle]: OL,
  [Ln.Wye]: RL
}, un = Object.assign(Object.assign({}, Ln), { Line: "line" });
var oi;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(oi || (oi = {}));
const NL = {
  items: [],
  labelClassName: "",
  onLegendItemClick: void 0,
  labelFontSize: null,
  labelMaxWidth: null,
  bulletSize: null,
  bulletSpacing: 4,
  bulletShape: (e) => {
    var t;
    return (t = e.shape) !== null && t !== void 0 ? t : un.Circle;
  },
  orientation: oi.Horizontal,
  renderIntoProvidedDomNode: !1
}, Xs = Yo * 3, LL = {
  [un.Circle]: Math.PI / 4,
  [un.Cross]: 5 / 9,
  [un.Diamond]: Math.sqrt(3) / 6,
  [un.Square]: 1,
  [un.Star]: 0.3,
  [un.Triangle]: Math.sqrt(3) / 4,
  [un.Wye]: 5 / 11
};
function D_(e, t, n) {
  return t < 1 ? 0 : e * t + n * (t - 1);
}
function zL(e) {
  e.each((t, n, a) => {
    Da(a[n]).append("svg").attr("width", "100%").attr("height", "100%").append("path");
  });
}
function HL(e, t, n) {
  e.each((a, r, o) => {
    var s;
    const i = wb(a, t.bulletShape, r), u = NV((s = a.color) !== null && s !== void 0 ? s : $o(a, n, r)), d = u.length, c = Xs, f = Od(getComputedStyle(o[r]).getPropertyValue("--vis-legend-bullet-size")), p = t.bulletSpacing * (Xs / f), v = D_(c, d, p), m = i === un.Line ? Xs / 2.5 : Xs, g = Da(o[r]).select("svg").attr("viewBox", `0 0 ${v} ${m}`);
    g.selectAll("path").remove();
    const w = a.inactive ? "var(--vis-legend-bullet-inactive-opacity)" : 1;
    u.forEach((C, S) => {
      const $ = g.append("path");
      if (i === un.Line) {
        const k = S * (c + p), B = k + c;
        $.attr("d", `M${k},${m / 2} L${B},${m / 2}`).attr("transform", null).style("opacity", w).style("stroke", C).style("stroke-width", "3px").style("fill", null).style("fill-opacity", null).style("marker-start", "none").style("marker-end", "none");
      } else {
        const k = VL().type(FL[i]).size(c * m * LL[i]), B = (c - 2) / c;
        let D = m / 2;
        switch (i) {
          case un.Triangle:
            D += m / 8;
            break;
          case un.Star:
            D += m / 16;
            break;
          case un.Wye:
            D -= m / 16;
            break;
        }
        const P = S * (c + p) + c / 2;
        $.attr("d", k).attr("transform", `translate(${P}, ${Math.round(D)}) scale(${B})`).style("stroke", C).style("stroke-width", "1px").style("opacity", null).style("fill", C).style("fill-opacity", w);
      }
    });
  });
}
const Kf = rn`
  label: bullet-legend-component;
`, UL = Pf`
  :root {
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-legend-font-family: */

    --vis-legend-label-color: #6c778c;
    --vis-legend-label-max-width: 300px;
    --vis-legend-label-font-size: 12px;
    --vis-legend-bullet-size: 9px;
    --vis-legend-bullet-inactive-opacity: 0.15;
    --vis-legend-item-spacing: 20px;
    --vis-legend-vertical-item-spacing: 5px;
    --vis-legend-bullet-label-spacing: 8px;

    --vis-dark-legend-label-color: #eee;
  }

  body.theme-dark ${`.${Kf}`} {
    --vis-legend-label-color: var(--vis-dark-legend-label-color);
  }

  body.theme-patterns {
    --vis-legend-bullet-size: 14px;
  }
`, hl = rn`
  label: legendItem;
  display: inline-flex;
  align-items: center;
  font-family: var(--vis-legend-font-family, var(--vis-font-family));
  margin-right: var(--vis-legend-item-spacing);
  white-space: nowrap;
  cursor: default;
  user-select: none;
  max-width: min-content;
`, M_ = rn`
  label: legendItemVertical;
  display: flex;
  margin-top: var(--vis-legend-vertical-item-spacing);
`, q_ = rn`
  cursor: pointer;
`, Gd = rn`
  label: legendItemLabel;
  font-size: var(--vis-legend-label-font-size);
  display: inline-block;
  vertical-align: middle;
  color: var(--vis-legend-label-color);
  max-width: var(--vis-legend-label-max-width);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`, Kd = rn`
  flex: 0 0 auto;
  label: legendItemBullet;
  margin-right: var(--vis-legend-bullet-label-spacing);
  height: var(--vis-legend-bullet-size);
  width: var(--vis-legend-bullet-size);

  svg {
    display: block;
  }
`, jL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bullet: Kd,
  clickable: q_,
  item: hl,
  itemVertical: M_,
  label: Gd,
  root: Kf,
  variables: UL
}, Symbol.toStringTag, { value: "Module" }));
class Yf {
  constructor(t, n) {
    this._defaultConfig = NL, this.config = this._defaultConfig, this._colorAccessor = (a) => a.color, this._container = t, this.div = n?.renderIntoProvidedDomNode ? Da(this._container) : Da(this._container).append("div"), this.div.classed(Kf, !0), this.element = this.div.node(), n && this.update(n);
  }
  update(t) {
    this.prevConfig = this.config, this.config = Gi(this._defaultConfig, t), this.render();
  }
  render() {
    const { config: t } = this, n = this.div.selectAll(`.${hl}`).data(t.items), a = n.enter().append("div").on("click", this._onItemClick.bind(this)), r = a.merge(n);
    r.attr("class", (o) => {
      var s;
      return `${hl} ${(s = o.className) !== null && s !== void 0 ? s : ""}`;
    }).classed(M_, t.orientation === oi.Vertical).classed(q_, (o) => !!t.onLegendItemClick && this._isItemClickable(o)).attr("title", (o) => o.name).style("display", (o) => o.hidden ? "none" : null), a.append("span").attr("class", Kd).call(zL), r.select(`.${Kd}`).style("width", function(o) {
      const i = (Array.isArray(o.color) ? o.color : [o.color]).length, u = Od(getComputedStyle(this).getPropertyValue("--vis-legend-bullet-size")) || 9, d = t.bulletSize ? Od(t.bulletSize) : u, c = t.bulletSpacing;
      return `${D_(d, i, c)}px`;
    }).style("height", t.bulletSize).style("box-sizing", "content-box").call(HL, this.config, this._colorAccessor), a.append("span").attr("class", Gd).classed(t.labelClassName, !0).style("max-width", t.labelMaxWidth).style("font-size", t.labelFontSize), r.select(`.${Gd}`).text((o) => o.name), n.exit().remove();
  }
  _isItemClickable(t) {
    return t.pointer === void 0 ? !0 : t.pointer;
  }
  _onItemClick(t, n) {
    const { config: { onLegendItemClick: a } } = this, o = this.div.selectAll(`.${hl}`).nodes().indexOf(t.currentTarget);
    a && a(n, o);
  }
  destroy() {
    this.element !== this._container && this.div.remove();
  }
}
Yf.selectors = jL;
const WL = Object.assign(Object.assign({}, __), { yStacked: void 0, baseline: null, duration: 100, tooltip: void 0, template: (e, t, n, a) => "", hideWhenFarFromPointer: !0, hideWhenFarFromPointerDistance: 100, snapToData: !0, getCircles: void 0, color: void 0, strokeColor: void 0, strokeWidth: void 0, onCrosshairMove: void 0, forceShowAt: void 0, skipRangeCheck: !1 }), GL = Pf`
  :root {
    --vis-crosshair-line-stroke-color: #888;
    --vis-crosshair-line-stroke-width: 1px;
    --vis-crosshair-line-stroke-opacity: 1;
    --vis-crosshair-circle-stroke-color: #fff;
    --vis-crosshair-circle-stroke-width: 1px;
    --vis-crosshair-circle-stroke-opacity: 0.75;
  }
`, KL = rn`
  label: crosshair-component;
`, E_ = rn`
  stroke: var(--vis-crosshair-line-stroke-color);
  stroke-width: var(--vis-crosshair-line-stroke-width);
  stroke-opacity: var(--vis-crosshair-line-stroke-opacity);
  pointer-events: none;
`, T_ = rn`
  stroke: var(--vis-crosshair-circle-stroke-color);
  stroke-width: var(--vis-crosshair-circle-stroke-width);
  stroke-opacity: var(--vis-crosshair-circle-stroke-opacity);
  pointer-events: none;
`, YL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle: T_,
  globalStyles: GL,
  line: E_,
  root: KL
}, Symbol.toStringTag, { value: "Module" }));
class A_ extends yL {
  constructor(t) {
    super(), this.clippable = !0, this._defaultConfig = WL, this.config = this._defaultConfig, this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, this._animFrameId = null, this._accessors = {
      x: void 0,
      y: void 0,
      yStacked: void 0,
      baseline: void 0
    }, t && this.setConfig(t), this.g.style("opacity", 0), this.line = this.g.append("line").attr("class", E_);
  }
  set accessors(t) {
    this._accessors = t;
  }
  get accessors() {
    var t;
    const { config: n } = this, a = !!(n.x || n.y || n.yStacked), r = a ? n.x : this._accessors.x, o = a ? n.y : this._accessors.y, s = o ? Sf(o) ? o : [o] : void 0, i = a ? n.yStacked : this._accessors.yStacked, u = (t = n.baseline) !== null && t !== void 0 ? t : this._accessors.baseline;
    return { x: r, y: s, yStacked: i, baseline: u };
  }
  _isContainerInViewport() {
    var t;
    if (!(!((t = this.container) === null || t === void 0) && t.node()))
      return !1;
    const n = this.container.node().getBoundingClientRect(), a = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight, o = Math.max(0, Math.min(n.right, a) - Math.max(n.left, 0)), s = Math.max(0, Math.min(n.bottom, r) - Math.max(n.top, 0)), i = n.width * n.height, u = o * s;
    return i > 0 && u / i >= 0.35;
  }
  setContainer(t) {
    this.container !== t && (this.container = t, this.container.on("mousemove.crosshair", this._onMouseMove.bind(this)), this.container.on("mouseout.crosshair", this._onMouseOut.bind(this)), this.container.on("wheel.crosshair", this._onWheel.bind(this)));
  }
  _render(t) {
    var n, a, r, o, s;
    const { config: i, datamodel: u } = this, d = Eo(t) ? t : i.duration, c = i.forceShowAt !== void 0, f = c ? this.xScale(i.forceShowAt) : this._xPx, p = this.xScale.invert(f), v = !((n = u.data) === null || n === void 0) && n.length && this.accessors.x ? u.data.indexOf(Hl(u.data, p, this.accessors.x, oa.Left)) : void 0;
    let m, g;
    i.snapToData && (!this.accessors.y && !this.accessors.yStacked && (!((a = u.data) === null || a === void 0) && a.length) && console.warn("Unovis | Crosshair: Y accessors have not been configured. Please check if they're present in the configuration object"), !(!((r = u.data) === null || r === void 0) && r.length) && this._mouseEvent && console.warn("Unovis | Crosshair: No data to snap to. Make sure the data has been passed to the container or to the crosshair itself"), m = Hl(u.data, p, this.accessors.x), g = u.data.indexOf(m));
    const w = this.xScale.range(), C = this.yScale.range(), S = i.snapToData && m ? qv(Math.round(this.xScale(cn(m, this.accessors.x, g))), 0, this._width) : qv(f, w[0], w[1]), $ = f >= w[0] && f <= w[1], k = this._yPx >= Math.min(C[0], C[1]) && this._yPx <= Math.max(C[0], C[1]);
    let B = i.skipRangeCheck ? !!this._xPx : this._xPx ? $ && k : $;
    i.hideWhenFarFromPointer && Math.abs(S - +f) >= i.hideWhenFarFromPointerDistance && (B = !1);
    const D = (o = i.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (B && D && this._isContainerInViewport()) {
      const M = D.getContainer() || this.container.node(), I = D.isContainerBody();
      if (c) {
        const F = this.container.node().getBoundingClientRect(), J = (I ? f + F.left : f) + this._containerMargin.left, ne = this._height / 2 + (I ? F.top : 0), Q = [J, ne];
        this._showTooltip(m, p, Q, v);
      } else if (this._mouseEvent) {
        const F = I ? [this._mouseEvent.clientX, this._mouseEvent.clientY] : Vl(this._mouseEvent, M);
        this._showTooltip(m, p, F, v);
      }
    } else
      this._hideTooltip();
    if (this._mouseEvent && ((s = i.onCrosshairMove) === null || s === void 0 || s.call(i, B ? this.xScale.invert(this._xPx) : void 0, m, g, this._mouseEvent), this._mouseEvent = void 0), Hu(this.g, d).style("opacity", B ? 1 : 0), !isFinite(f))
      return;
    this.line.attr("y1", 0).attr("y2", this._height), Hu(this.line, d, nm).attr("x1", S).attr("x2", S);
    const P = Cf(i.getCircles) ? i.getCircles(p, u.data, this.yScale, v) : this.getCircleData(m, g), E = this.g.selectAll("circle").data(P, (M, I) => {
      var F;
      return (F = M.id) !== null && F !== void 0 ? F : I;
    }), T = E.enter().append("circle").attr("class", T_).attr("r", 0).attr("cx", S).attr("cy", (M) => M.y).style("fill", (M) => M.color).style("stroke", (M) => M.strokeColor).style("stroke-width", (M) => M.strokeWidth);
    Hu(T.merge(E), d, nm).attr("cx", S).attr("cy", (M) => M.y).attr("r", 4).style("opacity", (M) => M.opacity).style("fill", (M) => M.color).style("stroke", (M) => M.strokeColor).style("stroke-width", (M) => M.strokeWidth), E.exit().remove();
  }
  hide(t) {
    window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      var n, a;
      this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, (a = (n = this.config).onCrosshairMove) === null || a === void 0 || a.call(n, void 0, void 0, void 0, t), this._render();
    });
  }
  _onMouseMove(t) {
    var n;
    const { datamodel: a, element: r } = this;
    !this.accessors.x && (!((n = a.data) === null || n === void 0) && n.length) && console.warn("Unovis | Crosshair: X accessor function has not been configured. Please check if it's present in the configuration object");
    const [o, s] = Vl(t, r);
    this._xPx = o, this._yPx = s, this._mouseEvent = t, window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      this._render();
    });
  }
  _onMouseOut(t) {
    var n;
    (!t || !(!((n = this.container) === null || n === void 0) && n.node().contains(t.relatedTarget))) && this.hide(t);
  }
  _onWheel(t) {
    this.hide(t);
  }
  _showTooltip(t, n, a, r) {
    var o;
    const { config: s, datamodel: i } = this, u = (o = s.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (!u || !a)
      return;
    const [d, c] = a, f = s.template(t, n, i.data, r);
    if (u.config.followCursor = !0, !u.config.horizontalPlacement || u.config.horizontalPlacement === et.Auto) {
      const p = u.isContainerBody() ? d - this.container.node().getBoundingClientRect().left : d;
      u.overrideHorizontalPlacement(p > this._containerWidth / 2 ? et.Left : et.Right);
    }
    f && u.show(f, { x: d, y: c });
  }
  _hideTooltip() {
    var t;
    const { config: n } = this, a = (t = n.tooltip) !== null && t !== void 0 ? t : this.tooltip;
    a?.hide();
  }
  // We don't want Crosshair to be be taken in to account in domain calculations
  getYDataExtent() {
    return [void 0, void 0];
  }
  getCircleData(t, n) {
    var a, r;
    const { config: o } = this;
    if (o.snapToData && t) {
      const s = (a = this.accessors.y) !== null && a !== void 0 ? a : [], i = (r = this.accessors.yStacked) !== null && r !== void 0 ? r : [], u = cn(t, this.accessors.baseline, n) || 0, d = IV(t, n, ...i).map((f, p) => ({
        y: this.yScale(f + u),
        opacity: Eo(cn(t, i[p], p)) ? 1 : 0,
        color: $o(t, o.color, p),
        strokeColor: o.strokeColor ? $o(t, o.strokeColor, p) : void 0,
        strokeWidth: o.strokeWidth ? cn(t, o.strokeWidth, p) : void 0
      })), c = s.map((f, p) => {
        const v = cn(t, f, n);
        return {
          y: this.yScale(v),
          opacity: Eo(v) ? 1 : 0,
          color: $o(t, o.color, d.length + p),
          strokeColor: o.strokeColor ? $o(t, o.strokeColor, p) : void 0,
          strokeWidth: o.strokeWidth ? cn(t, o.strokeWidth, p) : void 0
        };
      });
      return d.concat(c);
    }
    return [];
  }
}
A_.selectors = YL;
const XL = /* @__PURE__ */ Symbol("tooltipAccessorKey"), JL = /* @__PURE__ */ Symbol("crosshairAccessorKey");
function Xf(e, t) {
  return Ed(e, t);
}
function Jf(e) {
  const t = Pt(), n = t.attrs;
  return q(() => {
    const a = {}, r = t?.vnode.props ?? {};
    return Object.keys(r).forEach((o) => {
      a[gl(o)] = e[gl(o)];
    }), { ...a, ...n };
  });
}
const ZL = { "data-vis-crosshair": "" }, QL = /* @__PURE__ */ b({
  __name: "index",
  props: {
    data: {}
  },
  setup(e, { expose: t }) {
    const n = wn(JL), a = e, r = q(() => n.data.value ?? a.data), o = Jf(a), s = O();
    return Ce(() => {
      Pe(() => {
        var i;
        s.value = new A_(o.value), (i = s.value) == null || i.setData(r.value), n.update(s.value);
      });
    }), nt(() => {
      var i;
      (i = s.value) == null || i.destroy(), n.destroy();
    }), me(o, (i, u) => {
      var d;
      Xf(i, u) || (d = s.value) == null || d.setConfig(o.value);
    }), me(r, () => {
      var i;
      (i = s.value) == null || i.setData(r.value);
    }), t({
      component: s
    }), (i, u) => (h(), W("div", ZL));
  }
}), e4 = { "data-vis-tooltip": "" }, O_ = /* @__PURE__ */ b({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    hideDelay: {},
    showDelay: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = wn(XL), a = Jf(e), r = O();
    return Ce(() => {
      Pe(() => {
        r.value = new C_(a.value), n.update(r.value);
      });
    }), nt(() => {
      var o;
      (o = r.value) == null || o.destroy(), n.destroy();
    }), me(a, (o, s) => {
      var i;
      Xf(o, s) || (i = r.value) == null || i.setConfig(a.value);
    }), t({
      component: r
    }), (o, s) => (h(), W("div", e4));
  }
}), t4 = /* @__PURE__ */ b({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletSpacing: {},
    bulletShape: {},
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e;
    q(() => n.data);
    const a = Jf(n), r = O(), o = O();
    return Ce(() => {
      Pe(() => {
        o.value && (r.value = new Yf(o.value, { ...a.value, renderIntoProvidedDomNode: !0 }));
      });
    }), nt(() => {
      var s;
      (s = r.value) == null || s.destroy();
    }), me(a, (s, i) => {
      var u;
      Xf(s, i) || (u = r.value) == null || u.update(a.value);
    }), t({
      component: r
    }), (s, i) => (h(), W("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: o
    }, null, 512));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-map],[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend],[data-vis-rolling-pin-legend]{display:block}")), document.head.appendChild(e);
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t);
  }
})();
const m7 = /* @__PURE__ */ b({
  __name: "ChartCrosshair",
  props: {
    colors: { default: () => [] },
    index: {},
    items: {},
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(o) {
      if (n.has(o))
        return n.get(o);
      {
        const s = document.createElement("div"), i = Object.entries(bb(o, [t.index])).map(([d, c]) => ({ ...t.items.find((p) => p.name === d), value: c })), u = t.customTooltip ?? Yd;
        return ed(u, { title: o[t.index].toString(), data: i }).mount(
          s
        ), n.set(o, s.innerHTML), s.innerHTML;
      }
    }
    function r(o, s) {
      return t.colors[s] ?? "transparent";
    }
    return (o, s) => (h(), W(Ke, null, [
      N(l(O_), {
        "horizontal-shift": 20,
        "vertical-shift": 20
      }),
      N(l(QL), {
        template: a,
        color: r
      })
    ], 64));
  }
}), h7 = /* @__PURE__ */ b({
  __name: "ChartLegend",
  props: {
    items: { default: () => [] }
  },
  emits: ["legendItemClick", "update:items"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = O();
    function o() {
      const i = `.${Yf.selectors.item}`;
      Pe(() => {
        const u = r.value?.querySelectorAll(i), d = Kt({ variant: "ghost", size: "xs" }).split(" ");
        u?.forEach((c) => c.classList.add(...d, "!inline-flex", "!mr-2"));
      });
    }
    Ce(() => {
      o();
    });
    function s(i, u) {
      a("legendItemClick", i, u);
      const d = n.items[u], c = d ? !d.inactive : !0;
      n.items.some((p) => p.inactive) && c ? a(
        "update:items",
        n.items.map((p) => ({ ...p, inactive: !1 }))
      ) : a(
        "update:items",
        n.items.map(
          (p) => p.name === i.name ? { ...i, inactive: !1 } : { ...p, inactive: !0 }
        )
      ), o();
    }
    return (i, u) => (h(), W("div", {
      ref_key: "elRef",
      ref: r,
      class: "w-max",
      style: {
        "--vis-legend-bullet-size": "16px"
      }
    }, [
      N(l(t4), {
        items: e.items,
        "on-legend-item-click": s
      }, null, 8, ["items"])
    ], 512));
  }
}), g7 = /* @__PURE__ */ b({
  __name: "ChartSingleTooltip",
  props: {
    selector: {},
    index: {},
    items: {},
    valueFormatter: { type: Function },
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(r, o, s) {
      const i = t.valueFormatter ?? ((u) => `${u}`);
      if (t.index in r) {
        if (n.has(r))
          return n.get(r);
        {
          const u = document.createElement("div"), d = Object.entries(bb(r, [t.index])).map(([f, p]) => ({ ...t.items?.find((m) => m.name === f), value: i(p) })), c = t.customTooltip ?? Yd;
          return ed(c, { title: r[t.index], data: d }).mount(u), n.set(r, u.innerHTML), u.innerHTML;
        }
      } else {
        const u = r.data;
        if (n.has(u))
          return n.get(u);
        {
          const d = s[o];
          if (!d) return "";
          const c = getComputedStyle(d), f = [
            { name: u.name, value: i(u[t.index]), color: c.fill }
          ], p = document.createElement("div"), v = t.customTooltip ?? Yd;
          return ed(v, { title: r[t.index], data: f }).mount(p), n.set(r, p.innerHTML), p.innerHTML;
        }
      }
    }
    return (r, o) => (h(), x(l(O_), {
      "horizontal-shift": 20,
      "vertical-shift": 20,
      triggers: {
        [e.selector]: a
      }
    }, null, 8, ["triggers"]));
  }
}), n4 = { class: "flex items-center" }, a4 = { class: "mr-2 h-2.5 w-2.5" }, r4 = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 30 30"
}, o4 = ["stroke", "fill"], s4 = { class: "ml-4 font-semibold" }, Yd = /* @__PURE__ */ b({
  __name: "ChartTooltip",
  props: {
    title: {},
    data: {}
  },
  setup(e) {
    return (t, n) => (h(), x(l(r3), { class: "text-sm" }, {
      default: y(() => [
        e.title ? (h(), x(l(s3), {
          key: 0,
          class: "border-b p-3"
        }, {
          default: y(() => [
            N(l(l3), null, {
              default: y(() => [
                Re(Ne(e.title), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : qe("", !0),
        N(l(o3), { class: "flex min-w-[180px] flex-col gap-1 p-3" }, {
          default: y(() => [
            (h(!0), W(Ke, null, Nt(e.data, (a, r) => (h(), W("div", {
              key: r,
              class: "flex justify-between"
            }, [
              we("div", n4, [
                we("span", a4, [
                  (h(), W("svg", r4, [
                    we("path", {
                      d: " M 15 15 m -14, 0 a 14,14 0 1,1 28,0 a 14,14 0 1,1 -28,0",
                      stroke: a.color,
                      fill: a.color,
                      "stroke-width": "1"
                    }, null, 8, o4)
                  ]))
                ]),
                we("span", null, Ne(a.name), 1)
              ]),
              we("span", s4, Ne(a.value), 1)
            ]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
function y7(e = 3) {
  const t = Math.floor(e / 2), n = e % 2, a = t + n, r = t;
  return [
    ...Array.from(new Array(a).keys()).map(
      (o) => `hsl(var(--vis-primary-color) / ${1 - 1 / a * o})`
    ),
    ...Array.from(new Array(r).keys()).map(
      (o) => `hsl(var(--vis-secondary-color) / ${1 - 1 / r * o})`
    )
  ];
}
const b7 = /* @__PURE__ */ b({
  __name: "Checkbox",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null] },
    disabled: { type: Boolean },
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = q(() => {
      const { class: s, ...i } = n;
      return i;
    }), o = ve(r, a);
    return (s, i) => (h(), x(l(YC), A(l(o), {
      class: l(R)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: y(() => [
        N(l(JC), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: y(() => [
            _(s.$slots, "default", {}, () => [
              N(l(no), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _7 = /* @__PURE__ */ b({
  __name: "Collapsible",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(Nh), oe(le(l(r))), {
      default: y(({ open: i }) => [
        _(o.$slots, "default", { open: i })
      ]),
      _: 3
    }, 16));
  }
}), w7 = /* @__PURE__ */ b({
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Lh), A(t, { class: "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down" }), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), x7 = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(zh), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), C7 = /* @__PURE__ */ b({
  __name: "Combobox",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    resetSearchTermOnBlur: { type: Boolean },
    resetSearchTermOnSelect: { type: Boolean },
    openOnFocus: { type: Boolean },
    openOnClick: { type: Boolean },
    ignoreFilter: { type: Boolean },
    resetModelValueOnClear: { type: Boolean },
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    highlightOnHover: { type: Boolean },
    by: { type: [String, Function] },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(O$), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), S7 = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(h$), A(l(a), {
      class: l(R)("w-[200px]", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $7 = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(H$), A(l(n), {
      class: l(R)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), B7 = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(W$), A(l(n), {
      class: l(R)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        e.heading ? (h(), x(l(Q$), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(Ne(e.heading), 1)
          ]),
          _: 1
        })) : qe("", !0),
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), k7 = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: { type: Function },
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(K$), A(l(o), {
      class: l(R)(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), P7 = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(X$), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center justify-between gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), D7 = /* @__PURE__ */ b({
  __name: "ComboboxList",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(tB), null, {
      default: y(() => [
        N(l(L$), A(l(o), {
          class: l(R)(
            "z-50 w-[200px] rounded-md border bg-popover text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            N(l(sB), null, {
              default: y(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), M7 = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(aB), A(l(n), {
      class: l(R)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), l4 = /* @__PURE__ */ b({
  __name: "Command",
  props: {
    modelValue: { default: "" },
    defaultValue: {},
    multiple: { type: Boolean },
    orientation: {},
    dir: {},
    disabled: { type: Boolean },
    selectionBehavior: {},
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "highlight", "entryFocus", "leave"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a), s = O(/* @__PURE__ */ new Map()), i = O(/* @__PURE__ */ new Map()), { contains: u } = Ah({ sensitivity: "base" }), d = jt({
      search: "",
      filtered: {
        /** The count of all visible items. */
        count: 0,
        /** Map from visible item id to its search score. */
        items: /* @__PURE__ */ new Map(),
        /** Set of groups with at least one visible item. */
        groups: /* @__PURE__ */ new Set()
      }
    });
    function c() {
      if (!d.search) {
        d.filtered.count = s.value.size;
        return;
      }
      d.filtered.groups = /* @__PURE__ */ new Set();
      let f = 0;
      for (const [p, v] of s.value) {
        const m = u(v, d.search);
        d.filtered.items.set(p, m ? 1 : 0), m && f++;
      }
      for (const [p, v] of i.value)
        for (const m of v)
          if (d.filtered.items.get(m) > 0) {
            d.filtered.groups.add(p);
            break;
          }
      d.filtered.count = f;
    }
    return me(
      () => d.search,
      () => {
        c();
      }
    ), f4({
      allItems: s,
      allGroups: i,
      filterState: d
    }), (f, p) => (h(), x(l(cg), A(l(o), {
      class: l(R)(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        n.class
      )
    }), {
      default: y(() => [
        _(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), i4 = /* @__PURE__ */ b({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(mi), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), q7 = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Aa), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), u4 = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(yi), null, {
      default: y(() => [
        N(l(ds), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(us), A(l(o), {
          class: l(R)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(Aa), { class: "absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-none disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground" }, {
              default: y(() => [
                N(l(ao), { class: "h-4 w-4" }),
                i[0] || (i[0] = we("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), E7 = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(gi), A(l(a), {
      class: l(R)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), T7 = /* @__PURE__ */ b({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), A7 = /* @__PURE__ */ b({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(R)("flex flex-col gap-y-1.5 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), O7 = /* @__PURE__ */ b({
  __name: "DialogScrollContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(yi), null, {
      default: y(() => [
        N(l(ds), { class: "fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }, {
          default: y(() => [
            N(l(us), A({
              class: l(R)(
                "relative z-50 my-8 grid w-full max-w-lg gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full",
                n.class
              )
            }, l(o), {
              onPointerDownOutside: i[0] || (i[0] = (u) => {
                const d = u.detail.originalEvent, c = d.target;
                (d.offsetX > c.clientWidth || d.offsetY > c.clientHeight) && u.preventDefault();
              })
            }), {
              default: y(() => [
                _(s.$slots, "default"),
                N(l(Aa), { class: "absolute top-4 right-4 rounded-md p-0.5 transition-colors hover:bg-secondary" }, {
                  default: y(() => [
                    N(l(ao), { class: "h-4 w-4" }),
                    i[1] || (i[1] = we("span", { class: "sr-only" }, "Close", -1))
                  ]),
                  _: 1
                })
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), I7 = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(bi), A(l(a), {
      class: l(R)("text-lg leading-none font-semibold tracking-tight", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), R7 = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(_i), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), V7 = /* @__PURE__ */ b({
  __name: "CommandDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(i4), oe(le(l(r))), {
      default: y(() => [
        N(l(u4), { class: "overflow-hidden p-0 shadow-lg" }, {
          default: y(() => [
            N(l4, { class: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5" }, {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16));
  }
}), F7 = /* @__PURE__ */ b({
  __name: "CommandEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { filterState: a } = ou(), r = q(() => !!a.search && a.filtered.count === 0);
    return (o, s) => r.value ? (h(), x(l(X), A({ key: 0 }, l(n), {
      class: l(R)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"])) : qe("", !0);
  }
}), N7 = /* @__PURE__ */ b({
  __name: "CommandGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { allGroups: a, filterState: r } = ou(), o = Ge(), s = q(() => r.search ? r.filtered.groups.has(o) : !0);
    return v4({ id: o }), Ce(() => {
      a.value.has(o) || a.value.set(o, /* @__PURE__ */ new Set());
    }), nt(() => {
      a.value.delete(o);
    }), (i, u) => (h(), x(l(vg), A(l(n), {
      id: l(o),
      class: l(R)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      ),
      hidden: s.value ? void 0 : !0
    }), {
      default: y(() => [
        e.heading ? (h(), x(l(B$), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(Ne(e.heading), 1)
          ]),
          _: 1
        })) : qe("", !0),
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class", "hidden"]));
  }
}), d4 = {
  class: "flex items-center border-b px-3",
  "cmdk-input-wrapper": ""
}, L7 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CommandInput",
  props: {
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), { filterState: r } = ou();
    return (o, s) => (h(), W("div", d4, [
      N(l(kO), { class: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
      N(l(pg), A({ ...l(a), ...o.$attrs }, {
        modelValue: l(r).search,
        "onUpdate:modelValue": s[0] || (s[0] = (i) => l(r).search = i),
        "auto-focus": "",
        class: l(R)(
          "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      }), null, 16, ["modelValue", "class"])
    ]));
  }
}), z7 = /* @__PURE__ */ b({
  __name: "CommandItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a), s = Ge(), { filterState: i, allItems: u, allGroups: d } = ou(), c = p4(), f = q(() => {
      if (i.search) {
        const m = i.filtered.items.get(s);
        return m === void 0 ? !0 : m > 0;
      } else
        return !0;
    }), p = O(), v = L2(p);
    return Ce(() => {
      if (!(v.value instanceof HTMLElement)) return;
      u.value.set(s, v.value.textContent ?? n?.value.toString());
      const m = c?.id;
      m && (d.value.has(m) ? d.value.get(m)?.add(s) : d.value.set(m, /* @__PURE__ */ new Set([s])));
    }), nt(() => {
      u.value.delete(s);
    }), (m, g) => f.value ? (h(), x(l(mg), A({ key: 0 }, l(o), {
      id: l(s),
      ref_key: "itemRef",
      ref: p,
      class: l(R)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      ),
      onSelect: g[0] || (g[0] = () => {
        l(i).search = "";
      })
    }), {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class"])) : qe("", !0);
  }
}), c4 = { role: "presentation" }, H7 = /* @__PURE__ */ b({
  __name: "CommandList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(fg), A(l(a), {
      class: l(R)("max-h-[300px] overflow-x-hidden overflow-y-auto", t.class)
    }), {
      default: y(() => [
        we("div", c4, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), U7 = /* @__PURE__ */ b({
  __name: "CommandSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Xc), A(l(n), {
      class: l(R)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), j7 = /* @__PURE__ */ b({
  __name: "CommandShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), [ou, f4] = Se("Command"), [p4, v4] = Se("CommandGroup"), W7 = /* @__PURE__ */ b({
  __name: "ContextMenu",
  props: {
    pressOpenDelay: {},
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(NB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), m4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, G7 = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(RB), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", m4, [
          N(l(xg), null, {
            default: y(() => [
              N(l(no), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), K7 = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(JB), null, {
      default: y(() => [
        N(l(zB), A(l(o), {
          class: l(R)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Y7 = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(UB), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), X7 = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(WB), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), J7 = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(YB), A(l(n), {
      class: l(R)("px-2 py-1.5 text-sm font-semibold text-foreground", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Z7 = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(QB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), h4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, Q7 = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(tk), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", h4, [
          N(l(xg), null, {
            default: y(() => [
              N(l(uf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), eU = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(ak), A(l(n), {
      class: l(R)("-mx-1 my-1 h-px bg-border", t.class)
    }), null, 16, ["class"]));
  }
}), tU = /* @__PURE__ */ b({
  __name: "ContextMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), nU = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(ok), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), aU = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(lk), A(l(o), {
      class: l(R)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rU = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(uk), A(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(Va), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), oU = /* @__PURE__ */ b({
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(ck), oe(le(l(n))), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
(function() {
  var e;
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.nonce = (e = document.head.querySelector("meta[property=csp-nonce]")) == null ? void 0 : e.content, t.appendChild(document.createTextNode('[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32,.72,0,1);animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform, 100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform, 100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height, 0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height, 0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true]):after{content:"";position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]:after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]:after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]:after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]:after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:hover,[data-vaul-handle]:active{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover: hover) and (pointer: fine){[data-vaul-drawer]{-webkit-user-select:none;user-select:none}}@media (pointer: fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{0%{transform:translate3d(0,var(--initial-transform, 100%),0)}to{transform:translateZ(0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform, 100%),0)}}@keyframes slideFromTop{0%{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}to{transform:translateZ(0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}}@keyframes slideFromLeft{0%{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}to{transform:translateZ(0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}}@keyframes slideFromRight{0%{transform:translate3d(var(--initial-transform, 100%),0,0)}to{transform:translateZ(0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform, 100%),0,0)}}')), document.head.appendChild(t);
    }
  } catch (n) {
    console.error("vite-plugin-css-injected-by-js", n);
  }
})();
const g4 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const y4 = (e) => typeof e < "u";
function b4(e) {
  return JSON.parse(JSON.stringify(e));
}
function qm(e, t, n, a = {}) {
  var r, o, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = Pt(), m = n || v?.emit || ((r = v?.$emit) == null ? void 0 : r.bind(v)) || ((s = (o = v?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(v?.proxy));
  let g = d;
  t || (t = "modelValue"), g = g || `update:${t.toString()}`;
  const w = ($) => i ? typeof i == "function" ? i($) : b4($) : $, C = () => y4(e[t]) ? w(e[t]) : f, S = ($) => {
    p ? p($) && m(g, $) : m(g, $);
  };
  if (u) {
    const $ = C(), k = O($);
    let B = !1;
    return me(
      () => e[t],
      (D) => {
        B || (B = !0, k.value = w(D), Pe(() => B = !1));
      }
    ), me(
      k,
      (D) => {
        !B && (D !== e[t] || c) && S(D);
      },
      { deep: c }
    ), k;
  } else
    return q({
      get() {
        return C();
      },
      set($) {
        S($);
      }
    });
}
const [Zf, _4] = Se("DrawerRoot"), I_ = /* @__PURE__ */ new WeakMap();
function Et(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement) || !t)
    return;
  const a = {};
  Object.entries(t).forEach(([r, o]) => {
    if (r.startsWith("--")) {
      e.style.setProperty(r, o);
      return;
    }
    a[r] = e.style[r], e.style[r] = o;
  }), !n && I_.set(e, a);
}
function w4(e, t) {
  if (!e || !(e instanceof HTMLElement))
    return;
  const n = I_.get(e);
  n && Object.entries(n).forEach(([a, r]) => {
    e.style[a] = r;
  });
}
function Js(e, t) {
  const n = window.getComputedStyle(e), a = n.transform || n.webkitTransform || n.mozTransform;
  let r = a.match(/^matrix3d\((.+)\)$/);
  return r ? Number.parseFloat(r[1].split(", ")[bt(t) ? 13 : 12]) : (r = a.match(/^matrix\((.+)\)$/), r ? Number.parseFloat(r[1].split(", ")[bt(t) ? 5 : 4]) : null);
}
function x4(e) {
  return 8 * (Math.log(e + 1) - 2);
}
function bt(e) {
  switch (e) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return e;
  }
}
function Xu(e, t) {
  if (!e)
    return () => {
    };
  const n = e.style.cssText;
  return Object.assign(e.style, t), () => {
    e.style.cssText = n;
  };
}
function C4(...e) {
  return (...t) => {
    for (const n of e)
      typeof n == "function" && n(...t);
  };
}
const ft = {
  DURATION: 0.5,
  EASE: [0.32, 0.72, 0, 1]
}, R_ = 0.4, S4 = 0.25, $4 = 100, V_ = 8, Zs = 16, F_ = 26, Em = "vaul-dragging";
function B4({
  activeSnapPoint: e,
  snapPoints: t,
  drawerRef: n,
  overlayRef: a,
  fadeFromIndex: r,
  onSnapPointChange: o,
  direction: s
}) {
  const i = O(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  function u() {
    i.value = {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    };
  }
  Ce(() => {
    typeof window < "u" && window.addEventListener("resize", u);
  }), ar(() => {
    typeof window < "u" && window.removeEventListener("resize", u);
  });
  const d = q(
    () => (t.value && e.value === t.value[t.value.length - 1]) ?? null
  ), c = q(
    () => t.value && t.value.length > 0 && (r?.value || r?.value === 0) && !Number.isNaN(r?.value) && t.value[r?.value ?? -1] === e.value || !t.value
  ), f = q(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.findIndex(($) => $ === e.value)) ?? null;
    }
  ), p = q(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.map(($) => {
        const k = typeof $ == "string";
        let B = 0;
        if (k && (B = Number.parseInt($, 10)), bt(s.value)) {
          const P = k ? B : i.value ? $ * i.value.innerHeight : 0;
          return i.value ? s.value === "bottom" ? i.value.innerHeight - P : -i.value.innerHeight + P : P;
        }
        const D = k ? B : i.value ? $ * i.value.innerWidth : 0;
        return i.value ? s.value === "right" ? i.value.innerWidth - D : -i.value.innerWidth + D : D;
      })) ?? [];
    }
  ), v = q(
    () => {
      var S;
      return f.value !== null ? (S = p.value) == null ? void 0 : S[f.value] : null;
    }
  ), m = (S) => {
    var $, k, B, D;
    const P = (($ = p.value) == null ? void 0 : $.findIndex((E) => E === S)) ?? null;
    Pe(() => {
      var E;
      o(P, p.value), Et((E = n.value) == null ? void 0 : E.$el, {
        transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
        transform: bt(s.value) ? `translate3d(0, ${S}px, 0)` : `translate3d(${S}px, 0, 0)`
      });
    }), p.value && P !== p.value.length - 1 && P !== r?.value ? Et((k = a.value) == null ? void 0 : k.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "0"
    }) : Et((B = a.value) == null ? void 0 : B.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "1"
    }), e.value = P !== null ? ((D = t.value) == null ? void 0 : D[P]) ?? null : null;
  };
  me(
    [e, p, t],
    () => {
      var S;
      if (e.value) {
        const $ = ((S = t.value) == null ? void 0 : S.findIndex((k) => k === e.value)) ?? -1;
        p.value && $ !== -1 && typeof p.value[$] == "number" && m(p.value[$]);
      }
    },
    {
      immediate: !0
      // if you want to run the effect immediately as well
    }
  );
  function g({
    draggedDistance: S,
    closeDrawer: $,
    velocity: k,
    dismissible: B
  }) {
    var D, P, E;
    if (r.value === void 0)
      return;
    const T = s.value === "bottom" || s.value === "right" ? (v.value ?? 0) - S : (v.value ?? 0) + S, M = f.value === r.value - 1, I = f.value === 0, F = S > 0;
    if (M && Et((D = a.value) == null ? void 0 : D.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`
    }), k > 2 && !F) {
      B ? $() : m(p.value[0]);
      return;
    }
    if (k > 2 && F && p && t.value) {
      m(p.value[t.value.length - 1]);
      return;
    }
    const J = (P = p.value) == null ? void 0 : P.reduce((Q, G) => typeof Q != "number" || typeof G != "number" ? Q : Math.abs(G - T) < Math.abs(Q - T) ? G : Q), ne = bt(s.value) ? window.innerHeight : window.innerWidth;
    if (k > R_ && Math.abs(S) < ne * 0.4) {
      const Q = F ? 1 : -1;
      if (Q > 0 && d) {
        m(p.value[(((E = t.value) == null ? void 0 : E.length) ?? 0) - 1]);
        return;
      }
      if (I && Q < 0 && B && $(), f.value === null)
        return;
      m(p.value[f.value + Q]);
      return;
    }
    m(J);
  }
  function w({ draggedDistance: S }) {
    var $;
    if (v.value === null)
      return;
    const k = s.value === "bottom" || s.value === "right" ? v.value - S : v.value + S;
    (s.value === "bottom" || s.value === "right") && k < p.value[p.value.length - 1] || (s.value === "top" || s.value === "left") && k > p.value[p.value.length - 1] || Et(($ = n.value) == null ? void 0 : $.$el, {
      transform: bt(s.value) ? `translate3d(0, ${k}px, 0)` : `translate3d(${k}px, 0, 0)`
    });
  }
  function C(S, $) {
    if (!t.value || typeof f.value != "number" || !p.value || r.value === void 0)
      return null;
    const k = f.value === r.value - 1;
    if (f.value >= r.value && $)
      return 0;
    if (k && !$)
      return 1;
    if (!c.value && !k)
      return null;
    const B = k ? f.value + 1 : f.value - 1, D = k ? p.value[B] - p.value[B - 1] : p.value[B + 1] - p.value[B], P = S / Math.abs(D);
    return k ? 1 - P : P;
  }
  return {
    isLastSnapPoint: d,
    shouldFade: c,
    getPercentageDragged: C,
    activeSnapPointIndex: f,
    onRelease: g,
    onDrag: w,
    snapPointsOffset: p
  };
}
function Tm() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
let yo = null;
function k4(e) {
  const { isOpen: t, modal: n, nested: a, hasBeenOpened: r, preventScrollRestoration: o, noBodyStyles: s } = e, i = O(typeof window < "u" ? window.location.href : ""), u = O(0);
  function d() {
    if (Tm() && yo === null && t.value && !s.value) {
      yo = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      };
      const { scrollX: f, innerHeight: p } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-u.value}px`,
        left: `${-f}px`,
        right: "0px",
        height: "auto"
      }), setTimeout(() => {
        requestAnimationFrame(() => {
          const v = p - window.innerHeight;
          v && u.value >= p && (document.body.style.top = `-${u.value + v}px`);
        });
      }, 300);
    }
  }
  function c() {
    if (Tm() && yo !== null && !s.value) {
      const f = -Number.parseInt(document.body.style.top, 10), p = -Number.parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, yo), window.requestAnimationFrame(() => {
        if (o.value && i.value !== window.location.href) {
          i.value = window.location.href;
          return;
        }
        window.scrollTo(p, f);
      }), yo = null;
    }
  }
  return Ce(() => {
    function f() {
      u.value = window.scrollY;
    }
    f(), window.addEventListener("scroll", f), nt(() => {
      window.removeEventListener("scroll", f);
    });
  }), me([t, r, i], () => {
    a.value || !r.value || (t.value ? (window.matchMedia("(display-mode: standalone)").matches || d(), n.value || setTimeout(() => {
      c();
    }, 500)) : c());
  }), { restorePositionSetting: c };
}
function P4(e, t) {
  return e && e.value ? e : t;
}
function D4(e) {
  const {
    emitDrag: t,
    emitRelease: n,
    emitClose: a,
    emitOpenChange: r,
    open: o,
    dismissible: s,
    nested: i,
    modal: u,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    scrollLockTimeout: f,
    closeThreshold: p,
    activeSnapPoint: v,
    fadeFromIndex: m,
    direction: g,
    noBodyStyles: w,
    handleOnly: C,
    preventScrollRestoration: S
  } = e, $ = O(o.value ?? !1), k = O(!1), B = O(!1), D = O(!1), P = O(null), E = O(null), T = O(null), M = O(null), I = O(null), F = O(!1), J = O(null), ne = O(0), Q = O(!1);
  O(0);
  const G = O(null);
  O(0);
  const H = q(() => {
    var ke;
    return ((ke = G.value) == null ? void 0 : ke.$el.getBoundingClientRect().height) || 0;
  }), U = P4(
    e.snapPoints,
    O(void 0)
  ), se = q(() => {
    var ke;
    return U && (((ke = U.value) == null ? void 0 : ke.length) ?? 0) > 0;
  }), ee = O(null), {
    activeSnapPointIndex: de,
    onRelease: fe,
    snapPointsOffset: _e,
    onDrag: ye,
    shouldFade: Te,
    getPercentageDragged: ce
  } = B4({
    snapPoints: U,
    activeSnapPoint: v,
    drawerRef: G,
    fadeFromIndex: m,
    overlayRef: P,
    onSnapPointChange: V,
    direction: g
  });
  function V(ke, Le) {
    U.value && ke === Le.length - 1 && (E.value = /* @__PURE__ */ new Date());
  }
  k4({
    isOpen: $,
    modal: u,
    nested: i,
    hasBeenOpened: k,
    noBodyStyles: w,
    preventScrollRestoration: S
  });
  function te() {
    return (window.innerWidth - F_) / window.innerWidth;
  }
  function z(ke, Le) {
    var Ue;
    if (!ke)
      return !1;
    let We = ke;
    const it = (Ue = window.getSelection()) == null ? void 0 : Ue.toString(), ut = G.value ? Js(G.value.$el, g.value) : null, St = /* @__PURE__ */ new Date();
    if (We.hasAttribute("data-vaul-no-drag") || We.closest("[data-vaul-no-drag]"))
      return !1;
    if (g.value === "right" || g.value === "left")
      return !0;
    if (E.value && St.getTime() - E.value.getTime() < 500)
      return !1;
    if (ut !== null && (g.value === "bottom" ? ut > 0 : ut < 0))
      return !0;
    if (it && it.length > 0)
      return !1;
    if (I.value && St.getTime() - I.value.getTime() < f.value && ut === 0 || Le)
      return I.value = St, !1;
    for (; We; ) {
      if (We.scrollHeight > We.clientHeight) {
        if (We.scrollTop !== 0)
          return I.value = /* @__PURE__ */ new Date(), !1;
        if (We.getAttribute("role") === "dialog")
          return !0;
      }
      We = We.parentNode;
    }
    return !0;
  }
  function re(ke) {
    !s.value && !U.value || G.value && !G.value.$el.contains(ke.target) || (B.value = !0, T.value = /* @__PURE__ */ new Date(), ke.target.setPointerCapture(ke.pointerId), ne.value = bt(g.value) ? ke.clientY : ke.clientX);
  }
  function ie(ke) {
    var Le, Ue, We, it, ut, St;
    if (G.value && B.value) {
      const on = g.value === "bottom" || g.value === "right" ? 1 : -1, mn = (ne.value - (bt(g.value) ? ke.clientY : ke.clientX)) * on, Ie = mn > 0, Mt = U.value && !s.value && !Ie;
      if (Mt && de.value === 0)
        return;
      const Ut = Math.abs(mn), Ot = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      let K = Ut / H.value;
      const Y = ce(Ut, Ie);
      if (Y !== null && (K = Y), Mt && K >= 1 || !F.value && !z(ke.target, Ie))
        return;
      if ((Le = G?.value) == null || Le.$el.classList.add(Em), F.value = !0, Et((Ue = G.value) == null ? void 0 : Ue.$el, {
        transition: "none"
      }), Et((We = P.value) == null ? void 0 : We.$el, {
        transition: "none"
      }), U.value && ye({ draggedDistance: mn }), Ie && !U.value) {
        const ge = x4(mn), De = Math.min(ge * -1, 0) * on;
        Et((it = G.value) == null ? void 0 : it.$el, {
          transform: bt(g.value) ? `translate3d(0, ${De}px, 0)` : `translate3d(${De}px, 0, 0)`
        });
        return;
      }
      const ue = 1 - K;
      if ((Te.value || m.value && de.value === m.value - 1) && (t(K), Et(
        (ut = P.value) == null ? void 0 : ut.$el,
        {
          opacity: `${ue}`,
          transition: "none"
        },
        !0
      )), Ot && P.value && d.value) {
        const ge = Math.min(te() + K * (1 - te()), 1), De = 8 - K * 8, Oe = Math.max(0, 14 - K * 14);
        Et(
          Ot,
          {
            borderRadius: `${De}px`,
            transform: bt(g.value) ? `scale(${ge}) translate3d(0, ${Oe}px, 0)` : `scale(${ge}) translate3d(${Oe}px, 0, 0)`,
            transition: "none"
          },
          !0
        );
      }
      if (!U.value) {
        const ge = Ut * on;
        Et((St = G.value) == null ? void 0 : St.$el, {
          transform: bt(g.value) ? `translate3d(0, ${ge}px, 0)` : `translate3d(${ge}px, 0, 0)`
        });
      }
    }
  }
  function L() {
    var ke;
    if (!G.value)
      return;
    const Le = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]"), Ue = Js(G.value.$el, g.value);
    Et(G.value.$el, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`
    }), Et((ke = P.value) == null ? void 0 : ke.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "1"
    }), d.value && Ue && Ue > 0 && $.value && Et(
      Le,
      {
        borderRadius: `${V_}px`,
        overflow: "hidden",
        ...bt(g.value) ? {
          transform: `scale(${te()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${te()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${ft.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${ft.EASE.join(",")})`
      },
      !0
    );
  }
  function be(ke) {
    G.value && (a(), ke || ($.value = !1), window.setTimeout(() => {
      U.value && (v.value = U.value[0]);
    }, ft.DURATION * 1e3));
  }
  Ae(() => {
    if (!$.value && d.value && g4) {
      const ke = setTimeout(() => {
        w4(document.body);
      }, 200);
      return () => clearTimeout(ke);
    }
  }), me(o, () => {
    $.value = o.value, o.value || be();
  });
  function xe(ke) {
    if (!B.value || !G.value)
      return;
    G.value.$el.classList.remove(Em), F.value = !1, B.value = !1, M.value = /* @__PURE__ */ new Date();
    const Le = Js(G.value.$el, g.value);
    if (!z(ke.target, !1) || !Le || Number.isNaN(Le) || T.value === null)
      return;
    const Ue = M.value.getTime() - T.value.getTime(), We = ne.value - (bt(g.value) ? ke.clientY : ke.clientX), it = Math.abs(We) / Ue;
    if (it > 0.05 && (D.value = !0, window.setTimeout(() => {
      D.value = !1;
    }, 200)), U.value) {
      const St = g.value === "bottom" || g.value === "right" ? 1 : -1;
      fe({
        draggedDistance: We * St,
        closeDrawer: be,
        velocity: it,
        dismissible: s.value
      }), n(!0);
      return;
    }
    if (g.value === "bottom" || g.value === "right" ? We > 0 : We < 0) {
      L(), n(!0);
      return;
    }
    if (it > R_) {
      be(), n(!1);
      return;
    }
    const ut = Math.min(
      G.value.$el.getBoundingClientRect().height ?? 0,
      window.innerHeight
    );
    if (Le >= ut * p.value) {
      be(), n(!1);
      return;
    }
    n(!0), L();
  }
  me($, (ke) => {
    ke && (E.value = /* @__PURE__ */ new Date()), r(ke);
  }, { immediate: !0 });
  function Fe(ke) {
    var Le, Ue;
    const We = ke ? (window.innerWidth - Zs) / window.innerWidth : 1, it = ke ? -16 : 0;
    J.value && window.clearTimeout(J.value), Et((Le = G.value) == null ? void 0 : Le.$el, {
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      transform: `scale(${We}) translate3d(0, ${it}px, 0)`
    }), !ke && (Ue = G.value) != null && Ue.$el && (J.value = window.setTimeout(() => {
      var ut, St;
      const on = Js((ut = G.value) == null ? void 0 : ut.$el, g.value);
      Et((St = G.value) == null ? void 0 : St.$el, {
        transition: "none",
        transform: bt(g.value) ? `translate3d(0, ${on}px, 0)` : `translate3d(${on}px, 0, 0)`
      });
    }, 500));
  }
  function Xe(ke) {
    var Le;
    if (ke < 0)
      return;
    const Ue = bt(g.value) ? window.innerHeight : window.innerWidth, We = (Ue - Zs) / Ue, it = We + ke * (1 - We), ut = -16 + ke * Zs;
    Et((Le = G.value) == null ? void 0 : Le.$el, {
      transform: bt(g.value) ? `scale(${it}) translate3d(0, ${ut}px, 0)` : `scale(${it}) translate3d(${ut}px, 0, 0)`,
      transition: "none"
    });
  }
  function lt(ke) {
    var Le;
    const Ue = bt(g.value) ? window.innerHeight : window.innerWidth, We = ke ? (Ue - Zs) / Ue : 1, it = ke ? -16 : 0;
    ke && Et((Le = G.value) == null ? void 0 : Le.$el, {
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      transform: bt(g.value) ? `scale(${We}) translate3d(0, ${it}px, 0)` : `scale(${We}) translate3d(${it}px, 0, 0)`
    });
  }
  return {
    open: o,
    isOpen: $,
    modal: u,
    keyboardIsOpen: Q,
    hasBeenOpened: k,
    drawerRef: G,
    drawerHeightRef: H,
    overlayRef: P,
    handleRef: ee,
    isDragging: B,
    dragStartTime: T,
    isAllowedToDrag: F,
    snapPoints: U,
    activeSnapPoint: v,
    hasSnapPoints: se,
    pointerStart: ne,
    dismissible: s,
    snapPointsOffset: _e,
    direction: g,
    shouldFade: Te,
    fadeFromIndex: m,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    onPress: re,
    onDrag: ie,
    onRelease: xe,
    closeDrawer: be,
    onNestedDrag: Xe,
    onNestedRelease: lt,
    onNestedOpenChange: Fe,
    emitClose: a,
    emitDrag: t,
    emitRelease: n,
    emitOpenChange: r,
    nested: i,
    handleOnly: C,
    noBodyStyles: w
  };
}
const M4 = /* @__PURE__ */ b({
  __name: "DrawerRoot",
  props: {
    activeSnapPoint: { default: void 0 },
    closeThreshold: { default: S4 },
    shouldScaleBackground: { type: Boolean, default: void 0 },
    setBackgroundColorOnScale: { type: Boolean, default: !0 },
    scrollLockTimeout: { default: $4 },
    fixed: { type: Boolean, default: void 0 },
    dismissible: { type: Boolean, default: !0 },
    modal: { type: Boolean, default: !0 },
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: void 0 },
    nested: { type: Boolean, default: !1 },
    direction: { default: "bottom" },
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean, default: !1 },
    preventScrollRestoration: { type: Boolean },
    snapPoints: { default: void 0 },
    fadeFromIndex: { default: void 0 }
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n;
    h0();
    const o = q(() => a.fadeFromIndex ?? (a.snapPoints && a.snapPoints.length - 1)), s = qm(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), i = qm(a, "activeSnapPoint", r, {
      passive: a.activeSnapPoint === void 0
    }), u = {
      emitDrag: (m) => r("drag", m),
      emitRelease: (m) => r("release", m),
      emitClose: () => r("close"),
      emitOpenChange: (m) => {
        r("update:open", m), setTimeout(() => {
          r("animationEnd", m);
        }, ft.DURATION * 1e3);
      }
    }, { closeDrawer: d, hasBeenOpened: c, modal: f, isOpen: p } = _4(
      D4({
        ...u,
        ...Me(a),
        activeSnapPoint: i,
        fadeFromIndex: o,
        open: s
      })
    );
    function v(m) {
      if (s.value !== void 0) {
        u.emitOpenChange(m);
        return;
      }
      p.value = m, m ? c.value = !0 : d();
    }
    return t({
      open: p
    }), (m, g) => (h(), x(l(mi), {
      open: l(p),
      modal: l(f),
      "onUpdate:open": v
    }, {
      default: y(() => [
        _(m.$slots, "default", { open: l(p) })
      ]),
      _: 3
    }, 8, ["open", "modal"]));
  }
}), q4 = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  setup(e) {
    const { overlayRef: t, hasSnapPoints: n, isOpen: a, shouldFade: r } = Zf();
    return (o, s) => (h(), x(l(ds), {
      ref_key: "overlayRef",
      ref: t,
      "data-vaul-overlay": "",
      "data-vaul-snap-points": l(a) && l(n) ? "true" : "false",
      "data-vaul-snap-points-overlay": l(a) && l(r) ? "true" : "false"
    }, null, 8, ["data-vaul-snap-points", "data-vaul-snap-points-overlay"]));
  }
}), E4 = () => () => {
};
function T4() {
  const { direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: a, noBodyStyles: r } = Zf(), o = O(null), s = O(document.body.style.backgroundColor);
  function i() {
    return (window.innerWidth - F_) / window.innerWidth;
  }
  Ae((u) => {
    if (t.value && n.value) {
      o.value && clearTimeout(o.value);
      const d = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!d)
        return;
      C4(
        a.value && !r.value ? Xu(document.body, { background: "black" }) : E4,
        Xu(d, {
          transformOrigin: bt(e.value) ? "top" : "left",
          transitionProperty: "transform, border-radius",
          transitionDuration: `${ft.DURATION}s`,
          transitionTimingFunction: `cubic-bezier(${ft.EASE.join(",")})`
        })
      );
      const c = Xu(d, {
        borderRadius: `${V_}px`,
        overflow: "hidden",
        ...bt(e.value) ? {
          transform: `scale(${i()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${i()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      u(() => {
        c(), o.value = window.setTimeout(() => {
          s.value ? document.body.style.background = s.value : document.body.style.removeProperty("background");
        }, ft.DURATION * 1e3);
      });
    }
  }, { flush: "pre" });
}
const A4 = /* @__PURE__ */ b({
  __name: "DrawerContent",
  setup(e) {
    const {
      open: t,
      isOpen: n,
      snapPointsOffset: a,
      hasSnapPoints: r,
      drawerRef: o,
      onPress: s,
      onDrag: i,
      onRelease: u,
      modal: d,
      emitOpenChange: c,
      dismissible: f,
      keyboardIsOpen: p,
      closeDrawer: v,
      direction: m,
      handleOnly: g
    } = Zf();
    T4();
    const w = O(!1), C = q(() => a.value && a.value.length > 0 ? `${a.value[0]}px` : "0");
    function S(B) {
      if (!d.value || B.defaultPrevented) {
        B.preventDefault();
        return;
      }
      p.value && (p.value = !1), f.value ? c(!1) : B.preventDefault();
    }
    function $(B) {
      g.value || s(B);
    }
    function k(B) {
      g.value || i(B);
    }
    return Ae(() => {
      r.value && window.requestAnimationFrame(() => {
        w.value = !0;
      });
    }), (B, D) => (h(), x(l(us), {
      ref_key: "drawerRef",
      ref: o,
      "data-vaul-drawer": "",
      "data-vaul-drawer-direction": l(m),
      "data-vaul-delayed-snap-points": w.value ? "true" : "false",
      "data-vaul-snap-points": l(n) && l(r) ? "true" : "false",
      style: dt({ "--snap-point-height": C.value }),
      onPointerdown: $,
      onPointermove: k,
      onPointerup: l(u),
      onPointerDownOutside: S,
      onOpenAutoFocus: D[0] || (D[0] = Ye(() => {
      }, ["prevent"])),
      onEscapeKeyDown: D[1] || (D[1] = (P) => {
        l(f) || P.preventDefault();
      })
    }, {
      default: y(() => [
        _(B.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-vaul-drawer-direction", "data-vaul-delayed-snap-points", "data-vaul-snap-points", "style", "onPointerup"]));
  }
}), sU = /* @__PURE__ */ b({
  __name: "Drawer",
  props: {
    activeSnapPoint: {},
    closeThreshold: {},
    shouldScaleBackground: { type: Boolean, default: !0 },
    setBackgroundColorOnScale: { type: Boolean },
    scrollLockTimeout: {},
    fixed: { type: Boolean },
    dismissible: { type: Boolean },
    modal: { type: Boolean },
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    nested: { type: Boolean },
    direction: {},
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean },
    preventScrollRestoration: { type: Boolean },
    snapPoints: {},
    fadeFromIndex: {}
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(M4), A({ "data-slot": "drawer" }, l(r)), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), lU = /* @__PURE__ */ b({
  __name: "DrawerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Aa), A({ "data-slot": "drawer-close" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), O4 = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(q4), A({ "data-slot": "drawer-overlay" }, l(n), {
      class: l(R)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), iU = /* @__PURE__ */ b({
  __name: "DrawerContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = ve(n, t);
    return (o, s) => (h(), x(l(yi), null, {
      default: y(() => [
        N(O4),
        N(l(A4), A({ "data-slot": "drawer-content" }, l(r), {
          class: l(R)(
            "group/drawer-content fixed z-50 flex h-auto flex-col bg-background",
            "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg",
            "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg",
            "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm",
            "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm",
            n.class
          )
        }), {
          default: y(() => [
            s[0] || (s[0] = we("div", { class: "mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full bg-muted group-data-[vaul-drawer-direction=bottom]/drawer-content:block" }, null, -1)),
            _(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), uU = /* @__PURE__ */ b({
  __name: "DrawerDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(gi), A({ "data-slot": "drawer-description" }, l(n), {
      class: l(R)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dU = /* @__PURE__ */ b({
  __name: "DrawerFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "drawer-footer",
      class: ae(l(R)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), cU = /* @__PURE__ */ b({
  __name: "DrawerHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "drawer-header",
      class: ae(l(R)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), fU = /* @__PURE__ */ b({
  __name: "DrawerTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(bi), A({ "data-slot": "drawer-title" }, l(n), {
      class: l(R)("font-semibold text-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pU = /* @__PURE__ */ b({
  __name: "DrawerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(_i), A({ "data-slot": "drawer-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vU = /* @__PURE__ */ b({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(oP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), I4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, mU = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(nP), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", I4, [
          N(l($g), null, {
            default: y(() => [
              N(l(no), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hU = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(hP), null, {
      default: y(() => [
        N(l(lP), A(l(o), {
          class: l(R)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), gU = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(uP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yU = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(cP), A(l(a), {
      class: l(R)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bU = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(vP), A(l(a), {
      class: l(R)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _U = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(yP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), R4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, wU = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(_P), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", R4, [
          N(l($g), null, {
            default: y(() => [
              N(l(uf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xU = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(xP), A(l(n), {
      class: l(R)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), CU = /* @__PURE__ */ b({
  __name: "DropdownMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest opacity-60", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), SU = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(SP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), $U = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(BP), A(l(o), {
      class: l(R)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), BU = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(PP), A(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent data-[state=open]:bg-accent",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(Va), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kU = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(MP), A({ class: "outline-none" }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), PU = /* @__PURE__ */ b({
  __name: "Empty",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty",
      class: ae(
        l(R)(
          "flex min-w-0 flex-1 flex-col items-center justify-center gap-6 rounded-lg border-dashed p-6 text-center text-balance md:p-12",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), DU = /* @__PURE__ */ b({
  __name: "EmptyContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-content",
      class: ae(
        l(R)(
          "flex w-full max-w-sm min-w-0 flex-col items-center gap-4 text-sm text-balance",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), MU = /* @__PURE__ */ b({
  __name: "EmptyDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      "data-slot": "empty-description",
      class: ae(
        l(R)(
          "text-sm/relaxed text-muted-foreground [&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), qU = /* @__PURE__ */ b({
  __name: "EmptyHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-header",
      class: ae(l(R)("flex max-w-sm flex-col items-center gap-2 text-center", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), V4 = ["data-variant"], EU = /* @__PURE__ */ b({
  __name: "EmptyMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-icon",
      "data-variant": e.variant,
      class: ae(l(R)(l(F4)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, V4));
  }
}), TU = /* @__PURE__ */ b({
  __name: "EmptyTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-title",
      class: ae(l(R)("text-lg font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), F4 = an(
  "mb-2 flex shrink-0 items-center justify-center [&_svg]:pointer-events-none [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground [&_svg:not([class*='size-'])]:size-6"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), N4 = ["data-orientation"], AU = /* @__PURE__ */ b({
  __name: "Field",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      role: "group",
      "data-slot": "field",
      "data-orientation": e.orientation,
      class: ae(l(R)(l(j4)({ orientation: e.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, N4));
  }
}), OU = /* @__PURE__ */ b({
  __name: "FieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-content",
      class: ae(l(R)("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), IU = /* @__PURE__ */ b({
  __name: "FieldDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      "data-slot": "field-description",
      class: ae(
        l(R)(
          "text-sm leading-normal font-normal text-muted-foreground group-has-[[data-orientation=horizontal]]/field:text-balance",
          "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), L4 = {
  key: 2,
  class: "ml-4 flex list-disc flex-col gap-1"
}, RU = /* @__PURE__ */ b({
  __name: "FieldError",
  props: {
    class: {},
    errors: {}
  },
  setup(e) {
    const t = e, n = q(() => !t.errors || t.errors.length === 0 ? null : t.errors.length === 1 && t.errors[0]?.message ? t.errors[0].message : t.errors.some((a) => a?.message) ? t.errors : null);
    return (a, r) => a.$slots.default || n.value ? (h(), W("div", {
      key: 0,
      role: "alert",
      "data-slot": "field-error",
      class: ae(l(R)("text-sm font-normal text-destructive", t.class))
    }, [
      a.$slots.default ? _(a.$slots, "default", { key: 0 }) : typeof n.value == "string" ? (h(), W(Ke, { key: 1 }, [
        Re(Ne(n.value), 1)
      ], 64)) : Array.isArray(n.value) ? (h(), W("ul", L4, [
        (h(!0), W(Ke, null, Nt(n.value, (o, s) => (h(), W("li", { key: s }, Ne(o?.message), 1))), 128))
      ])) : qe("", !0)
    ], 2)) : qe("", !0);
  }
}), VU = /* @__PURE__ */ b({
  __name: "FieldGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-group",
      class: ae(
        l(R)(
          "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), N_ = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(UP), A(l(n), {
      class: l(R)(
        "text-sm leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), FU = /* @__PURE__ */ b({
  __name: "FieldLabel",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(N_), {
      "data-slot": "field-label",
      class: ae(
        l(R)(
          "group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50",
          "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&_>[data-slot=field]]:p-3",
          "has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-primary/5 dark:has-[[data-state=checked]]:bg-primary/10",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), z4 = ["data-variant"], NU = /* @__PURE__ */ b({
  __name: "FieldLegend",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("legend", {
      "data-slot": "field-legend",
      "data-variant": e.variant,
      class: ae(
        l(R)(
          "mb-3 font-medium",
          "data-[variant=legend]:text-base",
          "data-[variant=label]:text-sm",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 10, z4));
  }
}), H4 = ["data-content"], U4 = {
  key: 0,
  class: "relative mx-auto block w-fit bg-background px-2 text-muted-foreground",
  "data-slot": "field-separator-content"
}, LU = /* @__PURE__ */ b({
  __name: "FieldSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-separator",
      "data-content": !!n.$slots.default,
      class: ae(
        l(R)("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", t.class)
      )
    }, [
      N(l(Hi), { class: "absolute inset-0 top-1/2" }),
      n.$slots.default ? (h(), W("span", U4, [
        _(n.$slots, "default")
      ])) : qe("", !0)
    ], 10, H4));
  }
}), zU = /* @__PURE__ */ b({
  __name: "FieldSet",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("fieldset", {
      "data-slot": "field-set",
      class: ae(
        l(R)(
          "flex flex-col gap-6",
          "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), HU = /* @__PURE__ */ b({
  __name: "FieldTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-label",
      class: ae(
        l(R)(
          "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), j4 = an(
  "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
  {
    variants: {
      orientation: {
        vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
        horizontal: [
          "flex-row items-center",
          "[&>[data-slot=field-label]]:flex-auto",
          "has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px has-[>[data-slot=field-content]]:items-start"
        ],
        responsive: [
          "@md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto flex-col [&>*]:w-full [&>.sr-only]:w-auto",
          "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
          "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
        ]
      }
    },
    defaultVariants: {
      orientation: "vertical"
    }
  }
);
function Ft(e) {
  return typeof e == "function";
}
function Sr(e) {
  return e == null;
}
const tr = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function Qf(e) {
  return Number(e) >= 0;
}
function W4(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function G4(e) {
  return typeof e == "object" && e !== null;
}
function K4(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function Am(e) {
  if (!G4(e) || K4(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function Zo(e, t) {
  return Object.keys(t).forEach((n) => {
    if (Am(t[n]) && Am(e[n])) {
      e[n] || (e[n] = {}), Zo(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function Bo(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let a = 1; a < t.length; a++) {
    if (Qf(t[a])) {
      n += `[${t[a]}]`;
      continue;
    }
    n += `.${t[a]}`;
  }
  return n;
}
const Y4 = {};
function X4(e) {
  return Y4[e];
}
function Om(e, t, n) {
  typeof n.value == "object" && (n.value = je(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function je(e) {
  if (typeof e != "object") return e;
  var t = 0, n, a, r, o = Object.prototype.toString.call(e);
  if (o === "[object Object]" ? r = Object.create(e.__proto__ || null) : o === "[object Array]" ? r = Array(e.length) : o === "[object Set]" ? (r = /* @__PURE__ */ new Set(), e.forEach(function(s) {
    r.add(je(s));
  })) : o === "[object Map]" ? (r = /* @__PURE__ */ new Map(), e.forEach(function(s, i) {
    r.set(je(i), je(s));
  })) : o === "[object Date]" ? r = /* @__PURE__ */ new Date(+e) : o === "[object RegExp]" ? r = new RegExp(e.source, e.flags) : o === "[object DataView]" ? r = new e.constructor(je(e.buffer)) : o === "[object ArrayBuffer]" ? r = e.slice(0) : o.slice(-6) === "Array]" && (r = new e.constructor(e)), r) {
    for (a = Object.getOwnPropertySymbols(e); t < a.length; t++)
      Om(r, a[t], Object.getOwnPropertyDescriptor(e, a[t]));
    for (t = 0, a = Object.getOwnPropertyNames(e); t < a.length; t++)
      Object.hasOwnProperty.call(r, n = a[t]) && r[n] === e[n] || Om(r, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return r || e;
}
const ks = /* @__PURE__ */ Symbol("vee-validate-form"), J4 = /* @__PURE__ */ Symbol("vee-validate-form-context"), L_ = /* @__PURE__ */ Symbol("vee-validate-field-instance"), si = /* @__PURE__ */ Symbol("Default empty value"), Z4 = typeof window < "u";
function Xd(e) {
  return Ft(e) && !!e.__locatorRef;
}
function kn(e) {
  return !!e && Ft(e.parse) && e.__type === "VVTypedSchema";
}
function li(e) {
  return !!e && Ft(e.validate);
}
function Ps(e) {
  return e === "checkbox" || e === "radio";
}
function Q4(e) {
  return tr(e) || Array.isArray(e);
}
function ez(e) {
  return Array.isArray(e) ? e.length === 0 : tr(e) && Object.keys(e).length === 0;
}
function su(e) {
  return /^\[.+\]$/i.test(e);
}
function tz(e) {
  return z_(e) && e.multiple;
}
function z_(e) {
  return e.tagName === "SELECT";
}
function nz(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function az(e, t) {
  return !nz(e, t) && t.type !== "file" && !Ps(t.type);
}
function H_(e) {
  return ep(e) && e.target && "submit" in e.target;
}
function ep(e) {
  return e ? !!(typeof Event < "u" && Ft(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function Im(e, t) {
  return t in e && e[t] !== si;
}
function Tt(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, a, r;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (!Tt(e[a], t[a]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      for (a of e.entries())
        if (!Tt(a[1], t.get(a[0])))
          return !1;
      return !0;
    }
    if (Vm(e) && Vm(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (e[a] !== t[a])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (e = Rm(e), t = Rm(t), r = Object.keys(e), n = r.length, n !== Object.keys(t).length)
      return !1;
    for (a = n; a-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, r[a]))
        return !1;
    for (a = n; a-- !== 0; ) {
      var o = r[a];
      if (!Tt(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Rm(e) {
  return Object.fromEntries(Object.entries(e).filter(([, t]) => t !== void 0));
}
function Vm(e) {
  return Z4 ? e instanceof File : !1;
}
function tp(e) {
  return su(e) ? e.replace(/\[|\]/gi, "") : e;
}
function pt(e, t, n) {
  return e ? su(t) ? e[tp(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((r, o) => Q4(r) && o in r ? r[o] : n, e) : n;
}
function Rt(e, t, n) {
  if (su(t)) {
    e[tp(t)] = n;
    return;
  }
  const a = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let o = 0; o < a.length; o++) {
    if (o === a.length - 1) {
      r[a[o]] = n;
      return;
    }
    (!(a[o] in r) || Sr(r[a[o]])) && (r[a[o]] = Qf(a[o + 1]) ? [] : {}), r = r[a[o]];
  }
}
function Ju(e, t) {
  if (Array.isArray(e) && Qf(t)) {
    e.splice(Number(t), 1);
    return;
  }
  tr(e) && delete e[t];
}
function Fm(e, t) {
  if (su(t)) {
    delete e[tp(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let a = e;
  for (let o = 0; o < n.length; o++) {
    if (o === n.length - 1) {
      Ju(a, n[o]);
      break;
    }
    if (!(n[o] in a) || Sr(a[n[o]]))
      break;
    a = a[n[o]];
  }
  const r = n.map((o, s) => pt(e, n.slice(0, s).join(".")));
  for (let o = r.length - 1; o >= 0; o--)
    if (ez(r[o])) {
      if (o === 0) {
        Ju(e, n[0]);
        continue;
      }
      Ju(r[o - 1], n[o - 1]);
    }
}
function ln(e) {
  return Object.keys(e);
}
function np(e, t = void 0) {
  const n = Pt();
  return n?.provides[e] || wn(e, t);
}
function Nm(e, t, n) {
  if (Array.isArray(e)) {
    const a = [...e], r = a.findIndex((o) => Tt(o, t));
    return r >= 0 ? a.splice(r, 1) : a.push(t), a;
  }
  return Tt(e, t) ? n : t;
}
function Lm(e, t = 0) {
  let n = null, a = [];
  return function(...r) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const o = e(...r);
      a.forEach((s) => s(o)), a = [];
    }, t), new Promise((o) => a.push(o));
  };
}
function rz(e, t) {
  return tr(t) && t.number ? W4(e) : e;
}
function Jd(e, t) {
  let n;
  return async function(...r) {
    const o = e(...r);
    n = o;
    const s = await o;
    return o !== n ? s : (n = void 0, t(s, r));
  };
}
function oz({ get: e, set: t }) {
  const n = O(je(e()));
  return me(e, (a) => {
    Tt(a, n.value) || (n.value = je(a));
  }, {
    deep: !0
  }), me(n, (a) => {
    Tt(a, e()) || t(je(a));
  }, {
    deep: !0
  }), n;
}
function Zd(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function Qs(e, t) {
  const n = {};
  for (const a in e)
    t.includes(a) || (n[a] = e[a]);
  return n;
}
function sz(e) {
  let t = null, n = [];
  return function(...a) {
    const r = Pe(() => {
      if (t !== r)
        return;
      const o = e(...a);
      n.forEach((s) => s(o)), n = [], t = null;
    });
    return t = r, new Promise((o) => n.push(o));
  };
}
function lu(e, t, n) {
  return t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
    default: () => {
      var a, r;
      return (r = (a = t.slots).default) === null || r === void 0 ? void 0 : r.call(a, n());
    }
  } : t.slots.default;
}
function Zu(e) {
  if (U_(e))
    return e._value;
}
function U_(e) {
  return "_value" in e;
}
function lz(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function ii(e) {
  if (!ep(e))
    return e;
  const t = e.target;
  if (Ps(t.type) && U_(t))
    return Zu(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (tz(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(Zu);
  if (z_(t)) {
    const n = Array.from(t.options).find((a) => a.selected);
    return n ? Zu(n) : t.value;
  }
  return lz(t);
}
function j_(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? tr(e) && e._$$isNormalized ? e : tr(e) ? Object.keys(e).reduce((n, a) => {
    const r = iz(e[a]);
    return e[a] !== !1 && (n[a] = zm(r)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, a) => {
    const r = uz(a);
    return r.name && (n[r.name] = zm(r.params)), n;
  }, t) : t;
}
function iz(e) {
  return e === !0 ? [] : Array.isArray(e) || tr(e) ? e : [e];
}
function zm(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? dz(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, a) => (n[a] = t(e[a]), n), {});
}
const uz = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function dz(e) {
  const t = (n) => {
    var a;
    return (a = pt(n, e)) !== null && a !== void 0 ? a : n[e];
  };
  return t.__locatorRef = e, t;
}
function cz(e) {
  return Array.isArray(e) ? e.filter(Xd) : ln(e).filter((t) => Xd(e[t])).map((t) => e[t]);
}
const fz = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let pz = Object.assign({}, fz);
const Ga = () => pz;
async function W_(e, t, n = {}) {
  const a = n?.bails, r = {
    name: n?.name || "{field}",
    rules: t,
    label: n?.label,
    bails: a ?? !0,
    formData: n?.values || {}
  }, o = await vz(r, e);
  return Object.assign(Object.assign({}, o), { valid: !o.errors.length });
}
async function vz(e, t) {
  const n = e.rules;
  if (kn(n) || li(n))
    return hz(t, Object.assign(Object.assign({}, e), { rules: n }));
  if (Ft(n) || Array.isArray(n)) {
    const i = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, u = Array.isArray(n) ? n : [n], d = u.length, c = [];
    for (let f = 0; f < d; f++) {
      const p = u[f], v = await p(t, i);
      if (!(typeof v != "string" && !Array.isArray(v) && v)) {
        if (Array.isArray(v))
          c.push(...v);
        else {
          const g = typeof v == "string" ? v : K_(i);
          c.push(g);
        }
        if (e.bails)
          return {
            errors: c
          };
      }
    }
    return {
      errors: c
    };
  }
  const a = Object.assign(Object.assign({}, e), { rules: j_(n) }), r = [], o = Object.keys(a.rules), s = o.length;
  for (let i = 0; i < s; i++) {
    const u = o[i], d = await gz(a, t, {
      name: u,
      params: a.rules[u]
    });
    if (d.error && (r.push(d.error), e.bails))
      return {
        errors: r
      };
  }
  return {
    errors: r
  };
}
function mz(e) {
  return !!e && e.name === "ValidationError";
}
function G_(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n, a) {
      var r;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1, context: a?.formData || {} }),
          errors: []
        };
      } catch (o) {
        if (!mz(o))
          throw o;
        if (!(!((r = o.inner) === null || r === void 0) && r.length) && o.errors.length)
          return { errors: [{ path: o.path, errors: o.errors }] };
        const s = o.inner.reduce((i, u) => {
          const d = u.path || "";
          return i[d] || (i[d] = { errors: [], path: d }), i[d].errors.push(...u.errors), i;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function hz(e, t) {
  const a = await (kn(t.rules) ? t.rules : G_(t.rules)).parse(e, { formData: t.formData }), r = [];
  for (const o of a.errors)
    o.errors.length && r.push(...o.errors);
  return {
    value: a.value,
    errors: r
  };
}
async function gz(e, t, n) {
  const a = X4(n.name);
  if (!a)
    throw new Error(`No such validator '${n.name}' exists.`);
  const r = yz(n.params, e.formData), o = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: r })
  }, s = await a(t, r, o);
  return typeof s == "string" ? {
    error: s
  } : {
    error: s ? void 0 : K_(o)
  };
}
function K_(e) {
  const t = Ga().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function yz(e, t) {
  const n = (a) => Xd(a) ? a(t) : a;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((a, r) => (a[r] = n(e[r]), a), {});
}
async function bz(e, t) {
  const a = await (kn(e) ? e : G_(e)).parse(je(t), { formData: je(t) }), r = {}, o = {};
  for (const s of a.errors) {
    const i = s.errors, u = (s.path || "").replace(/\["(\d+)"\]/g, (d, c) => `[${c}]`);
    r[u] = { valid: !i.length, errors: i }, i.length && (o[u] = i[0]);
  }
  return {
    valid: !a.errors.length,
    results: r,
    errors: o,
    values: a.value,
    source: "schema"
  };
}
async function _z(e, t, n) {
  const r = ln(e).map(async (d) => {
    var c, f, p;
    const v = (c = n?.names) === null || c === void 0 ? void 0 : c[d], m = await W_(pt(t, d), e[d], {
      name: v?.name || d,
      label: v?.label,
      values: t,
      bails: (p = (f = n?.bailsMap) === null || f === void 0 ? void 0 : f[d]) !== null && p !== void 0 ? p : !0
    });
    return Object.assign(Object.assign({}, m), { path: d });
  });
  let o = !0;
  const s = await Promise.all(r), i = {}, u = {};
  for (const d of s)
    i[d.path] = {
      valid: d.valid,
      errors: d.errors
    }, d.valid || (o = !1, u[d.path] = d.errors[0]);
  return {
    valid: o,
    results: i,
    errors: u,
    source: "schema"
  };
}
let Hm = 0;
function wz(e, t) {
  const { value: n, initialValue: a, setInitialValue: r } = xz(e, t.modelValue, t.form);
  if (!t.form) {
    let u = function(v) {
      var m;
      "value" in v && (n.value = v.value), "errors" in v && c(v.errors), "touched" in v && (p.touched = (m = v.touched) !== null && m !== void 0 ? m : p.touched), "initialValue" in v && r(v.initialValue);
    };
    const { errors: d, setErrors: c } = $z(), f = Hm >= Number.MAX_SAFE_INTEGER ? 0 : ++Hm, p = Sz(n, a, d, t.schema);
    return {
      id: f,
      path: e,
      value: n,
      initialValue: a,
      meta: p,
      flags: { pendingUnmount: { [f]: !1 }, pendingReset: !1 },
      errors: d,
      setState: u
    };
  }
  const o = t.form.createPathState(e, {
    bails: t.bails,
    label: t.label,
    type: t.type,
    validate: t.validate,
    schema: t.schema
  }), s = q(() => o.errors);
  function i(u) {
    var d, c, f;
    "value" in u && (n.value = u.value), "errors" in u && ((d = t.form) === null || d === void 0 || d.setFieldError(l(e), u.errors)), "touched" in u && ((c = t.form) === null || c === void 0 || c.setFieldTouched(l(e), (f = u.touched) !== null && f !== void 0 ? f : !1)), "initialValue" in u && r(u.initialValue);
  }
  return {
    id: Array.isArray(o.id) ? o.id[o.id.length - 1] : o.id,
    path: e,
    value: n,
    errors: s,
    meta: o,
    initialValue: a,
    flags: o.__flags,
    setState: i
  };
}
function xz(e, t, n) {
  const a = O(l(t));
  function r() {
    return n ? pt(n.initialValues.value, l(e), l(a)) : l(a);
  }
  function o(d) {
    if (!n) {
      a.value = d;
      return;
    }
    n.setFieldInitialValue(l(e), d, !0);
  }
  const s = q(r);
  if (!n)
    return {
      value: O(r()),
      initialValue: s,
      setInitialValue: o
    };
  const i = Cz(t, n, s, e);
  return n.stageInitialValue(l(e), i, !0), {
    value: q({
      get() {
        return pt(n.values, l(e));
      },
      set(d) {
        n.setFieldValue(l(e), d, !1);
      }
    }),
    initialValue: s,
    setInitialValue: o
  };
}
function Cz(e, t, n, a) {
  return mt(e) ? l(e) : e !== void 0 ? e : pt(t.values, l(a), l(n));
}
function Sz(e, t, n, a) {
  const r = q(() => {
    var s, i, u;
    return (u = (i = (s = pe(a)) === null || s === void 0 ? void 0 : s.describe) === null || i === void 0 ? void 0 : i.call(s).required) !== null && u !== void 0 ? u : !1;
  }), o = jt({
    touched: !1,
    pending: !1,
    valid: !0,
    required: r,
    validated: !!l(n).length,
    initialValue: q(() => l(t)),
    dirty: q(() => !Tt(l(e), l(t)))
  });
  return me(n, (s) => {
    o.valid = !s.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), o;
}
function $z() {
  const e = O([]);
  return {
    errors: e,
    setErrors: (t) => {
      e.value = Zd(t);
    }
  };
}
function Bz(e, t, n) {
  return Ps(n?.type) ? Pz(e, t, n) : Y_(e, t, n);
}
function Y_(e, t, n) {
  const { initialValue: a, validateOnMount: r, bails: o, type: s, checkedValue: i, label: u, validateOnValueUpdate: d, uncheckedValue: c, controlled: f, keepValueOnUnmount: p, syncVModel: v, form: m } = kz(n), g = f ? np(ks) : void 0, w = m || g, C = q(() => Bo(pe(e))), S = q(() => {
    if (pe(w?.schema))
      return;
    const V = l(t);
    return li(V) || kn(V) || Ft(V) || Array.isArray(V) ? V : j_(V);
  }), $ = !Ft(S.value) && kn(pe(t)), { id: k, value: B, initialValue: D, meta: P, setState: E, errors: T, flags: M } = wz(C, {
    modelValue: a,
    form: w,
    bails: o,
    label: u,
    type: s,
    validate: S.value ? G : void 0,
    schema: $ ? t : void 0
  }), I = q(() => T.value[0]);
  v && Dz({
    value: B,
    prop: v,
    handleChange: H,
    shouldValidate: () => d && !M.pendingReset
  });
  const F = (ce, V = !1) => {
    P.touched = !0, V && ne();
  };
  async function J(ce) {
    var V, te;
    if (w?.validateSchema) {
      const { results: z } = await w.validateSchema(ce);
      return (V = z[pe(C)]) !== null && V !== void 0 ? V : { valid: !0, errors: [] };
    }
    return S.value ? W_(B.value, S.value, {
      name: pe(C),
      label: pe(u),
      values: (te = w?.values) !== null && te !== void 0 ? te : {},
      bails: o
    }) : { valid: !0, errors: [] };
  }
  const ne = Jd(async () => (P.pending = !0, P.validated = !0, J("validated-only")), (ce) => (M.pendingUnmount[ye.id] || (E({ errors: ce.errors }), P.pending = !1, P.valid = ce.valid), ce)), Q = Jd(async () => J("silent"), (ce) => (P.valid = ce.valid, ce));
  function G(ce) {
    return ce?.mode === "silent" ? Q() : ne();
  }
  function H(ce, V = !0) {
    const te = ii(ce);
    de(te, V);
  }
  Ce(() => {
    if (r)
      return ne();
    (!w || !w.validateSchema) && Q();
  });
  function U(ce) {
    P.touched = ce;
  }
  function se(ce) {
    var V;
    const te = ce && "value" in ce ? ce.value : D.value;
    E({
      value: je(te),
      initialValue: je(te),
      touched: (V = ce?.touched) !== null && V !== void 0 ? V : !1,
      errors: ce?.errors || []
    }), P.pending = !1, P.validated = !1, Q();
  }
  const ee = Pt();
  function de(ce, V = !0) {
    B.value = ee && v ? rz(ce, ee.props.modelModifiers) : ce, (V ? ne : Q)();
  }
  function fe(ce) {
    E({ errors: Array.isArray(ce) ? ce : [ce] });
  }
  const _e = q({
    get() {
      return B.value;
    },
    set(ce) {
      de(ce, d);
    }
  }), ye = {
    id: k,
    name: C,
    label: u,
    value: _e,
    meta: P,
    errors: T,
    errorMessage: I,
    type: s,
    checkedValue: i,
    uncheckedValue: c,
    bails: o,
    keepValueOnUnmount: p,
    resetField: se,
    handleReset: () => se(),
    validate: G,
    handleChange: H,
    handleBlur: F,
    setState: E,
    setTouched: U,
    setErrors: fe,
    setValue: de
  };
  if (Kn(L_, ye), mt(t) && typeof l(t) != "function" && me(t, (ce, V) => {
    Tt(ce, V) || (P.validated ? ne() : Q());
  }, {
    deep: !0
  }), !w)
    return ye;
  const Te = q(() => {
    const ce = S.value;
    return !ce || Ft(ce) || li(ce) || kn(ce) || Array.isArray(ce) ? {} : Object.keys(ce).reduce((V, te) => {
      const z = cz(ce[te]).map((re) => re.__locatorRef).reduce((re, ie) => {
        const L = pt(w.values, ie) || w.values[ie];
        return L !== void 0 && (re[ie] = L), re;
      }, {});
      return Object.assign(V, z), V;
    }, {});
  });
  return me(Te, (ce, V) => {
    if (!Object.keys(ce).length)
      return;
    !Tt(ce, V) && (P.validated ? ne() : Q());
  }), ar(() => {
    var ce;
    const V = (ce = pe(ye.keepValueOnUnmount)) !== null && ce !== void 0 ? ce : pe(w.keepValuesOnUnmount), te = pe(C);
    if (V || !w || M.pendingUnmount[ye.id]) {
      w?.removePathState(te, k);
      return;
    }
    M.pendingUnmount[ye.id] = !0;
    const z = w.getPathState(te);
    if (Array.isArray(z?.id) && z?.multiple ? z?.id.includes(ye.id) : z?.id === ye.id) {
      if (z?.multiple && Array.isArray(z.value)) {
        const ie = z.value.findIndex((L) => Tt(L, pe(ye.checkedValue)));
        if (ie > -1) {
          const L = [...z.value];
          L.splice(ie, 1), w.setFieldValue(te, L);
        }
        Array.isArray(z.id) && z.id.splice(z.id.indexOf(ye.id), 1);
      } else
        w.unsetPathValue(pe(C));
      w.removePathState(te, k);
    }
  }), ye;
}
function kz(e) {
  const t = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    label: void 0,
    validateOnValueUpdate: !0,
    keepValueOnUnmount: void 0,
    syncVModel: !1,
    controlled: !0
  }), n = !!e?.syncVModel, a = typeof e?.syncVModel == "string" ? e.syncVModel : e?.modelPropName || "modelValue", r = n && !("initialValue" in (e || {})) ? Qd(Pt(), a) : e?.initialValue;
  if (!e)
    return Object.assign(Object.assign({}, t()), { initialValue: r });
  const o = "valueProp" in e ? e.valueProp : e.checkedValue, s = "standalone" in e ? !e.standalone : e.controlled, i = e?.modelPropName || e?.syncVModel || !1;
  return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
    initialValue: r,
    controlled: s ?? !0,
    checkedValue: o,
    syncVModel: i
  });
}
function Pz(e, t, n) {
  const a = n?.standalone ? void 0 : np(ks), r = n?.checkedValue, o = n?.uncheckedValue;
  function s(i) {
    const u = i.handleChange, d = q(() => {
      const f = pe(i.value), p = pe(r);
      return Array.isArray(f) ? f.findIndex((v) => Tt(v, p)) >= 0 : Tt(p, f);
    });
    function c(f, p = !0) {
      var v, m;
      if (d.value === ((v = f?.target) === null || v === void 0 ? void 0 : v.checked)) {
        p && i.validate();
        return;
      }
      const g = pe(e), w = a?.getPathState(g), C = ii(f);
      let S = (m = pe(r)) !== null && m !== void 0 ? m : C;
      a && w?.multiple && w.type === "checkbox" ? S = Nm(pt(a.values, g) || [], S, void 0) : n?.type === "checkbox" && (S = Nm(pe(i.value), S, pe(o))), u(S, p);
    }
    return Object.assign(Object.assign({}, i), {
      checked: d,
      checkedValue: r,
      uncheckedValue: o,
      handleChange: c
    });
  }
  return s(Y_(e, t, n));
}
function Dz({ prop: e, value: t, handleChange: n, shouldValidate: a }) {
  const r = Pt();
  if (!r || !e)
    return;
  const o = typeof e == "string" ? e : "modelValue", s = `update:${o}`;
  o in r.props && (me(t, (i) => {
    Tt(i, Qd(r, o)) || r.emit(s, i);
  }), me(() => Qd(r, o), (i) => {
    if (i === si && t.value === void 0)
      return;
    const u = i === si ? void 0 : i;
    Tt(u, t.value) || n(u, a());
  }));
}
function Qd(e, t) {
  if (e)
    return e.props[t];
}
const Mz = /* @__PURE__ */ b({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => Ga().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: si
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = Hn(e, "rules"), a = Hn(e, "name"), r = Hn(e, "label"), o = Hn(e, "uncheckedValue"), s = Hn(e, "keepValue"), { errors: i, value: u, errorMessage: d, validate: c, handleChange: f, handleBlur: p, setTouched: v, resetField: m, handleReset: g, meta: w, checked: C, setErrors: S, setValue: $ } = Bz(a, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: Ez(e, t),
      // Only for checkboxes and radio buttons
      checkedValue: t.attrs.value,
      uncheckedValue: o,
      label: r,
      validateOnValueUpdate: e.validateOnModelUpdate,
      keepValueOnUnmount: s,
      syncVModel: !0
    }), k = function(M, I = !0) {
      f(M, I);
    }, B = q(() => {
      const { validateOnInput: T, validateOnChange: M, validateOnBlur: I, validateOnModelUpdate: F } = qz(e);
      function J(H) {
        p(H, I), Ft(t.attrs.onBlur) && t.attrs.onBlur(H);
      }
      function ne(H) {
        k(H, T), Ft(t.attrs.onInput) && t.attrs.onInput(H);
      }
      function Q(H) {
        k(H, M), Ft(t.attrs.onChange) && t.attrs.onChange(H);
      }
      const G = {
        name: e.name,
        onBlur: J,
        onInput: ne,
        onChange: Q
      };
      return G["onUpdate:modelValue"] = (H) => k(H, F), G;
    }), D = q(() => {
      const T = Object.assign({}, B.value);
      Ps(t.attrs.type) && C && (T.checked = C.value);
      const M = Um(e, t);
      return az(M, t.attrs) && (T.value = u.value), T;
    }), P = q(() => Object.assign(Object.assign({}, B.value), { modelValue: u.value }));
    function E() {
      return {
        field: D.value,
        componentField: P.value,
        value: u.value,
        meta: w,
        errors: i.value,
        errorMessage: d.value,
        validate: c,
        resetField: m,
        handleChange: k,
        handleInput: (T) => k(T, !1),
        handleReset: g,
        handleBlur: B.value.onBlur,
        setTouched: v,
        setErrors: S,
        setValue: $
      };
    }
    return t.expose({
      value: u,
      meta: w,
      errors: i,
      errorMessage: d,
      setErrors: S,
      setTouched: v,
      setValue: $,
      reset: m,
      validate: c,
      handleChange: f
    }), () => {
      const T = kt(Um(e, t)), M = lu(T, t, E);
      return T ? en(T, Object.assign(Object.assign({}, t.attrs), D.value), M) : M;
    };
  }
});
function Um(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function qz(e) {
  var t, n, a, r;
  const { validateOnInput: o, validateOnChange: s, validateOnBlur: i, validateOnModelUpdate: u } = Ga();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : o,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : s,
    validateOnBlur: (a = e.validateOnBlur) !== null && a !== void 0 ? a : i,
    validateOnModelUpdate: (r = e.validateOnModelUpdate) !== null && r !== void 0 ? r : u
  };
}
function Ez(e, t) {
  return Ps(t.attrs.type) ? Im(e, "modelValue") ? e.modelValue : void 0 : Im(e, "modelValue") ? e.modelValue : t.attrs.value;
}
const UU = Mz;
let Tz = 0;
const el = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function X_(e) {
  const t = e?.initialValues || {}, n = Object.assign({}, pe(t)), a = l(e?.validationSchema);
  return a && kn(a) && Ft(a.cast) ? je(a.cast(n) || {}) : je(n);
}
function Az(e) {
  var t;
  const n = Tz++, a = e?.name || "Form";
  let r = 0;
  const o = O(!1), s = O(!1), i = O(0), u = [], d = jt(X_(e)), c = O([]), f = O({}), p = O({}), v = sz(() => {
    p.value = c.value.reduce((K, Y) => (K[Bo(pe(Y.path))] = Y, K), {});
  });
  function m(K, Y) {
    const ue = H(K);
    if (!ue) {
      typeof K == "string" && (f.value[Bo(K)] = Zd(Y));
      return;
    }
    if (typeof K == "string") {
      const ge = Bo(K);
      f.value[ge] && delete f.value[ge];
    }
    ue.errors = Zd(Y), ue.valid = !ue.errors.length;
  }
  function g(K) {
    ln(K).forEach((Y) => {
      m(Y, K[Y]);
    });
  }
  e?.initialErrors && g(e.initialErrors);
  const w = q(() => {
    const K = c.value.reduce((Y, ue) => (ue.errors.length && (Y[pe(ue.path)] = ue.errors), Y), {});
    return Object.assign(Object.assign({}, f.value), K);
  }), C = q(() => ln(w.value).reduce((K, Y) => {
    const ue = w.value[Y];
    return ue?.length && (K[Y] = ue[0]), K;
  }, {})), S = q(() => c.value.reduce((K, Y) => (K[pe(Y.path)] = { name: pe(Y.path) || "", label: Y.label || "" }, K), {})), $ = q(() => c.value.reduce((K, Y) => {
    var ue;
    return K[pe(Y.path)] = (ue = Y.bails) !== null && ue !== void 0 ? ue : !0, K;
  }, {})), k = Object.assign({}, e?.initialErrors || {}), B = (t = e?.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: D, originalInitialValues: P, setInitialValues: E } = Iz(c, d, e), T = Oz(c, d, P, C), M = q(() => c.value.reduce((K, Y) => {
    const ue = pt(d, pe(Y.path));
    return Rt(K, pe(Y.path), ue), K;
  }, {})), I = e?.validationSchema;
  function F(K, Y) {
    var ue, ge;
    const De = q(() => pt(D.value, pe(K))), Oe = p.value[pe(K)], Ee = Y?.type === "checkbox" || Y?.type === "radio";
    if (Oe && Ee) {
      Oe.multiple = !0;
      const Yt = r++;
      return Array.isArray(Oe.id) ? Oe.id.push(Yt) : Oe.id = [Oe.id, Yt], Oe.fieldsCount++, Oe.__flags.pendingUnmount[Yt] = !1, Oe;
    }
    const rt = q(() => pt(d, pe(K))), ct = pe(K), qt = se.findIndex((Yt) => Yt === ct);
    qt !== -1 && se.splice(qt, 1);
    const at = q(() => {
      var Yt, ha, mr, so;
      const du = pe(I);
      if (kn(du))
        return (ha = (Yt = du.describe) === null || Yt === void 0 ? void 0 : Yt.call(du, pe(K)).required) !== null && ha !== void 0 ? ha : !1;
      const cu = pe(Y?.schema);
      return kn(cu) && (so = (mr = cu.describe) === null || mr === void 0 ? void 0 : mr.call(cu).required) !== null && so !== void 0 ? so : !1;
    }), $t = r++, It = jt({
      id: $t,
      path: K,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((ue = k[ct]) === null || ue === void 0) && ue.length),
      required: at,
      initialValue: De,
      errors: ht([]),
      bails: (ge = Y?.bails) !== null && ge !== void 0 ? ge : !1,
      label: Y?.label,
      type: Y?.type || "default",
      value: rt,
      multiple: !1,
      __flags: {
        pendingUnmount: { [$t]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: Y?.validate,
      dirty: q(() => !Tt(l(rt), l(De)))
    });
    return c.value.push(It), p.value[ct] = It, v(), C.value[ct] && !k[ct] && Pe(() => {
      Ue(ct, { mode: "silent" });
    }), mt(K) && me(K, (Yt) => {
      v();
      const ha = je(rt.value);
      p.value[Yt] = It, Pe(() => {
        Rt(d, Yt, ha);
      });
    }), It;
  }
  const J = Lm(St, 5), ne = Lm(St, 5), Q = Jd(async (K) => await (K === "silent" ? J() : ne()), (K, [Y]) => {
    const ue = ln(V.errorBag.value), De = [
      .../* @__PURE__ */ new Set([...ln(K.results), ...c.value.map((Oe) => Oe.path), ...ue])
    ].sort().reduce((Oe, Ee) => {
      var rt;
      const ct = Ee, qt = H(ct) || U(ct), at = ((rt = K.results[ct]) === null || rt === void 0 ? void 0 : rt.errors) || [], $t = pe(qt?.path) || ct, It = Rz({ errors: at, valid: !at.length }, Oe.results[$t]);
      return Oe.results[$t] = It, It.valid || (Oe.errors[$t] = It.errors[0]), qt && f.value[$t] && delete f.value[$t], qt ? (qt.valid = It.valid, Y === "silent" || Y === "validated-only" && !qt.validated || m(qt, It.errors), Oe) : (m($t, at), Oe);
    }, {
      valid: K.valid,
      results: {},
      errors: {},
      source: K.source
    });
    return K.values && (De.values = K.values, De.source = K.source), ln(De.results).forEach((Oe) => {
      var Ee;
      const rt = H(Oe);
      rt && Y !== "silent" && (Y === "validated-only" && !rt.validated || m(rt, (Ee = De.results[Oe]) === null || Ee === void 0 ? void 0 : Ee.errors));
    }), De;
  });
  function G(K) {
    c.value.forEach(K);
  }
  function H(K) {
    const Y = typeof K == "string" ? Bo(K) : K;
    return typeof Y == "string" ? p.value[Y] : Y;
  }
  function U(K) {
    return c.value.filter((ue) => K.startsWith(pe(ue.path))).reduce((ue, ge) => ue ? ge.path.length > ue.path.length ? ge : ue : ge, void 0);
  }
  let se = [], ee;
  function de(K) {
    return se.push(K), ee || (ee = Pe(() => {
      [...se].sort().reverse().forEach((ue) => {
        Fm(d, ue);
      }), se = [], ee = null;
    })), ee;
  }
  function fe(K) {
    return function(ue, ge) {
      return function(Oe) {
        return Oe instanceof Event && (Oe.preventDefault(), Oe.stopPropagation()), G((Ee) => Ee.touched = !0), o.value = !0, i.value++, Le().then((Ee) => {
          const rt = je(d);
          if (Ee.valid && typeof ue == "function") {
            const ct = je(M.value);
            let qt = K ? ct : rt;
            return Ee.values && (qt = Ee.source === "schema" ? Ee.values : Object.assign({}, qt, Ee.values)), ue(qt, {
              evt: Oe,
              controlledValues: ct,
              setErrors: g,
              setFieldError: m,
              setTouched: Xe,
              setFieldTouched: L,
              setValues: re,
              setFieldValue: te,
              resetForm: ke,
              resetField: lt
            });
          }
          !Ee.valid && typeof ge == "function" && ge({
            values: rt,
            evt: Oe,
            errors: Ee.errors,
            results: Ee.results
          });
        }).then((Ee) => (o.value = !1, Ee), (Ee) => {
          throw o.value = !1, Ee;
        });
      };
    };
  }
  const ye = fe(!1);
  ye.withControlled = fe(!0);
  function Te(K, Y) {
    const ue = c.value.findIndex((De) => De.path === K && (Array.isArray(De.id) ? De.id.includes(Y) : De.id === Y)), ge = c.value[ue];
    if (!(ue === -1 || !ge)) {
      if (Pe(() => {
        Ue(K, { mode: "silent", warn: !1 });
      }), ge.multiple && ge.fieldsCount && ge.fieldsCount--, Array.isArray(ge.id)) {
        const De = ge.id.indexOf(Y);
        De >= 0 && ge.id.splice(De, 1), delete ge.__flags.pendingUnmount[Y];
      }
      (!ge.multiple || ge.fieldsCount <= 0) && (c.value.splice(ue, 1), We(K), v(), delete p.value[K]);
    }
  }
  function ce(K) {
    ln(p.value).forEach((Y) => {
      Y.startsWith(K) && delete p.value[Y];
    }), c.value = c.value.filter((Y) => !Y.path.startsWith(K)), Pe(() => {
      v();
    });
  }
  const V = {
    name: a,
    formId: n,
    values: d,
    controlledValues: M,
    errorBag: w,
    errors: C,
    schema: I,
    submitCount: i,
    meta: T,
    isSubmitting: o,
    isValidating: s,
    fieldArrays: u,
    keepValuesOnUnmount: B,
    validateSchema: l(I) ? Q : void 0,
    validate: Le,
    setFieldError: m,
    validateField: Ue,
    setFieldValue: te,
    setValues: re,
    setErrors: g,
    setFieldTouched: L,
    setTouched: Xe,
    resetForm: ke,
    resetField: lt,
    handleSubmit: ye,
    useFieldModel: Ie,
    defineInputBinds: Mt,
    defineComponentBinds: Ut,
    defineField: mn,
    stageInitialValue: it,
    unsetInitialValue: We,
    setFieldInitialValue: ut,
    createPathState: F,
    getPathState: H,
    unsetPathValue: de,
    removePathState: Te,
    initialValues: D,
    getAllPathStates: () => c.value,
    destroyPath: ce,
    isFieldTouched: be,
    isFieldDirty: xe,
    isFieldValid: Fe
  };
  function te(K, Y, ue = !0) {
    const ge = je(Y), De = typeof K == "string" ? K : K.path;
    H(De) || F(De), Rt(d, De, ge), ue && Ue(De);
  }
  function z(K, Y = !0) {
    ln(d).forEach((ue) => {
      delete d[ue];
    }), ln(K).forEach((ue) => {
      te(ue, K[ue], !1);
    }), Y && Le();
  }
  function re(K, Y = !0) {
    Zo(d, K), u.forEach((ue) => ue && ue.reset()), Y && Le();
  }
  function ie(K, Y) {
    const ue = H(pe(K)) || F(K);
    return q({
      get() {
        return ue.value;
      },
      set(ge) {
        var De;
        const Oe = pe(K);
        te(Oe, ge, (De = pe(Y)) !== null && De !== void 0 ? De : !1);
      }
    });
  }
  function L(K, Y) {
    const ue = H(K);
    ue && (ue.touched = Y);
  }
  function be(K) {
    const Y = H(K);
    return Y ? Y.touched : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.touched);
  }
  function xe(K) {
    const Y = H(K);
    return Y ? Y.dirty : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.dirty);
  }
  function Fe(K) {
    const Y = H(K);
    return Y ? Y.valid : c.value.filter((ue) => ue.path.startsWith(K)).every((ue) => ue.valid);
  }
  function Xe(K) {
    if (typeof K == "boolean") {
      G((Y) => {
        Y.touched = K;
      });
      return;
    }
    ln(K).forEach((Y) => {
      L(Y, !!K[Y]);
    });
  }
  function lt(K, Y) {
    var ue;
    const ge = Y && "value" in Y ? Y.value : pt(D.value, K), De = H(K);
    De && (De.__flags.pendingReset = !0), ut(K, je(ge), !0), te(K, ge, !1), L(K, (ue = Y?.touched) !== null && ue !== void 0 ? ue : !1), m(K, Y?.errors || []), Pe(() => {
      De && (De.__flags.pendingReset = !1);
    });
  }
  function ke(K, Y) {
    let ue = je(K?.values ? K.values : P.value);
    ue = Y?.force ? ue : Zo(P.value, ue), ue = kn(I) && Ft(I.cast) ? I.cast(ue) : ue, E(ue, { force: Y?.force }), G((ge) => {
      var De;
      ge.__flags.pendingReset = !0, ge.validated = !1, ge.touched = ((De = K?.touched) === null || De === void 0 ? void 0 : De[pe(ge.path)]) || !1, te(pe(ge.path), pt(ue, pe(ge.path)), !1), m(pe(ge.path), void 0);
    }), Y?.force ? z(ue, !1) : re(ue, !1), g(K?.errors || {}), i.value = K?.submitCount || 0, Pe(() => {
      Le({ mode: "silent" }), G((ge) => {
        ge.__flags.pendingReset = !1;
      });
    });
  }
  async function Le(K) {
    const Y = K?.mode || "force";
    if (Y === "force" && G((Ee) => Ee.validated = !0), V.validateSchema)
      return V.validateSchema(Y);
    s.value = !0;
    const ue = await Promise.all(c.value.map((Ee) => Ee.validate ? Ee.validate(K).then((rt) => ({
      key: pe(Ee.path),
      valid: rt.valid,
      errors: rt.errors,
      value: rt.value
    })) : Promise.resolve({
      key: pe(Ee.path),
      valid: !0,
      errors: [],
      value: void 0
    })));
    s.value = !1;
    const ge = {}, De = {}, Oe = {};
    for (const Ee of ue)
      ge[Ee.key] = {
        valid: Ee.valid,
        errors: Ee.errors
      }, Ee.value && Rt(Oe, Ee.key, Ee.value), Ee.errors.length && (De[Ee.key] = Ee.errors[0]);
    return {
      valid: ue.every((Ee) => Ee.valid),
      results: ge,
      errors: De,
      values: Oe,
      source: "fields"
    };
  }
  async function Ue(K, Y) {
    var ue;
    const ge = H(K);
    if (ge && Y?.mode !== "silent" && (ge.validated = !0), I) {
      const { results: De } = await Q(Y?.mode || "validated-only");
      return De[K] || { errors: [], valid: !0 };
    }
    return ge?.validate ? ge.validate(Y) : (!ge && (ue = Y?.warn), Promise.resolve({ errors: [], valid: !0 }));
  }
  function We(K) {
    Fm(D.value, K);
  }
  function it(K, Y, ue = !1) {
    ut(K, Y), Rt(d, K, Y), ue && !e?.initialValues && Rt(P.value, K, je(Y));
  }
  function ut(K, Y, ue = !1) {
    Rt(D.value, K, je(Y)), ue && Rt(P.value, K, je(Y));
  }
  async function St() {
    const K = l(I);
    if (!K)
      return { valid: !0, results: {}, errors: {}, source: "none" };
    s.value = !0;
    const Y = li(K) || kn(K) ? await bz(K, d) : await _z(K, d, {
      names: S.value,
      bailsMap: $.value
    });
    return s.value = !1, Y;
  }
  const on = ye((K, { evt: Y }) => {
    H_(Y) && Y.target.submit();
  });
  Ce(() => {
    if (e?.initialErrors && g(e.initialErrors), e?.initialTouched && Xe(e.initialTouched), e?.validateOnMount) {
      Le();
      return;
    }
    V.validateSchema && V.validateSchema("silent");
  }), mt(I) && me(I, () => {
    var K;
    (K = V.validateSchema) === null || K === void 0 || K.call(V, "validated-only");
  }), Kn(ks, V);
  function mn(K, Y) {
    const ue = Ft(Y) ? void 0 : Y?.label, ge = H(pe(K)) || F(K, { label: ue }), De = () => Ft(Y) ? Y(Qs(ge, el)) : Y || {};
    function Oe() {
      var at;
      ge.touched = !0, ((at = De().validateOnBlur) !== null && at !== void 0 ? at : Ga().validateOnBlur) && Ue(pe(ge.path));
    }
    function Ee() {
      var at;
      ((at = De().validateOnInput) !== null && at !== void 0 ? at : Ga().validateOnInput) && Pe(() => {
        Ue(pe(ge.path));
      });
    }
    function rt() {
      var at;
      ((at = De().validateOnChange) !== null && at !== void 0 ? at : Ga().validateOnChange) && Pe(() => {
        Ue(pe(ge.path));
      });
    }
    const ct = q(() => {
      const at = {
        onChange: rt,
        onInput: Ee,
        onBlur: Oe
      };
      return Ft(Y) ? Object.assign(Object.assign({}, at), Y(Qs(ge, el)).props || {}) : Y?.props ? Object.assign(Object.assign({}, at), Y.props(Qs(ge, el))) : at;
    });
    return [ie(K, () => {
      var at, $t, It;
      return (It = (at = De().validateOnModelUpdate) !== null && at !== void 0 ? at : ($t = Ga()) === null || $t === void 0 ? void 0 : $t.validateOnModelUpdate) !== null && It !== void 0 ? It : !0;
    }), ct];
  }
  function Ie(K) {
    return Array.isArray(K) ? K.map((Y) => ie(Y, !0)) : ie(K);
  }
  function Mt(K, Y) {
    const [ue, ge] = mn(K, Y);
    function De() {
      ge.value.onBlur();
    }
    function Oe(rt) {
      const ct = ii(rt);
      te(pe(K), ct, !1), ge.value.onInput();
    }
    function Ee(rt) {
      const ct = ii(rt);
      te(pe(K), ct, !1), ge.value.onChange();
    }
    return q(() => Object.assign(Object.assign({}, ge.value), {
      onBlur: De,
      onInput: Oe,
      onChange: Ee,
      value: ue.value
    }));
  }
  function Ut(K, Y) {
    const [ue, ge] = mn(K, Y), De = H(pe(K));
    function Oe(Ee) {
      ue.value = Ee;
    }
    return q(() => {
      const Ee = Ft(Y) ? Y(Qs(De, el)) : Y || {};
      return Object.assign({ [Ee.model || "modelValue"]: ue.value, [`onUpdate:${Ee.model || "modelValue"}`]: Oe }, ge.value);
    });
  }
  const Ot = Object.assign(Object.assign({}, V), { values: nr(d), handleReset: () => ke(), submitForm: on });
  return Kn(J4, Ot), Ot;
}
function Oz(e, t, n, a) {
  const r = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, o = q(() => !Tt(t, l(n)));
  function s() {
    const u = e.value;
    return ln(r).reduce((d, c) => {
      const f = r[c];
      return d[c] = u[f]((p) => p[c]), d;
    }, {});
  }
  const i = jt(s());
  return Ae(() => {
    const u = s();
    i.touched = u.touched, i.valid = u.valid, i.pending = u.pending;
  }), q(() => Object.assign(Object.assign({ initialValues: l(n) }, i), { valid: i.valid && !ln(a.value).length, dirty: o.value }));
}
function Iz(e, t, n) {
  const a = X_(n), r = O(a), o = O(je(a));
  function s(i, u) {
    u?.force ? (r.value = je(i), o.value = je(i)) : (r.value = Zo(je(r.value) || {}, je(i)), o.value = Zo(je(o.value) || {}, je(i))), u?.updateFields && e.value.forEach((d) => {
      if (d.touched)
        return;
      const f = pt(r.value, pe(d.path));
      Rt(t, pe(d.path), je(f));
    });
  }
  return {
    initialValues: r,
    originalInitialValues: o,
    setInitialValues: s
  };
}
function Rz(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const Vz = /* @__PURE__ */ b({
  name: "Form",
  inheritAttrs: !1,
  props: {
    as: {
      type: null,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: "Form"
    }
  },
  setup(e, t) {
    const n = Hn(e, "validationSchema"), a = Hn(e, "keepValues"), { errors: r, errorBag: o, values: s, meta: i, isSubmitting: u, isValidating: d, submitCount: c, controlledValues: f, validate: p, validateField: v, handleReset: m, resetForm: g, handleSubmit: w, setErrors: C, setFieldError: S, setFieldValue: $, setValues: k, setFieldTouched: B, setTouched: D, resetField: P } = Az({
      validationSchema: n.value ? n : void 0,
      initialValues: e.initialValues,
      initialErrors: e.initialErrors,
      initialTouched: e.initialTouched,
      validateOnMount: e.validateOnMount,
      keepValuesOnUnmount: a,
      name: e.name
    }), E = w((G, { evt: H }) => {
      H_(H) && H.target.submit();
    }, e.onInvalidSubmit), T = e.onSubmit ? w(e.onSubmit, e.onInvalidSubmit) : E;
    function M(G) {
      ep(G) && G.preventDefault(), m(), typeof t.attrs.onReset == "function" && t.attrs.onReset();
    }
    function I(G, H) {
      return w(typeof G == "function" && !H ? G : H, e.onInvalidSubmit)(G);
    }
    function F() {
      return je(s);
    }
    function J() {
      return je(i.value);
    }
    function ne() {
      return je(r.value);
    }
    function Q() {
      return {
        meta: i.value,
        errors: r.value,
        errorBag: o.value,
        values: s,
        isSubmitting: u.value,
        isValidating: d.value,
        submitCount: c.value,
        controlledValues: f.value,
        validate: p,
        validateField: v,
        handleSubmit: I,
        handleReset: m,
        submitForm: E,
        setErrors: C,
        setFieldError: S,
        setFieldValue: $,
        setValues: k,
        setFieldTouched: B,
        setTouched: D,
        resetForm: g,
        resetField: P,
        getValues: F,
        getMeta: J,
        getErrors: ne
      };
    }
    return t.expose({
      setFieldError: S,
      setErrors: C,
      setFieldValue: $,
      setValues: k,
      setFieldTouched: B,
      setTouched: D,
      resetForm: g,
      validate: p,
      validateField: v,
      resetField: P,
      getValues: F,
      getMeta: J,
      getErrors: ne,
      values: s,
      meta: i,
      errors: r
    }), function() {
      const H = e.as === "form" ? e.as : e.as ? kt(e.as) : null, U = lu(H, t, Q);
      return H ? en(H, Object.assign(Object.assign(Object.assign({}, H === "form" ? {
        // Disables native validation as vee-validate will handle it.
        novalidate: !0
      } : {}), t.attrs), { onSubmit: T, onReset: M }), U) : U;
    };
  }
}), jU = Vz;
function Fz(e) {
  const t = np(ks, void 0), n = O([]), a = () => {
  }, r = {
    fields: n,
    remove: a,
    push: a,
    swap: a,
    insert: a,
    update: a,
    replace: a,
    prepend: a,
    move: a
  };
  if (!t || !l(e))
    return r;
  const o = t.fieldArrays.find((B) => l(B.path) === l(e));
  if (o)
    return o;
  let s = 0;
  function i() {
    return pt(t?.values, pe(e), []) || [];
  }
  function u() {
    const B = i();
    Array.isArray(B) && (n.value = B.map((D, P) => c(D, P, n.value)), d());
  }
  u();
  function d() {
    const B = n.value.length;
    for (let D = 0; D < B; D++) {
      const P = n.value[D];
      P.isFirst = D === 0, P.isLast = D === B - 1;
    }
  }
  function c(B, D, P) {
    if (P && !Sr(D) && P[D])
      return P[D];
    const E = s++;
    return {
      key: E,
      value: oz({
        get() {
          const M = pt(t?.values, pe(e), []) || [], I = n.value.findIndex((F) => F.key === E);
          return I === -1 ? B : M[I];
        },
        set(M) {
          const I = n.value.findIndex((F) => F.key === E);
          I !== -1 && C(I, M);
        }
      }),
      // will be auto unwrapped
      isFirst: !1,
      isLast: !1
    };
  }
  function f() {
    d(), t?.validate({ mode: "silent" });
  }
  function p(B) {
    const D = pe(e), P = pt(t?.values, D);
    if (!P || !Array.isArray(P))
      return;
    const E = [...P];
    E.splice(B, 1);
    const T = D + `[${B}]`;
    t.destroyPath(T), t.unsetInitialValue(T), Rt(t.values, D, E), n.value.splice(B, 1), f();
  }
  function v(B) {
    const D = je(B), P = pe(e), E = pt(t?.values, P), T = Sr(E) ? [] : E;
    if (!Array.isArray(T))
      return;
    const M = [...T];
    M.push(D), t.stageInitialValue(P + `[${M.length - 1}]`, D), Rt(t.values, P, M), n.value.push(c(D)), f();
  }
  function m(B, D) {
    const P = pe(e), E = pt(t?.values, P);
    if (!Array.isArray(E) || !(B in E) || !(D in E))
      return;
    const T = [...E], M = [...n.value], I = T[B];
    T[B] = T[D], T[D] = I;
    const F = M[B];
    M[B] = M[D], M[D] = F, Rt(t.values, P, T), n.value = M, d();
  }
  function g(B, D) {
    const P = je(D), E = pe(e), T = pt(t?.values, E);
    if (!Array.isArray(T) || T.length < B)
      return;
    const M = [...T], I = [...n.value];
    M.splice(B, 0, P), I.splice(B, 0, c(P)), Rt(t.values, E, M), n.value = I, f();
  }
  function w(B) {
    const D = pe(e);
    t.stageInitialValue(D, B), Rt(t.values, D, B), u(), f();
  }
  function C(B, D) {
    const P = pe(e), E = pt(t?.values, P);
    !Array.isArray(E) || E.length - 1 < B || (Rt(t.values, `${P}[${B}]`, D), t?.validate({ mode: "validated-only" }));
  }
  function S(B) {
    const D = je(B), P = pe(e), E = pt(t?.values, P), T = Sr(E) ? [] : E;
    if (!Array.isArray(T))
      return;
    const M = [D, ...T];
    Rt(t.values, P, M), t.stageInitialValue(P + "[0]", D), n.value.unshift(c(D)), f();
  }
  function $(B, D) {
    const P = pe(e), E = pt(t?.values, P), T = Sr(E) ? [] : [...E];
    if (!Array.isArray(E) || !(B in E) || !(D in E))
      return;
    const M = [...n.value], I = M[B];
    M.splice(B, 1), M.splice(D, 0, I);
    const F = T[B];
    T.splice(B, 1), T.splice(D, 0, F), Rt(t.values, P, T), n.value = M, f();
  }
  const k = {
    fields: n,
    remove: p,
    push: v,
    swap: m,
    insert: g,
    update: C,
    replace: w,
    prepend: S,
    move: $
  };
  return t.fieldArrays.push(Object.assign({ path: e, reset: u }, k)), ar(() => {
    const B = t.fieldArrays.findIndex((D) => pe(D.path) === pe(e));
    B >= 0 && t.fieldArrays.splice(B, 1);
  }), me(i, (B) => {
    const D = n.value.map((P) => P.value);
    Tt(B, D) || u();
  }), k;
}
const Nz = /* @__PURE__ */ b({
  name: "FieldArray",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const { push: n, remove: a, swap: r, insert: o, replace: s, update: i, prepend: u, move: d, fields: c } = Fz(() => e.name);
    function f() {
      return {
        fields: c.value,
        push: n,
        remove: a,
        swap: r,
        insert: o,
        update: i,
        replace: s,
        prepend: u,
        move: d
      };
    }
    return t.expose({
      push: n,
      remove: a,
      swap: r,
      insert: o,
      update: i,
      replace: s,
      prepend: u,
      move: d
    }), () => lu(void 0, t, f);
  }
}), WU = Nz, Lz = /* @__PURE__ */ b({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const n = wn(ks, void 0), a = q(() => n?.errors.value[e.name]);
    function r() {
      return {
        message: a.value
      };
    }
    return () => {
      if (!a.value)
        return;
      const o = e.as ? kt(e.as) : e.as, s = lu(o, t, r), i = Object.assign({ role: "alert" }, t.attrs);
      return !o && (Array.isArray(s) || !s) && s?.length ? s : (Array.isArray(s) || !s) && !s?.length ? en(o || "span", i, a.value) : en(o, i, s);
    };
  }
}), zz = Lz, J_ = /* @__PURE__ */ Symbol();
function iu() {
  const e = wn(L_), t = wn(J_);
  if (!e) throw new Error("useFormField should be used within <FormField>");
  const { name: n, errorMessage: a, meta: r } = e, o = t, s = {
    valid: q(() => r.valid),
    isDirty: q(() => r.dirty),
    isTouched: q(() => r.touched),
    error: a
  };
  return {
    id: o,
    name: n,
    formItemId: `${o}-form-item`,
    formDescriptionId: `${o}-form-item-description`,
    formMessageId: `${o}-form-item-message`,
    ...s
  };
}
const GU = /* @__PURE__ */ b({
  __name: "FormControl",
  setup(e) {
    const { error: t, formItemId: n, formDescriptionId: a, formMessageId: r } = iu();
    return (o, s) => (h(), x(l($l), {
      id: l(n),
      "aria-describedby": l(t) ? `${l(a)} ${l(r)}` : `${l(a)}`,
      "aria-invalid": !!l(t)
    }, {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "aria-describedby", "aria-invalid"]));
  }
}), Hz = ["id"], KU = /* @__PURE__ */ b({
  __name: "FormDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { formDescriptionId: n } = iu();
    return (a, r) => (h(), W("p", {
      id: l(n),
      class: ae(l(R)("text-sm text-muted-foreground", t.class))
    }, [
      _(a.$slots, "default")
    ], 10, Hz));
  }
}), YU = /* @__PURE__ */ b({
  __name: "FormItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Ge();
    return Kn(J_, n), (a, r) => (h(), W("div", {
      class: ae(l(R)("space-y-2", t.class))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), XU = /* @__PURE__ */ b({
  __name: "FormLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, { error: n, formItemId: a } = iu();
    return (r, o) => (h(), x(l(N_), {
      class: ae(l(R)(l(n) && "text-destructive", t.class)),
      for: l(a)
    }, {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "for"]));
  }
}), JU = /* @__PURE__ */ b({
  __name: "FormMessage",
  setup(e) {
    const { name: t, formMessageId: n } = iu();
    return (a, r) => (h(), x(l(zz), {
      id: l(n),
      as: "p",
      name: pe(l(t)),
      class: "text-[0.8rem] font-medium text-destructive"
    }, null, 8, ["id", "name"]));
  }
}), ZU = /* @__PURE__ */ b({
  __name: "HoverCard",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    openDelay: {},
    closeDelay: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(TP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), QU = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(NP), null, {
      default: y(() => [
        N(l(VP), A(l(a), {
          class: l(R)(
            "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), e9 = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(zP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Z_ = /* @__PURE__ */ b({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ni(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => tc((h(), W("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null),
      "data-slot": "input",
      class: ae(
        l(R)(
          "h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30",
          "focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50",
          "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
          n.class
        )
      )
    }, null, 2)), [
      [Qm, l(r)]
    ]);
  }
}), t9 = /* @__PURE__ */ b({
  __name: "InputGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "input-group",
      role: "group",
      class: ae(
        l(R)(
          "group/input-group relative flex w-full items-center rounded-md border border-input outline-none dark:bg-input/30",
          "h-9 min-w-0 has-[>textarea]:h-auto",
          // Variants based on alignment.
          "has-[>[data-align=inline-start]]:[&>input]:pl-2",
          "has-[>[data-align=inline-end]]:[&>input]:pr-2",
          "has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3",
          "has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3",
          // Focus state.
          "has-[[data-slot=input-group-control]:focus-visible]:ring-1 has-[[data-slot=input-group-control]:focus-visible]:ring-ring",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Uz = ["data-align"], n9 = /* @__PURE__ */ b({
  __name: "InputGroupAddon",
  props: {
    align: { default: "inline-start" },
    class: {}
  },
  setup(e) {
    const t = e;
    function n(a) {
      const r = a.currentTarget, o = a.target;
      o && o.closest("button") || r && r?.parentElement && r.parentElement?.querySelector("input")?.focus();
    }
    return (a, r) => (h(), W("div", {
      role: "group",
      "data-slot": "input-group-addon",
      "data-align": t.align,
      class: ae(l(R)(l(Wz)({ align: t.align }), t.class)),
      onClick: n
    }, [
      _(a.$slots, "default")
    ], 10, Uz));
  }
}), a9 = /* @__PURE__ */ b({
  __name: "InputGroupButton",
  props: {
    variant: { default: "ghost" },
    size: { default: "xs" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(gs), {
      "data-size": t.size,
      variant: t.variant,
      class: ae(l(R)(l(Gz)({ size: t.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-size", "variant", "class"]));
  }
}), r9 = /* @__PURE__ */ b({
  __name: "InputGroupInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Z_), {
      "data-slot": "input-group-control",
      class: ae(
        l(R)(
          "flex-1 rounded-none border-0 bg-transparent ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), o9 = /* @__PURE__ */ b({
  __name: "InputGroupText",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(
        l(R)(
          "flex items-center gap-2 text-sm text-muted-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), jz = /* @__PURE__ */ b({
  __name: "Textarea",
  props: {
    class: {},
    defaultValue: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ni(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => tc((h(), W("textarea", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null),
      class: ae(
        l(R)(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          n.class
        )
      )
    }, null, 2)), [
      [Qm, l(r)]
    ]);
  }
}), s9 = /* @__PURE__ */ b({
  __name: "InputGroupTextarea",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(jz), {
      "data-slot": "input-group-control",
      class: ae(
        l(R)(
          "flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), Wz = an(
  "flex h-auto cursor-text select-none items-center justify-center gap-2 py-1.5 text-sm font-medium text-muted-foreground group-data-[disabled=true]/input-group:opacity-50 [&>kbd]:rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-4",
  {
    variants: {
      align: {
        "inline-start": "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
        "inline-end": "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
        "block-start": "[.border-b]:pb-3 order-first w-full justify-start px-3 pt-3 group-has-[>input]/input-group:pt-2.5",
        "block-end": "[.border-t]:pt-3 order-last w-full justify-start px-3 pb-3 group-has-[>input]/input-group:pb-2.5"
      }
    },
    defaultVariants: {
      align: "inline-start"
    }
  }
), Gz = an("flex items-center gap-2 text-sm shadow-none", {
  variants: {
    size: {
      xs: "h-6 gap-1 rounded-[calc(var(--radius)-5px)] px-2 has-[>svg]:px-2 [&>svg:not([class*='size-'])]:size-3.5",
      sm: "h-8 gap-1.5 rounded-md px-2.5 has-[>svg]:px-2.5",
      "icon-xs": "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
      "icon-sm": "size-8 p-0 has-[>svg]:p-0"
    }
  },
  defaultVariants: {
    size: "xs"
  }
});
function Kz(e) {
  return Qo() ? (ec(e), !0) : !1;
}
function Yz(e) {
  if (!mt(e))
    return jt(e);
  const t = new Proxy({}, {
    get(n, a, r) {
      return l(Reflect.get(e.value, a, r));
    },
    set(n, a, r) {
      return mt(e.value[a]) && !mt(r) ? e.value[a].value = r : e.value[a] = r, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return jt(t);
}
function Xz(e) {
  return Yz(q(e));
}
function Jz(e, ...t) {
  const n = t.flat(), a = n[0];
  return Xz(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(pe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
const Q_ = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Zz = Object.prototype.toString, Qz = (e) => Zz.call(e) === "[object Object]", e8 = () => {
};
function Qu(e) {
  return Array.isArray(e) ? e : [e];
}
function t8(...e) {
  if (e.length !== 1)
    return Hn(...e);
  const t = e[0];
  return typeof t == "function" ? nr(ui(() => ({ get: t, set: e8 }))) : O(t);
}
function n8(e, t, n) {
  return me(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
const e0 = Q_ ? window : void 0, La = Q_ ? window.document : void 0;
function a8(e) {
  var t;
  const n = pe(e);
  return (t = n?.$el) != null ? t : n;
}
function r8(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), r = q(() => {
    const i = Qu(pe(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), o = n8(
    () => {
      var i, u;
      return [
        (u = (i = r.value) == null ? void 0 : i.map((d) => a8(d))) != null ? u : [e0].filter((d) => d != null),
        Qu(pe(r.value ? e[1] : e[0])),
        Qu(l(r.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        pe(r.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !i?.length || !u?.length || !d?.length)
        return;
      const f = Qz(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return Kz(n), s;
}
function o8(e, t) {
  const n = ht(t);
  return me(
    t8(e),
    (a, r) => {
      n.value = r;
    },
    { flush: "sync" }
  ), nr(n);
}
const s8 = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`, l8 = b({
  props: { fallback: {
    type: String,
    required: !0
  } },
  setup(e) {
    return () => en("noscript", { innerHTML: `<style>${e.fallback}</style>` });
  }
}), t0 = /* @__PURE__ */ Symbol("vue-otp-context");
function i8(e) {
  return [
    setTimeout(e, 0),
    setTimeout(e, 10),
    setTimeout(e, 50)
  ];
}
const u8 = 18, n0 = 40, d8 = `${n0}px`, c8 = [
  "[data-lastpass-icon-root]",
  "com-1password-button",
  "[data-dashlanecreated]",
  '[style$="2147483647 !important;"]'
].join(",");
function f8({ containerRef: e, inputRef: t, pushPasswordManagerStrategy: n, isFocused: a }) {
  const r = O({
    done: !1,
    refocused: !1
  }), o = O(!1), s = O(!1), i = O(!1), u = q(() => n === "none" ? !1 : (n === "increase-width" || n === "experimental-no-flickering") && o.value && s.value), d = () => {
    const p = e.value, v = t.value;
    if (!p || !v || i.value || n === "none") return;
    const m = p, g = m.getBoundingClientRect().left + m.offsetWidth, w = m.getBoundingClientRect().top + m.offsetHeight / 2, C = g - u8, S = w;
    if (!(document.querySelectorAll(c8).length === 0 && document.elementFromPoint(C, S) === p) && (o.value = !0, i.value = !0, !r.value.refocused && document.activeElement === v)) {
      const $ = [v.selectionStart, v.selectionEnd];
      v.blur(), v.focus(), v.setSelectionRange($[0], $[1]), r.value.refocused = !0;
    }
  }, c = () => {
    const p = e.value;
    !p || n === "none" || (s.value = window.innerWidth - p.getBoundingClientRect().right >= n0);
  };
  let f;
  return Ce(() => {
    c(), f = setInterval(c, 1e3);
  }), nt(() => {
    clearInterval(f);
  }), me([a, t], (p, v, m) => {
    const [g, w] = p, C = g || document.activeElement === w;
    if (n === "none" || !C) return;
    const S = setTimeout(d, 0), $ = setTimeout(d, 2e3), k = setTimeout(d, 5e3), B = setTimeout(() => {
      i.value = !0;
    }, 6e3);
    m(() => {
      clearTimeout(S), clearTimeout($), clearTimeout(k), clearTimeout(B);
    });
  }), {
    hasPWMBadge: o,
    willPushPWMBadge: u,
    PWM_BADGE_SPACE_WIDTH: d8
  };
}
const p8 = { style: {
  position: "absolute",
  inset: "0",
  "pointer-events": "none"
} }, v8 = [
  "value",
  "data-input-otp-placeholder-shown",
  "data-input-otp-mss",
  "data-input-otp-mse",
  "aria-placeholder",
  "pattern"
], m8 = /* @__PURE__ */ b({
  name: "OTPInput",
  inheritAttrs: !1,
  __name: "OTPInput",
  props: /* @__PURE__ */ rp({
    maxlength: {},
    textAlign: { default: "left" },
    inputmode: { default: "numeric" },
    containerClass: {},
    pushPasswordManagerStrategy: { default: "increase-width" },
    noScriptCssFallback: { default: s8 },
    defaultValue: { default: "" },
    pasteTransformer: {},
    accept: {},
    alt: {},
    autocomplete: { default: "one-time-code" },
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [
      Boolean,
      Array,
      Set
    ] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {}
  }, {
    modelValue: { default(e) {
      return e.defaultValue;
    } },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ rp([
    "complete",
    "change",
    "select",
    "input",
    "focus",
    "blur",
    "mouseover",
    "mouseleave",
    "paste"
  ], ["update:modelValue"]),
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, [o] = g0(e, "modelValue"), s = o8(o), i = q(() => a.pattern ? typeof a.pattern == "string" ? new RegExp(a.pattern) : a.pattern : null), u = ht(!1), d = ht(!1), c = ht(null), f = ht(null), p = ht(null), v = ht(null), m = e0?.CSS?.supports?.("-webkit-touch-callout", "none");
    let g = { prev: [
      p.value?.selectionStart,
      p.value?.selectionEnd,
      p.value?.selectionDirection
    ] };
    function w(M, I) {
      try {
        M.insertRule(I);
      } catch {
        console.error("input-otp could not insert CSS rule:", I);
      }
    }
    Ce(() => {
      const M = p.value, I = v.value;
      if (!M || !I) return;
      g.prev = [
        M.selectionStart,
        M.selectionEnd,
        M.selectionDirection ?? "none"
      ];
      const F = r8(La, "selectionchange", J, { capture: !0 });
      function J() {
        if (!M) return;
        if (La?.activeElement !== M) {
          c.value = null, f.value = null;
          return;
        }
        const G = M.selectionStart, H = M.selectionEnd, U = M.selectionDirection, se = M.maxLength, ee = M.value, de = g.prev;
        let fe = -1, _e = -1, ye;
        if (ee.length !== 0 && G !== null && H !== null) {
          const te = G === H, z = G === ee.length && ee.length < se;
          if (te && !z) {
            const re = G;
            if (re === 0)
              fe = 0, _e = 1, ye = "forward";
            else if (re === se)
              fe = re - 1, _e = re, ye = "backward";
            else if (se > 1 && ee.length > 1) {
              let ie = 0;
              if (de[0] !== null && de[1] !== null) {
                ye = re < de[1] ? "backward" : "forward";
                const L = de[0] === de[1] && de[0] < se;
                ye === "backward" && !L && (ie = -1);
              }
              fe = ie + re, _e = ie + re + 1;
            }
          }
          fe !== -1 && _e !== -1 && fe !== _e && M.setSelectionRange(fe, _e, ye);
        }
        const Te = fe !== -1 ? fe : G, ce = _e !== -1 ? _e : H, V = ye ?? U;
        c.value = Te, f.value = ce, g.prev = [
          Te,
          ce,
          V
        ];
      }
      if (J(), La?.activeElement === M && (d.value = !0), !La?.getElementById("input-otp-style")) {
        const G = La?.createElement("style");
        if (G.id = "input-otp-style", La?.head.appendChild(G), G.sheet) {
          const H = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
          w(G.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), w(G.sheet, `[data-input-otp]:autofill { ${H} }`), w(G.sheet, `[data-input-otp]:-webkit-autofill { ${H} }`), w(G.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), w(G.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
        }
      }
      const ne = () => {
        I && I.style.setProperty("--root-height", `${M.clientHeight}px`);
      };
      ne();
      const Q = new ResizeObserver(ne);
      Q.observe(M), nt(() => {
        F(), Q.disconnect();
      });
    }), me([o], () => {
      i8(() => {
        if (!p.value) return;
        p.value?.dispatchEvent(new Event("input"));
        const M = p.value?.selectionStart, I = p.value?.selectionEnd, F = p.value?.selectionDirection;
        M !== null && I !== null && (c.value = M ?? null, f.value = I ?? null, g.prev = [
          M,
          I,
          F
        ]);
      });
    }, { immediate: !0 }), Ae(() => {
      s.value !== void 0 && o.value !== s.value && s.value.length < a.maxlength && o.value.length === a.maxlength && r("complete", o.value);
    });
    const C = f8({
      containerRef: v,
      inputRef: p,
      pushPasswordManagerStrategy: a.pushPasswordManagerStrategy,
      isFocused: d
    });
    function S(M) {
      if (M.inputType === "insertText" && M.data !== null) {
        const I = M.currentTarget, F = I.selectionStart ?? 0, J = I.selectionEnd ?? 0, ne = I.value, Q = (F !== J ? ne.slice(0, F) + M.data + ne.slice(J) : ne.slice(0, F) + M.data + ne.slice(F)).slice(0, a.maxlength);
        Q.length > 0 && i.value && !i.value.test(Q) && M.preventDefault();
      }
    }
    function $(M) {
      const I = M.currentTarget.value.slice(0, a.maxlength);
      if (I.length > 0 && i.value && !i.value.test(I)) {
        M.preventDefault();
        return;
      }
      typeof s.value == "string" && I.length < s.value.length && La?.dispatchEvent(new Event("selectionchange")), o.value = I, r("input", I);
    }
    function k() {
      const M = p.value;
      if (M) {
        const I = Math.min(M.value.length, a.maxlength - 1), F = M.value.length;
        M.setSelectionRange(I, F), c.value = I, f.value = F;
      }
      d.value = !0;
    }
    function B(M) {
      const I = p.value;
      if (!I || !a.pasteTransformer && (!m || !M.clipboardData || !I)) return;
      const F = M?.clipboardData?.getData("text/plain"), J = a?.pasteTransformer ? a.pasteTransformer(F) : F;
      M.preventDefault();
      const ne = p.value?.selectionStart, Q = p.value?.selectionEnd, G = (ne !== Q ? o.value.slice(0, ne) + J + o.value.slice(Q) : o.value.slice(0, ne) + J + o.value.slice(ne)).slice(0, a.maxlength);
      if (G.length > 0 && i.value && !i.value.test(G)) return;
      o.value = G, r("input", G);
      const H = Math.min(G.length, a.maxlength - 1), U = G.length;
      I?.setSelectionRange(H, U), c.value = H, f.value = U;
    }
    const D = he(Jz(a, "containerClass", "value", "pattern", "defaultValue", "pushPasswordManagerStrategy", "noScriptCssFallback", "modelValue")), P = q(() => ({
      position: "relative",
      cursor: a.disabled ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })), E = q(() => ({
      position: "absolute",
      inset: 0,
      width: C.willPushPWMBadge.value ? `calc(100% + ${C.PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: C.willPushPWMBadge.value ? `inset(0 ${C.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: a.textAlign,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })), T = q(() => ({
      slots: Array.from({ length: Number(a.maxlength) }).map((M, I) => {
        const F = d.value && c.value !== null && f.value !== null && (c.value === f.value && I === c.value || I >= c.value && I < f.value), J = o.value[I] !== void 0 ? o.value[I] : null;
        return {
          char: J,
          placeholderChar: J ?? a?.placeholder?.[I] ?? null,
          isActive: F,
          hasFakeCaret: F && J === null
        };
      }),
      isFocused: d.value,
      isHovering: !a.disabled && u.value
    }));
    return Kn(t0, T), t(Object.defineProperty({}, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => p
    })), (M, I) => (h(), W(Ke, null, [e.noScriptCssFallback !== null ? (h(), x(l(l8), {
      key: 0,
      fallback: e.noScriptCssFallback
    }, null, 8, ["fallback"])) : qe("v-if", !0), we("div", {
      ref_key: "containerRef",
      ref: v,
      "data-input-otp-container": "",
      style: dt(P.value),
      class: ae(e.containerClass)
    }, [_(M.$slots, "default", {
      slots: T.value.slots,
      isFocused: d.value,
      isHovering: !e.disabled && u.value
    }), we("div", p8, [we("input", A({
      ref_key: "inputRef",
      ref: p,
      value: l(o),
      "data-input-otp": "",
      "data-input-otp-placeholder-shown": l(o).length === 0 || void 0,
      "data-input-otp-mss": c.value,
      "data-input-otp-mse": f.value,
      "aria-placeholder": e.placeholder,
      style: E.value,
      pattern: i.value?.source
    }, {
      ...M.$attrs,
      ...l(D)
    }, {
      onBeforeinput: S,
      onMouseover: I[0] || (I[0] = (F) => {
        u.value = !0, r("mouseover", F);
      }),
      onMouseleave: I[1] || (I[1] = (F) => {
        u.value = !1, r("mouseleave", F);
      }),
      onPaste: I[2] || (I[2] = (F) => {
        B(F), r("paste", F);
      }),
      onInput: $,
      onFocus: I[3] || (I[3] = (F) => {
        k(), r("focus", F);
      }),
      onBlur: I[4] || (I[4] = (F) => {
        d.value = !1, r("blur", F);
      })
    }), null, 16, v8)])], 6)], 64));
  }
});
var h8 = m8;
function g8() {
  return wn(t0);
}
const l9 = /* @__PURE__ */ b({
  __name: "InputOTP",
  props: {
    maxlength: {},
    textAlign: {},
    inputmode: {},
    containerClass: {},
    pushPasswordManagerStrategy: {},
    noScriptCssFallback: {},
    defaultValue: {},
    pasteTransformer: { type: Function },
    accept: {},
    alt: {},
    autocomplete: {},
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [Boolean, Array, Set] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {},
    class: {}
  },
  emits: ["complete", "change", "select", "input", "focus", "blur", "mouseover", "mouseleave", "paste"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(h8), A(l(o), {
      "container-class": l(R)("flex items-center gap-2 has-disabled:opacity-50", n.class),
      "data-slot": "input-otp",
      class: "disabled:cursor-not-allowed"
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["container-class"]));
  }
}), i9 = /* @__PURE__ */ b({
  __name: "InputOTPGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), W("div", A({ "data-slot": "input-otp-group" }, l(a), {
      class: l(R)("flex items-center", t.class)
    }), [
      _(r.$slots, "default")
    ], 16));
  }
}), u9 = /* @__PURE__ */ b({
  __name: "InputOTPSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), W("div", A({
      "data-slot": "input-otp-separator",
      role: "separator"
    }, l(n)), [
      _(a.$slots, "default", {}, () => [
        N(l(cf))
      ])
    ], 16));
  }
}), y8 = ["data-active"], b8 = {
  key: 0,
  class: "pointer-events-none absolute inset-0 flex items-center justify-center"
}, d9 = /* @__PURE__ */ b({
  __name: "InputOTPSlot",
  props: {
    index: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), r = g8(), o = q(() => r?.value.slots[t.index]);
    return (s, i) => (h(), W("div", A(l(a), {
      "data-slot": "input-otp-slot",
      "data-active": o.value?.isActive,
      class: l(R)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md aria-invalid:border-destructive data-[active=true]:z-10 data-[active=true]:border-ring data-[active=true]:ring-[3px] data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:border-destructive data-[active=true]:aria-invalid:ring-destructive/20 dark:bg-input/30 dark:data-[active=true]:aria-invalid:ring-destructive/40",
        t.class
      )
    }), [
      Re(Ne(o.value?.char) + " ", 1),
      o.value?.hasFakeCaret ? (h(), W("div", b8, [...i[0] || (i[0] = [
        we("div", { class: "h-4 w-px animate-caret-blink bg-foreground duration-1000" }, null, -1)
      ])])) : qe("", !0)
    ], 16, y8));
  }
}), c9 = /* @__PURE__ */ b({
  __name: "Item",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" },
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-slot": "item",
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(R)(l(w8)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), f9 = /* @__PURE__ */ b({
  __name: "ItemActions",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-actions",
      class: ae(l(R)("flex items-center gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), p9 = /* @__PURE__ */ b({
  __name: "ItemContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-content",
      class: ae(l(R)("flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), v9 = /* @__PURE__ */ b({
  __name: "ItemDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      "data-slot": "item-description",
      class: ae(
        l(R)(
          "line-clamp-2 text-sm leading-normal font-normal text-balance text-muted-foreground",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), m9 = /* @__PURE__ */ b({
  __name: "ItemFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-footer",
      class: ae(l(R)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), h9 = /* @__PURE__ */ b({
  __name: "ItemGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      role: "list",
      "data-slot": "item-group",
      class: ae(l(R)("group/item-group flex flex-col", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), g9 = /* @__PURE__ */ b({
  __name: "ItemHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-header",
      class: ae(l(R)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), _8 = ["data-variant"], y9 = /* @__PURE__ */ b({
  __name: "ItemMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-media",
      "data-variant": t.variant,
      class: ae(l(R)(l(x8)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, _8));
  }
}), b9 = /* @__PURE__ */ b({
  __name: "ItemSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Hi), {
      "data-slot": "item-separator",
      orientation: "horizontal",
      class: ae(l(R)("my-0", t.class))
    }, null, 8, ["class"]));
  }
}), _9 = /* @__PURE__ */ b({
  __name: "ItemTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-title",
      class: ae(l(R)("flex w-fit items-center gap-2 text-sm leading-snug font-medium", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), w8 = an(
  "group/item [a]:hover:bg-accent/50 [a]:transition-colors flex flex-wrap items-center rounded-md border border-transparent text-sm outline-none transition-colors duration-100 focus-visible:border-ring focus-visible:ring-1 focus-visible:ring-ring",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border-border",
        muted: "bg-muted/50"
      },
      size: {
        default: "gap-4 p-4 ",
        sm: "gap-2.5 px-4 py-3"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), x8 = an(
  "flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:translate-y-0.5 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "size-8 rounded-sm border bg-muted [&_svg:not([class*='size-'])]:size-4",
        image: "size-10 overflow-hidden rounded-sm [&_img]:size-full [&_img]:object-cover"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), w9 = /* @__PURE__ */ b({
  __name: "Kbd",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("kbd", {
      class: ae(
        l(R)(
          "pointer-events-none inline-flex h-5 w-fit min-w-5 items-center justify-center gap-1 rounded-sm bg-muted px-1 font-sans text-xs font-medium text-muted-foreground select-none",
          "[&_svg:not([class*='size-'])]:size-3",
          "[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), x9 = /* @__PURE__ */ b({
  __name: "KbdGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("kbd", {
      "data-slot": "kbd-group",
      class: ae(l(R)("inline-flex items-center gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), C9 = /* @__PURE__ */ b({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(YP), A(l(o), {
      class: l(R)(
        "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), C8 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, S9 = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(WP), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", C8, [
          N(l(Bg), null, {
            default: y(() => [
              N(l(no), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $9 = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    sideFlip: { type: Boolean },
    align: { default: "start" },
    alignOffset: { default: -4 },
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(kg), null, {
      default: y(() => [
        N(l(eD), A(l(a), {
          class: l(R)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), B9 = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(nD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), k9 = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(rD), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), P9 = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(lD), {
      class: ae(l(R)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), D9 = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(ZP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), M9 = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(dD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), S8 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, q9 = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(fD), A(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", S8, [
          N(l(Bg), null, {
            default: y(() => [
              N(l(uf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), E9 = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(vD), A({
      class: l(R)("-mx-1 my-1 h-px bg-muted", t.class)
    }, l(a)), null, 16, ["class"]));
  }
}), T9 = /* @__PURE__ */ b({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), A9 = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(hD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), O9 = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(kg), null, {
      default: y(() => [
        N(l(yD), A(l(o), {
          class: l(R)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), I9 = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(_D), A(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(Va), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), R9 = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(xD), A(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-3 py-1 text-sm font-medium outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $8 = { class: "absolute top-full left-0 flex justify-center" }, B8 = /* @__PURE__ */ b({
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    align: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), W("div", $8, [
      N(l(jD), A(l(a), {
        class: l(R)(
          "origin-top-center relative left-[var(--reka-navigation-menu-viewport-left)] mt-1.5 h-[--reka-navigation-menu-viewport-height] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:zoom-in-90 md:w-[--reka-navigation-menu-viewport-width]",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), V9 = /* @__PURE__ */ b({
  __name: "NavigationMenu",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    orientation: {},
    delayDuration: {},
    skipDelayDuration: {},
    disableClickTrigger: { type: Boolean },
    disableHoverTrigger: { type: Boolean },
    disablePointerLeaveClose: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l($D), A(l(o), {
      class: l(R)("relative z-10 flex max-w-max flex-1 items-center justify-center", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default"),
        N(B8)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), F9 = /* @__PURE__ */ b({
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(AD), A(l(o), {
      class: l(R)(
        "top-0 left-0 w-full data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 data-[motion^=from-]:animate-in data-[motion^=from-]:fade-in data-[motion^=to-]:animate-out data-[motion^=to-]:fade-out md:absolute md:w-auto",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), N9 = /* @__PURE__ */ b({
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(ID), A(l(a), {
      class: l(R)(
        "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:animate-in data-[state=visible]:fade-in",
        t.class
      )
    }), {
      default: y(() => [...o[0] || (o[0] = [
        we("div", { class: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" }, null, -1)
      ])]),
      _: 1
    }, 16, ["class"]));
  }
}), L9 = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(MD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), z9 = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(VD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), H9 = /* @__PURE__ */ b({
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(ND), A(l(a), {
      class: l(R)("group flex flex-1 list-none items-center justify-center gap-x-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), U9 = /* @__PURE__ */ b({
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(HD), A(l(a), {
      class: l(R)(l(k8)(), "group", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(Li), {
          class: "relative top-px ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180",
          "aria-hidden": "true"
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), k8 = an(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
), j9 = /* @__PURE__ */ b({
  __name: "NumberField",
  props: {
    defaultValue: {},
    modelValue: {},
    min: {},
    max: {},
    step: {},
    stepSnapping: { type: Boolean },
    formatOptions: {},
    locale: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    disableWheelChange: { type: Boolean },
    invertWheelChange: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(nM), A(l(o), {
      class: l(R)("grid gap-1.5", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), W9 = /* @__PURE__ */ b({
  __name: "NumberFieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(
        l(R)(
          "relative [&>[data-slot=input]]:has-[[data-slot=decrement]]:pl-5 [&>[data-slot=input]]:has-[[data-slot=increment]]:pr-5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), G9 = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(rM), A({ "data-slot": "decrement" }, l(a), {
      class: l(R)(
        "absolute top-1/2 left-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(cf), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), K9 = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(sM), A({ "data-slot": "increment" }, l(a), {
      class: l(R)(
        "absolute top-1/2 right-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(BO), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Y9 = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(iM), {
      "data-slot": "input",
      class: ae(
        l(R)(
          "flex h-9 w-full rounded-md border border-input bg-transparent py-1 text-center text-sm shadow-sm transition-colors placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), X9 = /* @__PURE__ */ b({
  __name: "Pagination",
  props: {
    page: {},
    defaultPage: {},
    itemsPerPage: {},
    total: {},
    siblingCount: {},
    disabled: { type: Boolean },
    showEdges: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(pM), A({ "data-slot": "pagination" }, l(o), {
      class: l(R)("mx-auto flex w-full justify-center", n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), J9 = /* @__PURE__ */ b({
  __name: "PaginationContent",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(wM), A({ "data-slot": "pagination-content" }, l(n), {
      class: l(R)("flex flex-row items-center gap-1", t.class)
    }), {
      default: y((o) => [
        _(a.$slots, "default", oe(le(o)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Z9 = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(dM), A({ "data-slot": "pagination-ellipsis" }, l(n), {
      class: l(R)("flex size-9 items-center justify-center", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default", {}, () => [
          N(l(Gy), { class: "size-4" }),
          r[0] || (r[0] = we("span", { class: "sr-only" }, "More pages", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Q9 = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(mM), A({
      "data-slot": "pagination-first",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi)),
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "First", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ej = /* @__PURE__ */ b({
  __name: "PaginationItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {},
    size: { default: "icon" },
    class: {},
    isActive: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size", "isActive");
    return (a, r) => (h(), x(l(CM), A({ "data-slot": "pagination-item" }, l(n), {
      class: l(R)(
        l(Kt)({
          variant: e.isActive ? "outline" : "ghost",
          size: e.size
        }),
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), tj = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(gM), A({
      "data-slot": "pagination-last",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Last", -1)),
          N(l(Va))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), nj = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l($M), A({
      "data-slot": "pagination-next",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Next", -1)),
          N(l(Va))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), aj = /* @__PURE__ */ b({
  __name: "PaginationPrevious",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(kM), A({
      "data-slot": "pagination-previous",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi)),
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Previous", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rj = /* @__PURE__ */ b({
  __name: "PinInput",
  props: {
    modelValue: { default: () => [] },
    defaultValue: {},
    placeholder: {},
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: {},
    dir: {},
    disabled: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(qM), A(l(o), {
      class: l(R)("flex items-center gap-2", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), oj = /* @__PURE__ */ b({
  __name: "PinInputGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(X), A(l(a), {
      class: l(R)("flex items-center", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sj = /* @__PURE__ */ b({
  __name: "PinInputSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(X), oe(le(l(n))), {
      default: y(() => [
        _(a.$slots, "default", {}, () => [
          N(l(cf), { class: "w-2" })
        ])
      ]),
      _: 3
    }, 16));
  }
}), lj = /* @__PURE__ */ b({
  __name: "PinInputSlot",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(TM), A(l(a), {
      class: l(R)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-center text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md focus:relative focus:z-10 focus:ring-2 focus:ring-ring focus:outline-none",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), ij = /* @__PURE__ */ b({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(vk), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), uj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(Sk), null, {
      default: y(() => [
        N(l(xk), A({ ...l(o), ...s.$attrs }, {
          class: l(R)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), dj = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Bk), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cj = /* @__PURE__ */ b({
  __name: "Progress",
  props: {
    modelValue: { default: 0 },
    max: {},
    getValueLabel: {},
    getValueText: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(FM), A(l(n), {
      class: l(R)("relative h-2 w-full overflow-hidden rounded-full bg-primary/20", t.class)
    }), {
      default: y(() => [
        N(l(LM), {
          class: "h-full w-full flex-1 bg-primary transition-all",
          style: dt(`transform: translateX(-${100 - (t.modelValue ?? 0)}%);`)
        }, null, 8, ["style"])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), fj = /* @__PURE__ */ b({
  __name: "RadioGroup",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(YM), A({
      class: l(R)("grid gap-2", n.class)
    }, l(o)), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pj = /* @__PURE__ */ b({
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(QM), A(l(a), {
      class: l(R)(
        "peer aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        N(l(tq), { class: "flex items-center justify-center" }, {
          default: y(() => [
            N(l(no), { class: "h-3.5 w-3.5 text-primary" })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), P8 = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, vj = /* @__PURE__ */ b({
  __name: "RangeCalendar",
  props: {
    defaultPlaceholder: {},
    defaultValue: {},
    modelValue: {},
    placeholder: {},
    allowNonContiguousRanges: { type: Boolean },
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    maximumDays: {},
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    isDateHighlightable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    disableDaysOutsideCurrentView: { type: Boolean },
    fixedDate: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:validModelValue", "update:placeholder", "update:startValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(Ek), A({
      class: l(R)("p-3", n.class)
    }, l(o)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(O8), null, {
          default: y(() => [
            N(l(V8)),
            N(l(I8)),
            N(l(R8))
          ]),
          _: 1
        }),
        we("div", P8, [
          (h(!0), W(Ke, null, Nt(u, (c) => (h(), x(l(q8), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(T8), null, {
                default: y(() => [
                  N(l(jm), null, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Nt(d, (f) => (h(), x(l(A8), { key: f }, {
                        default: y(() => [
                          Re(Ne(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(E8), null, {
                default: y(() => [
                  (h(!0), W(Ke, null, Nt(c.rows, (f, p) => (h(), x(l(jm), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Nt(f, (v) => (h(), x(l(D8), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(M8), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), D8 = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Ak), A({
      class: l(R)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:bg-accent first:[&:has([data-selected])]:rounded-l-md last:[&:has([data-selected])]:rounded-r-md [&:has([data-selected][data-outside-view])]:bg-accent/50 [&:has([data-selected][data-selection-end])]:rounded-r-md [&:has([data-selected][data-selection-start])]:rounded-l-md",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), M8 = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Ik), A({
      class: l(R)(
        l(Kt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal data-[selected]:opacity-100",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selection Start
        "data-[selection-start]:bg-primary data-[selection-start]:text-primary-foreground data-[selection-start]:hover:bg-primary data-[selection-start]:hover:text-primary-foreground data-[selection-start]:focus:bg-primary data-[selection-start]:focus:text-primary-foreground",
        // Selection End
        "data-[selection-end]:bg-primary data-[selection-end]:text-primary-foreground data-[selection-end]:hover:bg-primary data-[selection-end]:hover:text-primary-foreground data-[selection-end]:focus:bg-primary data-[selection-end]:focus:text-primary-foreground",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), q8 = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Vk), A({
      class: l(R)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), E8 = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Nk), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), T8 = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(zk), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), jm = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Uk), A({
      class: l(R)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), A8 = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Wk), A({
      class: l(R)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), O8 = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Kk), A({
      class: l(R)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), I8 = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Xk), A({
      class: l(R)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(Ne(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), R8 = /* @__PURE__ */ b({
  __name: "RangeCalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Zk), A({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Va), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), V8 = /* @__PURE__ */ b({
  __name: "RangeCalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(eP), A({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), F8 = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, mj = /* @__PURE__ */ b({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    nonce: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(BT), A(l(o), {
      class: l(R)(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 focus-visible:outline-none [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:translate-x-0 [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]>div]:rotate-90",
        n.class
      )
    }), {
      default: y(() => [
        n.withHandle ? (h(), W("div", F8, [
          N(l(SO), { class: "h-2.5 w-2.5" })
        ])) : qe("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), hj = /* @__PURE__ */ b({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(xT), A(l(o), {
      class: l(R)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), N8 = /* @__PURE__ */ b({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(xq), A(l(n), {
      class: l(R)(
        "flex touch-none transition-colors select-none",
        e.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        e.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        t.class
      )
    }), {
      default: y(() => [
        N(l(kq), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), gj = /* @__PURE__ */ b({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(rq), A(l(n), {
      class: l(R)("relative overflow-hidden", t.class)
    }), {
      default: y(() => [
        N(l(Dq), { class: "h-full w-full rounded-[inherit]" }, {
          default: y(() => [
            _(a.$slots, "default")
          ]),
          _: 3
        }),
        N(N8),
        N(l(iq))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), yj = /* @__PURE__ */ b({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    by: { type: [String, Function] },
    dir: {},
    multiple: { type: Boolean },
    autocomplete: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(Oq), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(fE), null, {
      default: y(() => [
        N(l(Xq), A({ ...l(o), ...s.$attrs }, {
          class: l(R)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            e.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: y(() => [
            N(l(H8)),
            N(l($E), {
              class: ae(
                l(R)(
                  "p-1",
                  e.position === "popper" && "h-[--reka-select-trigger-height] w-full min-w-[--reka-select-trigger-width]"
                )
              )
            }, {
              default: y(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(z8))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), _j = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(eE), A({
      class: l(R)("w-full p-1", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), L8 = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, wj = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(oE), A(l(a), {
      class: l(R)(
        "relative flex w-full cursor-default items-center rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        we("span", L8, [
          N(l(lE), null, {
            default: y(() => [
              N(l(no), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        N(l(zg), null, {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xj = /* @__PURE__ */ b({
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(zg), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Cj = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(dE), {
      class: ae(l(R)("px-2 py-1.5 text-sm font-semibold", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), z8 = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(mE), A(l(a), {
      class: l(R)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Li))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), H8 = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(gE), A(l(a), {
      class: l(R)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(CO))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Sj = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(bE), A(l(n), {
      class: l(R)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), $j = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(wE), A(l(a), {
      class: l(R)(
        "flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-start text-sm whitespace-nowrap shadow-sm ring-offset-background focus:ring-1 focus:ring-ring focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[placeholder]:text-muted-foreground [&>span]:truncate",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(nE), { "as-child": "" }, {
          default: y(() => [
            N(l(Li), { class: "h-4 w-4 shrink-0 opacity-50" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Bj = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(CE), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), U8 = /* @__PURE__ */ b({
  __name: "Sheet",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(mi), A({ "data-slot": "sheet" }, l(r)), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), kj = /* @__PURE__ */ b({
  __name: "SheetClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Aa), A({ "data-slot": "sheet-close" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), j8 = /* @__PURE__ */ b({
  __name: "SheetOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(ds), A({
      "data-slot": "sheet-overlay",
      class: l(R)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), W8 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SheetContent",
  props: {
    class: {},
    side: { default: "right" },
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "side"), o = ve(r, a);
    return (s, i) => (h(), x(l(yi), null, {
      default: y(() => [
        N(j8),
        N(l(us), A({
          "data-slot": "sheet-content",
          class: l(R)(
            "fixed z-50 flex flex-col gap-4 bg-background shadow-lg transition ease-in-out data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:animate-in data-[state=open]:duration-500",
            e.side === "right" && "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
            e.side === "left" && "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
            e.side === "top" && "inset-x-0 top-0 h-auto border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
            e.side === "bottom" && "inset-x-0 bottom-0 h-auto border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
            n.class
          )
        }, { ...s.$attrs, ...l(o) }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(Aa), { class: "absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none data-[state=open]:bg-secondary" }, {
              default: y(() => [
                N(l(ao), { class: "size-4" }),
                i[0] || (i[0] = we("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Pj = /* @__PURE__ */ b({
  __name: "SheetDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(gi), A({
      "data-slot": "sheet-description",
      class: l(R)("text-sm text-muted-foreground", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Dj = /* @__PURE__ */ b({
  __name: "SheetFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "sheet-footer",
      class: ae(l(R)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Mj = /* @__PURE__ */ b({
  __name: "SheetHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "sheet-header",
      class: ae(l(R)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), qj = /* @__PURE__ */ b({
  __name: "SheetTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(bi), A({
      "data-slot": "sheet-title",
      class: l(R)("font-semibold text-foreground", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Ej = /* @__PURE__ */ b({
  __name: "SheetTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(_i), A({ "data-slot": "sheet-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Wm = "sidebar_state", G8 = 3600 * 24 * 7, K8 = "16rem", Y8 = "18rem", X8 = "3rem", J8 = "b", [uu, Z8] = Se("Sidebar"), Q8 = { class: "flex h-full w-full flex-col" }, eH = ["data-state", "data-collapsible", "data-variant", "data-side"], tH = {
  "data-sidebar": "sidebar",
  class: "flex h-full w-full flex-col bg-sidebar text-sidebar-foreground group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
}, Tj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "Sidebar",
  props: {
    side: { default: "left" },
    variant: { default: "sidebar" },
    collapsible: { default: "offcanvas" },
    class: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a, openMobile: r, setOpenMobile: o } = uu();
    return (s, i) => e.collapsible === "none" ? (h(), W("div", A({
      key: 0,
      class: l(R)("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", t.class)
    }, s.$attrs), [
      _(s.$slots, "default")
    ], 16)) : l(n) ? (h(), x(l(U8), A({
      key: 1,
      open: l(r)
    }, s.$attrs, { "onUpdate:open": l(o) }), {
      default: y(() => [
        N(l(W8), {
          "data-sidebar": "sidebar",
          "data-mobile": "true",
          side: e.side,
          class: "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
          style: dt({
            "--sidebar-width": l(Y8)
          })
        }, {
          default: y(() => [
            we("div", Q8, [
              _(s.$slots, "default")
            ])
          ]),
          _: 3
        }, 8, ["side", "style"])
      ]),
      _: 3
    }, 16, ["open", "onUpdate:open"])) : (h(), W("div", {
      key: 2,
      class: "group peer hidden md:block",
      "data-state": l(a),
      "data-collapsible": l(a) === "collapsed" ? e.collapsible : "",
      "data-variant": e.variant,
      "data-side": e.side
    }, [
      we("div", {
        class: ae(
          l(R)(
            "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            e.variant === "floating" || e.variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )
        )
      }, null, 2),
      we("div", A({
        class: l(R)(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          e.side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          e.variant === "floating" || e.variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+_2px)]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          t.class
        )
      }, s.$attrs), [
        we("div", tH, [
          _(s.$slots, "default")
        ])
      ], 16)
    ], 8, eH));
  }
}), Aj = /* @__PURE__ */ b({
  __name: "SidebarContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "content",
      class: ae(
        l(R)(
          "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Oj = /* @__PURE__ */ b({
  __name: "SidebarFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "footer",
      class: ae(l(R)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Ij = /* @__PURE__ */ b({
  __name: "SidebarGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "group",
      class: ae(l(R)("relative flex w-full min-w-0 flex-col p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Rj = /* @__PURE__ */ b({
  __name: "SidebarGroupAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "group-action",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(R)(
          "absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Vj = /* @__PURE__ */ b({
  __name: "SidebarGroupContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "group-content",
      class: ae(l(R)("w-full text-sm", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Fj = /* @__PURE__ */ b({
  __name: "SidebarGroupLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "group-label",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(R)(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear outline-none focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Nj = /* @__PURE__ */ b({
  __name: "SidebarHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "header",
      class: ae(l(R)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Lj = /* @__PURE__ */ b({
  __name: "SidebarInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Z_), {
      "data-sidebar": "input",
      class: ae(
        l(R)(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), zj = /* @__PURE__ */ b({
  __name: "SidebarInset",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("main", {
      class: ae(
        l(R)(
          "relative flex min-h-svh flex-1 flex-col bg-background",
          "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Hj = /* @__PURE__ */ b({
  __name: "SidebarMenu",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("ul", {
      "data-sidebar": "menu",
      class: ae(l(R)("flex w-full min-w-0 flex-col gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Uj = /* @__PURE__ */ b({
  __name: "SidebarMenuAction",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" },
    showOnHover: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "menu-action",
      class: ae(
        l(R)(
          "absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          e.showOnHover && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground data-[state=open]:opacity-100 md:opacity-0",
          t.class
        )
      ),
      as: e.as,
      "as-child": e.asChild
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "as", "as-child"]));
  }
}), jj = /* @__PURE__ */ b({
  __name: "SidebarMenuBadge",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(R)(
          "pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium text-sidebar-foreground tabular-nums select-none",
          "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Gm = /* @__PURE__ */ b({
  __name: "SidebarMenuButtonChild",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({
      "data-sidebar": "menu-button",
      "data-size": e.size,
      "data-active": e.isActive,
      class: l(R)(l(rH)({ variant: e.variant, size: e.size }), t.class),
      as: e.as,
      "as-child": e.asChild
    }, n.$attrs), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-size", "data-active", "class", "as", "as-child"]));
  }
}), Wj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SidebarMenuButton",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    tooltip: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a } = uu(), r = Z(t, "tooltip");
    return (o, s) => e.tooltip ? (h(), x(l(ff), { key: 1 }, {
      default: y(() => [
        N(l(vf), { "as-child": "" }, {
          default: y(() => [
            N(Gm, oe(le({ ...l(r), ...o.$attrs })), {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }),
        N(l(pf), {
          side: "right",
          align: "center",
          hidden: l(a) !== "collapsed" || l(n)
        }, {
          default: y(() => [
            typeof e.tooltip == "string" ? (h(), W(Ke, { key: 0 }, [
              Re(Ne(e.tooltip), 1)
            ], 64)) : (h(), x(kt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        }, 8, ["hidden"])
      ]),
      _: 3
    })) : (h(), x(Gm, oe(A({ key: 0 }, { ...l(r), ...o.$attrs })), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Gj = /* @__PURE__ */ b({
  __name: "SidebarMenuItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("li", {
      "data-sidebar": "menu-item",
      class: ae(l(R)("group/menu-item relative", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Km = /* @__PURE__ */ b({
  __name: "Skeleton",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "skeleton",
      class: ae(l(R)("animate-pulse rounded-md bg-primary/10", t.class))
    }, null, 2));
  }
}), Kj = /* @__PURE__ */ b({
  __name: "SidebarMenuSkeleton",
  props: {
    showIcon: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = q(() => `${Math.floor(Math.random() * 40) + 50}%`);
    return (a, r) => (h(), W("div", {
      "data-sidebar": "menu-skeleton",
      class: ae(l(R)("flex h-8 items-center gap-2 rounded-md px-2", t.class))
    }, [
      e.showIcon ? (h(), x(l(Km), {
        key: 0,
        class: "size-4 rounded-md",
        "data-sidebar": "menu-skeleton-icon"
      })) : qe("", !0),
      N(l(Km), {
        class: "h-4 max-w-[--skeleton-width] flex-1",
        "data-sidebar": "menu-skeleton-text",
        style: dt({ "--skeleton-width": n.value })
      }, null, 8, ["style"])
    ], 2));
  }
}), Yj = /* @__PURE__ */ b({
  __name: "SidebarMenuSub",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("ul", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(R)(
          "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Xj = /* @__PURE__ */ b({
  __name: "SidebarMenuSubButton",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    size: { default: "md" },
    isActive: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "menu-sub-button",
      as: e.as,
      "as-child": e.asChild,
      "data-size": e.size,
      "data-active": e.isActive,
      class: ae(
        l(R)(
          "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground ring-sidebar-ring outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
          "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
          e.size === "sm" && "text-xs",
          e.size === "md" && "text-sm",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-size", "data-active", "class"]));
  }
}), nH = {};
function aH(e, t) {
  return h(), W("li", null, [
    _(e.$slots, "default")
  ]);
}
const Jj = /* @__PURE__ */ cr(nH, [["render", aH]]), Zj = /* @__PURE__ */ b({
  __name: "SidebarProvider",
  props: {
    defaultOpen: { type: Boolean, default: !Fy?.cookie.includes(`${Wm}=false`) },
    open: { type: Boolean, default: void 0 },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ol("(max-width: 768px)"), o = O(!1), s = /* @__PURE__ */ Ni(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, document.cookie = `${Wm}=${s.value}; path=/; max-age=${G8}`;
    }
    function u(f) {
      o.value = f;
    }
    function d() {
      return r.value ? u(!o.value) : i(!s.value);
    }
    qr("keydown", (f) => {
      f.key === J8 && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = q(() => s.value ? "expanded" : "collapsed");
    return Z8({
      state: c,
      open: s,
      setOpen: i,
      isMobile: r,
      openMobile: o,
      setOpenMobile: u,
      toggleSidebar: d
    }), (f, p) => (h(), x(l(of), { "delay-duration": 0 }, {
      default: y(() => [
        we("div", A({
          style: {
            "--sidebar-width": l(K8),
            "--sidebar-width-icon": l(X8)
          },
          class: l(R)(
            "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
            n.class
          )
        }, f.$attrs), [
          _(f.$slots, "default")
        ], 16)
      ]),
      _: 3
    }));
  }
}), Qj = /* @__PURE__ */ b({
  __name: "SidebarRail",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = uu();
    return (a, r) => (h(), W("button", {
      "data-sidebar": "rail",
      "aria-label": "Toggle Sidebar",
      tabindex: -1,
      title: "Toggle Sidebar",
      class: ae(
        l(R)(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          t.class
        )
      ),
      onClick: r[0] || (r[0] = //@ts-ignore
      (...o) => l(n) && l(n)(...o))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), eW = /* @__PURE__ */ b({
  __name: "SidebarSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Hi), {
      "data-sidebar": "separator",
      class: ae(l(R)("mx-2 w-auto bg-sidebar-border", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), tW = /* @__PURE__ */ b({
  __name: "SidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = uu();
    return (a, r) => (h(), x(l(gs), {
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: ae(l(R)("h-7 w-7", t.class)),
      onClick: l(n)
    }, {
      default: y(() => [
        N(l(Xy)),
        r[0] || (r[0] = we("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"]));
  }
}), rH = an(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), nW = /* @__PURE__ */ b({
  __name: "Slider",
  props: {
    defaultValue: {},
    modelValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    inverted: { type: Boolean },
    min: {},
    max: {},
    step: {},
    minStepsBetweenThumbs: {},
    thumbAlignment: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(HE), A({
      class: l(R)(
        "relative flex w-full touch-none items-center select-none data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5 data-[orientation=vertical]:flex-col",
        n.class
      )
    }, l(o)), {
      default: y(() => [
        N(l(ZE), { class: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20 data-[orientation=vertical]:w-1.5" }, {
          default: y(() => [
            N(l(WE), { class: "absolute h-full bg-primary data-[orientation=vertical]:w-full" })
          ]),
          _: 1
        }),
        (h(!0), W(Ke, null, Nt(e.modelValue, (u, d) => (h(), x(l(XE), {
          key: d,
          class: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50"
        }))), 128))
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), aW = /* @__PURE__ */ b({
  __name: "Sonner",
  props: {
    id: {},
    invert: { type: Boolean },
    theme: {},
    position: {},
    closeButtonPosition: {},
    hotkey: {},
    richColors: { type: Boolean },
    expand: { type: Boolean },
    duration: {},
    gap: {},
    visibleToasts: {},
    closeButton: { type: Boolean },
    toastOptions: {},
    class: {},
    style: {},
    offset: {},
    mobileOffset: {},
    dir: {},
    swipeDirections: {},
    icons: {},
    containerAriaLabel: {}
  },
  setup(e) {
    const n = Z(e, "toastOptions");
    return (a, r) => (h(), x(l(tb), A({
      class: "toaster group",
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, l(n)), {
      "success-icon": y(() => [
        N(l(Wy), { class: "size-4" })
      ]),
      "info-icon": y(() => [
        N(l(Ky), { class: "size-4" })
      ]),
      "warning-icon": y(() => [
        N(l(Jy), { class: "size-4" })
      ]),
      "error-icon": y(() => [
        N(l(Yy), { class: "size-4" })
      ]),
      "loading-icon": y(() => [
        we("div", null, [
          N(l(df), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": y(() => [
        N(l(ao), { class: "size-4" })
      ]),
      _: 1
    }, 16));
  }
}), rW = /* @__PURE__ */ b({
  __name: "Spinner",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(df), {
      role: "status",
      "aria-label": "Loading",
      class: ae(l(R)("size-4 animate-spin", t.class))
    }, null, 8, ["class"]));
  }
}), oW = /* @__PURE__ */ b({
  __name: "Stepper",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    modelValue: {},
    linear: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(MT), A({
      class: l(R)("flex gap-2", n.class)
    }, l(o)), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sW = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(OT), A(l(a), {
      class: l(R)("text-xs text-muted-foreground", t.class)
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lW = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(RT), A(l(a), {
      class: l(R)(
        "inline-flex h-8 w-8 items-center justify-center rounded-full text-muted-foreground/50",
        // Disabled
        "group-data-[disabled]:text-muted-foreground group-data-[disabled]:opacity-50",
        // Active
        "group-data-[state=active]:bg-primary group-data-[state=active]:text-primary-foreground",
        // Completed
        "group-data-[state=completed]:bg-accent group-data-[state=completed]:text-accent-foreground",
        t.class
      )
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), iW = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {},
    disabled: { type: Boolean },
    completed: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(TT), A(l(a), {
      class: l(R)("group flex items-center gap-2 data-[disabled]:pointer-events-none", t.class)
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uW = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(FT), A(l(a), {
      class: l(R)(
        "bg-muted",
        // Disabled
        "group-data-[disabled]:bg-muted group-data-[disabled]:opacity-50",
        // Completed
        "group-data-[state=completed]:bg-accent-foreground",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), dW = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(LT), A(l(a), {
      class: l(R)("text-md font-semibold whitespace-nowrap", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cW = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(HT), A(l(a), {
      class: l(R)("flex flex-col items-center gap-1 rounded-md p-1 text-center", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fW = /* @__PURE__ */ b({
  __name: "Switch",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean },
    id: {},
    value: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(GT), A(l(o), {
      class: l(R)(
        "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
        n.class
      )
    }), {
      default: y(() => [
        N(l(YT), {
          class: ae(
            l(R)(
              "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
            )
          )
        }, {
          default: y(() => [
            _(s.$slots, "thumb")
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), oH = { class: "relative w-full overflow-auto" }, pW = /* @__PURE__ */ b({
  __name: "Table",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", oH, [
      we("table", {
        class: ae(l(R)("w-full caption-bottom text-sm", t.class))
      }, [
        _(n.$slots, "default")
      ], 2)
    ]));
  }
}), vW = /* @__PURE__ */ b({
  __name: "TableBody",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("tbody", {
      class: ae(l(R)("[&_tr:last-child]:border-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), sH = /* @__PURE__ */ b({
  __name: "TableCell",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("td", {
      class: ae(
        l(R)(
          "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), mW = /* @__PURE__ */ b({
  __name: "TableHead",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("th", {
      class: ae(
        l(R)(
          "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), hW = /* @__PURE__ */ b({
  __name: "TableHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("thead", {
      class: ae(l(R)("[&_tr]:border-b", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), gW = /* @__PURE__ */ b({
  __name: "TableFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("tfoot", {
      class: ae(l(R)("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), lH = /* @__PURE__ */ b({
  __name: "TableRow",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("tr", {
      class: ae(
        l(R)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", t.class)
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), yW = /* @__PURE__ */ b({
  __name: "TableCaption",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("caption", {
      class: ae(l(R)("mt-4 text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), iH = { class: "flex items-center justify-center py-10" }, bW = /* @__PURE__ */ b({
  __name: "TableEmpty",
  props: {
    class: {},
    colspan: { default: 1 }
  },
  setup(e) {
    const t = e, n = q(() => {
      const { class: a, ...r } = t;
      return r;
    });
    return (a, r) => (h(), x(lH, null, {
      default: y(() => [
        N(sH, A({
          class: l(R)("p-4 align-middle text-sm whitespace-nowrap text-foreground", t.class)
        }, n.value), {
          default: y(() => [
            we("div", iH, [
              _(a.$slots, "default")
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), _W = /* @__PURE__ */ b({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), x(l(ZT), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wW = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(eA), A({
      class: l(R)(
        "mt-2 ring-offset-background focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none",
        t.class
      )
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xW = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(nA), A(l(n), {
      class: l(R)(
        "inline-flex items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uH = { class: "truncate" }, CW = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(rA), A(l(a), {
      class: l(R)(
        "inline-flex items-center justify-center rounded-md px-3 py-1 text-sm font-medium whitespace-nowrap ring-offset-background transition-all focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
        t.class
      )
    }), {
      default: y(() => [
        we("span", uH, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), SW = /* @__PURE__ */ b({
  __name: "TagsInput",
  props: {
    modelValue: {},
    defaultValue: {},
    addOnPaste: { type: Boolean },
    addOnTab: { type: Boolean },
    addOnBlur: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: {},
    dir: {},
    max: {},
    id: {},
    convertValue: { type: Function },
    displayValue: { type: Function },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "invalid", "addTag", "removeTag"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(lA), A(l(o), {
      class: l(R)(
        "flex flex-wrap items-center gap-2 rounded-md border border-input bg-background px-3 py-1.5 text-sm",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $W = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(uA), A(l(a), {
      class: l(R)("min-h-5 flex-1 bg-transparent px-1 text-sm focus:outline-none", t.class)
    }), null, 16, ["class"]));
  }
}), BW = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(fA), A(l(a), {
      class: l(R)(
        "flex h-5 items-center rounded-md bg-secondary ring-offset-background data-[state=active]:ring-2 data-[state=active]:ring-ring data-[state=active]:ring-offset-2",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kW = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(vA), A(l(a), {
      class: l(R)("mr-1 flex rounded bg-transparent", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(ao), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PW = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(hA), A(l(a), {
      class: l(R)("rounded bg-transparent px-2 py-0.5 text-sm", t.class)
    }), null, 16, ["class"]));
  }
}), DW = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "size", "variant"), o = ve(r, a);
    return (s, i) => (h(), x(l(by), A(l(o), {
      class: l(R)(l(a0)({ variant: e.variant, size: e.size }), n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), a0 = an(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 min-w-9 px-2",
        sm: "h-8 min-w-8 px-1.5",
        lg: "h-10 min-w-10 px-2.5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), MW = /* @__PURE__ */ b({
  __name: "ToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {},
    class: {},
    variant: {},
    size: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    Kn("toggleGroup", {
      variant: n.variant,
      size: n.size
    });
    const r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), x(l(bA), A(l(o), {
      class: l(R)("flex items-center justify-center gap-1", n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), qW = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e, n = wn("toggleGroup"), a = Z(t, "class", "size", "variant"), r = he(a);
    return (o, s) => (h(), x(l(xA), A(l(r), {
      class: l(R)(
        l(a0)({
          variant: l(n)?.variant || e.variant,
          size: l(n)?.size || e.size
        }),
        t.class
      )
    }), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
export {
  zH as Accord,
  VI as Accordion,
  FI as AccordionContent,
  NI as AccordionItem,
  LI as AccordionTrigger,
  HH as Alert,
  UH as AlertDescription,
  H2 as AlertDialog,
  U2 as AlertDialogAction,
  j2 as AlertDialogCancel,
  W2 as AlertDialogContent,
  G2 as AlertDialogDescription,
  K2 as AlertDialogFooter,
  Y2 as AlertDialogHeader,
  X2 as AlertDialogTitle,
  CH as AlertDialogTrigger,
  jH as AlertTitle,
  WH as AspectRatio,
  GH as Avatar,
  KH as AvatarFallback,
  YH as AvatarImage,
  XH as Badge,
  JH as Breadcrumb,
  ZH as BreadcrumbEllipsis,
  QH as BreadcrumbItem,
  e7 as BreadcrumbLink,
  t7 as BreadcrumbList,
  n7 as BreadcrumbPage,
  a7 as BreadcrumbSeparator,
  gs as Button,
  r7 as ButtonGroup,
  o7 as ButtonGroupSeparator,
  s7 as ButtonGroupText,
  MO as COLLAPSIBLE_SIDEBAR_WIDTH,
  qO as COLLAPSIBLE_SIDEBAR_WIDTH_ICON,
  EH as COLLAPSIBLE_SIDEBAR_WIDTH_MOBILE,
  l7 as Calendar,
  KI as CalendarCell,
  YI as CalendarCellTrigger,
  XI as CalendarGrid,
  JI as CalendarGridBody,
  ZI as CalendarGridHead,
  _v as CalendarGridRow,
  QI as CalendarHeadCell,
  e3 as CalendarHeader,
  t3 as CalendarHeading,
  n3 as CalendarNextButton,
  a3 as CalendarPrevButton,
  r3 as Card,
  o3 as CardContent,
  i7 as CardDescription,
  u7 as CardFooter,
  s3 as CardHeader,
  l3 as CardTitle,
  d7 as Carousel,
  c7 as CarouselContent,
  f7 as CarouselItem,
  v7 as CarouselNext,
  p7 as CarouselPrevious,
  m7 as ChartCrosshair,
  h7 as ChartLegend,
  g7 as ChartSingleTooltip,
  Yd as ChartTooltip,
  b7 as Checkbox,
  _7 as Collapsible,
  w7 as CollapsibleContent,
  OH as CollapsibleMain,
  VH as CollapsibleMenuButton,
  FH as CollapsibleMenuGroup,
  AH as CollapsibleSidebarDesktop,
  IH as CollapsibleSidebarTrigger,
  x7 as CollapsibleTrigger,
  TH as CollapsibleTwoColumnLayout,
  C7 as Combobox,
  S7 as ComboboxAnchor,
  pH as ComboboxCancel,
  $7 as ComboboxEmpty,
  B7 as ComboboxGroup,
  k7 as ComboboxInput,
  P7 as ComboboxItem,
  vH as ComboboxItemIndicator,
  D7 as ComboboxList,
  M7 as ComboboxSeparator,
  mH as ComboboxTrigger,
  l4 as Command,
  V7 as CommandDialog,
  F7 as CommandEmpty,
  N7 as CommandGroup,
  L7 as CommandInput,
  z7 as CommandItem,
  H7 as CommandList,
  U7 as CommandSeparator,
  j7 as CommandShortcut,
  SH as ConfirmDialog,
  W7 as ContextMenu,
  G7 as ContextMenuCheckboxItem,
  K7 as ContextMenuContent,
  Y7 as ContextMenuGroup,
  X7 as ContextMenuItem,
  J7 as ContextMenuLabel,
  Z7 as ContextMenuRadioGroup,
  Q7 as ContextMenuRadioItem,
  eU as ContextMenuSeparator,
  tU as ContextMenuShortcut,
  nU as ContextMenuSub,
  aU as ContextMenuSubContent,
  rU as ContextMenuSubTrigger,
  oU as ContextMenuTrigger,
  i4 as Dialog,
  q7 as DialogClose,
  u4 as DialogContent,
  E7 as DialogDescription,
  T7 as DialogFooter,
  A7 as DialogHeader,
  O7 as DialogScrollContent,
  I7 as DialogTitle,
  R7 as DialogTrigger,
  sU as Drawer,
  lU as DrawerClose,
  iU as DrawerContent,
  uU as DrawerDescription,
  dU as DrawerFooter,
  cU as DrawerHeader,
  O4 as DrawerOverlay,
  fU as DrawerTitle,
  pU as DrawerTrigger,
  vU as DropdownMenu,
  mU as DropdownMenuCheckboxItem,
  hU as DropdownMenuContent,
  gU as DropdownMenuGroup,
  yU as DropdownMenuItem,
  bU as DropdownMenuLabel,
  hP as DropdownMenuPortal,
  _U as DropdownMenuRadioGroup,
  wU as DropdownMenuRadioItem,
  xU as DropdownMenuSeparator,
  CU as DropdownMenuShortcut,
  SU as DropdownMenuSub,
  $U as DropdownMenuSubContent,
  BU as DropdownMenuSubTrigger,
  kU as DropdownMenuTrigger,
  PU as Empty,
  DU as EmptyContent,
  MU as EmptyDescription,
  qU as EmptyHeader,
  EU as EmptyMedia,
  TU as EmptyTitle,
  J_ as FORM_ITEM_INJECTION_KEY,
  AU as Field,
  OU as FieldContent,
  IU as FieldDescription,
  RU as FieldError,
  VU as FieldGroup,
  FU as FieldLabel,
  NU as FieldLegend,
  LU as FieldSeparator,
  zU as FieldSet,
  HU as FieldTitle,
  NH as Flasher,
  jU as Form,
  GU as FormControl,
  KU as FormDescription,
  UU as FormField,
  WU as FormFieldArray,
  YU as FormItem,
  XU as FormLabel,
  JU as FormMessage,
  BH as Header,
  LH as Heading,
  ZU as HoverCard,
  QU as HoverCardContent,
  e9 as HoverCardTrigger,
  Z_ as Input,
  t9 as InputGroup,
  n9 as InputGroupAddon,
  a9 as InputGroupButton,
  r9 as InputGroupInput,
  o9 as InputGroupText,
  s9 as InputGroupTextarea,
  l9 as InputOTP,
  i9 as InputOTPGroup,
  u9 as InputOTPSeparator,
  d9 as InputOTPSlot,
  c9 as Item,
  f9 as ItemActions,
  p9 as ItemContent,
  v9 as ItemDescription,
  m9 as ItemFooter,
  h9 as ItemGroup,
  g9 as ItemHeader,
  y9 as ItemMedia,
  b9 as ItemSeparator,
  _9 as ItemTitle,
  w9 as Kbd,
  x9 as KbdGroup,
  N_ as Label,
  kH as Main,
  C9 as Menubar,
  S9 as MenubarCheckboxItem,
  $9 as MenubarContent,
  B9 as MenubarGroup,
  k9 as MenubarItem,
  P9 as MenubarLabel,
  D9 as MenubarMenu,
  M9 as MenubarRadioGroup,
  q9 as MenubarRadioItem,
  E9 as MenubarSeparator,
  T9 as MenubarShortcut,
  A9 as MenubarSub,
  O9 as MenubarSubContent,
  I9 as MenubarSubTrigger,
  R9 as MenubarTrigger,
  V9 as NavigationMenu,
  F9 as NavigationMenuContent,
  N9 as NavigationMenuIndicator,
  L9 as NavigationMenuItem,
  z9 as NavigationMenuLink,
  H9 as NavigationMenuList,
  U9 as NavigationMenuTrigger,
  B8 as NavigationMenuViewport,
  j9 as NumberField,
  W9 as NumberFieldContent,
  G9 as NumberFieldDecrement,
  K9 as NumberFieldIncrement,
  Y9 as NumberFieldInput,
  X9 as Pagination,
  J9 as PaginationContent,
  Z9 as PaginationEllipsis,
  Q9 as PaginationFirst,
  ej as PaginationItem,
  tj as PaginationLast,
  nj as PaginationNext,
  aj as PaginationPrevious,
  rj as PinInput,
  oj as PinInputGroup,
  sj as PinInputSeparator,
  lj as PinInputSlot,
  ij as Popover,
  hH as PopoverAnchor,
  uj as PopoverContent,
  dj as PopoverTrigger,
  cj as Progress,
  fj as RadioGroup,
  pj as RadioGroupItem,
  vj as RangeCalendar,
  D8 as RangeCalendarCell,
  M8 as RangeCalendarCellTrigger,
  q8 as RangeCalendarGrid,
  E8 as RangeCalendarGridBody,
  T8 as RangeCalendarGridHead,
  jm as RangeCalendarGridRow,
  A8 as RangeCalendarHeadCell,
  O8 as RangeCalendarHeader,
  I8 as RangeCalendarHeading,
  R8 as RangeCalendarNextButton,
  V8 as RangeCalendarPrevButton,
  mj as ResizableHandle,
  gH as ResizablePanel,
  hj as ResizablePanelGroup,
  gj as ScrollArea,
  N8 as ScrollBar,
  yj as Select,
  bj as SelectContent,
  _j as SelectGroup,
  wj as SelectItem,
  xj as SelectItemText,
  Cj as SelectLabel,
  z8 as SelectScrollDownButton,
  H8 as SelectScrollUpButton,
  Sj as SelectSeparator,
  $j as SelectTrigger,
  Bj as SelectValue,
  Hi as Separator,
  U8 as Sheet,
  kj as SheetClose,
  W8 as SheetContent,
  Pj as SheetDescription,
  Dj as SheetFooter,
  Mj as SheetHeader,
  j8 as SheetOverlay,
  qj as SheetTitle,
  Ej as SheetTrigger,
  Tj as Sidebar,
  Aj as SidebarContent,
  Oj as SidebarFooter,
  Ij as SidebarGroup,
  Rj as SidebarGroupAction,
  Vj as SidebarGroupContent,
  Fj as SidebarGroupLabel,
  Nj as SidebarHeader,
  Lj as SidebarInput,
  zj as SidebarInset,
  Hj as SidebarMenu,
  Uj as SidebarMenuAction,
  jj as SidebarMenuBadge,
  Wj as SidebarMenuButton,
  Gj as SidebarMenuItem,
  Kj as SidebarMenuSkeleton,
  Yj as SidebarMenuSub,
  Xj as SidebarMenuSubButton,
  Jj as SidebarMenuSubItem,
  Zj as SidebarProvider,
  Qj as SidebarRail,
  eW as SidebarSeparator,
  tW as SidebarTrigger,
  Km as Skeleton,
  nW as Slider,
  rW as Spinner,
  oW as Stepper,
  sW as StepperDescription,
  lW as StepperIndicator,
  iW as StepperItem,
  uW as StepperSeparator,
  dW as StepperTitle,
  cW as StepperTrigger,
  fW as Switch,
  pW as Table,
  vW as TableBody,
  yW as TableCaption,
  sH as TableCell,
  bW as TableEmpty,
  gW as TableFooter,
  mW as TableHead,
  hW as TableHeader,
  lH as TableRow,
  _W as Tabs,
  wW as TabsContent,
  xW as TabsList,
  CW as TabsTrigger,
  SW as TagsInput,
  $W as TagsInputInput,
  BW as TagsInputItem,
  kW as TagsInputItemDelete,
  PW as TagsInputItemText,
  jz as Textarea,
  RH as Tip,
  aW as Toaster,
  DW as Toggle,
  MW as ToggleGroup,
  qW as ToggleGroupItem,
  ff as Tooltip,
  pf as TooltipContent,
  VO as TooltipProvider,
  vf as TooltipTrigger,
  $H as TwoColumnLayout,
  PH as TwoColumnLayoutSidebar,
  DH as TwoColumnLayoutSidebarDesktop,
  MH as TwoColumnLayoutSidebarMobile,
  qH as TwoColumnLayoutSidebarTrigger,
  zI as alertVariants,
  HI as avatarVariant,
  UI as badgeVariants,
  WI as buttonGroupVariants,
  Kt as buttonVariants,
  R as cn,
  bH as createContext,
  y7 as defaultColors,
  F4 as emptyMediaVariants,
  j4 as fieldVariants,
  Wz as inputGroupAddonVariants,
  Gz as inputGroupButtonVariants,
  x8 as itemMediaVariants,
  w8 as itemVariants,
  k8 as navigationMenuTriggerStyle,
  cH as preset,
  f4 as provideCommandContext,
  v4 as provideCommandGroupContext,
  rH as sidebarMenuButtonVariants,
  a0 as toggleVariants,
  ji as useCarousel,
  ys as useCollapsibleSidebar,
  ou as useCommand,
  p4 as useCommandGroup,
  Q2 as useConfirmDialog,
  OI as useFlasher,
  xH as useMobileBottomNav,
  _H as useMobileNavigation,
  uu as useSidebar,
  wH as useSwipeNavigation,
  yH as valueUpdater
};
