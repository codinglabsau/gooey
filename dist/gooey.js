import * as lp from "vue";
import { inject as Cn, provide as Xn, Fragment as Ye, shallowRef as gt, readonly as or, toValue as fe, getCurrentScope as ss, onScopeDispose as sc, customRef as pi, watch as ve, nextTick as ke, effectScope as Qm, computed as E, watchEffect as Ie, onBeforeUnmount as sr, isRef as mt, reactive as Wt, unref as l, getCurrentInstance as ht, toRef as jn, ref as I, toRefs as Me, onMounted as Ce, toHandlerKey as m0, camelize as xl, onUnmounted as Qe, defineComponent as b, h as an, Comment as h0, mergeProps as A, cloneVNode as g0, createBlock as x, openBlock as h, withCtx as y, renderSlot as _, createVNode as N, createCommentVNode as Ee, withKeys as Je, normalizeStyle as dt, Teleport as vi, normalizeProps as oe, guardReactiveProps as le, withModifiers as Ke, createElementBlock as G, withDirectives as lc, vShow as y0, createElementVNode as xe, toDisplayString as He, createTextVNode as Re, markRaw as b0, renderList as Lt, resolveDynamicComponent as Tt, watchPostEffect as eh, shallowReadonly as br, mergeDefaults as th, watchSyncEffect as _0, withMemo as w0, onBeforeMount as x0, toRaw as C0, toHandlers as S0, hasInjectionContext as nh, onUpdated as $0, normalizeClass as re, useAttrs as k0, isVNode as co, createApp as od, useSlots as B0, warn as ah, vModelText as rh, mergeModels as ip, useModel as D0 } from "vue";
function oh(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var hu, up;
function P0() {
  if (up) return hu;
  up = 1;
  function e(n, a) {
    return { handler: n, config: a };
  }
  e.withOptions = function(n, a = () => ({})) {
    function r(o) {
      return { handler: n(o), config: a(o) };
    }
    return r.__isOptionsFunction = !0, r;
  };
  var t = e;
  return hu = t, hu;
}
var gu, dp;
function M0() {
  if (dp) return gu;
  dp = 1;
  const e = P0();
  function t(n) {
    return Object.fromEntries(
      Object.entries(n).filter(([a]) => a !== "DEFAULT")
    );
  }
  return gu = e(
    ({ addUtilities: n, matchUtilities: a, theme: r }) => {
      n({
        "@keyframes enter": r("keyframes.enter"),
        "@keyframes exit": r("keyframes.exit"),
        ".animate-in": {
          animationName: "enter",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-enter-opacity": "initial",
          "--tw-enter-scale": "initial",
          "--tw-enter-rotate": "initial",
          "--tw-enter-translate-x": "initial",
          "--tw-enter-translate-y": "initial"
        },
        ".animate-out": {
          animationName: "exit",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-exit-opacity": "initial",
          "--tw-exit-scale": "initial",
          "--tw-exit-rotate": "initial",
          "--tw-exit-translate-x": "initial",
          "--tw-exit-translate-y": "initial"
        }
      }), a(
        {
          "fade-in": (o) => ({ "--tw-enter-opacity": o }),
          "fade-out": (o) => ({ "--tw-exit-opacity": o })
        },
        { values: r("animationOpacity") }
      ), a(
        {
          "zoom-in": (o) => ({ "--tw-enter-scale": o }),
          "zoom-out": (o) => ({ "--tw-exit-scale": o })
        },
        { values: r("animationScale") }
      ), a(
        {
          "spin-in": (o) => ({ "--tw-enter-rotate": o }),
          "spin-out": (o) => ({ "--tw-exit-rotate": o })
        },
        { values: r("animationRotate") }
      ), a(
        {
          "slide-in-from-top": (o) => ({
            "--tw-enter-translate-y": `-${o}`
          }),
          "slide-in-from-bottom": (o) => ({
            "--tw-enter-translate-y": o
          }),
          "slide-in-from-left": (o) => ({
            "--tw-enter-translate-x": `-${o}`
          }),
          "slide-in-from-right": (o) => ({
            "--tw-enter-translate-x": o
          }),
          "slide-out-to-top": (o) => ({
            "--tw-exit-translate-y": `-${o}`
          }),
          "slide-out-to-bottom": (o) => ({
            "--tw-exit-translate-y": o
          }),
          "slide-out-to-left": (o) => ({
            "--tw-exit-translate-x": `-${o}`
          }),
          "slide-out-to-right": (o) => ({
            "--tw-exit-translate-x": o
          })
        },
        { values: r("animationTranslate") }
      ), a(
        { duration: (o) => ({ animationDuration: o }) },
        { values: t(r("animationDuration")) }
      ), a(
        { delay: (o) => ({ animationDelay: o }) },
        { values: r("animationDelay") }
      ), a(
        { ease: (o) => ({ animationTimingFunction: o }) },
        { values: t(r("animationTimingFunction")) }
      ), n({
        ".running": { animationPlayState: "running" },
        ".paused": { animationPlayState: "paused" }
      }), a(
        { "fill-mode": (o) => ({ animationFillMode: o }) },
        { values: r("animationFillMode") }
      ), a(
        { direction: (o) => ({ animationDirection: o }) },
        { values: r("animationDirection") }
      ), a(
        { repeat: (o) => ({ animationIterationCount: o }) },
        { values: r("animationRepeat") }
      );
    },
    {
      theme: {
        extend: {
          animationDelay: ({ theme: n }) => ({
            ...n("transitionDelay")
          }),
          animationDuration: ({ theme: n }) => ({
            0: "0ms",
            ...n("transitionDuration")
          }),
          animationTimingFunction: ({ theme: n }) => ({
            ...n("transitionTimingFunction")
          }),
          animationFillMode: {
            none: "none",
            forwards: "forwards",
            backwards: "backwards",
            both: "both"
          },
          animationDirection: {
            normal: "normal",
            reverse: "reverse",
            alternate: "alternate",
            "alternate-reverse": "alternate-reverse"
          },
          animationOpacity: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("opacity")
          }),
          animationTranslate: ({ theme: n }) => ({
            DEFAULT: "100%",
            ...n("translate")
          }),
          animationScale: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("scale")
          }),
          animationRotate: ({ theme: n }) => ({
            DEFAULT: "30deg",
            ...n("rotate")
          }),
          animationRepeat: {
            0: "0",
            1: "1",
            infinite: "infinite"
          },
          keyframes: {
            enter: {
              from: {
                opacity: "var(--tw-enter-opacity, 1)",
                transform: "translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))"
              }
            },
            exit: {
              to: {
                opacity: "var(--tw-exit-opacity, 1)",
                transform: "translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))"
              }
            }
          }
        }
      }
    }
  ), gu;
}
var q0 = M0();
const E0 = /* @__PURE__ */ oh(q0), x7 = {
  darkMode: ["class"],
  safelist: ["dark"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))"
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))"
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))"
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))"
        }
      },
      borderRadius: {
        xl: "calc(var(--radius) + 4px)",
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" }
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }
        },
        "collapsible-down": {
          from: { height: "0" },
          to: { height: "var(--radix-collapsible-content-height)" }
        },
        "collapsible-up": {
          from: { height: "var(--radix-collapsible-content-height)" },
          to: { height: "0" }
        }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "collapsible-down": "collapsible-down 0.2s ease-in-out",
        "collapsible-up": "collapsible-up 0.2s ease-in-out"
      }
    }
  },
  plugins: [E0]
};
function cp(e) {
  return typeof e == "string" ? `'${e}'` : new T0().serialize(e);
}
const T0 = /* @__PURE__ */ (function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(n, a) {
      const r = typeof n, o = typeof a;
      return r === "string" && o === "string" ? n.localeCompare(a) : r === "number" && o === "number" ? n - a : String.prototype.localeCompare.call(this.serialize(n, !0), this.serialize(a, !0));
    }
    serialize(n, a) {
      if (n === null) return "null";
      switch (typeof n) {
        case "string":
          return a ? n : `'${n}'`;
        case "bigint":
          return `${n}n`;
        case "object":
          return this.$object(n);
        case "function":
          return this.$function(n);
      }
      return String(n);
    }
    serializeObject(n) {
      const a = Object.prototype.toString.call(n);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), n);
      const r = n.constructor, o = r === Object || r === void 0 ? "" : r.name;
      if (o !== "" && globalThis[o] === r) return this.serializeBuiltInType(o, n);
      if (typeof n.toJSON == "function") {
        const s = n.toJSON();
        return o + (s !== null && typeof s == "object" ? this.$object(s) : `(${this.serialize(s)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(n));
    }
    serializeBuiltInType(n, a) {
      const r = this["$" + n];
      if (r) return r.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(n, a.entries());
      throw new Error(`Cannot serialize ${n}`);
    }
    serializeObjectEntries(n, a) {
      const r = Array.from(a).sort((s, i) => this.compare(s[0], i[0]));
      let o = `${n}{`;
      for (let s = 0; s < r.length; s++) {
        const [i, u] = r[s];
        o += `${this.serialize(i, !0)}:${this.serialize(u)}`, s < r.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(n) {
      let a = this.#e.get(n);
      return a === void 0 && (this.#e.set(n, `#${this.#e.size}`), a = this.serializeObject(n), this.#e.set(n, a)), a;
    }
    $function(n) {
      const a = Function.prototype.toString.call(n);
      return a.slice(-15) === "[native code] }" ? `${n.name || ""}()[native]` : `${n.name}(${n.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(n) {
      let a = "[";
      for (let r = 0; r < n.length; r++) a += this.serialize(n[r]), r < n.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(n) {
      try {
        return `Date(${n.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(n) {
      return `ArrayBuffer[${new Uint8Array(n).join(",")}]`;
    }
    $Set(n) {
      return `Set${this.$Array(Array.from(n).sort((a, r) => this.compare(a, r)))}`;
    }
    $Map(n) {
      return this.serializeObjectEntries("Map", n.entries());
    }
  }
  for (const t of ["Error", "RegExp", "URL"]) e.prototype["$" + t] = function(n) {
    return `${t}(${n})`;
  };
  for (const t of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join(",")}]`;
  };
  for (const t of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join("n,")}${n.length > 0 ? "n" : ""}]`;
  };
  return e;
})();
function En(e, t) {
  return e === t || cp(e) === cp(t);
}
function A0(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function I0(e, t, n) {
  const a = e.findIndex((i) => En(i, t)), r = e.findIndex((i) => En(i, n));
  if (a === -1 || r === -1) return [];
  const [o, s] = [a, r].sort((i, u) => i - u);
  return e.slice(o, s + 1);
}
const ls = typeof document < "u";
function Or(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e));
}
function As(e, t) {
  let n = e;
  const a = t.toString(), r = a.indexOf("."), o = r >= 0 ? a.length - r : 0;
  if (o > 0) {
    const s = 10 ** o;
    n = Math.round(n * s) / s;
  }
  return n;
}
function O0(e, t, n, a) {
  t = Number(t), n = Number(n);
  const r = (e - (Number.isNaN(t) ? 0 : t)) % a;
  let o = As(Math.abs(r) * 2 >= a ? e + Math.sign(r) * (a - Math.abs(r)) : e - r, a);
  return Number.isNaN(t) ? !Number.isNaN(n) && o > n && (o = Math.floor(As(n / a, a)) * a) : o < t ? o = t : !Number.isNaN(n) && o > n && (o = t + Math.floor(As((n - t) / a, a)) * a), o = As(o, a), o;
}
function Be(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = Cn(a, s);
    if (i || i === null) return i;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (s) => (Xn(a, s), s)];
}
function ot() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function is(e, t, n) {
  const a = n.originalEvent.target, r = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(r);
}
function Mn(e) {
  return e == null;
}
function Cl(e, t) {
  return Mn(e) ? !1 : Array.isArray(e) ? e.some((n) => En(n, t)) : En(e, t);
}
function ic(e) {
  return e ? e.flatMap((t) => t.type === Ye ? ic(t.children) : [t]) : [];
}
const R0 = ["INPUT", "TEXTAREA"];
function lr(e, t, n, a = {}) {
  if (!t || a.enableIgnoredElement && R0.includes(t.nodeName)) return null;
  const { arrowKeyOptions: r = "both", attributeName: o = "[data-reka-collection-item]", itemsArray: s = [], loop: i = !0, dir: u = "ltr", preventScroll: d = !0, focus: c = !1 } = a, [f, p, v, m, g, w] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ], C = v || m, S = f || p;
  if (!g && !w && (!C && !S || r === "vertical" && S || r === "horizontal" && C)) return null;
  const $ = n ? Array.from(n.querySelectorAll(o)) : s;
  if (!$.length) return null;
  d && e.preventDefault();
  let B = null;
  return S || C ? B = sh($, t, {
    goForward: C ? m : u === "ltr" ? f : p,
    loop: i
  }) : g ? B = $.at(0) || null : w && (B = $.at(-1) || null), c && B?.focus(), B;
}
function sh(e, t, n, a = e.length) {
  if (--a === 0) return null;
  const r = e.indexOf(t), o = n.goForward ? r + 1 : r - 1;
  if (!n.loop && (o < 0 || o >= e.length)) return null;
  const s = (o + e.length) % e.length, i = e[s];
  return i ? i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false" ? sh(e, i, n, a) : i : null;
}
const [us] = Be("ConfigProvider");
function V0(e, t) {
  var n;
  const a = gt();
  return Ie(() => {
    a.value = e();
  }, {
    ...t,
    flush: (n = void 0) != null ? n : "sync"
  }), or(a);
}
function ga(e) {
  return ss() ? (sc(e), !0) : !1;
}
function Dr() {
  const e = /* @__PURE__ */ new Set(), t = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const s = () => t(o);
      return ga(s), {
        off: s
      };
    },
    off: t,
    trigger: (...o) => Promise.all(Array.from(e).map((s) => s(...o))),
    clear: () => {
      e.clear();
    }
  };
}
function F0(e) {
  let t = !1, n;
  const a = Qm(!0);
  return (...r) => (t || (n = a.run(() => e(...r)), t = !0), n);
}
function lh(e) {
  let t = 0, n, a;
  const r = () => {
    t -= 1, a && t <= 0 && (a.stop(), n = void 0, a = void 0);
  };
  return (...o) => (t += 1, a || (a = Qm(!0), n = a.run(() => e(...o))), ga(r), n);
}
function N0(e) {
  if (!mt(e))
    return Wt(e);
  const t = new Proxy({}, {
    get(n, a, r) {
      return l(Reflect.get(e.value, a, r));
    },
    set(n, a, r) {
      return mt(e.value[a]) && !mt(r) ? e.value[a].value = r : e.value[a] = r, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Wt(t);
}
function uc(e) {
  return N0(E(e));
}
function ds(e, ...t) {
  const n = t.flat(), a = n[0];
  return uc(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(fe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
const rn = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const L0 = (e) => typeof e < "u", z0 = (e) => e != null, H0 = Object.prototype.toString, U0 = (e) => H0.call(e) === "[object Object]", Sl = () => {
}, fp = /* @__PURE__ */ j0();
function j0() {
  var e, t;
  return rn && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window?.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function ih(e, t) {
  function n(...a) {
    return new Promise((r, o) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(r).catch(o);
    });
  }
  return n;
}
const uh = (e) => e();
function W0(e, t = {}) {
  let n, a, r = Sl;
  const o = (u) => {
    clearTimeout(u), r(), r = Sl;
  };
  let s;
  return (u) => {
    const d = fe(e), c = fe(t.maxWait);
    return n && o(n), d <= 0 || c !== void 0 && c <= 0 ? (a && (o(a), a = null), Promise.resolve(u())) : new Promise((f, p) => {
      r = t.rejectOnCancel ? p : f, s = u, c && !a && (a = setTimeout(() => {
        n && o(n), a = null, f(s());
      }, c)), n = setTimeout(() => {
        a && o(a), a = null, f(u());
      }, d);
    });
  };
}
function G0(e = uh, t = {}) {
  const {
    initialState: n = "active"
  } = t, a = Y0(n === "active");
  function r() {
    a.value = !1;
  }
  function o() {
    a.value = !0;
  }
  const s = (...i) => {
    a.value && e(...i);
  };
  return { isActive: or(a), pause: r, resume: o, eventFilter: s };
}
function K0(e) {
  return ht();
}
function sl(e) {
  return Array.isArray(e) ? e : [e];
}
function Y0(...e) {
  if (e.length !== 1)
    return jn(...e);
  const t = e[0];
  return typeof t == "function" ? or(pi(() => ({ get: t, set: Sl }))) : I(t);
}
function cs(e, t = 1e4) {
  return pi((n, a) => {
    let r = fe(e), o;
    const s = () => setTimeout(() => {
      r = fe(e), a();
    }, fe(t));
    return ga(() => {
      clearTimeout(o);
    }), {
      get() {
        return n(), r;
      },
      set(i) {
        r = i, a(), clearTimeout(o), o = s();
      }
    };
  });
}
function dc(e, t = 200, n = {}) {
  return ih(
    W0(t, n),
    e
  );
}
function X0(e, t, n = {}) {
  const {
    eventFilter: a = uh,
    ...r
  } = n;
  return ve(
    e,
    ih(
      a,
      t
    ),
    r
  );
}
function pp(e, t, n = {}) {
  const {
    eventFilter: a,
    initialState: r = "active",
    ...o
  } = n, { eventFilter: s, pause: i, resume: u, isActive: d } = G0(a, { initialState: r });
  return { stop: X0(
    e,
    t,
    {
      ...o,
      eventFilter: s
    }
  ), pause: i, resume: u, isActive: d };
}
function J0(e, t, ...[n]) {
  const {
    flush: a = "sync",
    deep: r = !1,
    immediate: o = !0,
    direction: s = "both",
    transform: i = {}
  } = n || {}, u = [], d = "ltr" in i && i.ltr || ((p) => p), c = "rtl" in i && i.rtl || ((p) => p);
  return (s === "both" || s === "ltr") && u.push(pp(
    e,
    (p) => {
      u.forEach((v) => v.pause()), t.value = d(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: r, immediate: o }
  )), (s === "both" || s === "rtl") && u.push(pp(
    t,
    (p) => {
      u.forEach((v) => v.pause()), e.value = c(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: r, immediate: o }
  )), () => {
    u.forEach((p) => p.stop());
  };
}
function Z0(e, t) {
  K0() && sr(e, t);
}
function dh(e, t, n = {}) {
  const {
    immediate: a = !0,
    immediateCallback: r = !1
  } = n, o = gt(!1);
  let s = null;
  function i() {
    s && (clearTimeout(s), s = null);
  }
  function u() {
    o.value = !1, i();
  }
  function d(...c) {
    r && e(), i(), o.value = !0, s = setTimeout(() => {
      o.value = !1, s = null, e(...c);
    }, fe(t));
  }
  return a && (o.value = !0, rn && d()), ga(u), {
    isPending: or(o),
    start: d,
    stop: u
  };
}
function Q0(e, t, n) {
  return ve(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
function ew(e, t, n) {
  const a = ve(e, (...r) => (ke(() => a()), t(...r)), n);
  return a;
}
const Ra = rn ? window : void 0;
function Gt(e) {
  var t;
  const n = fe(e);
  return (t = n?.$el) != null ? t : n;
}
function zt(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), r = E(() => {
    const i = sl(fe(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), o = Q0(
    () => {
      var i, u;
      return [
        (u = (i = r.value) == null ? void 0 : i.map((d) => Gt(d))) != null ? u : [Ra].filter((d) => d != null),
        sl(fe(r.value ? e[1] : e[0])),
        sl(l(r.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        fe(r.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !i?.length || !u?.length || !d?.length)
        return;
      const f = U0(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return ga(n), s;
}
function cc() {
  const e = gt(!1), t = ht();
  return t && Ce(() => {
    e.value = !0;
  }, t), e;
}
function ch(e) {
  const t = cc();
  return E(() => (t.value, !!e()));
}
function tw(e, t, n = {}) {
  const { window: a = Ra, ...r } = n;
  let o;
  const s = ch(() => a && "MutationObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = E(() => {
    const p = fe(e), v = sl(p).map(Gt).filter(z0);
    return new Set(v);
  }), d = ve(
    () => u.value,
    (p) => {
      i(), s.value && p.size && (o = new MutationObserver(t), p.forEach((v) => o.observe(v, r)));
    },
    { immediate: !0, flush: "post" }
  ), c = () => o?.takeRecords(), f = () => {
    d(), i();
  };
  return ga(f), {
    isSupported: s,
    stop: f,
    takeRecords: c
  };
}
function nw(e, t, n = {}) {
  const {
    window: a = Ra,
    document: r = a?.document,
    flush: o = "sync"
  } = n;
  if (!a || !r)
    return Sl;
  let s;
  const i = (c) => {
    s?.(), s = c;
  }, u = Ie(() => {
    const c = Gt(e);
    if (c) {
      const { stop: f } = tw(
        r,
        (p) => {
          p.map((m) => [...m.removedNodes]).flat().some((m) => m === c || m.contains(c)) && t(p);
        },
        {
          window: a,
          childList: !0,
          subtree: !0
        }
      );
      i(f);
    }
  }, { flush: o }), d = () => {
    u(), i();
  };
  return ga(d), d;
}
function aw(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function rw(...e) {
  let t, n, a = {};
  e.length === 3 ? (t = e[0], n = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], a = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: r = Ra,
    eventName: o = "keydown",
    passive: s = !1,
    dedupe: i = !1
  } = a, u = aw(t);
  return zt(r, o, (c) => {
    c.repeat && fe(i) || u(c) && n(c);
  }, s);
}
function ow(e = {}) {
  var t;
  const {
    window: n = Ra,
    deep: a = !0,
    triggerOnRemoval: r = !1
  } = e, o = (t = e.document) != null ? t : n?.document, s = () => {
    var d;
    let c = o?.activeElement;
    if (a)
      for (; c?.shadowRoot; )
        c = (d = c?.shadowRoot) == null ? void 0 : d.activeElement;
    return c;
  }, i = gt(), u = () => {
    i.value = s();
  };
  if (n) {
    const d = {
      capture: !0,
      passive: !0
    };
    zt(
      n,
      "blur",
      (c) => {
        c.relatedTarget === null && u();
      },
      d
    ), zt(
      n,
      "focus",
      u,
      d
    );
  }
  return r && nw(i, u, { document: o }), u(), i;
}
function sw(e) {
  return JSON.parse(JSON.stringify(e));
}
function Tn(e, t, n = {}) {
  const { window: a = Ra, ...r } = n;
  let o;
  const s = ch(() => a && "ResizeObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = E(() => {
    const f = fe(e);
    return Array.isArray(f) ? f.map((p) => Gt(p)) : [Gt(f)];
  }), d = ve(
    u,
    (f) => {
      if (i(), s.value && a) {
        o = new ResizeObserver(t);
        for (const p of f)
          p && o.observe(p, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    i(), d();
  };
  return ga(c), {
    isSupported: s,
    stop: c
  };
}
const lw = "focusin", iw = "focusout", uw = ":focus-within";
function dw(e, t = {}) {
  const { window: n = Ra } = t, a = E(() => Gt(e)), r = gt(!1), o = E(() => r.value), s = ow(t);
  if (!n || !s.value)
    return { focused: o };
  const i = { passive: !0 };
  return zt(a, lw, () => r.value = !0, i), zt(a, iw, () => {
    var u, d, c;
    return r.value = (c = (d = (u = a.value) == null ? void 0 : u.matches) == null ? void 0 : d.call(u, uw)) != null ? c : !1;
  }, i), { focused: o };
}
function Ve(e, t, n, a = {}) {
  var r, o, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = ht(), m = n || v?.emit || ((r = v?.$emit) == null ? void 0 : r.bind(v)) || ((s = (o = v?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(v?.proxy));
  let g = d;
  t || (t = "modelValue"), g = g || `update:${t.toString()}`;
  const w = ($) => i ? typeof i == "function" ? i($) : sw($) : $, C = () => L0(e[t]) ? w(e[t]) : f, S = ($) => {
    p ? p($) && m(g, $) : m(g, $);
  };
  if (u) {
    const $ = C(), B = I($);
    let k = !1;
    return ve(
      () => e[t],
      (P) => {
        k || (k = !0, B.value = w(P), ke(() => k = !1));
      }
    ), ve(
      B,
      (P) => {
        !k && (P !== e[t] || c) && S(P);
      },
      { deep: c }
    ), B;
  } else
    return E({
      get() {
        return C();
      },
      set($) {
        S($);
      }
    });
}
function yu(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function sd(e, t, n = ".", a) {
  if (!yu(t))
    return sd(e, {}, n, a);
  const r = Object.assign({}, t);
  for (const o in e) {
    if (o === "__proto__" || o === "constructor")
      continue;
    const s = e[o];
    s != null && (a && a(r, o, s, n) || (Array.isArray(s) && Array.isArray(r[o]) ? r[o] = [...s, ...r[o]] : yu(s) && yu(r[o]) ? r[o] = sd(
      s,
      r[o],
      (n ? `${n}.` : "") + o.toString(),
      a
    ) : r[o] = s));
  }
  return r;
}
function cw(e) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((n, a) => sd(n, a, "", e), {})
  );
}
const fw = cw(), pw = lh(() => {
  const e = I(/* @__PURE__ */ new Map()), t = I(), n = E(() => {
    for (const s of e.value.values()) if (s) return !0;
    return !1;
  }), a = us({ scrollBody: I(!0) });
  let r = null;
  const o = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", fp && r?.(), t.value = void 0;
  };
  return ve(n, (s, i) => {
    if (!rn) return;
    if (!s) {
      i && o();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const u = window.innerWidth - document.documentElement.clientWidth, d = {
      padding: u,
      margin: 0
    }, c = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? fw({
      padding: a.scrollBody.value.padding === !0 ? u : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? u : a.scrollBody.value.margin
    }, d) : d : {
      padding: 0,
      margin: 0
    };
    u > 0 && (document.body.style.paddingRight = typeof c.padding == "number" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == "number" ? `${c.margin}px` : String(c.margin), document.documentElement.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), fp && (r = zt(document, "touchmove", (f) => vw(f), { passive: !1 })), ke(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function fs(e) {
  const t = Math.random().toString(36).substring(2, 7), n = pw();
  n.value.set(t, e ?? !1);
  const a = E({
    get: () => n.value.get(t) ?? !1,
    set: (r) => n.value.set(t, r)
  });
  return Z0(() => {
    n.value.delete(t);
  }), a;
}
function fh(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : fh(n);
  }
}
function vw(e) {
  const t = e || window.event, n = t.target;
  return n instanceof Element && fh(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);
}
function Pr(e, t) {
  return e - t * Math.floor(e / t);
}
const ph = 1721426;
function Ka(e, t, n, a) {
  t = ps(e, t);
  let r = t - 1, o = -2;
  return n <= 2 ? o = 0 : Ma(t) && (o = -1), ph - 1 + 365 * r + Math.floor(r / 4) - Math.floor(r / 100) + Math.floor(r / 400) + Math.floor((367 * n - 362) / 12 + o + a);
}
function Ma(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function ps(e, t) {
  return e === "BC" ? 1 - t : t;
}
function mi(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const mw = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class An {
  fromJulianDay(t) {
    let n = t, a = n - ph, r = Math.floor(a / 146097), o = Pr(a, 146097), s = Math.floor(o / 36524), i = Pr(o, 36524), u = Math.floor(i / 1461), d = Pr(i, 1461), c = Math.floor(d / 365), f = r * 400 + s * 100 + u * 4 + c + (s !== 4 && c !== 4 ? 1 : 0), [p, v] = mi(f), m = n - Ka(p, v, 1, 1), g = 2;
    n < Ka(p, v, 3, 1) ? g = 0 : Ma(v) && (g = 1);
    let w = Math.floor(((m + g) * 12 + 373) / 367), C = n - Ka(p, v, w, 1) + 1;
    return new Ct(p, v, w, C);
  }
  toJulianDay(t) {
    return Ka(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return mw[Ma(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return Ma(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const hw = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function wt(e, t) {
  return t = en(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function fc(e, t) {
  return t = en(t, e.calendar), e = ld(e), t = ld(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function Ba(e, t) {
  return pc(e.calendar, t.calendar) && wt(e, t);
}
function vp(e, t) {
  return pc(e.calendar, t.calendar) && fc(e, t);
}
function pc(e, t) {
  var n, a, r, o;
  return (o = (r = (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && r !== void 0 ? r : (a = t.isEqual) === null || a === void 0 ? void 0 : a.call(t, e)) !== null && o !== void 0 ? o : e.identifier === t.identifier;
}
function vh(e, t) {
  return wt(e, hh(t));
}
function mh(e, t, n) {
  let a = e.calendar.toJulianDay(e), r = _w(t), o = Math.ceil(a + 1 - r) % 7;
  return o < 0 && (o += 7), o;
}
function gw(e) {
  return sa(Date.now(), e);
}
function hh(e) {
  return Cw(gw(e));
}
function gh(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function yw(e, t) {
  return mp(e) - mp(t);
}
function mp(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let bu = null;
function Yr() {
  return bu == null && (bu = new Intl.DateTimeFormat().resolvedOptions().timeZone), bu;
}
function ld(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function hp(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
const gp = /* @__PURE__ */ new Map(), _u = /* @__PURE__ */ new Map();
function bw(e) {
  if (Intl.Locale) {
    let n = gp.get(e);
    return n || (n = new Intl.Locale(e).maximize().region, n && gp.set(e, n)), n;
  }
  let t = e.split("-")[1];
  return t === "u" ? void 0 : t;
}
function _w(e) {
  let t = _u.get(e);
  if (!t) {
    if (Intl.Locale) {
      let a = new Intl.Locale(e);
      if ("getWeekInfo" in a && (t = a.getWeekInfo(), t))
        return _u.set(e, t), t.firstDay;
    }
    let n = bw(e);
    if (e.includes("-fw-")) {
      let a = e.split("-fw-")[1].split("-")[0];
      a === "mon" ? t = {
        firstDay: 1
      } : a === "tue" ? t = {
        firstDay: 2
      } : a === "wed" ? t = {
        firstDay: 3
      } : a === "thu" ? t = {
        firstDay: 4
      } : a === "fri" ? t = {
        firstDay: 5
      } : a === "sat" ? t = {
        firstDay: 6
      } : t = {
        firstDay: 0
      };
    } else e.includes("-ca-iso8601") ? t = {
      firstDay: 1
    } : t = {
      firstDay: n && hw[n] || 0
    };
    _u.set(e, t);
  }
  return t.firstDay;
}
function Rr(e) {
  e = en(e, new An());
  let t = ps(e.era, e.year);
  return yh(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function yh(e, t, n, a, r, o, s) {
  let i = /* @__PURE__ */ new Date();
  return i.setUTCHours(a, r, o, s), i.setUTCFullYear(e, t - 1, n), i.getTime();
}
function id(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === Yr()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: n, month: a, day: r, hour: o, minute: s, second: i } = bh(e, t);
  return yh(n, a, r, o, s, i, 0) - Math.floor(e / 1e3) * 1e3;
}
const yp = /* @__PURE__ */ new Map();
function bh(e, t) {
  let n = yp.get(t);
  n || (n = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), yp.set(t, n));
  let a = n.formatToParts(new Date(e)), r = {};
  for (let o of a) o.type !== "literal" && (r[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: r.era === "BC" || r.era === "B" ? -r.year + 1 : +r.year,
    month: +r.month,
    day: +r.day,
    hour: r.hour === "24" ? 0 : +r.hour,
    minute: +r.minute,
    second: +r.second
  };
}
const bp = 864e5;
function ww(e, t, n, a) {
  return (n === a ? [
    n
  ] : [
    n,
    a
  ]).filter((o) => xw(e, t, o));
}
function xw(e, t, n) {
  let a = bh(n, t);
  return e.year === a.year && e.month === a.month && e.day === a.day && e.hour === a.hour && e.minute === a.minute && e.second === a.second;
}
function oa(e, t, n = "compatible") {
  let a = Vr(e);
  if (t === "UTC") return Rr(a);
  if (t === Yr() && n === "compatible") {
    a = en(a, new An());
    let u = /* @__PURE__ */ new Date(), d = ps(a.era, a.year);
    return u.setFullYear(d, a.month - 1, a.day), u.setHours(a.hour, a.minute, a.second, a.millisecond), u.getTime();
  }
  let r = Rr(a), o = id(r - bp, t), s = id(r + bp, t), i = ww(a, t, r - o, r - s);
  if (i.length === 1) return i[0];
  if (i.length > 1) switch (n) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return i[0];
    case "later":
      return i[i.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (n) {
    case "earlier":
      return Math.min(r - o, r - s);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(r - o, r - s);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function _h(e, t, n = "compatible") {
  return new Date(oa(e, t, n));
}
function sa(e, t) {
  let n = id(e, t), a = new Date(e + n), r = a.getUTCFullYear(), o = a.getUTCMonth() + 1, s = a.getUTCDate(), i = a.getUTCHours(), u = a.getUTCMinutes(), d = a.getUTCSeconds(), c = a.getUTCMilliseconds();
  return new Nr(r < 1 ? "BC" : "AD", r < 1 ? -r + 1 : r, o, s, t, n, i, u, d, c);
}
function Cw(e) {
  return new Ct(e.calendar, e.era, e.year, e.month, e.day);
}
function Vr(e, t) {
  let n = 0, a = 0, r = 0, o = 0;
  if ("timeZone" in e) ({ hour: n, minute: a, second: r, millisecond: o } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: n, minute: a, second: r, millisecond: o } = t), new Fr(e.calendar, e.era, e.year, e.month, e.day, n, a, r, o);
}
function en(e, t) {
  if (pc(e.calendar, t)) return e;
  let n = t.fromJulianDay(e.calendar.toJulianDay(e)), a = e.copy();
  return a.calendar = t, a.era = n.era, a.year = n.year, a.month = n.month, a.day = n.day, er(a), a;
}
function Sw(e, t, n) {
  if (e instanceof Nr)
    return e.timeZone === t ? e : kw(e, t);
  let a = oa(e, t, n);
  return sa(a, t);
}
function $w(e) {
  let t = Rr(e) - e.offset;
  return new Date(t);
}
function kw(e, t) {
  let n = Rr(e) - e.offset;
  return en(sa(n, t), e.calendar);
}
const fo = 36e5;
function hi(e, t) {
  let n = e.copy(), a = "hour" in n ? Mw(n, t) : 0;
  ud(n, t.years || 0), n.calendar.balanceYearMonth && n.calendar.balanceYearMonth(n, e), n.month += t.months || 0, dd(n), wh(n), n.day += (t.weeks || 0) * 7, n.day += t.days || 0, n.day += a, Bw(n), n.calendar.balanceDate && n.calendar.balanceDate(n), n.year < 1 && (n.year = 1, n.month = 1, n.day = 1);
  let r = n.calendar.getYearsInEra(n);
  if (n.year > r) {
    var o, s;
    let u = (o = (s = n.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(s, n);
    n.year = r, n.month = u ? 1 : n.calendar.getMonthsInYear(n), n.day = u ? 1 : n.calendar.getDaysInMonth(n);
  }
  n.month < 1 && (n.month = 1, n.day = 1);
  let i = n.calendar.getMonthsInYear(n);
  return n.month > i && (n.month = i, n.day = n.calendar.getDaysInMonth(n)), n.day = Math.max(1, Math.min(n.calendar.getDaysInMonth(n), n.day)), n;
}
function ud(e, t) {
  var n, a;
  !((n = (a = e.calendar).isInverseEra) === null || n === void 0) && n.call(a, e) && (t = -t), e.year += t;
}
function dd(e) {
  for (; e.month < 1; )
    ud(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, ud(e, 1);
}
function Bw(e) {
  for (; e.day < 1; )
    e.month--, dd(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, dd(e);
}
function wh(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function er(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), wh(e);
}
function xh(e) {
  let t = {};
  for (let n in e) typeof e[n] == "number" && (t[n] = -e[n]);
  return t;
}
function Ch(e, t) {
  return hi(e, xh(t));
}
function vc(e, t) {
  let n = e.copy();
  return t.era != null && (n.era = t.era), t.year != null && (n.year = t.year), t.month != null && (n.month = t.month), t.day != null && (n.day = t.day), er(n), n;
}
function $l(e, t) {
  let n = e.copy();
  return t.hour != null && (n.hour = t.hour), t.minute != null && (n.minute = t.minute), t.second != null && (n.second = t.second), t.millisecond != null && (n.millisecond = t.millisecond), Pw(n), n;
}
function Dw(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = Is(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = Is(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = Is(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = Is(e.hour, 24), t;
}
function Pw(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function Is(e, t) {
  let n = e % t;
  return n < 0 && (n += t), n;
}
function Mw(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, Dw(e);
}
function mc(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "era": {
      let i = e.calendar.getEras(), u = i.indexOf(e.era);
      if (u < 0) throw new Error("Invalid era: " + e.era);
      u = la(u, n, 0, i.length - 1, a?.round), r.era = i[u], er(r);
      break;
    }
    case "year":
      var o, s;
      !((o = (s = r.calendar).isInverseEra) === null || o === void 0) && o.call(s, r) && (n = -n), r.year = la(e.year, n, -1 / 0, 9999, a?.round), r.year === -1 / 0 && (r.year = 1), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, e);
      break;
    case "month":
      r.month = la(e.month, n, 1, e.calendar.getMonthsInYear(e), a?.round);
      break;
    case "day":
      r.day = la(e.day, n, 1, e.calendar.getDaysInMonth(e), a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(r), er(r), r;
}
function Sh(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "hour": {
      let o = e.hour, s = 0, i = 23;
      if (a?.hourCycle === 12) {
        let u = o >= 12;
        s = u ? 12 : 0, i = u ? 23 : 11;
      }
      r.hour = la(o, n, s, i, a?.round);
      break;
    }
    case "minute":
      r.minute = la(e.minute, n, 0, 59, a?.round);
      break;
    case "second":
      r.second = la(e.second, n, 0, 59, a?.round);
      break;
    case "millisecond":
      r.millisecond = la(e.millisecond, n, 0, 999, a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return r;
}
function la(e, t, n, a, r = !1) {
  if (r) {
    e += Math.sign(t), e < n && (e = a);
    let o = Math.abs(t);
    t > 0 ? e = Math.ceil(e / o) * o : e = Math.floor(e / o) * o, e > a && (e = n);
  } else
    e += t, e < n ? e = a - (n - e - 1) : e > a && (e = n + (e - a - 1));
  return e;
}
function $h(e, t) {
  let n;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let r = hi(Vr(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    n = oa(r, e.timeZone);
  } else
    n = Rr(e) - e.offset;
  n += t.milliseconds || 0, n += (t.seconds || 0) * 1e3, n += (t.minutes || 0) * 6e4, n += (t.hours || 0) * 36e5;
  let a = sa(n, e.timeZone);
  return en(a, e.calendar);
}
function qw(e, t) {
  return $h(e, xh(t));
}
function Ew(e, t, n, a) {
  switch (t) {
    case "hour": {
      let r = 0, o = 23;
      if (a?.hourCycle === 12) {
        let m = e.hour >= 12;
        r = m ? 12 : 0, o = m ? 23 : 11;
      }
      let s = Vr(e), i = en($l(s, {
        hour: r
      }), new An()), u = [
        oa(i, e.timeZone, "earlier"),
        oa(i, e.timeZone, "later")
      ].filter((m) => sa(m, e.timeZone).day === i.day)[0], d = en($l(s, {
        hour: o
      }), new An()), c = [
        oa(d, e.timeZone, "earlier"),
        oa(d, e.timeZone, "later")
      ].filter((m) => sa(m, e.timeZone).day === d.day).pop(), f = Rr(e) - e.offset, p = Math.floor(f / fo), v = f % fo;
      return f = la(p, n, Math.floor(u / fo), Math.floor(c / fo), a?.round) * fo + v, en(sa(f, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return Sh(e, t, n, a);
    case "era":
    case "year":
    case "month":
    case "day": {
      let r = mc(Vr(e), t, n, a), o = oa(r, e.timeZone);
      return en(sa(o, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function Tw(e, t, n) {
  let a = Vr(e), r = $l(vc(a, t), t);
  if (r.compare(a) === 0) return e;
  let o = oa(r, e.timeZone, n);
  return en(sa(o, e.timeZone), e.calendar);
}
function Aw(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function kh(e) {
  let t = en(e, new An()), n;
  return t.era === "BC" ? n = t.year === 1 ? "0000" : "-" + String(Math.abs(1 - t.year)).padStart(6, "00") : n = String(t.year).padStart(4, "0"), `${n}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function Bh(e) {
  return `${kh(e)}T${Aw(e)}`;
}
function Iw(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let n = Math.floor(e / 36e5), a = Math.floor(e % 36e5 / 6e4), r = Math.floor(e % 36e5 % 6e4 / 1e3), o = `${t}${String(n).padStart(2, "0")}:${String(a).padStart(2, "0")}`;
  return r !== 0 && (o += `:${String(r).padStart(2, "0")}`), o;
}
function Ow(e) {
  return `${Bh(e)}${Iw(e.offset)}[${e.timeZone}]`;
}
function Rw(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function hc(e, t, n) {
  Rw(e, t), t.set(e, n);
}
function gc(e) {
  let t = typeof e[0] == "object" ? e.shift() : new An(), n;
  if (typeof e[0] == "string") n = e.shift();
  else {
    let s = t.getEras();
    n = s[s.length - 1];
  }
  let a = e.shift(), r = e.shift(), o = e.shift();
  return [
    t,
    n,
    a,
    r,
    o
  ];
}
var Vw = /* @__PURE__ */ new WeakMap();
class Ct {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Ct(this.calendar, this.era, this.year, this.month, this.day) : new Ct(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return hi(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return Ch(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return vc(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return mc(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return _h(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return kh(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return gh(this, t);
  }
  constructor(...t) {
    hc(this, Vw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = gc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, er(this);
  }
}
var Fw = /* @__PURE__ */ new WeakMap();
class Fr {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Fr(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new Fr(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return hi(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return Ch(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return vc($l(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return mc(this, t, n, a);
      default:
        return Sh(this, t, n, a);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, n) {
    return _h(this, t, n);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Bh(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let n = gh(this, t);
    return n === 0 ? yw(this, Vr(t)) : n;
  }
  constructor(...t) {
    hc(this, Fw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = gc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, er(this);
  }
}
var Nw = /* @__PURE__ */ new WeakMap();
class Nr {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Nr(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new Nr(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return $h(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return qw(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, n) {
    return Tw(this, t, n);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return Ew(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return $w(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return Ow(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - Sw(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    hc(this, Nw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = gc(t), i = t.shift(), u = t.shift();
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.timeZone = i, this.offset = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, er(this);
  }
}
const Mr = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], Lw = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], ll = [
  1867,
  1911,
  1925,
  1988,
  2018
], ka = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function _p(e) {
  const t = Mr.findIndex(([n, a, r]) => e.year < n || e.year === n && e.month < a || e.year === n && e.month === a && e.day < r);
  return t === -1 ? Mr.length - 1 : t === 0 ? 0 : t - 1;
}
function wu(e) {
  let t = ll[ka.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new Ct(e.year + t, e.month, e.day);
}
class zw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = _p(n);
    return new Ct(this, ka[a], n.year - ll[a], n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(wu(t));
  }
  balanceDate(t) {
    let n = wu(t), a = _p(n);
    ka[a] !== t.era && (t.era = ka[a], t.year = n.year - ll[a]), this.constrainDate(t);
  }
  constrainDate(t) {
    let n = ka.indexOf(t.era), a = Lw[n];
    if (a != null) {
      let [r, o, s] = a, i = r - ll[n];
      t.year = Math.max(1, Math.min(i, t.year)), t.year === i && (t.month = Math.min(o, t.month), t.month === o && (t.day = Math.min(s, t.day)));
    }
    if (t.year === 1 && n >= 0) {
      let [, r, o] = Mr[n];
      t.month = Math.max(r, t.month), t.month === r && (t.day = Math.max(o, t.day));
    }
  }
  getEras() {
    return ka;
  }
  getYearsInEra(t) {
    let n = ka.indexOf(t.era), a = Mr[n], r = Mr[n + 1];
    if (r == null)
      return 9999 - a[0] + 1;
    let o = r[0] - a[0];
    return (t.month < r[1] || t.month === r[1] && t.day < r[2]) && o++, o;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(wu(t));
  }
  getMinimumMonthInYear(t) {
    let n = wp(t);
    return n ? n[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let n = wp(t);
    return n && t.month === n[1] ? n[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function wp(e) {
  if (e.year === 1) {
    let t = ka.indexOf(e.era);
    return Mr[t];
  }
}
const Dh = -543;
class Hw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ps(n.era, n.year);
    return new Ct(this, a - Dh, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(xp(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(xp(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function xp(e) {
  let [t, n] = mi(e.year + Dh);
  return new Ct(t, n, e.month, e.day);
}
const kl = 1911;
function Ph(e) {
  return e.era === "minguo" ? e.year + kl : 1 - e.year + kl;
}
function Cp(e) {
  let t = e - kl;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class Uw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ps(n.era, n.year), [r, o] = Cp(a);
    return new Ct(this, r, o, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Sp(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [n, a] = Cp(Ph(t));
    t.era = n, t.year = a;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Sp(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - kl;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function Sp(e) {
  let [t, n] = mi(Ph(e));
  return new Ct(t, n, e.month, e.day);
}
const $p = 1948320, kp = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class jw {
  fromJulianDay(t) {
    let n = t - $p, a = 1 + Math.floor((33 * n + 3) / 12053), r = 365 * (a - 1) + Math.floor((8 * a + 21) / 33), o = n - r, s = o < 216 ? Math.floor(o / 31) : Math.floor((o - 6) / 30), i = o - kp[s] + 1;
    return new Ct(this, a, s + 1, i);
  }
  toJulianDay(t) {
    let n = $p - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return n += kp[t.month - 1], n += t.day, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || Pr(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const xu = 78, Bp = 80;
class Ww extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = n.year - xu, r = t - Ka(n.era, n.year, 1, 1), o;
    r < Bp ? (a--, o = Ma(n.year - 1) ? 31 : 30, r += o + 155 + 90 + 10) : (o = Ma(n.year) ? 31 : 30, r -= Bp);
    let s, i;
    if (r < o)
      s = 1, i = r + 1;
    else {
      let u = r - o;
      u < 155 ? (s = Math.floor(u / 31) + 2, i = u % 31 + 1) : (u -= 155, s = Math.floor(u / 30) + 7, i = u % 30 + 1);
    }
    return new Ct(this, a, s, i);
  }
  toJulianDay(t) {
    let n = t.year + xu, [a, r] = mi(n), o, s;
    return Ma(r) ? (o = 31, s = Ka(a, r, 3, 21)) : (o = 30, s = Ka(a, r, 3, 22)), t.month === 1 ? s + t.day - 1 : (s += o + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (s += (t.month - 7) * 30), s += t.day - 1, s);
  }
  getDaysInMonth(t) {
    return t.month === 1 && Ma(t.year + xu) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const Bl = 1948440, Dp = 1948439, wn = 1300, _r = 1600, Gw = 460322;
function Dl(e, t, n, a) {
  return a + Math.ceil(29.5 * (n - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function Mh(e, t, n) {
  let a = Math.floor((30 * (n - t) + 10646) / 10631), r = Math.min(12, Math.ceil((n - (29 + Dl(t, a, 1, 1))) / 29.5) + 1), o = n - Dl(t, a, r, 1) + 1;
  return new Ct(e, a, r, o);
}
function Pp(e) {
  return (14 + 11 * e) % 30 < 11;
}
class yc {
  fromJulianDay(t) {
    return Mh(this, Bl, t);
  }
  toJulianDay(t) {
    return Dl(Bl, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = 29 + t.month % 2;
    return t.month === 12 && Pp(t.year) && n++, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return Pp(t.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class Kw extends yc {
  fromJulianDay(t) {
    return Mh(this, Dp, t);
  }
  toJulianDay(t) {
    return Dl(Dp, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const Yw = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let cd, qr;
function il(e) {
  return Gw + qr[e - wn];
}
function xo(e, t) {
  let n = e - wn, a = 1 << 11 - (t - 1);
  return (cd[n] & a) === 0 ? 29 : 30;
}
function Mp(e, t) {
  let n = il(e);
  for (let a = 1; a < t; a++) n += xo(e, a);
  return n;
}
function qp(e) {
  return qr[e + 1 - wn] - qr[e - wn];
}
class Xw extends yc {
  fromJulianDay(t) {
    let n = t - Bl, a = il(wn), r = il(_r);
    if (n < a || n > r) return super.fromJulianDay(t);
    {
      let o = wn - 1, s = 1, i = 1;
      for (; i > 0; ) {
        o++, i = n - il(o) + 1;
        let u = qp(o);
        if (i === u) {
          s = 12;
          break;
        } else if (i < u) {
          let d = xo(o, s);
          for (s = 1; i > d; )
            i -= d, s++, d = xo(o, s);
          break;
        }
      }
      return new Ct(this, o, s, n - Mp(o, s) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < wn || t.year > _r ? super.toJulianDay(t) : Bl + Mp(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < wn || t.year > _r ? super.getDaysInMonth(t) : xo(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < wn || t.year > _r ? super.getDaysInYear(t) : qp(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", cd || (cd = new Uint16Array(Uint8Array.from(atob(Yw), (t) => t.charCodeAt(0)).buffer)), !qr) {
      qr = new Uint32Array(_r - wn + 1);
      let t = 0;
      for (let n = wn; n <= _r; n++) {
        qr[n - wn] = t;
        for (let a = 1; a <= 12; a++) t += xo(n, a);
      }
    }
  }
}
const Ep = 347997, qh = 1080, Eh = 24 * qh, Jw = 29, Zw = 12 * qh + 793, Qw = Jw * Eh + Zw;
function Ga(e) {
  return Pr(e * 7 + 1, 19) < 7;
}
function ul(e) {
  let t = Math.floor((235 * e - 234) / 19), n = 12084 + 13753 * t, a = t * 29 + Math.floor(n / 25920);
  return Pr(3 * (a + 1), 7) < 3 && (a += 1), a;
}
function e1(e) {
  let t = ul(e - 1), n = ul(e);
  return ul(e + 1) - n === 356 ? 2 : n - t === 382 ? 1 : 0;
}
function Mo(e) {
  return ul(e) + e1(e);
}
function Th(e) {
  return Mo(e + 1) - Mo(e);
}
function t1(e) {
  let t = Th(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    // deficient
    case 354:
      return 1;
    // normal
    case 355:
      return 2;
  }
}
function Os(e, t) {
  if (t >= 6 && !Ga(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let n = t1(e);
  return t === 2 ? n === 2 ? 30 : 29 : t === 3 ? n === 0 ? 29 : 30 : t === 6 ? Ga(e) ? 30 : 0 : 30;
}
class n1 {
  fromJulianDay(t) {
    let n = t - Ep, a = n * Eh / Qw, r = Math.floor((19 * a + 234) / 235) + 1, o = Mo(r), s = Math.floor(n - o);
    for (; s < 1; )
      r--, o = Mo(r), s = Math.floor(n - o);
    let i = 1, u = 0;
    for (; u < s; )
      u += Os(r, i), i++;
    i--, u -= Os(r, i);
    let d = s - u;
    return new Ct(this, r, i, d);
  }
  toJulianDay(t) {
    let n = Mo(t.year);
    for (let a = 1; a < t.month; a++) n += Os(t.year, a);
    return n + t.day + Ep;
  }
  getDaysInMonth(t) {
    return Os(t.year, t.month);
  }
  getMonthsInYear(t) {
    return Ga(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return Th(t.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, n) {
    n.year !== t.year && (Ga(n.year) && !Ga(t.year) && n.month > 6 ? t.month-- : !Ga(n.year) && Ga(t.year) && n.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const fd = 1723856, Tp = 1824665, pd = 5500;
function Pl(e, t, n, a) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (n - 1) + a - 1;
}
function bc(e, t) {
  let n = Math.floor(4 * (t - e) / 1461), a = 1 + Math.floor((t - Pl(e, n, 1, 1)) / 30), r = t + 1 - Pl(e, n, a, 1);
  return [
    n,
    a,
    r
  ];
}
function Ah(e) {
  return Math.floor(e % 4 / 3);
}
function Ih(e, t) {
  return t % 13 !== 0 ? 30 : Ah(e) + 5;
}
class _c {
  fromJulianDay(t) {
    let [n, a, r] = bc(fd, t), o = "AM";
    return n <= 0 && (o = "AA", n += pd), new Ct(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "AA" && (n -= pd), Pl(fd, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    return Ih(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + Ah(t.year);
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class a1 extends _c {
  fromJulianDay(t) {
    let [n, a, r] = bc(fd, t);
    return n += pd, new Ct(this, "AA", n, a, r);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class r1 extends _c {
  fromJulianDay(t) {
    let [n, a, r] = bc(Tp, t), o = "CE";
    return n <= 0 && (o = "BCE", n = 1 - n), new Ct(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Pl(Tp, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Ih(n, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function o1(e) {
  switch (e) {
    case "buddhist":
      return new Hw();
    case "ethiopic":
      return new _c();
    case "ethioaa":
      return new a1();
    case "coptic":
      return new r1();
    case "hebrew":
      return new n1();
    case "indian":
      return new Ww();
    case "islamic-civil":
      return new yc();
    case "islamic-tbla":
      return new Kw();
    case "islamic-umalqura":
      return new Xw();
    case "japanese":
      return new zw();
    case "persian":
      return new jw();
    case "roc":
      return new Uw();
    default:
      return new An();
  }
}
let Cu = /* @__PURE__ */ new Map();
class aa {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)}  ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.formatter.formatToParts(t), r = this.formatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return i1() && (this.resolvedHourCycle || (this.resolvedHourCycle = u1(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, n = {}) {
    this.formatter = Oh(t, n), this.options = n;
  }
}
const s1 = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function Oh(e, t = {}) {
  if (typeof t.hour12 == "boolean" && l1()) {
    t = {
      ...t
    };
    let r = s1[String(t.hour12)][e.split("-")[0]], o = t.hour12 ? "h12" : "h23";
    t.hourCycle = r ?? o, delete t.hour12;
  }
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : "");
  if (Cu.has(n)) return Cu.get(n);
  let a = new Intl.DateTimeFormat(e, t);
  return Cu.set(n, a), a;
}
let Su = null;
function l1() {
  return Su == null && (Su = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), Su;
}
let $u = null;
function i1() {
  return $u == null && ($u = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), $u;
}
function u1(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = Oh(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), a = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), r = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (a === 0 && r === 23) return "h23";
  if (a === 24 && r === 23) return "h24";
  if (a === 0 && r === 11) return "h11";
  if (a === 12 && r === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function Bn(e, t = Yr()) {
  return wc(e) ? e.toDate() : e.toDate(t);
}
function d1(e) {
  return e instanceof Fr;
}
function wc(e) {
  return e instanceof Nr;
}
function c1(e) {
  return d1(e) || wc(e);
}
function No(e) {
  if (e instanceof Date) {
    const t = e.getFullYear(), n = e.getMonth() + 1;
    return new Date(t, n, 0).getDate();
  } else return e.set({ day: 100 }).day;
}
function Za(e, t) {
  return e.compare(t) < 0;
}
function dl(e, t) {
  return e.compare(t) > 0;
}
function f1(e, t) {
  return e.compare(t) <= 0;
}
function p1(e, t) {
  return e.compare(t) >= 0;
}
function v1(e, t, n) {
  return p1(e, t) && f1(e, n);
}
function ku(e, t, n) {
  return dl(e, t) && Za(e, n);
}
function m1(e, t, n) {
  const a = mh(e, n);
  return t > a ? e.subtract({ days: a + 7 - t }) : t === a ? e : e.subtract({ days: a - t });
}
function h1(e, t, n) {
  const a = mh(e, n), r = t === 0 ? 6 : t - 1;
  return a === r ? e : a > r ? e.add({ days: 7 - a + r }) : e.add({ days: r - a });
}
function g1(e, t, n, a, r) {
  if (n === void 0 && a === void 0 && r === void 0) return !0;
  let o = e.add({ days: 1 });
  if ((a?.(o) || n?.(o)) && !r?.(o)) return !1;
  const s = t;
  for (; o.compare(s) < 0; )
    if (o = o.add({ days: 1 }), (a?.(o) || n?.(o)) && !r?.(o)) return !1;
  return !0;
}
function Rh(e) {
  const { defaultValue: t, defaultPlaceholder: n, granularity: a = "day", locale: r = "en" } = e;
  if (Array.isArray(t) && t.length) return t.at(-1).copy();
  if (t && !Array.isArray(t)) return t.copy();
  if (n) return n.copy();
  const o = /* @__PURE__ */ new Date(), s = o.getFullYear(), i = o.getMonth() + 1, u = o.getDate(), d = [
    "hour",
    "minute",
    "second"
  ], c = new aa(r), f = o1(c.resolvedOptions().calendar);
  return d.includes(a ?? "day") ? en(new Fr(s, i, u, 0, 0, 0), f) : en(new Ct(s, i, u), f);
}
function y1(e, t) {
  const n = [];
  for (let a = 0; a < e.length; a += t) n.push(e.slice(a, a + t));
  return n;
}
function Vh(e) {
  const t = e.querySelector("[data-selected]");
  if (t) return t.focus();
  const n = e.querySelector("[data-today]");
  if (n) return n.focus();
  const a = e.querySelector("[data-reka-calendar-day]");
  if (a) return a.focus();
}
function vd(e, t) {
  const n = [];
  let a = e.add({ days: 1 });
  const r = t;
  for (; a.compare(r) < 0; )
    n.push(a), a = a.add({ days: 1 });
  return n;
}
function Bu(e) {
  const { dateObj: t, weekStartsOn: n, fixedWeeks: a, locale: r } = e, o = No(t), s = Array.from({ length: o }, (w, C) => t.set({ day: C + 1 })), i = ld(t), u = hp(t), d = m1(i, n, r), c = h1(u, n, r), f = vd(d.subtract({ days: 1 }), i), p = vd(u, c.add({ days: 1 })), v = f.length + s.length + p.length;
  if (a && v < 42) {
    const w = 42 - v;
    let C = p[p.length - 1];
    C || (C = hp(t));
    const S = Array.from({ length: w }, ($, B) => {
      const k = B + 1;
      return C.add({ days: k });
    });
    p.push(...S);
  }
  const m = f.concat(s, p), g = y1(m, 7);
  return {
    value: t,
    cells: m,
    rows: g
  };
}
function Ha(e) {
  const { numberOfMonths: t, dateObj: n, ...a } = e, r = [];
  if (!t || t === 1)
    return r.push(Bu({
      ...a,
      dateObj: n
    })), r;
  r.push(Bu({
    ...a,
    dateObj: n
  }));
  for (let o = 1; o < t; o++) {
    const s = n.add({ months: o });
    r.push(Bu({
      ...a,
      dateObj: s
    }));
  }
  return r;
}
function b1(e, t = {}) {
  const n = I(e);
  function a() {
    return n.value;
  }
  function r(w) {
    n.value = w;
  }
  function o(w, C) {
    return new aa(n.value, {
      ...t,
      ...C
    }).format(w);
  }
  function s(w, C = !0) {
    return c1(w) && C ? o(Bn(w), {
      dateStyle: "long",
      timeStyle: "long"
    }) : o(Bn(w), { dateStyle: "long" });
  }
  function i(w, C = {}) {
    return new aa(n.value, {
      ...t,
      month: "long",
      year: "numeric",
      ...C
    }).format(w);
  }
  function u(w, C = {}) {
    return new aa(n.value, {
      ...t,
      month: "long",
      ...C
    }).format(w);
  }
  function d() {
    const w = hh(Yr());
    return [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12
    ].map((S) => ({
      label: u(Bn(w.set({ month: S }))),
      value: S
    }));
  }
  function c(w, C = {}) {
    return new aa(n.value, {
      ...t,
      year: "numeric",
      ...C
    }).format(w);
  }
  function f(w, C) {
    return wc(w) ? new aa(n.value, {
      ...t,
      ...C,
      timeZone: w.timeZone
    }).formatToParts(Bn(w)) : new aa(n.value, {
      ...t,
      ...C
    }).formatToParts(Bn(w));
  }
  function p(w, C = "narrow") {
    return new aa(n.value, {
      ...t,
      weekday: C
    }).format(w);
  }
  function v(w) {
    const S = new aa(n.value, {
      ...t,
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(w).find(($) => $.type === "dayPeriod")?.value;
    return S === "PM" || S === "p.m." ? "PM" : "AM";
  }
  const m = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function g(w, C, S = {}) {
    const $ = {
      ...m,
      ...S
    }, k = f(w, $).find((P) => P.type === C);
    return k ? k.value : "";
  }
  return {
    setLocale: r,
    getLocale: a,
    fullMonth: u,
    fullYear: c,
    fullMonthAndYear: i,
    toParts: f,
    custom: o,
    part: g,
    dayPeriod: v,
    selectedDate: s,
    dayOfWeek: p,
    getMonths: d
  };
}
function yt(e) {
  const t = us({ dir: I("ltr") });
  return E(() => e?.value || t.dir?.value || "ltr");
}
function Kt(e) {
  const t = ht(), n = t?.type.emits, a = {};
  return n?.length || console.warn(`No emitted event found. Please check component: ${t?.type.__name}`), n?.forEach((r) => {
    a[m0(xl(r))] = (...o) => e(r, ...o);
  }), a;
}
function Fh(e) {
  const t = E(() => l(e)), n = E(() => new Intl.Collator("en", {
    usage: "search",
    ...t.value
  }));
  return {
    startsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(0, i.length), i) === 0),
    endsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(-i.length), i) === 0),
    contains: (s, i) => {
      if (i.length === 0) return !0;
      s = s.normalize("NFC"), i = i.normalize("NFC");
      let u = 0;
      const d = i.length;
      for (; u + d <= s.length; u++) {
        const c = s.slice(u, u + d);
        if (n.value.compare(i, c) === 0) return !0;
      }
      return !1;
    }
  };
}
let Du = 0;
function xc() {
  Ie((e) => {
    if (!rn) return;
    const t = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", t[0] ?? Ap()), document.body.insertAdjacentElement("beforeend", t[1] ?? Ap()), Du++, e(() => {
      Du === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((n) => n.remove()), Du--;
    });
  });
}
function Ap() {
  const e = document.createElement("span");
  return e.setAttribute("data-reka-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
function Rn(e) {
  return E(() => fe(e) ? !!Gt(e)?.closest("form") : !0);
}
function j() {
  const e = ht(), t = I(), n = E(() => ["#text", "#comment"].includes(t.value?.$el.nodeName) ? t.value?.$el.nextElementSibling : Gt(t)), a = Object.assign({}, e.exposed), r = {};
  for (const s in e.props) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[s]
  });
  if (Object.keys(a).length > 0) for (const s in a) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => a[s]
  });
  Object.defineProperty(r, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = r;
  function o(s) {
    if (t.value = s, !!s && (Object.defineProperty(r, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s instanceof Element ? s : s.$el
    }), !(s instanceof Element) && !Object.hasOwn(s, "$el"))) {
      const i = s.$.exposed, u = Object.assign({}, r);
      for (const d in i) Object.defineProperty(u, d, {
        enumerable: !0,
        configurable: !0,
        get: () => i[d]
      });
      e.exposed = u;
    }
  }
  return {
    forwardRef: o,
    currentRef: t,
    currentElement: n
  };
}
function he(e) {
  const t = ht(), n = Object.keys(t?.type.props ?? {}).reduce((r, o) => {
    const s = (t?.type.props[o]).default;
    return s !== void 0 && (r[o] = s), r;
  }, {}), a = jn(e);
  return E(() => {
    const r = {}, o = t?.vnode.props ?? {};
    return Object.keys(o).forEach((s) => {
      r[xl(s)] = o[s];
    }), Object.keys({
      ...n,
      ...r
    }).reduce((s, i) => (a.value[i] !== void 0 && (s[i] = a.value[i]), s), {});
  });
}
function me(e, t) {
  const n = he(e), a = t ? Kt(t) : {};
  return E(() => ({
    ...n.value,
    ...a
  }));
}
function Nh(e, t) {
  const n = cs(!1, 300);
  ga(() => {
    n.value = !1;
  });
  const a = I(null), r = Dr();
  function o() {
    a.value = null, n.value = !1;
  }
  function s(i, u) {
    const d = i.currentTarget, c = {
      x: i.clientX,
      y: i.clientY
    }, f = _1(c, d.getBoundingClientRect()), p = w1(c, f), v = x1(u.getBoundingClientRect()), m = S1([...p, ...v]);
    a.value = m, n.value = !0;
  }
  return Ie((i) => {
    if (e.value && t.value) {
      const u = (c) => s(c, t.value), d = (c) => s(c, e.value);
      e.value.addEventListener("pointerleave", u), t.value.addEventListener("pointerleave", d), i(() => {
        e.value?.removeEventListener("pointerleave", u), t.value?.removeEventListener("pointerleave", d);
      });
    }
  }), Ie((i) => {
    if (a.value) {
      const u = (d) => {
        if (!a.value || !(d.target instanceof Element)) return;
        const c = d.target, f = {
          x: d.clientX,
          y: d.clientY
        }, p = e.value?.contains(c) || t.value?.contains(c), v = !C1(f, a.value), m = !!c.closest("[data-grace-area-trigger]");
        p ? o() : (v || m) && (o(), r.trigger());
      };
      e.value?.ownerDocument.addEventListener("pointermove", u), i(() => e.value?.ownerDocument.removeEventListener("pointermove", u));
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: r.on
  };
}
function _1(e, t) {
  const n = Math.abs(t.top - e.y), a = Math.abs(t.bottom - e.y), r = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, a, r, o)) {
    case o:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case a:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function w1(e, t, n = 5) {
  const a = [];
  switch (t) {
    case "top":
      a.push({
        x: e.x - n,
        y: e.y + n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "bottom":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y - n
      });
      break;
    case "left":
      a.push({
        x: e.x + n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "right":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x - n,
        y: e.y + n
      });
      break;
  }
  return a;
}
function x1(e) {
  const { top: t, right: n, bottom: a, left: r } = e;
  return [
    {
      x: r,
      y: t
    },
    {
      x: n,
      y: t
    },
    {
      x: n,
      y: a
    },
    {
      x: r,
      y: a
    }
  ];
}
function C1(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function S1(e) {
  const t = e.slice();
  return t.sort((n, a) => n.x < a.x ? -1 : n.x > a.x ? 1 : n.y < a.y ? -1 : n.y > a.y ? 1 : 0), $1(t);
}
function $1(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) t.pop();
      else break;
    }
    t.push(r);
  }
  t.pop();
  const n = [];
  for (let a = e.length - 1; a >= 0; a--) {
    const r = e[a];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) n.pop();
      else break;
    }
    n.push(r);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var k1 = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, wr = /* @__PURE__ */ new WeakMap(), Rs = /* @__PURE__ */ new WeakMap(), Vs = {}, Pu = 0, Lh = function(e) {
  return e && (e.host || Lh(e.parentNode));
}, B1 = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var a = Lh(n);
    return a && e.contains(a) ? a : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, D1 = function(e, t, n, a) {
  var r = B1(t, Array.isArray(e) ? e : [e]);
  Vs[n] || (Vs[n] = /* @__PURE__ */ new WeakMap());
  var o = Vs[n], s = [], i = /* @__PURE__ */ new Set(), u = new Set(r), d = function(f) {
    !f || i.has(f) || (i.add(f), d(f.parentNode));
  };
  r.forEach(d);
  var c = function(f) {
    !f || u.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (i.has(p))
        c(p);
      else
        try {
          var v = p.getAttribute(a), m = v !== null && v !== "false", g = (wr.get(p) || 0) + 1, w = (o.get(p) || 0) + 1;
          wr.set(p, g), o.set(p, w), s.push(p), g === 1 && m && Rs.set(p, !0), w === 1 && p.setAttribute(n, "true"), m || p.setAttribute(a, "true");
        } catch (C) {
          console.error("aria-hidden: cannot operate on ", p, C);
        }
    });
  };
  return c(t), i.clear(), Pu++, function() {
    s.forEach(function(f) {
      var p = wr.get(f) - 1, v = o.get(f) - 1;
      wr.set(f, p), o.set(f, v), p || (Rs.has(f) || f.removeAttribute(a), Rs.delete(f)), v || f.removeAttribute(n);
    }), Pu--, Pu || (wr = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), Rs = /* @__PURE__ */ new WeakMap(), Vs = {});
  };
}, P1 = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), r = k1(e);
  return r ? (a.push.apply(a, Array.from(r.querySelectorAll("[aria-live], script"))), D1(a, r, n, "aria-hidden")) : function() {
    return null;
  };
};
function vs(e) {
  let t;
  ve(() => Gt(e), (n) => {
    n ? t = P1(n) : t && t();
  }), Qe(() => {
    t && t();
  });
}
let M1 = 0;
function Ge(e, t = "reka") {
  if (e) return e;
  if ("useId" in lp) return `${t}-${lp.useId?.()}`;
  const n = us({ useId: void 0 });
  return n.useId ? `${t}-${n.useId()}` : `${t}-${++M1}`;
}
function ms() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function Cc(e) {
  const t = us({ locale: I("en") });
  return E(() => e?.value || t.locale?.value || "en");
}
function zh(e) {
  const t = I(), n = E(() => t.value?.width ?? 0), a = E(() => t.value?.height ?? 0);
  return Ce(() => {
    const r = Gt(e);
    if (r) {
      t.value = {
        width: r.offsetWidth,
        height: r.offsetHeight
      };
      const o = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length) return;
        const i = s[0];
        let u, d;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          u = f.inlineSize, d = f.blockSize;
        } else
          u = r.offsetWidth, d = r.offsetHeight;
        t.value = {
          width: u,
          height: d
        };
      });
      return o.observe(r, { box: "border-box" }), () => o.unobserve(r);
    } else t.value = void 0;
  }), {
    width: n,
    height: a
  };
}
function Hh(e, t) {
  const n = I(e);
  function a(o) {
    return t[n.value][o] ?? n.value;
  }
  return {
    state: n,
    dispatch: (o) => {
      n.value = a(o);
    }
  };
}
function gi(e) {
  const t = cs("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (r, o) => {
      t.value = t.value + r;
      {
        const s = ot(), i = o.map((p) => ({
          ...p,
          textValue: p.value?.textValue ?? p.ref.textContent?.trim() ?? ""
        })), u = i.find((p) => p.ref === s), d = i.map((p) => p.textValue), c = q1(d, t.value, u?.textValue), f = i.find((p) => p.textValue === c);
        return f && f.ref.focus(), f?.ref;
      }
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function Sc(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
function q1(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = Sc(e, Math.max(o, 0));
  r.length === 1 && (s = s.filter((d) => d !== n));
  const u = s.find((d) => d.toLowerCase().startsWith(r.toLowerCase()));
  return u !== n ? u : void 0;
}
function E1(e, t) {
  const n = I({}), a = I("none"), r = I(e), o = e.value ? "mounted" : "unmounted";
  let s;
  const i = t.value?.ownerDocument.defaultView ?? Ra, { state: u, dispatch: d } = Hh(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), c = (w) => {
    if (rn) {
      const C = new CustomEvent(w, {
        bubbles: !1,
        cancelable: !1
      });
      t.value?.dispatchEvent(C);
    }
  };
  ve(e, async (w, C) => {
    const S = C !== w;
    if (await ke(), S) {
      const $ = a.value, B = Fs(t.value);
      w ? (d("MOUNT"), c("enter"), B === "none" && c("after-enter")) : B === "none" || B === "undefined" || n.value?.display === "none" ? (d("UNMOUNT"), c("leave"), c("after-leave")) : C && $ !== B ? (d("ANIMATION_OUT"), c("leave")) : (d("UNMOUNT"), c("after-leave"));
    }
  }, { immediate: !0 });
  const f = (w) => {
    const C = Fs(t.value), S = C.includes(CSS.escape(w.animationName)), $ = u.value === "mounted" ? "enter" : "leave";
    if (w.target === t.value && S && (c(`after-${$}`), d("ANIMATION_END"), !r.value)) {
      const B = t.value.style.animationFillMode;
      t.value.style.animationFillMode = "forwards", s = i?.setTimeout(() => {
        t.value?.style.animationFillMode === "forwards" && (t.value.style.animationFillMode = B);
      });
    }
    w.target === t.value && C === "none" && d("ANIMATION_END");
  }, p = (w) => {
    w.target === t.value && (a.value = Fs(t.value));
  }, v = ve(t, (w, C) => {
    w ? (n.value = getComputedStyle(w), w.addEventListener("animationstart", p), w.addEventListener("animationcancel", f), w.addEventListener("animationend", f)) : (d("ANIMATION_END"), s !== void 0 && i?.clearTimeout(s), C?.removeEventListener("animationstart", p), C?.removeEventListener("animationcancel", f), C?.removeEventListener("animationend", f));
  }, { immediate: !0 }), m = ve(u, () => {
    const w = Fs(t.value);
    a.value = u.value === "mounted" ? w : "none";
  });
  return Qe(() => {
    v(), m();
  }), { isPresent: E(() => ["mounted", "unmountSuspended"].includes(u.value)) };
}
function Fs(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var St = b({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: t, expose: n }) {
    const { present: a, forceMount: r } = Me(e), o = I(), { isPresent: s } = E1(a, o);
    n({ present: s });
    let i = t.default({ present: s.value });
    i = ic(i || []);
    const u = ht();
    if (i && i?.length > 1) {
      const d = u?.parent?.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${d}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((c) => `  - ${c}`).join(`
`)
      ].join(`
`));
    }
    return () => r.value || a.value || s.value ? an(t.default({ present: s.value })[0], { ref: (d) => {
      const c = Gt(d);
      return typeof c?.hasAttribute > "u" || (c?.hasAttribute("data-reka-popper-content-wrapper") ? o.value = c.firstElementChild : o.value = c), c;
    } }) : null;
  }
});
const Ml = b({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: t, slots: n }) {
    return () => {
      if (!n.default) return null;
      const a = ic(n.default()), r = a.findIndex((u) => u.type !== h0);
      if (r === -1) return a;
      const o = a[r];
      delete o.props?.ref;
      const s = o.props ? A(t, o.props) : t, i = g0({
        ...o,
        props: {}
      }, s);
      return a.length === 1 ? i : (a[r] = i, a);
    };
  }
}), T1 = [
  "area",
  "img",
  "input"
], X = b({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: t, slots: n }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && T1.includes(a) ? () => an(a, t) : a !== "template" ? () => an(e.as, t, { default: n.default }) : () => an(Ml, t, { default: n.default });
  }
});
function Ht() {
  const e = I(), t = E(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : Gt(e));
  return {
    primitiveElement: e,
    currentElement: t
  };
}
const [Uh, A1] = Be("CollapsibleRoot");
var I1 = /* @__PURE__ */ b({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = Ve(a, "open", n, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), { disabled: s, unmountOnHide: i } = Me(a);
    return A1({
      contentId: "",
      disabled: s,
      open: o,
      unmountOnHide: i,
      onOpenToggle: () => {
        s.value || (o.value = !o.value);
      }
    }), t({ open: o }), j(), (u, d) => (h(), x(l(X), {
      as: u.as,
      "as-child": a.asChild,
      "data-state": l(o) ? "open" : "closed",
      "data-disabled": l(s) ? "" : void 0
    }, {
      default: y(() => [_(u.$slots, "default", { open: l(o) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ]));
  }
}), jh = I1, O1 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["contentFound"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Uh();
    r.contentId ||= Ge(void 0, "reka-collapsible-content");
    const o = I(), { forwardRef: s, currentElement: i } = j(), u = I(0), d = I(0), c = E(() => r.open.value), f = I(c.value), p = I();
    ve(() => [c.value, o.value?.present], async () => {
      await ke();
      const m = i.value;
      if (!m) return;
      p.value = p.value || {
        transitionDuration: m.style.transitionDuration,
        animationName: m.style.animationName
      }, m.style.transitionDuration = "0s", m.style.animationName = "none";
      const g = m.getBoundingClientRect();
      d.value = g.height, u.value = g.width, f.value || (m.style.transitionDuration = p.value.transitionDuration, m.style.animationName = p.value.animationName);
    }, { immediate: !0 });
    const v = E(() => f.value && r.open.value);
    return Ce(() => {
      requestAnimationFrame(() => {
        f.value = !1;
      });
    }), zt(i, "beforematch", (m) => {
      requestAnimationFrame(() => {
        r.onOpenToggle(), a("contentFound");
      });
    }), (m, g) => (h(), x(l(St), {
      ref_key: "presentRef",
      ref: o,
      present: m.forceMount || l(r).open.value,
      "force-mount": !0
    }, {
      default: y(({ present: w }) => [N(l(X), A(m.$attrs, {
        id: l(r).contentId,
        ref: l(s),
        "as-child": n.asChild,
        as: m.as,
        hidden: w ? void 0 : l(r).unmountOnHide.value ? "" : "until-found",
        "data-state": v.value ? void 0 : l(r).open.value ? "open" : "closed",
        "data-disabled": l(r).disabled?.value ? "" : void 0,
        style: {
          "--reka-collapsible-content-height": `${d.value}px`,
          "--reka-collapsible-content-width": `${u.value}px`
        }
      }), {
        default: y(() => [!l(r).unmountOnHide.value || w ? _(m.$slots, "default", { key: 0 }) : Ee("v-if", !0)]),
        _: 2
      }, 1040, [
        "id",
        "as-child",
        "as",
        "hidden",
        "data-state",
        "data-disabled",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Wh = O1, R1 = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Uh();
    return (a, r) => (h(), x(l(X), {
      type: a.as === "button" ? "button" : void 0,
      as: a.as,
      "as-child": t.asChild,
      "aria-controls": l(n).contentId,
      "aria-expanded": l(n).open.value,
      "data-state": l(n).open.value ? "open" : "closed",
      "data-disabled": l(n).disabled?.value ? "" : void 0,
      disabled: l(n).disabled?.value,
      onClick: l(n).onOpenToggle
    }, {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "aria-controls",
      "aria-expanded",
      "data-state",
      "data-disabled",
      "disabled",
      "onClick"
    ]));
  }
}), Gh = R1;
function V1({ type: e, defaultValue: t, modelValue: n }) {
  const a = n || t;
  return n !== void 0 || t !== void 0 ? Array.isArray(a) ? "multiple" : "single" : e ?? "single";
}
function F1({ type: e, defaultValue: t, modelValue: n }) {
  return e || V1({
    type: e,
    defaultValue: t,
    modelValue: n
  });
}
function N1({ type: e, defaultValue: t }) {
  return t !== void 0 ? t : e === "single" ? void 0 : [];
}
function Kh(e, t) {
  const n = E(() => F1(e)), a = Ve(e, "modelValue", t, {
    defaultValue: N1(e),
    passive: e.modelValue === void 0,
    deep: !0
  });
  function r(s) {
    if (n.value === "single") a.value = En(s, a.value) ? void 0 : s;
    else {
      const i = Array.isArray(a.value) ? [...a.value || []] : [a.value].filter(Boolean);
      if (Cl(i, s)) {
        const u = i.findIndex((d) => En(d, s));
        i.splice(u, 1);
      } else i.push(s);
      a.value = i;
    }
  }
  const o = E(() => n.value === "single");
  return {
    modelValue: a,
    changeModelValue: r,
    isSingle: o
  };
}
const [yi, L1] = Be("AccordionRoot");
var z1 = /* @__PURE__ */ b({
  __name: "AccordionRoot",
  props: {
    collapsible: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, disabled: o, unmountOnHide: s } = Me(n), i = yt(r), { modelValue: u, changeModelValue: d, isSingle: c } = Kh(n, a), { forwardRef: f, currentElement: p } = j();
    return L1({
      disabled: o,
      direction: i,
      orientation: n.orientation,
      parentElement: p,
      isSingle: c,
      collapsible: n.collapsible,
      modelValue: u,
      changeModelValue: d,
      unmountOnHide: s
    }), (v, m) => (h(), x(l(X), {
      ref: l(f),
      "as-child": v.asChild,
      as: v.as
    }, {
      default: y(() => [_(v.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), H1 = z1, md = /* @__PURE__ */ (function(e) {
  return e.Open = "open", e.Closed = "closed", e;
})(md || {});
const [$c, U1] = Be("AccordionItem");
var j1 = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: String,
      required: !0
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = yi(), r = E(() => a.isSingle.value ? n.value === a.modelValue.value : Array.isArray(a.modelValue.value) && a.modelValue.value.includes(n.value)), o = E(() => a.disabled.value || n.disabled), s = E(() => o.value ? "" : void 0), i = E(() => r.value ? md.Open : md.Closed);
    t({
      open: r,
      dataDisabled: s
    });
    const { currentRef: u, currentElement: d } = j();
    U1({
      open: r,
      dataState: i,
      disabled: o,
      dataDisabled: s,
      triggerId: "",
      currentRef: u,
      currentElement: d,
      value: E(() => n.value)
    });
    function c(f) {
      const p = f.target;
      if (Array.from(a.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []).findIndex((g) => g === p) === -1) return null;
      lr(f, p, a.parentElement.value, {
        arrowKeyOptions: a.orientation,
        dir: a.direction.value,
        focus: !0
      });
    }
    return (f, p) => (h(), x(l(jh), {
      "data-orientation": l(a).orientation,
      "data-disabled": s.value,
      "data-state": i.value,
      disabled: o.value,
      open: r.value,
      as: n.as,
      "as-child": n.asChild,
      "unmount-on-hide": n.unmountOnHide ?? l(a).unmountOnHide.value,
      onKeydown: Je(c, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end"
      ])
    }, {
      default: y(() => [_(f.$slots, "default", { open: r.value })]),
      _: 3
    }, 8, [
      "data-orientation",
      "data-disabled",
      "data-state",
      "disabled",
      "open",
      "as",
      "as-child",
      "unmount-on-hide"
    ]));
  }
}), W1 = j1, G1 = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = yi(), a = $c();
    return j(), (r, o) => (h(), x(l(Wh), {
      role: "region",
      "as-child": t.asChild,
      as: r.as,
      "force-mount": t.forceMount,
      "aria-labelledby": l(a).triggerId,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      style: {
        "--reka-accordion-content-width": "var(--reka-collapsible-content-width)",
        "--reka-accordion-content-height": "var(--reka-collapsible-content-height)"
      },
      onContentFound: o[0] || (o[0] = (s) => l(n).changeModelValue(l(a).value.value))
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "force-mount",
      "aria-labelledby",
      "data-state",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), K1 = G1, Y1 = /* @__PURE__ */ b({
  __name: "AccordionHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h3"
    }
  },
  setup(e) {
    const t = e, n = yi(), a = $c();
    return j(), (r, o) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-orientation",
      "data-state",
      "data-disabled"
    ]));
  }
}), X1 = Y1, J1 = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = yi(), a = $c();
    a.triggerId ||= Ge(void 0, "reka-accordion-trigger");
    function r() {
      const o = n.isSingle.value && a.open.value && !n.collapsible;
      a.disabled.value || o || n.changeModelValue(a.value.value);
    }
    return (o, s) => (h(), x(l(Gh), {
      id: l(a).triggerId,
      ref: l(a).currentRef,
      "data-reka-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-disabled": l(a).disabled.value || void 0,
      "aria-expanded": l(a).open.value || !1,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      disabled: l(a).disabled.value,
      onClick: r
    }, {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "aria-disabled",
      "aria-expanded",
      "data-disabled",
      "data-orientation",
      "data-state",
      "disabled"
    ]));
  }
}), Z1 = J1;
const [Zn, Q1] = Be("DialogRoot");
var ex = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = I(), s = I(), { modal: i } = Me(n);
    return Q1({
      open: r,
      modal: i,
      openModal: () => {
        r.value = !0;
      },
      onOpenChange: (u) => {
        r.value = u;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: o,
      contentElement: s
    }), (u, d) => _(u.$slots, "default", {
      open: l(r),
      close: () => r.value = !1
    });
  }
}), bi = ex, tx = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zn();
    return (a, r) => (h(), x(l(X), A(t, {
      type: a.as === "button" ? "button" : void 0,
      onClick: r[0] || (r[0] = (o) => l(n).onOpenChange(!1))
    }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), Va = tx;
const nx = "dismissableLayer.pointerDownOutside", ax = "dismissableLayer.focusOutside";
function Yh(e, t) {
  const n = t.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), r = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(n && (a === n || r.indexOf(a) < r.indexOf(n)));
}
function rx(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = I(!1), o = I(() => {
  });
  return Ie((s) => {
    if (!rn || !fe(n)) return;
    const i = async (d) => {
      const c = d.target;
      if (!(!t?.value || !c)) {
        if (Yh(t.value, c)) {
          r.value = !1;
          return;
        }
        if (d.target && !r.value) {
          let p = function() {
            is(nx, e, f);
          };
          const f = { originalEvent: d };
          d.pointerType === "touch" ? (a.removeEventListener("click", o.value), o.value = p, a.addEventListener("click", o.value, { once: !0 })) : p();
        } else a.removeEventListener("click", o.value);
        r.value = !1;
      }
    }, u = window.setTimeout(() => {
      a.addEventListener("pointerdown", i);
    }, 0);
    s(() => {
      window.clearTimeout(u), a.removeEventListener("pointerdown", i), a.removeEventListener("click", o.value);
    });
  }), { onPointerDownCapture: () => {
    fe(n) && (r.value = !0);
  } };
}
function ox(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = I(!1);
  return Ie((o) => {
    if (!rn || !fe(n)) return;
    const s = async (i) => {
      if (!t?.value) return;
      await ke(), await ke();
      const u = i.target;
      !t.value || !u || Yh(t.value, u) || i.target && !r.value && is(ax, e, { originalEvent: i });
    };
    a.addEventListener("focusin", s), o(() => a.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => {
      fe(n) && (r.value = !0);
    },
    onBlurCapture: () => {
      fe(n) && (r.value = !1);
    }
  };
}
const yn = Wt({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  originalBodyPointerEvents: void 0,
  branches: /* @__PURE__ */ new Set()
});
var sx = /* @__PURE__ */ b({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = E(() => o.value?.ownerDocument ?? globalThis.document), i = E(() => yn.layersRoot), u = E(() => o.value ? Array.from(i.value).indexOf(o.value) : -1), d = E(() => yn.layersWithOutsidePointerEventsDisabled.size > 0), c = E(() => {
      const v = Array.from(i.value), [m] = [...yn.layersWithOutsidePointerEventsDisabled].slice(-1), g = v.indexOf(m);
      return u.value >= g;
    }), f = rx(async (v) => {
      const m = [...yn.branches].some((g) => g?.contains(v.target));
      !c.value || m || (a("pointerDownOutside", v), a("interactOutside", v), await ke(), v.defaultPrevented || a("dismiss"));
    }, o), p = ox((v) => {
      [...yn.branches].some((g) => g?.contains(v.target)) || (a("focusOutside", v), a("interactOutside", v), v.defaultPrevented || a("dismiss"));
    }, o);
    return rw("Escape", (v) => {
      u.value === i.value.size - 1 && (a("escapeKeyDown", v), v.defaultPrevented || a("dismiss"));
    }), Ie((v) => {
      o.value && (n.disableOutsidePointerEvents && (yn.layersWithOutsidePointerEventsDisabled.size === 0 && (yn.originalBodyPointerEvents = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), yn.layersWithOutsidePointerEventsDisabled.add(o.value)), i.value.add(o.value), v(() => {
        n.disableOutsidePointerEvents && yn.layersWithOutsidePointerEventsDisabled.size === 1 && !Mn(yn.originalBodyPointerEvents) && (s.value.body.style.pointerEvents = yn.originalBodyPointerEvents);
      }));
    }), Ie((v) => {
      v(() => {
        o.value && (i.value.delete(o.value), yn.layersWithOutsidePointerEventsDisabled.delete(o.value));
      });
    }), (v, m) => (h(), x(l(X), {
      ref: l(r),
      "as-child": v.asChild,
      as: v.as,
      "data-dismissable-layer": "",
      style: dt({ pointerEvents: d.value ? c.value ? "auto" : "none" : void 0 }),
      onFocusCapture: l(p).onFocusCapture,
      onBlurCapture: l(p).onBlurCapture,
      onPointerdownCapture: l(f).onPointerDownCapture
    }, {
      default: y(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), Fa = sx;
const lx = F0(() => I([]));
function ix() {
  const e = lx();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && n?.pause(), e.value = Ip(e.value, t), e.value.unshift(t);
    },
    remove(t) {
      e.value = Ip(e.value, t), e.value[0]?.resume();
    }
  };
}
function Ip(e, t) {
  const n = [...e], a = n.indexOf(t);
  return a !== -1 && n.splice(a, 1), n;
}
function ux(e) {
  return e.filter((t) => t.tagName !== "A");
}
const Mu = "focusScope.autoFocusOnMount", qu = "focusScope.autoFocusOnUnmount", Op = {
  bubbles: !1,
  cancelable: !0
};
function dx(e, { select: t = !1 } = {}) {
  const n = ot();
  for (const a of e)
    if ($a(a, { select: t }), ot() !== n) return !0;
}
function cx(e) {
  const t = Xh(e), n = Rp(t, e), a = Rp(t.reverse(), e);
  return [n, a];
}
function Xh(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Rp(e, t) {
  for (const n of e) if (!fx(n, { upTo: t })) return n;
}
function fx(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function px(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function $a(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = ot();
    e.focus({ preventScroll: !0 }), e !== n && px(e) && t && e.select();
  }
}
var vx = /* @__PURE__ */ b({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    trapped: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, { currentRef: r, currentElement: o } = j(), s = I(null), i = ix(), u = Wt({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Ie((c) => {
      if (!rn) return;
      const f = o.value;
      if (!n.trapped) return;
      function p(w) {
        if (u.paused || !f) return;
        const C = w.target;
        f.contains(C) ? s.value = C : $a(s.value, { select: !0 });
      }
      function v(w) {
        if (u.paused || !f) return;
        const C = w.relatedTarget;
        C !== null && (f.contains(C) || $a(s.value, { select: !0 }));
      }
      function m(w) {
        f.contains(s.value) || $a(f);
      }
      document.addEventListener("focusin", p), document.addEventListener("focusout", v);
      const g = new MutationObserver(m);
      f && g.observe(f, {
        childList: !0,
        subtree: !0
      }), c(() => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", v), g.disconnect();
      });
    }), Ie(async (c) => {
      const f = o.value;
      if (await ke(), !f) return;
      i.add(u);
      const p = ot();
      if (!f.contains(p)) {
        const m = new CustomEvent(Mu, Op);
        f.addEventListener(Mu, (g) => a("mountAutoFocus", g)), f.dispatchEvent(m), m.defaultPrevented || (dx(ux(Xh(f)), { select: !0 }), ot() === p && $a(f));
      }
      c(() => {
        f.removeEventListener(Mu, (w) => a("mountAutoFocus", w));
        const m = new CustomEvent(qu, Op), g = (w) => {
          a("unmountAutoFocus", w);
        };
        f.addEventListener(qu, g), f.dispatchEvent(m), setTimeout(() => {
          m.defaultPrevented || $a(p ?? document.body, { select: !0 }), f.removeEventListener(qu, g), i.remove(u);
        }, 0);
      });
    });
    function d(c) {
      if (!n.loop && !n.trapped || u.paused) return;
      const f = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, p = ot();
      if (f && p) {
        const v = c.currentTarget, [m, g] = cx(v);
        m && g ? !c.shiftKey && p === g ? (c.preventDefault(), n.loop && $a(m, { select: !0 })) : c.shiftKey && p === m && (c.preventDefault(), n.loop && $a(g, { select: !0 })) : p === v && c.preventDefault();
      }
    }
    return (c, f) => (h(), x(l(X), {
      ref_key: "currentRef",
      ref: r,
      tabindex: "-1",
      "as-child": c.asChild,
      as: c.as,
      onKeydown: d
    }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), _i = vx;
const mx = "menu.itemSelect", hd = ["Enter", " "], hx = [
  "ArrowDown",
  "PageUp",
  "Home"
], Jh = [
  "ArrowUp",
  "PageDown",
  "End"
], gx = [...hx, ...Jh], yx = {
  ltr: [...hd, "ArrowRight"],
  rtl: [...hd, "ArrowLeft"]
}, bx = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function kc(e) {
  return e ? "open" : "closed";
}
function ql(e) {
  return e === "indeterminate";
}
function Bc(e) {
  return ql(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function gd(e) {
  const t = ot();
  for (const n of e)
    if (n === t || (n.focus(), ot() !== t)) return;
}
function _x(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function wx(e, t) {
  if (!t) return !1;
  const n = {
    x: e.clientX,
    y: e.clientY
  };
  return _x(n, t);
}
function Lo(e) {
  return e.pointerType === "mouse";
}
const xx = "DialogTitle", Cx = "DialogContent";
function Sx({ titleName: e = xx, contentName: t = Cx, componentLink: n = "dialog.html#title", titleId: a, descriptionId: r, contentElement: o }) {
  const s = `Warning: \`${t}\` requires a \`${e}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${n}`, i = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${t}.`;
  Ce(() => {
    document.getElementById(a) || console.warn(s);
    const d = o.value?.getAttribute("aria-describedby");
    r && d && (document.getElementById(r) || console.warn(i));
  });
}
var $x = /* @__PURE__ */ b({
  __name: "DialogContentImpl",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Zn(), { forwardRef: o, currentElement: s } = j();
    return r.titleId ||= Ge(void 0, "reka-dialog-title"), r.descriptionId ||= Ge(void 0, "reka-dialog-description"), Ce(() => {
      r.contentElement = s, ot() !== document.body && (r.triggerElement.value = ot());
    }), process.env.NODE_ENV !== "production" && Sx({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: r.titleId,
      descriptionId: r.descriptionId,
      contentElement: s
    }), (i, u) => (h(), x(l(_i), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [N(l(Fa), A({
        id: l(r).contentId,
        ref: l(o),
        as: i.as,
        "as-child": i.asChild,
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        role: "dialog",
        "aria-describedby": l(r).descriptionId,
        "aria-labelledby": l(r).titleId,
        "data-state": l(kc)(l(r).open.value)
      }, i.$attrs, {
        onDismiss: u[0] || (u[0] = (d) => l(r).onOpenChange(!1)),
        onEscapeKeyDown: u[1] || (u[1] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[2] || (u[2] = (d) => a("focusOutside", d)),
        onInteractOutside: u[3] || (u[3] = (d) => a("interactOutside", d)),
        onPointerDownOutside: u[4] || (u[4] = (d) => a("pointerDownOutside", d))
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "as",
        "as-child",
        "disable-outside-pointer-events",
        "aria-describedby",
        "aria-labelledby",
        "data-state"
      ])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Zh = $x, kx = /* @__PURE__ */ b({
  __name: "DialogContentModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Zn(), o = Kt(a), { forwardRef: s, currentElement: i } = j();
    return vs(i), (u, d) => (h(), x(Zh, A({
      ...n,
      ...l(o)
    }, {
      ref: l(s),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (c.preventDefault(), l(r).triggerElement.value?.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0;
        (f.button === 2 || p) && c.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (c) => {
        c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), Bx = kx, Dx = /* @__PURE__ */ b({
  __name: "DialogContentNonModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    j();
    const o = Zn(), s = I(!1), i = I(!1);
    return (u, d) => (h(), x(Zh, A({
      ...n,
      ...l(r)
    }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (s.value || l(o).triggerElement.value?.focus(), c.preventDefault()), s.value = !1, i.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = (c) => {
        c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const f = c.target;
        l(o).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && i.value && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Px = Dx, Mx = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Zn(), o = Kt(a), { forwardRef: s } = j();
    return (i, u) => (h(), x(l(St), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [l(r).modal.value ? (h(), x(Bx, A({
        key: 0,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(Px, A({
        key: 1,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), hs = Mx, qx = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zn();
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).descriptionId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), wi = qx, Ex = /* @__PURE__ */ b({
  __name: "DialogOverlayImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Zn();
    return fs(!0), j(), (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": l(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state"
    ]));
  }
}), Tx = Ex, Ax = /* @__PURE__ */ b({
  __name: "DialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Zn(), { forwardRef: n } = j();
    return (a, r) => l(t)?.modal.value ? (h(), x(l(St), {
      key: 0,
      present: a.forceMount || l(t).open.value
    }, {
      default: y(() => [N(Tx, A(a.$attrs, {
        ref: l(n),
        as: a.as,
        "as-child": a.asChild
      }), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, ["as", "as-child"])]),
      _: 3
    }, 8, ["present"])) : Ee("v-if", !0);
  }
}), gs = Ax, Ix = /* @__PURE__ */ b({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: !1,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = cc();
    return (n, a) => l(t) || n.forceMount ? (h(), x(vi, {
      key: 0,
      to: n.to,
      disabled: n.disabled,
      defer: n.defer
    }, [_(n.$slots, "default")], 8, [
      "to",
      "disabled",
      "defer"
    ])) : Ee("v-if", !0);
  }
}), Na = Ix, Ox = /* @__PURE__ */ b({
  __name: "DialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xi = Ox, Rx = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e, n = Zn();
    return j(), (a, r) => (h(), x(l(X), A(t, { id: l(n).titleId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Ci = Rx, Vx = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Zn(), { forwardRef: a, currentElement: r } = j();
    return n.contentId ||= Ge(void 0, "reka-dialog-content"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), x(l(X), A(t, {
      ref: l(a),
      type: o.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": l(n).open.value || !1,
      "aria-controls": l(n).open.value ? l(n).contentId : void 0,
      "data-state": l(n).open.value ? "open" : "closed",
      onClick: l(n).onOpenToggle
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "onClick"
    ]));
  }
}), Si = Vx, Fx = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Va), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Nx = Fx;
const [Lx, zx] = Be("AlertDialogContent");
var Hx = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    j();
    const o = I();
    return zx({ onCancelElementChange: (s) => {
      o.value = s;
    } }), (s, i) => (h(), x(l(hs), A({
      ...n,
      ...l(r)
    }, {
      role: "alertdialog",
      onPointerDownOutside: i[0] || (i[0] = Ke(() => {
      }, ["prevent"])),
      onInteractOutside: i[1] || (i[1] = Ke(() => {
      }, ["prevent"])),
      onOpenAutoFocus: i[2] || (i[2] = () => {
        ke(() => {
          o.value?.focus({ preventScroll: !0 });
        });
      })
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ux = Hx, jx = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Lx(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onCancelElementChange(r.value);
    }), (o, s) => (h(), x(l(Va), A(t, { ref: l(a) }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Wx = jx, Gx = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(wi), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Kx = Gx, Yx = /* @__PURE__ */ b({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(gs), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Xx = Yx, Jx = /* @__PURE__ */ b({
  __name: "AlertDialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Zx = Jx, Qx = /* @__PURE__ */ b({
  __name: "AlertDialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(bi), A(l(r), { modal: !0 }), {
      default: y((i) => [_(o.$slots, "default", oe(le(i)))]),
      _: 3
    }, 16));
  }
}), eC = Qx, tC = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Ci), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nC = tC, aC = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Si), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rC = aC, oC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "AspectRatio",
  props: {
    ratio: {
      type: Number,
      required: !1,
      default: 1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = E(() => 1 / t.ratio * 100);
    return (r, o) => (h(), G("div", {
      style: dt(`position: relative; width: 100%; padding-bottom: ${a.value}%`),
      "data-reka-aspect-ratio-wrapper": ""
    }, [N(l(X), A({
      ref: l(n),
      "as-child": r.asChild,
      as: r.as,
      style: {
        position: "absolute",
        inset: "0px"
      }
    }, r.$attrs), {
      default: y(() => [_(r.$slots, "default", { aspect: a.value })]),
      _: 3
    }, 16, ["as-child", "as"])], 4));
  }
}), sC = oC;
const [Qh, lC] = Be("AvatarRoot");
var iC = /* @__PURE__ */ b({
  __name: "AvatarRoot",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return j(), lC({ imageLoadingStatus: I("idle") }), (t, n) => (h(), x(l(X), {
      "as-child": t.asChild,
      as: t.as
    }, {
      default: y(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), uC = iC, dC = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Qh();
    j();
    const a = I(t.delayMs === void 0);
    return Ie((r) => {
      if (t.delayMs && rn) {
        const o = window.setTimeout(() => {
          a.value = !0;
        }, t.delayMs);
        r(() => {
          window.clearTimeout(o);
        });
      }
    }), (r, o) => a.value && l(n).imageLoadingStatus.value !== "loaded" ? (h(), x(l(X), {
      key: 0,
      "as-child": r.asChild,
      as: r.as
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"])) : Ee("v-if", !0);
  }
}), cC = dC;
function Vp(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function fC(e, { referrerPolicy: t, crossOrigin: n } = {}) {
  const a = I(!1), r = I(null), o = E(() => a.value ? (!r.value && rn && (r.value = new window.Image()), r.value) : null), s = I(Vp(o.value, e.value)), i = (u) => () => {
    a.value && (s.value = u);
  };
  return Ce(() => {
    a.value = !0, Ie((u) => {
      const d = o.value;
      if (!d) return;
      s.value = Vp(d, e.value);
      const c = i("loaded"), f = i("error");
      d.addEventListener("load", c), d.addEventListener("error", f), t?.value && (d.referrerPolicy = t.value), typeof n?.value == "string" && (d.crossOrigin = n.value), u(() => {
        d.removeEventListener("load", c), d.removeEventListener("error", f);
      });
    });
  }), Qe(() => {
    a.value = !1;
  }), s;
}
var pC = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {
      type: String,
      required: !0
    },
    referrerPolicy: {
      type: null,
      required: !1
    },
    crossOrigin: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "img"
    }
  },
  emits: ["loadingStatusChange"],
  setup(e, { emit: t }) {
    const n = e, a = t, { src: r, referrerPolicy: o, crossOrigin: s } = Me(n);
    j();
    const i = Qh(), u = fC(r, {
      referrerPolicy: o,
      crossOrigin: s
    });
    return ve(u, (d) => {
      a("loadingStatusChange", d), d !== "idle" && (i.imageLoadingStatus.value = d);
    }, { immediate: !0 }), (d, c) => lc((h(), x(l(X), {
      role: "img",
      "as-child": d.asChild,
      as: d.as,
      src: l(r),
      "referrer-policy": l(o)
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "src",
      "referrer-policy"
    ])), [[y0, l(u) === "loaded"]]);
  }
}), vC = pC;
function mC(e) {
  function t(a) {
    return Array.isArray(e.date.value) ? e.date.value.some((r) => wt(r, a)) : e.date.value ? wt(e.date.value, a) : !1;
  }
  const n = E(() => {
    if (Array.isArray(e.date.value)) {
      if (!e.date.value.length) return !1;
      for (const a of e.date.value)
        if (e.isDateDisabled?.(a) || e.isDateUnavailable?.(a)) return !0;
    } else {
      if (!e.date.value) return !1;
      if (e.isDateDisabled?.(e.date.value) || e.isDateUnavailable?.(e.date.value)) return !0;
    }
    return !1;
  });
  return {
    isDateSelected: t,
    isInvalid: n
  };
}
function hC(e, t) {
  const n = t(e), a = n.compare(e), r = {};
  return a >= 7 && (r.day = 1), a >= No(e) && (r.month = 1), n.set({ ...r });
}
function gC(e, t) {
  const n = t(e), a = e.compare(n), r = {};
  return a >= 7 && (r.day = 35), a >= No(e) && (r.month = 13), n.set({ ...r });
}
function yC(e, t) {
  return t(e);
}
function bC(e, t) {
  return t(e);
}
function eg(e) {
  const t = b1(e.locale.value), n = E(() => {
    const g = { calendar: e.placeholder.value.calendar.identifier };
    return e.placeholder.value.calendar.identifier === "gregory" && e.placeholder.value.era === "BC" && (g.era = "short"), g;
  }), a = I(Ha({
    dateObj: e.placeholder.value,
    weekStartsOn: e.weekStartsOn.value,
    locale: e.locale.value,
    fixedWeeks: e.fixedWeeks.value,
    numberOfMonths: e.numberOfMonths.value
  })), r = E(() => a.value.map((g) => g.value));
  function o(g) {
    return !r.value.some((w) => vp(g, w));
  }
  const s = (g) => {
    if (!e.maxValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const w = a.value[a.value.length - 1].value;
    if (!g && !e.nextPage.value) {
      const S = w.add({ months: 1 }).set({ day: 1 });
      return dl(S, e.maxValue.value);
    }
    const C = hC(w, g || e.nextPage.value);
    return dl(C, e.maxValue.value);
  }, i = (g) => {
    if (!e.minValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const w = a.value[0].value;
    if (!g && !e.prevPage.value) {
      const S = w.subtract({ months: 1 }).set({ day: 35 });
      return Za(S, e.minValue.value);
    }
    const C = gC(w, g || e.prevPage.value);
    return Za(C, e.minValue.value);
  };
  function u(g) {
    return !!(e.isDateDisabled?.(g) || e.disabled.value || e.maxValue.value && dl(g, e.maxValue.value) || e.minValue.value && Za(g, e.minValue.value));
  }
  const d = (g) => !!e.isDateUnavailable?.(g), c = E(() => a.value.length ? a.value[0].rows[0].map((g) => t.dayOfWeek(Bn(g), e.weekdayFormat.value)) : []), f = (g) => {
    const w = a.value[0].value;
    if (!g && !e.nextPage.value) {
      const B = w.add({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), k = Ha({
        dateObj: B,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = k, e.placeholder.value = k[0].value.set({ day: 1 });
      return;
    }
    const C = yC(w, g || e.nextPage.value), S = Ha({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!g) {
      const B = S[0].value.compare(w);
      B >= No(w) && ($.day = 1), B >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  }, p = (g) => {
    const w = a.value[0].value;
    if (!g && !e.prevPage.value) {
      const B = w.subtract({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), k = Ha({
        dateObj: B,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = k, e.placeholder.value = k[0].value.set({ day: 1 });
      return;
    }
    const C = bC(w, g || e.prevPage.value), S = Ha({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!g) {
      const B = w.compare(S[0].value);
      B >= No(w) && ($.day = 1), B >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  };
  ve(e.placeholder, (g) => {
    r.value.some((w) => vp(w, g)) || (a.value = Ha({
      dateObj: g,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    }));
  }), ve([
    e.locale,
    e.weekStartsOn,
    e.fixedWeeks,
    e.numberOfMonths
  ], () => {
    a.value = Ha({
      dateObj: e.placeholder.value,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
  });
  const v = E(() => {
    if (!a.value.length) return "";
    if (e.locale.value !== t.getLocale() && t.setLocale(e.locale.value), a.value.length === 1) {
      const P = a.value[0].value;
      return `${t.fullMonthAndYear(Bn(P), n.value)}`;
    }
    const g = Bn(a.value[0].value), w = Bn(a.value[a.value.length - 1].value), C = t.fullMonth(g, n.value), S = t.fullMonth(w, n.value), $ = t.fullYear(g, n.value), B = t.fullYear(w, n.value);
    return $ === B ? `${C} - ${S} ${B}` : `${C} ${$} - ${S} ${B}`;
  }), m = E(() => `${e.calendarLabel.value ?? "Event Date"}, ${v.value}`);
  return {
    isDateDisabled: u,
    isDateUnavailable: d,
    isNextButtonDisabled: s,
    isPrevButtonDisabled: i,
    grid: a,
    weekdays: c,
    visibleView: r,
    isOutsideVisibleView: o,
    formatter: t,
    nextPage: f,
    prevPage: p,
    headingValue: v,
    fullCalendarLabel: m
  };
}
const _C = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, wC = {
  role: "heading",
  "aria-level": "2"
}, [Xr, xC] = Be("CalendarRoot");
var CC = /* @__PURE__ */ b({
  __name: "CalendarRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, multiple: f, minValue: p, maxValue: v, numberOfMonths: m, preventDeselect: g, isDateDisabled: w, isDateUnavailable: C, calendarLabel: S, defaultValue: $, nextPage: B, prevPage: k, dir: P, locale: D, disableDaysOutsideCurrentView: q } = Me(n), { primitiveElement: T, currentElement: M } = Ht(), O = Cc(D), F = yt(P), J = Ve(n, "modelValue", a, {
      defaultValue: $.value,
      passive: n.modelValue === void 0
    }), ne = Rh({
      defaultPlaceholder: n.placeholder,
      defaultValue: J.value,
      locale: n.locale
    }), Q = Ve(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ne.copy(),
      passive: n.placeholder === void 0
    });
    function W(L) {
      Q.value = L.copy();
    }
    const { fullCalendarLabel: H, headingValue: U, isDateDisabled: se, isDateUnavailable: ee, isNextButtonDisabled: de, isPrevButtonDisabled: pe, weekdays: _e, isOutsideVisibleView: ge, nextPage: Te, prevPage: ce, formatter: R, grid: te } = eg({
      locale: O,
      placeholder: Q,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: m,
      minValue: p,
      maxValue: v,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: w.value,
      isDateUnavailable: C.value,
      calendarLabel: S,
      nextPage: B,
      prevPage: k
    }), { isInvalid: z, isDateSelected: ae } = mC({
      date: J,
      isDateDisabled: se,
      isDateUnavailable: ee
    });
    ve(J, (L) => {
      if (Array.isArray(L) && L.length) {
        const be = L[L.length - 1];
        be && !Ba(Q.value, be) && W(be);
      } else !Array.isArray(L) && L && !Ba(Q.value, L) && W(L);
    });
    function ie(L) {
      if (f.value) {
        if (!J.value) J.value = [L.copy()];
        else if (Array.isArray(J.value)) {
          if (J.value.findIndex((we) => wt(we, L)) === -1) J.value = [...J.value, L];
          else if (!g.value) {
            const we = J.value.filter((Fe) => !wt(Fe, L));
            if (!we.length) {
              Q.value = L.copy(), J.value = void 0;
              return;
            }
            J.value = we.map((Fe) => Fe.copy());
          }
        }
      } else {
        if (!J.value) {
          J.value = L.copy();
          return;
        }
        !g.value && Ba(J.value, L) ? (Q.value = L.copy(), J.value = void 0) : J.value = L.copy();
      }
    }
    return Ce(() => {
      s.value && Vh(M.value);
    }), xC({
      isDateUnavailable: ee,
      dir: F,
      isDateDisabled: se,
      locale: O,
      formatter: R,
      modelValue: J,
      placeholder: Q,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: te,
      weekDays: _e,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      multiple: f,
      numberOfMonths: m,
      readonly: o,
      preventDeselect: g,
      fullCalendarLabel: H,
      headingValue: U,
      isInvalid: z,
      isDateSelected: ae,
      isNextButtonDisabled: de,
      isPrevButtonDisabled: pe,
      isOutsideVisibleView: ge,
      nextPage: Te,
      prevPage: ce,
      parentElement: M,
      onPlaceholderChange: W,
      onDateChange: ie,
      disableDaysOutsideCurrentView: q,
      minValue: p,
      maxValue: v
    }), (L, be) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: T,
      as: L.as,
      "as-child": L.asChild,
      "aria-label": l(H),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(z) ? "" : void 0,
      dir: l(F)
    }, {
      default: y(() => [_(L.$slots, "default", {
        date: l(Q),
        grid: l(te),
        weekDays: l(_e),
        weekStartsOn: l(u),
        locale: l(O),
        fixedWeeks: l(c),
        modelValue: l(J)
      }), xe("div", _C, [xe("div", wC, He(l(H)), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), SC = CC, $C = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = Xr();
    return (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isDateSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), kC = $C, BC = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = ms(), a = Xr(), { primitiveElement: r } = Ht(), o = E(() => t.day.day.toLocaleString(a.locale.value)), s = E(() => a.formatter.custom(Bn(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), i = E(() => a.isDateUnavailable?.(t.day) ?? !1), u = E(() => vh(t.day, Yr())), d = E(() => !fc(t.day, t.month)), c = E(() => a.isOutsideVisibleView(t.day)), f = E(() => a.isDateDisabled(t.day) || a.disableDaysOutsideCurrentView.value && d.value), p = E(() => !a.disabled.value && wt(t.day, a.placeholder.value)), v = E(() => a.isDateSelected(t.day));
    function m(C) {
      a.readonly.value || a.isDateDisabled(C) || a.isDateUnavailable?.(C) || a.onDateChange(C);
    }
    function g() {
      f.value || m(t.day);
    }
    function w(C) {
      if (f.value) return;
      C.preventDefault(), C.stopPropagation();
      const S = a.parentElement.value, $ = 7, B = a.dir.value === "rtl" ? -1 : 1;
      switch (C.code) {
        case n.ARROW_RIGHT:
          k(t.day, B);
          break;
        case n.ARROW_LEFT:
          k(t.day, -B);
          break;
        case n.ARROW_UP:
          k(t.day, -$);
          break;
        case n.ARROW_DOWN:
          k(t.day, $);
          break;
        case n.ENTER:
        case n.SPACE_CODE:
          m(t.day);
      }
      function k(P, D) {
        const q = P.add({ days: D });
        if (a.minValue.value && q.compare(a.minValue.value) < 0 || a.maxValue.value && q.compare(a.maxValue.value) > 0) return;
        const T = S.querySelector(`[data-value='${q.toString()}']:not([data-outside-view])`);
        if (!T) {
          if (D > 0) {
            if (a.isNextButtonDisabled()) return;
            a.nextPage();
          } else {
            if (a.isPrevButtonDisabled()) return;
            a.prevPage();
          }
          ke(() => {
            k(P, D);
          });
          return;
        }
        if (T && T.hasAttribute("data-disabled")) return k(q, D);
        a.onPlaceholderChange(q), T?.focus();
      }
    }
    return (C, S) => (h(), x(l(X), A({
      ref_key: "primitiveElement",
      ref: r
    }, t, {
      role: "button",
      "aria-label": s.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-disabled": f.value || i.value ? !0 : void 0,
      "data-selected": v.value ? !0 : void 0,
      "data-value": C.day.toString(),
      "data-disabled": f.value ? "" : void 0,
      "data-unavailable": i.value ? "" : void 0,
      "data-today": u.value ? "" : void 0,
      "data-outside-view": d.value ? "" : void 0,
      "data-outside-visible-view": c.value ? "" : void 0,
      "data-focused": p.value ? "" : void 0,
      tabindex: p.value ? 0 : d.value || f.value ? void 0 : -1,
      onClick: g,
      onKeydown: [Je(w, [
        "up",
        "down",
        "left",
        "right",
        "space",
        "enter"
      ]), S[0] || (S[0] = Je(Ke(() => {
      }, ["prevent"]), ["enter"]))]
    }), {
      default: y(() => [_(C.$slots, "default", {
        dayValue: o.value,
        disabled: f.value,
        today: u.value,
        selected: v.value,
        outsideView: d.value,
        outsideVisibleView: c.value,
        unavailable: i.value
      }, () => [Re(He(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-disabled",
      "data-selected",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-outside-visible-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), DC = BC, PC = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = Xr(), a = E(() => n.disabled.value ? !0 : void 0), r = E(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), x(l(X), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), MC = PC, qC = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), EC = qC, TC = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), AC = TC, IC = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OC = IC, RC = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VC = RC, FC = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), NC = FC, LC = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Xr();
    return (a, r) => (h(), x(l(X), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(He(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), zC = LC, HC = /* @__PURE__ */ b({
  __name: "CalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = Xr();
    return (r, o) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), UC = HC, jC = /* @__PURE__ */ b({
  __name: "CalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = Xr();
    return (r, o) => (h(), x(l(X), {
      "aria-label": "Previous page",
      as: t.as,
      "as-child": t.asChild,
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), WC = jC;
const Fp = "data-reka-collection-item";
function st(e = {}) {
  const { key: t = "", isProvider: n = !1 } = e, a = `${t}CollectionProvider`;
  let r;
  if (n) {
    const c = I(/* @__PURE__ */ new Map());
    r = {
      collectionRef: I(),
      itemMap: c
    }, Xn(a, r);
  } else r = Cn(a);
  const o = (c = !1) => {
    const f = r.collectionRef.value;
    if (!f) return [];
    const p = Array.from(f.querySelectorAll(`[${Fp}]`)), m = Array.from(r.itemMap.value.values()).sort((g, w) => p.indexOf(g.ref) - p.indexOf(w.ref));
    return c ? m : m.filter((g) => g.ref.dataset.disabled !== "");
  }, s = b({
    name: "CollectionSlot",
    setup(c, { slots: f }) {
      const { primitiveElement: p, currentElement: v } = Ht();
      return ve(v, () => {
        r.collectionRef.value = v.value;
      }), () => an(Ml, { ref: p }, f);
    }
  }), i = b({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(c, { slots: f, attrs: p }) {
      const { primitiveElement: v, currentElement: m } = Ht();
      return Ie((g) => {
        if (m.value) {
          const w = b0(m.value);
          r.itemMap.value.set(w, {
            ref: m.value,
            value: c.value
          }), g(() => r.itemMap.value.delete(w));
        }
      }), () => an(Ml, {
        ...p,
        [Fp]: "",
        ref: v
      }, f);
    }
  }), u = E(() => Array.from(r.itemMap.value.values())), d = E(() => r.itemMap.value.size);
  return {
    getItems: o,
    reactiveItems: u,
    itemMapSize: d,
    CollectionSlot: s,
    CollectionItem: i
  };
}
const GC = "rovingFocusGroup.onEntryFocus", KC = {
  bubbles: !1,
  cancelable: !0
}, YC = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function XC(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function tg(e, t, n) {
  const a = XC(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return YC[a];
}
function ng(e, t = !1) {
  const n = ot();
  for (const a of e)
    if (a === n || (a.focus({ preventScroll: t }), ot() !== n)) return;
}
function JC(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
const [ZC, QC] = Be("RovingFocusGroup");
var eS = /* @__PURE__ */ b({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { loop: o, orientation: s, dir: i } = Me(a), u = yt(i), d = Ve(a, "currentTabStopId", r, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), c = I(!1), f = I(!1), p = I(0), { getItems: v, CollectionSlot: m } = st({ isProvider: !0 });
    function g(C) {
      const S = !f.value;
      if (C.currentTarget && C.target === C.currentTarget && S && !c.value) {
        const $ = new CustomEvent(GC, KC);
        if (C.currentTarget.dispatchEvent($), r("entryFocus", $), !$.defaultPrevented) {
          const B = v().map((T) => T.ref).filter((T) => T.dataset.disabled !== ""), k = B.find((T) => T.getAttribute("data-active") === ""), P = B.find((T) => T.getAttribute("data-highlighted") === ""), D = B.find((T) => T.id === d.value), q = [
            k,
            P,
            D,
            ...B
          ].filter(Boolean);
          ng(q, a.preventScrollOnEntryFocus);
        }
      }
      f.value = !1;
    }
    function w() {
      setTimeout(() => {
        f.value = !1;
      }, 1);
    }
    return t({ getItems: v }), QC({
      loop: o,
      dir: u,
      orientation: s,
      currentTabStopId: d,
      onItemFocus: (C) => {
        d.value = C;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        p.value++;
      },
      onFocusableItemRemove: () => {
        p.value--;
      }
    }), (C, S) => (h(), x(l(m), null, {
      default: y(() => [N(l(X), {
        tabindex: c.value || p.value === 0 ? -1 : 0,
        "data-orientation": l(s),
        as: C.as,
        "as-child": C.asChild,
        dir: l(u),
        style: { outline: "none" },
        onMousedown: S[0] || (S[0] = ($) => f.value = !0),
        onMouseup: w,
        onFocus: g,
        onBlur: S[1] || (S[1] = ($) => c.value = !1)
      }, {
        default: y(() => [_(C.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), ys = eS, tS = /* @__PURE__ */ b({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = ZC(), a = Ge(), r = E(() => t.tabStopId || a), o = E(() => n.currentTabStopId.value === r.value), { getItems: s, CollectionItem: i } = st();
    Ce(() => {
      t.focusable && n.onFocusableItemAdd();
    }), Qe(() => {
      t.focusable && n.onFocusableItemRemove();
    });
    function u(d) {
      if (d.key === "Tab" && d.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (d.target !== d.currentTarget) return;
      const c = tg(d, n.orientation.value, n.dir.value);
      if (c !== void 0) {
        if (d.metaKey || d.ctrlKey || d.altKey || !t.allowShiftKey && d.shiftKey) return;
        d.preventDefault();
        let f = [...s().map((p) => p.ref).filter((p) => p.dataset.disabled !== "")];
        if (c === "last") f.reverse();
        else if (c === "prev" || c === "next") {
          c === "prev" && f.reverse();
          const p = f.indexOf(d.currentTarget);
          f = n.loop.value ? JC(f, p + 1) : f.slice(p + 1);
        }
        ke(() => ng(f));
      }
    }
    return (d, c) => (h(), x(l(i), null, {
      default: y(() => [N(l(X), {
        tabindex: o.value ? 0 : -1,
        "data-orientation": l(n).orientation.value,
        "data-active": d.active ? "" : void 0,
        "data-disabled": d.focusable ? void 0 : "",
        as: d.as,
        "as-child": d.asChild,
        onMousedown: c[0] || (c[0] = (f) => {
          d.focusable ? l(n).onItemFocus(r.value) : f.preventDefault();
        }),
        onFocus: c[1] || (c[1] = (f) => l(n).onItemFocus(r.value)),
        onKeydown: u
      }, {
        default: y(() => [_(d.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), bs = tS, nS = /* @__PURE__ */ b({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-hidden": t.feature === "focusable" ? "true" : void 0,
      "data-hidden": t.feature === "fully-hidden" ? "" : void 0,
      tabindex: t.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: y(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), $i = nS, aS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Ht(), r = E(() => t.checked ?? t.value);
    return ve(r, (o, s) => {
      if (!a.value) return;
      const i = a.value, u = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(u, "value").set;
      if (c && o !== s) {
        const f = new Event("input", { bubbles: !0 }), p = new Event("change", { bubbles: !0 });
        c.call(i, o), i.dispatchEvent(f), i.dispatchEvent(p);
      }
    }), (o, s) => (h(), x($i, A({
      ref_key: "primitiveElement",
      ref: n
    }, {
      ...t,
      ...o.$attrs
    }, { as: "input" }), null, 16));
  }
}), Np = aS, rS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, n = E(() => typeof t.value == "object" && Array.isArray(t.value) && t.value.length === 0 && t.required), a = E(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" || t.value === null || t.value === void 0 ? [{
      name: t.name,
      value: t.value
    }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((r, o) => typeof r == "object" ? Object.entries(r).map(([s, i]) => ({
      name: `${t.name}[${o}][${s}]`,
      value: i
    })) : {
      name: `${t.name}[${o}]`,
      value: r
    }) : t.value !== null && typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([r, o]) => ({
      name: `${t.name}[${r}]`,
      value: o
    })) : []);
    return (r, o) => (h(), G(Ye, null, [Ee(" We render single input if it's required "), n.value ? (h(), x(Np, A({ key: r.name }, {
      ...t,
      ...r.$attrs
    }, {
      name: r.name,
      value: r.value
    }), null, 16, ["name", "value"])) : (h(!0), G(Ye, { key: 1 }, Lt(a.value, (s) => (h(), x(Np, A({ key: s.name }, { ref_for: !0 }, {
      ...t,
      ...r.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), Vn = rS;
const [oS] = Be("CheckboxGroupRoot");
function El(e) {
  return e === "indeterminate";
}
function ag(e) {
  return El(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
const [sS, lS] = Be("CheckboxRoot");
var iS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultValue: {
      type: [Boolean, String],
      required: !1
    },
    modelValue: {
      type: [
        Boolean,
        String,
        null
      ],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: null,
      required: !1,
      default: "on"
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = oS(null), i = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), u = E(() => s?.disabled.value || n.disabled), d = E(() => Mn(s?.modelValue.value) ? i.value === "indeterminate" ? "indeterminate" : i.value : Cl(s.modelValue.value, n.value));
    function c() {
      if (Mn(s?.modelValue.value))
        i.value = El(i.value) ? !0 : !i.value;
      else {
        const v = [...s.modelValue.value || []];
        if (Cl(v, n.value)) {
          const m = v.findIndex((g) => En(g, n.value));
          v.splice(m, 1);
        } else v.push(n.value);
        s.modelValue.value = v;
      }
    }
    const f = Rn(o), p = E(() => n.id && o.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return lS({
      disabled: u,
      state: d
    }), (v, m) => (h(), x(Tt(l(s)?.rovingFocus.value ? l(bs) : l(X)), A(v.$attrs, {
      id: v.id,
      ref: l(r),
      role: "checkbox",
      "as-child": v.asChild,
      as: v.as,
      type: v.as === "button" ? "button" : void 0,
      "aria-checked": l(El)(d.value) ? "mixed" : d.value,
      "aria-required": v.required,
      "aria-label": v.$attrs["aria-label"] || p.value,
      "data-state": l(ag)(d.value),
      "data-disabled": u.value ? "" : void 0,
      disabled: u.value,
      focusable: l(s)?.rovingFocus.value ? !u.value : void 0,
      onKeydown: Je(Ke(() => {
      }, ["prevent"]), ["enter"]),
      onClick: c
    }), {
      default: y(() => [_(v.$slots, "default", {
        modelValue: l(i),
        state: d.value
      }), l(f) && v.name && !l(s) ? (h(), x(l(Vn), {
        key: 0,
        type: "checkbox",
        checked: !!d.value,
        name: v.name,
        value: v.value,
        disabled: u.value,
        required: v.required
      }, null, 8, [
        "checked",
        "name",
        "value",
        "disabled",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "as-child",
      "as",
      "type",
      "aria-checked",
      "aria-required",
      "aria-label",
      "data-state",
      "data-disabled",
      "disabled",
      "focusable",
      "onKeydown"
    ]));
  }
}), uS = iS, dS = /* @__PURE__ */ b({
  __name: "CheckboxIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = sS();
    return (a, r) => (h(), x(l(St), { present: a.forceMount || l(El)(l(n).state.value) || l(n).state.value === !0 }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "data-state": l(ag)(l(n).state.value),
        "data-disabled": l(n).disabled.value ? "" : void 0,
        style: { pointerEvents: "none" },
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), cS = dS;
const [rg, fS] = Be("PopperRoot");
var pS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = I();
    return fS({
      anchor: t,
      onAnchorChange: (n) => t.value = n
    }), (n, a) => _(n.$slots, "default");
  }
}), ir = pS, vS = /* @__PURE__ */ b({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = rg();
    return eh(() => {
      r.onAnchorChange(t.reference ?? a.value);
    }), (o, s) => (h(), x(l(X), {
      ref: l(n),
      as: o.as,
      "as-child": o.asChild
    }, {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), ur = vS;
const mS = {
  key: 0,
  d: "M0 0L6 6L12 0"
}, hS = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
var gS = /* @__PURE__ */ b({
  __name: "Arrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, {
      width: n.width,
      height: n.height,
      viewBox: n.asChild ? void 0 : "0 0 12 6",
      preserveAspectRatio: n.asChild ? void 0 : "none"
    }), {
      default: y(() => [_(n.$slots, "default", {}, () => [n.rounded ? (h(), G("path", hS)) : (h(), G("path", mS))])]),
      _: 3
    }, 16, [
      "width",
      "height",
      "viewBox",
      "preserveAspectRatio"
    ]));
  }
}), yS = gS;
function bS(e) {
  return e !== null;
}
function _S(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: a, middlewareData: r } = t, s = r.arrow?.centerOffset !== 0, i = s ? 0 : e.arrowWidth, u = s ? 0 : e.arrowHeight, [d, c] = yd(n), f = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[c], p = (r.arrow?.x ?? 0) + i / 2, v = (r.arrow?.y ?? 0) + u / 2;
      let m = "", g = "";
      return d === "bottom" ? (m = s ? f : `${p}px`, g = `${-u}px`) : d === "top" ? (m = s ? f : `${p}px`, g = `${a.floating.height + u}px`) : d === "right" ? (m = `${-u}px`, g = s ? f : `${v}px`) : d === "left" && (m = `${a.floating.width + u}px`, g = s ? f : `${v}px`), { data: {
        x: m,
        y: g
      } };
    }
  };
}
function yd(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
const wS = ["top", "right", "bottom", "left"], Ta = Math.min, fn = Math.max, Tl = Math.round, Ns = Math.floor, Gn = (e) => ({
  x: e,
  y: e
}), xS = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, CS = {
  start: "end",
  end: "start"
};
function bd(e, t, n) {
  return fn(e, Ta(t, n));
}
function ca(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function fa(e) {
  return e.split("-")[0];
}
function Jr(e) {
  return e.split("-")[1];
}
function Dc(e) {
  return e === "x" ? "y" : "x";
}
function Pc(e) {
  return e === "y" ? "height" : "width";
}
const SS = /* @__PURE__ */ new Set(["top", "bottom"]);
function Wn(e) {
  return SS.has(fa(e)) ? "y" : "x";
}
function Mc(e) {
  return Dc(Wn(e));
}
function $S(e, t, n) {
  n === void 0 && (n = !1);
  const a = Jr(e), r = Mc(e), o = Pc(r);
  let s = r === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = Al(s)), [s, Al(s)];
}
function kS(e) {
  const t = Al(e);
  return [_d(e), t, _d(t)];
}
function _d(e) {
  return e.replace(/start|end/g, (t) => CS[t]);
}
const Lp = ["left", "right"], zp = ["right", "left"], BS = ["top", "bottom"], DS = ["bottom", "top"];
function PS(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? zp : Lp : t ? Lp : zp;
    case "left":
    case "right":
      return t ? BS : DS;
    default:
      return [];
  }
}
function MS(e, t, n, a) {
  const r = Jr(e);
  let o = PS(fa(e), n === "start", a);
  return r && (o = o.map((s) => s + "-" + r), t && (o = o.concat(o.map(_d)))), o;
}
function Al(e) {
  return e.replace(/left|right|bottom|top/g, (t) => xS[t]);
}
function qS(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function og(e) {
  return typeof e != "number" ? qS(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Il(e) {
  const {
    x: t,
    y: n,
    width: a,
    height: r
  } = e;
  return {
    width: a,
    height: r,
    top: n,
    left: t,
    right: t + a,
    bottom: n + r,
    x: t,
    y: n
  };
}
function Hp(e, t, n) {
  let {
    reference: a,
    floating: r
  } = e;
  const o = Wn(t), s = Mc(t), i = Pc(s), u = fa(t), d = o === "y", c = a.x + a.width / 2 - r.width / 2, f = a.y + a.height / 2 - r.height / 2, p = a[i] / 2 - r[i] / 2;
  let v;
  switch (u) {
    case "top":
      v = {
        x: c,
        y: a.y - r.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: a.y + a.height
      };
      break;
    case "right":
      v = {
        x: a.x + a.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: a.x - r.width,
        y: f
      };
      break;
    default:
      v = {
        x: a.x,
        y: a.y
      };
  }
  switch (Jr(t)) {
    case "start":
      v[s] -= p * (n && d ? -1 : 1);
      break;
    case "end":
      v[s] += p * (n && d ? -1 : 1);
      break;
  }
  return v;
}
const ES = async (e, t, n) => {
  const {
    placement: a = "bottom",
    strategy: r = "absolute",
    middleware: o = [],
    platform: s
  } = n, i = o.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: c,
    y: f
  } = Hp(d, a, u), p = a, v = {}, m = 0;
  for (let g = 0; g < i.length; g++) {
    const {
      name: w,
      fn: C
    } = i[g], {
      x: S,
      y: $,
      data: B,
      reset: k
    } = await C({
      x: c,
      y: f,
      initialPlacement: a,
      placement: p,
      strategy: r,
      middlewareData: v,
      rects: d,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = S ?? c, f = $ ?? f, v = {
      ...v,
      [w]: {
        ...v[w],
        ...B
      }
    }, k && m <= 50 && (m++, typeof k == "object" && (k.placement && (p = k.placement), k.rects && (d = k.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : k.rects), {
      x: c,
      y: f
    } = Hp(d, p, u)), g = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: r,
    middlewareData: v
  };
};
async function zo(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: a,
    y: r,
    platform: o,
    rects: s,
    elements: i,
    strategy: u
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: v = 0
  } = ca(t, e), m = og(v), w = i[p ? f === "floating" ? "reference" : "floating" : f], C = Il(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(w))) == null || n ? w : w.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(i.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: u
  })), S = f === "floating" ? {
    x: a,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, $ = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(i.floating)), B = await (o.isElement == null ? void 0 : o.isElement($)) ? await (o.getScale == null ? void 0 : o.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, k = Il(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: S,
    offsetParent: $,
    strategy: u
  }) : S);
  return {
    top: (C.top - k.top + m.top) / B.y,
    bottom: (k.bottom - C.bottom + m.bottom) / B.y,
    left: (C.left - k.left + m.left) / B.x,
    right: (k.right - C.right + m.right) / B.x
  };
}
const TS = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: a,
      placement: r,
      rects: o,
      platform: s,
      elements: i,
      middlewareData: u
    } = t, {
      element: d,
      padding: c = 0
    } = ca(e, t) || {};
    if (d == null)
      return {};
    const f = og(c), p = {
      x: n,
      y: a
    }, v = Mc(r), m = Pc(v), g = await s.getDimensions(d), w = v === "y", C = w ? "top" : "left", S = w ? "bottom" : "right", $ = w ? "clientHeight" : "clientWidth", B = o.reference[m] + o.reference[v] - p[v] - o.floating[m], k = p[v] - o.reference[v], P = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d));
    let D = P ? P[$] : 0;
    (!D || !await (s.isElement == null ? void 0 : s.isElement(P))) && (D = i.floating[$] || o.floating[m]);
    const q = B / 2 - k / 2, T = D / 2 - g[m] / 2 - 1, M = Ta(f[C], T), O = Ta(f[S], T), F = M, J = D - g[m] - O, ne = D / 2 - g[m] / 2 + q, Q = bd(F, ne, J), W = !u.arrow && Jr(r) != null && ne !== Q && o.reference[m] / 2 - (ne < F ? M : O) - g[m] / 2 < 0, H = W ? ne < F ? ne - F : ne - J : 0;
    return {
      [v]: p[v] + H,
      data: {
        [v]: Q,
        centerOffset: ne - Q - H,
        ...W && {
          alignmentOffset: H
        }
      },
      reset: W
    };
  }
}), AS = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        middlewareData: o,
        rects: s,
        initialPlacement: i,
        platform: u,
        elements: d
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: g = !0,
        ...w
      } = ca(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const C = fa(r), S = Wn(i), $ = fa(i) === i, B = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)), k = p || ($ || !g ? [Al(i)] : kS(i)), P = m !== "none";
      !p && P && k.push(...MS(i, g, m, B));
      const D = [i, ...k], q = await zo(t, w), T = [];
      let M = ((a = o.flip) == null ? void 0 : a.overflows) || [];
      if (c && T.push(q[C]), f) {
        const ne = $S(r, s, B);
        T.push(q[ne[0]], q[ne[1]]);
      }
      if (M = [...M, {
        placement: r,
        overflows: T
      }], !T.every((ne) => ne <= 0)) {
        var O, F;
        const ne = (((O = o.flip) == null ? void 0 : O.index) || 0) + 1, Q = D[ne];
        if (Q && (!(f === "alignment" ? S !== Wn(Q) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        M.every((U) => Wn(U.placement) === S ? U.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ne,
              overflows: M
            },
            reset: {
              placement: Q
            }
          };
        let W = (F = M.filter((H) => H.overflows[0] <= 0).sort((H, U) => H.overflows[1] - U.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!W)
          switch (v) {
            case "bestFit": {
              var J;
              const H = (J = M.filter((U) => {
                if (P) {
                  const se = Wn(U.placement);
                  return se === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  se === "y";
                }
                return !0;
              }).map((U) => [U.placement, U.overflows.filter((se) => se > 0).reduce((se, ee) => se + ee, 0)]).sort((U, se) => U[1] - se[1])[0]) == null ? void 0 : J[0];
              H && (W = H);
              break;
            }
            case "initialPlacement":
              W = i;
              break;
          }
        if (r !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
};
function Up(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function jp(e) {
  return wS.some((t) => e[t] >= 0);
}
const IS = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: a = "referenceHidden",
        ...r
      } = ca(e, t);
      switch (a) {
        case "referenceHidden": {
          const o = await zo(t, {
            ...r,
            elementContext: "reference"
          }), s = Up(o, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: jp(s)
            }
          };
        }
        case "escaped": {
          const o = await zo(t, {
            ...r,
            altBoundary: !0
          }), s = Up(o, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: jp(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, sg = /* @__PURE__ */ new Set(["left", "top"]);
async function OS(e, t) {
  const {
    placement: n,
    platform: a,
    elements: r
  } = e, o = await (a.isRTL == null ? void 0 : a.isRTL(r.floating)), s = fa(n), i = Jr(n), u = Wn(n) === "y", d = sg.has(s) ? -1 : 1, c = o && u ? -1 : 1, f = ca(t, e);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return i && typeof m == "number" && (v = i === "end" ? m * -1 : m), u ? {
    x: v * c,
    y: p * d
  } : {
    x: p * d,
    y: v * c
  };
}
const RS = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, a;
      const {
        x: r,
        y: o,
        placement: s,
        middlewareData: i
      } = t, u = await OS(t, e);
      return s === ((n = i.offset) == null ? void 0 : n.placement) && (a = i.arrow) != null && a.alignmentOffset ? {} : {
        x: r + u.x,
        y: o + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, VS = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: a,
        placement: r
      } = t, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: i = {
          fn: (w) => {
            let {
              x: C,
              y: S
            } = w;
            return {
              x: C,
              y: S
            };
          }
        },
        ...u
      } = ca(e, t), d = {
        x: n,
        y: a
      }, c = await zo(t, u), f = Wn(fa(r)), p = Dc(f);
      let v = d[p], m = d[f];
      if (o) {
        const w = p === "y" ? "top" : "left", C = p === "y" ? "bottom" : "right", S = v + c[w], $ = v - c[C];
        v = bd(S, v, $);
      }
      if (s) {
        const w = f === "y" ? "top" : "left", C = f === "y" ? "bottom" : "right", S = m + c[w], $ = m - c[C];
        m = bd(S, m, $);
      }
      const g = i.fn({
        ...t,
        [p]: v,
        [f]: m
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - a,
          enabled: {
            [p]: o,
            [f]: s
          }
        }
      };
    }
  };
}, FS = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: a,
        placement: r,
        rects: o,
        middlewareData: s
      } = t, {
        offset: i = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = ca(e, t), c = {
        x: n,
        y: a
      }, f = Wn(r), p = Dc(f);
      let v = c[p], m = c[f];
      const g = ca(i, t), w = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (u) {
        const $ = p === "y" ? "height" : "width", B = o.reference[p] - o.floating[$] + w.mainAxis, k = o.reference[p] + o.reference[$] - w.mainAxis;
        v < B ? v = B : v > k && (v = k);
      }
      if (d) {
        var C, S;
        const $ = p === "y" ? "width" : "height", B = sg.has(fa(r)), k = o.reference[f] - o.floating[$] + (B && ((C = s.offset) == null ? void 0 : C[f]) || 0) + (B ? 0 : w.crossAxis), P = o.reference[f] + o.reference[$] + (B ? 0 : ((S = s.offset) == null ? void 0 : S[f]) || 0) - (B ? w.crossAxis : 0);
        m < k ? m = k : m > P && (m = P);
      }
      return {
        [p]: v,
        [f]: m
      };
    }
  };
}, NS = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        rects: o,
        platform: s,
        elements: i
      } = t, {
        apply: u = () => {
        },
        ...d
      } = ca(e, t), c = await zo(t, d), f = fa(r), p = Jr(r), v = Wn(r) === "y", {
        width: m,
        height: g
      } = o.floating;
      let w, C;
      f === "top" || f === "bottom" ? (w = f, C = p === (await (s.isRTL == null ? void 0 : s.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (C = f, w = p === "end" ? "top" : "bottom");
      const S = g - c.top - c.bottom, $ = m - c.left - c.right, B = Ta(g - c[w], S), k = Ta(m - c[C], $), P = !t.middlewareData.shift;
      let D = B, q = k;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (q = $), (a = t.middlewareData.shift) != null && a.enabled.y && (D = S), P && !p) {
        const M = fn(c.left, 0), O = fn(c.right, 0), F = fn(c.top, 0), J = fn(c.bottom, 0);
        v ? q = m - 2 * (M !== 0 || O !== 0 ? M + O : fn(c.left, c.right)) : D = g - 2 * (F !== 0 || J !== 0 ? F + J : fn(c.top, c.bottom));
      }
      await u({
        ...t,
        availableWidth: q,
        availableHeight: D
      });
      const T = await s.getDimensions(i.floating);
      return m !== T.width || g !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ki() {
  return typeof window < "u";
}
function dr(e) {
  return qc(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function vn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Qn(e) {
  var t;
  return (t = (qc(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function qc(e) {
  return ki() ? e instanceof Node || e instanceof vn(e).Node : !1;
}
function In(e) {
  return ki() ? e instanceof Element || e instanceof vn(e).Element : !1;
}
function Jn(e) {
  return ki() ? e instanceof HTMLElement || e instanceof vn(e).HTMLElement : !1;
}
function Wp(e) {
  return !ki() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof vn(e).ShadowRoot;
}
const LS = /* @__PURE__ */ new Set(["inline", "contents"]);
function _s(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: a,
    display: r
  } = On(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !LS.has(r);
}
const zS = /* @__PURE__ */ new Set(["table", "td", "th"]);
function HS(e) {
  return zS.has(dr(e));
}
const US = [":popover-open", ":modal"];
function Bi(e) {
  return US.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const jS = ["transform", "translate", "scale", "rotate", "perspective"], WS = ["transform", "translate", "scale", "rotate", "perspective", "filter"], GS = ["paint", "layout", "strict", "content"];
function Ec(e) {
  const t = Tc(), n = In(e) ? On(e) : e;
  return jS.some((a) => n[a] ? n[a] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || WS.some((a) => (n.willChange || "").includes(a)) || GS.some((a) => (n.contain || "").includes(a));
}
function KS(e) {
  let t = Aa(e);
  for (; Jn(t) && !Lr(t); ) {
    if (Ec(t))
      return t;
    if (Bi(t))
      return null;
    t = Aa(t);
  }
  return null;
}
function Tc() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const YS = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Lr(e) {
  return YS.has(dr(e));
}
function On(e) {
  return vn(e).getComputedStyle(e);
}
function Di(e) {
  return In(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Aa(e) {
  if (dr(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Wp(e) && e.host || // Fallback.
    Qn(e)
  );
  return Wp(t) ? t.host : t;
}
function lg(e) {
  const t = Aa(e);
  return Lr(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Jn(t) && _s(t) ? t : lg(t);
}
function Ho(e, t, n) {
  var a;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const r = lg(e), o = r === ((a = e.ownerDocument) == null ? void 0 : a.body), s = vn(r);
  if (o) {
    const i = wd(s);
    return t.concat(s, s.visualViewport || [], _s(r) ? r : [], i && n ? Ho(i) : []);
  }
  return t.concat(r, Ho(r, [], n));
}
function wd(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function ig(e) {
  const t = On(e);
  let n = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const r = Jn(e), o = r ? e.offsetWidth : n, s = r ? e.offsetHeight : a, i = Tl(n) !== o || Tl(a) !== s;
  return i && (n = o, a = s), {
    width: n,
    height: a,
    $: i
  };
}
function Ac(e) {
  return In(e) ? e : e.contextElement;
}
function Er(e) {
  const t = Ac(e);
  if (!Jn(t))
    return Gn(1);
  const n = t.getBoundingClientRect(), {
    width: a,
    height: r,
    $: o
  } = ig(t);
  let s = (o ? Tl(n.width) : n.width) / a, i = (o ? Tl(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: s,
    y: i
  };
}
const XS = /* @__PURE__ */ Gn(0);
function ug(e) {
  const t = vn(e);
  return !Tc() || !t.visualViewport ? XS : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function JS(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== vn(e) ? !1 : t;
}
function tr(e, t, n, a) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = Ac(e);
  let s = Gn(1);
  t && (a ? In(a) && (s = Er(a)) : s = Er(e));
  const i = JS(o, n, a) ? ug(o) : Gn(0);
  let u = (r.left + i.x) / s.x, d = (r.top + i.y) / s.y, c = r.width / s.x, f = r.height / s.y;
  if (o) {
    const p = vn(o), v = a && In(a) ? vn(a) : a;
    let m = p, g = wd(m);
    for (; g && a && v !== m; ) {
      const w = Er(g), C = g.getBoundingClientRect(), S = On(g), $ = C.left + (g.clientLeft + parseFloat(S.paddingLeft)) * w.x, B = C.top + (g.clientTop + parseFloat(S.paddingTop)) * w.y;
      u *= w.x, d *= w.y, c *= w.x, f *= w.y, u += $, d += B, m = vn(g), g = wd(m);
    }
  }
  return Il({
    width: c,
    height: f,
    x: u,
    y: d
  });
}
function Pi(e, t) {
  const n = Di(e).scrollLeft;
  return t ? t.left + n : tr(Qn(e)).left + n;
}
function dg(e, t) {
  const n = e.getBoundingClientRect(), a = n.left + t.scrollLeft - Pi(e, n), r = n.top + t.scrollTop;
  return {
    x: a,
    y: r
  };
}
function ZS(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: a,
    strategy: r
  } = e;
  const o = r === "fixed", s = Qn(a), i = t ? Bi(t.floating) : !1;
  if (a === s || i && o)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = Gn(1);
  const c = Gn(0), f = Jn(a);
  if ((f || !f && !o) && ((dr(a) !== "body" || _s(s)) && (u = Di(a)), Jn(a))) {
    const v = tr(a);
    d = Er(a), c.x = v.x + a.clientLeft, c.y = v.y + a.clientTop;
  }
  const p = s && !f && !o ? dg(s, u) : Gn(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - u.scrollLeft * d.x + c.x + p.x,
    y: n.y * d.y - u.scrollTop * d.y + c.y + p.y
  };
}
function QS(e) {
  return Array.from(e.getClientRects());
}
function e$(e) {
  const t = Qn(e), n = Di(e), a = e.ownerDocument.body, r = fn(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), o = fn(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let s = -n.scrollLeft + Pi(e);
  const i = -n.scrollTop;
  return On(a).direction === "rtl" && (s += fn(t.clientWidth, a.clientWidth) - r), {
    width: r,
    height: o,
    x: s,
    y: i
  };
}
const Gp = 25;
function t$(e, t) {
  const n = vn(e), a = Qn(e), r = n.visualViewport;
  let o = a.clientWidth, s = a.clientHeight, i = 0, u = 0;
  if (r) {
    o = r.width, s = r.height;
    const c = Tc();
    (!c || c && t === "fixed") && (i = r.offsetLeft, u = r.offsetTop);
  }
  const d = Pi(a);
  if (d <= 0) {
    const c = a.ownerDocument, f = c.body, p = getComputedStyle(f), v = c.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0, m = Math.abs(a.clientWidth - f.clientWidth - v);
    m <= Gp && (o -= m);
  } else d <= Gp && (o += d);
  return {
    width: o,
    height: s,
    x: i,
    y: u
  };
}
const n$ = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function a$(e, t) {
  const n = tr(e, !0, t === "fixed"), a = n.top + e.clientTop, r = n.left + e.clientLeft, o = Jn(e) ? Er(e) : Gn(1), s = e.clientWidth * o.x, i = e.clientHeight * o.y, u = r * o.x, d = a * o.y;
  return {
    width: s,
    height: i,
    x: u,
    y: d
  };
}
function Kp(e, t, n) {
  let a;
  if (t === "viewport")
    a = t$(e, n);
  else if (t === "document")
    a = e$(Qn(e));
  else if (In(t))
    a = a$(t, n);
  else {
    const r = ug(e);
    a = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return Il(a);
}
function cg(e, t) {
  const n = Aa(e);
  return n === t || !In(n) || Lr(n) ? !1 : On(n).position === "fixed" || cg(n, t);
}
function r$(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let a = Ho(e, [], !1).filter((i) => In(i) && dr(i) !== "body"), r = null;
  const o = On(e).position === "fixed";
  let s = o ? Aa(e) : e;
  for (; In(s) && !Lr(s); ) {
    const i = On(s), u = Ec(s);
    !u && i.position === "fixed" && (r = null), (o ? !u && !r : !u && i.position === "static" && !!r && n$.has(r.position) || _s(s) && !u && cg(e, s)) ? a = a.filter((c) => c !== s) : r = i, s = Aa(s);
  }
  return t.set(e, a), a;
}
function o$(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: a,
    strategy: r
  } = e;
  const s = [...n === "clippingAncestors" ? Bi(t) ? [] : r$(t, this._c) : [].concat(n), a], i = s[0], u = s.reduce((d, c) => {
    const f = Kp(t, c, r);
    return d.top = fn(f.top, d.top), d.right = Ta(f.right, d.right), d.bottom = Ta(f.bottom, d.bottom), d.left = fn(f.left, d.left), d;
  }, Kp(t, i, r));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function s$(e) {
  const {
    width: t,
    height: n
  } = ig(e);
  return {
    width: t,
    height: n
  };
}
function l$(e, t, n) {
  const a = Jn(t), r = Qn(t), o = n === "fixed", s = tr(e, !0, o, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = Gn(0);
  function d() {
    u.x = Pi(r);
  }
  if (a || !a && !o)
    if ((dr(t) !== "body" || _s(r)) && (i = Di(t)), a) {
      const v = tr(t, !0, o, t);
      u.x = v.x + t.clientLeft, u.y = v.y + t.clientTop;
    } else r && d();
  o && !a && r && d();
  const c = r && !a && !o ? dg(r, i) : Gn(0), f = s.left + i.scrollLeft - u.x - c.x, p = s.top + i.scrollTop - u.y - c.y;
  return {
    x: f,
    y: p,
    width: s.width,
    height: s.height
  };
}
function Eu(e) {
  return On(e).position === "static";
}
function Yp(e, t) {
  if (!Jn(e) || On(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Qn(e) === n && (n = n.ownerDocument.body), n;
}
function fg(e, t) {
  const n = vn(e);
  if (Bi(e))
    return n;
  if (!Jn(e)) {
    let r = Aa(e);
    for (; r && !Lr(r); ) {
      if (In(r) && !Eu(r))
        return r;
      r = Aa(r);
    }
    return n;
  }
  let a = Yp(e, t);
  for (; a && HS(a) && Eu(a); )
    a = Yp(a, t);
  return a && Lr(a) && Eu(a) && !Ec(a) ? n : a || KS(e) || n;
}
const i$ = async function(e) {
  const t = this.getOffsetParent || fg, n = this.getDimensions, a = await n(e.floating);
  return {
    reference: l$(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function u$(e) {
  return On(e).direction === "rtl";
}
const d$ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ZS,
  getDocumentElement: Qn,
  getClippingRect: o$,
  getOffsetParent: fg,
  getElementRects: i$,
  getClientRects: QS,
  getDimensions: s$,
  getScale: Er,
  isElement: In,
  isRTL: u$
};
function pg(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function c$(e, t) {
  let n = null, a;
  const r = Qn(e);
  function o() {
    var i;
    clearTimeout(a), (i = n) == null || i.disconnect(), n = null;
  }
  function s(i, u) {
    i === void 0 && (i = !1), u === void 0 && (u = 1), o();
    const d = e.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: v
    } = d;
    if (i || t(), !p || !v)
      return;
    const m = Ns(f), g = Ns(r.clientWidth - (c + p)), w = Ns(r.clientHeight - (f + v)), C = Ns(c), $ = {
      rootMargin: -m + "px " + -g + "px " + -w + "px " + -C + "px",
      threshold: fn(0, Ta(1, u)) || 1
    };
    let B = !0;
    function k(P) {
      const D = P[0].intersectionRatio;
      if (D !== u) {
        if (!B)
          return s();
        D ? s(!1, D) : a = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !pg(d, e.getBoundingClientRect()) && s(), B = !1;
    }
    try {
      n = new IntersectionObserver(k, {
        ...$,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(k, $);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function f$(e, t, n, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = a, d = Ac(e), c = r || o ? [...d ? Ho(d) : [], ...Ho(t)] : [];
  c.forEach((C) => {
    r && C.addEventListener("scroll", n, {
      passive: !0
    }), o && C.addEventListener("resize", n);
  });
  const f = d && i ? c$(d, n) : null;
  let p = -1, v = null;
  s && (v = new ResizeObserver((C) => {
    let [S] = C;
    S && S.target === d && v && (v.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var $;
      ($ = v) == null || $.observe(t);
    })), n();
  }), d && !u && v.observe(d), v.observe(t));
  let m, g = u ? tr(e) : null;
  u && w();
  function w() {
    const C = tr(e);
    g && !pg(g, C) && n(), g = C, m = requestAnimationFrame(w);
  }
  return n(), () => {
    var C;
    c.forEach((S) => {
      r && S.removeEventListener("scroll", n), o && S.removeEventListener("resize", n);
    }), f?.(), (C = v) == null || C.disconnect(), v = null, u && cancelAnimationFrame(m);
  };
}
const p$ = RS, v$ = VS, Xp = AS, m$ = NS, h$ = IS, g$ = TS, y$ = FS, b$ = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), r = {
    platform: d$,
    ...n
  }, o = {
    ...r.platform,
    _c: a
  };
  return ES(e, t, {
    ...r,
    platform: o
  });
};
function _$(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function xd(e) {
  if (_$(e)) {
    const t = e.$el;
    return qc(t) && dr(t) === "#comment" ? null : t;
  }
  return e;
}
function $r(e) {
  return typeof e == "function" ? e() : l(e);
}
function w$(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = xd($r(e.element));
      return n == null ? {} : g$({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
function vg(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Jp(e, t) {
  const n = vg(e);
  return Math.round(t * n) / n;
}
function x$(e, t, n) {
  n === void 0 && (n = {});
  const a = n.whileElementsMounted, r = E(() => {
    var D;
    return (D = $r(n.open)) != null ? D : !0;
  }), o = E(() => $r(n.middleware)), s = E(() => {
    var D;
    return (D = $r(n.placement)) != null ? D : "bottom";
  }), i = E(() => {
    var D;
    return (D = $r(n.strategy)) != null ? D : "absolute";
  }), u = E(() => {
    var D;
    return (D = $r(n.transform)) != null ? D : !0;
  }), d = E(() => xd(e.value)), c = E(() => xd(t.value)), f = I(0), p = I(0), v = I(i.value), m = I(s.value), g = gt({}), w = I(!1), C = E(() => {
    const D = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return D;
    const q = Jp(c.value, f.value), T = Jp(c.value, p.value);
    return u.value ? {
      ...D,
      transform: "translate(" + q + "px, " + T + "px)",
      ...vg(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: q + "px",
      top: T + "px"
    };
  });
  let S;
  function $() {
    if (d.value == null || c.value == null)
      return;
    const D = r.value;
    b$(d.value, c.value, {
      middleware: o.value,
      placement: s.value,
      strategy: i.value
    }).then((q) => {
      f.value = q.x, p.value = q.y, v.value = q.strategy, m.value = q.placement, g.value = q.middlewareData, w.value = D !== !1;
    });
  }
  function B() {
    typeof S == "function" && (S(), S = void 0);
  }
  function k() {
    if (B(), a === void 0) {
      $();
      return;
    }
    if (d.value != null && c.value != null) {
      S = a(d.value, c.value, $);
      return;
    }
  }
  function P() {
    r.value || (w.value = !1);
  }
  return ve([o, s, i, r], $, {
    flush: "sync"
  }), ve([d, c], k, {
    flush: "sync"
  }), ve(r, P, {
    flush: "sync"
  }), ss() && sc(B), {
    x: br(f),
    y: br(p),
    strategy: br(v),
    placement: br(m),
    middlewareData: br(g),
    isPositioned: br(w),
    floatingStyles: C,
    update: $
  };
}
const mg = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [C$, S$] = Be("PopperContent");
var $$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ th({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...mg }),
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = rg(), { forwardRef: o, currentElement: s } = j(), i = I(), u = I(), { width: d, height: c } = zh(u), f = E(() => n.side + (n.align !== "center" ? `-${n.align}` : "")), p = E(() => typeof n.collisionPadding == "number" ? n.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...n.collisionPadding
    }), v = E(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = E(() => ({
      padding: p.value,
      boundary: v.value.filter(bS),
      altBoundary: v.value.length > 0
    })), g = E(() => ({
      mainAxis: n.sideFlip,
      crossAxis: n.alignFlip
    })), w = V0(() => [
      p$({
        mainAxis: n.sideOffset + c.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && Xp({
        ...m.value,
        ...g.value
      }),
      n.avoidCollisions && v$({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? y$() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && Xp({
        ...m.value,
        ...g.value
      }),
      m$({
        ...m.value,
        apply: ({ elements: F, rects: J, availableWidth: ne, availableHeight: Q }) => {
          const { width: W, height: H } = J.reference, U = F.floating.style;
          U.setProperty("--reka-popper-available-width", `${ne}px`), U.setProperty("--reka-popper-available-height", `${Q}px`), U.setProperty("--reka-popper-anchor-width", `${W}px`), U.setProperty("--reka-popper-anchor-height", `${H}px`);
        }
      }),
      u.value && w$({
        element: u.value,
        padding: n.arrowPadding
      }),
      _S({
        arrowWidth: d.value,
        arrowHeight: c.value
      }),
      n.hideWhenDetached && h$({
        strategy: "referenceHidden",
        ...m.value
      })
    ]), C = E(() => n.reference ?? r.anchor.value), { floatingStyles: S, placement: $, isPositioned: B, middlewareData: k } = x$(C, i, {
      strategy: n.positionStrategy,
      placement: f,
      whileElementsMounted: (...F) => f$(...F, {
        layoutShift: !n.disableUpdateOnLayoutShift,
        animationFrame: n.updatePositionStrategy === "always"
      }),
      middleware: w
    }), P = E(() => yd($.value)[0]), D = E(() => yd($.value)[1]);
    eh(() => {
      B.value && a("placed");
    });
    const q = E(() => k.value.arrow?.centerOffset !== 0), T = I("");
    Ie(() => {
      s.value && (T.value = window.getComputedStyle(s.value).zIndex);
    });
    const M = E(() => k.value.arrow?.x ?? 0), O = E(() => k.value.arrow?.y ?? 0);
    return S$({
      placedSide: P,
      onArrowChange: (F) => u.value = F,
      arrowX: M,
      arrowY: O,
      shouldHideArrow: q
    }), (F, J) => (h(), G("div", {
      ref_key: "floatingRef",
      ref: i,
      "data-reka-popper-content-wrapper": "",
      style: dt({
        ...l(S),
        transform: l(B) ? l(S).transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: T.value,
        "--reka-popper-transform-origin": [l(k).transformOrigin?.x, l(k).transformOrigin?.y].join(" "),
        ...l(k).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [N(l(X), A({ ref: l(o) }, F.$attrs, {
      "as-child": n.asChild,
      as: F.as,
      "data-side": P.value,
      "data-align": D.value,
      style: { animation: l(B) ? void 0 : "none" }
    }), {
      default: y(() => [_(F.$slots, "default")]),
      _: 3
    }, 16, [
      "as-child",
      "as",
      "data-side",
      "data-align",
      "style"
    ])], 4));
  }
}), Zr = $$;
const k$ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var B$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {
      type: Number,
      required: !1
    },
    height: {
      type: Number,
      required: !1
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = C$(), a = E(() => k$[n.placedSide.value]);
    return (r, o) => (h(), G("span", {
      ref: (s) => {
        l(n).onArrowChange(s);
      },
      style: dt({
        position: "absolute",
        left: l(n).arrowX?.value ? `${l(n).arrowX?.value}px` : void 0,
        top: l(n).arrowY?.value ? `${l(n).arrowY?.value}px` : void 0,
        [a.value]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[l(n).placedSide.value],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[l(n).placedSide.value],
        visibility: l(n).shouldHideArrow.value ? "hidden" : void 0
      })
    }, [N(yS, A(r.$attrs, {
      ref: l(t),
      style: { display: "block" },
      as: r.as,
      "as-child": r.asChild,
      rounded: r.rounded,
      width: r.width,
      height: r.height
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "rounded",
      "width",
      "height"
    ])], 4));
  }
}), D$ = B$, P$ = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: t } = j();
    return (n, a) => (h(), x(l(ur), {
      "as-child": "",
      reference: n.reference
    }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "as-child": n.asChild,
        as: n.as
      }, n.$attrs), {
        default: y(() => [_(n.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), M$ = P$;
function q$(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => qo(a, t, n)) : qo(e, t, n);
}
function qo(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : En(e, t);
}
const [Mi, E$] = Be("ListboxRoot");
var T$ = /* @__PURE__ */ b({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { multiple: o, highlightOnHover: s, orientation: i, disabled: u, selectionBehavior: d, dir: c } = Me(a), { getItems: f } = st({ isProvider: !0 }), { handleTypeaheadSearch: p } = gi(), { primitiveElement: v, currentElement: m } = Ht(), g = ms(), w = yt(c), C = Rn(m), S = I(), $ = I(!1), B = I(!0), k = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (o.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function P(R) {
      if ($.value = !0, a.multiple) {
        const te = Array.isArray(k.value) ? [...k.value] : [], z = te.findIndex((ae) => qo(ae, R, a.by));
        a.selectionBehavior === "toggle" ? (z === -1 ? te.push(R) : te.splice(z, 1), k.value = te) : (k.value = [R], S.value = R);
      } else a.selectionBehavior === "toggle" && qo(k.value, R, a.by) ? k.value = void 0 : k.value = R;
      setTimeout(() => {
        $.value = !1;
      }, 1);
    }
    const D = I(null), q = I(null), T = I(!1), M = I(!1), O = Dr(), F = Dr(), J = Dr();
    function ne() {
      return f().map((R) => R.ref).filter((R) => R.dataset.disabled !== "");
    }
    function Q(R, te = !0) {
      if (!R) return;
      D.value = R, B.value && D.value.focus(), te && D.value.scrollIntoView({ block: "nearest" });
      const z = f().find((ae) => ae.ref === R);
      r("highlight", z);
    }
    function W(R) {
      if (T.value) J.trigger(R);
      else {
        const te = f().find((z) => qo(z.value, R, a.by));
        te && (D.value = te.ref, Q(te.ref));
      }
    }
    function H(R) {
      D.value && D.value.isConnected && (R.preventDefault(), R.stopPropagation(), M.value || D.value.click());
    }
    function U(R) {
      if (B.value) {
        if ($.value = !0, T.value) F.trigger(R);
        else {
          const te = R.altKey || R.ctrlKey || R.metaKey;
          if (te && R.key === "a" && o.value) {
            const z = f(), ae = z.map((ie) => ie.value);
            k.value = [...ae], R.preventDefault(), Q(z[z.length - 1].ref);
          } else if (!te) {
            const z = p(R.key, f());
            z && Q(z);
          }
        }
        setTimeout(() => {
          $.value = !1;
        }, 1);
      }
    }
    function se() {
      M.value = !0;
    }
    function ee() {
      ke(() => {
        M.value = !1;
      });
    }
    function de() {
      ke(() => {
        const R = new KeyboardEvent("keydown", { key: "PageUp" });
        ge(R);
      });
    }
    function pe(R) {
      const te = D.value;
      te?.isConnected && (q.value = te), D.value = null, r("leave", R);
    }
    function _e(R) {
      const te = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if (R.currentTarget?.dispatchEvent(te), r("entryFocus", te), !te.defaultPrevented)
        if (q.value) Q(q.value);
        else {
          const z = ne()?.[0];
          Q(z);
        }
    }
    function ge(R) {
      const te = tg(R, i.value, w.value);
      if (!te) return;
      let z = ne();
      if (D.value) {
        if (te === "last") z.reverse();
        else if (te === "prev" || te === "next") {
          te === "prev" && z.reverse();
          const ae = z.indexOf(D.value);
          z = z.slice(ae + 1);
        }
        Te(R, z[0]);
      }
      if (z.length) {
        const ae = !D.value && te === "prev" ? z.length - 1 : 0;
        Q(z[ae]);
      }
      if (T.value) return F.trigger(R);
    }
    function Te(R, te) {
      if (!(T.value || a.selectionBehavior !== "replace" || !o.value || !Array.isArray(k.value) || (R.altKey || R.ctrlKey || R.metaKey) && !R.shiftKey) && R.shiftKey) {
        const ae = f().filter((be) => be.ref.dataset.disabled !== "");
        let ie = ae.find((be) => be.ref === te)?.value;
        if (R.key === g.END ? ie = ae[ae.length - 1].value : R.key === g.HOME && (ie = ae[0].value), !ie || !S.value) return;
        const L = I0(ae.map((be) => be.value), S.value, ie);
        k.value = L;
      }
    }
    async function ce(R) {
      if (await ke(), T.value) O.trigger(R);
      else {
        const te = ne(), z = te.find((ae) => ae.dataset.state === "checked");
        z ? Q(z) : te.length && Q(te[0]);
      }
    }
    return ve(k, () => {
      $.value || ke(() => {
        ce();
      });
    }, {
      immediate: !0,
      deep: !0
    }), t({
      highlightedElement: D,
      highlightItem: W,
      highlightFirstItem: de,
      highlightSelected: ce,
      getItems: f
    }), E$({
      modelValue: k,
      onValueChange: P,
      multiple: o,
      orientation: i,
      dir: w,
      disabled: u,
      highlightOnHover: s,
      highlightedElement: D,
      isVirtual: T,
      virtualFocusHook: O,
      virtualKeydownHook: F,
      virtualHighlightHook: J,
      by: a.by,
      firstValue: S,
      selectionBehavior: d,
      focusable: B,
      onLeave: pe,
      onEnter: _e,
      changeHighlight: Q,
      onKeydownEnter: H,
      onKeydownNavigation: ge,
      onKeydownTypeAhead: U,
      onCompositionStart: se,
      onCompositionEnd: ee,
      highlightFirstItem: de
    }), (R, te) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: v,
      as: R.as,
      "as-child": R.asChild,
      dir: l(w),
      "data-disabled": l(u) ? "" : void 0,
      onPointerleave: pe,
      onFocusout: te[0] || (te[0] = async (z) => {
        const ae = z.relatedTarget || z.target;
        await ke(), D.value && l(m) && !l(m).contains(ae) && pe(z);
      })
    }, {
      default: y(() => [_(R.$slots, "default", { modelValue: l(k) }), l(C) && R.name ? (h(), x(l(Vn), {
        key: 0,
        name: R.name,
        value: l(k),
        disabled: l(u),
        required: R.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), hg = T$, A$ = /* @__PURE__ */ b({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: t } = st(), n = Mi(), a = cs(!1, 10);
    return (r, o) => (h(), x(l(t), null, {
      default: y(() => [N(l(X), {
        role: "listbox",
        as: r.as,
        "as-child": r.asChild,
        tabindex: l(n).focusable.value ? l(n).highlightedElement.value ? "-1" : "0" : "-1",
        "aria-orientation": l(n).orientation.value,
        "aria-multiselectable": !!l(n).multiple.value,
        "data-orientation": l(n).orientation.value,
        onMousedown: o[0] || (o[0] = Ke((s) => a.value = !0, ["left"])),
        onFocus: o[1] || (o[1] = (s) => {
          l(a) || l(n).onEnter(s);
        }),
        onKeydown: [
          o[2] || (o[2] = Je((s) => {
            l(n).orientation.value === "vertical" && (s.key === "ArrowLeft" || s.key === "ArrowRight") || l(n).orientation.value === "horizontal" && (s.key === "ArrowUp" || s.key === "ArrowDown") || (s.preventDefault(), l(n).focusable.value && l(n).onKeydownNavigation(s));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          Je(l(n).onKeydownEnter, ["enter"]),
          l(n).onKeydownTypeAhead
        ]
      }, {
        default: y(() => [_(r.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), gg = A$, I$ = /* @__PURE__ */ b({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "modelValue", t, {
      defaultValue: "",
      passive: n.modelValue === void 0
    }), o = Mi(), { primitiveElement: s, currentElement: i } = Ht(), u = E(() => n.disabled || o.disabled.value || !1), d = I();
    return _0(() => d.value = o.highlightedElement.value?.id), Ce(() => {
      o.focusable.value = !1, setTimeout(() => {
        n.autoFocus && i.value?.focus();
      }, 1);
    }), Qe(() => {
      o.focusable.value = !0;
    }), (c, f) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: s,
      as: c.as,
      "as-child": c.asChild,
      value: l(r),
      disabled: u.value ? "" : void 0,
      "data-disabled": u.value ? "" : void 0,
      "aria-disabled": u.value ?? void 0,
      "aria-activedescendant": d.value,
      type: "text",
      onKeydown: [Je(Ke(l(o).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), Je(l(o).onKeydownEnter, ["enter"])],
      onInput: f[0] || (f[0] = (p) => {
        r.value = p.target.value, l(o).highlightFirstItem();
      }),
      onCompositionstart: l(o).onCompositionStart,
      onCompositionend: l(o).onCompositionEnd
    }, {
      default: y(() => [_(c.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), yg = I$;
const [O$, R$] = Be("ListboxGroup");
var V$ = /* @__PURE__ */ b({
  __name: "ListboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-listbox-group");
    return R$({ id: n }), (a, r) => (h(), x(l(X), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), bg = V$, F$ = /* @__PURE__ */ b({
  __name: "ListboxGroupLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = O$({ id: "" });
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).id }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), N$ = F$;
const L$ = "listbox.select", [z$, H$] = Be("ListboxItem");
var U$ = /* @__PURE__ */ b({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ge(void 0, "reka-listbox-item"), { CollectionItem: o } = st(), { forwardRef: s, currentElement: i } = j(), u = Mi(), d = E(() => i.value === u.highlightedElement.value), c = E(() => q$(u.modelValue.value, n.value, u.by)), f = E(() => u.disabled.value || n.disabled);
    async function p(m) {
      a("select", m), !m?.defaultPrevented && !f.value && m && (u.onValueChange(n.value), u.changeHighlight(i.value));
    }
    function v(m) {
      const g = {
        originalEvent: m,
        value: n.value
      };
      is(L$, p, g);
    }
    return H$({ isSelected: c }), (m, g) => (h(), x(l(o), { value: m.value }, {
      default: y(() => [w0([d.value, c.value], () => N(l(X), A({ id: l(r) }, m.$attrs, {
        ref: l(s),
        role: "option",
        tabindex: l(u).focusable.value ? d.value ? "0" : "-1" : -1,
        "aria-selected": c.value,
        as: m.as,
        "as-child": m.asChild,
        disabled: f.value ? "" : void 0,
        "data-disabled": f.value ? "" : void 0,
        "data-highlighted": d.value ? "" : void 0,
        "data-state": c.value ? "checked" : "unchecked",
        onClick: v,
        onKeydown: Je(Ke(v, ["prevent"]), ["space"]),
        onPointermove: g[0] || (g[0] = () => {
          l(u).highlightedElement.value !== l(i) && l(u).highlightOnHover.value && !l(u).focusable.value && l(u).changeHighlight(l(i), !1);
        })
      }), {
        default: y(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), g, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), _g = U$, j$ = /* @__PURE__ */ b({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = z$();
    return (a, r) => l(n).isSelected.value ? (h(), x(l(X), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), W$ = j$;
const [ya, G$] = Be("ComboboxRoot");
var K$ = /* @__PURE__ */ b({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    resetModelValueOnClear: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1,
      default: !0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { primitiveElement: o, currentElement: s } = Ht(), { multiple: i, disabled: u, ignoreFilter: d, resetSearchTermOnSelect: c, openOnFocus: f, openOnClick: p, dir: v, resetModelValueOnClear: m, highlightOnHover: g } = Me(a), w = yt(v), C = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (i.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), S = Ve(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function $(W) {
      S.value = W, J.value = "", W ? (await ke(), o.value?.highlightSelected(), k.value = !0, D.value?.focus()) : (k.value = !1, setTimeout(() => {
        !W && a.resetSearchTermOnBlur && B.trigger();
      }, 1));
    }
    const B = Dr(), k = I(!1), P = I(!1), D = I(), q = I(), T = E(() => o.value?.highlightedElement ?? void 0), M = I(/* @__PURE__ */ new Map()), O = I(/* @__PURE__ */ new Map()), { contains: F } = Fh({ sensitivity: "base" }), J = I(""), ne = E((W) => {
      if (!J.value || a.ignoreFilter || P.value) return {
        count: M.value.size,
        items: W?.items ?? /* @__PURE__ */ new Map(),
        groups: W?.groups ?? new Set(O.value.keys())
      };
      let H = 0;
      const U = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Set();
      for (const [ee, de] of M.value) {
        const pe = F(de, J.value);
        U.set(ee, pe ? 1 : 0), pe && H++;
      }
      for (const [ee, de] of O.value) for (const pe of de) if (U.get(pe) > 0) {
        se.add(ee);
        break;
      }
      return {
        count: H,
        items: U,
        groups: se
      };
    }), Q = ht();
    return Ce(() => {
      Q?.exposed && (Q.exposed.highlightItem = o.value?.highlightItem, Q.exposed.highlightFirstItem = o.value?.highlightFirstItem, Q.exposed.highlightSelected = o.value?.highlightSelected);
    }), t({
      filtered: ne,
      highlightedElement: T,
      highlightItem: o.value?.highlightItem,
      highlightFirstItem: o.value?.highlightFirstItem,
      highlightSelected: o.value?.highlightSelected
    }), G$({
      modelValue: C,
      multiple: i,
      disabled: u,
      open: S,
      onOpenChange: $,
      contentId: "",
      isUserInputted: k,
      isVirtual: P,
      inputElement: D,
      highlightedElement: T,
      onInputElementChange: (W) => D.value = W,
      triggerElement: q,
      onTriggerElementChange: (W) => q.value = W,
      parentElement: s,
      resetSearchTermOnSelect: c,
      onResetSearchTerm: B.on,
      allItems: M,
      allGroups: O,
      filterSearch: J,
      filterState: ne,
      ignoreFilter: d,
      openOnFocus: f,
      openOnClick: p,
      resetModelValueOnClear: m
    }), (W, H) => (h(), x(l(ir), null, {
      default: y(() => [N(l(hg), A({
        ref_key: "primitiveElement",
        ref: o
      }, W.$attrs, {
        modelValue: l(C),
        "onUpdate:modelValue": H[0] || (H[0] = (U) => mt(C) ? C.value = U : null),
        style: { pointerEvents: l(S) ? "auto" : void 0 },
        as: W.as,
        "as-child": W.asChild,
        dir: l(w),
        multiple: l(i),
        name: W.name,
        required: W.required,
        disabled: l(u),
        "highlight-on-hover": l(g),
        by: a.by,
        onHighlight: H[1] || (H[1] = (U) => r("highlight", U))
      }), {
        default: y(() => [_(W.$slots, "default", {
          open: l(S),
          modelValue: l(C)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "highlight-on-hover",
        "by"
      ])]),
      _: 3
    }));
  }
}), Y$ = K$;
const [C7, X$] = Be("ComboboxContent");
var J$ = /* @__PURE__ */ b({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { position: r } = Me(n), o = ya(), { forwardRef: s, currentElement: i } = j();
    fs(n.bodyLock), vs(o.parentElement);
    const u = E(() => n.position === "popper" ? n : {}), d = he(u.value), c = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    X$({ position: r });
    const f = I(!1);
    return Ce(() => {
      o.inputElement.value && (f.value = i.value.contains(o.inputElement.value), f.value && o.inputElement.value.focus());
    }), Qe(() => {
      const p = ot();
      f.value && (!p || p === document.body) && o.triggerElement.value?.focus();
    }), (p, v) => (h(), x(l(gg), { "as-child": "" }, {
      default: y(() => [N(l(Fa), {
        "as-child": "",
        "disable-outside-pointer-events": p.disableOutsidePointerEvents,
        onDismiss: v[0] || (v[0] = (m) => l(o).onOpenChange(!1)),
        onFocusOutside: v[1] || (v[1] = (m) => {
          l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("focusOutside", m);
        }),
        onInteractOutside: v[2] || (v[2] = (m) => a("interactOutside", m)),
        onEscapeKeyDown: v[3] || (v[3] = (m) => a("escapeKeyDown", m)),
        onPointerDownOutside: v[4] || (v[4] = (m) => {
          l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("pointerDownOutside", m);
        })
      }, {
        default: y(() => [(h(), x(Tt(l(r) === "popper" ? l(Zr) : l(X)), A({
          ...p.$attrs,
          ...l(d)
        }, {
          id: l(o).contentId,
          ref: l(s),
          "data-state": l(o).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...l(r) === "popper" ? c : {}
          }
        }), {
          default: y(() => [_(p.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), Z$ = J$, Q$ = /* @__PURE__ */ b({
  __name: "ComboboxCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = ya();
    function a() {
      n.filterSearch.value = "", n.inputElement.value && (n.inputElement.value.value = "", n.inputElement.value.focus()), n.resetModelValueOnClear?.value && (n.modelValue.value = n.multiple.value ? [] : null);
    }
    return (r, o) => (h(), x(l(X), A({ type: r.as === "button" ? "button" : void 0 }, t, {
      tabindex: "-1",
      onClick: a
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), S7 = Q$, ek = /* @__PURE__ */ b({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), { forwardRef: o } = j(), s = ya();
    return s.contentId ||= Ge(void 0, "reka-combobox-content"), (i, u) => (h(), x(l(St), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(Z$, A({
        ...l(r),
        ...i.$attrs
      }, { ref: l(o) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), tk = ek, nk = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ya(), a = E(() => n.ignoreFilter.value ? n.allItems.value.size === 0 : n.filterState.value.count === 0);
    return (r, o) => a.value ? (h(), x(l(X), oe(A({ key: 0 }, t)), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[0] || (o[0] = Re("No options"))])]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), ak = nk;
const [wg, rk] = Be("ComboboxGroup");
var ok = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-combobox-group"), a = ya(), r = E(() => a.ignoreFilter.value ? !0 : a.filterSearch.value ? a.filterState.value.groups.has(n) : !0), o = rk({
      id: n,
      labelId: ""
    });
    return Ce(() => {
      a.allGroups.value.has(n) || a.allGroups.value.set(n, /* @__PURE__ */ new Set());
    }), Qe(() => {
      a.allGroups.value.delete(n);
    }), (s, i) => (h(), x(l(bg), A({
      id: l(n),
      "aria-labelledby": l(o).labelId
    }, t, { hidden: r.value ? void 0 : !0 }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "hidden"
    ]));
  }
}), sk = ok, lk = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ya(), o = Mi(), { primitiveElement: s, currentElement: i } = Ht(), u = Ve(n, "modelValue", a, { passive: n.modelValue === void 0 });
    Ce(() => {
      i.value && r.onInputElementChange(i.value);
    });
    function d(m) {
      r.open.value || r.onOpenChange(!0);
    }
    function c(m) {
      const g = m.target;
      r.open.value ? r.filterSearch.value = g.value : (r.onOpenChange(!0), ke(() => {
        g.value && (r.filterSearch.value = g.value, o.highlightFirstItem());
      }));
    }
    function f() {
      r.openOnFocus.value && !r.open.value && r.onOpenChange(!0);
    }
    function p() {
      r.openOnClick.value && !r.open.value && r.onOpenChange(!0);
    }
    function v() {
      const m = r.modelValue.value;
      n.displayValue ? u.value = n.displayValue(m) : !r.multiple.value && m && !Array.isArray(m) && typeof m != "object" ? u.value = m.toString() : u.value = "", ke(() => {
        u.value = u.value;
      });
    }
    return r.onResetSearchTerm(() => {
      v();
    }), ve(r.modelValue, async () => {
      !r.isUserInputted.value && r.resetSearchTermOnSelect.value && v();
    }, {
      immediate: !0,
      deep: !0
    }), ve(r.filterState, (m, g) => {
      !r.isVirtual.value && g.count === 0 && o.highlightFirstItem();
    }), (m, g) => (h(), x(l(yg), {
      ref_key: "primitiveElement",
      ref: s,
      modelValue: l(u),
      "onUpdate:modelValue": g[0] || (g[0] = (w) => mt(u) ? u.value = w : null),
      as: m.as,
      "as-child": m.asChild,
      "auto-focus": m.autoFocus,
      disabled: m.disabled,
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: p,
      onInput: c,
      onKeydown: Je(Ke(d, ["prevent"]), ["down", "up"]),
      onFocus: f
    }, {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), ik = lk, uk = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ge(void 0, "reka-combobox-item"), o = ya(), s = wg(null), { primitiveElement: i, currentElement: u } = Ht();
    if (n.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const d = E(() => {
      if (o.isVirtual.value || o.ignoreFilter.value || !o.filterSearch.value) return !0;
      {
        const c = o.filterState.value.items.get(r);
        return c === void 0 ? !0 : c > 0;
      }
    });
    return Ce(() => {
      o.allItems.value.set(r, n.textValue || u.value.textContent || u.value.innerText);
      const c = s?.id;
      c && (o.allGroups.value.has(c) ? o.allGroups.value.get(c)?.add(r) : o.allGroups.value.set(c, /* @__PURE__ */ new Set([r])));
    }), Qe(() => {
      o.allItems.value.delete(r);
    }), (c, f) => d.value ? (h(), x(l(_g), A({ key: 0 }, n, {
      id: l(r),
      ref_key: "primitiveElement",
      ref: i,
      disabled: l(o).disabled.value || c.disabled,
      onSelect: f[0] || (f[0] = (p) => {
        a("select", p), !p.defaultPrevented && !l(o).multiple.value && !c.disabled && !l(o).disabled.value && (p.preventDefault(), l(o).onOpenChange(!1), l(o).modelValue.value = n.value);
      })
    }), {
      default: y(() => [_(c.$slots, "default", {}, () => [Re(He(c.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : Ee("v-if", !0);
  }
}), dk = uk, ck = /* @__PURE__ */ b({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(W$), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $7 = ck, fk = /* @__PURE__ */ b({
  __name: "ComboboxLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = wg({
      id: "",
      labelId: ""
    });
    return n.labelId ||= Ge(void 0, "reka-combobox-group-label"), (a, r) => (h(), x(l(X), A(t, { id: l(n).labelId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), pk = fk, vk = /* @__PURE__ */ b({
  __name: "ComboboxPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), mk = vk, hk = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gk = hk, yk = /* @__PURE__ */ b({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = ya(), o = E(() => t.disabled || r.disabled.value || !1);
    return Ce(() => {
      a.value && r.onTriggerElementChange(a.value);
    }), (s, i) => (h(), x(l(X), A(t, {
      ref: l(n),
      type: s.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "data-state": l(r).open.value ? "open" : "closed",
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "aria-disabled": o.value ?? void 0,
      onClick: i[0] || (i[0] = (u) => l(r).onOpenChange(!l(r).open.value))
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), k7 = yk;
function qi(e) {
  const t = us({ nonce: I() });
  return E(() => e?.value || t.nonce?.value);
}
var bk = /* @__PURE__ */ b({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), { nonce: a } = Me(t), r = qi(a), o = ya();
    return (s, i) => (h(), G(Ye, null, [N(l(X), A({
      ...s.$attrs,
      ...t
    }, {
      ref: l(n),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: l(o).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["style"]), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: y(() => i[0] || (i[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), _k = bk, wk = /* @__PURE__ */ b({
  __name: "MenuAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(ur), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ei = wk;
function xk() {
  const e = I(!1);
  return Ce(() => {
    zt("keydown", () => {
      e.value = !0;
    }, {
      capture: !0,
      passive: !0
    }), zt(["pointerdown", "pointermove"], () => {
      e.value = !1;
    }, {
      capture: !0,
      passive: !0
    });
  }), e;
}
const Ck = lh(xk), [cr, xg] = Be(["MenuRoot", "MenuSub"], "MenuContext"), [ws, Sk] = Be("MenuRoot");
var $k = /* @__PURE__ */ b({
  __name: "MenuRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r, dir: o } = Me(n), s = yt(o), i = Ve(n, "open", a), u = I(), d = Ck();
    return xg({
      open: i,
      onOpenChange: (c) => {
        i.value = c;
      },
      content: u,
      onContentChange: (c) => {
        u.value = c;
      }
    }), Sk({
      onClose: () => {
        i.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: s,
      modal: r
    }), (c, f) => (h(), x(l(ir), null, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }));
  }
}), Ic = $k;
const [Oc, kk] = Be("MenuContent");
var Bk = /* @__PURE__ */ b({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ th({
    loop: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    disableOutsideScroll: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...mg }),
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = cr(), o = ws(), { trapFocus: s, disableOutsidePointerEvents: i, loop: u } = Me(n);
    xc(), fs(i.value);
    const d = I(""), c = I(0), f = I(0), p = I(null), v = I("right"), m = I(0), g = I(null), w = I(), { forwardRef: C, currentElement: S } = j(), { handleTypeaheadSearch: $ } = gi();
    ve(S, (T) => {
      r.onContentChange(T);
    }), Qe(() => {
      window.clearTimeout(c.value);
    });
    function B(T) {
      return v.value === p.value?.side && wx(T, p.value?.area);
    }
    async function k(T) {
      a("openAutoFocus", T), !T.defaultPrevented && (T.preventDefault(), S.value?.focus({ preventScroll: !0 }));
    }
    function P(T) {
      if (T.defaultPrevented) return;
      const O = T.target.closest("[data-reka-menu-content]") === T.currentTarget, F = T.ctrlKey || T.altKey || T.metaKey, J = T.key.length === 1, ne = lr(T, ot(), S.value, {
        loop: u.value,
        arrowKeyOptions: "vertical",
        dir: o?.dir.value,
        focus: !0,
        attributeName: "[data-reka-collection-item]:not([data-disabled])"
      });
      if (ne) return ne?.focus();
      if (T.code === "Space") return;
      const Q = w.value?.getItems() ?? [];
      if (O && (T.key === "Tab" && T.preventDefault(), !F && J && $(T.key, Q)), T.target !== S.value || !gx.includes(T.key)) return;
      T.preventDefault();
      const W = [...Q.map((H) => H.ref)];
      Jh.includes(T.key) && W.reverse(), gd(W);
    }
    function D(T) {
      T?.currentTarget?.contains?.(T.target) || (window.clearTimeout(c.value), d.value = "");
    }
    function q(T) {
      if (!Lo(T)) return;
      const M = T.target, O = m.value !== T.clientX;
      if (T?.currentTarget?.contains(M) && O) {
        const F = T.clientX > m.value ? "right" : "left";
        v.value = F, m.value = T.clientX;
      }
    }
    return kk({
      onItemEnter: (T) => !!B(T),
      onItemLeave: (T) => {
        B(T) || (S.value?.focus(), g.value = null);
      },
      onTriggerLeave: (T) => !!B(T),
      searchRef: d,
      pointerGraceTimerRef: f,
      onPointerGraceIntentChange: (T) => {
        p.value = T;
      }
    }), (T, M) => (h(), x(l(_i), {
      "as-child": "",
      trapped: l(s),
      onMountAutoFocus: k,
      onUnmountAutoFocus: M[7] || (M[7] = (O) => a("closeAutoFocus", O))
    }, {
      default: y(() => [N(l(Fa), {
        "as-child": "",
        "disable-outside-pointer-events": l(i),
        onEscapeKeyDown: M[2] || (M[2] = (O) => a("escapeKeyDown", O)),
        onPointerDownOutside: M[3] || (M[3] = (O) => a("pointerDownOutside", O)),
        onFocusOutside: M[4] || (M[4] = (O) => a("focusOutside", O)),
        onInteractOutside: M[5] || (M[5] = (O) => a("interactOutside", O)),
        onDismiss: M[6] || (M[6] = (O) => a("dismiss"))
      }, {
        default: y(() => [N(l(ys), {
          ref_key: "rovingFocusGroupRef",
          ref: w,
          "current-tab-stop-id": g.value,
          "onUpdate:currentTabStopId": M[0] || (M[0] = (O) => g.value = O),
          "as-child": "",
          orientation: "vertical",
          dir: l(o).dir.value,
          loop: l(u),
          onEntryFocus: M[1] || (M[1] = (O) => {
            a("entryFocus", O), l(o).isUsingKeyboardRef.value || O.preventDefault();
          })
        }, {
          default: y(() => [N(l(Zr), {
            ref: l(C),
            role: "menu",
            as: T.as,
            "as-child": T.asChild,
            "aria-orientation": "vertical",
            "data-reka-menu-content": "",
            "data-state": l(kc)(l(r).open.value),
            dir: l(o).dir.value,
            side: T.side,
            "side-offset": T.sideOffset,
            align: T.align,
            "align-offset": T.alignOffset,
            "avoid-collisions": T.avoidCollisions,
            "collision-boundary": T.collisionBoundary,
            "collision-padding": T.collisionPadding,
            "arrow-padding": T.arrowPadding,
            "prioritize-position": T.prioritizePosition,
            "position-strategy": T.positionStrategy,
            "update-position-strategy": T.updatePositionStrategy,
            sticky: T.sticky,
            "hide-when-detached": T.hideWhenDetached,
            reference: T.reference,
            onKeydown: P,
            onBlur: D,
            onPointermove: q
          }, {
            default: y(() => [_(T.$slots, "default")]),
            _: 3
          }, 8, [
            "as",
            "as-child",
            "data-state",
            "dir",
            "side",
            "side-offset",
            "align",
            "align-offset",
            "avoid-collisions",
            "collision-boundary",
            "collision-padding",
            "arrow-padding",
            "prioritize-position",
            "position-strategy",
            "update-position-strategy",
            "sticky",
            "hide-when-detached",
            "reference"
          ])]),
          _: 3
        }, 8, [
          "current-tab-stop-id",
          "dir",
          "loop"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Rc = Bk, Dk = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Oc(), { forwardRef: a } = j(), { CollectionItem: r } = st(), o = I(!1);
    async function s(u) {
      u.defaultPrevented || Lo(u) && (t.disabled ? n.onItemLeave(u) : n.onItemEnter(u) || u.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function i(u) {
      await ke(), !u.defaultPrevented && Lo(u) && n.onItemLeave(u);
    }
    return (u, d) => (h(), x(l(r), { value: { textValue: u.textValue } }, {
      default: y(() => [N(l(X), A({
        ref: l(a),
        role: "menuitem",
        tabindex: "-1"
      }, u.$attrs, {
        as: u.as,
        "as-child": u.asChild,
        "aria-disabled": u.disabled || void 0,
        "data-disabled": u.disabled ? "" : void 0,
        "data-highlighted": o.value ? "" : void 0,
        onPointermove: s,
        onPointerleave: i,
        onFocus: d[0] || (d[0] = async (c) => {
          await ke(), !(c.defaultPrevented || u.disabled) && (o.value = !0);
        }),
        onBlur: d[1] || (d[1] = async (c) => {
          await ke(), !c.defaultPrevented && (o.value = !1);
        })
      }), {
        default: y(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-disabled",
        "data-disabled",
        "data-highlighted"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), Cg = Dk, Pk = /* @__PURE__ */ b({
  __name: "MenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = ws(), i = Oc(), u = I(!1);
    async function d() {
      const c = o.value;
      if (!n.disabled && c) {
        const f = new CustomEvent(mx, {
          bubbles: !0,
          cancelable: !0
        });
        a("select", f), await ke(), f.defaultPrevented ? u.value = !1 : s.onClose();
      }
    }
    return (c, f) => (h(), x(Cg, A(n, {
      ref: l(r),
      onClick: d,
      onPointerdown: f[0] || (f[0] = () => {
        u.value = !0;
      }),
      onPointerup: f[1] || (f[1] = async (p) => {
        await ke(), !p.defaultPrevented && (u.value || p.currentTarget?.click());
      }),
      onKeydown: f[2] || (f[2] = async (p) => {
        const v = l(i).searchRef.value !== "";
        c.disabled || v && p.key === " " || l(hd).includes(p.key) && (p.currentTarget.click(), p.preventDefault());
      })
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xs = Pk;
const [Mk, Sg] = Be(["MenuCheckboxItem", "MenuRadioItem"], "MenuItemIndicatorContext");
var qk = /* @__PURE__ */ b({
  __name: "MenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = Mk({ modelValue: I(!1) });
    return (n, a) => (h(), x(l(St), { present: n.forceMount || l(ql)(l(t).modelValue.value) || l(t).modelValue.value === !0 }, {
      default: y(() => [N(l(X), {
        as: n.as,
        "as-child": n.asChild,
        "data-state": l(Bc)(l(t).modelValue.value)
      }, {
        default: y(() => [_(n.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Vc = qk, Ek = /* @__PURE__ */ b({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ds(n, ["modelValue"]), o = he(r), s = Ve(n, "modelValue", a);
    return Sg({ modelValue: s }), (i, u) => (h(), x(xs, A({ role: "menuitemcheckbox" }, l(o), {
      "aria-checked": l(ql)(l(s)) ? "mixed" : l(s),
      "data-state": l(Bc)(l(s)),
      onSelect: u[0] || (u[0] = async (d) => {
        a("select", d), l(ql)(l(s)) ? s.value = !0 : s.value = !l(s);
      })
    }), {
      default: y(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Fc = Ek, Tk = /* @__PURE__ */ b({
  __name: "MenuRootContentModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = me(n, a), o = cr(), { forwardRef: s, currentElement: i } = j();
    return vs(i), (u, d) => (h(), x(Rc, A(l(r), {
      ref: l(s),
      "trap-focus": l(o).open.value,
      "disable-outside-pointer-events": l(o).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (c) => l(o).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = Ke((c) => a("focusOutside", c), ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), Ak = Tk, Ik = /* @__PURE__ */ b({
  __name: "MenuRootContentNonModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), o = cr();
    return (s, i) => (h(), x(Rc, A(l(r), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (u) => l(o).onOpenChange(!1))
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ok = Ik, Rk = /* @__PURE__ */ b({
  __name: "MenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), o = cr(), s = ws();
    return (i, u) => (h(), x(l(St), { present: i.forceMount || l(o).open.value }, {
      default: y(() => [l(s).modal.value ? (h(), x(Ak, oe(A({ key: 0 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(Ok, oe(A({ key: 1 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), Nc = Rk, Vk = /* @__PURE__ */ b({
  __name: "MenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({ role: "group" }, t), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ti = Vk, Fk = /* @__PURE__ */ b({
  __name: "MenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Lc = Fk, Nk = /* @__PURE__ */ b({
  __name: "MenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zc = Nk;
const [Lk, zk] = Be("MenuRadioGroup");
var Hk = /* @__PURE__ */ b({
  __name: "MenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ds(n, ["modelValue"]), o = he(r), s = Ve(n, "modelValue", a);
    return zk({
      modelValue: s,
      onValueChange: (i) => {
        s.value = i;
      }
    }), (i, u) => (h(), x(Ti, oe(le(l(o))), {
      default: y(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16));
  }
}), Hc = Hk, Uk = /* @__PURE__ */ b({
  __name: "MenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ds(n, ["value"]), o = he(r), { value: s } = Me(n), i = Lk(), u = E(() => i.modelValue.value === s?.value);
    return Sg({ modelValue: u }), (d, c) => (h(), x(xs, A({ role: "menuitemradio" }, l(o), {
      "aria-checked": u.value,
      "data-state": l(Bc)(u.value),
      onSelect: c[0] || (c[0] = async (f) => {
        a("select", f), l(i).onValueChange(l(s));
      })
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Uc = Uk, jk = /* @__PURE__ */ b({
  __name: "MenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), jc = jk;
const [$g, Wk] = Be("MenuSub");
var Gk = /* @__PURE__ */ b({
  __name: "MenuSub",
  props: { open: {
    type: Boolean,
    required: !1,
    default: void 0
  } },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      defaultValue: !1,
      passive: n.open === void 0
    }), o = cr(), s = I(), i = I();
    return Ie((u) => {
      o?.open.value === !1 && (r.value = !1), u(() => r.value = !1);
    }), xg({
      open: r,
      onOpenChange: (u) => {
        r.value = u;
      },
      content: i,
      onContentChange: (u) => {
        i.value = u;
      }
    }), Wk({
      triggerId: "",
      contentId: "",
      trigger: s,
      onTriggerChange: (u) => {
        s.value = u;
      }
    }), (u, d) => (h(), x(l(ir), null, {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }));
  }
}), Wc = Gk, Kk = /* @__PURE__ */ b({
  __name: "MenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1,
      default: !0
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), o = cr(), s = ws(), i = $g(), { forwardRef: u, currentElement: d } = j();
    return i.contentId ||= Ge(void 0, "reka-menu-sub-content"), (c, f) => (h(), x(l(St), { present: c.forceMount || l(o).open.value }, {
      default: y(() => [N(Rc, A(l(r), {
        id: l(i).contentId,
        ref: l(u),
        "aria-labelledby": l(i).triggerId,
        align: "start",
        side: l(s).dir.value === "rtl" ? "left" : "right",
        "disable-outside-pointer-events": !1,
        "disable-outside-scroll": !1,
        "trap-focus": !1,
        onOpenAutoFocus: f[0] || (f[0] = Ke((p) => {
          l(s).isUsingKeyboardRef.value && l(d)?.focus();
        }, ["prevent"])),
        onCloseAutoFocus: f[1] || (f[1] = Ke(() => {
        }, ["prevent"])),
        onFocusOutside: f[2] || (f[2] = (p) => {
          p.defaultPrevented || p.target !== l(i).trigger.value && l(o).onOpenChange(!1);
        }),
        onEscapeKeyDown: f[3] || (f[3] = (p) => {
          l(s).onClose(), p.preventDefault();
        }),
        onKeydown: f[4] || (f[4] = (p) => {
          const v = p.currentTarget?.contains(p.target), m = l(bx)[l(s).dir.value].includes(p.key);
          v && m && (l(o).onOpenChange(!1), l(i).trigger.value?.focus(), p.preventDefault());
        })
      }), {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "side"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Gc = Kk, Yk = /* @__PURE__ */ b({
  __name: "MenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = cr(), a = ws(), r = $g(), o = Oc(), s = I(null);
    r.triggerId ||= Ge(void 0, "reka-menu-sub-trigger");
    function i() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    Qe(() => {
      i();
    });
    function u(f) {
      !Lo(f) || o.onItemEnter(f) || !t.disabled && !n.open.value && !s.value && (o.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), i();
      }, 100));
    }
    async function d(f) {
      if (!Lo(f)) return;
      i();
      const p = n.content.value?.getBoundingClientRect();
      if (p?.width) {
        const v = n.content.value?.dataset.side, m = v === "right", g = m ? -5 : 5, w = p[m ? "left" : "right"], C = p[m ? "right" : "left"];
        o.onPointerGraceIntentChange({
          area: [
            {
              x: f.clientX + g,
              y: f.clientY
            },
            {
              x: w,
              y: p.top
            },
            {
              x: C,
              y: p.top
            },
            {
              x: C,
              y: p.bottom
            },
            {
              x: w,
              y: p.bottom
            }
          ],
          side: v
        }), window.clearTimeout(o.pointerGraceTimerRef.value), o.pointerGraceTimerRef.value = window.setTimeout(() => o.onPointerGraceIntentChange(null), 300);
      } else {
        if (o.onTriggerLeave(f)) return;
        o.onPointerGraceIntentChange(null);
      }
    }
    async function c(f) {
      const p = o.searchRef.value !== "";
      t.disabled || p && f.key === " " || yx[a.dir.value].includes(f.key) && (n.onOpenChange(!0), await ke(), n.content.value?.focus(), f.preventDefault());
    }
    return (f, p) => (h(), x(Ei, { "as-child": "" }, {
      default: y(() => [N(Cg, A(t, {
        id: l(r).triggerId,
        ref: (v) => {
          l(r)?.onTriggerChange(v?.$el);
        },
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(r).contentId,
        "data-state": l(kc)(l(n).open.value),
        onClick: p[0] || (p[0] = async (v) => {
          t.disabled || v.defaultPrevented || (v.currentTarget.focus(), l(n).open.value || l(n).onOpenChange(!0));
        }),
        onPointermove: u,
        onPointerleave: d,
        onKeydown: c
      }), {
        default: y(() => [_(f.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-expanded",
        "aria-controls",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), Kc = Yk, Xk = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Fc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Jk = Xk;
const [kg, Zk] = Be("ContextMenuRoot");
var Qk = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuRoot",
  props: {
    pressOpenDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, modal: o, pressOpenDelay: s } = Me(n);
    j();
    const i = yt(r), u = I(!1), d = I();
    return Zk({
      open: u,
      onOpenChange: (c) => {
        u.value = c;
      },
      dir: i,
      modal: o,
      triggerElement: d,
      pressOpenDelay: s
    }), ve(u, (c) => {
      a("update:open", c);
    }), (c, f) => (h(), x(l(Ic), {
      open: u.value,
      "onUpdate:open": f[0] || (f[0] = (p) => u.value = p),
      dir: l(i),
      modal: l(o)
    }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), eB = Qk, tB = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const o = kg(), s = I(!1);
    return (i, u) => (h(), x(l(Nc), A(l(r), {
      side: "right",
      "side-offset": 2,
      align: "start",
      "update-position-strategy": "always",
      style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        !d.defaultPrevented && s.value && d.preventDefault(), s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        d.detail.originalEvent.button === 2 && d.target === l(o).triggerElement.value && d.preventDefault(), !d.defaultPrevented && !l(o).modal.value && (s.value = !0);
      })
    }), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nB = tB, aB = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Ti), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rB = aB, oB = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(xs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sB = oB, lB = /* @__PURE__ */ b({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Vc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Bg = lB, iB = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Lc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), uB = iB, dB = /* @__PURE__ */ b({
  __name: "ContextMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(zc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), cB = dB, fB = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Hc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), pB = fB, vB = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Uc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), mB = vB, hB = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(jc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gB = hB, yB = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (o, s) => (h(), x(l(Wc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), bB = yB, _B = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Gc), A(l(r), { style: {
      "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), wB = _B, xB = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Kc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), CB = xB;
function Zp(e) {
  return e.pointerType !== "mouse";
}
var SB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { disabled: n } = Me(t), { forwardRef: a, currentElement: r } = j(), o = kg(), s = I({
      x: 0,
      y: 0
    }), i = E(() => ({ getBoundingClientRect: () => ({
      width: 0,
      height: 0,
      left: s.value.x,
      right: s.value.x,
      top: s.value.y,
      bottom: s.value.y,
      ...s.value
    }) })), u = I(0);
    function d() {
      window.clearTimeout(u.value);
    }
    function c(m) {
      s.value = {
        x: m.clientX,
        y: m.clientY
      }, o.onOpenChange(!0);
    }
    async function f(m) {
      n.value || (await ke(), m.defaultPrevented || (d(), c(m), m.preventDefault()));
    }
    async function p(m) {
      n.value || (await ke(), Zp(m) && !m.defaultPrevented && (d(), u.value = window.setTimeout(() => c(m), o.pressOpenDelay.value)));
    }
    async function v(m) {
      n.value || (await ke(), Zp(m) && !m.defaultPrevented && d());
    }
    return Ce(() => {
      r.value && (o.triggerElement.value = r.value);
    }), (m, g) => (h(), G(Ye, null, [N(l(Ei), {
      as: "template",
      reference: i.value
    }, null, 8, ["reference"]), N(l(X), A({
      ref: l(a),
      as: m.as,
      "as-child": m.asChild,
      "data-state": l(o).open.value ? "open" : "closed",
      "data-disabled": l(n) ? "" : void 0,
      style: {
        WebkitTouchCallout: "none",
        pointerEvents: "auto"
      }
    }, m.$attrs, {
      onContextmenu: f,
      onPointerdown: p,
      onPointermove: v,
      onPointercancel: v,
      onPointerup: v
    }), {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ])], 64));
  }
}), $B = SB;
const [Qr, kB] = Be("PopoverRoot");
var BB = /* @__PURE__ */ b({
  __name: "PopoverRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r } = Me(n), o = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = I(), i = I(!1);
    return kB({
      contentId: "",
      triggerId: "",
      modal: r,
      open: o,
      onOpenChange: (u) => {
        o.value = u;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      triggerElement: s,
      hasCustomAnchor: i
    }), (u, d) => (h(), x(l(ir), null, {
      default: y(() => [_(u.$slots, "default", {
        open: l(o),
        close: () => o.value = !1
      })]),
      _: 3
    }));
  }
}), DB = BB, PB = /* @__PURE__ */ b({
  __name: "PopoverAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Qr();
    return x0(() => {
      n.hasCustomAnchor.value = !0;
    }), Qe(() => {
      n.hasCustomAnchor.value = !1;
    }), (a, r) => (h(), x(l(ur), oe(le(t)), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), B7 = PB, MB = /* @__PURE__ */ b({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(ds(n, "trapFocus", "disableOutsidePointerEvents")), { forwardRef: o } = j(), s = Qr();
    return xc(), (i, u) => (h(), x(l(_i), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [N(l(Fa), {
        "as-child": "",
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        onPointerDownOutside: u[0] || (u[0] = (d) => a("pointerDownOutside", d)),
        onInteractOutside: u[1] || (u[1] = (d) => a("interactOutside", d)),
        onEscapeKeyDown: u[2] || (u[2] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[3] || (u[3] = (d) => a("focusOutside", d)),
        onDismiss: u[4] || (u[4] = (d) => l(s).onOpenChange(!1))
      }, {
        default: y(() => [N(l(Zr), A(l(r), {
          id: l(s).contentId,
          ref: l(o),
          "data-state": l(s).open.value ? "open" : "closed",
          "aria-labelledby": l(s).triggerId,
          style: {
            "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
            "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
            "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
          },
          role: "dialog"
        }), {
          default: y(() => [_(i.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "aria-labelledby"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Dg = MB, qB = /* @__PURE__ */ b({
  __name: "PopoverContentModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Qr(), o = I(!1);
    fs(!0);
    const s = me(n, a), { forwardRef: i, currentElement: u } = j();
    return vs(u), (d, c) => (h(), x(Dg, A(l(s), {
      ref: l(i),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: c[0] || (c[0] = Ke((f) => {
        a("closeAutoFocus", f), o.value || l(r).triggerElement.value?.focus();
      }, ["prevent"])),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        a("pointerDownOutside", f);
        const p = f.detail.originalEvent, v = p.button === 0 && p.ctrlKey === !0, m = p.button === 2 || v;
        o.value = m;
      }),
      onFocusOutside: c[2] || (c[2] = Ke(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), EB = qB, TB = /* @__PURE__ */ b({
  __name: "PopoverContentNonModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Qr(), o = I(!1), s = I(!1), i = me(n, a);
    return (u, d) => (h(), x(Dg, A(l(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        a("closeAutoFocus", c), c.defaultPrevented || (o.value || l(r).triggerElement.value?.focus(), c.preventDefault()), o.value = !1, s.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = async (c) => {
        a("interactOutside", c), c.defaultPrevented || (o.value = !0, c.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const f = c.target;
        l(r).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && s.value && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), AB = TB, IB = /* @__PURE__ */ b({
  __name: "PopoverContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Qr(), o = me(n, a), { forwardRef: s } = j();
    return r.contentId ||= Ge(void 0, "reka-popover-content"), (i, u) => (h(), x(l(St), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [l(r).modal.value ? (h(), x(EB, A({ key: 0 }, l(o), { ref: l(s) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(AB, A({ key: 1 }, l(o), { ref: l(s) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), OB = IB, RB = /* @__PURE__ */ b({
  __name: "PopoverPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VB = RB, FB = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Qr(), { forwardRef: a, currentElement: r } = j();
    return n.triggerId ||= Ge(void 0, "reka-popover-trigger"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), x(Tt(l(n).hasCustomAnchor.value ? l(X) : l(ur)), { "as-child": "" }, {
      default: y(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).contentId,
        "data-state": l(n).open.value ? "open" : "closed",
        as: o.as,
        "as-child": t.asChild,
        onClick: l(n).onOpenToggle
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "aria-expanded",
        "aria-controls",
        "data-state",
        "as",
        "as-child",
        "onClick"
      ])]),
      _: 3
    }));
  }
}), NB = FB;
function LB(e) {
  const t = E(() => e.start.value ? !!e.isDateDisabled(e.start.value) : !1), n = E(() => e.end.value ? !!e.isDateDisabled(e.end.value) : !1), a = E(() => t.value || n.value ? !1 : !!(e.start.value && e.end.value && Za(e.end.value, e.start.value))), r = (p) => e.start.value ? wt(e.start.value, p) : !1, o = (p) => e.end.value ? wt(e.end.value, p) : !1, s = (p) => e.start.value && wt(e.start.value, p) || e.end.value && wt(e.end.value, p) ? !0 : e.end.value && e.start.value ? ku(p, e.start.value, e.end.value) : !1, i = (p) => {
    if (e.isDateDisabled(p)) return !0;
    if (e.maximumDays?.value) {
      if (e.start.value && e.end.value) {
        if (e.fixedDate.value) {
          const v = vd(e.start.value, e.end.value).length;
          if (v <= e.maximumDays.value) {
            const m = e.maximumDays.value - v - 1, g = e.start.value.subtract({ days: m }), w = e.end.value.add({ days: m });
            return !ku(p, g, w);
          }
        }
        return !1;
      }
      if (e.start.value) {
        const v = e.start.value.add({ days: e.maximumDays.value }), m = e.start.value.subtract({ days: e.maximumDays.value });
        return !ku(p, m, v);
      }
    }
    return !e.start.value || e.end.value || wt(e.start.value, p), !1;
  }, u = (p) => !!e.isDateHighlightable?.(p), d = E(() => {
    if (e.start.value && e.end.value && !e.fixedDate.value || !e.start.value || !e.focusedValue.value) return null;
    const p = Za(e.start.value, e.focusedValue.value), v = p ? e.start.value : e.focusedValue.value, m = p ? e.focusedValue.value : e.start.value;
    if (wt(v, m)) return {
      start: v,
      end: m
    };
    if (e.maximumDays?.value && !e.end.value) {
      const w = p ? v.add({ days: e.maximumDays.value - 1 }) : v.subtract({ days: e.maximumDays.value });
      return {
        start: v,
        end: w
      };
    }
    return g1(v, m, e.allowNonContiguousRanges.value ? () => !1 : e.isDateUnavailable, i, e.isDateHighlightable) ? {
      start: v,
      end: m
    } : null;
  });
  return {
    isInvalid: a,
    isSelected: s,
    isDateHighlightable: u,
    highlightedRange: d,
    isSelectionStart: r,
    isSelectionEnd: o,
    isHighlightedStart: (p) => !d.value || !d.value.start ? !1 : wt(d.value.start, p),
    isHighlightedEnd: (p) => !d.value || !d.value.end ? !1 : wt(d.value.end, p),
    isDateDisabled: i
  };
}
const zB = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, HB = {
  role: "heading",
  "aria-level": "2"
}, [eo, UB] = Be("RangeCalendarRoot");
var jB = /* @__PURE__ */ b({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: Object,
      required: !1,
      default: () => ({
        start: void 0,
        end: void 0
      })
    },
    modelValue: {
      type: [Object, null],
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    allowNonContiguousRanges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maximumDays: {
      type: Number,
      required: !1,
      default: void 0
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateHighlightable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    fixedDate: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: [
    "update:modelValue",
    "update:validModelValue",
    "update:placeholder",
    "update:startValue"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, numberOfMonths: f, preventDeselect: p, isDateUnavailable: v, isDateHighlightable: m, isDateDisabled: g, calendarLabel: w, maxValue: C, minValue: S, dir: $, locale: B, nextPage: k, prevPage: P, allowNonContiguousRanges: D, disableDaysOutsideCurrentView: q, fixedDate: T, maximumDays: M } = Me(n), { primitiveElement: O, currentElement: F } = Ht(), J = yt($), ne = Cc(B), Q = I(), W = I(), H = I(!1), U = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: n.modelValue === void 0
    }), se = I(U.value);
    ve(se, (Oe) => {
      a("update:validModelValue", Oe);
    });
    const ee = Rh({
      defaultPlaceholder: n.placeholder,
      defaultValue: U.value.start,
      locale: n.locale
    }), de = I(U.value.start), pe = I(U.value.end), _e = Ve(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ee.copy(),
      passive: n.placeholder === void 0
    });
    function ge(Oe) {
      _e.value = Oe.copy();
    }
    const { fullCalendarLabel: Te, headingValue: ce, isDateDisabled: R, isDateUnavailable: te, isNextButtonDisabled: z, isPrevButtonDisabled: ae, grid: ie, weekdays: L, isOutsideVisibleView: be, nextPage: we, prevPage: Fe, formatter: Xe } = eg({
      locale: ne,
      placeholder: _e,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: f,
      minValue: S,
      maxValue: C,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: g.value,
      isDateUnavailable: v.value,
      calendarLabel: w,
      nextPage: k,
      prevPage: P
    }), { isInvalid: lt, isSelected: De, isDateHighlightable: Ne, highlightedRange: Ue, isSelectionStart: We, isSelectionEnd: it, isHighlightedStart: ut, isHighlightedEnd: $t, isDateDisabled: un } = LB({
      start: de,
      end: pe,
      isDateDisabled: R,
      isDateUnavailable: te,
      isDateHighlightable: m.value,
      focusedValue: W,
      allowNonContiguousRanges: D,
      fixedDate: T,
      maximumDays: M
    });
    ve(U, (Oe, Pt) => {
      (!Pt?.start && Oe?.start || !Oe || !Oe.start || de.value && !Ba(Oe.start, de.value)) && (de.value = Oe?.start?.copy?.()), (!Pt?.end && Oe.end || !Oe || !Oe.end || pe.value && !Ba(Oe.end, pe.value)) && (pe.value = Oe?.end?.copy?.());
    }), ve(de, (Oe) => {
      Oe && !Ba(Oe, _e.value) && ge(Oe), a("update:startValue", Oe);
    }), ve([de, pe], ([Oe, Pt]) => {
      const jt = U.value;
      if (!(jt && jt.start && jt.end && Oe && Pt && Ba(jt.start, Oe) && Ba(jt.end, Pt)))
        if (H.value = !0, Pt && Oe) {
          const Rt = Za(Pt, Oe) ? {
            start: Pt.copy(),
            end: Oe.copy()
          } : {
            start: Oe.copy(),
            end: Pt.copy()
          };
          U.value = {
            start: Rt.start,
            end: Rt.end
          }, H.value = !1, se.value = {
            start: Rt.start.copy(),
            end: Rt.end.copy()
          };
        } else U.value = Oe ? {
          start: Oe.copy(),
          end: void 0
        } : {
          start: Pt?.copy(),
          end: void 0
        };
    });
    const gn = ms();
    return zt("keydown", (Oe) => {
      Oe.key === gn.ESCAPE && H.value && (de.value = se.value.start?.copy(), pe.value = se.value.end?.copy());
    }), UB({
      isDateUnavailable: te,
      isDateHighlightable: Ne,
      startValue: de,
      endValue: pe,
      formatter: Xe,
      modelValue: U,
      placeholder: _e,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: ie,
      weekDays: L,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      numberOfMonths: f,
      readonly: o,
      preventDeselect: p,
      fullCalendarLabel: Te,
      headingValue: ce,
      isInvalid: lt,
      isDateDisabled: un,
      allowNonContiguousRanges: D,
      highlightedRange: Ue,
      focusedValue: W,
      lastPressedDateValue: Q,
      isSelected: De,
      isSelectionEnd: it,
      isSelectionStart: We,
      isNextButtonDisabled: z,
      isPrevButtonDisabled: ae,
      isOutsideVisibleView: be,
      nextPage: we,
      prevPage: Fe,
      parentElement: F,
      onPlaceholderChange: ge,
      locale: ne,
      dir: J,
      isHighlightedStart: ut,
      isHighlightedEnd: $t,
      disableDaysOutsideCurrentView: q,
      fixedDate: T,
      maximumDays: M,
      minValue: S,
      maxValue: C
    }), Ce(() => {
      s.value && Vh(F.value);
    }), (Oe, Pt) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: O,
      as: Oe.as,
      "as-child": Oe.asChild,
      "aria-label": l(Te),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(lt) ? "" : void 0,
      dir: l(J)
    }, {
      default: y(() => [xe("div", zB, [xe("div", HB, He(l(Te)), 1)]), _(Oe.$slots, "default", {
        date: l(_e),
        grid: l(ie),
        weekDays: l(L),
        weekStartsOn: l(u),
        locale: l(ne),
        fixedWeeks: l(c),
        modelValue: l(U)
      })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), WB = jB, GB = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = eo();
    return (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), KB = GB, YB = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = eo(), a = ms(), { primitiveElement: r } = Ht(), o = E(() => n.formatter.custom(Bn(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), s = E(() => n.isDateUnavailable?.(t.day) ?? !1), i = E(() => n.isSelected(t.day)), u = E(() => n.isSelectionStart(t.day)), d = E(() => n.isSelectionEnd(t.day)), c = E(() => n.isHighlightedStart(t.day)), f = E(() => n.isHighlightedEnd(t.day)), p = E(() => n.highlightedRange.value ? v1(t.day, n.highlightedRange.value.start, n.highlightedRange.value.end) : !1), v = E(() => n.allowNonContiguousRanges.value), m = E(() => vh(t.day, Yr())), g = E(() => !fc(t.day, t.month)), w = E(() => n.isOutsideVisibleView(t.day)), C = E(() => n.isDateDisabled(t.day) || n.disableDaysOutsideCurrentView.value && g.value), S = E(() => t.day.day.toLocaleString(n.locale.value)), $ = E(() => !n.disabled.value && wt(t.day, n.placeholder.value));
    function B(q, T) {
      if (!n.readonly.value && !(n.isDateDisabled(T) || n.isDateUnavailable?.(T))) {
        if (n.lastPressedDateValue.value = T.copy(), n.startValue.value && n.highlightedRange.value === null) {
          if (wt(T, n.startValue.value) && !n.preventDeselect.value && !n.endValue.value) {
            n.startValue.value = void 0, n.onPlaceholderChange(T);
            return;
          } else if (!n.endValue.value) {
            q.preventDefault(), n.lastPressedDateValue.value && wt(n.lastPressedDateValue.value, T) && (n.startValue.value = T.copy());
            return;
          }
        }
        if (n.startValue.value && n.endValue.value && wt(n.startValue.value, n.endValue.value) && wt(n.startValue.value, T) && !n.preventDeselect.value) {
          n.startValue.value = void 0, n.endValue.value = void 0, n.onPlaceholderChange(T);
          return;
        }
        n.startValue.value ? n.endValue.value ? n.endValue.value && n.startValue.value && (n.fixedDate.value ? n.fixedDate.value === "start" ? T.compare(n.startValue.value) < 0 ? n.startValue.value = T.copy() : n.endValue.value = T.copy() : n.fixedDate.value === "end" && (T.compare(n.endValue.value) > 0 ? n.endValue.value = T.copy() : n.startValue.value = T.copy()) : (n.endValue.value = void 0, n.startValue.value = T.copy())) : n.endValue.value = T.copy() : n.startValue.value = T.copy();
      }
    }
    function k(q) {
      C.value || B(q, t.day);
    }
    function P() {
      C.value || n.isDateUnavailable?.(t.day) || (n.focusedValue.value = t.day.copy());
    }
    function D(q) {
      if (C.value) return;
      q.preventDefault(), q.stopPropagation();
      const T = n.parentElement.value, M = 7, O = n.dir.value === "rtl" ? -1 : 1;
      switch (q.code) {
        case a.ARROW_RIGHT:
          F(t.day, O);
          break;
        case a.ARROW_LEFT:
          F(t.day, -O);
          break;
        case a.ARROW_UP:
          F(t.day, -M);
          break;
        case a.ARROW_DOWN:
          F(t.day, M);
          break;
        case a.ENTER:
        case a.SPACE_CODE:
          B(q, t.day);
      }
      function F(J, ne) {
        const Q = J.add({ days: ne });
        if (n.minValue.value && Q.compare(n.minValue.value) < 0 || n.maxValue.value && Q.compare(n.maxValue.value) > 0) return;
        const W = T.querySelector(`[data-value='${Q.toString()}']:not([data-outside-view])`);
        if (!W) {
          if (ne > 0) {
            if (n.isNextButtonDisabled()) return;
            n.nextPage();
          } else {
            if (n.isPrevButtonDisabled()) return;
            n.prevPage();
          }
          ke(() => {
            F(J, ne);
          });
          return;
        }
        if (W && W.hasAttribute("data-disabled")) return F(Q, ne);
        n.onPlaceholderChange(Q), W?.focus();
      }
    }
    return (q, T) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: r,
      as: q.as,
      "as-child": q.asChild,
      role: "button",
      "aria-label": o.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-pressed": i.value && (v.value || !s.value) ? !0 : void 0,
      "aria-disabled": C.value || s.value ? !0 : void 0,
      "data-highlighted": p.value && (v.value || !s.value) ? "" : void 0,
      "data-selection-start": u.value ? !0 : void 0,
      "data-selection-end": d.value ? !0 : void 0,
      "data-highlighted-start": c.value ? !0 : void 0,
      "data-highlighted-end": f.value ? !0 : void 0,
      "data-selected": i.value && (v.value || !s.value) ? !0 : void 0,
      "data-outside-visible-view": w.value ? "" : void 0,
      "data-value": q.day.toString(),
      "data-disabled": C.value ? "" : void 0,
      "data-unavailable": s.value ? "" : void 0,
      "data-today": m.value ? "" : void 0,
      "data-outside-view": g.value ? "" : void 0,
      "data-focused": $.value ? "" : void 0,
      tabindex: $.value ? 0 : g.value || C.value ? void 0 : -1,
      onClick: k,
      onFocusin: P,
      onMouseenter: P,
      onKeydown: Je(D, [
        "up",
        "down",
        "left",
        "right",
        "enter",
        "space"
      ])
    }, {
      default: y(() => [_(q.$slots, "default", {
        dayValue: S.value,
        disabled: C.value,
        today: m.value,
        selected: i.value,
        outsideView: g.value,
        outsideVisibleView: w.value,
        unavailable: s.value,
        highlighted: p.value && (v.value || !s.value),
        highlightedStart: c.value,
        highlightedEnd: f.value,
        selectionStart: u.value,
        selectionEnd: d.value
      }, () => [Re(He(S.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "aria-pressed",
      "aria-disabled",
      "data-highlighted",
      "data-selection-start",
      "data-selection-end",
      "data-highlighted-start",
      "data-highlighted-end",
      "data-selected",
      "data-outside-visible-view",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), XB = YB, JB = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = eo(), a = E(() => n.disabled.value ? !0 : void 0), r = E(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), x(l(X), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), ZB = JB, QB = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), eD = QB, tD = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nD = tD, aD = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rD = aD, oD = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sD = oD, lD = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iD = lD, uD = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = eo();
    return (a, r) => (h(), x(l(X), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(He(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), dD = uD, cD = /* @__PURE__ */ b({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = eo();
    return (r, o) => (h(), x(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), fD = cD, pD = /* @__PURE__ */ b({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = eo();
    return (r, o) => (h(), x(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Previous page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), vD = pD, mD = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Fc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), hD = mD;
const [Pg, gD] = Be("DropdownMenuRoot");
var yD = /* @__PURE__ */ b({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = I(), { modal: s, dir: i } = Me(n), u = yt(i);
    return gD({
      open: r,
      onOpenChange: (d) => {
        r.value = d;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      triggerId: "",
      triggerElement: o,
      contentId: "",
      modal: s,
      dir: u
    }), (d, c) => (h(), x(l(Ic), {
      open: l(r),
      "onUpdate:open": c[0] || (c[0] = (f) => mt(r) ? r.value = f : null),
      dir: l(u),
      modal: l(s)
    }, {
      default: y(() => [_(d.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), bD = yD, _D = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const o = Pg(), s = I(!1);
    function i(u) {
      u.defaultPrevented || (s.value || setTimeout(() => {
        o.triggerElement.value?.focus();
      }, 0), s.value = !1, u.preventDefault());
    }
    return o.contentId ||= Ge(void 0, "reka-dropdown-menu-content"), (u, d) => (h(), x(l(Nc), A(l(r), {
      id: l(o).contentId,
      "aria-labelledby": l(o)?.triggerId,
      style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: i,
      onInteractOutside: d[0] || (d[0] = (c) => {
        if (c.defaultPrevented) return;
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, v = f.button === 2 || p;
        (!l(o).modal.value || v) && (s.value = !0), l(o).triggerElement.value?.contains(c.target) && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), wD = _D, xD = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Ti), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), CD = xD, SD = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(xs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $D = SD, kD = /* @__PURE__ */ b({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Vc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Mg = kD, BD = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Lc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), DD = BD, PD = /* @__PURE__ */ b({
  __name: "DropdownMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(zc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), MD = PD, qD = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Hc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ED = qD, TD = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Uc), oe(le(l(r))), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), AD = TD, ID = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(jc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OD = ID, RD = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      passive: n.open === void 0,
      defaultValue: n.defaultOpen ?? !1
    });
    return j(), (o, s) => (h(), x(l(Wc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), VD = RD, FD = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Gc), A(l(r), { style: {
      "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ND = FD, LD = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Kc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zD = LD, HD = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Pg(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.triggerElement = r;
    }), n.triggerId ||= Ge(void 0, "reka-dropdown-menu-trigger"), (o, s) => (h(), x(l(Ei), { "as-child": "" }, {
      default: y(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "as-child": t.asChild,
        as: o.as,
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).open.value ? l(n).contentId : void 0,
        "data-disabled": o.disabled ? "" : void 0,
        disabled: o.disabled,
        "data-state": l(n).open.value ? "open" : "closed",
        onClick: s[0] || (s[0] = async (i) => {
          !o.disabled && i.button === 0 && i.ctrlKey === !1 && (l(n)?.onOpenToggle(), await ke(), l(n).open.value && i.preventDefault());
        }),
        onKeydown: s[1] || (s[1] = Je((i) => {
          o.disabled || (["Enter", " "].includes(i.key) && l(n).onOpenToggle(), i.key === "ArrowDown" && l(n).onOpenChange(!0), [
            "Enter",
            " ",
            "ArrowDown"
          ].includes(i.key) && i.preventDefault());
        }, [
          "enter",
          "space",
          "arrow-down"
        ]))
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as-child",
        "as",
        "aria-expanded",
        "aria-controls",
        "data-disabled",
        "disabled",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), UD = HD;
const [Yc, jD] = Be("HoverCardRoot");
var WD = /* @__PURE__ */ b({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    openDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    closeDelay: {
      type: Number,
      required: !1,
      default: 300
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { openDelay: r, closeDelay: o } = Me(n);
    j();
    const s = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = I(0), u = I(0), d = I(!1), c = I(!1), f = I(!1), p = I();
    function v() {
      clearTimeout(u.value), i.value = window.setTimeout(() => s.value = !0, r.value);
    }
    function m() {
      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => s.value = !1, o.value));
    }
    function g() {
      s.value = !1;
    }
    return jD({
      open: s,
      onOpenChange(w) {
        s.value = w;
      },
      onOpen: v,
      onClose: m,
      onDismiss: g,
      hasSelectionRef: d,
      isPointerDownOnContentRef: c,
      isPointerInTransitRef: f,
      triggerElement: p
    }), (w, C) => (h(), x(l(ir), null, {
      default: y(() => [_(w.$slots, "default", { open: l(s) })]),
      _: 3
    }));
  }
}), GD = WD;
function Cd(e) {
  return (t) => t.pointerType === "touch" ? void 0 : e();
}
function KD(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
var YD = /* @__PURE__ */ b({
  __name: "HoverCardContentImpl",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(n), { forwardRef: o, currentElement: s } = j(), i = Yc(), { isPointerInTransit: u, onPointerExit: d } = Nh(i.triggerElement, s);
    J0(i.isPointerInTransitRef, u, { direction: "rtl" }), d(() => {
      i.onClose();
    });
    const c = I(!1);
    let f;
    Ie((v) => {
      if (c.value) {
        const m = document.body;
        f = m.style.userSelect || m.style.webkitUserSelect, m.style.userSelect = "none", m.style.webkitUserSelect = "none", v(() => {
          m.style.userSelect = f, m.style.webkitUserSelect = f;
        });
      }
    });
    function p() {
      c.value = !1, i.isPointerDownOnContentRef.value = !1, ke(() => {
        document.getSelection()?.toString() !== "" && (i.hasSelectionRef.value = !0);
      });
    }
    return Ce(() => {
      s.value && (document.addEventListener("pointerup", p), KD(s.value).forEach((m) => m.setAttribute("tabindex", "-1")));
    }), Qe(() => {
      document.removeEventListener("pointerup", p), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;
    }), (v, m) => (h(), x(l(Fa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: m[1] || (m[1] = (g) => a("escapeKeyDown", g)),
      onPointerDownOutside: m[2] || (m[2] = (g) => a("pointerDownOutside", g)),
      onFocusOutside: m[3] || (m[3] = Ke((g) => a("focusOutside", g), ["prevent"])),
      onDismiss: l(i).onDismiss
    }, {
      default: y(() => [N(l(Zr), A({
        ...l(r),
        ...v.$attrs
      }, {
        ref: l(o),
        "data-state": l(i).open.value ? "open" : "closed",
        style: {
          userSelect: c.value ? "text" : void 0,
          WebkitUserSelect: c.value ? "text" : void 0,
          "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
          "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
          "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onPointerdown: m[0] || (m[0] = (g) => {
          g.currentTarget.contains(g.target) && (c.value = !0), l(i).hasSelectionRef.value = !1, l(i).isPointerDownOnContentRef.value = !0;
        })
      }), {
        default: y(() => [_(v.$slots, "default")]),
        _: 3
      }, 16, ["data-state", "style"])]),
      _: 3
    }, 8, ["onDismiss"]));
  }
}), XD = YD, JD = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), { forwardRef: o } = j(), s = Yc();
    return (i, u) => (h(), x(l(St), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(XD, A(l(r), {
        ref: l(o),
        onPointerenter: u[0] || (u[0] = (d) => l(Cd)(l(s).onOpen)(d))
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), ZD = JD, QD = /* @__PURE__ */ b({
  __name: "HoverCardPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), eP = QD, tP = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  setup(e) {
    const { forwardRef: t, currentElement: n } = j(), a = Yc();
    a.triggerElement = n;
    function r() {
      setTimeout(() => {
        !a.isPointerInTransitRef.value && !a.open.value && a.onClose();
      }, 0);
    }
    return (o, s) => (h(), x(l(ur), {
      "as-child": "",
      reference: o.reference
    }, {
      default: y(() => [N(l(X), {
        ref: l(t),
        "as-child": o.asChild,
        as: o.as,
        "data-state": l(a).open.value ? "open" : "closed",
        "data-grace-area-trigger": "",
        onPointerenter: s[0] || (s[0] = (i) => l(Cd)(l(a).onOpen)(i)),
        onPointerleave: s[1] || (s[1] = (i) => l(Cd)(r)(i)),
        onFocus: s[2] || (s[2] = (i) => l(a).onOpen()),
        onBlur: s[3] || (s[3] = (i) => l(a).onClose())
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "data-state"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), nP = tP, aP = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "label"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { onMousedown: a[0] || (a[0] = (r) => {
      !r.defaultPrevented && r.detail > 1 && r.preventDefault();
    }) }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rP = aP, oP = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Fc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sP = oP;
const [Ai, lP] = Be("MenubarRoot");
var iP = /* @__PURE__ */ b({
  __name: "MenubarRoot",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r } = j(), { CollectionSlot: o } = st({
      key: "Menubar",
      isProvider: !0
    }), s = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), i = I(null), { dir: u, loop: d } = Me(n), c = yt(u);
    return lP({
      modelValue: s,
      dir: c,
      loop: d,
      onMenuOpen: (f) => {
        s.value = f, i.value = f;
      },
      onMenuClose: () => {
        s.value = "";
      },
      onMenuToggle: (f) => {
        s.value = s.value ? "" : f, i.value = f;
      }
    }), (f, p) => (h(), x(l(o), null, {
      default: y(() => [N(l(ys), {
        "current-tab-stop-id": i.value,
        "onUpdate:currentTabStopId": p[0] || (p[0] = (v) => i.value = v),
        orientation: "horizontal",
        loop: l(d),
        dir: l(c),
        "as-child": ""
      }, {
        default: y(() => [N(l(X), {
          ref: l(r),
          role: "menubar"
        }, {
          default: y(() => [_(f.$slots, "default", { modelValue: l(s) })]),
          _: 3
        }, 512)]),
        _: 3
      }, 8, [
        "current-tab-stop-id",
        "loop",
        "dir"
      ])]),
      _: 3
    }));
  }
}), uP = iP;
const [Xc, dP] = Be("MenubarMenu");
var cP = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: { value: {
    type: String,
    required: !1
  } },
  setup(e) {
    const n = Ge(e.value), a = Ai();
    j();
    const r = I(), o = I(!1), s = E(() => a.modelValue.value === n);
    return ve(s, () => {
      s.value || (o.value = !1);
    }), dP({
      value: n,
      triggerElement: r,
      triggerId: n,
      contentId: "",
      wasKeyboardTriggerOpenRef: o
    }), (i, u) => (h(), x(l(Ic), {
      open: s.value,
      modal: !1,
      dir: l(a).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || l(a).onMenuClose();
      })
    }, {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), fP = cP, pP = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const o = Ai(), s = Xc();
    s.contentId ||= Ge(void 0, "reka-menubar-content");
    const { getItems: i } = st({ key: "Menubar" }), u = I(!1);
    function d(c) {
      const p = c.target.hasAttribute("data-reka-menubar-subtrigger"), m = (o.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!m && p) return;
      let w = i().filter(($) => $.ref.dataset.disabled !== "").map(($) => $.ref.dataset.value);
      m && w.reverse();
      const C = w.indexOf(s.value);
      w = o.loop.value ? Sc(w, C + 1) : w.slice(C + 1);
      const [S] = w;
      S && o.onMenuOpen(S);
    }
    return (c, f) => (h(), x(l(Nc), A(l(r), {
      id: l(s).contentId,
      "data-reka-menubar-content": "",
      "aria-labelledby": l(s).triggerId,
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (p) => {
        !l(o).modelValue.value && !u.value && l(s).triggerElement.value?.focus(), u.value = !1, p.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (p) => {
        const v = p.target;
        l(i)().filter((g) => g.ref.dataset.disabled !== "").some((g) => g.ref.contains(v)) && p.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (p) => {
        u.value = !0;
      }),
      onEntryFocus: f[3] || (f[3] = (p) => {
        l(s).wasKeyboardTriggerOpenRef.value || p.preventDefault();
      }),
      onKeydown: Je(d, ["arrow-right", "arrow-left"])
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), vP = pP, mP = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Ti), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), hP = mP, gP = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(xs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), yP = gP, bP = /* @__PURE__ */ b({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Vc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), qg = bP, _P = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Lc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), wP = _P, xP = /* @__PURE__ */ b({
  __name: "MenubarPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(zc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Eg = xP, CP = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Hc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), SP = CP, $P = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Uc), oe(le(l(r))), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), kP = $P, BP = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(jc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), DP = BP, PP = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    return (o, s) => (h(), x(l(Wc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), MP = PP, qP = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const { getItems: o } = st({ key: "Menubar" }), s = Ai(), i = Xc();
    function u(d) {
      if (d.target.hasAttribute("data-reka-menubar-subtrigger")) return;
      let p = o().filter((g) => g.ref.dataset.disabled !== "").map((g) => g.ref.dataset.value);
      const v = p.indexOf(i.value);
      p = s.loop.value ? Sc(p, v + 1) : p.slice(v + 1);
      const [m] = p;
      m && s.onMenuOpen(m);
    }
    return (d, c) => (h(), x(l(Gc), A(l(r), {
      "data-reka-menubar-content": "",
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onKeydown: Je(u, ["arrow-right"])
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), EP = qP, TP = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Kc), A(t, { "data-reka-menubar-subtrigger": "" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), AP = TP, IP = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = Ai(), n = Xc(), { forwardRef: a, currentElement: r } = j(), { CollectionItem: o } = st({ key: "Menubar" }), s = I(!1), i = E(() => t.modelValue.value === n.value);
    return Ce(() => {
      n.triggerElement = r;
    }), (u, d) => (h(), x(l(bs), {
      "as-child": "",
      focusable: !u.disabled,
      "tab-stop-id": l(n).value
    }, {
      default: y(() => [N(l(o), null, {
        default: y(() => [N(l(Ei), { "as-child": "" }, {
          default: y(() => [N(l(X), {
            id: l(n).triggerId,
            ref: l(a),
            as: u.as,
            "as-child": u.asChild,
            type: u.as === "button" ? "button" : void 0,
            role: "menuitem",
            "aria-haspopup": "menu",
            "aria-expanded": i.value,
            "aria-controls": i.value ? l(n).contentId : void 0,
            "data-highlighted": s.value ? "" : void 0,
            "data-state": i.value ? "open" : "closed",
            "data-disabled": u.disabled ? "" : void 0,
            disabled: u.disabled,
            "data-value": l(n).value,
            onPointerdown: d[0] || (d[0] = (c) => {
              !u.disabled && c.button === 0 && c.ctrlKey === !1 && (l(t).onMenuOpen(l(n).value), i.value || c.preventDefault());
            }),
            onPointerenter: d[1] || (d[1] = () => {
              l(t).modelValue.value && !i.value && (l(t).onMenuOpen(l(n).value), l(r)?.focus());
            }),
            onKeydown: d[2] || (d[2] = Je((c) => {
              u.disabled || (["Enter", " "].includes(c.key) && l(t).onMenuToggle(l(n).value), c.key === "ArrowDown" && l(t).onMenuOpen(l(n).value), [
                "Enter",
                " ",
                "ArrowDown"
              ].includes(c.key) && (l(n).wasKeyboardTriggerOpenRef.value = !0, c.preventDefault()));
            }, [
              "enter",
              "space",
              "arrow-down"
            ])),
            onFocus: d[3] || (d[3] = (c) => s.value = !0),
            onBlur: d[4] || (d[4] = (c) => s.value = !1)
          }, {
            default: y(() => [_(u.$slots, "default")]),
            _: 3
          }, 8, [
            "id",
            "as",
            "as-child",
            "type",
            "aria-expanded",
            "aria-controls",
            "data-highlighted",
            "data-state",
            "data-disabled",
            "disabled",
            "data-value"
          ])]),
          _: 3
        })]),
        _: 3
      })]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), OP = IP;
const [fr, RP] = Be(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var VP = /* @__PURE__ */ b({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: void 0
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: 200
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableClickTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableHoverTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disablePointerLeaveClose: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "modelValue", t, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), o = I(""), { forwardRef: s, currentElement: i } = j(), u = I(), d = I(), c = I(), { getItems: f, CollectionSlot: p } = st({
      key: "NavigationMenu",
      isProvider: !0
    }), { delayDuration: v, skipDelayDuration: m, dir: g, disableClickTrigger: w, disableHoverTrigger: C, unmountOnHide: S } = Me(n), $ = yt(g), B = cs(!1, m), k = E(() => r.value !== "" || B.value ? 150 : v.value), P = dc((D) => {
      typeof D == "string" && (o.value = r.value, r.value = D);
    }, k);
    return Ie(() => {
      if (!r.value) return;
      const D = f().map((q) => q.ref);
      c.value = D.find((q) => q.id.includes(r.value));
    }), RP({
      isRootMenu: !0,
      modelValue: r,
      previousValue: o,
      baseId: Ge(void 0, "reka-navigation-menu"),
      disableClickTrigger: w,
      disableHoverTrigger: C,
      dir: $,
      unmountOnHide: S,
      orientation: n.orientation,
      rootNavigationMenu: i,
      indicatorTrack: u,
      activeTrigger: c,
      onIndicatorTrackChange: (D) => {
        u.value = D;
      },
      viewport: d,
      onViewportChange: (D) => {
        d.value = D;
      },
      onTriggerEnter: (D) => {
        P(D);
      },
      onTriggerLeave: () => {
        B.value = !0, P("");
      },
      onContentEnter: () => {
        P();
      },
      onContentLeave: () => {
        n.disablePointerLeaveClose || P("");
      },
      onItemSelect: (D) => {
        o.value = r.value, r.value = D;
      },
      onItemDismiss: () => {
        o.value = r.value, r.value = "";
      }
    }), (D, q) => (h(), x(l(p), null, {
      default: y(() => [N(l(X), {
        ref: l(s),
        "aria-label": "Main",
        as: D.as,
        "as-child": D.asChild,
        "data-orientation": D.orientation,
        dir: l($),
        "data-reka-navigation-menu": ""
      }, {
        default: y(() => [_(D.$slots, "default", { modelValue: l(r) })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-orientation",
        "dir"
      ])]),
      _: 3
    }));
  }
}), FP = VP;
function Ii(e) {
  return e ? "open" : "closed";
}
function Tg(e, t) {
  return `${e}-trigger-${t}`;
}
function Jc(e, t) {
  return `${e}-content-${t}`;
}
const NP = "navigationMenu.linkSelect", cl = "navigationMenu.rootContentDismiss";
function Sd(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Ag(e) {
  const t = ot();
  return e.some((n) => n === t ? !0 : (n.focus(), ot() !== t));
}
function LP(e) {
  return e.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    e.forEach((t) => {
      const n = t.dataset.tabindex;
      t.setAttribute("tabindex", n);
    });
  };
}
function Ig(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
const [Zc, zP] = Be("NavigationMenuItem");
var HP = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  setup(e) {
    const t = e;
    j();
    const { getItems: n } = st({ key: "NavigationMenu" }), a = fr(), r = Ge(t.value), o = I(), s = I(), i = Jc(a.baseId, r);
    let u = () => ({});
    const d = I(!1);
    async function c(m = "start") {
      const g = document.getElementById(i);
      if (g) {
        u();
        const w = Sd(g);
        w.length && Ag(m === "start" ? w : w.reverse());
      }
    }
    function f() {
      const m = document.getElementById(i);
      if (m) {
        const g = Sd(m);
        g.length && (u = LP(g));
      }
    }
    zP({
      value: r,
      contentId: i,
      triggerRef: o,
      focusProxyRef: s,
      wasEscapeCloseRef: d,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function p() {
      a.onItemDismiss(), o.value?.focus();
    }
    function v(m) {
      const g = ot();
      if (m.keyCode === 32 || m.key === "Enter") if (a.modelValue.value === r) {
        p(), m.preventDefault();
        return;
      } else {
        m.target.click(), m.preventDefault();
        return;
      }
      const w = n().filter((S) => S.ref.parentElement?.hasAttribute("data-menu-item")).map((S) => S.ref);
      if (!w.includes(g)) return;
      const C = lr(m, g, void 0, {
        itemsArray: w,
        loop: !1
      });
      C && C?.focus(), m.preventDefault(), m.stopPropagation();
    }
    return (m, g) => (h(), x(l(X), {
      "as-child": m.asChild,
      as: m.as,
      "data-menu-item": "",
      onKeydown: Je(v, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end",
        "space"
      ])
    }, {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), UP = HP, jP = /* @__PURE__ */ b({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = fr(), u = Zc(), d = Tg(i.baseId, u.value), c = Jc(i.baseId, u.value), f = I(null), p = E(() => {
      const S = r().map((q) => q.ref.id.split("trigger-")[1]);
      i.dir.value === "rtl" && S.reverse();
      const $ = S.indexOf(i.modelValue.value), B = S.indexOf(i.previousValue.value), k = u.value === i.modelValue.value, P = B === S.indexOf(u.value);
      if (!k && !P) return f.value;
      const D = (() => {
        if ($ !== B) {
          if (k && B !== -1) return $ > B ? "from-end" : "from-start";
          if (P && $ !== -1) return $ > B ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = D, D;
    });
    function v(S) {
      if (a("focusOutside", S), a("interactOutside", S), S.detail.originalEvent.target.hasAttribute("data-navigation-menu-trigger") && S.preventDefault(), !S.defaultPrevented) {
        u.onContentFocusOutside();
        const B = S.target;
        i.rootNavigationMenu?.value?.contains(B) && S.preventDefault();
      }
    }
    function m(S) {
      if (a("pointerDownOutside", S), !S.defaultPrevented) {
        const $ = S.target, B = r().some((P) => P.ref.contains($)), k = i.isRootMenu && i.viewport.value?.contains($);
        (B || k || !i.isRootMenu) && S.preventDefault();
      }
    }
    Ie((S) => {
      const $ = s.value;
      if (i.isRootMenu && $) {
        const B = () => {
          i.onItemDismiss(), u.onRootContentClose(), $.contains(ot()) && u.triggerRef.value?.focus();
        };
        $.addEventListener(cl, B), S(() => $.removeEventListener(cl, B));
      }
    });
    function g(S) {
      a("escapeKeyDown", S), S.defaultPrevented || (i.onItemDismiss(), u.triggerRef?.value?.focus(), u.wasEscapeCloseRef.value = !0);
    }
    function w(S) {
      if (S.target.closest("[data-reka-navigation-menu]") !== i.rootNavigationMenu.value) return;
      const $ = S.altKey || S.ctrlKey || S.metaKey, B = S.key === "Tab" && !$, k = Sd(S.currentTarget);
      if (B) {
        const D = ot(), q = k.findIndex((O) => O === D), M = S.shiftKey ? k.slice(0, q).reverse() : k.slice(q + 1, k.length);
        if (Ag(M)) S.preventDefault();
        else {
          u.focusProxyRef.value?.focus();
          return;
        }
      }
      lr(S, ot(), void 0, {
        itemsArray: k,
        loop: !1,
        enableIgnoredElement: !0
      })?.focus();
    }
    function C() {
      const S = new Event(cl, {
        bubbles: !0,
        cancelable: !0
      });
      s.value?.dispatchEvent(S);
    }
    return (S, $) => (h(), x(l(Fa), A({
      id: l(c),
      ref: l(o),
      "aria-labelledby": l(d),
      "data-motion": p.value,
      "data-state": l(Ii)(l(i).modelValue.value === l(u).value),
      "data-orientation": l(i).orientation
    }, n, {
      onKeydown: w,
      onEscapeKeyDown: g,
      onPointerDownOutside: m,
      onFocusOutside: v,
      onDismiss: C
    }), {
      default: y(() => [_(S.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "data-motion",
      "data-state",
      "data-orientation"
    ]));
  }
}), WP = jP, GP = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = me(ds(n, "forceMount"), a), { forwardRef: o } = j(), s = fr(), i = Zc(), u = E(() => i.value === s.modelValue.value), d = E(() => s.viewport.value && !s.modelValue.value && s.previousValue.value ? s.previousValue.value === i.value : !1);
    return (c, f) => (h(), x(vi, {
      to: l(rn) && l(s).viewport.value ? l(s).viewport.value : "body",
      disabled: l(rn) && l(s).viewport.value ? !l(s).viewport.value : !0
    }, [N(l(St), {
      present: c.forceMount || u.value || d.value,
      "force-mount": !l(s).unmountOnHide.value
    }, {
      default: y(({ present: p }) => [N(WP, A({
        ref: l(o),
        "data-state": l(Ii)(u.value),
        style: { pointerEvents: !u.value && l(s).isRootMenu ? "none" : void 0 }
      }, {
        ...c.$attrs,
        ...l(r)
      }, {
        hidden: !p,
        onPointerenter: f[0] || (f[0] = (v) => l(s).onContentEnter(l(i).value)),
        onPointerleave: f[1] || (f[1] = (v) => l(Ig)(() => l(s).onContentLeave())(v)),
        onPointerDownOutside: f[2] || (f[2] = (v) => a("pointerDownOutside", v)),
        onFocusOutside: f[3] || (f[3] = (v) => a("focusOutside", v)),
        onInteractOutside: f[4] || (f[4] = (v) => a("interactOutside", v))
      }), {
        default: y(() => [_(c.$slots, "default")]),
        _: 2
      }, 1040, [
        "data-state",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"])], 8, ["to", "disabled"]));
  }
}), KP = GP, YP = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = fr(), r = I(), o = E(() => a.orientation === "horizontal"), s = E(() => !!a.modelValue.value), { activeTrigger: i } = a;
    function u() {
      i.value && (r.value = {
        size: o.value ? i.value.offsetWidth : i.value.offsetHeight,
        position: o.value ? i.value.offsetLeft : i.value.offsetTop
      });
    }
    return Ie(() => {
      a.modelValue.value && u();
    }), Tn(i, u), Tn(a.indicatorTrack, u), (d, c) => l(a).indicatorTrack.value ? (h(), x(vi, {
      key: 0,
      to: l(a).indicatorTrack.value
    }, [N(l(St), { present: d.forceMount || s.value }, {
      default: y(() => [N(l(X), A({
        ref: l(n),
        "aria-hidden": "true",
        "data-state": s.value ? "visible" : "hidden",
        "data-orientation": l(a).orientation,
        "as-child": t.asChild,
        as: d.as,
        style: { ...r.value ? {
          "--reka-navigation-menu-indicator-size": `${r.value.size}px`,
          "--reka-navigation-menu-indicator-position": `${r.value.position}px`
        } : {} }
      }, d.$attrs), {
        default: y(() => [_(d.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }, 8, ["present"])], 8, ["to"])) : Ee("v-if", !0);
  }
}), XP = YP, JP = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { CollectionItem: r } = st({ key: "NavigationMenu" });
    j();
    async function o(s) {
      const i = new CustomEvent(NP, {
        bubbles: !0,
        cancelable: !0,
        detail: { originalEvent: s }
      });
      if (a("select", i), !i.defaultPrevented && !s.metaKey) {
        const u = new CustomEvent(cl, {
          bubbles: !0,
          cancelable: !0
        });
        s.target?.dispatchEvent(u);
      }
    }
    return (s, i) => (h(), x(l(r), null, {
      default: y(() => [N(l(X), {
        as: s.as,
        "data-active": s.active ? "" : void 0,
        "aria-current": s.active ? "page" : void 0,
        "as-child": n.asChild,
        onClick: o
      }, {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "data-active",
        "aria-current",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), ZP = JP, QP = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  setup(e) {
    const t = e, n = fr(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onIndicatorTrackChange(r.value);
    }), (o, s) => (h(), x(l(X), {
      ref: l(a),
      style: { position: "relative" }
    }, {
      default: y(() => [N(l(X), A(o.$attrs, {
        "as-child": t.asChild,
        as: o.as,
        "data-orientation": l(n).orientation
      }), {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-orientation"
      ])]),
      _: 3
    }, 512));
  }
}), eM = QP;
const tM = ["aria-owns"];
var nM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = fr(), a = Zc(), { CollectionItem: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = I(""), u = I(""), d = cs(!1, 300), c = I(!1), f = E(() => a.value === n.modelValue.value);
    Ce(() => {
      a.triggerRef = s, i.value = Tg(n.baseId, a.value), u.value = Jc(n.baseId, a.value);
    });
    function p() {
      n.disableHoverTrigger.value || (c.value = !1, a.wasEscapeCloseRef.value = !1);
    }
    function v($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled || c.value || a.wasEscapeCloseRef.value || d.value) return;
        n.onTriggerEnter(a.value), d.value = !0;
      }
    }
    function m($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled) return;
        n.onTriggerLeave(), d.value = !1;
      }
    }
    function g($) {
      (!("pointerType" in $) || $.pointerType === "mouse") && n.disableClickTrigger.value || d.value || (f.value ? n.onItemSelect("") : n.onItemSelect(a.value), c.value = f.value);
    }
    function w($) {
      const k = {
        horizontal: "ArrowDown",
        vertical: n.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight"
      }[n.orientation];
      f.value && $.key === k && (a.onEntryKeyDown(), $.preventDefault(), $.stopPropagation());
    }
    function C($) {
      a.focusProxyRef.value = Gt($);
    }
    function S($) {
      const B = document.getElementById(a.contentId), k = $.relatedTarget, P = k === s.value, D = B?.contains(k);
      (P || !D) && a.onFocusProxyEnter(P ? "start" : "end");
    }
    return ($, B) => (h(), G(Ye, null, [N(l(r), null, {
      default: y(() => [N(l(X), A({
        id: i.value,
        ref: l(o),
        disabled: $.disabled,
        "data-disabled": $.disabled ? "" : void 0,
        "data-state": l(Ii)(f.value),
        "data-navigation-menu-trigger": "",
        "aria-expanded": f.value,
        "aria-controls": u.value,
        "as-child": t.asChild,
        as: $.as
      }, $.$attrs, {
        onPointerenter: p,
        onPointermove: v,
        onPointerleave: m,
        onClick: g,
        onKeydown: w
      }), {
        default: y(() => [_($.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "disabled",
        "data-disabled",
        "data-state",
        "aria-expanded",
        "aria-controls",
        "as-child",
        "as"
      ])]),
      _: 3
    }), f.value ? (h(), G(Ye, { key: 0 }, [N(l($i), {
      ref: C,
      "aria-hidden": "true",
      tabindex: 0,
      onFocus: S
    }), l(n).viewport ? (h(), G("span", {
      key: 0,
      "aria-owns": u.value
    }, null, 8, tM)) : Ee("v-if", !0)], 64)) : Ee("v-if", !0)], 64));
  }
}), aM = nM, rM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    align: {
      type: String,
      required: !1,
      default: "center"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = fr(), { activeTrigger: o, rootNavigationMenu: s, modelValue: i } = r, u = I(), d = I(), c = E(() => !!r.modelValue.value);
    ve(a, () => {
      r.onViewportChange(a.value);
    });
    const f = I();
    ve([i, c], () => {
      ke(() => {
        a.value && requestAnimationFrame(() => {
          const v = a.value?.querySelector("[data-state=open]");
          f.value = v;
        });
      });
    }, { immediate: !0 });
    function p() {
      if (f.value && o.value && s.value) {
        const v = document.documentElement.offsetWidth, m = document.documentElement.offsetHeight, g = s.value.getBoundingClientRect(), w = o.value.getBoundingClientRect(), { offsetWidth: C, offsetHeight: S } = f.value, $ = w.left - g.left, B = w.top - g.top;
        let k = null, P = null;
        switch (t.align) {
          case "start":
            k = $, P = B;
            break;
          case "end":
            k = $ - C + w.width, P = B - S + w.height;
            break;
          default:
            k = $ - C / 2 + w.width / 2, P = B - S / 2 + w.height / 2;
        }
        const D = 10;
        k + g.left < D && (k = D - g.left);
        const q = k + g.left + C;
        q > v - D && (k -= q - v + D, k < D - g.left && (k = D - g.left)), P + g.top < D && (P = D - g.top);
        const T = P + g.top + S;
        T > m - D && (P -= T - m + D, P < D - g.top && (P = D - g.top)), k = Math.round(k), P = Math.round(P), d.value = {
          left: k,
          top: P
        };
      }
    }
    return Tn(f, () => {
      f.value && (u.value = {
        width: f.value.offsetWidth,
        height: f.value.offsetHeight
      }, p());
    }), Tn([globalThis.document?.body, s], () => {
      p();
    }), (v, m) => (h(), x(l(St), {
      present: v.forceMount || c.value,
      "force-mount": !l(r).unmountOnHide.value,
      onAfterLeave: m[2] || (m[2] = () => {
        u.value = void 0, d.value = void 0;
      })
    }, {
      default: y(({ present: g }) => [N(l(X), A(v.$attrs, {
        ref: l(n),
        as: v.as,
        "as-child": v.asChild,
        "data-state": l(Ii)(c.value),
        "data-orientation": l(r).orientation,
        style: {
          pointerEvents: !c.value && l(r).isRootMenu ? "none" : void 0,
          "--reka-navigation-menu-viewport-width": u.value ? `${u.value?.width}px` : void 0,
          "--reka-navigation-menu-viewport-height": u.value ? `${u.value?.height}px` : void 0,
          "--reka-navigation-menu-viewport-left": d.value ? `${d.value?.left}px` : void 0,
          "--reka-navigation-menu-viewport-top": d.value ? `${d.value?.top}px` : void 0
        },
        hidden: !g,
        onPointerenter: m[0] || (m[0] = (w) => l(r).onContentEnter(l(r).modelValue.value)),
        onPointerleave: m[1] || (m[1] = (w) => l(Ig)(() => l(r).onContentLeave())(w))
      }), {
        default: y(() => [_(v.$slots, "default")]),
        _: 2
      }, 1040, [
        "as",
        "as-child",
        "data-state",
        "data-orientation",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"]));
  }
}), oM = rM;
let Tu = /* @__PURE__ */ new Map(), $d = !1;
try {
  $d = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let Ol = !1;
try {
  Ol = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const Og = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
class Rg {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let n = "";
    if (!$d && this.options.signDisplay != null ? n = lM(this.numberFormatter, this.options.signDisplay, t) : n = this.numberFormatter.format(t), this.options.style === "unit" && !Ol) {
      var a;
      let { unit: r, unitDisplay: o = "short", locale: s } = this.resolvedOptions();
      if (!r) return n;
      let i = (a = Og[r]) === null || a === void 0 ? void 0 : a[o];
      n += i[s] || i.default;
    }
    return n;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, n) {
    if (typeof this.numberFormatter.formatRange == "function") return this.numberFormatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)}  ${this.format(n)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.numberFormatter.formatRangeToParts == "function") return this.numberFormatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.numberFormatter.formatToParts(t), r = this.numberFormatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !$d && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !Ol && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, n = {}) {
    this.numberFormatter = sM(t, n), this.options = n;
  }
}
function sM(e, t = {}) {
  let { numberingSystem: n } = t;
  if (n && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${n}`), t.style === "unit" && !Ol) {
    var a;
    let { unit: s, unitDisplay: i = "short" } = t;
    if (!s) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((a = Og[s]) === null || a === void 0) && a[i])) throw new Error(`Unsupported unit ${s} with unitDisplay = ${i}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let r = e + (t ? Object.entries(t).sort((s, i) => s[0] < i[0] ? -1 : 1).join() : "");
  if (Tu.has(r)) return Tu.get(r);
  let o = new Intl.NumberFormat(e, t);
  return Tu.set(r, o), o;
}
function lM(e, t, n) {
  if (t === "auto") return e.format(n);
  if (t === "never") return e.format(Math.abs(n));
  {
    let a = !1;
    if (t === "always" ? a = n > 0 || Object.is(n, 0) : t === "exceptZero" && (Object.is(n, -0) || Object.is(n, 0) ? n = Math.abs(n) : a = n > 0), a) {
      let r = e.format(-n), o = e.format(n), s = r.replace(o, "").replace(/\u200e|\u061C/, "");
      return [
        ...s
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), r.replace(o, "!!!").replace(s, "+").replace("!!!", o);
    } else return e.format(n);
  }
}
const iM = new RegExp("^.*\\(.*\\).*$"), uM = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
class Vg {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return Au(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, n, a) {
    return Au(this.locale, this.options, t).isValidPartialNumber(t, n, a);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return Au(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, n = {}) {
    this.locale = t, this.options = n;
  }
}
const Qp = /* @__PURE__ */ new Map();
function Au(e, t, n) {
  let a = ev(e, t);
  if (!e.includes("-nu-") && !a.isValidPartialNumber(n)) {
    for (let r of uM) if (r !== a.options.numberingSystem) {
      let o = ev(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + r, t);
      if (o.isValidPartialNumber(n)) return o;
    }
  }
  return a;
}
function ev(e, t) {
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : ""), a = Qp.get(n);
  return a || (a = new dM(e, t), Qp.set(n, a)), a;
}
class dM {
  parse(t) {
    let n = this.sanitize(t);
    if (this.symbols.group && (n = xr(n, this.symbols.group, "")), this.symbols.decimal && (n = n.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (n = n.replace(this.symbols.minusSign, "-")), n = n.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let s = n.indexOf("-");
      n = n.replace("-", ""), n = n.replace("+", "");
      let i = n.indexOf(".");
      i === -1 && (i = n.length), n = n.replace(".", ""), i - 2 === 0 ? n = `0.${n}` : i - 2 === -1 ? n = `0.0${n}` : i - 2 === -2 ? n = "0.00" : n = `${n.slice(0, i - 2)}.${n.slice(i - 2)}`, s > -1 && (n = `-${n}`);
    }
    let a = n ? +n : NaN;
    if (isNaN(a)) return NaN;
    if (this.options.style === "percent") {
      var r, o;
      let s = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((r = this.options.minimumFractionDigits) !== null && r !== void 0 ? r : 0) + 2, 20),
        maximumFractionDigits: Math.min(((o = this.options.maximumFractionDigits) !== null && o !== void 0 ? o : 0) + 2, 20)
      };
      return new Vg(this.locale, s).parse(new Rg(this.locale, s).format(a));
    }
    return this.options.currencySign === "accounting" && iM.test(t) && (a = -1 * a), a;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("", this.symbols.decimal)), this.symbols.group && (t = xr(t, ".", this.symbols.group))), this.symbols.group === "" && t.includes("'") && (t = xr(t, "'", this.symbols.group)), this.options.locale === "fr-FR" && this.symbols.group && (t = xr(t, " ", this.symbols.group), t = xr(t, /\u00A0/g, this.symbols.group)), t;
  }
  isValidPartialNumber(t, n = -1 / 0, a = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && n < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && a > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = xr(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, n = {}) {
    this.locale = t, n.roundingIncrement !== 1 && n.roundingIncrement != null && (n.maximumFractionDigits == null && n.minimumFractionDigits == null ? (n.maximumFractionDigits = 0, n.minimumFractionDigits = 0) : n.maximumFractionDigits == null ? n.maximumFractionDigits = n.minimumFractionDigits : n.minimumFractionDigits == null && (n.minimumFractionDigits = n.maximumFractionDigits)), this.formatter = new Intl.NumberFormat(t, n), this.options = this.formatter.resolvedOptions(), this.symbols = fM(t, this.formatter, this.options, n);
    var a, r;
    this.options.style === "percent" && (((a = this.options.minimumFractionDigits) !== null && a !== void 0 ? a : 0) > 18 || ((r = this.options.maximumFractionDigits) !== null && r !== void 0 ? r : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const tv = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), cM = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function fM(e, t, n, a) {
  var r, o, s, i;
  let u = new Intl.NumberFormat(e, {
    ...n,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  }), d = u.formatToParts(-10000.111), c = u.formatToParts(10000.111), f = cM.map((M) => u.formatToParts(M));
  var p;
  let v = (p = (r = d.find((M) => M.type === "minusSign")) === null || r === void 0 ? void 0 : r.value) !== null && p !== void 0 ? p : "-", m = (o = c.find((M) => M.type === "plusSign")) === null || o === void 0 ? void 0 : o.value;
  !m && (a?.signDisplay === "exceptZero" || a?.signDisplay === "always") && (m = "+");
  let w = (s = new Intl.NumberFormat(e, {
    ...n,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((M) => M.type === "decimal")) === null || s === void 0 ? void 0 : s.value, C = (i = d.find((M) => M.type === "group")) === null || i === void 0 ? void 0 : i.value, S = d.filter((M) => !tv.has(M.type)).map((M) => nv(M.value)), $ = f.flatMap((M) => M.filter((O) => !tv.has(O.type)).map((O) => nv(O.value))), B = [
    .../* @__PURE__ */ new Set([
      ...S,
      ...$
    ])
  ].sort((M, O) => O.length - M.length), k = B.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${B.join("|")}|[\\p{White_Space}]`, "gu"), P = [
    ...new Intl.NumberFormat(n.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), D = new Map(P.map((M, O) => [
    M,
    O
  ])), q = new RegExp(`[${P.join("")}]`, "g");
  return {
    minusSign: v,
    plusSign: m,
    decimal: w,
    group: C,
    literals: k,
    numeral: q,
    index: (M) => String(D.get(M))
  };
}
function xr(e, t, n) {
  return e.replaceAll ? e.replaceAll(t, n) : e.split(t).join(n);
}
function nv(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Fg(e) {
  const { disabled: t } = e, n = I(), a = Dr(), r = () => window.clearTimeout(n.value), o = (p) => {
    r(), !t.value && (a.trigger(), n.value = window.setTimeout(() => {
      o(60);
    }, p));
  }, s = () => {
    o(400);
  }, i = () => {
    r();
  }, u = I(!1), d = E(() => Gt(e.target)), c = (p) => {
    p.button !== 0 || u.value || (p.preventDefault(), u.value = !0, s());
  }, f = () => {
    u.value = !1, i();
  };
  return rn && (zt(d || window, "pointerdown", c), zt(window, "pointerup", f), zt(window, "pointercancel", f)), {
    isPressed: u,
    onTrigger: a.on
  };
}
function av(e, t = I({})) {
  return uc(() => new Rg(e.value, t.value));
}
function pM(e, t = I({})) {
  return uc(() => new Vg(e.value, t.value));
}
function rv(e, t, n) {
  let a = e === "+" ? t + n : t - n;
  if (t % 1 !== 0 || n % 1 !== 0) {
    const r = t.toString().split("."), o = n.toString().split("."), s = r[1] && r[1].length || 0, i = o[1] && o[1].length || 0, u = 10 ** Math.max(s, i);
    t = Math.round(t * u), n = Math.round(n * u), a = e === "+" ? t + n : t - n, a /= u;
  }
  return a;
}
const [Qc, vM] = Be("NumberFieldRoot");
var mM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NumberFieldRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: void 0
    },
    modelValue: {
      type: [Number, null],
      required: !1
    },
    min: {
      type: Number,
      required: !1
    },
    max: {
      type: Number,
      required: !1
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    stepSnapping: {
      type: Boolean,
      required: !1,
      default: !0
    },
    formatOptions: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    readonly: {
      type: Boolean,
      required: !1
    },
    disableWheelChange: {
      type: Boolean,
      required: !1
    },
    invertWheelChange: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, disableWheelChange: s, invertWheelChange: i, min: u, max: d, step: c, stepSnapping: f, formatOptions: p, id: v, locale: m } = Me(n), g = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { primitiveElement: w, currentElement: C } = Ht(), S = Cc(m), $ = Rn(C), B = I(), k = E(() => !Mn(g.value) && (U(g.value) === u.value || u.value && !isNaN(g.value) ? rv("-", g.value, c.value) < u.value : !1)), P = E(() => !Mn(g.value) && (U(g.value) === d.value || d.value && !isNaN(g.value) ? rv("+", g.value, c.value) > d.value : !1));
    function D(ee, de = 1) {
      if (B.value?.focus(), n.disabled || n.readonly) return;
      const pe = F.parse(B.value?.value ?? "");
      isNaN(pe) ? g.value = u.value ?? 0 : ee === "increase" ? g.value = U(pe + (c.value ?? 1) * de) : g.value = U(pe - (c.value ?? 1) * de);
    }
    function q(ee = 1) {
      D("increase", ee);
    }
    function T(ee = 1) {
      D("decrease", ee);
    }
    function M(ee) {
      ee === "min" && u.value !== void 0 ? g.value = U(u.value) : ee === "max" && d.value !== void 0 && (g.value = U(d.value));
    }
    const O = av(S, p), F = pM(S, p), J = E(() => O.resolvedOptions().maximumFractionDigits > 0 ? "decimal" : "numeric"), ne = av(S, p), Q = E(() => Mn(g.value) || isNaN(g.value) ? "" : ne.format(g.value));
    function W(ee) {
      return F.isValidPartialNumber(ee, u.value, d.value);
    }
    function H(ee) {
      B.value && (B.value.value = ee);
    }
    function U(ee) {
      let de;
      return c.value === void 0 || isNaN(c.value) || !f.value ? de = Or(ee, u.value, d.value) : de = O0(ee, u.value, d.value, c.value), de = F.parse(O.format(de)), de;
    }
    function se(ee) {
      const de = F.parse(ee);
      return g.value = isNaN(de) ? void 0 : U(de), ee.length ? (isNaN(de), H(Q.value)) : H(ee);
    }
    return vM({
      modelValue: g,
      handleDecrease: T,
      handleIncrease: q,
      handleMinMaxValue: M,
      inputMode: J,
      inputEl: B,
      onInputElement: (ee) => B.value = ee,
      textValue: Q,
      validate: W,
      applyInputValue: se,
      disabled: r,
      readonly: o,
      disableWheelChange: s,
      invertWheelChange: i,
      max: d,
      min: u,
      isDecreaseDisabled: k,
      isIncreaseDisabled: P,
      id: v
    }), (ee, de) => (h(), x(l(X), A(ee.$attrs, {
      ref_key: "primitiveElement",
      ref: w,
      role: "group",
      as: ee.as,
      "as-child": ee.asChild,
      "data-disabled": l(r) ? "" : void 0,
      "data-readonly": l(o) ? "" : void 0
    }), {
      default: y(() => [_(ee.$slots, "default", {
        modelValue: l(g),
        textValue: Q.value
      }), l($) && ee.name ? (h(), x(l(Vn), {
        key: 0,
        type: "text",
        value: l(g),
        name: ee.name,
        disabled: l(r),
        readonly: l(o),
        required: ee.required
      }, null, 8, [
        "value",
        "name",
        "disabled",
        "readonly",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-disabled",
      "data-readonly"
    ]));
  }
}), hM = mM, gM = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Qc(), a = E(() => n.disabled?.value || n.readonly.value || t.disabled || n.isDecreaseDisabled.value), { primitiveElement: r, currentElement: o } = Ht(), { isPressed: s, onTrigger: i } = Fg({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleDecrease();
    }), (u, d) => (h(), x(l(X), A(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Decrease",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ke(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), yM = gM, bM = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Qc(), a = E(() => n.disabled?.value || n.readonly.value || t.disabled || n.isIncreaseDisabled.value), { primitiveElement: r, currentElement: o } = Ht(), { isPressed: s, onTrigger: i } = Fg({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleIncrease();
    }), (u, d) => (h(), x(l(X), A(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Increase",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ke(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), _M = bM, wM = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Ht(), r = Qc();
    function o(u) {
      r.disableWheelChange.value || u.target === ot() && (Math.abs(u.deltaY) <= Math.abs(u.deltaX) || (u.preventDefault(), u.deltaY > 0 ? r.invertWheelChange.value ? r.handleDecrease() : r.handleIncrease() : u.deltaY < 0 && (r.invertWheelChange.value ? r.handleIncrease() : r.handleDecrease())));
    }
    Ce(() => {
      r.onInputElement(a.value);
    });
    const s = I(r.textValue.value);
    ve(() => r.textValue.value, () => {
      s.value = r.textValue.value;
    }, {
      immediate: !0,
      deep: !0
    });
    function i() {
      requestAnimationFrame(() => {
        s.value = r.textValue.value;
      });
    }
    return (u, d) => (h(), x(l(X), A(t, {
      id: l(r).id.value,
      ref_key: "primitiveElement",
      ref: n,
      value: s.value,
      role: "spinbutton",
      type: "text",
      tabindex: "0",
      inputmode: l(r).inputMode.value,
      disabled: l(r).disabled.value ? "" : void 0,
      "data-disabled": l(r).disabled.value ? "" : void 0,
      readonly: l(r).readonly.value ? "" : void 0,
      "data-readonly": l(r).readonly.value ? "" : void 0,
      autocomplete: "off",
      autocorrect: "off",
      spellcheck: "false",
      "aria-roledescription": "Number field",
      "aria-valuenow": l(r).modelValue.value,
      "aria-valuemin": l(r).min.value,
      "aria-valuemax": l(r).max.value,
      onKeydown: [
        d[0] || (d[0] = Je(Ke((c) => l(r).handleIncrease(), ["prevent"]), ["up"])),
        d[1] || (d[1] = Je(Ke((c) => l(r).handleDecrease(), ["prevent"]), ["down"])),
        d[2] || (d[2] = Je(Ke((c) => l(r).handleIncrease(10), ["prevent"]), ["page-up"])),
        d[3] || (d[3] = Je(Ke((c) => l(r).handleDecrease(10), ["prevent"]), ["page-down"])),
        d[4] || (d[4] = Je(Ke((c) => l(r).handleMinMaxValue("min"), ["prevent"]), ["home"])),
        d[5] || (d[5] = Je(Ke((c) => l(r).handleMinMaxValue("max"), ["prevent"]), ["end"])),
        d[8] || (d[8] = Je((c) => l(r).applyInputValue(c.target?.value), ["enter"]))
      ],
      onWheel: o,
      onBeforeinput: d[6] || (d[6] = (c) => {
        const f = c.target;
        let p = f.value.slice(0, f.selectionStart ?? void 0) + (c.data ?? "") + f.value.slice(f.selectionEnd ?? void 0);
        l(r).validate(p) || c.preventDefault();
      }),
      onInput: d[7] || (d[7] = (c) => {
        const f = c.target;
        s.value = f.value;
      }),
      onChange: i,
      onBlur: d[9] || (d[9] = (c) => l(r).applyInputValue(c.target?.value))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "value",
      "inputmode",
      "disabled",
      "data-disabled",
      "readonly",
      "data-readonly",
      "aria-valuenow",
      "aria-valuemin",
      "aria-valuemax"
    ]));
  }
}), xM = wM, CM = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { "data-type": "ellipsis" }), {
      default: y(() => [_(n.$slots, "default", {}, () => [a[0] || (a[0] = Re(""))])]),
      _: 3
    }, 16));
  }
}), SM = CM;
const [to, $M] = Be("PaginationRoot");
var kM = /* @__PURE__ */ b({
  __name: "PaginationRoot",
  props: {
    page: {
      type: Number,
      required: !1
    },
    defaultPage: {
      type: Number,
      required: !1,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      required: !0
    },
    total: {
      type: Number,
      required: !1,
      default: 0
    },
    siblingCount: {
      type: Number,
      required: !1,
      default: 2
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    showEdges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, { siblingCount: r, disabled: o, showEdges: s } = Me(n);
    j();
    const i = Ve(n, "page", a, {
      defaultValue: n.defaultPage,
      passive: n.page === void 0
    }), u = E(() => Math.max(1, Math.ceil(n.total / (n.itemsPerPage || 1))));
    return $M({
      page: i,
      onPageChange(d) {
        i.value = d;
      },
      pageCount: u,
      siblingCount: r,
      disabled: o,
      showEdges: s
    }), (d, c) => (h(), x(l(X), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: y(() => [_(d.$slots, "default", {
        page: l(i),
        pageCount: u.value
      })]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), BM = kM, DM = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = to();
    j();
    const a = E(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "First Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("First page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), PM = DM, MM = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = to();
    j();
    const a = E(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Last Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).pageCount.value))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Last page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), qM = MM;
function _a(e, t) {
  const n = t - e + 1;
  return Array.from({ length: n }, (a, r) => r + e);
}
function EM(e) {
  return e.map((t) => typeof t == "number" ? {
    type: "page",
    value: t
  } : { type: "ellipsis" });
}
const Ls = "ellipsis";
function TM(e, t, n, a) {
  const o = t, s = Math.max(e - n, 1), i = Math.min(e + n, o);
  if (a) {
    const d = Math.min(2 * n + 5, t) - 2, c = s > 3 && Math.abs(o - d - 1 + 1) > 2 && Math.abs(s - 1) > 2, f = i < o - 2 && Math.abs(o - d) > 2 && Math.abs(o - i) > 2;
    if (!c && f)
      return [
        ..._a(1, d),
        Ls,
        o
      ];
    if (c && !f) {
      const v = _a(o - d + 1, o);
      return [
        1,
        Ls,
        ...v
      ];
    }
    if (c && f) {
      const v = _a(s, i);
      return [
        1,
        Ls,
        ...v,
        Ls,
        o
      ];
    }
    return _a(1, o);
  } else {
    const u = n * 2 + 1;
    return t < u ? _a(1, o) : e <= n + 1 ? _a(1, u) : t - e <= n ? _a(t - u + 1, o) : _a(s, i);
  }
}
var AM = /* @__PURE__ */ b({
  __name: "PaginationList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = to(), a = E(() => EM(TM(n.page.value, n.pageCount.value, n.siblingCount.value, n.showEdges.value)));
    return (r, o) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(r.$slots, "default", { items: a.value })]),
      _: 3
    }, 16));
  }
}), IM = AM, OM = /* @__PURE__ */ b({
  __name: "PaginationListItem",
  props: {
    value: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = to(), a = E(() => n.page.value === t.value), r = E(() => n.disabled.value);
    return (o, s) => (h(), x(l(X), A(t, {
      "data-type": "page",
      "aria-label": `Page ${o.value}`,
      "aria-current": a.value ? "page" : void 0,
      "data-selected": a.value ? "true" : void 0,
      disabled: r.value,
      type: o.as === "button" ? "button" : void 0,
      onClick: s[0] || (s[0] = (i) => !r.value && l(n).onPageChange(o.value))
    }), {
      default: y(() => [_(o.$slots, "default", {}, () => [Re(He(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-current",
      "data-selected",
      "disabled",
      "type"
    ]));
  }
}), RM = OM, VM = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = to(), a = E(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Next Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value + 1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Next page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), FM = VM, NM = /* @__PURE__ */ b({
  __name: "PaginationPrev",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = to(), a = E(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Previous Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value - 1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Prev page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), LM = NM;
const [zM, HM] = Be("PinInputRoot");
var UM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PinInputRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    mask: {
      type: Boolean,
      required: !1
    },
    otp: {
      type: Boolean,
      required: !1
    },
    type: {
      type: null,
      required: !1,
      default: "text"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, { mask: r, otp: o, placeholder: s, type: i, disabled: u, dir: d } = Me(n), { forwardRef: c } = j(), f = yt(d), p = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? [],
      passive: !0,
      deep: !0
    }), v = E(() => Array.isArray(p.value) ? [...p.value] : []), m = I(/* @__PURE__ */ new Set());
    function g(S) {
      m.value.add(S);
    }
    const w = E(() => n.type === "number"), C = E(() => v.value.filter(($) => !!$ || w.value && $ === 0).length === m.value.size);
    return ve(p, () => {
      C.value && a("complete", p.value);
    }, { deep: !0 }), HM({
      modelValue: p,
      currentModelValue: v,
      mask: r,
      otp: o,
      placeholder: s,
      type: i,
      dir: f,
      disabled: u,
      isCompleted: C,
      inputElements: m,
      onInputElementChange: g,
      isNumericMode: w
    }), (S, $) => (h(), x(l(X), A(S.$attrs, {
      ref: l(c),
      dir: l(f),
      "data-complete": C.value ? "" : void 0,
      "data-disabled": l(u) ? "" : void 0
    }), {
      default: y(() => [_(S.$slots, "default", { modelValue: l(p) }), N(Vn, {
        id: S.id,
        as: "input",
        feature: "focusable",
        tabindex: "-1",
        value: v.value.join(""),
        name: S.name ?? "",
        disabled: l(u),
        required: S.required,
        onFocus: $[0] || ($[0] = (B) => Array.from(m.value)?.[0]?.focus())
      }, null, 8, [
        "id",
        "value",
        "name",
        "disabled",
        "required"
      ])]),
      _: 3
    }, 16, [
      "dir",
      "data-complete",
      "data-disabled"
    ]));
  }
}), jM = UM, WM = /* @__PURE__ */ b({
  __name: "PinInputInput",
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = zM(), a = E(() => Array.from(n.inputElements.value)), r = E(() => n.currentModelValue.value[t.index]), o = E(() => t.disabled || n.disabled.value), s = E(() => n.otp.value), i = E(() => n.mask.value), { primitiveElement: u, currentElement: d } = Ht();
    function c(k) {
      const P = k.target;
      if ((k.data?.length ?? 0) > 1) {
        S(P.value);
        return;
      }
      if (n.isNumericMode.value && !/^\d*$/.test(P.value)) {
        P.value = P.value.replace(/\D/g, "");
        return;
      }
      P.value = k.data || P.value.slice(-1), B(t.index, P.value);
      const D = a.value[t.index + 1];
      D && D.focus();
    }
    function f() {
      const k = d.value;
      ke(() => {
        k && !k.value && (k.placeholder = n.placeholder.value);
      });
    }
    function p(k) {
      lr(k, ot(), void 0, {
        itemsArray: a.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: "horizontal",
        dir: n.dir.value
      });
    }
    function v(k) {
      if (k.preventDefault(), k.target.value) B(t.index, "");
      else {
        const q = a.value[t.index - 1];
        q && (q.focus(), B(t.index - 1, ""));
      }
    }
    function m(k) {
      k.key === "Delete" && (k.preventDefault(), B(t.index, ""));
    }
    function g(k) {
      const P = k.target;
      P.setSelectionRange(1, 1), P.value || (P.placeholder = ""), setTimeout(() => {
        P.value || (P.placeholder = "");
      });
    }
    function w(k) {
      f();
    }
    function C(k) {
      k.preventDefault();
      const P = k.clipboardData;
      if (!P) return;
      const D = P.getData("text");
      S(D);
    }
    function S(k) {
      const P = [...n.currentModelValue.value], D = k.length >= a.value.length ? 0 : t.index, q = Math.min(D + k.length, a.value.length);
      for (let T = D; T < q; T++) {
        const M = a.value[T], O = k[T - D];
        n.isNumericMode.value && !/^\d*$/.test(O) || (P[T] = O, M.focus());
      }
      n.modelValue.value = P, a.value[q]?.focus();
    }
    function $(k) {
      let P = k.length - 1;
      for (; P >= 0 && k[P] === ""; )
        k.pop(), P--;
      return k;
    }
    function B(k, P) {
      const D = [...n.currentModelValue.value];
      if (n.isNumericMode.value) {
        const q = +P;
        P === "" || isNaN(q) ? delete D[k] : D[k] = q;
      } else D[k] = P;
      n.modelValue.value = $(D);
    }
    return ve(r, () => {
      r.value || f();
    }), Ce(() => {
      n.onInputElementChange(d.value);
    }), Qe(() => {
      n.inputElements?.value.delete(d.value);
    }), (k, P) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: u,
      autocapitalize: "none",
      as: k.as,
      "as-child": k.asChild,
      autocomplete: s.value ? "one-time-code" : "false",
      type: i.value ? "password" : "text",
      inputmode: l(n).isNumericMode.value ? "numeric" : "text",
      pattern: l(n).isNumericMode.value ? "[0-9]*" : void 0,
      placeholder: l(n).placeholder.value,
      value: r.value,
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "data-complete": l(n).isCompleted.value ? "" : void 0,
      "aria-label": `pin input ${k.index + 1} of ${a.value.length}`,
      onInput: P[0] || (P[0] = (D) => c(D)),
      onKeydown: [
        Je(p, [
          "left",
          "right",
          "up",
          "down",
          "home",
          "end"
        ]),
        Je(v, ["backspace"]),
        Je(m, ["delete"])
      ],
      onFocus: g,
      onBlur: w,
      onPaste: C
    }, {
      default: y(() => [_(k.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "autocomplete",
      "type",
      "inputmode",
      "pattern",
      "placeholder",
      "value",
      "disabled",
      "data-disabled",
      "data-complete",
      "aria-label"
    ]));
  }
}), GM = WM;
const Uo = 100, [KM, YM] = Be("ProgressRoot"), Rl = (e) => typeof e == "number";
function XM(e, t) {
  return Mn(e) || Rl(e) && !Number.isNaN(e) && e <= t && e >= 0 ? e : (console.error(`Invalid prop \`value\` of value \`${e}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Uo} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function JM(e) {
  return Rl(e) && !Number.isNaN(e) && e > 0 ? e : (console.error(`Invalid prop \`max\` of value \`${e}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Uo}\`.`), Uo);
}
var ZM = /* @__PURE__ */ b({
  __name: "ProgressRoot",
  props: {
    modelValue: {
      type: [Number, null],
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: Uo
    },
    getValueLabel: {
      type: Function,
      required: !1,
      default: (e, t) => Rl(e) ? `${Math.round(e / t * Uo)}%` : void 0
    },
    getValueText: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:max"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "modelValue", a, { passive: n.modelValue === void 0 }), o = Ve(n, "max", a, { passive: n.max === void 0 });
    ve(() => r.value, async (i) => {
      const u = XM(i, n.max);
      u !== i && (await ke(), r.value = u);
    }, { immediate: !0 }), ve(() => n.max, (i) => {
      const u = JM(n.max);
      u !== i && (o.value = u);
    }, { immediate: !0 });
    const s = E(() => Mn(r.value) ? "indeterminate" : r.value === o.value ? "complete" : "loading");
    return YM({
      modelValue: r,
      max: o,
      progressState: s
    }), (i, u) => (h(), x(l(X), {
      "as-child": i.asChild,
      as: i.as,
      "aria-valuemax": l(o),
      "aria-valuemin": 0,
      "aria-valuenow": Rl(l(r)) ? l(r) : void 0,
      "aria-valuetext": i.getValueText?.(l(r), l(o)),
      "aria-label": i.getValueLabel(l(r), l(o)),
      role: "progressbar",
      "data-state": s.value,
      "data-value": l(r) ?? void 0,
      "data-max": l(o)
    }, {
      default: y(() => [_(i.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "aria-valuemax",
      "aria-valuenow",
      "aria-valuetext",
      "aria-label",
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), QM = ZM, eq = /* @__PURE__ */ b({
  __name: "ProgressIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = KM();
    return j(), (a, r) => (h(), x(l(X), A(t, {
      "data-state": l(n).progressState.value,
      "data-value": l(n).modelValue?.value ?? void 0,
      "data-max": l(n).max.value
    }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, [
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), tq = eq;
const nq = "radio.select";
function aq(e, t, n) {
  is(nq, n, {
    originalEvent: e,
    value: t
  });
}
var rq = /* @__PURE__ */ b({
  __name: "Radio",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:checked", "select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ve(n, "checked", a, { passive: n.checked === void 0 }), { value: o } = Me(n), { forwardRef: s, currentElement: i } = j(), u = Rn(i), d = E(() => n.id && i.value ? document.querySelector(`[for="${n.id}"]`)?.innerText ?? n.value : void 0);
    function c(f) {
      n.disabled || aq(f, n.value, (p) => {
        a("select", p), !p?.defaultPrevented && (r.value = !0, u.value && p.stopPropagation());
      });
    }
    return (f, p) => (h(), x(l(X), A(f.$attrs, {
      id: f.id,
      ref: l(s),
      role: "radio",
      type: f.as === "button" ? "button" : void 0,
      as: f.as,
      "aria-checked": l(r),
      "aria-label": d.value,
      "as-child": f.asChild,
      disabled: f.disabled ? "" : void 0,
      "data-state": l(r) ? "checked" : "unchecked",
      "data-disabled": f.disabled ? "" : void 0,
      value: l(o),
      required: f.required,
      name: f.name,
      onClick: Ke(c, ["stop"])
    }), {
      default: y(() => [_(f.$slots, "default", { checked: l(r) }), l(u) && f.name ? (h(), x(l(Vn), {
        key: 0,
        type: "radio",
        tabindex: "-1",
        value: l(o),
        checked: !!l(r),
        name: f.name,
        disabled: f.disabled,
        required: f.required
      }, null, 8, [
        "value",
        "checked",
        "name",
        "disabled",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "as",
      "aria-checked",
      "aria-label",
      "as-child",
      "disabled",
      "data-state",
      "data-disabled",
      "value",
      "required",
      "name"
    ]));
  }
}), oq = rq;
const [sq, lq] = Be("RadioGroupRoot");
var iq = /* @__PURE__ */ b({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { disabled: i, loop: u, orientation: d, name: c, required: f, dir: p } = Me(n), v = yt(p), m = Rn(o);
    return lq({
      modelValue: s,
      changeModelValue: (g) => {
        s.value = g;
      },
      disabled: i,
      loop: u,
      orientation: d,
      name: c?.value,
      required: f
    }), (g, w) => (h(), x(l(ys), {
      "as-child": "",
      orientation: l(d),
      dir: l(v),
      loop: l(u)
    }, {
      default: y(() => [N(l(X), {
        ref: l(r),
        role: "radiogroup",
        "data-disabled": l(i) ? "" : void 0,
        "as-child": g.asChild,
        as: g.as,
        "aria-orientation": l(d),
        "aria-required": l(f),
        dir: l(v)
      }, {
        default: y(() => [_(g.$slots, "default", { modelValue: l(s) }), l(m) && l(c) ? (h(), x(l(Vn), {
          key: 0,
          required: l(f),
          disabled: l(i),
          value: l(s),
          name: l(c)
        }, null, 8, [
          "required",
          "disabled",
          "value",
          "name"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 8, [
        "data-disabled",
        "as-child",
        "as",
        "aria-orientation",
        "aria-required",
        "dir"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), uq = iq;
const [dq, cq] = Be("RadioGroupItem");
var fq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = sq(), i = E(() => s.disabled.value || n.disabled), u = E(() => s.required.value || n.required), d = E(() => En(s.modelValue?.value, n.value));
    cq({
      disabled: i,
      checked: d
    });
    const c = I(!1), f = [
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ];
    zt("keydown", (v) => {
      f.includes(v.key) && (c.value = !0);
    }), zt("keyup", () => {
      c.value = !1;
    });
    function p() {
      setTimeout(() => {
        c.value && o.value?.click();
      }, 0);
    }
    return (v, m) => (h(), x(l(bs), {
      checked: d.value,
      disabled: i.value,
      "as-child": "",
      focusable: !i.value,
      active: d.value
    }, {
      default: y(() => [N(oq, A({
        ...v.$attrs,
        ...n
      }, {
        ref: l(r),
        checked: d.value,
        required: u.value,
        disabled: i.value,
        "onUpdate:checked": m[0] || (m[0] = (g) => l(s).changeModelValue(v.value)),
        onSelect: m[1] || (m[1] = (g) => a("select", g)),
        onKeydown: m[2] || (m[2] = Je(Ke(() => {
        }, ["prevent"]), ["enter"])),
        onFocus: p
      }), {
        default: y(() => [_(v.$slots, "default", {
          checked: d.value,
          required: u.value,
          disabled: i.value
        })]),
        _: 3
      }, 16, [
        "checked",
        "required",
        "disabled"
      ])]),
      _: 3
    }, 8, [
      "checked",
      "disabled",
      "focusable",
      "active"
    ]));
  }
}), pq = fq, vq = /* @__PURE__ */ b({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = dq();
    return (a, r) => (h(), x(l(St), { present: a.forceMount || l(n).checked.value }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "data-state": l(n).checked.value ? "checked" : "unchecked",
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), mq = vq;
const [Sn, hq] = Be("ScrollAreaRoot");
var gq = /* @__PURE__ */ b({
  __name: "ScrollAreaRoot",
  props: {
    type: {
      type: String,
      required: !1,
      default: "hover"
    },
    dir: {
      type: String,
      required: !1
    },
    scrollHideDelay: {
      type: Number,
      required: !1,
      default: 600
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = I(0), r = I(0), o = I(), s = I(), i = I(), u = I(), d = I(!1), c = I(!1), { type: f, dir: p, scrollHideDelay: v } = Me(n), m = yt(p);
    function g() {
      o.value?.scrollTo({ top: 0 });
    }
    function w() {
      o.value?.scrollTo({
        top: 0,
        left: 0
      });
    }
    t({
      viewport: o,
      scrollTop: g,
      scrollTopLeft: w
    });
    const { forwardRef: C, currentElement: S } = j();
    return hq({
      type: f,
      dir: m,
      scrollHideDelay: v,
      scrollArea: S,
      viewport: o,
      onViewportChange: ($) => {
        o.value = $ || void 0;
      },
      content: s,
      onContentChange: ($) => {
        s.value = $;
      },
      scrollbarX: i,
      scrollbarXEnabled: d,
      scrollbarY: u,
      scrollbarYEnabled: c,
      onScrollbarXChange: ($) => {
        i.value = $ || void 0;
      },
      onScrollbarYChange: ($) => {
        u.value = $ || void 0;
      },
      onScrollbarXEnabledChange: ($) => {
        d.value = $;
      },
      onScrollbarYEnabledChange: ($) => {
        c.value = $;
      },
      onCornerWidthChange: ($) => {
        a.value = $;
      },
      onCornerHeightChange: ($) => {
        r.value = $;
      }
    }), ($, B) => (h(), x(l(X), {
      ref: l(C),
      "as-child": n.asChild,
      as: $.as,
      dir: l(m),
      style: dt({
        position: "relative",
        "--reka-scroll-area-corner-width": `${a.value}px`,
        "--reka-scroll-area-corner-height": `${r.value}px`
      })
    }, {
      default: y(() => [_($.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "dir",
      "style"
    ]));
  }
}), yq = gq, bq = /* @__PURE__ */ b({
  __name: "ScrollAreaCornerImpl",
  setup(e) {
    const t = Sn(), n = I(0), a = I(0), r = E(() => !!n.value && !!a.value);
    function o() {
      const i = t.scrollbarX.value?.offsetHeight || 0;
      t.onCornerHeightChange(i), a.value = i;
    }
    function s() {
      const i = t.scrollbarY.value?.offsetWidth || 0;
      t.onCornerWidthChange(i), n.value = i;
    }
    return Tn(t.scrollbarX.value, o), Tn(t.scrollbarY.value, s), ve(() => t.scrollbarX.value, o), ve(() => t.scrollbarY.value, s), (i, u) => r.value ? (h(), x(l(X), A({
      key: 0,
      style: {
        width: `${n.value}px`,
        height: `${a.value}px`,
        position: "absolute",
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: 0
      }
    }, i.$parent?.$props), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, ["style"])) : Ee("v-if", !0);
  }
}), _q = bq, wq = /* @__PURE__ */ b({
  __name: "ScrollAreaCorner",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = Sn(), r = E(() => !!a.scrollbarX.value && !!a.scrollbarY.value), o = E(() => a.type.value !== "scroll" && r.value);
    return (s, i) => o.value ? (h(), x(_q, A({ key: 0 }, t, { ref: l(n) }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), xq = wq;
function Ng(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function Oi(e) {
  const t = Lg(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, a = (e.scrollbar.size - n) * t;
  return Math.max(a, 18);
}
function Lg(e, t) {
  const n = e / t;
  return Number.isNaN(n) ? 0 : n;
}
function Cq(e, t = () => {
}) {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, a = 0;
  return (function r() {
    const o = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, s = n.left !== o.left, i = n.top !== o.top;
    (s || i) && t(), n = o, a = window.requestAnimationFrame(r);
  })(), () => window.cancelAnimationFrame(a);
}
function ov(e, t, n = "ltr") {
  const a = Oi(t), r = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - r, s = t.content - t.viewport, i = o - a, u = n === "ltr" ? [0, s] : [s * -1, 0], d = Or(e, u[0], u[1]);
  return Ng([0, s], [0, i])(d);
}
function zs(e) {
  return e ? Number.parseInt(e, 10) : 0;
}
function Sq(e, t, n, a = "ltr") {
  const r = Oi(n), o = r / 2, s = t || o, i = r - s, u = n.scrollbar.paddingStart + s, d = n.scrollbar.size - n.scrollbar.paddingEnd - i, c = n.content - n.viewport, f = a === "ltr" ? [0, c] : [c * -1, 0];
  return Ng([u, d], f)(e);
}
function sv(e, t) {
  return e > 0 && e < t;
}
var $q = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarX",
  setup(e) {
    const t = Sn(), n = Vi(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarXChange(r.value);
    });
    const o = E(() => n.sizes.value);
    return (s, i) => (h(), x(Hg, {
      ref: l(a),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: dt({
        bottom: 0,
        left: l(t).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
        right: l(t).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
        "--reka-scroll-area-thumb-width": o.value ? `${l(Oi)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.x))
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), kq = $q, Bq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarY",
  setup(e) {
    const t = Sn(), n = Vi(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarYChange(r.value);
    });
    const o = E(() => n.sizes.value);
    return (s, i) => (h(), x(Hg, {
      ref: l(a),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: dt({
        top: 0,
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--reka-scroll-area-corner-height)",
        "--reka-scroll-area-thumb-height": o.value ? `${l(Oi)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.y))
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), Dq = Bq, Pq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarAuto",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Sn(), n = Ri(), { forwardRef: a } = j(), r = I(!1), o = dc(() => {
      if (t.viewport.value) {
        const s = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        r.value = n.isHorizontal.value ? s : i;
      }
    }, 10);
    return Ce(() => o()), Tn(t.viewport, o), Tn(t.content, o), (s, i) => (h(), x(l(St), { present: s.forceMount || r.value }, {
      default: y(() => [N(ef, A(s.$attrs, {
        ref: l(a),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), zg = Pq, Mq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Sn(), { forwardRef: n } = j();
    let a;
    const r = I(!1);
    function o() {
      window.clearTimeout(a), r.value = !0;
    }
    function s() {
      a = window.setTimeout(() => {
        r.value = !1;
      }, t.scrollHideDelay.value);
    }
    return Ce(() => {
      const i = t.scrollArea.value;
      i && (i.addEventListener("pointerenter", o), i.addEventListener("pointerleave", s));
    }), Qe(() => {
      const i = t.scrollArea.value;
      i && (window.clearTimeout(a), i.removeEventListener("pointerenter", o), i.removeEventListener("pointerleave", s));
    }), (i, u) => (h(), x(l(St), { present: i.forceMount || r.value }, {
      default: y(() => [N(zg, A(i.$attrs, {
        ref: l(n),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), qq = Mq, Eq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarScroll",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Sn(), n = Ri(), { forwardRef: a } = j(), { state: r, dispatch: o } = Hh("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }), s = E(() => r.value !== "hidden");
    Ie((u) => {
      if (r.value === "idle") {
        const d = window.setTimeout(() => o("HIDE"), t.scrollHideDelay.value);
        u(() => {
          window.clearTimeout(d);
        });
      }
    });
    const i = dc(() => o("SCROLL_END"), 100);
    return Ie((u) => {
      const d = t.viewport.value, c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (d) {
        let f = d[c];
        const p = () => {
          const v = d[c];
          f !== v && (o("SCROLL"), i()), f = v;
        };
        d.addEventListener("scroll", p), u(() => {
          d.removeEventListener("scroll", p);
        });
      }
    }), (u, d) => (h(), x(l(St), { present: u.forceMount || s.value }, {
      default: y(() => [N(ef, A(u.$attrs, {
        ref: l(a),
        "data-state": s.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), Tq = Eq;
const [Ri, Aq] = Be("ScrollAreaScrollbar");
var Iq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = Sn(), r = E(() => t.orientation === "horizontal");
    ve(r, () => {
      r.value ? a.onScrollbarXEnabledChange(!0) : a.onScrollbarYEnabledChange(!0);
    }, { immediate: !0 }), Qe(() => {
      a.onScrollbarXEnabledChange(!1), a.onScrollbarYEnabledChange(!1);
    });
    const { orientation: o, forceMount: s, asChild: i, as: u } = Me(t);
    return Aq({
      orientation: o,
      forceMount: s,
      isHorizontal: r,
      as: u,
      asChild: i
    }), (d, c) => l(a).type.value === "hover" ? (h(), x(qq, A({ key: 0 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "scroll" ? (h(), x(Tq, A({ key: 1 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "auto" ? (h(), x(zg, A({ key: 2 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "always" ? (h(), x(ef, A({ key: 3 }, d.$attrs, {
      ref: l(n),
      "data-state": "visible"
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), Oq = Iq;
const [Vi, Rq] = Be("ScrollAreaScrollbarVisible");
var Vq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarVisible",
  setup(e) {
    const t = Sn(), n = Ri(), { forwardRef: a } = j(), r = I({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    }), o = E(() => {
      const C = Lg(r.value.viewport, r.value.content);
      return C > 0 && C < 1;
    }), s = I(), i = I(0);
    function u(C, S) {
      if (v.value) {
        const $ = t.viewport.value.scrollLeft + C.deltaY;
        t.viewport.value.scrollLeft = $, sv($, S) && C.preventDefault();
      } else {
        const $ = t.viewport.value.scrollTop + C.deltaY;
        t.viewport.value.scrollTop = $, sv($, S) && C.preventDefault();
      }
    }
    function d(C, S) {
      v.value ? i.value = S.x : i.value = S.y;
    }
    function c(C) {
      i.value = 0;
    }
    function f(C) {
      r.value = C;
    }
    function p(C, S) {
      return Sq(C, i.value, r.value, S);
    }
    const v = E(() => n.isHorizontal.value);
    function m(C) {
      v.value ? t.viewport.value.scrollLeft = p(C, t.dir.value) : t.viewport.value.scrollTop = p(C);
    }
    function g() {
      if (v.value) {
        if (t.viewport.value && s.value) {
          const C = t.viewport.value.scrollLeft, S = ov(C, r.value, t.dir.value);
          s.value.style.transform = `translate3d(${S}px, 0, 0)`;
        }
      } else if (t.viewport.value && s.value) {
        const C = t.viewport.value.scrollTop, S = ov(C, r.value);
        s.value.style.transform = `translate3d(0, ${S}px, 0)`;
      }
    }
    function w(C) {
      s.value = C;
    }
    return Rq({
      sizes: r,
      hasThumb: o,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: c,
      handleSizeChange: f,
      onThumbPositionChange: g,
      onThumbChange: w,
      onDragScroll: m
    }), (C, S) => v.value ? (h(), x(kq, A({ key: 0 }, C.$attrs, { ref: l(a) }), {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 16)) : (h(), x(Dq, A({ key: 1 }, C.$attrs, { ref: l(a) }), {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ef = Vq, Fq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarImpl",
  props: { isHorizontal: {
    type: Boolean,
    required: !0
  } },
  emits: [
    "onDragScroll",
    "onWheelScroll",
    "onThumbPointerDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Sn(), o = Vi(), s = Ri(), { forwardRef: i, currentElement: u } = j(), d = I(""), c = I();
    function f(C) {
      if (c.value) {
        const S = C.clientX - c.value?.left, $ = C.clientY - c.value?.top;
        a("onDragScroll", {
          x: S,
          y: $
        });
      }
    }
    function p(C) {
      C.button === 0 && (C.target.setPointerCapture(C.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", r.viewport && (r.viewport.value.style.scrollBehavior = "auto"), f(C));
    }
    function v(C) {
      f(C);
    }
    function m(C) {
      const S = C.target;
      S.hasPointerCapture(C.pointerId) && S.releasePointerCapture(C.pointerId), document.body.style.webkitUserSelect = d.value, r.viewport && (r.viewport.value.style.scrollBehavior = ""), c.value = void 0;
    }
    function g(C) {
      const S = C.target, $ = u.value?.contains(S), B = o.sizes.value.content - o.sizes.value.viewport;
      $ && o.handleWheelScroll(C, B);
    }
    Ce(() => {
      document.addEventListener("wheel", g, { passive: !1 });
    }), Qe(() => {
      document.removeEventListener("wheel", g);
    });
    function w() {
      u.value && (n.isHorizontal ? o.handleSizeChange({
        content: r.viewport.value?.scrollWidth ?? 0,
        viewport: r.viewport.value?.offsetWidth ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: zs(getComputedStyle(u.value).paddingLeft),
          paddingEnd: zs(getComputedStyle(u.value).paddingRight)
        }
      }) : o.handleSizeChange({
        content: r.viewport.value?.scrollHeight ?? 0,
        viewport: r.viewport.value?.offsetHeight ?? 0,
        scrollbar: {
          size: u.value?.clientHeight ?? 0,
          paddingStart: zs(getComputedStyle(u.value).paddingTop),
          paddingEnd: zs(getComputedStyle(u.value).paddingBottom)
        }
      }), o.onThumbPositionChange());
    }
    return Tn(u, w), Tn(r.content, w), (C, S) => (h(), x(l(X), {
      ref: l(i),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: l(s).as.value,
      "as-child": l(s).asChild.value,
      onPointerdown: p,
      onPointermove: v,
      onPointerup: m
    }, {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Hg = Fq, Nq = /* @__PURE__ */ b({
  __name: "ScrollAreaThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Sn(), a = Vi();
    function r(p) {
      const m = p.target.getBoundingClientRect(), g = p.clientX - m.left, w = p.clientY - m.top;
      a.handleThumbDown(p, {
        x: g,
        y: w
      });
    }
    function o(p) {
      a.handleThumbUp(p);
    }
    const { forwardRef: s, currentElement: i } = j(), u = I(), d = E(() => n.viewport.value);
    function c() {
      if (!u.value) {
        const p = Cq(d.value, a.onThumbPositionChange);
        u.value = p, a.onThumbPositionChange();
      }
    }
    const f = E(() => a.sizes.value);
    return ew(f, () => {
      a.onThumbChange(i.value), d.value && (a.onThumbPositionChange(), d.value.addEventListener("scroll", c));
    }), Qe(() => {
      d.value.removeEventListener("scroll", c), n.viewport.value?.removeEventListener("scroll", c);
    }), (p, v) => (h(), x(l(X), {
      ref: l(s),
      "data-state": l(a).hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--reka-scroll-area-thumb-width)",
        height: "var(--reka-scroll-area-thumb-height)"
      },
      "as-child": t.asChild,
      as: p.as,
      onPointerdown: r,
      onPointerup: o
    }, {
      default: y(() => [_(p.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "as-child",
      "as"
    ]));
  }
}), Lq = Nq, zq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, { nonce: a } = Me(n), r = qi(a), o = Sn(), s = I();
    Ce(() => {
      o.onViewportChange(s.value), o.onContentChange(u.value);
    }), t({ viewportElement: s });
    const { forwardRef: i, currentElement: u } = j();
    return (d, c) => (h(), G(Ye, null, [xe("div", A({
      ref_key: "viewportElement",
      ref: s,
      "data-reka-scroll-area-viewport": "",
      style: {
        overflowX: l(o).scrollbarXEnabled.value ? "scroll" : "hidden",
        overflowY: l(o).scrollbarYEnabled.value ? "scroll" : "hidden"
      }
    }, d.$attrs, { tabindex: 0 }), [N(l(X), {
      ref: l(i),
      style: dt({ minWidth: l(o).scrollbarXEnabled.value ? "fit-content" : void 0 }),
      "as-child": n.asChild,
      as: d.as
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "style",
      "as-child",
      "as"
    ])], 16), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: y(() => c[0] || (c[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), Hq = zq;
const Uq = [
  " ",
  "Enter",
  "ArrowUp",
  "ArrowDown"
], jq = [" ", "Enter"], $n = 10;
function jo(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => kd(a, t, n)) : kd(e, t, n);
}
function kd(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : En(e, t);
}
function Wq(e) {
  return e == null || e === "" || Array.isArray(e) && e.length === 0;
}
const Gq = {
  key: 0,
  value: ""
}, [La, Ug] = Be("SelectRoot");
var Kq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1,
      default: void 0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    autocomplete: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { required: r, disabled: o, multiple: s, dir: i } = Me(n), u = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? (s.value ? [] : void 0),
      passive: n.modelValue === void 0,
      deep: !0
    }), d = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), c = I(), f = I(), p = I({
      x: 0,
      y: 0
    }), v = E(() => s.value && Array.isArray(u.value) ? u.value?.length === 0 : Mn(u.value));
    st({ isProvider: !0 });
    const m = yt(i), g = Rn(c), w = I(/* @__PURE__ */ new Set()), C = E(() => Array.from(w.value).map((B) => B.value).join(";"));
    function S(B) {
      if (s.value) {
        const k = Array.isArray(u.value) ? [...u.value] : [], P = k.findIndex((D) => kd(D, B, n.by));
        P === -1 ? k.push(B) : k.splice(P, 1), u.value = [...k];
      } else u.value = B;
    }
    function $(B) {
      return Array.from(w.value).find((k) => jo(B, k.value, n.by));
    }
    return Ug({
      triggerElement: c,
      onTriggerChange: (B) => {
        c.value = B;
      },
      valueElement: f,
      onValueElementChange: (B) => {
        f.value = B;
      },
      contentId: "",
      modelValue: u,
      onValueChange: S,
      by: n.by,
      open: d,
      multiple: s,
      required: r,
      onOpenChange: (B) => {
        d.value = B;
      },
      dir: m,
      triggerPointerDownPosRef: p,
      disabled: o,
      isEmptyModelValue: v,
      optionsSet: w,
      onOptionAdd: (B) => {
        const k = $(B.value);
        k && w.value.delete(k), w.value.add(B);
      },
      onOptionRemove: (B) => {
        const k = $(B.value);
        k && w.value.delete(k);
      }
    }), (B, k) => (h(), x(l(ir), null, {
      default: y(() => [_(B.$slots, "default", {
        modelValue: l(u),
        open: l(d)
      }), l(g) ? (h(), x(Jq, {
        key: C.value,
        "aria-hidden": "true",
        tabindex: "-1",
        multiple: l(s),
        required: l(r),
        name: B.name,
        autocomplete: B.autocomplete,
        disabled: l(o),
        value: l(u)
      }, {
        default: y(() => [l(Mn)(l(u)) ? (h(), G("option", Gq)) : Ee("v-if", !0), (h(!0), G(Ye, null, Lt(Array.from(w.value), (P) => (h(), G("option", A({ key: P.value ?? "" }, { ref_for: !0 }, P), null, 16))), 128))]),
        _: 1
      }, 8, [
        "multiple",
        "required",
        "name",
        "autocomplete",
        "disabled",
        "value"
      ])) : Ee("v-if", !0)]),
      _: 3
    }));
  }
}), Yq = Kq, Xq = /* @__PURE__ */ b({
  __name: "BubbleSelect",
  props: {
    autocomplete: {
      type: String,
      required: !1
    },
    autofocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    form: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    size: {
      type: Number,
      required: !1
    },
    value: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = I(), a = La();
    ve(() => t.value, (o, s) => {
      const i = window.HTMLSelectElement.prototype, d = Object.getOwnPropertyDescriptor(i, "value").set;
      if (o !== s && d && n.value) {
        const c = new Event("change", { bubbles: !0 });
        d.call(n.value, o), n.value.dispatchEvent(c);
      }
    });
    function r(o) {
      a.onValueChange(o.target.value);
    }
    return (o, s) => (h(), x(l($i), { "as-child": "" }, {
      default: y(() => [xe("select", A({
        ref_key: "selectElement",
        ref: n
      }, t, { onInput: r }), [_(o.$slots, "default")], 16)]),
      _: 3
    }));
  }
}), Jq = Xq, Zq = /* @__PURE__ */ b({
  __name: "SelectPopperPosition",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: $n
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(Zr), A(l(n), { style: {
      boxSizing: "border-box",
      "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-select-content-available-width": "var(--reka-popper-available-width)",
      "--reka-select-content-available-height": "var(--reka-popper-available-height)",
      "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Qq = Zq;
const e2 = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [pr, jg] = Be("SelectContent");
var t2 = /* @__PURE__ */ b({
  __name: "SelectContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "item-aligned"
    },
    bodyLock: {
      type: Boolean,
      required: !1,
      default: !0
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = La();
    xc(), fs(n.bodyLock);
    const { CollectionSlot: o, getItems: s } = st(), i = I();
    vs(i);
    const { search: u, handleTypeaheadSearch: d } = gi(), c = I(), f = I(), p = I(), v = I(!1), m = I(!1), g = I(!1);
    function w() {
      f.value && i.value && gd([f.value, i.value]);
    }
    ve(v, () => {
      w();
    });
    const { onOpenChange: C, triggerPointerDownPosRef: S } = r;
    Ie((P) => {
      if (!i.value) return;
      let D = {
        x: 0,
        y: 0
      };
      const q = (M) => {
        D = {
          x: Math.abs(Math.round(M.pageX) - (S.value?.x ?? 0)),
          y: Math.abs(Math.round(M.pageY) - (S.value?.y ?? 0))
        };
      }, T = (M) => {
        M.pointerType !== "touch" && (D.x <= 10 && D.y <= 10 ? M.preventDefault() : i.value?.contains(M.target) || C(!1), document.removeEventListener("pointermove", q), S.value = null);
      };
      S.value !== null && (document.addEventListener("pointermove", q), document.addEventListener("pointerup", T, {
        capture: !0,
        once: !0
      })), P(() => {
        document.removeEventListener("pointermove", q), document.removeEventListener("pointerup", T, { capture: !0 });
      });
    });
    function $(P) {
      const D = P.ctrlKey || P.altKey || P.metaKey;
      if (P.key === "Tab" && P.preventDefault(), !D && P.key.length === 1 && d(P.key, s()), [
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End"
      ].includes(P.key)) {
        let T = [...s().map((M) => M.ref)];
        if (["ArrowUp", "End"].includes(P.key) && (T = T.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(P.key)) {
          const M = P.target, O = T.indexOf(M);
          T = T.slice(O + 1);
        }
        setTimeout(() => gd(T)), P.preventDefault();
      }
    }
    const B = E(() => n.position === "popper" ? n : {}), k = he(B.value);
    return jg({
      content: i,
      viewport: c,
      onViewportChange: (P) => {
        c.value = P;
      },
      itemRefCallback: (P, D, q) => {
        const T = !m.value && !q, M = jo(r.modelValue.value, D, r.by);
        if (r.multiple.value) {
          if (g.value) return;
          (M || T) && (f.value = P, M && (g.value = !0));
        } else (M || T) && (f.value = P);
        T && (m.value = !0);
      },
      selectedItem: f,
      selectedItemText: p,
      onItemLeave: () => {
        i.value?.focus();
      },
      itemTextRefCallback: (P, D, q) => {
        const T = !m.value && !q;
        (jo(r.modelValue.value, D, r.by) || T) && (p.value = P);
      },
      focusSelectedItem: w,
      position: n.position,
      isPositioned: v,
      searchRef: u
    }), (P, D) => (h(), x(l(o), null, {
      default: y(() => [N(l(_i), {
        "as-child": "",
        onMountAutoFocus: D[6] || (D[6] = Ke(() => {
        }, ["prevent"])),
        onUnmountAutoFocus: D[7] || (D[7] = (q) => {
          a("closeAutoFocus", q), !q.defaultPrevented && (l(r).triggerElement.value?.focus({ preventScroll: !0 }), q.preventDefault());
        })
      }, {
        default: y(() => [N(l(Fa), {
          "as-child": "",
          "disable-outside-pointer-events": P.disableOutsidePointerEvents,
          onFocusOutside: D[2] || (D[2] = Ke(() => {
          }, ["prevent"])),
          onDismiss: D[3] || (D[3] = (q) => l(r).onOpenChange(!1)),
          onEscapeKeyDown: D[4] || (D[4] = (q) => a("escapeKeyDown", q)),
          onPointerDownOutside: D[5] || (D[5] = (q) => a("pointerDownOutside", q))
        }, {
          default: y(() => [(h(), x(Tt(P.position === "popper" ? Qq : o2), A({
            ...P.$attrs,
            ...l(k)
          }, {
            id: l(r).contentId,
            ref: (q) => {
              const T = l(Gt)(q);
              T?.hasAttribute("data-reka-popper-content-wrapper") ? i.value = T.firstElementChild : i.value = T;
            },
            role: "listbox",
            "data-state": l(r).open.value ? "open" : "closed",
            dir: l(r).dir.value,
            style: {
              display: "flex",
              flexDirection: "column",
              outline: "none"
            },
            onContextmenu: D[0] || (D[0] = Ke(() => {
            }, ["prevent"])),
            onPlaced: D[1] || (D[1] = (q) => v.value = !0),
            onKeydown: $
          }), {
            default: y(() => [_(P.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "data-state",
            "dir",
            "onKeydown"
          ]))]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      })]),
      _: 3
    }));
  }
}), n2 = t2;
const [tf, a2] = Be("SelectItemAlignedPosition");
var r2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st(), o = La(), s = pr(), i = I(!1), u = I(!0), d = I(), { forwardRef: c, currentElement: f } = j(), { viewport: p, selectedItem: v, selectedItemText: m, focusSelectedItem: g } = s;
    function w() {
      if (o.triggerElement.value && o.valueElement.value && d.value && f.value && p?.value && v?.value && m?.value) {
        const $ = o.triggerElement.value.getBoundingClientRect(), B = f.value.getBoundingClientRect(), k = o.valueElement.value.getBoundingClientRect(), P = m.value.getBoundingClientRect();
        if (o.dir.value !== "rtl") {
          const R = P.left - B.left, te = k.left - R, z = $.left - te, ae = $.width + z, ie = Math.max(ae, B.width), L = window.innerWidth - $n, be = Or(te, $n, Math.max($n, L - ie));
          d.value.style.minWidth = `${ae}px`, d.value.style.left = `${be}px`;
        } else {
          const R = B.right - P.right, te = window.innerWidth - k.right - R, z = window.innerWidth - $.right - te, ae = $.width + z, ie = Math.max(ae, B.width), L = window.innerWidth - $n, be = Or(te, $n, Math.max($n, L - ie));
          d.value.style.minWidth = `${ae}px`, d.value.style.right = `${be}px`;
        }
        const D = r().map((R) => R.ref), q = window.innerHeight - $n * 2, T = p.value.scrollHeight, M = window.getComputedStyle(f.value), O = Number.parseInt(M.borderTopWidth, 10), F = Number.parseInt(M.paddingTop, 10), J = Number.parseInt(M.borderBottomWidth, 10), ne = Number.parseInt(M.paddingBottom, 10), Q = O + F + T + ne + J, W = Math.min(v.value.offsetHeight * 5, Q), H = window.getComputedStyle(p.value), U = Number.parseInt(H.paddingTop, 10), se = Number.parseInt(H.paddingBottom, 10), ee = $.top + $.height / 2 - $n, de = q - ee, pe = v.value.offsetHeight / 2, _e = v.value.offsetTop + pe, ge = O + F + _e, Te = Q - ge;
        if (ge <= ee) {
          const R = v.value === D[D.length - 1];
          d.value.style.bottom = "0px";
          const te = f.value.clientHeight - p.value.offsetTop - p.value.offsetHeight, z = Math.max(de, pe + (R ? se : 0) + te + J), ae = ge + z;
          d.value.style.height = `${ae}px`;
        } else {
          const R = v.value === D[0];
          d.value.style.top = "0px";
          const z = Math.max(ee, O + p.value.offsetTop + (R ? U : 0) + pe) + Te;
          d.value.style.height = `${z}px`, p.value.scrollTop = ge - ee + p.value.offsetTop;
        }
        d.value.style.margin = `${$n}px 0`, d.value.style.minHeight = `${W}px`, d.value.style.maxHeight = `${q}px`, a("placed"), requestAnimationFrame(() => i.value = !0);
      }
    }
    const C = I("");
    Ce(async () => {
      await ke(), w(), f.value && (C.value = window.getComputedStyle(f.value).zIndex);
    });
    function S($) {
      $ && u.value === !0 && (w(), g?.(), u.value = !1);
    }
    return Tn(o.triggerElement, () => {
      w();
    }), a2({
      contentWrapper: d,
      shouldExpandOnScrollRef: i,
      onScrollButtonChange: S
    }), ($, B) => (h(), G("div", {
      ref_key: "contentWrapperElement",
      ref: d,
      style: dt({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: C.value
      })
    }, [N(l(X), A({
      ref: l(c),
      style: {
        boxSizing: "border-box",
        maxHeight: "100%"
      }
    }, {
      ...$.$attrs,
      ...n
    }), {
      default: y(() => [_($.$slots, "default")]),
      _: 3
    }, 16)], 4));
  }
}), o2 = r2, s2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectProvider",
  props: { context: {
    type: Object,
    required: !0
  } },
  setup(e) {
    return Ug(e.context), jg(e2), (n, a) => _(n.$slots, "default");
  }
}), l2 = s2;
const i2 = { key: 1 };
var u2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, r = me(n, t), o = La(), s = I();
    Ce(() => {
      s.value = new DocumentFragment();
    });
    const i = I(), u = E(() => n.forceMount || o.open.value), d = I(u.value);
    return ve(u, () => {
      setTimeout(() => d.value = u.value);
    }), (c, f) => u.value || d.value || i.value?.present ? (h(), x(l(St), {
      key: 0,
      ref_key: "presenceRef",
      ref: i,
      present: u.value
    }, {
      default: y(() => [N(n2, oe(le({
        ...l(r),
        ...c.$attrs
      })), {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"])) : s.value ? (h(), G("div", i2, [(h(), x(vi, { to: s.value }, [N(l2, { context: l(o) }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["context"])], 8, ["to"]))])) : Ee("v-if", !0);
  }
}), d2 = u2;
const [c2, f2] = Be("SelectGroup");
var p2 = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-select-group");
    return f2({ id: n }), (a, r) => (h(), x(l(X), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), v2 = p2, m2 = /* @__PURE__ */ b({
  __name: "SelectIcon",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), x(l(X), {
      "aria-hidden": "true",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: y(() => [_(t.$slots, "default", {}, () => [n[0] || (n[0] = Re(""))])]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), h2 = m2;
const [Wg, g2] = Be("SelectItem");
var y2 = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = Me(n), o = La(), s = pr(), { forwardRef: i, currentElement: u } = j(), { CollectionItem: d } = st(), c = E(() => jo(o.modelValue?.value, n.value, o.by)), f = I(!1), p = I(n.textValue ?? ""), v = Ge(void 0, "reka-select-item-text"), m = "select.select";
    async function g(B) {
      if (B.defaultPrevented) return;
      const k = {
        originalEvent: B,
        value: n.value
      };
      is(m, w, k);
    }
    async function w(B) {
      await ke(), a("select", B), !B.defaultPrevented && (r.value || (o.onValueChange(n.value), o.multiple.value || o.onOpenChange(!1)));
    }
    async function C(B) {
      await ke(), !B.defaultPrevented && (r.value ? s.onItemLeave?.() : B.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function S(B) {
      await ke(), !B.defaultPrevented && B.currentTarget === ot() && s.onItemLeave?.();
    }
    async function $(B) {
      await ke(), !(B.defaultPrevented || s.searchRef?.value !== "" && B.key === " ") && (jq.includes(B.key) && g(B), B.key === " " && B.preventDefault());
    }
    if (n.value === "") throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    return Ce(() => {
      u.value && s.itemRefCallback(u.value, n.value, n.disabled);
    }), g2({
      value: n.value,
      disabled: r,
      textId: v,
      isSelected: c,
      onItemTextChange: (B) => {
        p.value = ((p.value || B?.textContent) ?? "").trim();
      }
    }), (B, k) => (h(), x(l(d), { value: { textValue: p.value } }, {
      default: y(() => [N(l(X), {
        ref: l(i),
        role: "option",
        "aria-labelledby": l(v),
        "data-highlighted": f.value ? "" : void 0,
        "aria-selected": c.value,
        "data-state": c.value ? "checked" : "unchecked",
        "aria-disabled": l(r) || void 0,
        "data-disabled": l(r) ? "" : void 0,
        tabindex: l(r) ? void 0 : -1,
        as: B.as,
        "as-child": B.asChild,
        onFocus: k[0] || (k[0] = (P) => f.value = !0),
        onBlur: k[1] || (k[1] = (P) => f.value = !1),
        onPointerup: g,
        onPointerdown: k[2] || (k[2] = (P) => {
          P.currentTarget.focus({ preventScroll: !0 });
        }),
        onTouchend: k[3] || (k[3] = Ke(() => {
        }, ["prevent", "stop"])),
        onPointermove: C,
        onPointerleave: S,
        onKeydown: $
      }, {
        default: y(() => [_(B.$slots, "default")]),
        _: 3
      }, 8, [
        "aria-labelledby",
        "data-highlighted",
        "aria-selected",
        "data-state",
        "aria-disabled",
        "data-disabled",
        "tabindex",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), b2 = y2, _2 = /* @__PURE__ */ b({
  __name: "SelectItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Wg();
    return (a, r) => l(n).isSelected.value ? (h(), x(l(X), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), w2 = _2, x2 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = La(), a = pr(), r = Wg(), { forwardRef: o, currentElement: s } = j(), i = E(() => ({
      value: r.value,
      disabled: r.disabled.value,
      textContent: s.value?.textContent ?? r.value?.toString() ?? ""
    }));
    return Ce(() => {
      s.value && (r.onItemTextChange(s.value), a.itemTextRefCallback(s.value, r.value, r.disabled.value), n.onOptionAdd(i.value));
    }), Qe(() => {
      n.onOptionRemove(i.value);
    }), (u, d) => (h(), x(l(X), A({
      id: l(r).textId,
      ref: l(o)
    }, {
      ...t,
      ...u.$attrs
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Gg = x2, C2 = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = c2({ id: "" });
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).id }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), S2 = C2, $2 = /* @__PURE__ */ b({
  __name: "SelectPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), k2 = $2, B2 = /* @__PURE__ */ b({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(e, { emit: t }) {
    const n = t, { getItems: a } = st(), r = pr(), o = I(null);
    function s() {
      o.value !== null && (window.clearInterval(o.value), o.value = null);
    }
    Ie(() => {
      a().map((c) => c.ref).find((c) => c === ot())?.scrollIntoView({ block: "nearest" });
    });
    function i() {
      o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    function u() {
      r.onItemLeave?.(), o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    return sr(() => s()), (d, c) => (h(), x(l(X), A({
      "aria-hidden": "true",
      style: { flexShrink: 0 }
    }, d.$parent?.$props, {
      onPointerdown: i,
      onPointermove: u,
      onPointerleave: c[0] || (c[0] = () => {
        s();
      })
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Kg = B2, D2 = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = pr(), n = t.position === "item-aligned" ? tf() : void 0, { forwardRef: a, currentElement: r } = j(), o = I(!1);
    return Ie((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          const d = i.scrollHeight - i.clientHeight;
          o.value = Math.ceil(i.scrollTop) < d;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), ve(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), x(Kg, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : Ee("v-if", !0);
  }
}), P2 = D2, M2 = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = pr(), n = t.position === "item-aligned" ? tf() : void 0, { forwardRef: a, currentElement: r } = j(), o = I(!1);
    return Ie((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          o.value = i.scrollTop > 0;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), ve(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), x(Kg, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : Ee("v-if", !0);
  }
}), q2 = M2, E2 = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({ "aria-hidden": "true" }, t), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), T2 = E2, A2 = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = La(), { forwardRef: a, currentElement: r } = j(), o = E(() => n.disabled?.value || t.disabled);
    n.contentId ||= Ge(void 0, "reka-select-content"), Ce(() => {
      n.onTriggerChange(r.value);
    });
    const { getItems: s } = st(), { search: i, handleTypeaheadSearch: u, resetTypeahead: d } = gi();
    function c() {
      o.value || (n.onOpenChange(!0), d());
    }
    function f(p) {
      c(), n.triggerPointerDownPosRef.value = {
        x: Math.round(p.pageX),
        y: Math.round(p.pageY)
      };
    }
    return (p, v) => (h(), x(l(ur), {
      "as-child": "",
      reference: p.reference
    }, {
      default: y(() => [N(l(X), {
        ref: l(a),
        role: "combobox",
        type: p.as === "button" ? "button" : void 0,
        "aria-controls": l(n).contentId,
        "aria-expanded": l(n).open.value || !1,
        "aria-required": l(n).required?.value,
        "aria-autocomplete": "none",
        disabled: o.value,
        dir: l(n)?.dir.value,
        "data-state": l(n)?.open.value ? "open" : "closed",
        "data-disabled": o.value ? "" : void 0,
        "data-placeholder": l(Wq)(l(n).modelValue?.value) ? "" : void 0,
        "as-child": p.asChild,
        as: p.as,
        onClick: v[0] || (v[0] = (m) => {
          m?.currentTarget?.focus();
        }),
        onPointerdown: v[1] || (v[1] = (m) => {
          if (m.pointerType === "touch") return m.preventDefault();
          const g = m.target;
          g.hasPointerCapture(m.pointerId) && g.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && (f(m), m.preventDefault());
        }),
        onPointerup: v[2] || (v[2] = Ke((m) => {
          m.pointerType === "touch" && f(m);
        }, ["prevent"])),
        onKeydown: v[3] || (v[3] = (m) => {
          const g = l(i) !== "";
          !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && g && m.key === " " || (l(u)(m.key, l(s)()), l(Uq).includes(m.key) && (c(), m.preventDefault()));
        })
      }, {
        default: y(() => [_(p.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "aria-controls",
        "aria-expanded",
        "aria-required",
        "disabled",
        "dir",
        "data-state",
        "data-disabled",
        "data-placeholder",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), I2 = A2, O2 = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = La();
    Ce(() => {
      r.valueElement = a;
    });
    const o = E(() => {
      let i = [];
      const u = Array.from(r.optionsSet.value), d = (c) => u.find((f) => jo(c, f.value, r.by));
      return Array.isArray(r.modelValue.value) ? i = r.modelValue.value.map((c) => d(c)?.textContent ?? "") : i = [d(r.modelValue.value)?.textContent ?? ""], i.filter(Boolean);
    }), s = E(() => o.value.length ? o.value.join(", ") : t.placeholder);
    return (i, u) => (h(), x(l(X), {
      ref: l(n),
      as: i.as,
      "as-child": i.asChild,
      style: { pointerEvents: "none" },
      "data-placeholder": o.value.length ? void 0 : t.placeholder
    }, {
      default: y(() => [_(i.$slots, "default", {
        selectedLabel: o.value,
        modelValue: l(r).modelValue.value
      }, () => [Re(He(s.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-placeholder"
    ]));
  }
}), R2 = O2, V2 = /* @__PURE__ */ b({
  __name: "SelectViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { nonce: n } = Me(t), a = qi(n), r = pr(), o = r.position === "item-aligned" ? tf() : void 0, { forwardRef: s, currentElement: i } = j();
    Ce(() => {
      r?.onViewportChange(i.value);
    });
    const u = I(0);
    function d(c) {
      const f = c.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: v } = o ?? {};
      if (p?.value && v?.value) {
        const m = Math.abs(u.value - f.scrollTop);
        if (m > 0) {
          const g = window.innerHeight - $n * 2, w = Number.parseFloat(v.value.style.minHeight), C = Number.parseFloat(v.value.style.height), S = Math.max(w, C);
          if (S < g) {
            const $ = S + m, B = Math.min(g, $), k = $ - B;
            v.value.style.height = `${B}px`, v.value.style.bottom === "0px" && (f.scrollTop = k > 0 ? k : 0, v.value.style.justifyContent = "flex-end");
          }
        }
      }
      u.value = f.scrollTop;
    }
    return (c, f) => (h(), G(Ye, null, [N(l(X), A({
      ref: l(s),
      "data-reka-select-viewport": "",
      role: "presentation"
    }, {
      ...c.$attrs,
      ...t
    }, {
      style: {
        position: "relative",
        flex: 1,
        overflow: "hidden auto"
      },
      onScroll: d
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16), N(l(X), {
      as: "style",
      nonce: l(a)
    }, {
      default: y(() => f[0] || (f[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), F2 = V2, N2 = /* @__PURE__ */ b({
  __name: "BaseSeparator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ["horizontal", "vertical"];
    function a(i) {
      return n.includes(i);
    }
    const r = E(() => a(t.orientation) ? t.orientation : "horizontal"), o = E(() => r.value === "vertical" ? t.orientation : void 0), s = E(() => t.decorative ? { role: "none" } : {
      "aria-orientation": o.value,
      role: "separator"
    });
    return (i, u) => (h(), x(l(X), A({
      as: i.as,
      "as-child": i.asChild,
      "data-orientation": r.value
    }, s.value), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-orientation"
    ]));
  }
}), L2 = N2, z2 = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(L2, oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nf = z2;
function H2(e = [], t, n) {
  const a = [...e];
  return a[n] = t, a.sort((r, o) => r - o);
}
function Yg(e, t, n) {
  const o = 100 / (n - t) * (e - t);
  return Or(o, 0, 100);
}
function U2(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function j2(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((r) => Math.abs(r - t)), a = Math.min(...n);
  return n.indexOf(a);
}
function W2(e, t, n) {
  const a = e / 2, o = af([0, 50], [0, a]);
  return (a - o(t) * n) * n;
}
function G2(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function K2(e, t) {
  if (t > 0) {
    const n = G2(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function af(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function Y2(e) {
  return (String(e).split(".")[1] || "").length;
}
function X2(e, t) {
  const n = 10 ** t;
  return Math.round(e * n) / n;
}
const Xg = ["PageUp", "PageDown"], Jg = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
], Zg = {
  "from-left": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-right": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowRight"
  ],
  "from-bottom": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-top": [
    "Home",
    "PageUp",
    "ArrowUp",
    "ArrowLeft"
  ]
}, [Qg, ey] = Be(["SliderVertical", "SliderHorizontal"]);
var J2 = /* @__PURE__ */ b({
  __name: "SliderHorizontal",
  props: {
    dir: {
      type: String,
      required: !1
    },
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, dir: s, inverted: i } = Me(n), { forwardRef: u, currentElement: d } = j(), c = no(), f = I(), p = I(), v = E(() => s?.value !== "rtl" && !i.value || s?.value !== "ltr" && i.value);
    function m(S, $) {
      const B = p.value || d.value.getBoundingClientRect(), k = [...c.thumbElements.value][c.valueIndexToChangeRef.value], P = c.thumbAlignment.value === "contain" ? k.clientWidth : 0;
      !f.value && !$ && c.thumbAlignment.value === "contain" && (f.value = S.clientX - k.getBoundingClientRect().left);
      const D = [0, B.width - P], q = v.value ? [o.value, r.value] : [r.value, o.value], T = af(D, q);
      p.value = B;
      const M = $ ? S.clientX - B.left - P / 2 : S.clientX - B.left - (f.value ?? 0);
      return T(M);
    }
    const g = E(() => v.value ? "left" : "right"), w = E(() => v.value ? "right" : "left"), C = E(() => v.value ? 1 : -1);
    return ey({
      startEdge: g,
      endEdge: w,
      direction: C,
      size: "width"
    }), (S, $) => (h(), x(ty, {
      ref: l(u),
      dir: l(s),
      "data-orientation": "horizontal",
      style: dt({ "--reka-slider-thumb-transform": !v.value && l(c).thumbAlignment.value === "overflow" ? "translateX(50%)" : "translateX(-50%)" }),
      onSlideStart: $[0] || ($[0] = (B) => {
        const k = m(B, !0);
        a("slideStart", k);
      }),
      onSlideMove: $[1] || ($[1] = (B) => {
        const k = m(B);
        a("slideMove", k);
      }),
      onSlideEnd: $[2] || ($[2] = () => {
        p.value = void 0, f.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: $[3] || ($[3] = (B) => {
        const k = v.value ? "from-left" : "from-right", P = l(Zg)[k].includes(B.key);
        a("stepKeyDown", B, P ? -1 : 1);
      }),
      onEndKeyDown: $[4] || ($[4] = (B) => a("endKeyDown", B)),
      onHomeKeyDown: $[5] || ($[5] = (B) => a("homeKeyDown", B))
    }, {
      default: y(() => [_(S.$slots, "default")]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), Z2 = J2, Q2 = /* @__PURE__ */ b({
  __name: "SliderVertical",
  props: {
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, inverted: s } = Me(n), i = no(), { forwardRef: u, currentElement: d } = j(), c = I(), f = I(), p = E(() => !s.value);
    function v(C, S) {
      const $ = f.value || d.value.getBoundingClientRect(), B = [...i.thumbElements.value][i.valueIndexToChangeRef.value], k = i.thumbAlignment.value === "contain" ? B.clientHeight : 0;
      !c.value && !S && i.thumbAlignment.value === "contain" && (c.value = C.clientY - B.getBoundingClientRect().top);
      const P = [0, $.height - k], D = p.value ? [r.value, o.value] : [o.value, r.value], q = af(P, D), T = S ? C.clientY - $.top - k / 2 : C.clientY - $.top - (c.value ?? 0);
      return f.value = $, q(T);
    }
    const m = E(() => p.value ? "bottom" : "top"), g = E(() => p.value ? "top" : "bottom"), w = E(() => p.value ? 1 : -1);
    return ey({
      startEdge: m,
      endEdge: g,
      direction: w,
      size: "height"
    }), (C, S) => (h(), x(ty, {
      ref: l(u),
      "data-orientation": "vertical",
      style: dt({ "--reka-slider-thumb-transform": !p.value && l(i).thumbAlignment.value === "overflow" ? "translateY(-50%)" : "translateY(50%)" }),
      onSlideStart: S[0] || (S[0] = ($) => {
        const B = v($, !0);
        a("slideStart", B);
      }),
      onSlideMove: S[1] || (S[1] = ($) => {
        const B = v($);
        a("slideMove", B);
      }),
      onSlideEnd: S[2] || (S[2] = () => {
        f.value = void 0, c.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: S[3] || (S[3] = ($) => {
        const B = p.value ? "from-bottom" : "from-top", k = l(Zg)[B].includes($.key);
        a("stepKeyDown", $, k ? -1 : 1);
      }),
      onEndKeyDown: S[4] || (S[4] = ($) => a("endKeyDown", $)),
      onHomeKeyDown: S[5] || (S[5] = ($) => a("homeKeyDown", $))
    }, {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), eE = Q2;
const [no, tE] = Be("SliderRoot");
var nE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    defaultValue: {
      type: Array,
      required: !1,
      default: () => [0]
    },
    modelValue: {
      type: [Array, null],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    inverted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    min: {
      type: Number,
      required: !1,
      default: 0
    },
    max: {
      type: Number,
      required: !1,
      default: 100
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    minStepsBetweenThumbs: {
      type: Number,
      required: !1,
      default: 0
    },
    thumbAlignment: {
      type: String,
      required: !1,
      default: "contain"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, { min: r, max: o, step: s, minStepsBetweenThumbs: i, orientation: u, disabled: d, thumbAlignment: c, dir: f } = Me(n), p = yt(f), { forwardRef: v, currentElement: m } = j(), g = Rn(m), { CollectionSlot: w } = st({ isProvider: !0 }), C = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), S = E(() => Array.isArray(C.value) ? [...C.value] : []), $ = I(0), B = I(S.value);
    function k(M) {
      const O = j2(S.value, M);
      q(M, O);
    }
    function P(M) {
      q(M, $.value);
    }
    function D() {
      const M = B.value[$.value];
      S.value[$.value] !== M && a("valueCommit", C0(S.value));
    }
    function q(M, O, { commit: F } = { commit: !1 }) {
      const J = Y2(s.value), ne = X2(Math.round((M - r.value) / s.value) * s.value + r.value, J), Q = Or(ne, r.value, o.value), W = H2(S.value, Q, O);
      if (K2(W, i.value * s.value)) {
        $.value = W.indexOf(Q);
        const H = String(W) !== String(C.value);
        H && F && a("valueCommit", W), H && (T.value[$.value]?.focus(), C.value = W);
      }
    }
    const T = I([]);
    return tE({
      modelValue: C,
      currentModelValue: S,
      valueIndexToChangeRef: $,
      thumbElements: T,
      orientation: u,
      min: r,
      max: o,
      disabled: d,
      thumbAlignment: c
    }), (M, O) => (h(), x(l(w), null, {
      default: y(() => [(h(), x(Tt(l(u) === "horizontal" ? Z2 : eE), A(M.$attrs, {
        ref: l(v),
        "as-child": M.asChild,
        as: M.as,
        min: l(r),
        max: l(o),
        dir: l(p),
        inverted: M.inverted,
        "aria-disabled": l(d),
        "data-disabled": l(d) ? "" : void 0,
        onPointerdown: O[0] || (O[0] = () => {
          l(d) || (B.value = S.value);
        }),
        onSlideStart: O[1] || (O[1] = (F) => !l(d) && k(F)),
        onSlideMove: O[2] || (O[2] = (F) => !l(d) && P(F)),
        onSlideEnd: O[3] || (O[3] = (F) => !l(d) && D()),
        onHomeKeyDown: O[4] || (O[4] = (F) => !l(d) && q(l(r), 0, { commit: !0 })),
        onEndKeyDown: O[5] || (O[5] = (F) => !l(d) && q(l(o), S.value.length - 1, { commit: !0 })),
        onStepKeyDown: O[6] || (O[6] = (F, J) => {
          if (!l(d)) {
            const W = l(Xg).includes(F.key) || F.shiftKey && l(Jg).includes(F.key) ? 10 : 1, H = $.value, U = S.value[H], se = l(s) * W * J;
            q(U + se, H, { commit: !0 });
          }
        })
      }), {
        default: y(() => [_(M.$slots, "default", { modelValue: l(C) }), l(g) && M.name ? (h(), x(l(Vn), {
          key: 0,
          type: "number",
          value: l(C),
          name: M.name,
          required: M.required,
          disabled: l(d),
          step: l(s)
        }, null, 8, [
          "value",
          "name",
          "required",
          "disabled",
          "step"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "min",
        "max",
        "dir",
        "inverted",
        "aria-disabled",
        "data-disabled"
      ]))]),
      _: 3
    }));
  }
}), aE = nE, rE = /* @__PURE__ */ b({
  __name: "SliderImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  emits: [
    "slideStart",
    "slideMove",
    "slideEnd",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = no();
    return (o, s) => (h(), x(l(X), A({ "data-slider-impl": "" }, n, {
      onKeydown: s[0] || (s[0] = (i) => {
        i.key === "Home" ? (a("homeKeyDown", i), i.preventDefault()) : i.key === "End" ? (a("endKeyDown", i), i.preventDefault()) : l(Xg).concat(l(Jg)).includes(i.key) && (a("stepKeyDown", i), i.preventDefault());
      }),
      onPointerdown: s[1] || (s[1] = (i) => {
        const u = i.target;
        u.setPointerCapture(i.pointerId), i.preventDefault(), l(r).thumbElements.value.includes(u) ? u.focus() : a("slideStart", i);
      }),
      onPointermove: s[2] || (s[2] = (i) => {
        i.target.hasPointerCapture(i.pointerId) && a("slideMove", i);
      }),
      onPointerup: s[3] || (s[3] = (i) => {
        const u = i.target;
        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), a("slideEnd", i));
      })
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ty = rE, oE = /* @__PURE__ */ b({
  __name: "SliderRange",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = no(), n = Qg();
    j();
    const a = E(() => t.currentModelValue.value.map((s) => Yg(s, t.min.value, t.max.value))), r = E(() => t.currentModelValue.value.length > 1 ? Math.min(...a.value) : 0), o = E(() => 100 - Math.max(...a.value, 0));
    return (s, i) => (h(), x(l(X), {
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      "as-child": s.asChild,
      as: s.as,
      style: dt({
        [l(n).startEdge.value]: `${r.value}%`,
        [l(n).endEdge.value]: `${o.value}%`
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, [
      "data-disabled",
      "data-orientation",
      "as-child",
      "as",
      "style"
    ]));
  }
}), sE = oE, lE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = no(), a = Qg(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = E(() => n.modelValue?.value?.[t.index]), u = E(() => i.value === void 0 ? 0 : Yg(i.value, n.min.value ?? 0, n.max.value ?? 100)), d = E(() => U2(t.index, n.modelValue?.value?.length ?? 0)), c = zh(o), f = E(() => c[a.size].value), p = E(() => n.thumbAlignment.value === "overflow" || !f.value ? 0 : W2(f.value, u.value, a.direction.value)), v = cc();
    return Ce(() => {
      n.thumbElements.value.push(o.value);
    }), Qe(() => {
      const m = n.thumbElements.value.findIndex((g) => g === o.value) ?? -1;
      n.thumbElements.value.splice(m, 1);
    }), (m, g) => (h(), x(l(s), null, {
      default: y(() => [N(l(X), A(m.$attrs, {
        ref: l(r),
        role: "slider",
        tabindex: l(n).disabled.value ? void 0 : 0,
        "aria-label": m.$attrs["aria-label"] || d.value,
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "data-orientation": l(n).orientation.value,
        "aria-valuenow": i.value,
        "aria-valuemin": l(n).min.value,
        "aria-valuemax": l(n).max.value,
        "aria-orientation": l(n).orientation.value,
        "as-child": m.asChild,
        as: m.as,
        style: {
          transform: "var(--reka-slider-thumb-transform)",
          position: "absolute",
          [l(a).startEdge.value]: `calc(${u.value}% + ${p.value}px)`,
          display: !l(v) && i.value === void 0 ? "none" : void 0
        },
        onFocus: g[0] || (g[0] = () => {
          l(n).valueIndexToChangeRef.value = m.index;
        })
      }), {
        default: y(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "tabindex",
        "aria-label",
        "data-disabled",
        "data-orientation",
        "aria-valuenow",
        "aria-valuemin",
        "aria-valuemax",
        "aria-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }));
  }
}), iE = lE, uE = /* @__PURE__ */ b({
  __name: "SliderThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { getItems: n } = st(), { forwardRef: a, currentElement: r } = j(), o = E(() => r.value ? n(!0).findIndex((s) => s.ref === r.value) : -1);
    return (s, i) => (h(), x(iE, A({ ref: l(a) }, t, { index: o.value }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["index"]));
  }
}), dE = uE, cE = /* @__PURE__ */ b({
  __name: "SliderTrack",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = no();
    return j(), (n, a) => (h(), x(l(X), {
      "as-child": n.asChild,
      as: n.as,
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), fE = cE;
function ze(e, t = "Assertion failed!") {
  if (!e)
    throw console.error(t), new Error(t);
}
function ny(e, t = document) {
  if (!ls) return null;
  if (t instanceof HTMLElement && t?.dataset?.panelGroupId === e) return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function Fi(e, t = document) {
  if (!ls) return null;
  const n = t.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return n || null;
}
function ay(e, t, n = document) {
  return ls ? Wo(e, n).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === t) ?? null : null;
}
function Wo(e, t = document) {
  return ls ? Array.from(t.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function pE(e, t, n, a = document) {
  const r = Fi(t, a), o = Wo(e, a), s = r ? o.indexOf(r) : -1, i = n[s]?.id ?? null, u = n[s + 1]?.id ?? null;
  return [i, u];
}
function ry(e) {
  return e.type === "keydown";
}
function oy(e) {
  return e.type.startsWith("mouse");
}
function sy(e) {
  return e.type.startsWith("touch");
}
function Ni(e) {
  if (oy(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (sy(e)) {
    const t = e.touches[0];
    if (t && t.clientX && t.clientY) return {
      x: t.clientX,
      y: t.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function ly(e, t) {
  const n = e === "horizontal", { x: a, y: r } = Ni(t);
  return n ? a : r;
}
function vE(e, t, n, a, r) {
  const o = n === "horizontal", s = Fi(t, r);
  ze(s);
  const i = s.getAttribute("data-panel-group-id");
  ze(i);
  const { initialCursorPosition: u } = a, d = ly(n, e), c = ny(i, r);
  ze(c);
  const f = c.getBoundingClientRect(), p = o ? f.width : f.height;
  return (d - u) / p * 100;
}
function mE(e, t, n, a, r, o) {
  if (ry(e)) {
    const s = n === "horizontal";
    let i = 0;
    e.shiftKey ? i = 100 : i = r ?? 10;
    let u = 0;
    switch (e.key) {
      case "ArrowDown":
        u = s ? 0 : i;
        break;
      case "ArrowLeft":
        u = s ? -i : 0;
        break;
      case "ArrowRight":
        u = s ? i : 0;
        break;
      case "ArrowUp":
        u = s ? 0 : -i;
        break;
      case "End":
        u = 100;
        break;
      case "Home":
        u = -100;
        break;
    }
    return u;
  } else
    return a == null ? 0 : vE(e, t, n, a, o);
}
function hE({ layout: e, panelsArray: t, pivotIndices: n }) {
  let a = 0, r = 100, o = 0, s = 0;
  const i = n[0];
  ze(i != null), t.forEach((f, p) => {
    const { constraints: v } = f, { maxSize: m = 100, minSize: g = 0 } = v;
    p === i ? (a = g, r = m) : (o += g, s += m);
  });
  const u = Math.min(r, 100 - o), d = Math.max(a, 100 - s), c = e[i];
  return {
    valueMax: u,
    valueMin: d,
    valueNow: c
  };
}
function gE({ panelDataArray: e }) {
  const t = Array.from({ length: e.length }), n = e.map((o) => o.constraints);
  let a = 0, r = 100;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    ze(s);
    const { defaultSize: i } = s;
    i != null && (a++, t[o] = i, r -= i);
  }
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    ze(s);
    const { defaultSize: i } = s;
    if (i != null) continue;
    const u = e.length - a, d = r / u;
    a++, t[o] = d, r -= d;
  }
  return t;
}
function po(e, t, n) {
  t.forEach((a, r) => {
    const o = e[r];
    ze(o);
    const { callbacks: s, constraints: i, id: u } = o, { collapsedSize: d = 0, collapsible: c } = i, f = n[u];
    if (f == null || a !== f) {
      n[u] = a;
      const { onCollapse: p, onExpand: v, onResize: m } = s;
      m && m(a, f), c && (p || v) && (v && (f == null || f === d) && a !== d && v(), p && (f == null || f !== d) && a === d && p());
    }
  });
}
function yE(e, t = 10) {
  let n = null;
  return (...r) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...r);
    }, t);
  };
}
const rf = 10;
function Go(e, t, n = rf) {
  e = Number.parseFloat(e.toFixed(n)), t = Number.parseFloat(t.toFixed(n));
  const a = e - t;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function dn(e, t, n) {
  return Go(e, t, n) === 0;
}
function kr({ panelConstraints: e, panelIndex: t, size: n }) {
  const a = e[t];
  ze(a != null);
  const { collapsedSize: r = 0, collapsible: o, maxSize: s = 100, minSize: i = 0 } = a;
  if (Go(n, i) < 0) if (o) {
    const u = (r + i) / 2;
    Go(n, u) < 0 ? n = r : n = i;
  } else n = i;
  return n = Math.min(s, n), n = Number.parseFloat(n.toFixed(rf)), n;
}
function Hs(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function Co({ delta: e, layout: t, panelConstraints: n, pivotIndices: a, trigger: r }) {
  if (dn(e, 0)) return t;
  const o = [...t], [s, i] = a;
  ze(s != null), ze(i != null);
  let u = 0;
  if (r === "keyboard") {
    {
      const c = e < 0 ? i : s, f = n[c];
      if (ze(f), f.collapsible) {
        const p = t[c];
        ze(p != null);
        const v = n[c];
        ze(v);
        const { collapsedSize: m = 0, minSize: g = 0 } = v;
        if (dn(p, m)) {
          const w = g - p;
          Go(w, Math.abs(e)) > 0 && (e = e < 0 ? 0 - w : w);
        }
      }
    }
    {
      const c = e < 0 ? s : i, f = n[c];
      ze(f);
      const { collapsible: p } = f;
      if (p) {
        const v = t[c];
        ze(v != null);
        const m = n[c];
        ze(m);
        const { collapsedSize: g = 0, minSize: w = 0 } = m;
        if (dn(v, w)) {
          const C = v - g;
          Go(C, Math.abs(e)) > 0 && (e = e < 0 ? 0 - C : C);
        }
      }
    }
  }
  {
    const c = e < 0 ? 1 : -1;
    let f = e < 0 ? i : s, p = 0;
    for (; ; ) {
      const m = t[f];
      ze(m != null);
      const w = kr({
        panelConstraints: n,
        panelIndex: f,
        size: 100
      }) - m;
      if (p += w, f += c, f < 0 || f >= n.length) break;
    }
    const v = Math.min(Math.abs(e), Math.abs(p));
    e = e < 0 ? 0 - v : v;
  }
  {
    let f = e < 0 ? s : i;
    for (; f >= 0 && f < n.length; ) {
      const p = Math.abs(e) - Math.abs(u), v = t[f];
      ze(v != null);
      const m = v - p, g = kr({
        panelConstraints: n,
        panelIndex: f,
        size: m
      });
      if (!dn(v, g) && (u += v - g, o[f] = g, u.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? f-- : f++;
    }
  }
  if (dn(u, 0)) return t;
  {
    const c = e < 0 ? i : s, f = t[c];
    ze(f != null);
    const p = f + u, v = kr({
      panelConstraints: n,
      panelIndex: c,
      size: p
    });
    if (o[c] = v, !dn(v, p)) {
      let m = p - v, w = e < 0 ? i : s;
      for (; w >= 0 && w < n.length; ) {
        const C = o[w];
        ze(C != null);
        const S = C + m, $ = kr({
          panelConstraints: n,
          panelIndex: w,
          size: S
        });
        if (dn(C, $) || (m -= $ - C, o[w] = $), dn(m, 0)) break;
        e > 0 ? w-- : w++;
      }
    }
  }
  const d = o.reduce((c, f) => f + c, 0);
  return dn(d, 100) ? o : t;
}
function iy(e, t, n) {
  const a = ay(e, t, n);
  return a != null ? [a, a + 1] : [-1, -1];
}
function bE(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function _E(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: uv(e),
    b: uv(t)
  };
  let a;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), a = e;
  ze(a);
  const r = {
    a: iv(lv(n.a)),
    b: iv(lv(n.b))
  };
  if (r.a === r.b) {
    const o = a.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let i = o.length;
    for (; i--; ) {
      const u = o[i];
      if (u === s.a) return 1;
      if (u === s.b) return -1;
    }
  }
  return Math.sign(r.a - r.b);
}
const wE = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function xE(e) {
  const t = getComputedStyle(uy(e)).display;
  return t === "flex" || t === "inline-flex";
}
function CE(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || xE(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || wE.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function lv(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (ze(n), CE(n)) return n;
  }
  return null;
}
function iv(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function uv(e) {
  const t = [];
  for (; e; )
    t.push(e), e = uy(e);
  return t;
}
function uy(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
const dy = 1, cy = 2, fy = 4, py = 8;
function SE() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const $E = SE() === "coarse", Ia = [];
let Li = !1;
const Da = /* @__PURE__ */ new Map(), zi = /* @__PURE__ */ new Map(), Ko = /* @__PURE__ */ new Set();
function kE(e, t, n, a, r, o) {
  const { ownerDocument: s } = t, i = {
    direction: n,
    element: t,
    hitAreaMargins: a,
    nonce: r,
    setResizeHandlerState: o
  }, u = Da.get(s) ?? 0;
  return Da.set(s, u + 1), Ko.add(i), Vl(), function() {
    zi.delete(e), Ko.delete(i);
    const c = Da.get(s) ?? 1;
    Da.set(s, c - 1), Vl(), my(), c === 1 && Da.delete(s);
  };
}
function Us(e) {
  const { target: t } = e, { x: n, y: a } = Ni(e);
  Li = !0, of({
    target: t,
    x: n,
    y: a
  }), Vl(), Ia.length > 0 && (sf("down", e), e.preventDefault());
}
function wa(e) {
  const { x: t, y: n } = Ni(e);
  if (!Li) {
    const { target: a } = e;
    of({
      target: a,
      x: t,
      y: n
    });
  }
  sf("move", e), vy(), Ia.length > 0 && e.preventDefault();
}
function xa(e) {
  const { target: t } = e, { x: n, y: a } = Ni(e);
  zi.clear(), Li = !1, Ia.length > 0 && e.preventDefault(), sf("up", e), of({
    target: t,
    x: n,
    y: a
  }), vy(), Vl();
}
function of({ target: e, x: t, y: n }) {
  Ia.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), Ko.forEach((r) => {
    const { element: o, hitAreaMargins: s } = r, i = o.getBoundingClientRect(), { bottom: u, left: d, right: c, top: f } = i, p = $E ? s.coarse : s.fine;
    if (t >= d - p && t <= c + p && n >= f - p && n <= u + p) {
      if (a !== null && o !== a && !o.contains(a) && !a.contains(o) && _E(a, o) > 0) {
        let m = a, g = !1;
        for (; m && !m.contains(o); ) {
          if (bE(m.getBoundingClientRect(), i)) {
            g = !0;
            break;
          }
          m = m.parentElement;
        }
        if (g) return;
      }
      Ia.push(r);
    }
  });
}
function Iu(e, t) {
  zi.set(e, t);
}
function vy() {
  let e = !1, t = !1, n;
  Ia.forEach((r) => {
    const { direction: o, nonce: s } = r;
    o.value === "horizontal" ? e = !0 : t = !0, n = s.value;
  });
  let a = 0;
  zi.forEach((r) => {
    a |= r;
  }), e && t ? Ou("intersection", a, n) : e ? Ou("horizontal", a, n) : t ? Ou("vertical", a, n) : my();
}
function Vl() {
  Da.forEach((e, t) => {
    const { body: n } = t;
    n.removeEventListener("contextmenu", xa), n.removeEventListener("mousedown", Us), n.removeEventListener("mouseleave", wa), n.removeEventListener("mousemove", wa), n.removeEventListener("touchmove", wa), n.removeEventListener("touchstart", Us);
  }), window.removeEventListener("mouseup", xa), window.removeEventListener("touchcancel", xa), window.removeEventListener("touchend", xa), Ko.size > 0 && (Li ? (Ia.length > 0 && Da.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("contextmenu", xa), n.addEventListener("mouseleave", wa), n.addEventListener("mousemove", wa), n.addEventListener("touchmove", wa, { passive: !1 }));
  }), window.addEventListener("mouseup", xa), window.addEventListener("touchcancel", xa), window.addEventListener("touchend", xa)) : Da.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("mousedown", Us), n.addEventListener("mousemove", wa), n.addEventListener("touchmove", wa, { passive: !1 }), n.addEventListener("touchstart", Us));
  }));
}
function sf(e, t) {
  Ko.forEach((n) => {
    const { setResizeHandlerState: a } = n, r = Ia.includes(n);
    a(e, r, t);
  });
}
let Bd = null, Pa = null;
function BE(e, t) {
  if (t) {
    const n = (t & dy) !== 0, a = (t & cy) !== 0, r = (t & fy) !== 0, o = (t & py) !== 0;
    if (n) return r ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (a) return r ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (r) return "s-resize";
    if (o) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function my() {
  Pa !== null && (document.head.removeChild(Pa), Bd = null, Pa = null);
}
function Ou(e, t, n) {
  const a = BE(e, t);
  Bd !== a && (Bd = a, Pa === null && (Pa = document.createElement("style"), n && (Pa.nonce = n), document.head.appendChild(Pa)), Pa.innerHTML = `*{cursor: ${a}!important;}`);
}
function DE({ defaultSize: e, dragState: t, layout: n, panelData: a, panelIndex: r, precision: o = 3 }) {
  const s = n[r];
  let i;
  return s == null ? i = e !== void 0 ? e.toPrecision(o) : "1" : a.length === 1 ? i = "1" : i = s.toPrecision(o), {
    flexBasis: 0,
    flexGrow: i,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: t !== null ? "none" : void 0
  };
}
function PE({ layout: e, panelConstraints: t }) {
  const n = [...e], a = n.reduce((o, s) => o + s, 0);
  if (n.length !== t.length) throw new Error(`Invalid ${t.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!dn(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${n.map((o) => `${o}%`).join(", ")}. Layout normalization will be applied.`);
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      ze(s != null);
      const i = 100 / a * s;
      n[o] = i;
    }
  }
  let r = 0;
  for (let o = 0; o < t.length; o++) {
    const s = n[o];
    ze(s != null);
    const i = kr({
      panelConstraints: t,
      panelIndex: o,
      size: s
    });
    s !== i && (r += s - i, n[o] = i);
  }
  if (!dn(r, 0)) for (let o = 0; o < t.length; o++) {
    const s = n[o];
    ze(s != null);
    const i = s + r, u = kr({
      panelConstraints: t,
      panelIndex: o,
      size: i
    });
    if (s !== u && (r -= u - s, n[o] = u, dn(r, 0)))
      break;
  }
  return n;
}
function ME({ eagerValuesRef: e, groupId: t, layout: n, panelDataArray: a, panelGroupElement: r, setLayout: o }) {
  Ie((s) => {
    const i = r.value;
    if (!i) return;
    const u = Wo(t, i);
    for (let d = 0; d < a.length - 1; d++) {
      const { valueMax: c, valueMin: f, valueNow: p } = hE({
        layout: n.value,
        panelsArray: a,
        pivotIndices: [d, d + 1]
      }), v = u[d];
      if (v != null) {
        const m = a[d];
        ze(m), v.setAttribute("aria-controls", m.id), v.setAttribute("aria-valuemax", `${Math.round(c)}`), v.setAttribute("aria-valuemin", `${Math.round(f)}`), v.setAttribute("aria-valuenow", p != null ? `${Math.round(p)}` : "");
      }
    }
    s(() => {
      u.forEach((d) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    });
  }), Ie((s) => {
    const i = r.value;
    if (!i) return;
    const u = e.value;
    ze(u);
    const { panelDataArray: d } = u, c = ny(t, i);
    ze(c != null, `No group found for id "${t}"`);
    const f = Wo(t, i);
    ze(f);
    const p = f.map((v) => {
      const m = v.getAttribute("data-panel-resize-handle-id");
      ze(m);
      const [g, w] = pE(t, m, d, i);
      if (g == null || w == null) return () => {
      };
      const C = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const $ = d.findIndex((B) => B.id === g);
              if ($ >= 0) {
                const B = d[$];
                ze(B);
                const k = n.value[$], { collapsedSize: P = 0, collapsible: D, minSize: q = 0 } = B.constraints;
                if (k != null && D) {
                  const T = Co({
                    delta: dn(k, P) ? q - P : P - k,
                    layout: n.value,
                    panelConstraints: d.map((M) => M.constraints),
                    pivotIndices: iy(t, m, i),
                    trigger: "keyboard"
                  });
                  n.value !== T && o(T);
                }
              }
              break;
            }
          }
      };
      return v.addEventListener("keydown", C), () => {
        v.removeEventListener("keydown", C);
      };
    });
    s(() => {
      p.forEach((v) => v());
    });
  });
}
function dv(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function hy(e) {
  return `reka:${e}`;
}
function gy(e) {
  return e.map((t) => {
    const { constraints: n, id: a, idIsFromProps: r, order: o } = t;
    return r ? a : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function yy(e, t) {
  try {
    const n = hy(e), a = t.getItem(n);
    if (a) {
      const r = JSON.parse(a);
      if (typeof r == "object" && r != null) return r;
    }
  } catch {
  }
  return null;
}
function qE(e, t, n) {
  const a = yy(e, n) ?? {}, r = gy(t);
  return a[r] ?? null;
}
function EE(e, t, n, a, r) {
  const o = hy(e), s = gy(t), i = yy(e, r) ?? {};
  i[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: a
  };
  try {
    r.setItem(o, JSON.stringify(i));
  } catch (u) {
    console.error(u);
  }
}
const TE = 100, So = {
  getItem: (e) => (dv(So), So.getItem(e)),
  setItem: (e, t) => {
    dv(So), So.setItem(e, t);
  }
}, [by, AE] = Be("PanelGroup");
var IE = /* @__PURE__ */ b({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => So
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = {}, { direction: o } = Me(n), s = Ge(n.id, "reka-splitter-group"), i = yt(), { forwardRef: u, currentElement: d } = j(), c = I(null), f = I([]), p = I({}), v = I(/* @__PURE__ */ new Map()), m = I(0), g = E(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: c.value,
      id: s,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), w = I({
      layout: f.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), C = (H) => f.value = H;
    ME({
      eagerValuesRef: w,
      groupId: s,
      layout: f,
      panelDataArray: w.value.panelDataArray,
      setLayout: C,
      panelGroupElement: d
    }), Ie(() => {
      const { panelDataArray: H } = w.value, { autoSaveId: U } = n;
      if (U) {
        if (f.value.length === 0 || f.value.length !== H.length) return;
        let se = r[U];
        se || (se = yE(EE, TE), r[U] = se);
        const ee = [...H], de = new Map(v.value);
        se(U, ee, de, f.value, n.storage);
      }
    });
    function S(H, U) {
      const { panelDataArray: se } = w.value, ee = Q(se, H);
      return DE({
        defaultSize: U,
        dragState: c.value,
        layout: f.value,
        panelData: se,
        panelIndex: ee
      });
    }
    function $(H) {
      const { panelDataArray: U } = w.value;
      U.push(H), U.sort((se, ee) => {
        const de = se.order, pe = ee.order;
        return de == null && pe == null ? 0 : de == null ? -1 : pe == null ? 1 : de - pe;
      }), w.value.panelDataArrayChanged = !0;
    }
    ve(() => w.value.panelDataArrayChanged, () => {
      if (w.value.panelDataArrayChanged) {
        w.value.panelDataArrayChanged = !1;
        const { autoSaveId: H, storage: U } = g.value, { layout: se, panelDataArray: ee } = w.value;
        let de = null;
        if (H) {
          const _e = qE(H, ee, U);
          _e && (v.value = new Map(Object.entries(_e.expandToSizes)), de = _e.layout);
        }
        de === null && (de = gE({ panelDataArray: ee }));
        const pe = PE({
          layout: de,
          panelConstraints: ee.map((_e) => _e.constraints)
        });
        A0(se, pe) || (C(pe), w.value.layout = pe, a("layout", pe), po(ee, pe, p.value));
      }
    });
    function B(H) {
      return function(se) {
        se.preventDefault();
        const ee = d.value;
        if (!ee) return () => null;
        const { direction: de, dragState: pe, id: _e, keyboardResizeBy: ge } = g.value, { layout: Te, panelDataArray: ce } = w.value, { initialLayout: R } = pe ?? {}, te = iy(_e, H, ee);
        let z = mE(se, H, de, pe, ge, ee);
        if (z === 0) return;
        const ae = de === "horizontal";
        i.value === "rtl" && ae && (z = -z);
        const ie = ce.map((we) => we.constraints), L = Co({
          delta: z,
          layout: R ?? Te,
          panelConstraints: ie,
          pivotIndices: te,
          trigger: ry(se) ? "keyboard" : "mouse-or-touch"
        }), be = !Hs(Te, L);
        (oy(se) || sy(se)) && m.value !== z && (m.value = z, be ? Iu(H, 0) : ae ? Iu(H, z < 0 ? dy : cy) : Iu(H, z < 0 ? fy : py)), be && (C(L), w.value.layout = L, a("layout", L), po(ce, L, p.value));
      };
    }
    function k(H, U) {
      const { layout: se, panelDataArray: ee } = w.value, de = ee.map((R) => R.constraints), { panelSize: pe, pivotIndices: _e } = W(ee, H, se);
      ze(pe != null);
      const Te = Q(ee, H) === ee.length - 1 ? pe - U : U - pe, ce = Co({
        delta: Te,
        layout: se,
        panelConstraints: de,
        pivotIndices: _e,
        trigger: "imperative-api"
      });
      Hs(se, ce) || (C(ce), w.value.layout = ce, a("layout", ce), po(ee, ce, p.value));
    }
    function P(H, U) {
      const { layout: se, panelDataArray: ee } = w.value, de = Q(ee, H);
      ee[de] = H, w.value.panelDataArrayChanged = !0;
      const { collapsedSize: pe = 0, collapsible: _e } = U, { collapsedSize: ge = 0, collapsible: Te, maxSize: ce = 100, minSize: R = 0 } = H.constraints, { panelSize: te } = W(ee, H, se);
      te !== null && (_e && Te && te === pe ? pe !== ge && k(H, ge) : te < R ? k(H, R) : te > ce && k(H, ce));
    }
    function D(H, U) {
      const { direction: se } = g.value, { layout: ee } = w.value;
      if (!d.value) return;
      const de = Fi(H, d.value);
      ze(de);
      const pe = ly(se, U);
      c.value = {
        dragHandleId: H,
        dragHandleRect: de.getBoundingClientRect(),
        initialCursorPosition: pe,
        initialLayout: ee
      };
    }
    function q() {
      c.value = null;
    }
    function T(H) {
      const { panelDataArray: U } = w.value, se = Q(U, H);
      se >= 0 && (U.splice(se, 1), delete p.value[H.id], w.value.panelDataArrayChanged = !0);
    }
    function M(H) {
      const { layout: U, panelDataArray: se } = w.value;
      if (H.constraints.collapsible) {
        const ee = se.map((ge) => ge.constraints), { collapsedSize: de = 0, panelSize: pe, pivotIndices: _e } = W(se, H, U);
        if (ze(pe != null, `Panel size not found for panel "${H.id}"`), pe !== de) {
          v.value.set(H.id, pe);
          const Te = Q(se, H) === se.length - 1 ? pe - de : de - pe, ce = Co({
            delta: Te,
            layout: U,
            panelConstraints: ee,
            pivotIndices: _e,
            trigger: "imperative-api"
          });
          Hs(U, ce) || (C(ce), w.value.layout = ce, a("layout", ce), po(se, ce, p.value));
        }
      }
    }
    function O(H) {
      const { layout: U, panelDataArray: se } = w.value;
      if (H.constraints.collapsible) {
        const ee = se.map((Te) => Te.constraints), { collapsedSize: de = 0, panelSize: pe, minSize: _e = 0, pivotIndices: ge } = W(se, H, U);
        if (pe === de) {
          const Te = v.value.get(H.id), ce = Te != null && Te >= _e ? Te : _e, te = Q(se, H) === se.length - 1 ? pe - ce : ce - pe, z = Co({
            delta: te,
            layout: U,
            panelConstraints: ee,
            pivotIndices: ge,
            trigger: "imperative-api"
          });
          Hs(U, z) || (C(z), w.value.layout = z, a("layout", z), po(se, z, p.value));
        }
      }
    }
    function F(H) {
      const { layout: U, panelDataArray: se } = w.value, { panelSize: ee } = W(se, H, U);
      return ze(ee != null, `Panel size not found for panel "${H.id}"`), ee;
    }
    function J(H) {
      const { layout: U, panelDataArray: se } = w.value, { collapsedSize: ee = 0, collapsible: de, panelSize: pe } = W(se, H, U);
      return de ? pe === void 0 ? H.constraints.defaultSize === H.constraints.collapsedSize : pe === ee : !1;
    }
    function ne(H) {
      const { layout: U, panelDataArray: se } = w.value, { collapsedSize: ee = 0, collapsible: de, panelSize: pe } = W(se, H, U);
      return ze(pe != null, `Panel size not found for panel "${H.id}"`), !de || pe > ee;
    }
    AE({
      direction: o,
      dragState: c.value,
      groupId: s,
      reevaluatePanelConstraints: P,
      registerPanel: $,
      registerResizeHandle: B,
      resizePanel: k,
      startDragging: D,
      stopDragging: q,
      unregisterPanel: T,
      panelGroupElement: d,
      collapsePanel: M,
      expandPanel: O,
      isPanelCollapsed: J,
      isPanelExpanded: ne,
      getPanelSize: F,
      getPanelStyle: S
    });
    function Q(H, U) {
      return H.findIndex((se) => se === U || se.id === U.id);
    }
    function W(H, U, se) {
      const ee = Q(H, U), pe = ee === H.length - 1 ? [ee - 1, ee] : [ee, ee + 1], _e = se[ee];
      return {
        ...U.constraints,
        panelSize: _e,
        pivotIndices: pe
      };
    }
    return (H, U) => (h(), x(l(X), {
      ref: l(u),
      as: H.as,
      "as-child": H.asChild,
      style: dt({
        display: "flex",
        flexDirection: l(o) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": l(o),
      "data-panel-group-id": l(s)
    }, {
      default: y(() => [_(H.$slots, "default", { layout: f.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), OE = IE, RE = /* @__PURE__ */ b({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, o = by();
    if (o === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: s, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: f, groupId: p, reevaluatePanelConstraints: v, registerPanel: m, unregisterPanel: g } = o, w = Ge(a.id, "reka-splitter-panel"), C = E(() => ({
      callbacks: {
        onCollapse: () => r("collapse"),
        onExpand: () => r("expand"),
        onResize: (...q) => r("resize", ...q)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(rf)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: w,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    ve(() => C.value.constraints, (q, T) => {
      (T.collapsedSize !== q.collapsedSize || T.collapsible !== q.collapsible || T.maxSize !== q.maxSize || T.minSize !== q.minSize) && v(C.value, T);
    }, { deep: !0 }), Ce(() => {
      m(C.value);
    }), Qe(() => {
      g(C.value);
    });
    const S = E(() => d(C.value, a.defaultSize)), $ = E(() => c(C.value)), B = E(() => !$.value);
    function k() {
      s(C.value);
    }
    function P() {
      i(C.value);
    }
    function D(q) {
      f(C.value, q);
    }
    return t({
      collapse: k,
      expand: P,
      getSize() {
        return u(C.value);
      },
      resize: D,
      isCollapsed: $,
      isExpanded: B
    }), (q, T) => (h(), x(l(X), {
      id: l(w),
      style: dt(S.value),
      as: q.as,
      "as-child": q.asChild,
      "data-panel": "",
      "data-panel-collapsible": q.collapsible || void 0,
      "data-panel-group-id": l(p),
      "data-panel-id": l(w),
      "data-panel-size": Number.parseFloat(`${S.value.flexGrow}`).toFixed(1),
      "data-state": q.collapsible ? $.value ? "collapsed" : "expanded" : void 0
    }, {
      default: y(() => [_(q.$slots, "default", {
        isCollapsed: $.value,
        isExpanded: B.value,
        expand: P,
        collapse: k,
        resize: D
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), D7 = RE;
function VE({ disabled: e, handleId: t, resizeHandler: n, panelGroupElement: a }) {
  Ie((r) => {
    const o = a.value;
    if (e.value || n.value === null || o === null) return;
    const s = Fi(t, o);
    if (s == null) return;
    const i = (u) => {
      if (!u.defaultPrevented)
        switch (u.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            u.preventDefault(), n.value?.(u);
            break;
          }
          case "F6": {
            u.preventDefault();
            const d = s.getAttribute("data-panel-group-id");
            ze(d);
            const c = Wo(d, o), f = ay(d, t, o);
            ze(f !== null);
            const p = u.shiftKey ? f > 0 ? f - 1 : c.length - 1 : f + 1 < c.length ? f + 1 : 0;
            c[p].focus();
            break;
          }
        }
    };
    s.addEventListener("keydown", i), r(() => {
      s.removeEventListener("keydown", i);
    });
  });
}
var FE = /* @__PURE__ */ b({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), { disabled: s } = Me(n), i = by();
    if (i === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: u, groupId: d, registerResizeHandle: c, startDragging: f, stopDragging: p, panelGroupElement: v } = i, m = Ge(n.id, "reka-splitter-resize-handle"), g = I("inactive"), w = I(!1), C = I(null), { nonce: S } = Me(n), $ = qi(S);
    return ve(s, () => {
      ls && (s.value ? C.value = null : C.value = c(m));
    }, { immediate: !0 }), Ie((B) => {
      if (s.value || C.value === null) return;
      const k = o.value;
      if (!k) return;
      ze(k);
      const P = (D, q, T) => {
        if (q) switch (D) {
          case "down": {
            g.value = "drag", f(m, T), a("dragging", !0);
            break;
          }
          case "move": {
            g.value !== "drag" && (g.value = "hover"), C.value?.(T);
            break;
          }
          case "up": {
            g.value = "hover", p(), a("dragging", !1);
            break;
          }
        }
        else g.value = "inactive";
      };
      B(kE(m, k, u, {
        coarse: n.hitAreaMargins?.coarse ?? 15,
        fine: n.hitAreaMargins?.fine ?? 5
      }, $, P));
    }), VE({
      disabled: s,
      resizeHandler: C,
      handleId: m,
      panelGroupElement: v
    }), (B, k) => (h(), x(l(X), {
      id: l(m),
      ref: l(r),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: B.as,
      "as-child": B.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: B.tabindex,
      "data-state": g.value,
      "data-disabled": l(s) ? "" : void 0,
      "data-orientation": l(u),
      "data-panel-group-id": l(d),
      "data-resize-handle-active": g.value === "drag" ? "pointer" : w.value ? "keyboard" : void 0,
      "data-resize-handle-state": g.value,
      "data-panel-resize-handle-enabled": !l(s),
      "data-panel-resize-handle-id": l(m),
      onBlur: k[0] || (k[0] = (P) => w.value = !1),
      onFocus: k[1] || (k[1] = (P) => w.value = !1)
    }, {
      default: y(() => [_(B.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), NE = FE;
const LE = {
  "aria-live": "polite",
  "aria-atomic": "true",
  role: "status",
  style: {
    transform: "translateX(-100%)",
    position: "absolute",
    pointerEvents: "none",
    opacity: 0,
    margin: 0
  }
}, [lf, zE] = Be("StepperRoot");
var HE = /* @__PURE__ */ b({
  __name: "StepperRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: 1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    modelValue: {
      type: Number,
      required: !1
    },
    linear: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { dir: o, orientation: s, linear: i } = Me(a), u = yt(o), d = I(/* @__PURE__ */ new Set()), c = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue,
      passive: a.modelValue === void 0
    }), f = E(() => Array.from(d.value)), p = E(() => c.value === 1), v = E(() => c.value === f.value.length), m = E(() => d.value.size);
    function g(q) {
      q > m.value || q < 1 || d.value.size && f.value[q] && f.value[q].getAttribute("disabled") || i.value && q > (c.value ?? 1) + 1 || (c.value = q);
    }
    function w() {
      g((c.value ?? 1) + 1);
    }
    function C() {
      g((c.value ?? 1) - 1);
    }
    function S() {
      return (c.value ?? 1) < m.value;
    }
    function $() {
      return (c.value ?? 1) > 1;
    }
    const B = I(null), k = I(null), P = E(() => B.value ? B.value.getAttribute("disabled") === "" : !0), D = E(() => k.value ? k.value.getAttribute("disabled") === "" : !0);
    return ve(c, async () => {
      await ke(() => {
        B.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, k.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), ve(f, async () => {
      await ke(() => {
        B.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, k.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), zE({
      modelValue: c,
      changeModelValue: (q) => {
        c.value = q;
      },
      orientation: s,
      dir: u,
      linear: i,
      totalStepperItems: d
    }), t({
      goToStep: g,
      nextStep: w,
      prevStep: C,
      modelValue: c,
      totalSteps: m,
      isNextDisabled: P,
      isPrevDisabled: D,
      isFirstStep: p,
      isLastStep: v,
      hasNext: S,
      hasPrev: $
    }), j(), (q, T) => (h(), x(l(X), {
      role: "group",
      "aria-label": "progress",
      as: q.as,
      "as-child": q.asChild,
      "data-linear": l(i) ? "" : void 0,
      "data-orientation": q.orientation
    }, {
      default: y(() => [_(q.$slots, "default", {
        modelValue: l(c),
        totalSteps: d.value.size,
        isNextDisabled: P.value,
        isPrevDisabled: D.value,
        isFirstStep: p.value,
        isLastStep: v.value,
        goToStep: g,
        nextStep: w,
        prevStep: C,
        hasNext: S,
        hasPrev: $
      }), xe("div", LE, " Step " + He(l(c)) + " of " + He(d.value.size), 1)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-linear",
      "data-orientation"
    ]));
  }
}), UE = HE;
const [Cs, jE] = Be("StepperItem");
var WE = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    completed: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { disabled: n, step: a, completed: r } = Me(t), { forwardRef: o } = j(), s = lf(), i = Ge(void 0, "reka-stepper-item-title"), u = Ge(void 0, "reka-stepper-item-description"), d = E(() => r.value ? "completed" : s.modelValue.value === a.value ? "active" : s.modelValue.value > a.value ? "completed" : "inactive"), c = E(() => n.value ? !1 : s.linear.value ? a.value <= s.modelValue.value || a.value === s.modelValue.value + 1 : !0);
    return jE({
      titleId: i,
      descriptionId: u,
      state: d,
      disabled: n,
      step: a,
      isFocusable: c
    }), (f, p) => (h(), x(l(X), {
      ref: l(o),
      as: f.as,
      "as-child": f.asChild,
      "aria-current": d.value === "active" ? "true" : void 0,
      "data-state": d.value,
      disabled: l(n) || !c.value ? "" : void 0,
      "data-disabled": l(n) || !c.value ? "" : void 0,
      "data-orientation": l(s).orientation.value
    }, {
      default: y(() => [_(f.$slots, "default", { state: d.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-current",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), GE = WE, KE = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Cs();
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).descriptionId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), YE = KE, XE = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Cs();
    return j(), (a, r) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(a.$slots, "default", { step: l(n).step.value }, () => [Re(" Step " + He(l(n).step.value), 1)])]),
      _: 3
    }, 16));
  }
}), JE = XE, ZE = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {
      type: String,
      required: !1
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = lf(), a = Cs();
    return j(), (r, o) => (h(), x(l(nf), A(t, {
      decorative: "",
      orientation: l(n).orientation.value,
      "data-state": l(a).state.value
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["orientation", "data-state"]));
  }
}), QE = ZE, eT = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h4"
    }
  },
  setup(e) {
    const t = e, n = Cs();
    return j(), (a, r) => (h(), x(l(X), A(t, { id: l(n).titleId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), tT = eT, nT = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = lf(), n = Cs(), a = ms(), r = E(() => Array.from(t.totalStepperItems.value));
    function o(d) {
      if (!n.disabled.value) {
        if (t.linear.value) {
          if ((n.step.value <= t.modelValue.value || n.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {
            t.changeModelValue(n.step.value);
            return;
          }
        } else if (d.ctrlKey === !1) {
          t.changeModelValue(n.step.value);
          return;
        }
        d.preventDefault();
      }
    }
    function s(d) {
      d.preventDefault(), !n.disabled.value && ((d.key === a.ENTER || d.key === a.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(n.step.value), [
        a.ARROW_LEFT,
        a.ARROW_RIGHT,
        a.ARROW_UP,
        a.ARROW_DOWN
      ].includes(d.key) && lr(d, ot(), void 0, {
        itemsArray: r.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: t.orientation.value,
        dir: t.dir.value
      }));
    }
    const { forwardRef: i, currentElement: u } = j();
    return Ce(() => {
      t.totalStepperItems.value.add(u.value);
    }), Qe(() => {
      t.totalStepperItems.value.delete(u.value);
    }), (d, c) => (h(), x(l(X), {
      ref: l(i),
      type: d.as === "button" ? "button" : void 0,
      as: d.as,
      "as-child": d.asChild,
      "data-state": l(n).state.value,
      disabled: l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-disabled": l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      tabindex: l(n).isFocusable.value ? 0 : -1,
      "aria-describedby": l(n).descriptionId,
      "aria-labelledby": l(n).titleId,
      onMousedown: Ke(o, ["left"]),
      onKeydown: Je(s, [
        "enter",
        "space",
        "left",
        "right",
        "up",
        "down"
      ])
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation",
      "tabindex",
      "aria-describedby",
      "aria-labelledby"
    ]));
  }
}), aT = nT;
const [rT, oT] = Be("SwitchRoot");
var sT = /* @__PURE__ */ b({
  __name: "SwitchRoot",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    value: {
      type: String,
      required: !1,
      default: "on"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = Me(n), o = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function s() {
      r.value || (o.value = !o.value);
    }
    const { forwardRef: i, currentElement: u } = j(), d = Rn(u), c = E(() => n.id && u.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return oT({
      modelValue: o,
      toggleCheck: s,
      disabled: r
    }), (f, p) => (h(), x(l(X), A(f.$attrs, {
      id: f.id,
      ref: l(i),
      role: "switch",
      type: f.as === "button" ? "button" : void 0,
      value: f.value,
      "aria-label": f.$attrs["aria-label"] || c.value,
      "aria-checked": l(o),
      "aria-required": f.required,
      "data-state": l(o) ? "checked" : "unchecked",
      "data-disabled": l(r) ? "" : void 0,
      "as-child": f.asChild,
      as: f.as,
      disabled: l(r),
      onClick: s,
      onKeydown: Je(Ke(s, ["prevent"]), ["enter"])
    }), {
      default: y(() => [_(f.$slots, "default", { modelValue: l(o) }), l(d) && f.name ? (h(), x(l(Vn), {
        key: 0,
        type: "checkbox",
        name: f.name,
        disabled: l(r),
        required: f.required,
        value: f.value,
        checked: !!l(o)
      }, null, 8, [
        "name",
        "disabled",
        "required",
        "value",
        "checked"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "value",
      "aria-label",
      "aria-checked",
      "aria-required",
      "data-state",
      "data-disabled",
      "as-child",
      "as",
      "disabled",
      "onKeydown"
    ]));
  }
}), lT = sT, iT = /* @__PURE__ */ b({
  __name: "SwitchThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = rT();
    return j(), (n, a) => (h(), x(l(X), {
      "data-state": l(t).modelValue?.value ? "checked" : "unchecked",
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "as-child": n.asChild,
      as: n.as
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "data-disabled",
      "as-child",
      "as"
    ]));
  }
}), uT = iT;
const [uf, dT] = Be("TabsRoot");
var cT = /* @__PURE__ */ b({
  __name: "TabsRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    activationMode: {
      type: String,
      required: !1,
      default: "automatic"
    },
    modelValue: {
      type: null,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { orientation: r, unmountOnHide: o, dir: s } = Me(n), i = yt(s);
    j();
    const u = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), d = I();
    return dT({
      modelValue: u,
      changeModelValue: (c) => {
        u.value = c;
      },
      orientation: r,
      dir: i,
      unmountOnHide: o,
      activationMode: n.activationMode,
      baseId: Ge(void 0, "reka-tabs"),
      tabsList: d
    }), (c, f) => (h(), x(l(X), {
      dir: l(i),
      "data-orientation": l(r),
      "as-child": c.asChild,
      as: c.as
    }, {
      default: y(() => [_(c.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, [
      "dir",
      "data-orientation",
      "as-child",
      "as"
    ]));
  }
}), fT = cT;
function _y(e, t) {
  return `${e}-trigger-${t}`;
}
function wy(e, t) {
  return `${e}-content-${t}`;
}
var pT = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = uf(), r = E(() => _y(a.baseId, t.value)), o = E(() => wy(a.baseId, t.value)), s = E(() => t.value === a.modelValue.value), i = I(s.value);
    return Ce(() => {
      requestAnimationFrame(() => {
        i.value = !1;
      });
    }), (u, d) => (h(), x(l(St), {
      present: u.forceMount || s.value,
      "force-mount": ""
    }, {
      default: y(({ present: c }) => [N(l(X), {
        id: o.value,
        ref: l(n),
        "as-child": u.asChild,
        as: u.as,
        role: "tabpanel",
        "data-state": s.value ? "active" : "inactive",
        "data-orientation": l(a).orientation.value,
        "aria-labelledby": r.value,
        hidden: !c,
        tabindex: "0",
        style: dt({ animationDuration: i.value ? "0s" : void 0 })
      }, {
        default: y(() => [!l(a).unmountOnHide.value || c ? _(u.$slots, "default", { key: 0 }) : Ee("v-if", !0)]),
        _: 2
      }, 1032, [
        "id",
        "as-child",
        "as",
        "data-state",
        "data-orientation",
        "aria-labelledby",
        "hidden",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), vT = pT, mT = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { loop: n } = Me(t), { forwardRef: a, currentElement: r } = j(), o = uf();
    return o.tabsList = r, (s, i) => (h(), x(l(ys), {
      "as-child": "",
      orientation: l(o).orientation.value,
      dir: l(o).dir.value,
      loop: l(n)
    }, {
      default: y(() => [N(l(X), {
        ref: l(a),
        role: "tablist",
        "as-child": s.asChild,
        as: s.as,
        "aria-orientation": l(o).orientation.value
      }, {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "aria-orientation"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), hT = mT, gT = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = uf(), r = E(() => _y(a.baseId, t.value)), o = E(() => wy(a.baseId, t.value)), s = E(() => t.value === a.modelValue.value);
    return (i, u) => (h(), x(l(bs), {
      "as-child": "",
      focusable: !i.disabled,
      active: s.value
    }, {
      default: y(() => [N(l(X), {
        id: r.value,
        ref: l(n),
        role: "tab",
        type: i.as === "button" ? "button" : void 0,
        as: i.as,
        "as-child": i.asChild,
        "aria-selected": s.value ? "true" : "false",
        "aria-controls": o.value,
        "data-state": s.value ? "active" : "inactive",
        disabled: i.disabled,
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": l(a).orientation.value,
        onMousedown: u[0] || (u[0] = Ke((d) => {
          !i.disabled && d.ctrlKey === !1 ? l(a).changeModelValue(i.value) : d.preventDefault();
        }, ["left"])),
        onKeydown: u[1] || (u[1] = Je((d) => l(a).changeModelValue(i.value), ["enter", "space"])),
        onFocus: u[2] || (u[2] = () => {
          const d = l(a).activationMode !== "manual";
          !s.value && !i.disabled && d && l(a).changeModelValue(i.value);
        })
      }, {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as",
        "as-child",
        "aria-selected",
        "aria-controls",
        "data-state",
        "disabled",
        "data-disabled",
        "data-orientation"
      ])]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), yT = gT;
const [df, bT] = Be("TagsInputRoot");
var _T = /* @__PURE__ */ b({
  __name: "TagsInputRoot",
  props: {
    modelValue: {
      type: [Array, null],
      required: !1
    },
    defaultValue: {
      type: Array,
      required: !1,
      default: () => []
    },
    addOnPaste: {
      type: Boolean,
      required: !1
    },
    addOnTab: {
      type: Boolean,
      required: !1
    },
    addOnBlur: {
      type: Boolean,
      required: !1
    },
    duplicate: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    delimiter: {
      type: null,
      required: !1,
      default: ","
    },
    dir: {
      type: String,
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: 0
    },
    id: {
      type: String,
      required: !1
    },
    convertValue: {
      type: Function,
      required: !1
    },
    displayValue: {
      type: Function,
      required: !1,
      default: (e) => e.toString()
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "invalid",
    "addTag",
    "removeTag"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { addOnPaste: r, disabled: o, delimiter: s, max: i, id: u, dir: d, addOnBlur: c, addOnTab: f } = Me(n), p = yt(d), v = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: !0,
      deep: !0
    }), { forwardRef: m, currentElement: g } = j(), { focused: w } = dw(g), C = Rn(g), { getItems: S, CollectionSlot: $ } = st({ isProvider: !0 }), B = I(), k = I(!1), P = E(() => Array.isArray(v.value) ? [...v.value] : []);
    function D(q) {
      if (q !== -1) {
        const T = S().filter((M) => M.ref.dataset.disabled !== "");
        v.value = v.value.filter((M, O) => O !== q), a("removeTag", T[q].value);
      }
    }
    return bT({
      modelValue: v,
      onAddValue: (q) => {
        const T = [...P.value], M = T.length > 0 && typeof T[0] == "object", O = T.length > 0 && typeof n.defaultValue[0] == "object";
        if ((M || O) && typeof n.convertValue != "function") throw new Error("You must provide a `convertValue` function when using objects as values.");
        const F = n.convertValue ? n.convertValue(q) : q;
        if (T.length >= i.value && i.value)
          return a("invalid", F), !1;
        if (n.duplicate)
          return v.value = [...T, F], a("addTag", F), !0;
        if (T.includes(F))
          k.value = !0;
        else return v.value = [...T, F], a("addTag", F), !0;
        return a("invalid", F), !1;
      },
      onRemoveValue: D,
      onInputKeydown: (q) => {
        const T = q.target, M = S().map((F) => F.ref).filter((F) => F.dataset.disabled !== "");
        if (!M.length) return;
        const O = M.at(-1);
        switch (q.key) {
          case "Delete":
          case "Backspace": {
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (B.value) {
              const F = M.findIndex((J) => J === B.value);
              D(F), B.value = B.value === O ? M.at(F - 1) : M.at(F + 1), q.preventDefault();
            } else q.key === "Backspace" && (B.value = O, q.preventDefault());
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const F = q.key === "ArrowRight" && p.value === "ltr" || q.key === "ArrowLeft" && p.value === "rtl", J = !F;
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (J && !B.value)
              B.value = O, q.preventDefault();
            else if (F && O && B.value === O)
              B.value = void 0, q.preventDefault();
            else if (B.value) {
              const ne = lr(q, B.value, void 0, {
                itemsArray: M,
                loop: !1,
                dir: p.value
              });
              ne && (B.value = ne), q.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            B.value && q.preventDefault();
            break;
          }
          default:
            B.value = void 0;
        }
      },
      selectedElement: B,
      isInvalidInput: k,
      addOnPaste: r,
      addOnBlur: c,
      addOnTab: f,
      dir: p,
      disabled: o,
      delimiter: s,
      max: i,
      id: u,
      displayValue: n.displayValue
    }), (q, T) => (h(), x(l($), null, {
      default: y(() => [N(l(X), {
        ref: l(m),
        dir: l(p),
        as: q.as,
        "as-child": q.asChild,
        "data-invalid": k.value ? "" : void 0,
        "data-disabled": l(o) ? "" : void 0,
        "data-focused": l(w) ? "" : void 0
      }, {
        default: y(() => [_(q.$slots, "default", { modelValue: l(v) }), l(C) && q.name ? (h(), x(l(Vn), {
          key: 0,
          name: q.name,
          value: l(v),
          required: q.required,
          disabled: l(o)
        }, null, 8, [
          "name",
          "value",
          "required",
          "disabled"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 8, [
        "dir",
        "as",
        "as-child",
        "data-invalid",
        "data-disabled",
        "data-focused"
      ])]),
      _: 3
    }));
  }
}), wT = _T, xT = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    maxLength: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = df(), { forwardRef: a, currentElement: r } = j();
    function o(v) {
      if (n.selectedElement.value = void 0, !n.addOnBlur.value) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = "");
    }
    function s(v) {
      n.addOnTab.value && c(v);
    }
    const i = I(!1);
    function u() {
      i.value = !0;
    }
    function d() {
      ke(() => {
        i.value = !1;
      });
    }
    async function c(v) {
      if (i.value || (await ke(), v.defaultPrevented)) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = ""), v.preventDefault();
    }
    function f(v) {
      if (n.isInvalidInput.value = !1, v.data === null) return;
      const m = n.delimiter.value;
      if (m === v.data || m instanceof RegExp && m.test(v.data)) {
        const w = v.target;
        if (w.value = w.value.replace(m, ""), w.value.trim() === "") {
          w.value = "";
          return;
        }
        n.onAddValue(w.value) && (w.value = "");
      }
    }
    function p(v) {
      if (n.addOnPaste.value) {
        v.preventDefault();
        const m = v.clipboardData;
        if (!m) return;
        const g = m.getData("text");
        n.delimiter.value ? g.split(n.delimiter.value).forEach((C) => {
          n.onAddValue(C);
        }) : n.onAddValue(g);
      }
    }
    return Ce(() => {
      const v = r.value.nodeName === "INPUT" ? r.value : r.value.querySelector("input");
      v && setTimeout(() => {
        t.autoFocus && v?.focus();
      }, 1);
    }), (v, m) => (h(), x(l(X), {
      id: l(n).id?.value,
      ref: l(a),
      type: "text",
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      as: v.as,
      "as-child": v.asChild,
      maxlength: v.maxLength,
      placeholder: v.placeholder,
      disabled: l(n).disabled.value,
      "data-invalid": l(n).isInvalidInput.value ? "" : void 0,
      onInput: f,
      onKeydown: [
        Je(c, ["enter"]),
        Je(s, ["tab"]),
        l(n).onInputKeydown
      ],
      onBlur: o,
      onCompositionstart: u,
      onCompositionend: d,
      onPaste: p
    }, {
      default: y(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "maxlength",
      "placeholder",
      "disabled",
      "data-invalid",
      "onKeydown"
    ]));
  }
}), CT = xT;
const [xy, ST] = Be("TagsInputItem");
var $T = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { value: n } = Me(t), a = df(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = E(() => a.selectedElement.value === o.value), u = E(() => t.disabled || a.disabled.value), d = ST({
      value: n,
      isSelected: i,
      disabled: u,
      textId: "",
      displayValue: E(() => a.displayValue(n.value))
    });
    return (c, f) => (h(), x(l(s), { value: l(n) }, {
      default: y(() => [N(l(X), {
        ref: l(r),
        as: c.as,
        "as-child": c.asChild,
        "aria-labelledby": l(d).textId,
        "aria-current": i.value,
        "data-disabled": u.value ? "" : void 0,
        "data-state": i.value ? "active" : "inactive"
      }, {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-labelledby",
        "aria-current",
        "data-disabled",
        "data-state"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), kT = $T, BT = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = df(), a = xy(), r = E(() => a.disabled?.value || n.disabled.value);
    function o() {
      if (r.value) return;
      const s = n.modelValue.value.findIndex((i) => En(i, a.value.value));
      n.onRemoveValue(s);
    }
    return (s, i) => (h(), x(l(X), A({ tabindex: "-1" }, t, {
      "aria-labelledby": l(a).textId,
      "aria-current": l(a).isSelected.value,
      "data-state": l(a).isSelected.value ? "active" : "inactive",
      "data-disabled": r.value ? "" : void 0,
      type: s.as === "button" ? "button" : void 0,
      onClick: o
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-labelledby",
      "aria-current",
      "data-state",
      "data-disabled",
      "type"
    ]));
  }
}), DT = BT, PT = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = xy();
    return j(), n.textId ||= Ge(void 0, "reka-tags-input-item-text"), (a, r) => (h(), x(l(X), A(t, { id: l(n).textId }), {
      default: y(() => [_(a.$slots, "default", {}, () => [Re(He(l(n).displayValue.value), 1)])]),
      _: 3
    }, 16, ["id"]));
  }
}), MT = PT;
const [Cy, qT] = Be("ToggleGroupRoot");
var ET = /* @__PURE__ */ b({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: {
      type: Boolean,
      required: !1,
      default: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { loop: r, rovingFocus: o, disabled: s, dir: i } = Me(n), u = yt(i), { forwardRef: d, currentElement: c } = j(), { modelValue: f, changeModelValue: p, isSingle: v } = Kh(n, a), m = Rn(c);
    return qT({
      isSingle: v,
      modelValue: f,
      changeModelValue: p,
      dir: u,
      orientation: n.orientation,
      loop: r,
      rovingFocus: o,
      disabled: s
    }), (g, w) => (h(), x(Tt(l(o) ? l(ys) : l(X)), {
      "as-child": "",
      orientation: l(o) ? g.orientation : void 0,
      dir: l(u),
      loop: l(o) ? l(r) : void 0
    }, {
      default: y(() => [N(l(X), {
        ref: l(d),
        role: "group",
        "as-child": g.asChild,
        as: g.as
      }, {
        default: y(() => [_(g.$slots, "default", { modelValue: l(f) }), l(m) && g.name ? (h(), x(Vn, {
          key: 0,
          name: g.name,
          required: g.required,
          value: l(f)
        }, null, 8, [
          "name",
          "required",
          "value"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 8, ["as-child", "as"])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), TT = ET, AT = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = Cy(null), i = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function u() {
      i.value = !i.value;
    }
    const d = E(() => i.value ? "on" : "off"), c = Rn(o);
    return (f, p) => (h(), x(l(X), {
      ref: l(r),
      type: f.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: f.as,
      "aria-pressed": l(i),
      "data-state": d.value,
      "data-disabled": f.disabled ? "" : void 0,
      disabled: f.disabled,
      onClick: u
    }, {
      default: y(() => [_(f.$slots, "default", {
        modelValue: l(i),
        disabled: f.disabled,
        pressed: l(i),
        state: d.value
      }), l(c) && f.name && !l(s) ? (h(), x(Vn, {
        key: 0,
        type: "checkbox",
        name: f.name,
        value: l(i),
        required: f.required
      }, null, 8, [
        "name",
        "value",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 8, [
      "type",
      "as-child",
      "as",
      "aria-pressed",
      "data-state",
      "data-disabled",
      "disabled"
    ]));
  }
}), Sy = AT, IT = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Cy(), a = E(() => n.disabled?.value || t.disabled), r = E(() => Cl(n.modelValue.value, t.value)), { forwardRef: o } = j();
    return (s, i) => (h(), x(Tt(l(n).rovingFocus.value ? l(bs) : l(X)), A({ "as-child": "" }, l(n).rovingFocus.value ? {
      focusable: !a.value,
      active: r.value
    } : {}), {
      default: y(() => [N(l(Sy), A(t, {
        ref: l(o),
        disabled: a.value,
        "model-value": r.value,
        "onUpdate:modelValue": i[0] || (i[0] = (u) => l(n).changeModelValue(s.value))
      }), {
        default: y((u) => [_(s.$slots, "default", oe(le(u)))]),
        _: 3
      }, 16, ["disabled", "model-value"])]),
      _: 3
    }, 16));
  }
}), OT = IT, RT = /* @__PURE__ */ b({
  __name: "TooltipArrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(D$), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VT = RT;
const [cf, FT] = Be("TooltipProvider");
var NT = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: {
      type: Number,
      required: !1,
      default: 700
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(e) {
    const t = e, { delayDuration: n, skipDelayDuration: a, disableHoverableContent: r, disableClosingTrigger: o, ignoreNonKeyboardFocus: s, disabled: i } = Me(t);
    j();
    const u = I(!0), d = I(!1), { start: c, stop: f } = dh(() => {
      u.value = !0;
    }, a, { immediate: !1 });
    return FT({
      isOpenDelayed: u,
      delayDuration: n,
      onOpen() {
        f(), u.value = !1;
      },
      onClose() {
        c();
      },
      isPointerInTransitRef: d,
      disableHoverableContent: r,
      disableClosingTrigger: o,
      disabled: i,
      ignoreNonKeyboardFocus: s
    }), (p, v) => _(p.$slots, "default");
  }
}), $y = NT;
const ky = "tooltip.open", [Hi, LT] = Be("TooltipRoot");
var zT = /* @__PURE__ */ b({
  __name: "TooltipRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: void 0
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = cf(), o = E(() => n.disableHoverableContent ?? r.disableHoverableContent.value), s = E(() => n.disableClosingTrigger ?? r.disableClosingTrigger.value), i = E(() => n.disabled ?? r.disabled.value), u = E(() => n.delayDuration ?? r.delayDuration.value), d = E(() => n.ignoreNonKeyboardFocus ?? r.ignoreNonKeyboardFocus.value), c = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    ve(c, ($) => {
      r.onClose && ($ ? (r.onOpen(), document.dispatchEvent(new CustomEvent(ky))) : r.onClose());
    });
    const f = I(!1), p = I(), v = E(() => c.value ? f.value ? "delayed-open" : "instant-open" : "closed"), { start: m, stop: g } = dh(() => {
      f.value = !0, c.value = !0;
    }, u, { immediate: !1 });
    function w() {
      g(), f.value = !1, c.value = !0;
    }
    function C() {
      g(), c.value = !1;
    }
    function S() {
      m();
    }
    return LT({
      contentId: "",
      open: c,
      stateAttribute: v,
      trigger: p,
      onTriggerChange($) {
        p.value = $;
      },
      onTriggerEnter() {
        r.isOpenDelayed.value ? S() : w();
      },
      onTriggerLeave() {
        o.value ? C() : g();
      },
      onOpen: w,
      onClose: C,
      disableHoverableContent: o,
      disableClosingTrigger: s,
      disabled: i,
      ignoreNonKeyboardFocus: d
    }), ($, B) => (h(), x(l(ir), null, {
      default: y(() => [_($.$slots, "default", { open: l(c) })]),
      _: 3
    }));
  }
}), HT = zT, UT = /* @__PURE__ */ b({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    align: {
      type: null,
      required: !1,
      default: "center"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    arrowPadding: {
      type: Number,
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Hi(), { forwardRef: o, currentElement: s } = j(), i = E(() => n.ariaLabel || s.value?.textContent), u = E(() => {
      const { ariaLabel: d, ...c } = n;
      return c;
    });
    return Ce(() => {
      zt(window, "scroll", (d) => {
        d.target?.contains(r.trigger.value) && r.onClose();
      }), zt(window, ky, r.onClose);
    }), (d, c) => (h(), x(l(Fa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: c[0] || (c[0] = (f) => a("escapeKeyDown", f)),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        l(r).disableClosingTrigger.value && l(r).trigger.value?.contains(f.target) && f.preventDefault(), a("pointerDownOutside", f);
      }),
      onFocusOutside: c[2] || (c[2] = Ke(() => {
      }, ["prevent"])),
      onDismiss: c[3] || (c[3] = (f) => l(r).onClose())
    }, {
      default: y(() => [N(l(Zr), A({
        ref: l(o),
        "data-state": l(r).stateAttribute.value
      }, {
        ...d.$attrs,
        ...u.value
      }, { style: {
        "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
        "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
        "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: y(() => [_(d.$slots, "default"), N(l($i), {
          id: l(r).contentId,
          role: "tooltip"
        }, {
          default: y(() => [Re(He(i.value), 1)]),
          _: 1
        }, 8, ["id"])]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }));
  }
}), By = UT, jT = /* @__PURE__ */ b({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  setup(e) {
    const n = he(e), { forwardRef: a, currentElement: r } = j(), { trigger: o, onClose: s } = Hi(), i = cf(), { isPointerInTransit: u, onPointerExit: d } = Nh(o, r);
    return i.isPointerInTransitRef = u, d(() => {
      s();
    }), (c, f) => (h(), x(By, A({ ref: l(a) }, l(n)), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), WT = jT, GT = /* @__PURE__ */ b({
  __name: "TooltipContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Hi(), o = me(n, a), { forwardRef: s } = j();
    return (i, u) => (h(), x(l(St), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [(h(), x(Tt(l(r).disableHoverableContent.value ? By : WT), A({ ref: l(s) }, l(o)), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), KT = GT, YT = /* @__PURE__ */ b({
  __name: "TooltipPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), XT = YT, JT = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Hi(), a = cf();
    n.contentId ||= Ge(void 0, "reka-tooltip-content");
    const { forwardRef: r, currentElement: o } = j(), s = I(!1), i = I(!1), u = E(() => n.disabled.value ? {} : {
      click: g,
      focus: v,
      pointermove: f,
      pointerleave: p,
      pointerdown: c,
      blur: m
    });
    Ce(() => {
      n.onTriggerChange(o.value);
    });
    function d() {
      setTimeout(() => {
        s.value = !1;
      }, 1);
    }
    function c() {
      n.open && !n.disableClosingTrigger.value && n.onClose(), s.value = !0, document.addEventListener("pointerup", d, { once: !0 });
    }
    function f(w) {
      w.pointerType !== "touch" && !i.value && !a.isPointerInTransitRef.value && (n.onTriggerEnter(), i.value = !0);
    }
    function p() {
      n.onTriggerLeave(), i.value = !1;
    }
    function v(w) {
      s.value || n.ignoreNonKeyboardFocus.value && !w.target.matches?.(":focus-visible") || n.onOpen();
    }
    function m() {
      n.onClose();
    }
    function g() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (w, C) => (h(), x(l(ur), {
      "as-child": "",
      reference: w.reference
    }, {
      default: y(() => [N(l(X), A({
        ref: l(r),
        "aria-describedby": l(n).open.value ? l(n).contentId : void 0,
        "data-state": l(n).stateAttribute.value,
        as: w.as,
        "as-child": t.asChild,
        "data-grace-area-trigger": ""
      }, S0(u.value)), {
        default: y(() => [_(w.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-describedby",
        "data-state",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), ZT = JT;
function Dy(e) {
  var t, n, a = "";
  if (typeof e == "string" || typeof e == "number") a += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = Dy(e[t])) && (a && (a += " "), a += n);
  } else for (n in e) e[n] && (a && (a += " "), a += n);
  return a;
}
function Py() {
  for (var e, t, n = 0, a = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = Dy(e)) && (a && (a += " "), a += t);
  return a;
}
const QT = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let a = 0; a < e.length; a++)
    n[a] = e[a];
  for (let a = 0; a < t.length; a++)
    n[e.length + a] = t[a];
  return n;
}, eA = (e, t) => ({
  classGroupId: e,
  validator: t
}), My = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), Fl = "-", cv = [], tA = "arbitrary..", nA = (e) => {
  const t = rA(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: a
  } = e;
  return {
    getClassGroupId: (s) => {
      if (s.startsWith("[") && s.endsWith("]"))
        return aA(s);
      const i = s.split(Fl), u = i[0] === "" && i.length > 1 ? 1 : 0;
      return qy(i, u, t);
    },
    getConflictingClassGroupIds: (s, i) => {
      if (i) {
        const u = a[s], d = n[s];
        return u ? d ? QT(d, u) : u : d || cv;
      }
      return n[s] || cv;
    }
  };
}, qy = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const r = e[t], o = n.nextPart.get(r);
  if (o) {
    const d = qy(e, t + 1, o);
    if (d) return d;
  }
  const s = n.validators;
  if (s === null)
    return;
  const i = t === 0 ? e.join(Fl) : e.slice(t).join(Fl), u = s.length;
  for (let d = 0; d < u; d++) {
    const c = s[d];
    if (c.validator(i))
      return c.classGroupId;
  }
}, aA = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), a = t.slice(0, n);
  return a ? tA + a : void 0;
})(), rA = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return oA(n, t);
}, oA = (e, t) => {
  const n = My();
  for (const a in e) {
    const r = e[a];
    ff(r, n, a, t);
  }
  return n;
}, ff = (e, t, n, a) => {
  const r = e.length;
  for (let o = 0; o < r; o++) {
    const s = e[o];
    sA(s, t, n, a);
  }
}, sA = (e, t, n, a) => {
  if (typeof e == "string") {
    lA(e, t, n);
    return;
  }
  if (typeof e == "function") {
    iA(e, t, n, a);
    return;
  }
  uA(e, t, n, a);
}, lA = (e, t, n) => {
  const a = e === "" ? t : Ey(t, e);
  a.classGroupId = n;
}, iA = (e, t, n, a) => {
  if (dA(e)) {
    ff(e(a), t, n, a);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(eA(n, e));
}, uA = (e, t, n, a) => {
  const r = Object.entries(e), o = r.length;
  for (let s = 0; s < o; s++) {
    const [i, u] = r[s];
    ff(u, Ey(t, i), n, a);
  }
}, Ey = (e, t) => {
  let n = e;
  const a = t.split(Fl), r = a.length;
  for (let o = 0; o < r; o++) {
    const s = a[o];
    let i = n.nextPart.get(s);
    i || (i = My(), n.nextPart.set(s, i)), n = i;
  }
  return n;
}, dA = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, cA = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
  const r = (o, s) => {
    n[o] = s, t++, t > e && (t = 0, a = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let s = n[o];
      if (s !== void 0)
        return s;
      if ((s = a[o]) !== void 0)
        return r(o, s), s;
    },
    set(o, s) {
      o in n ? n[o] = s : r(o, s);
    }
  };
}, Dd = "!", fv = ":", fA = [], pv = (e, t, n, a, r) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: a,
  isExternal: r
}), pA = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let a = (r) => {
    const o = [];
    let s = 0, i = 0, u = 0, d;
    const c = r.length;
    for (let g = 0; g < c; g++) {
      const w = r[g];
      if (s === 0 && i === 0) {
        if (w === fv) {
          o.push(r.slice(u, g)), u = g + 1;
          continue;
        }
        if (w === "/") {
          d = g;
          continue;
        }
      }
      w === "[" ? s++ : w === "]" ? s-- : w === "(" ? i++ : w === ")" && i--;
    }
    const f = o.length === 0 ? r : r.slice(u);
    let p = f, v = !1;
    f.endsWith(Dd) ? (p = f.slice(0, -1), v = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      f.startsWith(Dd) && (p = f.slice(1), v = !0)
    );
    const m = d && d > u ? d - u : void 0;
    return pv(o, v, p, m);
  };
  if (t) {
    const r = t + fv, o = a;
    a = (s) => s.startsWith(r) ? o(s.slice(r.length)) : pv(fA, !1, s, void 0, !0);
  }
  if (n) {
    const r = a;
    a = (o) => n({
      className: o,
      parseClassName: r
    });
  }
  return a;
}, vA = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, a) => {
    t.set(n, 1e6 + a);
  }), (n) => {
    const a = [];
    let r = [];
    for (let o = 0; o < n.length; o++) {
      const s = n[o], i = s[0] === "[", u = t.has(s);
      i || u ? (r.length > 0 && (r.sort(), a.push(...r), r = []), a.push(s)) : r.push(s);
    }
    return r.length > 0 && (r.sort(), a.push(...r)), a;
  };
}, mA = (e) => ({
  cache: cA(e.cacheSize),
  parseClassName: pA(e),
  sortModifiers: vA(e),
  ...nA(e)
}), hA = /\s+/, gA = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: a,
    getConflictingClassGroupIds: r,
    sortModifiers: o
  } = t, s = [], i = e.trim().split(hA);
  let u = "";
  for (let d = i.length - 1; d >= 0; d -= 1) {
    const c = i[d], {
      isExternal: f,
      modifiers: p,
      hasImportantModifier: v,
      baseClassName: m,
      maybePostfixModifierPosition: g
    } = n(c);
    if (f) {
      u = c + (u.length > 0 ? " " + u : u);
      continue;
    }
    let w = !!g, C = a(w ? m.substring(0, g) : m);
    if (!C) {
      if (!w) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      if (C = a(m), !C) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      w = !1;
    }
    const S = p.length === 0 ? "" : p.length === 1 ? p[0] : o(p).join(":"), $ = v ? S + Dd : S, B = $ + C;
    if (s.indexOf(B) > -1)
      continue;
    s.push(B);
    const k = r(C, w);
    for (let P = 0; P < k.length; ++P) {
      const D = k[P];
      s.push($ + D);
    }
    u = c + (u.length > 0 ? " " + u : u);
  }
  return u;
}, yA = (...e) => {
  let t = 0, n, a, r = "";
  for (; t < e.length; )
    (n = e[t++]) && (a = Ty(n)) && (r && (r += " "), r += a);
  return r;
}, Ty = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let a = 0; a < e.length; a++)
    e[a] && (t = Ty(e[a])) && (n && (n += " "), n += t);
  return n;
}, bA = (e, ...t) => {
  let n, a, r, o;
  const s = (u) => {
    const d = t.reduce((c, f) => f(c), e());
    return n = mA(d), a = n.cache.get, r = n.cache.set, o = i, i(u);
  }, i = (u) => {
    const d = a(u);
    if (d)
      return d;
    const c = gA(u, n);
    return r(u, c), c;
  };
  return o = s, (...u) => o(yA(...u));
}, _A = [], Bt = (e) => {
  const t = (n) => n[e] || _A;
  return t.isThemeGetter = !0, t;
}, Ay = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, Iy = /^\((?:(\w[\w-]*):)?(.+)\)$/i, wA = /^\d+\/\d+$/, xA = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, CA = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, SA = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, $A = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, kA = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Cr = (e) => wA.test(e), Le = (e) => !!e && !Number.isNaN(Number(e)), Ca = (e) => !!e && Number.isInteger(Number(e)), Ru = (e) => e.endsWith("%") && Le(e.slice(0, -1)), ta = (e) => xA.test(e), BA = () => !0, DA = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  CA.test(e) && !SA.test(e)
), Oy = () => !1, PA = (e) => $A.test(e), MA = (e) => kA.test(e), qA = (e) => !Se(e) && !$e(e), EA = (e) => ao(e, Fy, Oy), Se = (e) => Ay.test(e), Ua = (e) => ao(e, Ny, DA), Vu = (e) => ao(e, RA, Le), vv = (e) => ao(e, Ry, Oy), TA = (e) => ao(e, Vy, MA), js = (e) => ao(e, Ly, PA), $e = (e) => Iy.test(e), vo = (e) => ro(e, Ny), AA = (e) => ro(e, VA), mv = (e) => ro(e, Ry), IA = (e) => ro(e, Fy), OA = (e) => ro(e, Vy), Ws = (e) => ro(e, Ly, !0), ao = (e, t, n) => {
  const a = Ay.exec(e);
  return a ? a[1] ? t(a[1]) : n(a[2]) : !1;
}, ro = (e, t, n = !1) => {
  const a = Iy.exec(e);
  return a ? a[1] ? t(a[1]) : n : !1;
}, Ry = (e) => e === "position" || e === "percentage", Vy = (e) => e === "image" || e === "url", Fy = (e) => e === "length" || e === "size" || e === "bg-size", Ny = (e) => e === "length", RA = (e) => e === "number", VA = (e) => e === "family-name", Ly = (e) => e === "shadow", FA = () => {
  const e = Bt("color"), t = Bt("font"), n = Bt("text"), a = Bt("font-weight"), r = Bt("tracking"), o = Bt("leading"), s = Bt("breakpoint"), i = Bt("container"), u = Bt("spacing"), d = Bt("radius"), c = Bt("shadow"), f = Bt("inset-shadow"), p = Bt("text-shadow"), v = Bt("drop-shadow"), m = Bt("blur"), g = Bt("perspective"), w = Bt("aspect"), C = Bt("ease"), S = Bt("animate"), $ = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], B = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], k = () => [...B(), $e, Se], P = () => ["auto", "hidden", "clip", "visible", "scroll"], D = () => ["auto", "contain", "none"], q = () => [$e, Se, u], T = () => [Cr, "full", "auto", ...q()], M = () => [Ca, "none", "subgrid", $e, Se], O = () => ["auto", {
    span: ["full", Ca, $e, Se]
  }, Ca, $e, Se], F = () => [Ca, "auto", $e, Se], J = () => ["auto", "min", "max", "fr", $e, Se], ne = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], Q = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], W = () => ["auto", ...q()], H = () => [Cr, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...q()], U = () => [e, $e, Se], se = () => [...B(), mv, vv, {
    position: [$e, Se]
  }], ee = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], de = () => ["auto", "cover", "contain", IA, EA, {
    size: [$e, Se]
  }], pe = () => [Ru, vo, Ua], _e = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    d,
    $e,
    Se
  ], ge = () => ["", Le, vo, Ua], Te = () => ["solid", "dashed", "dotted", "double"], ce = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], R = () => [Le, Ru, mv, vv], te = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    m,
    $e,
    Se
  ], z = () => ["none", Le, $e, Se], ae = () => ["none", Le, $e, Se], ie = () => [Le, $e, Se], L = () => [Cr, "full", ...q()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [ta],
      breakpoint: [ta],
      color: [BA],
      container: [ta],
      "drop-shadow": [ta],
      ease: ["in", "out", "in-out"],
      font: [qA],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [ta],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [ta],
      shadow: [ta],
      spacing: ["px", Le],
      text: [ta],
      "text-shadow": [ta],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", Cr, Se, $e, w]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Le, Se, $e, i]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": $()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": $()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: k()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: P()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": P()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": P()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: D()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": D()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": D()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: T()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": T()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": T()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: T()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: T()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: T()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: T()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: T()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: T()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Ca, "auto", $e, Se]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [Cr, "full", "auto", i, ...q()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Le, Cr, "auto", "initial", "none", Se]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Le, $e, Se]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Le, $e, Se]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Ca, "first", "last", "none", $e, Se]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": M()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: O()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": F()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": F()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": M()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: O()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": F()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": F()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": J()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": J()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: q()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": q()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": q()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ne(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...Q(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...Q()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ne()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ne()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...Q(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...Q()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: q()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: q()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: q()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: q()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: q()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: q()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: q()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: q()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: q()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: W()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: W()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: W()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: W()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: W()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: W()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: W()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: W()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: W()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": q()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": q()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: H()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [i, "screen", ...H()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          i,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...H()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          i,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...H()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...H()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...H()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...H()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, vo, Ua]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [a, $e, Vu]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Ru, Se]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [AA, Se, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [r, $e, Se]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Le, "none", $e, Vu]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...q()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", $e, Se]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", $e, Se]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: U()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: U()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Te(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Le, "from-font", "auto", $e, Ua]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: U()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Le, "auto", $e, Se]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: q()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", $e, Se]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", $e, Se]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: se()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ee()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: de()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Ca, $e, Se],
          radial: ["", $e, Se],
          conic: [Ca, $e, Se]
        }, OA, TA]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: U()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: pe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: pe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: pe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: U()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: U()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: U()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: _e()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": _e()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": _e()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": _e()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": _e()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": _e()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": _e()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": _e()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": _e()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": _e()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": _e()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": _e()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": _e()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": _e()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": _e()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ge()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ge()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ge()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ge()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ge()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ge()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ge()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ge()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ge()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ge()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ge()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Te(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...Te(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: U()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": U()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": U()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": U()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": U()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": U()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": U()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": U()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": U()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: U()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...Te(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Le, $e, Se]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Le, vo, Ua]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: U()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          Ws,
          js
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: U()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", f, Ws, js]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": U()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ge()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: U()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Le, Ua]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": U()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ge()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": U()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", p, Ws, js]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": U()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Le, $e, Se]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...ce(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": ce()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Le]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": R()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": R()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": U()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": U()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": R()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": R()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": U()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": U()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": R()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": R()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": U()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": U()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": R()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": R()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": U()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": U()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": R()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": R()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": U()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": U()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": R()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": R()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": U()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": U()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": R()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": R()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": U()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": U()
      }],
      "mask-image-radial": [{
        "mask-radial": [$e, Se]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": R()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": R()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": U()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": U()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": B()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Le]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": R()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": R()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": U()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": U()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: se()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: ee()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: de()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", $e, Se]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          $e,
          Se
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: te()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Le, $e, Se]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Le, $e, Se]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          v,
          Ws,
          js
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": U()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Le, $e, Se]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Le, $e, Se]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Le, $e, Se]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Le, $e, Se]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Le, $e, Se]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          $e,
          Se
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": te()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Le, $e, Se]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Le, $e, Se]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Le, $e, Se]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Le, $e, Se]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Le, $e, Se]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Le, $e, Se]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Le, $e, Se]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Le, $e, Se]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": q()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": q()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": q()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", $e, Se]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Le, "initial", $e, Se]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", C, $e, Se]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Le, $e, Se]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", S, $e, Se]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [g, $e, Se]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": k()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: z()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": z()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": z()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": z()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: ae()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": ae()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": ae()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": ae()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: ie()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": ie()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": ie()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [$e, Se, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: k()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: L()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": L()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": L()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": L()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: U()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: U()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", $e, Se]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": q()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": q()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": q()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": q()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": q()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": q()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": q()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": q()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": q()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": q()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": q()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": q()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": q()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": q()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": q()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": q()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": q()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": q()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", $e, Se]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...U()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Le, vo, Ua, Vu]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...U()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, NA = /* @__PURE__ */ bA(FA);
function V(...e) {
  return NA(Py(e));
}
function P7(e, t) {
  t.value = typeof e == "function" ? e(t.value) : e;
}
function M7(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = Cn(a, s);
    if (i || i === null) return i;
    throw new Error(
      `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`
    );
  }, (s) => (Xn(a, s), s)];
}
function LA(e, t, n = {}) {
  let a, r, o, s = !0;
  const i = () => {
    s = !0, o();
  };
  ve(e, i, {
    flush: "sync",
    ...n
  });
  const u = typeof t == "function" ? t : t.get, d = typeof t == "function" ? void 0 : t.set, c = pi((f, p) => (r = f, o = p, {
    get() {
      return s && (a = u(a), s = !1), r(), a;
    },
    set(v) {
      d?.(v);
    }
  }));
  return c.trigger = i, c;
}
const Tr = /* @__PURE__ */ new WeakMap(), zy = /* @__NO_SIDE_EFFECTS__ */ (...e) => {
  var t;
  const n = e[0], a = (t = ht()) === null || t === void 0 ? void 0 : t.proxy, r = a ?? ss();
  if (r == null && !nh()) throw new Error("injectLocal must be called in setup");
  return r && Tr.has(r) && n in Tr.get(r) ? Tr.get(r)[n] : Cn(...e);
};
function zA(e, t) {
  var n;
  const a = (n = ht()) === null || n === void 0 ? void 0 : n.proxy, r = a ?? ss();
  if (r == null) throw new Error("provideLocal must be called in setup");
  Tr.has(r) || Tr.set(r, /* @__PURE__ */ Object.create(null));
  const o = Tr.get(r);
  return o[e] = t, Xn(e, t);
}
// @__NO_SIDE_EFFECTS__
function HA(e, t) {
  const n = Symbol(e.name || "InjectionState"), a = void 0;
  return [(...s) => {
    const i = e(...s);
    return zA(n, i), i;
  }, () => /* @__PURE__ */ zy(n, a)];
}
const Hy = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const UA = (e) => typeof e < "u", jA = Object.prototype.toString, WA = (e) => jA.call(e) === "[object Object]";
function hv(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function Fu(e) {
  return Array.isArray(e) ? e : [e];
}
function GA(e) {
  return mt(e) ? Wt(new Proxy({}, {
    get(t, n, a) {
      return l(Reflect.get(e.value, n, a));
    },
    set(t, n, a) {
      return mt(e.value[n]) && !mt(a) ? e.value[n].value = a : e.value[n] = a, !0;
    },
    deleteProperty(t, n) {
      return Reflect.deleteProperty(e.value, n);
    },
    has(t, n) {
      return Reflect.has(e.value, n);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  })) : Wt(e);
}
function KA(e) {
  return GA(E(e));
}
function Z(e, ...t) {
  const n = t.flat(), a = n[0];
  return KA(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(fe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
function YA(e, t, n) {
  return ve(e, t, {
    ...n,
    immediate: !0
  });
}
const Uy = Hy ? window : void 0, XA = Hy ? window.document : void 0;
function jy(e) {
  var t;
  const n = fe(e);
  return (t = n?.$el) !== null && t !== void 0 ? t : n;
}
function Eo(...e) {
  const t = (a, r, o, s) => (a.addEventListener(r, o, s), () => a.removeEventListener(r, o, s)), n = E(() => {
    const a = Fu(fe(e[0])).filter((r) => r != null);
    return a.every((r) => typeof r != "string") ? a : void 0;
  });
  return YA(() => {
    var a, r;
    return [
      (a = (r = n.value) === null || r === void 0 ? void 0 : r.map((o) => jy(o))) !== null && a !== void 0 ? a : [Uy].filter((o) => o != null),
      Fu(fe(n.value ? e[1] : e[0])),
      Fu(l(n.value ? e[2] : e[1])),
      fe(n.value ? e[3] : e[2])
    ];
  }, ([a, r, o, s], i, u) => {
    if (!a?.length || !r?.length || !o?.length) return;
    const d = WA(s) ? { ...s } : s, c = a.flatMap((f) => r.flatMap((p) => o.map((v) => t(f, p, v, d))));
    u(() => {
      c.forEach((f) => f());
    });
  }, { flush: "post" });
}
// @__NO_SIDE_EFFECTS__
function JA() {
  const e = gt(!1), t = ht();
  return t && Ce(() => {
    e.value = !0;
  }, t), e;
}
// @__NO_SIDE_EFFECTS__
function ZA(e) {
  const t = /* @__PURE__ */ JA();
  return E(() => (t.value, !!e()));
}
const QA = /* @__PURE__ */ Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function eI() {
  const e = nh() ? /* @__PURE__ */ zy(QA, null) : null;
  return typeof e == "number" ? e : void 0;
}
function Pd(e, t = {}) {
  const { window: n = Uy, ssrWidth: a = /* @__PURE__ */ eI() } = t, r = /* @__PURE__ */ ZA(() => n && "matchMedia" in n && typeof n.matchMedia == "function"), o = gt(typeof a == "number"), s = gt(), i = gt(!1), u = (d) => {
    i.value = d.matches;
  };
  return Ie(() => {
    if (o.value) {
      o.value = !r.value, i.value = fe(e).split(",").some((d) => {
        const c = d.includes("not all"), f = d.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), p = d.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let v = !!(f || p);
        return f && v && (v = a >= hv(f[1])), p && v && (v = a <= hv(p[1])), c ? !v : v;
      });
      return;
    }
    r.value && (s.value = n.matchMedia(fe(e)), i.value = s.value.matches);
  }), Eo(s, "change", u, { passive: !0 }), E(() => i.value);
}
function tI(e) {
  return JSON.parse(JSON.stringify(e));
}
function nI(e) {
  const t = ht(), n = LA(() => null, () => e ? jy(e) : t.proxy.$el);
  return $0(n.trigger), Ce(n.trigger), n;
}
function aI(e, t = {}) {
  const { threshold: n = 50, onSwipe: a, onSwipeEnd: r, onSwipeStart: o, passive: s = !0 } = t, i = Wt({
    x: 0,
    y: 0
  }), u = Wt({
    x: 0,
    y: 0
  }), d = E(() => i.x - u.x), c = E(() => i.y - u.y), { max: f, abs: p } = Math, v = E(() => f(p(d.value), p(c.value)) >= n), m = gt(!1), g = E(() => v.value ? p(d.value) > p(c.value) ? d.value > 0 ? "left" : "right" : c.value > 0 ? "up" : "down" : "none"), w = (D) => [D.touches[0].clientX, D.touches[0].clientY], C = (D, q) => {
    i.x = D, i.y = q;
  }, S = (D, q) => {
    u.x = D, u.y = q;
  }, $ = {
    passive: s,
    capture: !s
  }, B = (D) => {
    m.value && r?.(D, g.value), m.value = !1;
  }, k = [
    Eo(e, "touchstart", (D) => {
      if (D.touches.length !== 1) return;
      const [q, T] = w(D);
      C(q, T), S(q, T), o?.(D);
    }, $),
    Eo(e, "touchmove", (D) => {
      if (D.touches.length !== 1) return;
      const [q, T] = w(D);
      S(q, T), $.capture && !$.passive && Math.abs(d.value) > Math.abs(c.value) && D.preventDefault(), !m.value && v.value && (m.value = !0), m.value && a?.(D);
    }, $),
    Eo(e, ["touchend", "touchcancel"], B, $)
  ];
  return {
    isSwiping: m,
    direction: g,
    coordsStart: i,
    coordsEnd: u,
    lengthX: d,
    lengthY: c,
    stop: () => k.forEach((D) => D())
  };
}
// @__NO_SIDE_EFFECTS__
function pf(e, t, n, a = {}) {
  var r, o;
  const { clone: s = !1, passive: i = !1, eventName: u, deep: d = !1, defaultValue: c, shouldEmit: f } = a, p = ht(), v = n || p?.emit || (p == null || (r = p.$emit) === null || r === void 0 ? void 0 : r.bind(p)) || (p == null || (o = p.proxy) === null || o === void 0 || (o = o.$emit) === null || o === void 0 ? void 0 : o.bind(p?.proxy));
  let m = u;
  t || (t = "modelValue"), m = m || `update:${t.toString()}`;
  const g = (S) => s ? typeof s == "function" ? s(S) : tI(S) : S, w = () => UA(e[t]) ? g(e[t]) : c, C = (S) => {
    f ? f(S) && v(m, S) : v(m, S);
  };
  if (i) {
    const S = I(w());
    let $ = !1;
    return ve(() => e[t], (B) => {
      $ || ($ = !0, S.value = g(B), ke(() => $ = !1));
    }), ve(S, (B) => {
      !$ && (B !== e[t] || d) && C(B);
    }, { deep: d }), S;
  } else return E({
    get() {
      return w();
    },
    set(S) {
      C(S);
    }
  });
}
function q7() {
  const e = Pd("(max-width: 768px)"), t = Pd("(min-width: 769px) and (max-width: 1024px)"), n = I(!1);
  Ce(() => {
    n.value = "ontouchstart" in window || navigator.maxTouchPoints > 0;
  });
  const a = E(() => e.value || t.value);
  return {
    isMobile: e,
    isTablet: t,
    isTouchDevice: n,
    isSmallScreen: a
  };
}
function E7(e, t = {}) {
  const { threshold: n = 50, enabled: a = !0, onSwipeLeft: r, onSwipeRight: o } = t, { direction: s, lengthX: i } = aI(e, {
    passive: !0,
    onSwipeEnd() {
      a && Math.abs(i.value) >= n && (s.value === "left" && r ? r() : s.value === "right" && o && o());
    }
  });
  return {
    direction: s,
    lengthX: i
  };
}
function T7() {
  const e = I(!0);
  let t = 0, n = !1;
  const a = () => {
    n || (window.requestAnimationFrame(() => {
      const r = window.scrollY, o = r - t;
      o > 10 && r > 100 ? e.value = !1 : o < -10 && (e.value = !0), t = r, n = !1;
    }), n = !0);
  };
  return Ce(() => {
    window.addEventListener("scroll", a, { passive: !0 });
  }), Qe(() => {
    window.removeEventListener("scroll", a);
  }), {
    isVisible: e
  };
}
const rI = /* @__PURE__ */ b({
  __name: "AlertDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(eC), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gv = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, yv = Py, sn = (e, t) => (n) => {
  var a;
  if (t?.variants == null) return yv(e, n?.class, n?.className);
  const { variants: r, defaultVariants: o } = t, s = Object.keys(r).map((d) => {
    const c = n?.[d], f = o?.[d];
    if (c === null) return null;
    const p = gv(c) || gv(f);
    return r[d][p];
  }), i = n && Object.entries(n).reduce((d, c) => {
    let [f, p] = c;
    return p === void 0 || (d[f] = p), d;
  }, {}), u = t == null || (a = t.compoundVariants) === null || a === void 0 ? void 0 : a.reduce((d, c) => {
    let { class: f, className: p, ...v } = c;
    return Object.entries(v).every((m) => {
      let [g, w] = m;
      return Array.isArray(w) ? w.includes({
        ...o,
        ...i
      }[g]) : {
        ...o,
        ...i
      }[g] === w;
    }) ? [
      ...d,
      f,
      p
    ] : d;
  }, []);
  return yv(e, s, u, n?.class, n?.className);
}, Ui = /* @__PURE__ */ b({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-slot": "button",
      as: e.as,
      "as-child": e.asChild,
      class: re(l(V)(l(Yt)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Yt = sn(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        xs: "h-7 rounded px-2",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), oI = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Nx), A(l(n), {
      class: l(V)(l(Yt)(), t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sI = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Wx), A(l(n), {
      class: l(V)(l(Yt)({ variant: "outline" }), "mt-2 sm:mt-0", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lI = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(Zx), null, {
      default: y(() => [
        N(l(Xx), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(Ux), A(l(o), {
          class: l(V)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), iI = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Kx), A(l(n), {
      class: l(V)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uI = /* @__PURE__ */ b({
  __name: "AlertDialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), dI = /* @__PURE__ */ b({
  __name: "AlertDialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("flex flex-col gap-y-2 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), cI = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(nC), A(l(n), {
      class: l(V)("text-lg font-semibold", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), A7 = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(rC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), I7 = /* @__PURE__ */ b({
  __name: "ConfirmDialog",
  setup(e) {
    const { isOpen: t, close: n, cancelButton: a, actionButton: r, title: o, description: s, variant: i } = vI();
    return (u, d) => (h(), x(l(rI), { open: l(t) }, {
      default: y(() => [
        N(l(lI), {
          onEscapeKeyDown: l(n),
          onPointerDownOutside: l(n)
        }, {
          default: y(() => [
            N(l(dI), null, {
              default: y(() => [
                N(l(cI), null, {
                  default: y(() => [
                    Re(He(l(o)), 1)
                  ]),
                  _: 1
                }),
                N(l(iI), null, {
                  default: y(() => [
                    Re(He(l(s)), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            N(l(uI), null, {
              default: y(() => [
                N(l(sI), {
                  onClick: l(a).handler
                }, {
                  default: y(() => [
                    Re(He(l(a).label ?? "Cancel"), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                N(l(oI), {
                  variant: l(i),
                  onClick: l(r).handler
                }, {
                  default: y(() => [
                    Re(He(l(r).label ?? "Confirm"), 1)
                  ]),
                  _: 1
                }, 8, ["variant", "onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onEscapeKeyDown", "onPointerDownOutside"])
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), vf = I(!1), Wy = I(""), Gy = I(""), Ky = I(null), Yy = I({
  label: void 0,
  handler: () => {
  }
}), Xy = I({
  label: void 0,
  handler: () => {
  }
}), fI = (e) => {
  Wy.value = e.title, Gy.value = e.description, Ky.value = e.variant, Yy.value = bv(e.cancelAction), Xy.value = bv(e.action), pI();
}, bv = (e) => typeof e == "string" ? {
  label: e,
  handler: fl
} : typeof e == "function" ? {
  label: void 0,
  handler: e
} : typeof e == "object" && e !== void 0 ? {
  label: e.label ?? void 0,
  handler: e.handler ?? fl
} : {
  label: void 0,
  handler: fl
}, fl = () => {
  vf.value = !1;
}, pI = () => {
  vf.value = !0;
};
function vI() {
  return {
    confirmDialog: (e) => fI(e),
    title: Wy,
    description: Gy,
    variant: Ky,
    isOpen: vf,
    close: fl,
    cancelButton: Yy,
    actionButton: Xy
  };
}
const vr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t)
    n[a] = r;
  return n;
}, mI = {}, hI = { class: "h-full bg-background dark:text-white" };
function gI(e, t) {
  return h(), G("div", hI, [
    _(e.$slots, "default")
  ]);
}
const O7 = /* @__PURE__ */ vr(mI, [["render", gI]]), yI = {}, bI = { class: "sticky top-0 z-50 flex h-16 shrink-0 items-center gap-x-4 bg-background/60 px-4 backdrop-blur sm:gap-x-6 sm:px-6 lg:px-8" };
function _I(e, t) {
  return h(), G("header", bI, [
    _(e.$slots, "default")
  ]);
}
const R7 = /* @__PURE__ */ vr(yI, [["render", _I]]), wI = {}, xI = { class: "px-4 py-10 sm:px-6 lg:px-8 lg:pl-72" };
function CI(e, t) {
  return h(), G("main", xI, [
    _(e.$slots, "default")
  ]);
}
const V7 = /* @__PURE__ */ vr(wI, [["render", CI]]), SI = {};
function $I(e, t) {
  return _(e.$slots, "default");
}
const F7 = /* @__PURE__ */ vr(SI, [["render", $I]]), kI = {}, BI = { class: "hidden px-6 py-10 lg:fixed lg:inset-y-0 lg:top-16 lg:z-50 lg:flex lg:w-72 lg:flex-col" }, DI = { class: "gap-y-5 overflow-y-auto" };
function PI(e, t) {
  return h(), G("div", BI, [
    xe("div", DI, [
      _(e.$slots, "default")
    ])
  ]);
}
const N7 = /* @__PURE__ */ vr(kI, [["render", PI]]), MI = {};
function qI(e, t) {
  return _(e.$slots, "default");
}
const L7 = /* @__PURE__ */ vr(MI, [["render", qI]]);
function EI(e, t) {
  return h(), G("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    xe("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
    })
  ]);
}
const TI = {
  type: "button",
  class: "-m-2.5 p-2.5 lg:hidden"
}, z7 = /* @__PURE__ */ b({
  __name: "TwoColumnLayoutSidebarTrigger",
  setup(e) {
    return (t, n) => (h(), G("button", TI, [
      n[0] || (n[0] = xe("span", { class: "sr-only" }, "Open sidebar", -1)),
      N(l(EI), {
        class: "h-6 w-6",
        "aria-hidden": "true"
      })
    ]));
  }
});
let Md = 1;
var AI = class {
  subscribers;
  toasts;
  dismissedToasts;
  constructor() {
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
  subscribe = (e) => (this.subscribers.push(e), () => {
    const t = this.subscribers.indexOf(e);
    this.subscribers.splice(t, 1);
  });
  publish = (e) => {
    this.subscribers.forEach((t) => t(e));
  };
  addToast = (e) => {
    this.publish(e), this.toasts = [...this.toasts, e];
  };
  create = (e) => {
    const { message: t, ...n } = e, a = typeof e.id == "number" || e.id && e.id?.length > 0 ? e.id : Md++, r = this.toasts.find((s) => s.id === a), o = e.dismissible === void 0 ? !0 : e.dismissible;
    return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a), r ? this.toasts = this.toasts.map((s) => s.id === a ? (this.publish({
      ...s,
      ...e,
      id: a,
      title: t
    }), {
      ...s,
      ...e,
      id: a,
      dismissible: o,
      title: t
    }) : s) : this.addToast({
      title: t,
      ...n,
      dismissible: o,
      id: a
    }), a;
  };
  dismiss = (e) => (e ? (this.dismissedToasts.add(e), requestAnimationFrame(() => this.subscribers.forEach((t) => t({
    id: e,
    dismiss: !0
  })))) : this.toasts.forEach((t) => {
    this.subscribers.forEach((n) => n({
      id: t.id,
      dismiss: !0
    }));
  }), e);
  message = (e, t) => this.create({
    ...t,
    message: e,
    type: "default"
  });
  error = (e, t) => this.create({
    ...t,
    type: "error",
    message: e
  });
  success = (e, t) => this.create({
    ...t,
    type: "success",
    message: e
  });
  info = (e, t) => this.create({
    ...t,
    type: "info",
    message: e
  });
  warning = (e, t) => this.create({
    ...t,
    type: "warning",
    message: e
  });
  loading = (e, t) => this.create({
    ...t,
    type: "loading",
    message: e
  });
  promise = (e, t) => {
    if (!t) return;
    let n;
    t.loading !== void 0 && (n = this.create({
      ...t,
      promise: e,
      type: "loading",
      message: t.loading,
      description: typeof t.description != "function" ? t.description : void 0
    }));
    const a = Promise.resolve(e instanceof Function ? e() : e);
    let r = n !== void 0, o;
    const s = a.then(async (u) => {
      if (o = ["resolve", u], co(u))
        r = !1, this.create({
          id: n,
          type: "default",
          message: u
        });
      else if (OI(u) && !u.ok) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(`HTTP error! status: ${u.status}`) : t.error, f = typeof t.description == "function" ? await t.description(`HTTP error! status: ${u.status}`) : t.description, v = typeof c == "object" && !co(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (u instanceof Error) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(u) : t.error, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !co(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (t.success !== void 0) {
        r = !1;
        const c = typeof t.success == "function" ? await t.success(u) : t.success, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !co(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "success",
          description: f,
          ...v
        });
      }
    }).catch(async (u) => {
      if (o = ["reject", u], t.error !== void 0) {
        r = !1;
        const d = typeof t.error == "function" ? await t.error(u) : t.error, c = typeof t.description == "function" ? await t.description(u) : t.description, p = typeof d == "object" && !co(d) ? d : {
          message: d || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: c,
          ...p
        });
      }
    }).finally(() => {
      r && (this.dismiss(n), n = void 0), t.finally?.();
    }), i = () => new Promise((u, d) => s.then(() => o[0] === "reject" ? d(o[1]) : u(o[1])).catch(d));
    return typeof n != "string" && typeof n != "number" ? { unwrap: i } : Object.assign(n, { unwrap: i });
  };
  custom = (e, t) => {
    const n = t?.id || Md++, a = this.toasts.find((o) => o.id === n), r = t?.dismissible === void 0 ? !0 : t.dismissible;
    return this.dismissedToasts.has(n) && this.dismissedToasts.delete(n), a ? this.toasts = this.toasts.map((o) => o.id === n ? (this.publish({
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), {
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }) : o) : this.addToast({
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), n;
  };
  getActiveToasts = () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id));
};
const Jt = new AI();
function II(e, t) {
  const n = t?.id || Md++;
  return Jt.create({
    message: e,
    id: n,
    type: "default",
    ...t
  }), n;
}
const OI = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", RI = II, VI = () => Jt.toasts, FI = () => Jt.getActiveToasts(), Gs = Object.assign(RI, {
  success: Jt.success,
  info: Jt.info,
  warning: Jt.warning,
  error: Jt.error,
  custom: Jt.custom,
  message: Jt.message,
  promise: Jt.promise,
  dismiss: Jt.dismiss,
  loading: Jt.loading
}, {
  getHistory: VI,
  getToasts: FI
});
function Ks(e) {
  return e.label !== void 0;
}
const NI = 3, Jy = "24px", Zy = "16px", _v = 4e3, LI = 356, zI = 14, HI = 45, Qy = 200;
function UI() {
  const e = I(!1);
  return Ie(() => {
    const t = () => {
      e.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
  }), { isDocumentHidden: e };
}
function Sa(...e) {
  return e.filter(Boolean).join(" ");
}
function jI(e) {
  const [t, n] = e.split("-"), a = [];
  return t && a.push(t), n && a.push(n), a;
}
function WI(e, t) {
  const n = {};
  return [e, t].forEach((a, r) => {
    const o = r === 1, s = o ? "--mobile-offset" : "--offset", i = o ? Zy : Jy;
    function u(d) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((c) => {
        n[`${s}-${c}`] = typeof d == "number" ? `${d}px` : d;
      });
    }
    typeof a == "number" || typeof a == "string" ? u(a) : typeof a == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((d) => {
      a[d] === void 0 ? n[`${s}-${d}`] = i : n[`${s}-${d}`] = typeof a[d] == "number" ? `${a[d]}px` : a[d];
    }) : u(i);
  }), n;
}
const GI = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded",
  "data-testid"
], KI = [
  "aria-label",
  "data-disabled",
  "data-close-button-position"
];
var YI = /* @__PURE__ */ b({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    closeButtonPosition: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = I(null), o = I(null), s = I(!1), i = I(!1), u = I(!1), d = I(!1), c = I(!1), f = I(0), p = I(0), v = I(n.toast.duration || n.duration || _v), m = I(null), g = I(null), w = E(() => n.index === 0), C = E(() => n.index + 1 <= n.visibleToasts), S = E(() => n.toast.type), $ = E(() => n.toast.dismissible !== !1), B = E(() => n.toast.class || ""), k = E(() => n.descriptionClass || ""), P = E(() => {
      const R = n.toast.position || n.position, z = n.heights.filter((ae) => ae.position === R).findIndex((ae) => ae.toastId === n.toast.id);
      return z >= 0 ? z : 0;
    }), D = E(() => {
      const R = n.toast.position || n.position;
      return n.heights.filter((z) => z.position === R).reduce((z, ae, ie) => ie >= P.value ? z : z + ae.height, 0);
    }), q = E(() => P.value * n.gap + D.value || 0), T = E(() => n.toast.closeButton ?? n.closeButton), M = E(() => n.toast.duration || n.duration || _v), O = I(0), F = I(0), J = I(null), ne = E(() => n.position.split("-")), Q = E(() => ne.value[0]), W = E(() => ne.value[1]), H = E(() => typeof n.toast.title != "string"), U = E(() => typeof n.toast.description != "string"), { isDocumentHidden: se } = UI(), ee = E(() => S.value && S.value === "loading");
    Ce(() => {
      s.value = !0, v.value = M.value;
    }), Ie(async () => {
      if (!s.value || !g.value) return;
      await ke();
      const R = g.value, te = R.style.height;
      R.style.height = "auto";
      const z = R.getBoundingClientRect().height;
      R.style.height = te, p.value = z, a("update:height", {
        toastId: n.toast.id,
        height: z,
        position: n.toast.position || n.position
      });
    });
    function de() {
      i.value = !0, f.value = q.value, setTimeout(() => {
        a("removeToast", n.toast);
      }, Qy);
    }
    function pe() {
      if (ee.value || !$.value) return {};
      de(), n.toast.onDismiss?.(n.toast);
    }
    function _e(R) {
      R.button !== 2 && (ee.value || !$.value || (m.value = /* @__PURE__ */ new Date(), f.value = q.value, R.target.setPointerCapture(R.pointerId), R.target.tagName !== "BUTTON" && (u.value = !0, J.value = {
        x: R.clientX,
        y: R.clientY
      })));
    }
    function ge() {
      if (d.value || !$.value) return;
      J.value = null;
      const R = Number(g.value?.style.getPropertyValue("--swipe-amount-x").replace("px", "") || 0), te = Number(g.value?.style.getPropertyValue("--swipe-amount-y").replace("px", "") || 0), z = (/* @__PURE__ */ new Date()).getTime() - (m.value?.getTime() || 0), ae = r.value === "x" ? R : te, ie = Math.abs(ae) / z;
      if (Math.abs(ae) >= HI || ie > 0.11) {
        f.value = q.value, n.toast.onDismiss?.(n.toast), r.value === "x" ? o.value = R > 0 ? "right" : "left" : o.value = te > 0 ? "down" : "up", de(), d.value = !0;
        return;
      } else
        g.value?.style.setProperty("--swipe-amount-x", "0px"), g.value?.style.setProperty("--swipe-amount-y", "0px");
      c.value = !1, u.value = !1, r.value = null;
    }
    function Te(R) {
      if (!J.value || !$.value || (window?.getSelection()?.toString()?.length ?? !1)) return;
      const z = R.clientY - J.value.y, ae = R.clientX - J.value.x, ie = n.swipeDirections ?? jI(n.position);
      !r.value && (Math.abs(ae) > 1 || Math.abs(z) > 1) && (r.value = Math.abs(ae) > Math.abs(z) ? "x" : "y");
      let L = {
        x: 0,
        y: 0
      };
      const be = (we) => 1 / (1.5 + Math.abs(we) / 20);
      if (r.value === "y") {
        if (ie.includes("top") || ie.includes("bottom")) if (ie.includes("top") && z < 0 || ie.includes("bottom") && z > 0) L.y = z;
        else {
          const we = z * be(z);
          L.y = Math.abs(we) < Math.abs(z) ? we : z;
        }
      } else if (r.value === "x" && (ie.includes("left") || ie.includes("right")))
        if (ie.includes("left") && ae < 0 || ie.includes("right") && ae > 0) L.x = ae;
        else {
          const we = ae * be(ae);
          L.x = Math.abs(we) < Math.abs(ae) ? we : ae;
        }
      (Math.abs(L.x) > 0 || Math.abs(L.y) > 0) && (c.value = !0), g.value?.style.setProperty("--swipe-amount-x", `${L.x}px`), g.value?.style.setProperty("--swipe-amount-y", `${L.y}px`);
    }
    Ce(() => {
      if (s.value = !0, !g.value) return;
      const R = g.value.getBoundingClientRect().height;
      p.value = R;
      const te = [{
        toastId: n.toast.id,
        height: R,
        position: n.toast.position
      }, ...n.heights];
      a("update:heights", te);
    }), sr(() => {
      g.value && a("removeToast", n.toast);
    }), Ie((R) => {
      if (n.toast.promise && S.value === "loading" || n.toast.duration === 1 / 0 || n.toast.type === "loading") return;
      let te;
      const z = () => {
        if (F.value < O.value) {
          const ie = (/* @__PURE__ */ new Date()).getTime() - O.value;
          v.value = v.value - ie;
        }
        F.value = (/* @__PURE__ */ new Date()).getTime();
      }, ae = () => {
        v.value !== 1 / 0 && (O.value = (/* @__PURE__ */ new Date()).getTime(), te = setTimeout(() => {
          n.toast.onAutoClose?.(n.toast), de();
        }, v.value));
      };
      n.expanded || n.interacting || se.value ? z() : ae(), R(() => {
        clearTimeout(te);
      });
    }), ve(() => n.toast.delete, (R) => {
      R !== void 0 && R && (de(), n.toast.onDismiss?.(n.toast));
    }, { deep: !0 });
    function ce() {
      u.value = !1, r.value = null, J.value = null;
    }
    return (R, te) => (h(), G("li", {
      tabindex: "0",
      ref_key: "toastRef",
      ref: g,
      class: re(l(Sa)(n.class, B.value, R.classes?.toast, R.toast.classes?.toast, R.classes?.[S.value], R.toast?.classes?.[S.value])),
      "data-sonner-toast": "",
      "data-rich-colors": R.toast.richColors ?? R.defaultRichColors,
      "data-styled": !(R.toast.component || R.toast?.unstyled || R.unstyled),
      "data-mounted": s.value,
      "data-promise": !!R.toast.promise,
      "data-swiped": c.value,
      "data-removed": i.value,
      "data-visible": C.value,
      "data-y-position": Q.value,
      "data-x-position": W.value,
      "data-index": R.index,
      "data-front": w.value,
      "data-swiping": u.value,
      "data-dismissible": $.value,
      "data-type": S.value,
      "data-invert": R.toast.invert || R.invert,
      "data-swipe-out": d.value,
      "data-swipe-direction": o.value,
      "data-expanded": !!(R.expanded || R.expandByDefault && s.value),
      "data-testid": R.toast.testId,
      style: dt({
        "--index": R.index,
        "--toasts-before": R.index,
        "--z-index": R.toasts.length - R.index,
        "--offset": `${i.value ? f.value : q.value}px`,
        "--initial-height": R.expandByDefault ? "auto" : `${p.value}px`,
        ...R.style,
        ...n.toast.style
      }),
      onDragend: ce,
      onPointerdown: _e,
      onPointerup: ge,
      onPointermove: Te
    }, [T.value && !R.toast.component && S.value !== "loading" ? (h(), G("button", {
      key: 0,
      "aria-label": R.closeButtonAriaLabel || "Close toast",
      "data-disabled": ee.value,
      "data-close-button": "true",
      "data-close-button-position": R.closeButtonPosition,
      class: re(l(Sa)(R.classes?.closeButton, R.toast?.classes?.closeButton)),
      onClick: pe
    }, [R.icons?.close ? (h(), x(Tt(R.icons?.close), { key: 0 })) : _(R.$slots, "close-icon", { key: 1 })], 10, KI)) : Ee("v-if", !0), R.toast.component ? (h(), x(Tt(R.toast.component), A({ key: 1 }, R.toast.componentProps, {
      onCloseToast: pe,
      isPaused: R.$props.expanded || R.$props.interacting || l(se)
    }), null, 16, ["isPaused"])) : (h(), G(Ye, { key: 2 }, [
      S.value !== "default" || R.toast.icon || R.toast.promise ? (h(), G("div", {
        key: 0,
        "data-icon": "",
        class: re(l(Sa)(R.classes?.icon, R.toast?.classes?.icon))
      }, [R.toast.icon ? (h(), x(Tt(R.toast.icon), { key: 0 })) : (h(), G(Ye, { key: 1 }, [S.value === "loading" ? _(R.$slots, "loading-icon", { key: 0 }) : S.value === "success" ? _(R.$slots, "success-icon", { key: 1 }) : S.value === "error" ? _(R.$slots, "error-icon", { key: 2 }) : S.value === "warning" ? _(R.$slots, "warning-icon", { key: 3 }) : S.value === "info" ? _(R.$slots, "info-icon", { key: 4 }) : Ee("v-if", !0)], 64))], 2)) : Ee("v-if", !0),
      xe("div", {
        "data-content": "",
        class: re(l(Sa)(R.classes?.content, R.toast?.classes?.content))
      }, [xe("div", {
        "data-title": "",
        class: re(l(Sa)(R.classes?.title, R.toast.classes?.title))
      }, [H.value ? (h(), x(Tt(R.toast.title), oe(A({ key: 0 }, R.toast.componentProps)), null, 16)) : (h(), G(Ye, { key: 1 }, [Re(He(R.toast.title), 1)], 64))], 2), R.toast.description ? (h(), G("div", {
        key: 0,
        "data-description": "",
        class: re(l(Sa)(R.descriptionClass, k.value, R.classes?.description, R.toast.classes?.description))
      }, [U.value ? (h(), x(Tt(R.toast.description), oe(A({ key: 0 }, R.toast.componentProps)), null, 16)) : (h(), G(Ye, { key: 1 }, [Re(He(R.toast.description), 1)], 64))], 2)) : Ee("v-if", !0)], 2),
      R.toast.cancel ? (h(), G("button", {
        key: 1,
        style: dt(R.toast.cancelButtonStyle || R.cancelButtonStyle),
        class: re(l(Sa)(R.classes?.cancelButton, R.toast.classes?.cancelButton)),
        "data-button": "",
        "data-cancel": "",
        onClick: te[0] || (te[0] = (z) => {
          l(Ks)(R.toast.cancel) && $.value && (R.toast.cancel.onClick?.(z), de());
        })
      }, He(l(Ks)(R.toast.cancel) ? R.toast.cancel?.label : R.toast.cancel), 7)) : Ee("v-if", !0),
      R.toast.action ? (h(), G("button", {
        key: 2,
        style: dt(R.toast.actionButtonStyle || R.actionButtonStyle),
        class: re(l(Sa)(R.classes?.actionButton, R.toast.classes?.actionButton)),
        "data-button": "",
        "data-action": "",
        onClick: te[1] || (te[1] = (z) => {
          l(Ks)(R.toast.action) && (R.toast.action.onClick?.(z), !z.defaultPrevented && de());
        })
      }, He(l(Ks)(R.toast.action) ? R.toast.action?.label : R.toast.action), 7)) : Ee("v-if", !0)
    ], 64))], 46, GI));
  }
}), XI = YI, Ss = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t) n[a] = r;
  return n;
};
const JI = {}, ZI = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function QI(e, t) {
  return h(), G("svg", ZI, t[0] || (t[0] = [xe("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), xe("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var eO = /* @__PURE__ */ Ss(JI, [["render", QI]]);
const tO = ["data-visible"], nO = { class: "sonner-spinner" };
var aO = /* @__PURE__ */ b({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(e) {
    const t = Array(12).fill(0);
    return (n, a) => (h(), G("div", {
      class: "sonner-loading-wrapper",
      "data-visible": n.visible
    }, [xe("div", nO, [(h(!0), G(Ye, null, Lt(l(t), (r) => (h(), G("div", {
      key: `spinner-bar-${r}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, tO));
  }
}), rO = aO;
const oO = {}, sO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function lO(e, t) {
  return h(), G("svg", sO, t[0] || (t[0] = [xe("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var iO = /* @__PURE__ */ Ss(oO, [["render", lO]]);
const uO = {}, dO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function cO(e, t) {
  return h(), G("svg", dO, t[0] || (t[0] = [xe("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var fO = /* @__PURE__ */ Ss(uO, [["render", cO]]);
const pO = {}, vO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function mO(e, t) {
  return h(), G("svg", vO, t[0] || (t[0] = [xe("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var hO = /* @__PURE__ */ Ss(pO, [["render", mO]]);
const gO = {}, yO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function bO(e, t) {
  return h(), G("svg", yO, t[0] || (t[0] = [xe("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var _O = /* @__PURE__ */ Ss(gO, [["render", bO]]);
const wO = ["aria-label"], xO = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position"
], CO = typeof window < "u" && typeof document < "u";
function SO() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const e = document.documentElement.getAttribute("dir");
  return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e;
}
var $O = /* @__PURE__ */ b({
  name: "Toaster",
  inheritAttrs: !1,
  __name: "Toaster",
  props: {
    id: {},
    invert: {
      type: Boolean,
      default: !1
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    closeButtonPosition: { default: "top-left" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: !1
    },
    expand: {
      type: Boolean,
      default: !1
    },
    duration: {},
    gap: { default: zI },
    visibleToasts: { default: NI },
    closeButton: {
      type: Boolean,
      default: !1
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: Jy },
    mobileOffset: { default: Zy },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(e) {
    const t = e, n = k0(), a = I([]), r = E(() => t.id ? a.value.filter((M) => M.toasterId === t.id) : a.value.filter((M) => !M.toasterId));
    function o(M, O) {
      return r.value.filter((F) => !F.position && O === 0 || F.position === M);
    }
    const s = E(() => {
      const M = r.value.filter((O) => O.position).map((O) => O.position);
      return M.length > 0 ? Array.from(new Set([t.position].concat(M))) : [t.position];
    }), i = E(() => {
      const M = {};
      return s.value.forEach((O) => {
        M[O] = a.value.filter((F) => F.position === O);
      }), M;
    }), u = I([]), d = I({}), c = I(!1);
    Ie(() => {
      s.value.forEach((M) => {
        M in d.value || (d.value[M] = !1);
      });
    });
    const f = I(t.theme !== "system" ? t.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = I(null), v = I(null), m = I(!1), g = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function w(M) {
      a.value.find((O) => O.id === M.id)?.delete || Jt.dismiss(M.id), a.value = a.value.filter(({ id: O }) => O !== M.id), setTimeout(() => {
        a.value.find((O) => O.id === M.id) || (u.value = u.value.filter((O) => O.toastId !== M.id));
      }, Qy + 50);
    }
    function C(M) {
      m.value && !M.currentTarget?.contains?.(M.relatedTarget) && (m.value = !1, v.value && (v.value.focus({ preventScroll: !0 }), v.value = null));
    }
    function S(M) {
      M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || m.value || (m.value = !0, v.value = M.relatedTarget);
    }
    function $(M) {
      M.target && M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || (c.value = !0);
    }
    Ie((M) => {
      const O = Jt.subscribe((F) => {
        if (F.dismiss) {
          requestAnimationFrame(() => {
            a.value = a.value.map((J) => J.id === F.id ? {
              ...J,
              delete: !0
            } : J);
          });
          return;
        }
        ke(() => {
          const J = a.value.findIndex((ne) => ne.id === F.id);
          J !== -1 ? a.value = [
            ...a.value.slice(0, J),
            {
              ...a.value[J],
              ...F
            },
            ...a.value.slice(J + 1)
          ] : a.value = [F, ...a.value];
        });
      });
      M(O);
    }), Ie((M) => {
      if (typeof window > "u") return;
      if (t.theme !== "system") {
        f.value = t.theme;
        return;
      }
      const O = window.matchMedia("(prefers-color-scheme: dark)"), F = (ne) => {
        f.value = ne ? "dark" : "light";
      };
      F(O.matches);
      const J = (ne) => {
        F(ne.matches);
      };
      try {
        O.addEventListener("change", J);
      } catch {
        O.addListener(J);
      }
      M(() => {
        try {
          O.removeEventListener("change", J);
        } catch {
          O.removeListener(J);
        }
      });
    }), Ie(() => {
      p.value && v.value && (v.value.focus({ preventScroll: !0 }), v.value = null, m.value = !1);
    }), Ie(() => {
      a.value.length <= 1 && Object.keys(d.value).forEach((M) => {
        d.value[M] = !1;
      });
    }), Ie((M) => {
      function O(F) {
        const J = t.hotkey.every((W) => F[W] || F.code === W), ne = Array.isArray(p.value) ? p.value[0] : p.value;
        J && (s.value.forEach((W) => {
          d.value[W] = !0;
        }), ne?.focus());
        const Q = document.activeElement === p.value || ne?.contains(document.activeElement);
        F.code === "Escape" && Q && s.value.forEach((W) => {
          d.value[W] = !1;
        });
      }
      CO && (document.addEventListener("keydown", O), M(() => {
        document.removeEventListener("keydown", O);
      }));
    });
    function B(M) {
      const O = M.currentTarget, F = O.getAttribute("data-y-position") + "-" + O.getAttribute("data-x-position");
      d.value[F] = !0;
    }
    function k(M) {
      if (!c.value) {
        const O = M.currentTarget, F = O.getAttribute("data-y-position") + "-" + O.getAttribute("data-x-position");
        d.value[F] = !1;
      }
    }
    function P() {
      Object.keys(d.value).forEach((M) => {
        d.value[M] = !1;
      });
    }
    function D() {
      c.value = !1;
    }
    function q(M) {
      u.value = M;
    }
    function T(M) {
      const O = u.value.findIndex((F) => F.toastId === M.toastId);
      if (O !== -1) u.value[O] = M;
      else {
        const F = u.value.findIndex((J) => J.position === M.position);
        F !== -1 ? u.value.splice(F, 0, M) : u.value.unshift(M);
      }
    }
    return (M, O) => (h(), G(Ye, null, [Ee(" Remove item from normal navigation flow, only available via hotkey "), xe("section", {
      "aria-label": `${M.containerAriaLabel} ${l(g)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(h(!0), G(Ye, null, Lt(s.value, (F, J) => (h(), G("ol", A({
      key: F,
      ref_for: !0,
      ref_key: "listRef",
      ref: p,
      "data-sonner-toaster": "",
      "data-sonner-theme": f.value,
      class: t.class,
      dir: M.dir === "auto" ? SO() : M.dir,
      tabIndex: -1,
      "data-theme": M.theme,
      "data-rich-colors": M.richColors,
      "data-y-position": F.split("-")[0],
      "data-x-position": F.split("-")[1],
      style: {
        "--front-toast-height": `${u.value[0]?.height || 0}px`,
        "--width": `${l(LI)}px`,
        "--gap": `${M.gap}px`,
        ...M.style,
        ...l(n).style,
        ...l(WI)(M.offset, M.mobileOffset)
      }
    }, { ref_for: !0 }, M.$attrs, {
      onBlur: C,
      onFocus: S,
      onMouseenter: B,
      onMousemove: B,
      onMouseleave: k,
      onDragend: P,
      onPointerdown: $,
      onPointerup: D
    }), [(h(!0), G(Ye, null, Lt(o(F, J), (ne, Q) => (h(), x(XI, {
      key: ne.id,
      heights: u.value,
      icons: M.icons,
      index: Q,
      toast: ne,
      defaultRichColors: M.richColors,
      duration: M.toastOptions?.duration ?? M.duration,
      class: re(M.toastOptions?.class ?? ""),
      descriptionClass: M.toastOptions?.descriptionClass,
      invert: M.invert,
      visibleToasts: M.visibleToasts,
      closeButton: M.toastOptions?.closeButton ?? M.closeButton,
      interacting: c.value,
      position: F,
      closeButtonPosition: M.toastOptions?.closeButtonPosition ?? M.closeButtonPosition,
      style: dt(M.toastOptions?.style),
      unstyled: M.toastOptions?.unstyled,
      classes: M.toastOptions?.classes,
      cancelButtonStyle: M.toastOptions?.cancelButtonStyle,
      actionButtonStyle: M.toastOptions?.actionButtonStyle,
      "close-button-aria-label": M.toastOptions?.closeButtonAriaLabel,
      toasts: i.value[F],
      expandByDefault: M.expand,
      gap: M.gap,
      expanded: d.value[F] || !1,
      swipeDirections: t.swipeDirections,
      "onUpdate:heights": q,
      "onUpdate:height": T,
      onRemoveToast: w
    }, {
      "close-icon": y(() => [_(M.$slots, "close-icon", {}, () => [N(eO)])]),
      "loading-icon": y(() => [_(M.$slots, "loading-icon", {}, () => [N(rO, { visible: ne.type === "loading" }, null, 8, ["visible"])])]),
      "success-icon": y(() => [_(M.$slots, "success-icon", {}, () => [N(iO)])]),
      "error-icon": y(() => [_(M.$slots, "error-icon", {}, () => [N(_O)])]),
      "warning-icon": y(() => [_(M.$slots, "warning-icon", {}, () => [N(hO)])]),
      "info-icon": y(() => [_(M.$slots, "info-icon", {}, () => [N(fO)])]),
      _: 2
    }, 1032, [
      "heights",
      "icons",
      "index",
      "toast",
      "defaultRichColors",
      "duration",
      "class",
      "descriptionClass",
      "invert",
      "visibleToasts",
      "closeButton",
      "interacting",
      "position",
      "closeButtonPosition",
      "style",
      "unstyled",
      "classes",
      "cancelButtonStyle",
      "actionButtonStyle",
      "close-button-aria-label",
      "toasts",
      "expandByDefault",
      "gap",
      "expanded",
      "swipeDirections"
    ]))), 128))], 16, xO))), 128))], 8, wO)], 2112));
  }
}), eb = $O;
const wv = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), kO = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, a) => a ? a.toUpperCase() : n.toLowerCase()
), BO = (e) => {
  const t = kO(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, DO = (...e) => e.filter((t, n, a) => !!t && t.trim() !== "" && a.indexOf(t) === n).join(" ").trim(), xv = (e) => e === "";
var mo = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const PO = ({
  name: e,
  iconNode: t,
  absoluteStrokeWidth: n,
  "absolute-stroke-width": a,
  strokeWidth: r,
  "stroke-width": o,
  size: s = mo.width,
  color: i = mo.stroke,
  ...u
}, { slots: d }) => an(
  "svg",
  {
    ...mo,
    ...u,
    width: s,
    height: s,
    stroke: i,
    "stroke-width": xv(n) || xv(a) || n === !0 || a === !0 ? Number(r || o || mo["stroke-width"]) * 24 / Number(s) : r || o || mo["stroke-width"],
    class: DO(
      "lucide",
      u.class,
      ...e ? [`lucide-${wv(BO(e))}-icon`, `lucide-${wv(e)}`] : ["lucide-icon"]
    )
  },
  [...t.map((c) => an(...c)), ...d.default ? [d.default()] : []]
);
const It = (e, t) => (n, { slots: a, attrs: r }) => an(
  PO,
  {
    ...r,
    ...n,
    iconNode: t,
    name: e
  },
  a
);
const oo = It("check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
const ji = It("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
const Wi = It("chevron-left", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
const za = It("chevron-right", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
const MO = It("chevron-up", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }]
]);
const tb = It("circle-check", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
const mf = It("circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
const nb = It("ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
const qO = It("grip-vertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
const ab = It("info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
const hf = It("loader-circle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
const gf = It("minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
const rb = It("octagon-x", [
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  [
    "path",
    {
      d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z",
      key: "2d38gg"
    }
  ],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
const EO = It("panel-left", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
const TO = It("plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
const AO = It("search", [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
]);
const ob = It("triangle-alert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
const so = It("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
function IO(e, t) {
  return Object.entries(e).map(([n, a]) => t === "key" ? n : t === "both" ? `${n}: ${a}` : a).join(`
`);
}
function OO() {
  return {
    info: (e) => {
      Gs.info("FYI", {
        description: e
      });
    },
    success: (e) => {
      Gs.success("Success", {
        description: e
      });
    },
    warning: (e) => {
      Gs.warning("Warning", {
        description: e
      });
    },
    error: (e, t = "value") => {
      Gs.error("Oh snap! Some errors were encountered.", {
        description: IO(e, t)
      });
    }
  };
}
const H7 = /* @__PURE__ */ b({
  __name: "Flasher",
  props: {
    info: {},
    success: {},
    warning: {},
    errors: {},
    objectFormat: { default: "value" }
  },
  setup(e) {
    const t = e, {
      info: n,
      success: a,
      warning: r,
      error: o
    } = OO();
    return ve(
      () => t.info,
      (s) => {
        s && n(t.info);
      },
      {
        immediate: !0
      }
    ), ve(
      () => t.success,
      (s) => {
        s && a(t.success);
      },
      { immediate: !0 }
    ), ve(
      () => t.warning,
      (s) => {
        s && r(t.warning);
      },
      { immediate: !0 }
    ), ve(
      () => t.errors,
      () => {
        t.errors !== void 0 && Object.keys(t.errors).length > 0 && o(t.errors, t.objectFormat);
      }
    ), (s, i) => (h(), x(l(eb), {
      class: "toaster group",
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, {
      "success-icon": y(() => [
        N(l(tb), { class: "size-4" })
      ]),
      "info-icon": y(() => [
        N(l(ab), { class: "size-4" })
      ]),
      "warning-icon": y(() => [
        N(l(ob), { class: "size-4" })
      ]),
      "error-icon": y(() => [
        N(l(rb), { class: "size-4" })
      ]),
      "loading-icon": y(() => [
        xe("div", null, [
          N(l(hf), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": y(() => [
        N(l(so), { class: "size-4" })
      ]),
      _: 1
    }));
  }
}), RO = { class: "flex items-center justify-between space-y-2" }, VO = { class: "flex items-center space-x-2" }, U7 = /* @__PURE__ */ b({
  __name: "Heading",
  props: {
    as: { default: "h2" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", RO, [
      (h(), x(Tt(e.as), {
        class: re(l(V)("text-3xl font-bold tracking-tight", t.class))
      }, {
        default: y(() => [
          _(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])),
      xe("div", VO, [
        _(n.$slots, "actions")
      ])
    ]));
  }
}), FO = /* @__PURE__ */ b({
  __name: "Accordion",
  props: {
    collapsible: { type: Boolean },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(H1), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), j7 = /* @__PURE__ */ b({
  __name: "Accord",
  props: {
    content: {},
    collapsible: { type: Boolean, default: !0 },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: { default: "single" },
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(FO, oe(le(l(r))), {
      default: y(() => [
        (h(!0), G(Ye, null, Lt(e.content, (i, u) => (h(), x(l(LO), {
          key: u,
          value: "item-" + u
        }, {
          default: y(() => [
            N(l(zO), null, {
              default: y(() => [
                _(o.$slots, u + ".title", { item: i }, () => [
                  Re(He(i.title), 1)
                ])
              ]),
              _: 2
            }, 1024),
            N(l(NO), null, {
              default: y(() => [
                _(o.$slots, u + ".content", { item: i }, () => [
                  Re(He(i.content), 1)
                ])
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1032, ["value"]))), 128))
      ]),
      _: 3
    }, 16));
  }
}), NO = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(K1), A(l(n), { class: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down" }), {
      default: y(() => [
        xe("div", {
          class: re(l(V)("pt-0 pb-4", t.class))
        }, [
          _(a.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16));
  }
}), LO = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(W1), A(l(a), {
      class: l(V)("border-b", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), zO = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(X1), { class: "flex" }, {
      default: y(() => [
        N(l(Z1), A(l(n), {
          class: l(V)(
            "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
            t.class
          )
        }), {
          default: y(() => [
            _(a.$slots, "default"),
            _(a.$slots, "icon", {}, () => [
              N(l(ji), { class: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), W7 = /* @__PURE__ */ b({
  __name: "Tip",
  props: {
    tooltip: {},
    indicator: { type: Boolean },
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(HO), null, {
      default: y(() => [
        N(l(sb), oe(le(l(r))), {
          default: y(() => [
            N(l(ib), {
              class: re(e.indicator ? "underline decoration-dotted underline-offset-4" : "")
            }, {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(lb), oe(le(o.$attrs)), {
              default: y(() => [
                _(o.$slots, "tooltip", {}, () => [
                  Re(He(e.tooltip), 1)
                ])
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), sb = /* @__PURE__ */ b({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(HT), A({ "data-slot": "tooltip" }, l(r)), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), lb = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(XT), null, {
      default: y(() => [
        N(l(KT), A({ "data-slot": "tooltip-content" }, { ...l(o), ...s.$attrs }, {
          class: l(V)(
            "z-50 w-fit animate-in rounded-md bg-foreground px-3 py-1.5 text-xs text-balance text-background fade-in-0 zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(VT), { class: "z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] bg-foreground fill-foreground" })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), HO = /* @__PURE__ */ b({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 0 },
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l($y), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ib = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(ZT), A({ "data-slot": "tooltip-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), G7 = /* @__PURE__ */ b({
  __name: "Alert",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)(l(UO)({ variant: e.variant }), t.class)),
      role: "alert"
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), K7 = /* @__PURE__ */ b({
  __name: "AlertDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("text-sm [&_p]:leading-relaxed", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Y7 = /* @__PURE__ */ b({
  __name: "AlertTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("h5", {
      class: re(l(V)("mb-1 leading-none font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), UO = sn(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), X7 = /* @__PURE__ */ b({
  __name: "AspectRatio",
  props: {
    ratio: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(sC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), J7 = /* @__PURE__ */ b({
  __name: "Avatar",
  props: {
    class: {},
    size: { default: "sm" },
    shape: { default: "circle" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(uC), {
      class: re(l(V)(l(jO)({ size: e.size, shape: e.shape }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Z7 = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(cC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Q7 = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {},
    referrerPolicy: {},
    crossOrigin: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(vC), A(t, { class: "h-full w-full object-cover" }), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), jO = sn(
  "inline-flex items-center justify-center font-normal text-foreground select-none shrink-0 bg-secondary overflow-hidden",
  {
    variants: {
      size: {
        sm: "h-10 w-10 text-xs",
        base: "h-16 w-16 text-2xl",
        lg: "h-32 w-32 text-5xl"
      },
      shape: {
        circle: "rounded-full",
        square: "rounded-md"
      }
    }
  }
), eH = /* @__PURE__ */ b({
  __name: "Badge",
  props: {
    variant: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)(l(WO)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), WO = sn(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        success: "border-transparent bg-success text-success-foreground shadow hover:bg-success/80",
        warning: "border-transparent bg-warning text-warning-foreground shadow hover:bg-warning/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), tH = /* @__PURE__ */ b({
  __name: "Breadcrumb",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("nav", {
      "aria-label": "breadcrumb",
      class: re(t.class)
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), nH = /* @__PURE__ */ b({
  __name: "BreadcrumbEllipsis",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      role: "presentation",
      "aria-hidden": "true",
      class: re(l(V)("flex h-9 w-9 items-center justify-center", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(nb), { class: "h-4 w-4" })
      ]),
      a[0] || (a[0] = xe("span", { class: "sr-only" }, "More", -1))
    ], 2));
  }
}), aH = /* @__PURE__ */ b({
  __name: "BreadcrumbItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("li", {
      class: re(l(V)("inline-flex items-center gap-1.5", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), rH = /* @__PURE__ */ b({
  __name: "BreadcrumbLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      as: e.as,
      "as-child": e.asChild,
      class: re(l(V)("transition-colors hover:text-foreground", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), oH = /* @__PURE__ */ b({
  __name: "BreadcrumbList",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("ol", {
      class: re(
        l(V)(
          "flex flex-wrap items-center gap-1.5 text-sm break-words text-muted-foreground sm:gap-2.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), sH = /* @__PURE__ */ b({
  __name: "BreadcrumbPage",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      role: "link",
      "aria-disabled": "true",
      "aria-current": "page",
      class: re(l(V)("font-normal text-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), lH = /* @__PURE__ */ b({
  __name: "BreadcrumbSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("li", {
      role: "presentation",
      "aria-hidden": "true",
      class: re(l(V)("[&>svg]:size-3.5", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(za))
      ])
    ], 2));
  }
}), GO = ["data-orientation"], iH = /* @__PURE__ */ b({
  __name: "ButtonGroup",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      class: re(l(V)(l(KO)({ orientation: t.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, GO));
  }
}), Gi = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(nf), A({ "data-slot": "separator" }, l(n), {
      class: l(V)(
        "shrink-0 bg-border data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), uH = /* @__PURE__ */ b({
  __name: "ButtonGroupSeparator",
  props: {
    orientation: { default: "vertical" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Gi), A({ "data-slot": "button-group-separator" }, l(n), {
      orientation: t.orientation,
      class: l(V)("relative !m-0 self-stretch bg-input data-[orientation=vertical]:h-auto", t.class)
    }), null, 16, ["orientation", "class"]));
  }
}), dH = /* @__PURE__ */ b({
  __name: "ButtonGroupText",
  props: {
    class: {},
    orientation: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      as: e.as,
      "as-child": e.asChild,
      class: re(
        l(V)(
          "flex items-center gap-2 rounded-md border bg-muted px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as", "as-child", "class"]));
  }
}), KO = sn(
  "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*:focus-visible]:relative [&>*:focus-visible]:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  {
    variants: {
      orientation: {
        horizontal: "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
        vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
      }
    },
    defaultVariants: {
      orientation: "horizontal"
    }
  }
), YO = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, cH = /* @__PURE__ */ b({
  __name: "Calendar",
  props: {
    defaultValue: {},
    defaultPlaceholder: {},
    placeholder: {},
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    modelValue: {},
    multiple: { type: Boolean },
    disableDaysOutsideCurrentView: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(SC), A({
      class: l(V)("p-3", n.class)
    }, l(o)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(n3), null, {
          default: y(() => [
            N(l(o3)),
            N(l(a3)),
            N(l(r3))
          ]),
          _: 1
        }),
        xe("div", YO, [
          (h(!0), G(Ye, null, Lt(u, (c) => (h(), x(l(ZO), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(e3), null, {
                default: y(() => [
                  N(l(Cv), null, {
                    default: y(() => [
                      (h(!0), G(Ye, null, Lt(d, (f) => (h(), x(l(t3), { key: f }, {
                        default: y(() => [
                          Re(He(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(QO), null, {
                default: y(() => [
                  (h(!0), G(Ye, null, Lt(c.rows, (f, p) => (h(), x(l(Cv), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (h(!0), G(Ye, null, Lt(f, (v) => (h(), x(l(XO), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(JO), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), XO = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(kC), A({
      class: l(V)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:rounded-md [&:has([data-selected])]:bg-accent [&:has([data-selected][data-outside-view])]:bg-accent/50",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), JO = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(DC), A({
      class: l(V)(
        l(Yt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selected
        "data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:opacity-100 data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:bg-accent/50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ZO = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(MC), A({
      class: l(V)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), QO = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(EC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), e3 = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(AC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Cv = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(OC), A({
      class: l(V)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), t3 = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(VC), A({
      class: l(V)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), n3 = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(NC), A({
      class: l(V)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), a3 = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(zC), A({
      class: l(V)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(He(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), r3 = /* @__PURE__ */ b({
  __name: "CalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(UC), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(za), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), o3 = /* @__PURE__ */ b({
  __name: "CalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(WC), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Wi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), s3 = /* @__PURE__ */ b({
  __name: "Card",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("rounded-xl border bg-card text-card-foreground shadow", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), l3 = /* @__PURE__ */ b({
  __name: "CardContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), fH = /* @__PURE__ */ b({
  __name: "CardDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      class: re(l(V)("text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), pH = /* @__PURE__ */ b({
  __name: "CardFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("flex items-center p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), i3 = /* @__PURE__ */ b({
  __name: "CardHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("flex flex-col gap-y-1.5 p-6", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), u3 = /* @__PURE__ */ b({
  __name: "CardTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("h3", {
      class: re(l(V)("leading-none font-semibold tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
});
function d3(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Sv(e) {
  return d3(e) || Array.isArray(e);
}
function c3() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function yf(e, t) {
  const n = Object.keys(e), a = Object.keys(t);
  if (n.length !== a.length) return !1;
  const r = JSON.stringify(Object.keys(e.breakpoints || {})), o = JSON.stringify(Object.keys(t.breakpoints || {}));
  return r !== o ? !1 : n.every((s) => {
    const i = e[s], u = t[s];
    return typeof i == "function" ? `${i}` == `${u}` : !Sv(i) || !Sv(u) ? i === u : yf(i, u);
  });
}
function $v(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function f3(e, t) {
  if (e.length !== t.length) return !1;
  const n = $v(e), a = $v(t);
  return n.every((r, o) => {
    const s = a[o];
    return yf(r, s);
  });
}
function bf(e) {
  return typeof e == "number";
}
function qd(e) {
  return typeof e == "string";
}
function Ki(e) {
  return typeof e == "boolean";
}
function kv(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function vt(e) {
  return Math.abs(e);
}
function _f(e) {
  return Math.sign(e);
}
function To(e, t) {
  return vt(e - t);
}
function p3(e, t) {
  if (e === 0 || t === 0 || vt(e) <= vt(t)) return 0;
  const n = To(vt(e), vt(t));
  return vt(n / e);
}
function v3(e) {
  return Math.round(e * 100) / 100;
}
function Yo(e) {
  return Xo(e).map(Number);
}
function qn(e) {
  return e[$s(e)];
}
function $s(e) {
  return Math.max(0, e.length - 1);
}
function wf(e, t) {
  return t === $s(e);
}
function Bv(e, t = 0) {
  return Array.from(Array(e), (n, a) => t + a);
}
function Xo(e) {
  return Object.keys(e);
}
function ub(e, t) {
  return [e, t].reduce((n, a) => (Xo(a).forEach((r) => {
    const o = n[r], s = a[r], i = kv(o) && kv(s);
    n[r] = i ? ub(o, s) : s;
  }), n), {});
}
function Ed(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function m3(e, t) {
  const n = {
    start: a,
    center: r,
    end: o
  };
  function a() {
    return 0;
  }
  function r(u) {
    return o(u) / 2;
  }
  function o(u) {
    return t - u;
  }
  function s(u, d) {
    return qd(e) ? n[e](u) : e(t, u, d);
  }
  return {
    measure: s
  };
}
function Jo() {
  let e = [];
  function t(r, o, s, i = {
    passive: !0
  }) {
    let u;
    if ("addEventListener" in r)
      r.addEventListener(o, s, i), u = () => r.removeEventListener(o, s, i);
    else {
      const d = r;
      d.addListener(s), u = () => d.removeListener(s);
    }
    return e.push(u), a;
  }
  function n() {
    e = e.filter((r) => r());
  }
  const a = {
    add: t,
    clear: n
  };
  return a;
}
function h3(e, t, n, a) {
  const r = Jo(), o = 1e3 / 60;
  let s = null, i = 0, u = 0;
  function d() {
    r.add(e, "visibilitychange", () => {
      e.hidden && m();
    });
  }
  function c() {
    v(), r.clear();
  }
  function f(w) {
    if (!u) return;
    s || (s = w, n(), n());
    const C = w - s;
    for (s = w, i += C; i >= o; )
      n(), i -= o;
    const S = i / o;
    a(S), u && (u = t.requestAnimationFrame(f));
  }
  function p() {
    u || (u = t.requestAnimationFrame(f));
  }
  function v() {
    t.cancelAnimationFrame(u), s = null, i = 0, u = 0;
  }
  function m() {
    s = null, i = 0;
  }
  return {
    init: d,
    destroy: c,
    start: p,
    stop: v,
    update: n,
    render: a
  };
}
function g3(e, t) {
  const n = t === "rtl", a = e === "y", r = a ? "y" : "x", o = a ? "x" : "y", s = !a && n ? -1 : 1, i = c(), u = f();
  function d(m) {
    const {
      height: g,
      width: w
    } = m;
    return a ? g : w;
  }
  function c() {
    return a ? "top" : n ? "right" : "left";
  }
  function f() {
    return a ? "bottom" : n ? "left" : "right";
  }
  function p(m) {
    return m * s;
  }
  return {
    scroll: r,
    cross: o,
    startEdge: i,
    endEdge: u,
    measureSize: d,
    direction: p
  };
}
function nr(e = 0, t = 0) {
  const n = vt(e - t);
  function a(d) {
    return d < e;
  }
  function r(d) {
    return d > t;
  }
  function o(d) {
    return a(d) || r(d);
  }
  function s(d) {
    return o(d) ? a(d) ? e : t : d;
  }
  function i(d) {
    return n ? d - n * Math.ceil((d - t) / n) : d;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: s,
    reachedAny: o,
    reachedMax: r,
    reachedMin: a,
    removeOffset: i
  };
}
function db(e, t, n) {
  const {
    constrain: a
  } = nr(0, e), r = e + 1;
  let o = s(t);
  function s(p) {
    return n ? vt((r + p) % r) : a(p);
  }
  function i() {
    return o;
  }
  function u(p) {
    return o = s(p), f;
  }
  function d(p) {
    return c().set(i() + p);
  }
  function c() {
    return db(e, i(), n);
  }
  const f = {
    get: i,
    set: u,
    add: d,
    clone: c
  };
  return f;
}
function y3(e, t, n, a, r, o, s, i, u, d, c, f, p, v, m, g, w, C, S) {
  const {
    cross: $,
    direction: B
  } = e, k = ["INPUT", "SELECT", "TEXTAREA"], P = {
    passive: !1
  }, D = Jo(), q = Jo(), T = nr(50, 225).constrain(v.measure(20)), M = {
    mouse: 300,
    touch: 400
  }, O = {
    mouse: 500,
    touch: 600
  }, F = m ? 43 : 25;
  let J = !1, ne = 0, Q = 0, W = !1, H = !1, U = !1, se = !1;
  function ee(L) {
    if (!S) return;
    function be(Fe) {
      (Ki(S) || S(L, Fe)) && ce(Fe);
    }
    const we = t;
    D.add(we, "dragstart", (Fe) => Fe.preventDefault(), P).add(we, "touchmove", () => {
    }, P).add(we, "touchend", () => {
    }).add(we, "touchstart", be).add(we, "mousedown", be).add(we, "touchcancel", te).add(we, "contextmenu", te).add(we, "click", z, !0);
  }
  function de() {
    D.clear(), q.clear();
  }
  function pe() {
    const L = se ? n : t;
    q.add(L, "touchmove", R, P).add(L, "touchend", te).add(L, "mousemove", R, P).add(L, "mouseup", te);
  }
  function _e(L) {
    const be = L.nodeName || "";
    return k.includes(be);
  }
  function ge() {
    return (m ? O : M)[se ? "mouse" : "touch"];
  }
  function Te(L, be) {
    const we = f.add(_f(L) * -1), Fe = c.byDistance(L, !m).distance;
    return m || vt(L) < T ? Fe : w && be ? Fe * 0.5 : c.byIndex(we.get(), 0).distance;
  }
  function ce(L) {
    const be = Ed(L, a);
    se = be, U = m && be && !L.buttons && J, J = To(r.get(), s.get()) >= 2, !(be && L.button !== 0) && (_e(L.target) || (W = !0, o.pointerDown(L), d.useFriction(0).useDuration(0), r.set(s), pe(), ne = o.readPoint(L), Q = o.readPoint(L, $), p.emit("pointerDown")));
  }
  function R(L) {
    if (!Ed(L, a) && L.touches.length >= 2) return te(L);
    const we = o.readPoint(L), Fe = o.readPoint(L, $), Xe = To(we, ne), lt = To(Fe, Q);
    if (!H && !se && (!L.cancelable || (H = Xe > lt, !H)))
      return te(L);
    const De = o.pointerMove(L);
    Xe > g && (U = !0), d.useFriction(0.3).useDuration(0.75), i.start(), r.add(B(De)), L.preventDefault();
  }
  function te(L) {
    const we = c.byDistance(0, !1).index !== f.get(), Fe = o.pointerUp(L) * ge(), Xe = Te(B(Fe), we), lt = p3(Fe, Xe), De = F - 10 * lt, Ne = C + lt / 50;
    H = !1, W = !1, q.clear(), d.useDuration(De).useFriction(Ne), u.distance(Xe, !m), se = !1, p.emit("pointerUp");
  }
  function z(L) {
    U && (L.stopPropagation(), L.preventDefault(), U = !1);
  }
  function ae() {
    return W;
  }
  return {
    init: ee,
    destroy: de,
    pointerDown: ae
  };
}
function b3(e, t) {
  let a, r;
  function o(f) {
    return f.timeStamp;
  }
  function s(f, p) {
    const m = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (Ed(f, t) ? f : f.touches[0])[m];
  }
  function i(f) {
    return a = f, r = f, s(f);
  }
  function u(f) {
    const p = s(f) - s(r), v = o(f) - o(a) > 170;
    return r = f, v && (a = f), p;
  }
  function d(f) {
    if (!a || !r) return 0;
    const p = s(r) - s(a), v = o(f) - o(a), m = o(f) - o(r) > 170, g = p / v;
    return v && !m && vt(g) > 0.1 ? g : 0;
  }
  return {
    pointerDown: i,
    pointerMove: u,
    pointerUp: d,
    readPoint: s
  };
}
function _3() {
  function e(n) {
    const {
      offsetTop: a,
      offsetLeft: r,
      offsetWidth: o,
      offsetHeight: s
    } = n;
    return {
      top: a,
      right: r + o,
      bottom: a + s,
      left: r,
      width: o,
      height: s
    };
  }
  return {
    measure: e
  };
}
function w3(e) {
  function t(a) {
    return e * (a / 100);
  }
  return {
    measure: t
  };
}
function x3(e, t, n, a, r, o, s) {
  const i = [e].concat(a);
  let u, d, c = [], f = !1;
  function p(w) {
    return r.measureSize(s.measure(w));
  }
  function v(w) {
    if (!o) return;
    d = p(e), c = a.map(p);
    function C(S) {
      for (const $ of S) {
        if (f) return;
        const B = $.target === e, k = a.indexOf($.target), P = B ? d : c[k], D = p(B ? e : a[k]);
        if (vt(D - P) >= 0.5) {
          w.reInit(), t.emit("resize");
          break;
        }
      }
    }
    u = new ResizeObserver((S) => {
      (Ki(o) || o(w, S)) && C(S);
    }), n.requestAnimationFrame(() => {
      i.forEach((S) => u.observe(S));
    });
  }
  function m() {
    f = !0, u && u.disconnect();
  }
  return {
    init: v,
    destroy: m
  };
}
function C3(e, t, n, a, r, o) {
  let s = 0, i = 0, u = r, d = o, c = e.get(), f = 0;
  function p() {
    const P = a.get() - e.get(), D = !u;
    let q = 0;
    return D ? (s = 0, n.set(a), e.set(a), q = P) : (n.set(e), s += P / u, s *= d, c += s, e.add(s), q = c - f), i = _f(q), f = c, k;
  }
  function v() {
    const P = a.get() - t.get();
    return vt(P) < 1e-3;
  }
  function m() {
    return u;
  }
  function g() {
    return i;
  }
  function w() {
    return s;
  }
  function C() {
    return $(r);
  }
  function S() {
    return B(o);
  }
  function $(P) {
    return u = P, k;
  }
  function B(P) {
    return d = P, k;
  }
  const k = {
    direction: g,
    duration: m,
    velocity: w,
    seek: p,
    settled: v,
    useBaseFriction: S,
    useBaseDuration: C,
    useFriction: B,
    useDuration: $
  };
  return k;
}
function S3(e, t, n, a, r) {
  const o = r.measure(10), s = r.measure(50), i = nr(0.1, 0.99);
  let u = !1;
  function d() {
    return !(u || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function c(v) {
    if (!d()) return;
    const m = e.reachedMin(t.get()) ? "min" : "max", g = vt(e[m] - t.get()), w = n.get() - t.get(), C = i.constrain(g / s);
    n.subtract(w * C), !v && vt(w) < o && (n.set(e.constrain(n.get())), a.useDuration(25).useBaseFriction());
  }
  function f(v) {
    u = !v;
  }
  return {
    shouldConstrain: d,
    constrain: c,
    toggleActive: f
  };
}
function $3(e, t, n, a, r) {
  const o = nr(-t + e, 0), s = f(), i = c(), u = p();
  function d(m, g) {
    return To(m, g) <= 1;
  }
  function c() {
    const m = s[0], g = qn(s), w = s.lastIndexOf(m), C = s.indexOf(g) + 1;
    return nr(w, C);
  }
  function f() {
    return n.map((m, g) => {
      const {
        min: w,
        max: C
      } = o, S = o.constrain(m), $ = !g, B = wf(n, g);
      return $ ? C : B || d(w, S) ? w : d(C, S) ? C : S;
    }).map((m) => parseFloat(m.toFixed(3)));
  }
  function p() {
    if (t <= e + r) return [o.max];
    if (a === "keepSnaps") return s;
    const {
      min: m,
      max: g
    } = i;
    return s.slice(m, g);
  }
  return {
    snapsContained: u,
    scrollContainLimit: i
  };
}
function k3(e, t, n) {
  const a = t[0], r = n ? a - e : qn(t);
  return {
    limit: nr(r, a)
  };
}
function B3(e, t, n, a) {
  const o = t.min + 0.1, s = t.max + 0.1, {
    reachedMin: i,
    reachedMax: u
  } = nr(o, s);
  function d(p) {
    return p === 1 ? u(n.get()) : p === -1 ? i(n.get()) : !1;
  }
  function c(p) {
    if (!d(p)) return;
    const v = e * (p * -1);
    a.forEach((m) => m.add(v));
  }
  return {
    loop: c
  };
}
function D3(e) {
  const {
    max: t,
    length: n
  } = e;
  function a(o) {
    const s = o - t;
    return n ? s / -n : 0;
  }
  return {
    get: a
  };
}
function P3(e, t, n, a, r) {
  const {
    startEdge: o,
    endEdge: s
  } = e, {
    groupSlides: i
  } = r, u = f().map(t.measure), d = p(), c = v();
  function f() {
    return i(a).map((g) => qn(g)[s] - g[0][o]).map(vt);
  }
  function p() {
    return a.map((g) => n[o] - g[o]).map((g) => -vt(g));
  }
  function v() {
    return i(d).map((g) => g[0]).map((g, w) => g + u[w]);
  }
  return {
    snaps: d,
    snapsAligned: c
  };
}
function M3(e, t, n, a, r, o) {
  const {
    groupSlides: s
  } = r, {
    min: i,
    max: u
  } = a, d = c();
  function c() {
    const p = s(o), v = !e || t === "keepSnaps";
    return n.length === 1 ? [o] : v ? p : p.slice(i, u).map((m, g, w) => {
      const C = !g, S = wf(w, g);
      if (C) {
        const $ = qn(w[0]) + 1;
        return Bv($);
      }
      if (S) {
        const $ = $s(o) - qn(w)[0] + 1;
        return Bv($, qn(w)[0]);
      }
      return m;
    });
  }
  return {
    slideRegistry: d
  };
}
function q3(e, t, n, a, r) {
  const {
    reachedAny: o,
    removeOffset: s,
    constrain: i
  } = a;
  function u(m) {
    return m.concat().sort((g, w) => vt(g) - vt(w))[0];
  }
  function d(m) {
    const g = e ? s(m) : i(m), w = t.map((S, $) => ({
      diff: c(S - g, 0),
      index: $
    })).sort((S, $) => vt(S.diff) - vt($.diff)), {
      index: C
    } = w[0];
    return {
      index: C,
      distance: g
    };
  }
  function c(m, g) {
    const w = [m, m + n, m - n];
    if (!e) return m;
    if (!g) return u(w);
    const C = w.filter((S) => _f(S) === g);
    return C.length ? u(C) : qn(w) - n;
  }
  function f(m, g) {
    const w = t[m] - r.get(), C = c(w, g);
    return {
      index: m,
      distance: C
    };
  }
  function p(m, g) {
    const w = r.get() + m, {
      index: C,
      distance: S
    } = d(w), $ = !e && o(w);
    if (!g || $) return {
      index: C,
      distance: m
    };
    const B = t[C] - S, k = m + c(B, 0);
    return {
      index: C,
      distance: k
    };
  }
  return {
    byDistance: p,
    byIndex: f,
    shortcut: c
  };
}
function E3(e, t, n, a, r, o, s) {
  function i(f) {
    const p = f.distance, v = f.index !== t.get();
    o.add(p), p && (a.duration() ? e.start() : (e.update(), e.render(1), e.update())), v && (n.set(t.get()), t.set(f.index), s.emit("select"));
  }
  function u(f, p) {
    const v = r.byDistance(f, p);
    i(v);
  }
  function d(f, p) {
    const v = t.clone().set(f), m = r.byIndex(v.get(), p);
    i(m);
  }
  return {
    distance: u,
    index: d
  };
}
function T3(e, t, n, a, r, o, s, i) {
  const u = {
    passive: !0,
    capture: !0
  };
  let d = 0;
  function c(v) {
    if (!i) return;
    function m(g) {
      if ((/* @__PURE__ */ new Date()).getTime() - d > 10) return;
      s.emit("slideFocusStart"), e.scrollLeft = 0;
      const S = n.findIndex(($) => $.includes(g));
      bf(S) && (r.useDuration(0), a.index(S, 0), s.emit("slideFocus"));
    }
    o.add(document, "keydown", f, !1), t.forEach((g, w) => {
      o.add(g, "focus", (C) => {
        (Ki(i) || i(v, C)) && m(w);
      }, u);
    });
  }
  function f(v) {
    v.code === "Tab" && (d = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: c
  };
}
function $o(e) {
  let t = e;
  function n() {
    return t;
  }
  function a(u) {
    t = s(u);
  }
  function r(u) {
    t += s(u);
  }
  function o(u) {
    t -= s(u);
  }
  function s(u) {
    return bf(u) ? u : u.get();
  }
  return {
    get: n,
    set: a,
    add: r,
    subtract: o
  };
}
function cb(e, t) {
  const n = e.scroll === "x" ? s : i, a = t.style;
  let r = null, o = !1;
  function s(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function i(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function u(p) {
    if (o) return;
    const v = v3(e.direction(p));
    v !== r && (a.transform = n(v), r = v);
  }
  function d(p) {
    o = !p;
  }
  function c() {
    o || (a.transform = "", t.getAttribute("style") || t.removeAttribute("style"));
  }
  return {
    clear: c,
    to: u,
    toggleActive: d
  };
}
function A3(e, t, n, a, r, o, s, i, u) {
  const c = Yo(r), f = Yo(r).reverse(), p = C().concat(S());
  function v(D, q) {
    return D.reduce((T, M) => T - r[M], q);
  }
  function m(D, q) {
    return D.reduce((T, M) => v(T, q) > 0 ? T.concat([M]) : T, []);
  }
  function g(D) {
    return o.map((q, T) => ({
      start: q - a[T] + 0.5 + D,
      end: q + t - 0.5 + D
    }));
  }
  function w(D, q, T) {
    const M = g(q);
    return D.map((O) => {
      const F = T ? 0 : -n, J = T ? n : 0, ne = T ? "end" : "start", Q = M[O][ne];
      return {
        index: O,
        loopPoint: Q,
        slideLocation: $o(-1),
        translate: cb(e, u[O]),
        target: () => i.get() > Q ? F : J
      };
    });
  }
  function C() {
    const D = s[0], q = m(f, D);
    return w(q, n, !1);
  }
  function S() {
    const D = t - s[0] - 1, q = m(c, D);
    return w(q, -n, !0);
  }
  function $() {
    return p.every(({
      index: D
    }) => {
      const q = c.filter((T) => T !== D);
      return v(q, t) <= 0.1;
    });
  }
  function B() {
    p.forEach((D) => {
      const {
        target: q,
        translate: T,
        slideLocation: M
      } = D, O = q();
      O !== M.get() && (T.to(O), M.set(O));
    });
  }
  function k() {
    p.forEach((D) => D.translate.clear());
  }
  return {
    canLoop: $,
    clear: k,
    loop: B,
    loopPoints: p
  };
}
function I3(e, t, n) {
  let a, r = !1;
  function o(u) {
    if (!n) return;
    function d(c) {
      for (const f of c)
        if (f.type === "childList") {
          u.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    a = new MutationObserver((c) => {
      r || (Ki(n) || n(u, c)) && d(c);
    }), a.observe(e, {
      childList: !0
    });
  }
  function s() {
    a && a.disconnect(), r = !0;
  }
  return {
    init: o,
    destroy: s
  };
}
function O3(e, t, n, a) {
  const r = {};
  let o = null, s = null, i, u = !1;
  function d() {
    i = new IntersectionObserver((m) => {
      u || (m.forEach((g) => {
        const w = t.indexOf(g.target);
        r[w] = g;
      }), o = null, s = null, n.emit("slidesInView"));
    }, {
      root: e.parentElement,
      threshold: a
    }), t.forEach((m) => i.observe(m));
  }
  function c() {
    i && i.disconnect(), u = !0;
  }
  function f(m) {
    return Xo(r).reduce((g, w) => {
      const C = parseInt(w), {
        isIntersecting: S
      } = r[C];
      return (m && S || !m && !S) && g.push(C), g;
    }, []);
  }
  function p(m = !0) {
    if (m && o) return o;
    if (!m && s) return s;
    const g = f(m);
    return m && (o = g), m || (s = g), g;
  }
  return {
    init: d,
    destroy: c,
    get: p
  };
}
function R3(e, t, n, a, r, o) {
  const {
    measureSize: s,
    startEdge: i,
    endEdge: u
  } = e, d = n[0] && r, c = m(), f = g(), p = n.map(s), v = w();
  function m() {
    if (!d) return 0;
    const S = n[0];
    return vt(t[i] - S[i]);
  }
  function g() {
    if (!d) return 0;
    const S = o.getComputedStyle(qn(a));
    return parseFloat(S.getPropertyValue(`margin-${u}`));
  }
  function w() {
    return n.map((S, $, B) => {
      const k = !$, P = wf(B, $);
      return k ? p[$] + c : P ? p[$] + f : B[$ + 1][i] - S[i];
    }).map(vt);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: v,
    startGap: c,
    endGap: f
  };
}
function V3(e, t, n, a, r, o, s, i, u) {
  const {
    startEdge: d,
    endEdge: c,
    direction: f
  } = e, p = bf(n);
  function v(C, S) {
    return Yo(C).filter(($) => $ % S === 0).map(($) => C.slice($, $ + S));
  }
  function m(C) {
    return C.length ? Yo(C).reduce((S, $, B) => {
      const k = qn(S) || 0, P = k === 0, D = $ === $s(C), q = r[d] - o[k][d], T = r[d] - o[$][c], M = !a && P ? f(s) : 0, O = !a && D ? f(i) : 0, F = vt(T - O - (q + M));
      return B && F > t + u && S.push($), D && S.push(C.length), S;
    }, []).map((S, $, B) => {
      const k = Math.max(B[$ - 1] || 0);
      return C.slice(k, S);
    }) : [];
  }
  function g(C) {
    return p ? v(C, n) : m(C);
  }
  return {
    groupSlides: g
  };
}
function F3(e, t, n, a, r, o, s) {
  const {
    align: i,
    axis: u,
    direction: d,
    startIndex: c,
    loop: f,
    duration: p,
    dragFree: v,
    dragThreshold: m,
    inViewThreshold: g,
    slidesToScroll: w,
    skipSnaps: C,
    containScroll: S,
    watchResize: $,
    watchSlides: B,
    watchDrag: k,
    watchFocus: P
  } = o, D = 2, q = _3(), T = q.measure(t), M = n.map(q.measure), O = g3(u, d), F = O.measureSize(T), J = w3(F), ne = m3(i, F), Q = !f && !!S, W = f || !!S, {
    slideSizes: H,
    slideSizesWithGaps: U,
    startGap: se,
    endGap: ee
  } = R3(O, T, M, n, W, r), de = V3(O, F, w, f, T, M, se, ee, D), {
    snaps: pe,
    snapsAligned: _e
  } = P3(O, ne, T, M, de), ge = -qn(pe) + qn(U), {
    snapsContained: Te,
    scrollContainLimit: ce
  } = $3(F, ge, _e, S, D), R = Q ? Te : _e, {
    limit: te
  } = k3(ge, R, f), z = db($s(R), c, f), ae = z.clone(), ie = Yo(n), L = ({
    dragHandler: Rt,
    scrollBody: K,
    scrollBounds: Y,
    options: {
      loop: ue
    }
  }) => {
    ue || Y.constrain(Rt.pointerDown()), K.seek();
  }, be = ({
    scrollBody: Rt,
    translate: K,
    location: Y,
    offsetLocation: ue,
    previousLocation: ye,
    scrollLooper: Pe,
    slideLooper: Ae,
    dragHandler: qe,
    animation: rt,
    eventHandler: ct,
    scrollBounds: Mt,
    options: {
      loop: at
    }
  }, kt) => {
    const Vt = Rt.settled(), Xt = !Mt.shouldConstrain(), ba = at ? Vt : Vt && Xt, yr = ba && !qe.pointerDown();
    yr && rt.stop();
    const uo = Y.get() * kt + ye.get() * (1 - kt);
    ue.set(uo), at && (Pe.loop(Rt.direction()), Ae.loop()), K.to(ue.get()), yr && ct.emit("settle"), ba || ct.emit("scroll");
  }, we = h3(a, r, () => L(jt), (Rt) => be(jt, Rt)), Fe = 0.68, Xe = R[z.get()], lt = $o(Xe), De = $o(Xe), Ne = $o(Xe), Ue = $o(Xe), We = C3(lt, Ne, De, Ue, p, Fe), it = q3(f, R, ge, te, Ue), ut = E3(we, z, ae, We, it, Ue, s), $t = D3(te), un = Jo(), gn = O3(t, n, s, g), {
    slideRegistry: Oe
  } = M3(Q, S, R, ce, de, ie), Pt = T3(e, n, Oe, ut, We, un, s, P), jt = {
    ownerDocument: a,
    ownerWindow: r,
    eventHandler: s,
    containerRect: T,
    slideRects: M,
    animation: we,
    axis: O,
    dragHandler: y3(O, e, a, r, Ue, b3(O, r), lt, we, ut, We, it, z, s, J, v, m, C, Fe, k),
    eventStore: un,
    percentOfView: J,
    index: z,
    indexPrevious: ae,
    limit: te,
    location: lt,
    offsetLocation: Ne,
    previousLocation: De,
    options: o,
    resizeHandler: x3(t, s, r, n, O, $, q),
    scrollBody: We,
    scrollBounds: S3(te, Ne, Ue, We, J),
    scrollLooper: B3(ge, te, Ne, [lt, Ne, De, Ue]),
    scrollProgress: $t,
    scrollSnapList: R.map($t.get),
    scrollSnaps: R,
    scrollTarget: it,
    scrollTo: ut,
    slideLooper: A3(O, F, ge, H, U, pe, R, Ne, n),
    slideFocus: Pt,
    slidesHandler: I3(t, s, B),
    slidesInView: gn,
    slideIndexes: ie,
    slideRegistry: Oe,
    slidesToScroll: de,
    target: Ue,
    translate: cb(O, t)
  };
  return jt;
}
function N3() {
  let e = {}, t;
  function n(d) {
    t = d;
  }
  function a(d) {
    return e[d] || [];
  }
  function r(d) {
    return a(d).forEach((c) => c(t, d)), u;
  }
  function o(d, c) {
    return e[d] = a(d).concat([c]), u;
  }
  function s(d, c) {
    return e[d] = a(d).filter((f) => f !== c), u;
  }
  function i() {
    e = {};
  }
  const u = {
    init: n,
    emit: r,
    off: s,
    on: o,
    clear: i
  };
  return u;
}
const L3 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function z3(e) {
  function t(o, s) {
    return ub(o, s || {});
  }
  function n(o) {
    const s = o.breakpoints || {}, i = Xo(s).filter((u) => e.matchMedia(u).matches).map((u) => s[u]).reduce((u, d) => t(u, d), {});
    return t(o, i);
  }
  function a(o) {
    return o.map((s) => Xo(s.breakpoints || {})).reduce((s, i) => s.concat(i), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: a
  };
}
function H3(e) {
  let t = [];
  function n(o, s) {
    return t = s.filter(({
      options: i
    }) => e.optionsAtMedia(i).active !== !1), t.forEach((i) => i.init(o, e)), s.reduce((i, u) => Object.assign(i, {
      [u.name]: u
    }), {});
  }
  function a() {
    t = t.filter((o) => o.destroy());
  }
  return {
    init: n,
    destroy: a
  };
}
function Nl(e, t, n) {
  const a = e.ownerDocument, r = a.defaultView, o = z3(r), s = H3(o), i = Jo(), u = N3(), {
    mergeOptions: d,
    optionsAtMedia: c,
    optionsMediaQueries: f
  } = o, {
    on: p,
    off: v,
    emit: m
  } = u, g = O;
  let w = !1, C, S = d(L3, Nl.globalOptions), $ = d(S), B = [], k, P, D;
  function q() {
    const {
      container: ie,
      slides: L
    } = $;
    P = (qd(ie) ? e.querySelector(ie) : ie) || e.children[0];
    const we = qd(L) ? P.querySelectorAll(L) : L;
    D = [].slice.call(we || P.children);
  }
  function T(ie) {
    const L = F3(e, P, D, a, r, ie, u);
    if (ie.loop && !L.slideLooper.canLoop()) {
      const be = Object.assign({}, ie, {
        loop: !1
      });
      return T(be);
    }
    return L;
  }
  function M(ie, L) {
    w || (S = d(S, ie), $ = c(S), B = L || B, q(), C = T($), f([S, ...B.map(({
      options: be
    }) => be)]).forEach((be) => i.add(be, "change", O)), $.active && (C.translate.to(C.location.get()), C.animation.init(), C.slidesInView.init(), C.slideFocus.init(ae), C.eventHandler.init(ae), C.resizeHandler.init(ae), C.slidesHandler.init(ae), C.options.loop && C.slideLooper.loop(), P.offsetParent && D.length && C.dragHandler.init(ae), k = s.init(ae, B)));
  }
  function O(ie, L) {
    const be = de();
    F(), M(d({
      startIndex: be
    }, ie), L), u.emit("reInit");
  }
  function F() {
    C.dragHandler.destroy(), C.eventStore.clear(), C.translate.clear(), C.slideLooper.clear(), C.resizeHandler.destroy(), C.slidesHandler.destroy(), C.slidesInView.destroy(), C.animation.destroy(), s.destroy(), i.clear();
  }
  function J() {
    w || (w = !0, i.clear(), F(), u.emit("destroy"), u.clear());
  }
  function ne(ie, L, be) {
    !$.active || w || (C.scrollBody.useBaseFriction().useDuration(L === !0 ? 0 : $.duration), C.scrollTo.index(ie, be || 0));
  }
  function Q(ie) {
    const L = C.index.add(1).get();
    ne(L, ie, -1);
  }
  function W(ie) {
    const L = C.index.add(-1).get();
    ne(L, ie, 1);
  }
  function H() {
    return C.index.add(1).get() !== de();
  }
  function U() {
    return C.index.add(-1).get() !== de();
  }
  function se() {
    return C.scrollSnapList;
  }
  function ee() {
    return C.scrollProgress.get(C.offsetLocation.get());
  }
  function de() {
    return C.index.get();
  }
  function pe() {
    return C.indexPrevious.get();
  }
  function _e() {
    return C.slidesInView.get();
  }
  function ge() {
    return C.slidesInView.get(!1);
  }
  function Te() {
    return k;
  }
  function ce() {
    return C;
  }
  function R() {
    return e;
  }
  function te() {
    return P;
  }
  function z() {
    return D;
  }
  const ae = {
    canScrollNext: H,
    canScrollPrev: U,
    containerNode: te,
    internalEngine: ce,
    destroy: J,
    off: v,
    on: p,
    emit: m,
    plugins: Te,
    previousScrollSnap: pe,
    reInit: g,
    rootNode: R,
    scrollNext: Q,
    scrollPrev: W,
    scrollProgress: ee,
    scrollSnapList: se,
    scrollTo: ne,
    selectedScrollSnap: de,
    slideNodes: z,
    slidesInView: _e,
    slidesNotInView: ge
  };
  return M(t, n), setTimeout(() => u.emit("init"), 0), ae;
}
Nl.globalOptions = void 0;
function xf(e = {}, t = []) {
  const n = mt(e), a = mt(t);
  let r = n ? e.value : e, o = a ? t.value : t;
  const s = gt(), i = gt();
  function u() {
    i.value && i.value.reInit(r, o);
  }
  return Ce(() => {
    !c3() || !s.value || (Nl.globalOptions = xf.globalOptions, i.value = Nl(s.value, r, o));
  }), sr(() => {
    i.value && i.value.destroy();
  }), n && ve(e, (d) => {
    yf(r, d) || (r = d, u());
  }), a && ve(t, (d) => {
    f3(o, d) || (o = d, u());
  }), [s, i];
}
xf.globalOptions = void 0;
const [U3, j3] = /* @__PURE__ */ HA(
  ({ opts: e, orientation: t, plugins: n }, a) => {
    const [r, o] = xf(
      {
        ...e,
        axis: t === "horizontal" ? "x" : "y"
      },
      n
    );
    function s() {
      o.value?.scrollPrev();
    }
    function i() {
      o.value?.scrollNext();
    }
    const u = I(!1), d = I(!1);
    function c(f) {
      u.value = f?.canScrollNext() || !1, d.value = f?.canScrollPrev() || !1;
    }
    return Ce(() => {
      o.value && (o.value?.on("init", c), o.value?.on("reInit", c), o.value?.on("select", c), a("init-api", o.value));
    }), {
      carouselRef: r,
      carouselApi: o,
      canScrollPrev: d,
      canScrollNext: u,
      scrollPrev: s,
      scrollNext: i,
      orientation: t
    };
  }
);
function Yi() {
  const e = j3();
  if (!e) throw new Error("useCarousel must be used within a <Carousel />");
  return e;
}
const vH = /* @__PURE__ */ b({
  __name: "Carousel",
  props: {
    opts: {},
    plugins: {},
    orientation: { default: "horizontal" },
    class: {}
  },
  emits: ["init-api"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, {
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    } = U3(a, r);
    t({
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    });
    function p(v) {
      const m = a.orientation === "vertical" ? "ArrowUp" : "ArrowLeft", g = a.orientation === "vertical" ? "ArrowDown" : "ArrowRight";
      if (v.key === m) {
        v.preventDefault(), f();
        return;
      }
      v.key === g && (v.preventDefault(), c());
    }
    return (v, m) => (h(), G("div", {
      class: re(l(V)("relative", a.class)),
      role: "region",
      "aria-roledescription": "carousel",
      tabindex: "0",
      onKeydown: p
    }, [
      _(v.$slots, "default", {
        canScrollNext: l(o),
        canScrollPrev: l(s),
        carouselApi: l(i),
        carouselRef: l(u),
        orientation: l(d),
        scrollNext: l(c),
        scrollPrev: l(f)
      })
    ], 34));
  }
}), mH = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CarouselContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { carouselRef: n, orientation: a } = Yi();
    return (r, o) => (h(), G("div", {
      ref_key: "carouselRef",
      ref: n,
      class: "overflow-hidden"
    }, [
      xe("div", A({
        class: l(V)("flex", l(a) === "horizontal" ? "-ml-4" : "-mt-4 flex-col", t.class)
      }, r.$attrs), [
        _(r.$slots, "default")
      ], 16)
    ], 512));
  }
}), hH = /* @__PURE__ */ b({
  __name: "CarouselItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n } = Yi();
    return (a, r) => (h(), G("div", {
      role: "group",
      "aria-roledescription": "slide",
      class: re(
        l(V)(
          "min-w-0 shrink-0 grow-0 basis-full",
          l(n) === "horizontal" ? "pl-4" : "pt-4",
          t.class
        )
      )
    }, [
      _(a.$slots, "default")
    ], 2));
  }
});
function W3(e, t) {
  return h(), G("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    xe("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M6.85355 3.14645C7.04882 3.34171 7.04882 3.65829 6.85355 3.85355L3.70711 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H3.70711L6.85355 11.1464C7.04882 11.3417 7.04882 11.6583 6.85355 11.8536C6.65829 12.0488 6.34171 12.0488 6.14645 11.8536L2.14645 7.85355C1.95118 7.65829 1.95118 7.34171 2.14645 7.14645L6.14645 3.14645C6.34171 2.95118 6.65829 2.95118 6.85355 3.14645Z",
      fill: "currentColor"
    })
  ]);
}
function G3(e, t) {
  return h(), G("svg", {
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    xe("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.14645 3.14645C8.34171 2.95118 8.65829 2.95118 8.85355 3.14645L12.8536 7.14645C13.0488 7.34171 13.0488 7.65829 12.8536 7.85355L8.85355 11.8536C8.65829 12.0488 8.34171 12.0488 8.14645 11.8536C7.95118 11.6583 7.95118 11.3417 8.14645 11.1464L11.2929 8H2.5C2.22386 8 2 7.77614 2 7.5C2 7.22386 2.22386 7 2.5 7H11.2929L8.14645 3.85355C7.95118 3.65829 7.95118 3.34171 8.14645 3.14645Z",
      fill: "currentColor"
    })
  ]);
}
const gH = /* @__PURE__ */ b({
  __name: "CarouselPrevious",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollPrev: a, scrollPrev: r } = Yi();
    return (o, s) => (h(), x(l(Ui), {
      disabled: !l(a),
      class: re(
        l(V)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -left-12 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: y(() => [
        _(o.$slots, "default", {}, () => [
          N(l(W3), { class: "size-4 text-current" }),
          s[0] || (s[0] = xe("span", { class: "sr-only" }, "Previous Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
}), yH = /* @__PURE__ */ b({
  __name: "CarouselNext",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollNext: a, scrollNext: r } = Yi();
    return (o, s) => (h(), x(l(Ui), {
      disabled: !l(a),
      class: re(
        l(V)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -right-12 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: y(() => [
        _(o.$slots, "default", {}, () => [
          N(l(G3), { class: "size-4 text-current" }),
          s[0] || (s[0] = xe("span", { class: "sr-only" }, "Next Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
});
var Td = "http://www.w3.org/1999/xhtml";
const Dv = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Td,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Xi(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Dv.hasOwnProperty(t) ? { space: Dv[t], local: e } : e;
}
function K3(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Td && t.documentElement.namespaceURI === Td ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function Y3(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function fb(e) {
  var t = Xi(e);
  return (t.local ? Y3 : K3)(t);
}
function X3() {
}
function Cf(e) {
  return e == null ? X3 : function() {
    return this.querySelector(e);
  };
}
function J3(e) {
  typeof e != "function" && (e = Cf(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = new Array(s), u, d, c = 0; c < s; ++c)
      (u = o[c]) && (d = e.call(u, u.__data__, c, o)) && ("__data__" in u && (d.__data__ = u.__data__), i[c] = d);
  return new hn(a, this._parents);
}
function Z3(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Q3() {
  return [];
}
function pb(e) {
  return e == null ? Q3 : function() {
    return this.querySelectorAll(e);
  };
}
function eR(e) {
  return function() {
    return Z3(e.apply(this, arguments));
  };
}
function tR(e) {
  typeof e == "function" ? e = eR(e) : e = pb(e);
  for (var t = this._groups, n = t.length, a = [], r = [], o = 0; o < n; ++o)
    for (var s = t[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && (a.push(e.call(u, u.__data__, d, s)), r.push(u));
  return new hn(a, r);
}
function vb(e) {
  return function() {
    return this.matches(e);
  };
}
function mb(e) {
  return function(t) {
    return t.matches(e);
  };
}
var nR = Array.prototype.find;
function aR(e) {
  return function() {
    return nR.call(this.children, e);
  };
}
function rR() {
  return this.firstElementChild;
}
function oR(e) {
  return this.select(e == null ? rR : aR(typeof e == "function" ? e : mb(e)));
}
var sR = Array.prototype.filter;
function lR() {
  return Array.from(this.children);
}
function iR(e) {
  return function() {
    return sR.call(this.children, e);
  };
}
function uR(e) {
  return this.selectAll(e == null ? lR : iR(typeof e == "function" ? e : mb(e)));
}
function dR(e) {
  typeof e != "function" && (e = vb(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new hn(a, this._parents);
}
function hb(e) {
  return new Array(e.length);
}
function cR() {
  return new hn(this._enter || this._groups.map(hb), this._parents);
}
function Ll(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Ll.prototype = {
  constructor: Ll,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function fR(e) {
  return function() {
    return e;
  };
}
function pR(e, t, n, a, r, o) {
  for (var s = 0, i, u = t.length, d = o.length; s < d; ++s)
    (i = t[s]) ? (i.__data__ = o[s], a[s] = i) : n[s] = new Ll(e, o[s]);
  for (; s < u; ++s)
    (i = t[s]) && (r[s] = i);
}
function vR(e, t, n, a, r, o, s) {
  var i, u, d = /* @__PURE__ */ new Map(), c = t.length, f = o.length, p = new Array(c), v;
  for (i = 0; i < c; ++i)
    (u = t[i]) && (p[i] = v = s.call(u, u.__data__, i, t) + "", d.has(v) ? r[i] = u : d.set(v, u));
  for (i = 0; i < f; ++i)
    v = s.call(e, o[i], i, o) + "", (u = d.get(v)) ? (a[i] = u, u.__data__ = o[i], d.delete(v)) : n[i] = new Ll(e, o[i]);
  for (i = 0; i < c; ++i)
    (u = t[i]) && d.get(p[i]) === u && (r[i] = u);
}
function mR(e) {
  return e.__data__;
}
function hR(e, t) {
  if (!arguments.length) return Array.from(this, mR);
  var n = t ? vR : pR, a = this._parents, r = this._groups;
  typeof e != "function" && (e = fR(e));
  for (var o = r.length, s = new Array(o), i = new Array(o), u = new Array(o), d = 0; d < o; ++d) {
    var c = a[d], f = r[d], p = f.length, v = gR(e.call(c, c && c.__data__, d, a)), m = v.length, g = i[d] = new Array(m), w = s[d] = new Array(m), C = u[d] = new Array(p);
    n(c, f, g, w, C, v, t);
    for (var S = 0, $ = 0, B, k; S < m; ++S)
      if (B = g[S]) {
        for (S >= $ && ($ = S + 1); !(k = w[$]) && ++$ < m; ) ;
        B._next = k || null;
      }
  }
  return s = new hn(s, a), s._enter = i, s._exit = u, s;
}
function gR(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function yR() {
  return new hn(this._exit || this._groups.map(hb), this._parents);
}
function bR(e, t, n) {
  var a = this.enter(), r = this, o = this.exit();
  return typeof e == "function" ? (a = e(a), a && (a = a.selection())) : a = a.append(e + ""), t != null && (r = t(r), r && (r = r.selection())), n == null ? o.remove() : n(o), a && r ? a.merge(r).order() : r;
}
function _R(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, a = t._groups, r = n.length, o = a.length, s = Math.min(r, o), i = new Array(r), u = 0; u < s; ++u)
    for (var d = n[u], c = a[u], f = d.length, p = i[u] = new Array(f), v, m = 0; m < f; ++m)
      (v = d[m] || c[m]) && (p[m] = v);
  for (; u < r; ++u)
    i[u] = n[u];
  return new hn(i, this._parents);
}
function wR() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var a = e[t], r = a.length - 1, o = a[r], s; --r >= 0; )
      (s = a[r]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
  return this;
}
function xR(e) {
  e || (e = CR);
  function t(f, p) {
    return f && p ? e(f.__data__, p.__data__) : !f - !p;
  }
  for (var n = this._groups, a = n.length, r = new Array(a), o = 0; o < a; ++o) {
    for (var s = n[o], i = s.length, u = r[o] = new Array(i), d, c = 0; c < i; ++c)
      (d = s[c]) && (u[c] = d);
    u.sort(t);
  }
  return new hn(r, this._parents).order();
}
function CR(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function SR() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function $R() {
  return Array.from(this);
}
function kR() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length; r < o; ++r) {
      var s = a[r];
      if (s) return s;
    }
  return null;
}
function BR() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function DR() {
  return !this.node();
}
function PR(e) {
  for (var t = this._groups, n = 0, a = t.length; n < a; ++n)
    for (var r = t[n], o = 0, s = r.length, i; o < s; ++o)
      (i = r[o]) && e.call(i, i.__data__, o, r);
  return this;
}
function MR(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function qR(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function ER(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function TR(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function AR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function IR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function OR(e, t) {
  var n = Xi(e);
  if (arguments.length < 2) {
    var a = this.node();
    return n.local ? a.getAttributeNS(n.space, n.local) : a.getAttribute(n);
  }
  return this.each((t == null ? n.local ? qR : MR : typeof t == "function" ? n.local ? IR : AR : n.local ? TR : ER)(n, t));
}
function gb(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function RR(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function VR(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function FR(e, t, n) {
  return function() {
    var a = t.apply(this, arguments);
    a == null ? this.style.removeProperty(e) : this.style.setProperty(e, a, n);
  };
}
function NR(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? RR : typeof t == "function" ? FR : VR)(e, t, n ?? "")) : zr(this.node(), e);
}
function zr(e, t) {
  return e.style.getPropertyValue(t) || gb(e).getComputedStyle(e, null).getPropertyValue(t);
}
function LR(e) {
  return function() {
    delete this[e];
  };
}
function zR(e, t) {
  return function() {
    this[e] = t;
  };
}
function HR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function UR(e, t) {
  return arguments.length > 1 ? this.each((t == null ? LR : typeof t == "function" ? HR : zR)(e, t)) : this.node()[e];
}
function yb(e) {
  return e.trim().split(/^|\s+/);
}
function Sf(e) {
  return e.classList || new bb(e);
}
function bb(e) {
  this._node = e, this._names = yb(e.getAttribute("class") || "");
}
bb.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function _b(e, t) {
  for (var n = Sf(e), a = -1, r = t.length; ++a < r; ) n.add(t[a]);
}
function wb(e, t) {
  for (var n = Sf(e), a = -1, r = t.length; ++a < r; ) n.remove(t[a]);
}
function jR(e) {
  return function() {
    _b(this, e);
  };
}
function WR(e) {
  return function() {
    wb(this, e);
  };
}
function GR(e, t) {
  return function() {
    (t.apply(this, arguments) ? _b : wb)(this, e);
  };
}
function KR(e, t) {
  var n = yb(e + "");
  if (arguments.length < 2) {
    for (var a = Sf(this.node()), r = -1, o = n.length; ++r < o; ) if (!a.contains(n[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? GR : t ? jR : WR)(n, t));
}
function YR() {
  this.textContent = "";
}
function XR(e) {
  return function() {
    this.textContent = e;
  };
}
function JR(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function ZR(e) {
  return arguments.length ? this.each(e == null ? YR : (typeof e == "function" ? JR : XR)(e)) : this.node().textContent;
}
function QR() {
  this.innerHTML = "";
}
function eV(e) {
  return function() {
    this.innerHTML = e;
  };
}
function tV(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function nV(e) {
  return arguments.length ? this.each(e == null ? QR : (typeof e == "function" ? tV : eV)(e)) : this.node().innerHTML;
}
function aV() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function rV() {
  return this.each(aV);
}
function oV() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function sV() {
  return this.each(oV);
}
function lV(e) {
  var t = typeof e == "function" ? e : fb(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function iV() {
  return null;
}
function uV(e, t) {
  var n = typeof e == "function" ? e : fb(e), a = t == null ? iV : typeof t == "function" ? t : Cf(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), a.apply(this, arguments) || null);
  });
}
function dV() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function cV() {
  return this.each(dV);
}
function fV() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function pV() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function vV(e) {
  return this.select(e ? pV : fV);
}
function mV(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function hV(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function gV(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", a = t.indexOf(".");
    return a >= 0 && (n = t.slice(a + 1), t = t.slice(0, a)), { type: t, name: n };
  });
}
function yV(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, a = -1, r = t.length, o; n < r; ++n)
        o = t[n], (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++a] = o;
      ++a ? t.length = a : delete this.__on;
    }
  };
}
function bV(e, t, n) {
  return function() {
    var a = this.__on, r, o = hV(t);
    if (a) {
      for (var s = 0, i = a.length; s < i; ++s)
        if ((r = a[s]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = o, r.options = n), r.value = t;
          return;
        }
    }
    this.addEventListener(e.type, o, n), r = { type: e.type, name: e.name, value: t, listener: o, options: n }, a ? a.push(r) : this.__on = [r];
  };
}
function _V(e, t, n) {
  var a = gV(e + ""), r, o = a.length, s;
  if (arguments.length < 2) {
    var i = this.node().__on;
    if (i) {
      for (var u = 0, d = i.length, c; u < d; ++u)
        for (r = 0, c = i[u]; r < o; ++r)
          if ((s = a[r]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (i = t ? bV : yV, r = 0; r < o; ++r) this.each(i(a[r], t, n));
  return this;
}
function xb(e, t, n) {
  var a = gb(e), r = a.CustomEvent;
  typeof r == "function" ? r = new r(t, n) : (r = a.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r);
}
function wV(e, t) {
  return function() {
    return xb(this, e, t);
  };
}
function xV(e, t) {
  return function() {
    return xb(this, e, t.apply(this, arguments));
  };
}
function CV(e, t) {
  return this.each((typeof t == "function" ? xV : wV)(e, t));
}
function* SV() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length, s; r < o; ++r)
      (s = a[r]) && (yield s);
}
var Cb = [null];
function hn(e, t) {
  this._groups = e, this._parents = t;
}
function ks() {
  return new hn([[document.documentElement]], Cb);
}
function $V() {
  return this;
}
hn.prototype = ks.prototype = {
  constructor: hn,
  select: J3,
  selectAll: tR,
  selectChild: oR,
  selectChildren: uR,
  filter: dR,
  data: hR,
  enter: cR,
  exit: yR,
  join: bR,
  merge: _R,
  selection: $V,
  order: wR,
  sort: xR,
  call: SR,
  nodes: $R,
  node: kR,
  size: BR,
  empty: DR,
  each: PR,
  attr: OR,
  style: NR,
  property: UR,
  classed: KR,
  text: ZR,
  html: nV,
  raise: rV,
  lower: sV,
  append: lV,
  insert: uV,
  remove: cV,
  clone: vV,
  datum: mV,
  on: _V,
  dispatch: CV,
  [Symbol.iterator]: SV
};
function Ea(e) {
  return typeof e == "string" ? new hn([[document.querySelector(e)]], [document.documentElement]) : new hn([[e]], Cb);
}
function kV(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function zl(e, t) {
  if (e = kV(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var a = n.createSVGPoint();
      return a.x = e.clientX, a.y = e.clientY, a = a.matrixTransform(t.getScreenCTM().inverse()), [a.x, a.y];
    }
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect();
      return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
var Ao;
(function(e) {
  e[e.SVG = 0] = "SVG", e[e.HTML = 1] = "HTML";
})(Ao || (Ao = {}));
var Ad;
(function(e) {
  e.Fit = "fit", e.Extend = "extend", e.FitWidth = "fit_width";
})(Ad || (Ad = {}));
function Io(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function BV(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function $f(e) {
  let t, n, a;
  e.length !== 2 ? (t = Io, n = (i, u) => Io(e(i), u), a = (i, u) => e(i) - u) : (t = e === Io || e === BV ? e : DV, n = e, a = e);
  function r(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) < 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function o(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) <= 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function s(i, u, d = 0, c = i.length) {
    const f = r(i, u, d, c - 1);
    return f > d && a(i[f - 1], u) > -a(i[f], u) ? f - 1 : f;
  }
  return { left: r, center: s, right: o };
}
function DV() {
  return 0;
}
function Sb(e) {
  return e === null ? NaN : +e;
}
const $b = $f(Io), Bs = $b.right, PV = $b.left;
$f(Sb).center;
class Pv extends Map {
  constructor(t, n = EV) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [a, r] of t) this.set(a, r);
  }
  get(t) {
    return super.get(Mv(this, t));
  }
  has(t) {
    return super.has(Mv(this, t));
  }
  set(t, n) {
    return super.set(MV(this, t), n);
  }
  delete(t) {
    return super.delete(qV(this, t));
  }
}
function Mv({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : n;
}
function MV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : (e.set(a, n), n);
}
function qV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) && (n = e.get(a), e.delete(a)), n;
}
function EV(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const TV = Math.sqrt(50), AV = Math.sqrt(10), IV = Math.sqrt(2);
function Hl(e, t, n) {
  const a = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(a)), o = a / Math.pow(10, r), s = o >= TV ? 10 : o >= AV ? 5 : o >= IV ? 2 : 1;
  let i, u, d;
  return r < 0 ? (d = Math.pow(10, -r) / s, i = Math.round(e * d), u = Math.round(t * d), i / d < e && ++i, u / d > t && --u, d = -d) : (d = Math.pow(10, r) * s, i = Math.round(e / d), u = Math.round(t / d), i * d < e && ++i, u * d > t && --u), u < i && 0.5 <= n && n < 2 ? Hl(e, t, n * 2) : [i, u, d];
}
function Id(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const a = t < e, [r, o, s] = a ? Hl(t, e, n) : Hl(e, t, n);
  if (!(o >= r)) return [];
  const i = o - r + 1, u = new Array(i);
  if (a)
    if (s < 0) for (let d = 0; d < i; ++d) u[d] = (o - d) / -s;
    else for (let d = 0; d < i; ++d) u[d] = (o - d) * s;
  else if (s < 0) for (let d = 0; d < i; ++d) u[d] = (r + d) / -s;
  else for (let d = 0; d < i; ++d) u[d] = (r + d) * s;
  return u;
}
function Od(e, t, n) {
  return t = +t, e = +e, n = +n, Hl(e, t, n)[2];
}
function Rd(e, t, n) {
  t = +t, e = +e, n = +n;
  const a = t < e, r = a ? Od(t, e, n) : Od(e, t, n);
  return (a ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function qv(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Ev(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function OV(e, t, n = Sb) {
  if (!(!(a = e.length) || isNaN(t = +t))) {
    if (t <= 0 || a < 2) return +n(e[0], 0, e);
    if (t >= 1) return +n(e[a - 1], a - 1, e);
    var a, r = (a - 1) * t, o = Math.floor(r), s = +n(e[o], o, e), i = +n(e[o + 1], o + 1, e);
    return s + (i - s) * (r - o);
  }
}
function RV(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var a = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++a < r; )
    o[a] = e + a * n;
  return o;
}
function VV(e, t, n) {
  var a = {}, r = a.noTrailing, o = r === void 0 ? !1 : r, s = a.noLeading, i = s === void 0 ? !1 : s, u = a.debounceMode, d = u === void 0 ? void 0 : u, c, f = !1, p = 0;
  function v() {
    c && clearTimeout(c);
  }
  function m(w) {
    var C = w || {}, S = C.upcomingOnly, $ = S === void 0 ? !1 : S;
    v(), f = !$;
  }
  function g() {
    for (var w = arguments.length, C = new Array(w), S = 0; S < w; S++)
      C[S] = arguments[S];
    var $ = this, B = Date.now() - p;
    if (f)
      return;
    function k() {
      p = Date.now(), t.apply($, C);
    }
    function P() {
      c = void 0;
    }
    !i && d && !c && k(), v(), d === void 0 && B > e ? i ? (p = Date.now(), o || (c = setTimeout(d ? P : k, e))) : k() : o !== !0 && (c = setTimeout(d ? P : k, d === void 0 ? e - B : e));
  }
  return g.cancel = m, g;
}
var ia;
(function(e) {
  e.Left = "left", e.Right = "right", e.Auto = "auto";
})(ia || (ia = {}));
const Oo = (e) => typeof e == "number", kf = (e) => typeof e == "function", Bf = (e) => Array.isArray(e), FV = (e) => e instanceof Object, Ul = (e) => e.constructor.name !== "Function" && e.constructor.name !== "Object", Tv = (e) => FV(e) && !Bf(e) && !kf(e) && !Ul(e), Vd = (e, t, n = [], a = /* @__PURE__ */ new Set()) => {
  if (Array.isArray(e)) {
    if (!Array.isArray(t) || e.length !== t.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (let r = 0; r < e.length; r++)
      if (!Vd(e[r], t[r], n, a))
        return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (typeof e == "object" && e !== null && t !== null) {
    if (typeof t != "object")
      return !1;
    if (e === t)
      return !0;
    const r = Object.keys(e).filter((s) => !n.includes(s)), o = Object.keys(t).filter((s) => !n.includes(s));
    if (r.length !== o.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (const s of r)
      if (!Vd(e[s], t[s], n, a))
        return !1;
    return !0;
  }
  return e === t;
}, jl = (e, t = /* @__PURE__ */ new Map()) => {
  if (typeof e != "object" || e === null)
    return e;
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof Array) {
    const n = [];
    t.set(e, n);
    for (const a of e)
      n.push(t.has(a) ? t.get(a) : jl(a, t));
    return n;
  }
  if (Ul(e))
    return e;
  if (e instanceof Object) {
    const n = {};
    t.set(e, n);
    const a = e;
    return Object.keys(e).reduce((r, o) => (r[o] = t.has(a[o]) ? t.get(a[o]) : jl(a[o], t), r), n), n;
  }
  return e;
}, Ji = (e, t, n = /* @__PURE__ */ new Map()) => {
  if (!e || !t || e === t)
    return e;
  const a = Ul(e) ? e : jl(e);
  return n.has(t) ? n.get(t) : (n.set(t, a), Object.keys(t).forEach((r) => {
    r === "__proto__" || r === "constructor" || (Tv(e[r]) && Tv(t[r]) ? a[r] = Ji(e[r], t[r], n) : Ul(t) ? a[r] = t : a[r] = jl(t[r]));
  }), a);
}, kb = (e, t) => (e = Object.assign({}, e), t.forEach((n) => delete e[n]), e), Wl = (e, t, n) => VV(t, e);
function Bb(e, t, n) {
  return kf(t) ? t(e, n) : t;
}
function Db(e, t, n) {
  return Bb(e, t, n);
}
function pn(e, t, n) {
  return Bb(e, t, n);
}
function Av(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function NV(e, t, ...n) {
  const a = [];
  let r = 0, o = 0;
  for (const s of n) {
    const i = pn(e, s, t) || 0;
    i >= 0 ? a.push(r += i) : a.push(o += i);
  }
  return a;
}
function LV(e, ...t) {
  return e ? Ev(e, (a, r) => Ev(t, (o) => pn(a, o, r))) : void 0;
}
function zV(e, ...t) {
  return e ? qv(e, (a, r) => qv(t, (o) => pn(a, o, r))) : void 0;
}
function Nu(e, ...t) {
  return [LV(e, ...t), zV(e, ...t)];
}
function Gl(e, t, n, a = ia.Auto) {
  if (e.length <= 1)
    return e[0];
  const o = e.map((u, d) => [u, d]).sort(([u, d], [c, f]) => pn(u, n, d) - pn(c, n, f)), s = o.map(([u, d]) => pn(u, n, d)), i = a === ia.Right ? PV(s, t, 0, e.length - 1) : Bs(s, t, 1, e.length);
  return a === ia.Right ? o[i][0] : a === ia.Left ? o[i - 1][0] : t - s[i - 1] > s[i] - t ? o[i][0] : o[i - 1][0];
}
function HV(e, t, n, a = !1) {
  if (!n)
    return [];
  const r = e.filter((o, s) => {
    const i = pn(o, n, s);
    return i >= t[0] && i <= t[1];
  });
  if (a) {
    if (r.length === 0) {
      const f = Gl(e, t[0], n, ia.Left), p = Gl(e, t[1], n, ia.Right);
      return [f, p].filter(Boolean);
    }
    const o = r[0], s = r[r.length - 1], i = e.findIndex((f) => f === o), u = e.findIndex((f) => f === s), d = Math.max(0, i - 1), c = Math.min(e.length - 1, u + 1);
    return e.slice(d, c + 1);
  }
  return r;
}
const UV = (e) => e == null ? [] : Array.isArray(e) ? e : [e];
function jV(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function WV(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var GV = /* @__PURE__ */ (function() {
  function e(n) {
    var a = this;
    this._insertTag = function(r) {
      var o;
      a.tags.length === 0 ? a.insertionPoint ? o = a.insertionPoint.nextSibling : a.prepend ? o = a.container.firstChild : o = a.before : o = a.tags[a.tags.length - 1].nextSibling, a.container.insertBefore(r, o), a.tags.push(r);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(a) {
    a.forEach(this._insertTag);
  }, t.insert = function(a) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(WV(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = jV(r);
      try {
        o.insertRule(a, o.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(a));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(a) {
      var r;
      return (r = a.parentNode) == null ? void 0 : r.removeChild(a);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), Ut = "-ms-", Kl = "-moz-", et = "-webkit-", Pb = "comm", Df = "rule", Pf = "decl", KV = "@import", Mb = "@keyframes", YV = "@layer", XV = Math.abs, Zi = String.fromCharCode, JV = Object.assign;
function ZV(e, t) {
  return Ft(e, 0) ^ 45 ? (((t << 2 ^ Ft(e, 0)) << 2 ^ Ft(e, 1)) << 2 ^ Ft(e, 2)) << 2 ^ Ft(e, 3) : 0;
}
function qb(e) {
  return e.trim();
}
function QV(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function nt(e, t, n) {
  return e.replace(t, n);
}
function Fd(e, t) {
  return e.indexOf(t);
}
function Ft(e, t) {
  return e.charCodeAt(t) | 0;
}
function Zo(e, t, n) {
  return e.slice(t, n);
}
function Un(e) {
  return e.length;
}
function Mf(e) {
  return e.length;
}
function Ys(e, t) {
  return t.push(e), e;
}
function eF(e, t) {
  return e.map(t).join("");
}
var Qi = 1, Hr = 1, Eb = 0, on = 0, xt = 0, lo = "";
function eu(e, t, n, a, r, o, s) {
  return { value: e, root: t, parent: n, type: a, props: r, children: o, line: Qi, column: Hr, length: s, return: "" };
}
function ho(e, t) {
  return JV(eu("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function tF() {
  return xt;
}
function nF() {
  return xt = on > 0 ? Ft(lo, --on) : 0, Hr--, xt === 10 && (Hr = 1, Qi--), xt;
}
function mn() {
  return xt = on < Eb ? Ft(lo, on++) : 0, Hr++, xt === 10 && (Hr = 1, Qi++), xt;
}
function Kn() {
  return Ft(lo, on);
}
function pl() {
  return on;
}
function Ds(e, t) {
  return Zo(lo, e, t);
}
function Qo(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Tb(e) {
  return Qi = Hr = 1, Eb = Un(lo = e), on = 0, [];
}
function Ab(e) {
  return lo = "", e;
}
function vl(e) {
  return qb(Ds(on - 1, Nd(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function aF(e) {
  for (; (xt = Kn()) && xt < 33; )
    mn();
  return Qo(e) > 2 || Qo(xt) > 3 ? "" : " ";
}
function rF(e, t) {
  for (; --t && mn() && !(xt < 48 || xt > 102 || xt > 57 && xt < 65 || xt > 70 && xt < 97); )
    ;
  return Ds(e, pl() + (t < 6 && Kn() == 32 && mn() == 32));
}
function Nd(e) {
  for (; mn(); )
    switch (xt) {
      // ] ) " '
      case e:
        return on;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Nd(xt);
        break;
      // (
      case 40:
        e === 41 && Nd(e);
        break;
      // \
      case 92:
        mn();
        break;
    }
  return on;
}
function oF(e, t) {
  for (; mn() && e + xt !== 57; )
    if (e + xt === 84 && Kn() === 47)
      break;
  return "/*" + Ds(t, on - 1) + "*" + Zi(e === 47 ? e : mn());
}
function sF(e) {
  for (; !Qo(Kn()); )
    mn();
  return Ds(e, on);
}
function lF(e) {
  return Ab(ml("", null, null, null, [""], e = Tb(e), 0, [0], e));
}
function ml(e, t, n, a, r, o, s, i, u) {
  for (var d = 0, c = 0, f = s, p = 0, v = 0, m = 0, g = 1, w = 1, C = 1, S = 0, $ = "", B = r, k = o, P = a, D = $; w; )
    switch (m = S, S = mn()) {
      // (
      case 40:
        if (m != 108 && Ft(D, f - 1) == 58) {
          Fd(D += nt(vl(S), "&", "&\f"), "&\f") != -1 && (C = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        D += vl(S);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        D += aF(m);
        break;
      // \
      case 92:
        D += rF(pl() - 1, 7);
        continue;
      // /
      case 47:
        switch (Kn()) {
          case 42:
          case 47:
            Ys(iF(oF(mn(), pl()), t, n), u);
            break;
          default:
            D += "/";
        }
        break;
      // {
      case 123 * g:
        i[d++] = Un(D) * C;
      // } ; \0
      case 125 * g:
      case 59:
      case 0:
        switch (S) {
          // \0 }
          case 0:
          case 125:
            w = 0;
          // ;
          case 59 + c:
            C == -1 && (D = nt(D, /\f/g, "")), v > 0 && Un(D) - f && Ys(v > 32 ? Ov(D + ";", a, n, f - 1) : Ov(nt(D, " ", "") + ";", a, n, f - 2), u);
            break;
          // @ ;
          case 59:
            D += ";";
          // { rule/at-rule
          default:
            if (Ys(P = Iv(D, t, n, d, c, r, i, $, B = [], k = [], f), o), S === 123)
              if (c === 0)
                ml(D, t, P, P, B, o, f, i, k);
              else
                switch (p === 99 && Ft(D, 3) === 110 ? 100 : p) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    ml(e, P, P, a && Ys(Iv(e, P, P, 0, 0, r, i, $, r, B = [], f), k), r, k, f, i, a ? B : k);
                    break;
                  default:
                    ml(D, P, P, P, [""], k, 0, i, k);
                }
        }
        d = c = v = 0, g = C = 1, $ = D = "", f = s;
        break;
      // :
      case 58:
        f = 1 + Un(D), v = m;
      default:
        if (g < 1) {
          if (S == 123)
            --g;
          else if (S == 125 && g++ == 0 && nF() == 125)
            continue;
        }
        switch (D += Zi(S), S * g) {
          // &
          case 38:
            C = c > 0 ? 1 : (D += "\f", -1);
            break;
          // ,
          case 44:
            i[d++] = (Un(D) - 1) * C, C = 1;
            break;
          // @
          case 64:
            Kn() === 45 && (D += vl(mn())), p = Kn(), c = f = Un($ = D += sF(pl())), S++;
            break;
          // -
          case 45:
            m === 45 && Un(D) == 2 && (g = 0);
        }
    }
  return o;
}
function Iv(e, t, n, a, r, o, s, i, u, d, c) {
  for (var f = r - 1, p = r === 0 ? o : [""], v = Mf(p), m = 0, g = 0, w = 0; m < a; ++m)
    for (var C = 0, S = Zo(e, f + 1, f = XV(g = s[m])), $ = e; C < v; ++C)
      ($ = qb(g > 0 ? p[C] + " " + S : nt(S, /&\f/g, p[C]))) && (u[w++] = $);
  return eu(e, t, n, r === 0 ? Df : i, u, d, c);
}
function iF(e, t, n) {
  return eu(e, t, n, Pb, Zi(tF()), Zo(e, 2, -2), 0);
}
function Ov(e, t, n, a) {
  return eu(e, t, n, Pf, Zo(e, 0, a), Zo(e, a + 1, -1), a);
}
function Ar(e, t) {
  for (var n = "", a = Mf(e), r = 0; r < a; r++)
    n += t(e[r], r, e, t) || "";
  return n;
}
function uF(e, t, n, a) {
  switch (e.type) {
    case YV:
      if (e.children.length) break;
    case KV:
    case Pf:
      return e.return = e.return || e.value;
    case Pb:
      return "";
    case Mb:
      return e.return = e.value + "{" + Ar(e.children, a) + "}";
    case Df:
      e.value = e.props.join(",");
  }
  return Un(n = Ar(e.children, a)) ? e.return = e.value + "{" + n + "}" : "";
}
function dF(e) {
  var t = Mf(e);
  return function(n, a, r, o) {
    for (var s = "", i = 0; i < t; i++)
      s += e[i](n, a, r, o) || "";
    return s;
  };
}
function cF(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function fF(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var pF = function(t, n, a) {
  for (var r = 0, o = 0; r = o, o = Kn(), r === 38 && o === 12 && (n[a] = 1), !Qo(o); )
    mn();
  return Ds(t, on);
}, vF = function(t, n) {
  var a = -1, r = 44;
  do
    switch (Qo(r)) {
      case 0:
        r === 38 && Kn() === 12 && (n[a] = 1), t[a] += pF(on - 1, n, a);
        break;
      case 2:
        t[a] += vl(r);
        break;
      case 4:
        if (r === 44) {
          t[++a] = Kn() === 58 ? "&\f" : "", n[a] = t[a].length;
          break;
        }
      // fallthrough
      default:
        t[a] += Zi(r);
    }
  while (r = mn());
  return t;
}, mF = function(t, n) {
  return Ab(vF(Tb(t), n));
}, Rv = /* @__PURE__ */ new WeakMap(), hF = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, a = t.parent, r = t.column === a.column && t.line === a.line; a.type !== "rule"; )
      if (a = a.parent, !a) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Rv.get(a)) && !r) {
      Rv.set(t, !0);
      for (var o = [], s = mF(n, o), i = a.props, u = 0, d = 0; u < s.length; u++)
        for (var c = 0; c < i.length; c++, d++)
          t.props[d] = o[u] ? s[u].replace(/&\f/g, i[c]) : i[c] + " " + s[u];
    }
  }
}, gF = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function Ib(e, t) {
  switch (ZV(e, t)) {
    // color-adjust
    case 5103:
      return et + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return et + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return et + e + Kl + e + Ut + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return et + e + Ut + e + e;
    // order
    case 6165:
      return et + e + Ut + "flex-" + e + e;
    // align-items
    case 5187:
      return et + e + nt(e, /(\w+).+(:[^]+)/, et + "box-$1$2" + Ut + "flex-$1$2") + e;
    // align-self
    case 5443:
      return et + e + Ut + "flex-item-" + nt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return et + e + Ut + "flex-line-pack" + nt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return et + e + Ut + nt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return et + e + Ut + nt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return et + "box-" + nt(e, "-grow", "") + et + e + Ut + nt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return et + nt(e, /([^-])(transform)/g, "$1" + et + "$2") + e;
    // cursor
    case 6187:
      return nt(nt(nt(e, /(zoom-|grab)/, et + "$1"), /(image-set)/, et + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return nt(e, /(image-set\([^]*)/, et + "$1$`$1");
    // justify-content
    case 4968:
      return nt(nt(e, /(.+:)(flex-)?(.*)/, et + "box-pack:$3" + Ut + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + et + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return nt(e, /(.+)-inline(.+)/, et + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Un(e) - 1 - t > 6) switch (Ft(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (Ft(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return nt(e, /(.+:)(.+)-([^]+)/, "$1" + et + "$2-$3$1" + Kl + (Ft(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Fd(e, "stretch") ? Ib(nt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (Ft(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (Ft(e, Un(e) - 3 - (~Fd(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return nt(e, ":", ":" + et) + e;
        // (inline-)?fl(e)x
        case 101:
          return nt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + et + (Ft(e, 14) === 45 ? "inline-" : "") + "box$3$1" + et + "$2$3$1" + Ut + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (Ft(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return et + e + Ut + nt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return et + e + Ut + nt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return et + e + Ut + nt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return et + e + Ut + e + e;
  }
  return e;
}
var yF = function(t, n, a, r) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Pf:
      t.return = Ib(t.value, t.length);
      break;
    case Mb:
      return Ar([ho(t, {
        value: nt(t.value, "@", "@" + et)
      })], r);
    case Df:
      if (t.length) return eF(t.props, function(o) {
        switch (QV(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Ar([ho(t, {
              props: [nt(o, /:(read-\w+)/, ":" + Kl + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return Ar([ho(t, {
              props: [nt(o, /:(plac\w+)/, ":" + et + "input-$1")]
            }), ho(t, {
              props: [nt(o, /:(plac\w+)/, ":" + Kl + "$1")]
            }), ho(t, {
              props: [nt(o, /:(plac\w+)/, Ut + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, bF = [yF], _F = function(t) {
  var n = t.key;
  if (n === "css") {
    var a = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(a, function(g) {
      var w = g.getAttribute("data-emotion");
      w.indexOf(" ") !== -1 && (document.head.appendChild(g), g.setAttribute("data-s", ""));
    });
  }
  var r = t.stylisPlugins || bF, o = {}, s, i = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(g) {
      for (var w = g.getAttribute("data-emotion").split(" "), C = 1; C < w.length; C++)
        o[w[C]] = !0;
      i.push(g);
    }
  );
  var u, d = [hF, gF];
  {
    var c, f = [uF, cF(function(g) {
      c.insert(g);
    })], p = dF(d.concat(r, f)), v = function(w) {
      return Ar(lF(w), p);
    };
    u = function(w, C, S, $) {
      c = S, v(w ? w + "{" + C.styles + "}" : C.styles), $ && (m.inserted[C.name] = !0);
    };
  }
  var m = {
    key: n,
    sheet: new GV({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return m.sheet.hydrate(i), m;
};
function wF(e) {
  for (var t = 0, n, a = 0, r = e.length; r >= 4; ++a, r -= 4)
    n = e.charCodeAt(a) & 255 | (e.charCodeAt(++a) & 255) << 8 | (e.charCodeAt(++a) & 255) << 16 | (e.charCodeAt(++a) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (r) {
    case 3:
      t ^= (e.charCodeAt(a + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(a + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(a) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var xF = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, CF = /[A-Z]|^ms/g, SF = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Ob = function(t) {
  return t.charCodeAt(1) === 45;
}, Vv = function(t) {
  return t != null && typeof t != "boolean";
}, Lu = /* @__PURE__ */ fF(function(e) {
  return Ob(e) ? e : e.replace(CF, "-$&").toLowerCase();
}), Fv = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(SF, function(a, r, o) {
          return qa = {
            name: r,
            styles: o,
            next: qa
          }, r;
        });
  }
  return xF[t] !== 1 && !Ob(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Yl(e, t, n) {
  if (n == null)
    return "";
  var a = n;
  if (a.__emotion_styles !== void 0)
    return a;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var r = n;
      if (r.anim === 1)
        return qa = {
          name: r.name,
          styles: r.styles,
          next: qa
        }, r.name;
      var o = n;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            qa = {
              name: s.name,
              styles: s.styles,
              next: qa
            }, s = s.next;
        var i = o.styles + ";";
        return i;
      }
      return $F(e, t, n);
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function $F(e, t, n) {
  var a = "";
  if (Array.isArray(n))
    for (var r = 0; r < n.length; r++)
      a += Yl(e, t, n[r]) + ";";
  else
    for (var o in n) {
      var s = n[o];
      if (typeof s != "object") {
        var i = s;
        t != null && t[i] !== void 0 ? a += o + "{" + t[i] + "}" : Vv(i) && (a += Lu(o) + ":" + Fv(o, i) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var u = 0; u < s.length; u++)
          Vv(s[u]) && (a += Lu(o) + ":" + Fv(o, s[u]) + ";");
      else {
        var d = Yl(e, t, s);
        switch (o) {
          case "animation":
          case "animationName": {
            a += Lu(o) + ":" + d + ";";
            break;
          }
          default:
            a += o + "{" + d + "}";
        }
      }
    }
  return a;
}
var Nv = /label:\s*([^\s;{]+)\s*(;|$)/g, qa;
function zu(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var a = !0, r = "";
  qa = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    a = !1, r += Yl(n, t, o);
  else {
    var s = o;
    r += s[0];
  }
  for (var i = 1; i < e.length; i++)
    if (r += Yl(n, t, e[i]), a) {
      var u = o;
      r += u[i];
    }
  Nv.lastIndex = 0;
  for (var d = "", c; (c = Nv.exec(r)) !== null; )
    d += "-" + c[1];
  var f = wF(r) + d;
  return {
    name: f,
    styles: r,
    next: qa
  };
}
function Rb(e, t, n) {
  var a = "";
  return n.split(" ").forEach(function(r) {
    e[r] !== void 0 ? t.push(e[r] + ";") : r && (a += r + " ");
  }), a;
}
var kF = function(t, n, a) {
  var r = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[r] === void 0 && (t.registered[r] = n.styles);
}, BF = function(t, n, a) {
  kF(t, n);
  var r = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + r : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function Lv(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function zv(e, t, n) {
  var a = [], r = Rb(e, a, n);
  return a.length < 2 ? n : r + t(a);
}
var DF = function(t) {
  var n = _F(t);
  n.sheet.speedy = function(i) {
    this.isSpeedy = i;
  }, n.compat = !0;
  var a = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = zu(d, n.registered, void 0);
    return BF(n, f), n.key + "-" + f.name;
  }, r = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = zu(d, n.registered), p = "animation-" + f.name;
    return Lv(n, {
      name: f.name,
      styles: "@keyframes " + p + "{" + f.styles + "}"
    }), p;
  }, o = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = zu(d, n.registered);
    Lv(n, f);
  }, s = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    return zv(n.registered, a, PF(d));
  };
  return {
    css: a,
    cx: s,
    injectGlobal: o,
    keyframes: r,
    hydrate: function(u) {
      u.forEach(function(d) {
        n.inserted[d] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: Rb.bind(null, n.registered),
    merge: zv.bind(null, n.registered, a)
  };
}, PF = function e(t) {
  for (var n = "", a = 0; a < t.length; a++) {
    var r = t[a];
    if (r != null) {
      var o = void 0;
      switch (typeof r) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(r))
            o = e(r);
          else {
            o = "";
            for (var s in r)
              r[s] && s && (o && (o += " "), o += s);
          }
          break;
        }
        default:
          o = r;
      }
      o && (n && (n += " "), n += o);
    }
  }
  return n;
}, Vb = DF({
  key: "css"
}), qf = Vb.injectGlobal, ln = Vb.css, Hu, Hv;
function MF() {
  return Hv || (Hv = 1, Hu = function(t, n) {
    n || (n = [0, ""]), t = String(t);
    var a = parseFloat(t, 10);
    return n[0] = a, n[1] = t.match(/[\d.\-\+]*\s*(.*)/)[1] || "", n;
  }), Hu;
}
var Uu, Uv;
function qF() {
  if (Uv) return Uu;
  Uv = 1;
  var e = MF();
  Uu = r;
  var t = a("in", document.body);
  function n(o, s) {
    var i = e(getComputedStyle(o).getPropertyValue(s));
    return i[0] * r(i[1], o);
  }
  function a(o, s) {
    var i = document.createElement("div");
    i.style.height = "128" + o, s.appendChild(i);
    var u = n(i, "height") / 128;
    return s.removeChild(i), u;
  }
  function r(o, s) {
    if (!o) return null;
    switch (s = s || document.body, o = (o + "" || "px").trim().toLowerCase(), (s === window || s === document) && (s = document.body), o) {
      case "%":
        return s.clientHeight / 100;
      case "ch":
      case "ex":
        return a(o, s);
      case "em":
        return n(s, "font-size");
      case "rem":
        return n(document.body, "font-size");
      case "vw":
        return window.innerWidth / 100;
      case "vh":
        return window.innerHeight / 100;
      case "vmin":
        return Math.min(window.innerWidth, window.innerHeight) / 100;
      case "vmax":
        return Math.max(window.innerWidth, window.innerHeight) / 100;
      case "in":
        return t;
      case "cm":
        return t / 2.54;
      case "mm":
        return t / 25.4;
      case "pt":
        return t / 72;
      case "pc":
        return t / 6;
      case "px":
        return 1;
    }
    var i = e(o);
    if (!isNaN(i[0]) && i[1]) {
      var u = r(i[1], s);
      return typeof u == "number" ? i[0] * u : null;
    }
    return null;
  }
  return Uu;
}
var EF = qF();
const Ld = /* @__PURE__ */ oh(EF);
function TF() {
  const e = () => Math.floor((1 + crypto.getRandomValues(new Uint32Array(1))[0]) * 65536).toString(16).substring(1);
  return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`;
}
function Ef(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Fb(e, t) {
  var n = Object.create(e.prototype);
  for (var a in t) n[a] = t[a];
  return n;
}
function Ps() {
}
var es = 0.7, Xl = 1 / es, Ir = "\\s*([+-]?\\d+)\\s*", ts = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Yn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", AF = /^#([0-9a-f]{3,8})$/, IF = new RegExp(`^rgb\\(${Ir},${Ir},${Ir}\\)$`), OF = new RegExp(`^rgb\\(${Yn},${Yn},${Yn}\\)$`), RF = new RegExp(`^rgba\\(${Ir},${Ir},${Ir},${ts}\\)$`), VF = new RegExp(`^rgba\\(${Yn},${Yn},${Yn},${ts}\\)$`), FF = new RegExp(`^hsl\\(${ts},${Yn},${Yn}\\)$`), NF = new RegExp(`^hsla\\(${ts},${Yn},${Yn},${ts}\\)$`), jv = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Ef(Ps, ar, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Wv,
  // Deprecated! Use color.formatHex.
  formatHex: Wv,
  formatHex8: LF,
  formatHsl: zF,
  formatRgb: Gv,
  toString: Gv
});
function Wv() {
  return this.rgb().formatHex();
}
function LF() {
  return this.rgb().formatHex8();
}
function zF() {
  return Nb(this).formatHsl();
}
function Gv() {
  return this.rgb().formatRgb();
}
function ar(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = AF.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Kv(t) : n === 3 ? new tn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Xs(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Xs(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = IF.exec(e)) ? new tn(t[1], t[2], t[3], 1) : (t = OF.exec(e)) ? new tn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = RF.exec(e)) ? Xs(t[1], t[2], t[3], t[4]) : (t = VF.exec(e)) ? Xs(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = FF.exec(e)) ? Jv(t[1], t[2] / 100, t[3] / 100, 1) : (t = NF.exec(e)) ? Jv(t[1], t[2] / 100, t[3] / 100, t[4]) : jv.hasOwnProperty(e) ? Kv(jv[e]) : e === "transparent" ? new tn(NaN, NaN, NaN, 0) : null;
}
function Kv(e) {
  return new tn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Xs(e, t, n, a) {
  return a <= 0 && (e = t = n = NaN), new tn(e, t, n, a);
}
function HF(e) {
  return e instanceof Ps || (e = ar(e)), e ? (e = e.rgb(), new tn(e.r, e.g, e.b, e.opacity)) : new tn();
}
function zd(e, t, n, a) {
  return arguments.length === 1 ? HF(e) : new tn(e, t, n, a ?? 1);
}
function tn(e, t, n, a) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +a;
}
Ef(tn, zd, Fb(Ps, {
  brighter(e) {
    return e = e == null ? Xl : Math.pow(Xl, e), new tn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? es : Math.pow(es, e), new tn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new tn(Qa(this.r), Qa(this.g), Qa(this.b), Jl(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Yv,
  // Deprecated! Use color.formatHex.
  formatHex: Yv,
  formatHex8: UF,
  formatRgb: Xv,
  toString: Xv
}));
function Yv() {
  return `#${Ya(this.r)}${Ya(this.g)}${Ya(this.b)}`;
}
function UF() {
  return `#${Ya(this.r)}${Ya(this.g)}${Ya(this.b)}${Ya((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Xv() {
  const e = Jl(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Qa(this.r)}, ${Qa(this.g)}, ${Qa(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Jl(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Qa(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ya(e) {
  return e = Qa(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Jv(e, t, n, a) {
  return a <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Dn(e, t, n, a);
}
function Nb(e) {
  if (e instanceof Dn) return new Dn(e.h, e.s, e.l, e.opacity);
  if (e instanceof Ps || (e = ar(e)), !e) return new Dn();
  if (e instanceof Dn) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, a = e.b / 255, r = Math.min(t, n, a), o = Math.max(t, n, a), s = NaN, i = o - r, u = (o + r) / 2;
  return i ? (t === o ? s = (n - a) / i + (n < a) * 6 : n === o ? s = (a - t) / i + 2 : s = (t - n) / i + 4, i /= u < 0.5 ? o + r : 2 - o - r, s *= 60) : i = u > 0 && u < 1 ? 0 : s, new Dn(s, i, u, e.opacity);
}
function jF(e, t, n, a) {
  return arguments.length === 1 ? Nb(e) : new Dn(e, t, n, a ?? 1);
}
function Dn(e, t, n, a) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +a;
}
Ef(Dn, jF, Fb(Ps, {
  brighter(e) {
    return e = e == null ? Xl : Math.pow(Xl, e), new Dn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? es : Math.pow(es, e), new Dn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, a = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - a;
    return new tn(
      ju(e >= 240 ? e - 240 : e + 120, r, a),
      ju(e, r, a),
      ju(e < 120 ? e + 240 : e - 120, r, a),
      this.opacity
    );
  },
  clamp() {
    return new Dn(Zv(this.h), Js(this.s), Js(this.l), Jl(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Jl(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Zv(this.h)}, ${Js(this.s) * 100}%, ${Js(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Zv(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Js(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function ju(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const WF = globalThis?.UNOVIS_COLORS || ["#4D8CFD", "#FF6B7E", "#F4B83E", "#A6CC74", "#00C19A", "#6859BE"], Lb = (e) => `--vis-${Oo(e) ? `color${e % WF.length}` : e}`, ns = 10, GF = [
  { id: "stripes-diagonal", svg: '<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="#000"/>' },
  { id: "dots", svg: '<path d="m0-1.5a1 1 0 010 3m10-3a1 1 0 000 3M5 3.5a1 1 0 010 3 1 1 0 010-3M0 8.5 a1 1 0 010 3m10-3a1 1 0 000 3" fill"#000"/>' },
  { id: "stripes-vertical", svg: '<path d="M 5,-1 L5,11" stroke="#000"/>' },
  { id: "crosshatch", svg: '<path d="M0 0L10 10ZM10 0L0 10Z" stroke="#000"/>' },
  { id: "waves", svg: '<path d="M0 4Q2.5 1 5 4 7.5 7 10 4v2Q7.5 9 5 6 2.5 3 0 6Z" fill="#000"/>' },
  { id: "circles", svg: '<circle cx="5" cy="5" r="3" stroke="#000" fill="#fff"/>' }
], KF = [
  { id: "circle", marker: '<circle cx="5" cy="5" r="5"/>', dashArray: [] },
  { id: "triangle", marker: '<path d="M5,0 L10,9 L0,9Z">', dashArray: [9, 1] },
  { id: "diamond", marker: '<path d="M 0 5 L5 0 L 10 5 L 5 10 L 0 5Z">', dashArray: [2] },
  { id: "arrow", marker: '<path d="M4 0 0 0 6 5 0 10 4 10 10 5Z">', dashArray: [2, 3, 8, 3] },
  { id: "square", marker: '<rect x="1" y="1" width="8" height="8"/>', dashArray: [6] },
  { id: "star", marker: '<path d="m2 9 3-9 3 9L0 3h10Z"/>', dashArray: [1, 6] }
];
function zb(e) {
  return `vis-${`pattern-${e.svg ? "fill" : "marker"}`}-${e.id}`;
}
const YF = (e) => `<mask id="${zb(e)}">
    <pattern id="${e.id}" viewBox="0 0 10 10" width="${ns}" height="${ns}" patternUnits="userSpaceOnUse">
      <rect width="100%" height="100%" fill="#fff"/>
      ${e.svg}
    </pattern>
    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#${e.id})"/>
  </mask>`, XF = (e, t) => `<marker id="${zb(e)}"
    fill="var(${Lb(t)})"
    markerUnits="userSpaceOnUse"
    refX="5"
    refY="5"
    markerWidth="${ns}"
    markerHeight="${ns}">
    ${e.marker}
  </marker>`;
function JF() {
  const e = GF.map(YF).concat(KF.map(XF)).join(""), t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.style.position = "fixed", t.style.zIndex = "-99999999", t.innerHTML = `<defs>${e}</defs>`, document.body.appendChild(t);
}
typeof window < "u" && JF();
var ZF = { value: () => {
} };
function Hb() {
  for (var e = 0, t = arguments.length, n = {}, a; e < t; ++e) {
    if (!(a = arguments[e] + "") || a in n || /[\s.]/.test(a)) throw new Error("illegal type: " + a);
    n[a] = [];
  }
  return new hl(n);
}
function hl(e) {
  this._ = e;
}
function QF(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var a = "", r = n.indexOf(".");
    if (r >= 0 && (a = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: a };
  });
}
hl.prototype = Hb.prototype = {
  constructor: hl,
  on: function(e, t) {
    var n = this._, a = QF(e + "", n), r, o = -1, s = a.length;
    if (arguments.length < 2) {
      for (; ++o < s; ) if ((r = (e = a[o]).type) && (r = e5(n[r], e.name))) return r;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++o < s; )
      if (r = (e = a[o]).type) n[r] = Qv(n[r], e.name, t);
      else if (t == null) for (r in n) n[r] = Qv(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new hl(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0) for (var n = new Array(r), a = 0, r, o; a < r; ++a) n[a] = arguments[a + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (o = this._[e], a = 0, r = o.length; a < r; ++a) o[a].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
  }
};
function e5(e, t) {
  for (var n = 0, a = e.length, r; n < a; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function Qv(e, t, n) {
  for (var a = 0, r = e.length; a < r; ++a)
    if (e[a].name === t) {
      e[a] = ZF, e = e.slice(0, a).concat(e.slice(a + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Ur = 0, ko = 0, go = 0, Ub = 1e3, Zl, Bo, Ql = 0, rr = 0, tu = 0, as = typeof performance == "object" && performance.now ? performance : Date, jb = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Tf() {
  return rr || (jb(t5), rr = as.now() + tu);
}
function t5() {
  rr = 0;
}
function ei() {
  this._call = this._time = this._next = null;
}
ei.prototype = Wb.prototype = {
  constructor: ei,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Tf() : +n) + (t == null ? 0 : +t), !this._next && Bo !== this && (Bo ? Bo._next = this : Zl = this, Bo = this), this._call = e, this._time = n, Hd();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Hd());
  }
};
function Wb(e, t, n) {
  var a = new ei();
  return a.restart(e, t, n), a;
}
function n5() {
  Tf(), ++Ur;
  for (var e = Zl, t; e; )
    (t = rr - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Ur;
}
function em() {
  rr = (Ql = as.now()) + tu, Ur = ko = 0;
  try {
    n5();
  } finally {
    Ur = 0, r5(), rr = 0;
  }
}
function a5() {
  var e = as.now(), t = e - Ql;
  t > Ub && (tu -= t, Ql = e);
}
function r5() {
  for (var e, t = Zl, n, a = 1 / 0; t; )
    t._call ? (a > t._time && (a = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Zl = n);
  Bo = e, Hd(a);
}
function Hd(e) {
  if (!Ur) {
    ko && (ko = clearTimeout(ko));
    var t = e - rr;
    t > 24 ? (e < 1 / 0 && (ko = setTimeout(em, e - as.now() - tu)), go && (go = clearInterval(go))) : (go || (Ql = as.now(), go = setInterval(a5, Ub)), Ur = 1, jb(em));
  }
}
function tm(e, t, n) {
  var a = new ei();
  return t = t == null ? 0 : +t, a.restart((r) => {
    a.stop(), e(r + t);
  }, t, n), a;
}
var o5 = Hb("start", "end", "cancel", "interrupt"), s5 = [], Gb = 0, nm = 1, Ud = 2, gl = 3, am = 4, jd = 5, yl = 6;
function nu(e, t, n, a, r, o) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  l5(e, n, {
    name: t,
    index: a,
    // For context during callback.
    group: r,
    // For context during callback.
    on: o5,
    tween: s5,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: Gb
  });
}
function Af(e, t) {
  var n = Fn(e, t);
  if (n.state > Gb) throw new Error("too late; already scheduled");
  return n;
}
function ea(e, t) {
  var n = Fn(e, t);
  if (n.state > gl) throw new Error("too late; already running");
  return n;
}
function Fn(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function l5(e, t, n) {
  var a = e.__transition, r;
  a[t] = n, n.timer = Wb(o, 0, n.time);
  function o(d) {
    n.state = nm, n.timer.restart(s, n.delay, n.time), n.delay <= d && s(d - n.delay);
  }
  function s(d) {
    var c, f, p, v;
    if (n.state !== nm) return u();
    for (c in a)
      if (v = a[c], v.name === n.name) {
        if (v.state === gl) return tm(s);
        v.state === am ? (v.state = yl, v.timer.stop(), v.on.call("interrupt", e, e.__data__, v.index, v.group), delete a[c]) : +c < t && (v.state = yl, v.timer.stop(), v.on.call("cancel", e, e.__data__, v.index, v.group), delete a[c]);
      }
    if (tm(function() {
      n.state === gl && (n.state = am, n.timer.restart(i, n.delay, n.time), i(d));
    }), n.state = Ud, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Ud) {
      for (n.state = gl, r = new Array(p = n.tween.length), c = 0, f = -1; c < p; ++c)
        (v = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (r[++f] = v);
      r.length = f + 1;
    }
  }
  function i(d) {
    for (var c = d < n.duration ? n.ease.call(null, d / n.duration) : (n.timer.restart(u), n.state = jd, 1), f = -1, p = r.length; ++f < p; )
      r[f].call(e, c);
    n.state === jd && (n.on.call("end", e, e.__data__, n.index, n.group), u());
  }
  function u() {
    n.state = yl, n.timer.stop(), delete a[t];
    for (var d in a) return;
    delete e.__transition;
  }
}
function Kb(e, t) {
  var n = e.__transition, a, r, o = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((a = n[s]).name !== t) {
        o = !1;
        continue;
      }
      r = a.state > Ud && a.state < jd, a.state = yl, a.timer.stop(), a.on.call(r ? "interrupt" : "cancel", e, e.__data__, a.index, a.group), delete n[s];
    }
    o && delete e.__transition;
  }
}
function i5(e) {
  return this.each(function() {
    Kb(this, e);
  });
}
const If = (e) => () => e;
function u5(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function d5(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(a) {
    return Math.pow(e + a * t, n);
  };
}
function c5(e) {
  return (e = +e) == 1 ? Yb : function(t, n) {
    return n - t ? d5(t, n, e) : If(isNaN(t) ? n : t);
  };
}
function Yb(e, t) {
  var n = t - e;
  return n ? u5(e, n) : If(isNaN(e) ? t : e);
}
const ti = (function e(t) {
  var n = c5(t);
  function a(r, o) {
    var s = n((r = zd(r)).r, (o = zd(o)).r), i = n(r.g, o.g), u = n(r.b, o.b), d = Yb(r.opacity, o.opacity);
    return function(c) {
      return r.r = s(c), r.g = i(c), r.b = u(c), r.opacity = d(c), r + "";
    };
  }
  return a.gamma = e, a;
})(1);
function f5(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, a = t.slice(), r;
  return function(o) {
    for (r = 0; r < n; ++r) a[r] = e[r] * (1 - o) + t[r] * o;
    return a;
  };
}
function p5(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function v5(e, t) {
  var n = t ? t.length : 0, a = e ? Math.min(n, e.length) : 0, r = new Array(a), o = new Array(n), s;
  for (s = 0; s < a; ++s) r[s] = io(e[s], t[s]);
  for (; s < n; ++s) o[s] = t[s];
  return function(i) {
    for (s = 0; s < a; ++s) o[s] = r[s](i);
    return o;
  };
}
function m5(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(a) {
    return n.setTime(e * (1 - a) + t * a), n;
  };
}
function kn(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function h5(e, t) {
  var n = {}, a = {}, r;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in e ? n[r] = io(e[r], t[r]) : a[r] = t[r];
  return function(o) {
    for (r in n) a[r] = n[r](o);
    return a;
  };
}
var Wd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Wu = new RegExp(Wd.source, "g");
function g5(e) {
  return function() {
    return e;
  };
}
function y5(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Xb(e, t) {
  var n = Wd.lastIndex = Wu.lastIndex = 0, a, r, o, s = -1, i = [], u = [];
  for (e = e + "", t = t + ""; (a = Wd.exec(e)) && (r = Wu.exec(t)); )
    (o = r.index) > n && (o = t.slice(n, o), i[s] ? i[s] += o : i[++s] = o), (a = a[0]) === (r = r[0]) ? i[s] ? i[s] += r : i[++s] = r : (i[++s] = null, u.push({ i: s, x: kn(a, r) })), n = Wu.lastIndex;
  return n < t.length && (o = t.slice(n), i[s] ? i[s] += o : i[++s] = o), i.length < 2 ? u[0] ? y5(u[0].x) : g5(t) : (t = u.length, function(d) {
    for (var c = 0, f; c < t; ++c) i[(f = u[c]).i] = f.x(d);
    return i.join("");
  });
}
function io(e, t) {
  var n = typeof t, a;
  return t == null || n === "boolean" ? If(t) : (n === "number" ? kn : n === "string" ? (a = ar(t)) ? (t = a, ti) : Xb : t instanceof ar ? ti : t instanceof Date ? m5 : p5(t) ? f5 : Array.isArray(t) ? v5 : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? h5 : kn)(e, t);
}
function Of(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var rm = 180 / Math.PI, Gd = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Jb(e, t, n, a, r, o) {
  var s, i, u;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (u = e * n + t * a) && (n -= e * u, a -= t * u), (i = Math.sqrt(n * n + a * a)) && (n /= i, a /= i, u /= i), e * a < t * n && (e = -e, t = -t, u = -u, s = -s), {
    translateX: r,
    translateY: o,
    rotate: Math.atan2(t, e) * rm,
    skewX: Math.atan(u) * rm,
    scaleX: s,
    scaleY: i
  };
}
var Zs;
function b5(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Gd : Jb(t.a, t.b, t.c, t.d, t.e, t.f);
}
function _5(e) {
  return e == null || (Zs || (Zs = document.createElementNS("http://www.w3.org/2000/svg", "g")), Zs.setAttribute("transform", e), !(e = Zs.transform.baseVal.consolidate())) ? Gd : (e = e.matrix, Jb(e.a, e.b, e.c, e.d, e.e, e.f));
}
function Zb(e, t, n, a) {
  function r(d) {
    return d.length ? d.pop() + " " : "";
  }
  function o(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var g = v.push("translate(", null, t, null, n);
      m.push({ i: g - 4, x: kn(d, f) }, { i: g - 2, x: kn(c, p) });
    } else (f || p) && v.push("translate(" + f + t + p + n);
  }
  function s(d, c, f, p) {
    d !== c ? (d - c > 180 ? c += 360 : c - d > 180 && (d += 360), p.push({ i: f.push(r(f) + "rotate(", null, a) - 2, x: kn(d, c) })) : c && f.push(r(f) + "rotate(" + c + a);
  }
  function i(d, c, f, p) {
    d !== c ? p.push({ i: f.push(r(f) + "skewX(", null, a) - 2, x: kn(d, c) }) : c && f.push(r(f) + "skewX(" + c + a);
  }
  function u(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var g = v.push(r(v) + "scale(", null, ",", null, ")");
      m.push({ i: g - 4, x: kn(d, f) }, { i: g - 2, x: kn(c, p) });
    } else (f !== 1 || p !== 1) && v.push(r(v) + "scale(" + f + "," + p + ")");
  }
  return function(d, c) {
    var f = [], p = [];
    return d = e(d), c = e(c), o(d.translateX, d.translateY, c.translateX, c.translateY, f, p), s(d.rotate, c.rotate, f, p), i(d.skewX, c.skewX, f, p), u(d.scaleX, d.scaleY, c.scaleX, c.scaleY, f, p), d = c = null, function(v) {
      for (var m = -1, g = p.length, w; ++m < g; ) f[(w = p[m]).i] = w.x(v);
      return f.join("");
    };
  };
}
var w5 = Zb(b5, "px, ", "px)", "deg)"), x5 = Zb(_5, ", ", ")", ")");
function C5(e, t) {
  t === void 0 && (t = e, e = io);
  for (var n = 0, a = t.length - 1, r = t[0], o = new Array(a < 0 ? 0 : a); n < a; ) o[n] = e(r, r = t[++n]);
  return function(s) {
    var i = Math.max(0, Math.min(a - 1, Math.floor(s *= a)));
    return o[i](s - i);
  };
}
function S5(e, t) {
  var n, a;
  return function() {
    var r = ea(this, e), o = r.tween;
    if (o !== n) {
      a = n = o;
      for (var s = 0, i = a.length; s < i; ++s)
        if (a[s].name === t) {
          a = a.slice(), a.splice(s, 1);
          break;
        }
    }
    r.tween = a;
  };
}
function $5(e, t, n) {
  var a, r;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = ea(this, e), s = o.tween;
    if (s !== a) {
      r = (a = s).slice();
      for (var i = { name: t, value: n }, u = 0, d = r.length; u < d; ++u)
        if (r[u].name === t) {
          r[u] = i;
          break;
        }
      u === d && r.push(i);
    }
    o.tween = r;
  };
}
function k5(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var a = Fn(this.node(), n).tween, r = 0, o = a.length, s; r < o; ++r)
      if ((s = a[r]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? S5 : $5)(n, e, t));
}
function Rf(e, t, n) {
  var a = e._id;
  return e.each(function() {
    var r = ea(this, a);
    (r.value || (r.value = {}))[t] = n.apply(this, arguments);
  }), function(r) {
    return Fn(r, a).value[t];
  };
}
function Qb(e, t) {
  var n;
  return (typeof t == "number" ? kn : t instanceof ar ? ti : (n = ar(t)) ? (t = n, ti) : Xb)(e, t);
}
function B5(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function D5(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function P5(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttribute(e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function M5(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function q5(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function E5(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function T5(e, t) {
  var n = Xi(e), a = n === "transform" ? x5 : Qb;
  return this.attrTween(e, typeof t == "function" ? (n.local ? E5 : q5)(n, a, Rf(this, "attr." + e, t)) : t == null ? (n.local ? D5 : B5)(n) : (n.local ? M5 : P5)(n, a, t));
}
function A5(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function I5(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function O5(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && I5(e, o)), n;
  }
  return r._value = t, r;
}
function R5(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && A5(e, o)), n;
  }
  return r._value = t, r;
}
function V5(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var a = Xi(e);
  return this.tween(n, (a.local ? O5 : R5)(a, t));
}
function F5(e, t) {
  return function() {
    Af(this, e).delay = +t.apply(this, arguments);
  };
}
function N5(e, t) {
  return t = +t, function() {
    Af(this, e).delay = t;
  };
}
function L5(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? F5 : N5)(t, e)) : Fn(this.node(), t).delay;
}
function z5(e, t) {
  return function() {
    ea(this, e).duration = +t.apply(this, arguments);
  };
}
function H5(e, t) {
  return t = +t, function() {
    ea(this, e).duration = t;
  };
}
function U5(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? z5 : H5)(t, e)) : Fn(this.node(), t).duration;
}
function j5(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    ea(this, e).ease = t;
  };
}
function W5(e) {
  var t = this._id;
  return arguments.length ? this.each(j5(t, e)) : Fn(this.node(), t).ease;
}
function G5(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    ea(this, e).ease = n;
  };
}
function K5(e) {
  if (typeof e != "function") throw new Error();
  return this.each(G5(this._id, e));
}
function Y5(e) {
  typeof e != "function" && (e = vb(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new pa(a, this._parents, this._name, this._id);
}
function X5(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, a = t.length, r = n.length, o = Math.min(a, r), s = new Array(a), i = 0; i < o; ++i)
    for (var u = t[i], d = n[i], c = u.length, f = s[i] = new Array(c), p, v = 0; v < c; ++v)
      (p = u[v] || d[v]) && (f[v] = p);
  for (; i < a; ++i)
    s[i] = t[i];
  return new pa(s, this._parents, this._name, this._id);
}
function J5(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function Z5(e, t, n) {
  var a, r, o = J5(t) ? Af : ea;
  return function() {
    var s = o(this, e), i = s.on;
    i !== a && (r = (a = i).copy()).on(t, n), s.on = r;
  };
}
function Q5(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Fn(this.node(), n).on.on(e) : this.each(Z5(n, e, t));
}
function eN(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function tN() {
  return this.on("end.remove", eN(this._id));
}
function nN(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Cf(e));
  for (var a = this._groups, r = a.length, o = new Array(r), s = 0; s < r; ++s)
    for (var i = a[s], u = i.length, d = o[s] = new Array(u), c, f, p = 0; p < u; ++p)
      (c = i[p]) && (f = e.call(c, c.__data__, p, i)) && ("__data__" in c && (f.__data__ = c.__data__), d[p] = f, nu(d[p], t, n, p, d, Fn(c, n)));
  return new pa(o, this._parents, t, n);
}
function aN(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = pb(e));
  for (var a = this._groups, r = a.length, o = [], s = [], i = 0; i < r; ++i)
    for (var u = a[i], d = u.length, c, f = 0; f < d; ++f)
      if (c = u[f]) {
        for (var p = e.call(c, c.__data__, f, u), v, m = Fn(c, n), g = 0, w = p.length; g < w; ++g)
          (v = p[g]) && nu(v, t, n, g, p, m);
        o.push(p), s.push(c);
      }
  return new pa(o, s, t, n);
}
var rN = ks.prototype.constructor;
function oN() {
  return new rN(this._groups, this._parents);
}
function sN(e, t) {
  var n, a, r;
  return function() {
    var o = zr(this, e), s = (this.style.removeProperty(e), zr(this, e));
    return o === s ? null : o === n && s === a ? r : r = t(n = o, a = s);
  };
}
function e_(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function lN(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = zr(this, e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function iN(e, t, n) {
  var a, r, o;
  return function() {
    var s = zr(this, e), i = n(this), u = i + "";
    return i == null && (u = i = (this.style.removeProperty(e), zr(this, e))), s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i));
  };
}
function uN(e, t) {
  var n, a, r, o = "style." + t, s = "end." + o, i;
  return function() {
    var u = ea(this, e), d = u.on, c = u.value[o] == null ? i || (i = e_(t)) : void 0;
    (d !== n || r !== c) && (a = (n = d).copy()).on(s, r = c), u.on = a;
  };
}
function dN(e, t, n) {
  var a = (e += "") == "transform" ? w5 : Qb;
  return t == null ? this.styleTween(e, sN(e, a)).on("end.style." + e, e_(e)) : typeof t == "function" ? this.styleTween(e, iN(e, a, Rf(this, "style." + e, t))).each(uN(this._id, e)) : this.styleTween(e, lN(e, a, t), n).on("end.style." + e, null);
}
function cN(e, t, n) {
  return function(a) {
    this.style.setProperty(e, t.call(this, a), n);
  };
}
function fN(e, t, n) {
  var a, r;
  function o() {
    var s = t.apply(this, arguments);
    return s !== r && (a = (r = s) && cN(e, s, n)), a;
  }
  return o._value = t, o;
}
function pN(e, t, n) {
  var a = "style." + (e += "");
  if (arguments.length < 2) return (a = this.tween(a)) && a._value;
  if (t == null) return this.tween(a, null);
  if (typeof t != "function") throw new Error();
  return this.tween(a, fN(e, t, n ?? ""));
}
function vN(e) {
  return function() {
    this.textContent = e;
  };
}
function mN(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function hN(e) {
  return this.tween("text", typeof e == "function" ? mN(Rf(this, "text", e)) : vN(e == null ? "" : e + ""));
}
function gN(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function yN(e) {
  var t, n;
  function a() {
    var r = e.apply(this, arguments);
    return r !== n && (t = (n = r) && gN(r)), t;
  }
  return a._value = e, a;
}
function bN(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, yN(e));
}
function _N() {
  for (var e = this._name, t = this._id, n = t_(), a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      if (u = s[d]) {
        var c = Fn(u, t);
        nu(u, e, n, d, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new pa(a, this._parents, e, n);
}
function wN() {
  var e, t, n = this, a = n._id, r = n.size();
  return new Promise(function(o, s) {
    var i = { value: s }, u = { value: function() {
      --r === 0 && o();
    } };
    n.each(function() {
      var d = ea(this, a), c = d.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(i), t._.interrupt.push(i), t._.end.push(u)), d.on = t;
    }), r === 0 && o();
  });
}
var xN = 0;
function pa(e, t, n, a) {
  this._groups = e, this._parents = t, this._name = n, this._id = a;
}
function t_() {
  return ++xN;
}
var na = ks.prototype;
pa.prototype = {
  constructor: pa,
  select: nN,
  selectAll: aN,
  selectChild: na.selectChild,
  selectChildren: na.selectChildren,
  filter: Y5,
  merge: X5,
  selection: oN,
  transition: _N,
  call: na.call,
  nodes: na.nodes,
  node: na.node,
  size: na.size,
  empty: na.empty,
  each: na.each,
  on: Q5,
  attr: T5,
  attrTween: V5,
  style: dN,
  styleTween: pN,
  text: hN,
  textTween: bN,
  remove: tN,
  tween: k5,
  delay: L5,
  duration: U5,
  ease: W5,
  easeVarying: K5,
  end: wN,
  [Symbol.iterator]: na[Symbol.iterator]
};
const om = (e) => +e;
function CN(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var SN = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: CN
};
function $N(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function kN(e) {
  var t, n;
  e instanceof pa ? (t = e._id, e = e._name) : (t = t_(), (n = SN).time = Tf(), e = e == null ? null : e + "");
  for (var a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && nu(u, e, t, d, s, n || $N(u, t));
  return new pa(a, this._parents, e, t);
}
ks.prototype.interrupt = i5;
ks.prototype.transition = kN;
function Gu(e, t, n) {
  if (e.nodes().forEach((a) => Kb(a)), t) {
    const a = e.transition().duration(t);
    return n && a.ease(n), a;
  } else
    return e;
}
class n_ {
  constructor(t) {
    this.data = t;
  }
  get data() {
    return this._data;
  }
  set data(t) {
    this._data = t;
  }
}
function Nn(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function a_(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const sm = /* @__PURE__ */ Symbol("implicit");
function Vf() {
  var e = new Pv(), t = [], n = [], a = sm;
  function r(o) {
    let s = e.get(o);
    if (s === void 0) {
      if (a !== sm) return a;
      e.set(o, s = t.push(o) - 1);
    }
    return n[s % n.length];
  }
  return r.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new Pv();
    for (const s of o)
      e.has(s) || e.set(s, t.push(s) - 1);
    return r;
  }, r.range = function(o) {
    return arguments.length ? (n = Array.from(o), r) : n.slice();
  }, r.unknown = function(o) {
    return arguments.length ? (a = o, r) : a;
  }, r.copy = function() {
    return Vf(t, n).unknown(a);
  }, Nn.apply(r, arguments), r;
}
function Ff() {
  var e = Vf().unknown(void 0), t = e.domain, n = e.range, a = 0, r = 1, o, s, i = !1, u = 0, d = 0, c = 0.5;
  delete e.unknown;
  function f() {
    var p = t().length, v = r < a, m = v ? r : a, g = v ? a : r;
    o = (g - m) / Math.max(1, p - u + d * 2), i && (o = Math.floor(o)), m += (g - m - o * (p - u)) * c, s = o * (1 - u), i && (m = Math.round(m), s = Math.round(s));
    var w = RV(p).map(function(C) {
      return m + o * C;
    });
    return n(v ? w.reverse() : w);
  }
  return e.domain = function(p) {
    return arguments.length ? (t(p), f()) : t();
  }, e.range = function(p) {
    return arguments.length ? ([a, r] = p, a = +a, r = +r, f()) : [a, r];
  }, e.rangeRound = function(p) {
    return [a, r] = p, a = +a, r = +r, i = !0, f();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return o;
  }, e.round = function(p) {
    return arguments.length ? (i = !!p, f()) : i;
  }, e.padding = function(p) {
    return arguments.length ? (u = Math.min(1, d = +p), f()) : u;
  }, e.paddingInner = function(p) {
    return arguments.length ? (u = Math.min(1, p), f()) : u;
  }, e.paddingOuter = function(p) {
    return arguments.length ? (d = +p, f()) : d;
  }, e.align = function(p) {
    return arguments.length ? (c = Math.max(0, Math.min(1, p)), f()) : c;
  }, e.copy = function() {
    return Ff(t(), [a, r]).round(i).paddingInner(u).paddingOuter(d).align(c);
  }, Nn.apply(f(), arguments);
}
function r_(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return r_(t());
  }, e;
}
function BN() {
  return r_(Ff.apply(null, arguments).paddingInner(1));
}
function DN(e) {
  return function() {
    return e;
  };
}
function Kd(e) {
  return +e;
}
var lm = [0, 1];
function nn(e) {
  return e;
}
function Yd(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : DN(isNaN(t) ? NaN : 0.5);
}
function PN(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(a) {
    return Math.max(e, Math.min(t, a));
  };
}
function MN(e, t, n) {
  var a = e[0], r = e[1], o = t[0], s = t[1];
  return r < a ? (a = Yd(r, a), o = n(s, o)) : (a = Yd(a, r), o = n(o, s)), function(i) {
    return o(a(i));
  };
}
function qN(e, t, n) {
  var a = Math.min(e.length, t.length) - 1, r = new Array(a), o = new Array(a), s = -1;
  for (e[a] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < a; )
    r[s] = Yd(e[s], e[s + 1]), o[s] = n(t[s], t[s + 1]);
  return function(i) {
    var u = Bs(e, i, 1, a) - 1;
    return o[u](r[u](i));
  };
}
function Ms(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function au() {
  var e = lm, t = lm, n = io, a, r, o, s = nn, i, u, d;
  function c() {
    var p = Math.min(e.length, t.length);
    return s !== nn && (s = PN(e[0], e[p - 1])), i = p > 2 ? qN : MN, u = d = null, f;
  }
  function f(p) {
    return p == null || isNaN(p = +p) ? o : (u || (u = i(e.map(a), t, n)))(a(s(p)));
  }
  return f.invert = function(p) {
    return s(r((d || (d = i(t, e.map(a), kn)))(p)));
  }, f.domain = function(p) {
    return arguments.length ? (e = Array.from(p, Kd), c()) : e.slice();
  }, f.range = function(p) {
    return arguments.length ? (t = Array.from(p), c()) : t.slice();
  }, f.rangeRound = function(p) {
    return t = Array.from(p), n = Of, c();
  }, f.clamp = function(p) {
    return arguments.length ? (s = p ? !0 : nn, c()) : s !== nn;
  }, f.interpolate = function(p) {
    return arguments.length ? (n = p, c()) : n;
  }, f.unknown = function(p) {
    return arguments.length ? (o = p, f) : o;
  }, function(p, v) {
    return a = p, r = v, c();
  };
}
function o_() {
  return au()(nn, nn);
}
function EN(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function ni(e, t) {
  if (!isFinite(e) || e === 0) return null;
  var n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e"), a = e.slice(0, n);
  return [
    a.length > 1 ? a[0] + a.slice(2) : a,
    +e.slice(n + 1)
  ];
}
function jr(e) {
  return e = ni(Math.abs(e)), e ? e[1] : NaN;
}
function TN(e, t) {
  return function(n, a) {
    for (var r = n.length, o = [], s = 0, i = e[0], u = 0; r > 0 && i > 0 && (u + i + 1 > a && (i = Math.max(1, a - u)), o.push(n.substring(r -= i, r + i)), !((u += i + 1) > a)); )
      i = e[s = (s + 1) % e.length];
    return o.reverse().join(t);
  };
}
function AN(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var IN = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function rs(e) {
  if (!(t = IN.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new Nf({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
rs.prototype = Nf.prototype;
function Nf(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
Nf.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function ON(e) {
  e: for (var t = e.length, n = 1, a = -1, r; n < t; ++n)
    switch (e[n]) {
      case ".":
        a = r = n;
        break;
      case "0":
        a === 0 && (a = n), r = n;
        break;
      default:
        if (!+e[n]) break e;
        a > 0 && (a = 0);
        break;
    }
  return a > 0 ? e.slice(0, a) + e.slice(r + 1) : e;
}
var ai;
function RN(e, t) {
  var n = ni(e, t);
  if (!n) return ai = void 0, e.toPrecision(t);
  var a = n[0], r = n[1], o = r - (ai = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, s = a.length;
  return o === s ? a : o > s ? a + new Array(o - s + 1).join("0") : o > 0 ? a.slice(0, o) + "." + a.slice(o) : "0." + new Array(1 - o).join("0") + ni(e, Math.max(0, t + o - 1))[0];
}
function im(e, t) {
  var n = ni(e, t);
  if (!n) return e + "";
  var a = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + a : a.length > r + 1 ? a.slice(0, r + 1) + "." + a.slice(r + 1) : a + new Array(r - a.length + 2).join("0");
}
const um = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: EN,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => im(e * 100, t),
  r: im,
  s: RN,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function dm(e) {
  return e;
}
var cm = Array.prototype.map, fm = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function VN(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? dm : TN(cm.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", a = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? dm : AN(cm.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", i = e.minus === void 0 ? "" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function d(f, p) {
    f = rs(f);
    var v = f.fill, m = f.align, g = f.sign, w = f.symbol, C = f.zero, S = f.width, $ = f.comma, B = f.precision, k = f.trim, P = f.type;
    P === "n" ? ($ = !0, P = "g") : um[P] || (B === void 0 && (B = 12), k = !0, P = "g"), (C || v === "0" && m === "=") && (C = !0, v = "0", m = "=");
    var D = (p && p.prefix !== void 0 ? p.prefix : "") + (w === "$" ? n : w === "#" && /[boxX]/.test(P) ? "0" + P.toLowerCase() : ""), q = (w === "$" ? a : /[%p]/.test(P) ? s : "") + (p && p.suffix !== void 0 ? p.suffix : ""), T = um[P], M = /[defgprs%]/.test(P);
    B = B === void 0 ? 6 : /[gprs]/.test(P) ? Math.max(1, Math.min(21, B)) : Math.max(0, Math.min(20, B));
    function O(F) {
      var J = D, ne = q, Q, W, H;
      if (P === "c")
        ne = T(F) + ne, F = "";
      else {
        F = +F;
        var U = F < 0 || 1 / F < 0;
        if (F = isNaN(F) ? u : T(Math.abs(F), B), k && (F = ON(F)), U && +F == 0 && g !== "+" && (U = !1), J = (U ? g === "(" ? g : i : g === "-" || g === "(" ? "" : g) + J, ne = (P === "s" && !isNaN(F) && ai !== void 0 ? fm[8 + ai / 3] : "") + ne + (U && g === "(" ? ")" : ""), M) {
          for (Q = -1, W = F.length; ++Q < W; )
            if (H = F.charCodeAt(Q), 48 > H || H > 57) {
              ne = (H === 46 ? r + F.slice(Q + 1) : F.slice(Q)) + ne, F = F.slice(0, Q);
              break;
            }
        }
      }
      $ && !C && (F = t(F, 1 / 0));
      var se = J.length + F.length + ne.length, ee = se < S ? new Array(S - se + 1).join(v) : "";
      switch ($ && C && (F = t(ee + F, ee.length ? S - ne.length : 1 / 0), ee = ""), m) {
        case "<":
          F = J + F + ne + ee;
          break;
        case "=":
          F = J + ee + F + ne;
          break;
        case "^":
          F = ee.slice(0, se = ee.length >> 1) + J + F + ne + ee.slice(se);
          break;
        default:
          F = ee + J + F + ne;
          break;
      }
      return o(F);
    }
    return O.toString = function() {
      return f + "";
    }, O;
  }
  function c(f, p) {
    var v = Math.max(-8, Math.min(8, Math.floor(jr(p) / 3))) * 3, m = Math.pow(10, -v), g = d((f = rs(f), f.type = "f", f), { suffix: fm[8 + v / 3] });
    return function(w) {
      return g(m * w);
    };
  }
  return {
    format: d,
    formatPrefix: c
  };
}
var Qs, Lf, s_;
FN({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function FN(e) {
  return Qs = VN(e), Lf = Qs.format, s_ = Qs.formatPrefix, Qs;
}
function NN(e) {
  return Math.max(0, -jr(Math.abs(e)));
}
function LN(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(jr(t) / 3))) * 3 - jr(Math.abs(e)));
}
function zN(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, jr(t) - jr(e)) + 1;
}
function HN(e, t, n, a) {
  var r = Rd(e, t, n), o;
  switch (a = rs(a ?? ",f"), a.type) {
    case "s": {
      var s = Math.max(Math.abs(e), Math.abs(t));
      return a.precision == null && !isNaN(o = LN(r, s)) && (a.precision = o), s_(a, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      a.precision == null && !isNaN(o = zN(r, Math.max(Math.abs(e), Math.abs(t)))) && (a.precision = o - (a.type === "e"));
      break;
    }
    case "f":
    case "%": {
      a.precision == null && !isNaN(o = NN(r)) && (a.precision = o - (a.type === "%") * 2);
      break;
    }
  }
  return Lf(a);
}
function mr(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var a = t();
    return Id(a[0], a[a.length - 1], n ?? 10);
  }, e.tickFormat = function(n, a) {
    var r = t();
    return HN(r[0], r[r.length - 1], n ?? 10, a);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var a = t(), r = 0, o = a.length - 1, s = a[r], i = a[o], u, d, c = 10;
    for (i < s && (d = s, s = i, i = d, d = r, r = o, o = d); c-- > 0; ) {
      if (d = Od(s, i, n), d === u)
        return a[r] = s, a[o] = i, t(a);
      if (d > 0)
        s = Math.floor(s / d) * d, i = Math.ceil(i / d) * d;
      else if (d < 0)
        s = Math.ceil(s * d) / d, i = Math.floor(i * d) / d;
      else
        break;
      u = d;
    }
    return e;
  }, e;
}
function l_() {
  var e = o_();
  return e.copy = function() {
    return Ms(e, l_());
  }, Nn.apply(e, arguments), mr(e);
}
function i_(e) {
  var t;
  function n(a) {
    return a == null || isNaN(a = +a) ? t : a;
  }
  return n.invert = n, n.domain = n.range = function(a) {
    return arguments.length ? (e = Array.from(a, Kd), n) : e.slice();
  }, n.unknown = function(a) {
    return arguments.length ? (t = a, n) : t;
  }, n.copy = function() {
    return i_(e).unknown(t);
  }, e = arguments.length ? Array.from(e, Kd) : [0, 1], mr(n);
}
function u_(e, t) {
  e = e.slice();
  var n = 0, a = e.length - 1, r = e[n], o = e[a], s;
  return o < r && (s = n, n = a, a = s, s = r, r = o, o = s), e[n] = t.floor(r), e[a] = t.ceil(o), e;
}
function pm(e) {
  return Math.log(e);
}
function vm(e) {
  return Math.exp(e);
}
function UN(e) {
  return -Math.log(-e);
}
function jN(e) {
  return -Math.exp(-e);
}
function WN(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function GN(e) {
  return e === 10 ? WN : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function KN(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function mm(e) {
  return (t, n) => -e(-t, n);
}
function YN(e) {
  const t = e(pm, vm), n = t.domain;
  let a = 10, r, o;
  function s() {
    return r = KN(a), o = GN(a), n()[0] < 0 ? (r = mm(r), o = mm(o), e(UN, jN)) : e(pm, vm), t;
  }
  return t.base = function(i) {
    return arguments.length ? (a = +i, s()) : a;
  }, t.domain = function(i) {
    return arguments.length ? (n(i), s()) : n();
  }, t.ticks = (i) => {
    const u = n();
    let d = u[0], c = u[u.length - 1];
    const f = c < d;
    f && ([d, c] = [c, d]);
    let p = r(d), v = r(c), m, g;
    const w = i == null ? 10 : +i;
    let C = [];
    if (!(a % 1) && v - p < w) {
      if (p = Math.floor(p), v = Math.ceil(v), d > 0) {
        for (; p <= v; ++p)
          for (m = 1; m < a; ++m)
            if (g = p < 0 ? m / o(-p) : m * o(p), !(g < d)) {
              if (g > c) break;
              C.push(g);
            }
      } else for (; p <= v; ++p)
        for (m = a - 1; m >= 1; --m)
          if (g = p > 0 ? m / o(-p) : m * o(p), !(g < d)) {
            if (g > c) break;
            C.push(g);
          }
      C.length * 2 < w && (C = Id(d, c, w));
    } else
      C = Id(p, v, Math.min(v - p, w)).map(o);
    return f ? C.reverse() : C;
  }, t.tickFormat = (i, u) => {
    if (i == null && (i = 10), u == null && (u = a === 10 ? "s" : ","), typeof u != "function" && (!(a % 1) && (u = rs(u)).precision == null && (u.trim = !0), u = Lf(u)), i === 1 / 0) return u;
    const d = Math.max(1, a * i / t.ticks().length);
    return (c) => {
      let f = c / o(Math.round(r(c)));
      return f * a < a - 0.5 && (f *= a), f <= d ? u(c) : "";
    };
  }, t.nice = () => n(u_(n(), {
    floor: (i) => o(Math.floor(r(i))),
    ceil: (i) => o(Math.ceil(r(i)))
  })), t;
}
function d_() {
  const e = YN(au()).domain([1, 10]);
  return e.copy = () => Ms(e, d_()).base(e.base()), Nn.apply(e, arguments), e;
}
function hm(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function gm(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function XN(e) {
  var t = 1, n = e(hm(t), gm(t));
  return n.constant = function(a) {
    return arguments.length ? e(hm(t = +a), gm(t)) : t;
  }, mr(n);
}
function c_() {
  var e = XN(au());
  return e.copy = function() {
    return Ms(e, c_()).constant(e.constant());
  }, Nn.apply(e, arguments);
}
function ym(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function JN(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function ZN(e) {
  return e < 0 ? -e * e : e * e;
}
function QN(e) {
  var t = e(nn, nn), n = 1;
  function a() {
    return n === 1 ? e(nn, nn) : n === 0.5 ? e(JN, ZN) : e(ym(n), ym(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, a()) : n;
  }, mr(t);
}
function zf() {
  var e = QN(au());
  return e.copy = function() {
    return Ms(e, zf()).exponent(e.exponent());
  }, Nn.apply(e, arguments), e;
}
function e6() {
  return zf.apply(null, arguments).exponent(0.5);
}
function f_() {
  var e = [], t = [], n = [], a;
  function r() {
    var s = 0, i = Math.max(1, t.length);
    for (n = new Array(i - 1); ++s < i; ) n[s - 1] = OV(e, s / i);
    return o;
  }
  function o(s) {
    return s == null || isNaN(s = +s) ? a : t[Bs(n, s)];
  }
  return o.invertExtent = function(s) {
    var i = t.indexOf(s);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? n[i - 1] : e[0],
      i < n.length ? n[i] : e[e.length - 1]
    ];
  }, o.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of s) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort(Io), r();
  }, o.range = function(s) {
    return arguments.length ? (t = Array.from(s), r()) : t.slice();
  }, o.unknown = function(s) {
    return arguments.length ? (a = s, o) : a;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return f_().domain(e).range(t).unknown(a);
  }, Nn.apply(o, arguments);
}
function p_() {
  var e = 0, t = 1, n = 1, a = [0.5], r = [0, 1], o;
  function s(u) {
    return u != null && u <= u ? r[Bs(a, u, 0, n)] : o;
  }
  function i() {
    var u = -1;
    for (a = new Array(n); ++u < n; ) a[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return s;
  }
  return s.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, i()) : [e, t];
  }, s.range = function(u) {
    return arguments.length ? (n = (r = Array.from(u)).length - 1, i()) : r.slice();
  }, s.invertExtent = function(u) {
    var d = r.indexOf(u);
    return d < 0 ? [NaN, NaN] : d < 1 ? [e, a[0]] : d >= n ? [a[n - 1], t] : [a[d - 1], a[d]];
  }, s.unknown = function(u) {
    return arguments.length && (o = u), s;
  }, s.thresholds = function() {
    return a.slice();
  }, s.copy = function() {
    return p_().domain([e, t]).range(r).unknown(o);
  }, Nn.apply(mr(s), arguments);
}
function v_() {
  var e = [0.5], t = [0, 1], n, a = 1;
  function r(o) {
    return o != null && o <= o ? t[Bs(e, o, 0, a)] : n;
  }
  return r.domain = function(o) {
    return arguments.length ? (e = Array.from(o), a = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(o) {
    return arguments.length ? (t = Array.from(o), a = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(o) {
    var s = t.indexOf(o);
    return [e[s - 1], e[s]];
  }, r.unknown = function(o) {
    return arguments.length ? (n = o, r) : n;
  }, r.copy = function() {
    return v_().domain(e).range(t).unknown(n);
  }, Nn.apply(r, arguments);
}
const Ku = /* @__PURE__ */ new Date(), Yu = /* @__PURE__ */ new Date();
function Dt(e, t, n, a) {
  function r(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return r.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), r.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), r.round = (o) => {
    const s = r(o), i = r.ceil(o);
    return o - s < i - o ? s : i;
  }, r.offset = (o, s) => (t(o = /* @__PURE__ */ new Date(+o), s == null ? 1 : Math.floor(s)), o), r.range = (o, s, i) => {
    const u = [];
    if (o = r.ceil(o), i = i == null ? 1 : Math.floor(i), !(o < s) || !(i > 0)) return u;
    let d;
    do
      u.push(d = /* @__PURE__ */ new Date(+o)), t(o, i), e(o);
    while (d < o && o < s);
    return u;
  }, r.filter = (o) => Dt((s) => {
    if (s >= s) for (; e(s), !o(s); ) s.setTime(s - 1);
  }, (s, i) => {
    if (s >= s)
      if (i < 0) for (; ++i <= 0; )
        for (; t(s, -1), !o(s); )
          ;
      else for (; --i >= 0; )
        for (; t(s, 1), !o(s); )
          ;
  }), n && (r.count = (o, s) => (Ku.setTime(+o), Yu.setTime(+s), e(Ku), e(Yu), Math.floor(n(Ku, Yu))), r.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(a ? (s) => a(s) % o === 0 : (s) => r.count(0, s) % o === 0) : r)), r;
}
const ri = Dt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
ri.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Dt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : ri);
ri.range;
const ua = 1e3, xn = ua * 60, da = xn * 60, va = da * 24, Hf = va * 7, bm = va * 30, Xu = va * 365, Xa = Dt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * ua);
}, (e, t) => (t - e) / ua, (e) => e.getUTCSeconds());
Xa.range;
const Uf = Dt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ua);
}, (e, t) => {
  e.setTime(+e + t * xn);
}, (e, t) => (t - e) / xn, (e) => e.getMinutes());
Uf.range;
const jf = Dt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * xn);
}, (e, t) => (t - e) / xn, (e) => e.getUTCMinutes());
jf.range;
const Wf = Dt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ua - e.getMinutes() * xn);
}, (e, t) => {
  e.setTime(+e + t * da);
}, (e, t) => (t - e) / da, (e) => e.getHours());
Wf.range;
const Gf = Dt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * da);
}, (e, t) => (t - e) / da, (e) => e.getUTCHours());
Gf.range;
const qs = Dt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * xn) / va,
  (e) => e.getDate() - 1
);
qs.range;
const ru = Dt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / va, (e) => e.getUTCDate() - 1);
ru.range;
const m_ = Dt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / va, (e) => Math.floor(e / va));
m_.range;
function hr(e) {
  return Dt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * xn) / Hf);
}
const ou = hr(0), oi = hr(1), t6 = hr(2), n6 = hr(3), Wr = hr(4), a6 = hr(5), r6 = hr(6);
ou.range;
oi.range;
t6.range;
n6.range;
Wr.range;
a6.range;
r6.range;
function gr(e) {
  return Dt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / Hf);
}
const su = gr(0), si = gr(1), o6 = gr(2), s6 = gr(3), Gr = gr(4), l6 = gr(5), i6 = gr(6);
su.range;
si.range;
o6.range;
s6.range;
Gr.range;
l6.range;
i6.range;
const Kf = Dt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
Kf.range;
const Yf = Dt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
Yf.range;
const ma = Dt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
ma.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
ma.range;
const ha = Dt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
ha.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Dt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
ha.range;
function h_(e, t, n, a, r, o) {
  const s = [
    [Xa, 1, ua],
    [Xa, 5, 5 * ua],
    [Xa, 15, 15 * ua],
    [Xa, 30, 30 * ua],
    [o, 1, xn],
    [o, 5, 5 * xn],
    [o, 15, 15 * xn],
    [o, 30, 30 * xn],
    [r, 1, da],
    [r, 3, 3 * da],
    [r, 6, 6 * da],
    [r, 12, 12 * da],
    [a, 1, va],
    [a, 2, 2 * va],
    [n, 1, Hf],
    [t, 1, bm],
    [t, 3, 3 * bm],
    [e, 1, Xu]
  ];
  function i(d, c, f) {
    const p = c < d;
    p && ([d, c] = [c, d]);
    const v = f && typeof f.range == "function" ? f : u(d, c, f), m = v ? v.range(d, +c + 1) : [];
    return p ? m.reverse() : m;
  }
  function u(d, c, f) {
    const p = Math.abs(c - d) / f, v = $f(([, , w]) => w).right(s, p);
    if (v === s.length) return e.every(Rd(d / Xu, c / Xu, f));
    if (v === 0) return ri.every(Math.max(Rd(d, c, f), 1));
    const [m, g] = s[p / s[v - 1][2] < s[v][2] / p ? v - 1 : v];
    return m.every(g);
  }
  return [i, u];
}
const [u6, d6] = h_(ha, Yf, su, m_, Gf, jf), [c6, f6] = h_(ma, Kf, ou, qs, Wf, Uf);
function Ju(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Zu(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function yo(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function p6(e) {
  var t = e.dateTime, n = e.date, a = e.time, r = e.periods, o = e.days, s = e.shortDays, i = e.months, u = e.shortMonths, d = bo(r), c = _o(r), f = bo(o), p = _o(o), v = bo(s), m = _o(s), g = bo(i), w = _o(i), C = bo(u), S = _o(u), $ = {
    a: H,
    A: U,
    b: se,
    B: ee,
    c: null,
    d: $m,
    e: $m,
    f: O6,
    g: W6,
    G: K6,
    H: T6,
    I: A6,
    j: I6,
    L: g_,
    m: R6,
    M: V6,
    p: de,
    q: pe,
    Q: Dm,
    s: Pm,
    S: F6,
    u: N6,
    U: L6,
    V: z6,
    w: H6,
    W: U6,
    x: null,
    X: null,
    y: j6,
    Y: G6,
    Z: Y6,
    "%": Bm
  }, B = {
    a: _e,
    A: ge,
    b: Te,
    B: ce,
    c: null,
    d: km,
    e: km,
    f: Q6,
    g: u4,
    G: c4,
    H: X6,
    I: J6,
    j: Z6,
    L: b_,
    m: e4,
    M: t4,
    p: R,
    q: te,
    Q: Dm,
    s: Pm,
    S: n4,
    u: a4,
    U: r4,
    V: o4,
    w: s4,
    W: l4,
    x: null,
    X: null,
    y: i4,
    Y: d4,
    Z: f4,
    "%": Bm
  }, k = {
    a: M,
    A: O,
    b: F,
    B: J,
    c: ne,
    d: Cm,
    e: Cm,
    f: P6,
    g: xm,
    G: wm,
    H: Sm,
    I: Sm,
    j: $6,
    L: D6,
    m: S6,
    M: k6,
    p: T,
    q: C6,
    Q: q6,
    s: E6,
    S: B6,
    u: y6,
    U: b6,
    V: _6,
    w: g6,
    W: w6,
    x: Q,
    X: W,
    y: xm,
    Y: wm,
    Z: x6,
    "%": M6
  };
  $.x = P(n, $), $.X = P(a, $), $.c = P(t, $), B.x = P(n, B), B.X = P(a, B), B.c = P(t, B);
  function P(z, ae) {
    return function(ie) {
      var L = [], be = -1, we = 0, Fe = z.length, Xe, lt, De;
      for (ie instanceof Date || (ie = /* @__PURE__ */ new Date(+ie)); ++be < Fe; )
        z.charCodeAt(be) === 37 && (L.push(z.slice(we, be)), (lt = _m[Xe = z.charAt(++be)]) != null ? Xe = z.charAt(++be) : lt = Xe === "e" ? " " : "0", (De = ae[Xe]) && (Xe = De(ie, lt)), L.push(Xe), we = be + 1);
      return L.push(z.slice(we, be)), L.join("");
    };
  }
  function D(z, ae) {
    return function(ie) {
      var L = yo(1900, void 0, 1), be = q(L, z, ie += "", 0), we, Fe;
      if (be != ie.length) return null;
      if ("Q" in L) return new Date(L.Q);
      if ("s" in L) return new Date(L.s * 1e3 + ("L" in L ? L.L : 0));
      if (ae && !("Z" in L) && (L.Z = 0), "p" in L && (L.H = L.H % 12 + L.p * 12), L.m === void 0 && (L.m = "q" in L ? L.q : 0), "V" in L) {
        if (L.V < 1 || L.V > 53) return null;
        "w" in L || (L.w = 1), "Z" in L ? (we = Zu(yo(L.y, 0, 1)), Fe = we.getUTCDay(), we = Fe > 4 || Fe === 0 ? si.ceil(we) : si(we), we = ru.offset(we, (L.V - 1) * 7), L.y = we.getUTCFullYear(), L.m = we.getUTCMonth(), L.d = we.getUTCDate() + (L.w + 6) % 7) : (we = Ju(yo(L.y, 0, 1)), Fe = we.getDay(), we = Fe > 4 || Fe === 0 ? oi.ceil(we) : oi(we), we = qs.offset(we, (L.V - 1) * 7), L.y = we.getFullYear(), L.m = we.getMonth(), L.d = we.getDate() + (L.w + 6) % 7);
      } else ("W" in L || "U" in L) && ("w" in L || (L.w = "u" in L ? L.u % 7 : "W" in L ? 1 : 0), Fe = "Z" in L ? Zu(yo(L.y, 0, 1)).getUTCDay() : Ju(yo(L.y, 0, 1)).getDay(), L.m = 0, L.d = "W" in L ? (L.w + 6) % 7 + L.W * 7 - (Fe + 5) % 7 : L.w + L.U * 7 - (Fe + 6) % 7);
      return "Z" in L ? (L.H += L.Z / 100 | 0, L.M += L.Z % 100, Zu(L)) : Ju(L);
    };
  }
  function q(z, ae, ie, L) {
    for (var be = 0, we = ae.length, Fe = ie.length, Xe, lt; be < we; ) {
      if (L >= Fe) return -1;
      if (Xe = ae.charCodeAt(be++), Xe === 37) {
        if (Xe = ae.charAt(be++), lt = k[Xe in _m ? ae.charAt(be++) : Xe], !lt || (L = lt(z, ie, L)) < 0) return -1;
      } else if (Xe != ie.charCodeAt(L++))
        return -1;
    }
    return L;
  }
  function T(z, ae, ie) {
    var L = d.exec(ae.slice(ie));
    return L ? (z.p = c.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function M(z, ae, ie) {
    var L = v.exec(ae.slice(ie));
    return L ? (z.w = m.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function O(z, ae, ie) {
    var L = f.exec(ae.slice(ie));
    return L ? (z.w = p.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function F(z, ae, ie) {
    var L = C.exec(ae.slice(ie));
    return L ? (z.m = S.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function J(z, ae, ie) {
    var L = g.exec(ae.slice(ie));
    return L ? (z.m = w.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function ne(z, ae, ie) {
    return q(z, t, ae, ie);
  }
  function Q(z, ae, ie) {
    return q(z, n, ae, ie);
  }
  function W(z, ae, ie) {
    return q(z, a, ae, ie);
  }
  function H(z) {
    return s[z.getDay()];
  }
  function U(z) {
    return o[z.getDay()];
  }
  function se(z) {
    return u[z.getMonth()];
  }
  function ee(z) {
    return i[z.getMonth()];
  }
  function de(z) {
    return r[+(z.getHours() >= 12)];
  }
  function pe(z) {
    return 1 + ~~(z.getMonth() / 3);
  }
  function _e(z) {
    return s[z.getUTCDay()];
  }
  function ge(z) {
    return o[z.getUTCDay()];
  }
  function Te(z) {
    return u[z.getUTCMonth()];
  }
  function ce(z) {
    return i[z.getUTCMonth()];
  }
  function R(z) {
    return r[+(z.getUTCHours() >= 12)];
  }
  function te(z) {
    return 1 + ~~(z.getUTCMonth() / 3);
  }
  return {
    format: function(z) {
      var ae = P(z += "", $);
      return ae.toString = function() {
        return z;
      }, ae;
    },
    parse: function(z) {
      var ae = D(z += "", !1);
      return ae.toString = function() {
        return z;
      }, ae;
    },
    utcFormat: function(z) {
      var ae = P(z += "", B);
      return ae.toString = function() {
        return z;
      }, ae;
    },
    utcParse: function(z) {
      var ae = D(z += "", !0);
      return ae.toString = function() {
        return z;
      }, ae;
    }
  };
}
var _m = { "-": "", _: " ", 0: "0" }, Ot = /^\s*\d+/, v6 = /^%/, m6 = /[\\^$*+?|[\]().{}]/g;
function Ze(e, t, n) {
  var a = e < 0 ? "-" : "", r = (a ? -e : e) + "", o = r.length;
  return a + (o < n ? new Array(n - o + 1).join(t) + r : r);
}
function h6(e) {
  return e.replace(m6, "\\$&");
}
function bo(e) {
  return new RegExp("^(?:" + e.map(h6).join("|") + ")", "i");
}
function _o(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function g6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 1));
  return a ? (e.w = +a[0], n + a[0].length) : -1;
}
function y6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 1));
  return a ? (e.u = +a[0], n + a[0].length) : -1;
}
function b6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.U = +a[0], n + a[0].length) : -1;
}
function _6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.V = +a[0], n + a[0].length) : -1;
}
function w6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.W = +a[0], n + a[0].length) : -1;
}
function wm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 4));
  return a ? (e.y = +a[0], n + a[0].length) : -1;
}
function xm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), n + a[0].length) : -1;
}
function x6(e, t, n) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), n + a[0].length) : -1;
}
function C6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 1));
  return a ? (e.q = a[0] * 3 - 3, n + a[0].length) : -1;
}
function S6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.m = a[0] - 1, n + a[0].length) : -1;
}
function Cm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.d = +a[0], n + a[0].length) : -1;
}
function $6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 3));
  return a ? (e.m = 0, e.d = +a[0], n + a[0].length) : -1;
}
function Sm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.H = +a[0], n + a[0].length) : -1;
}
function k6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.M = +a[0], n + a[0].length) : -1;
}
function B6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.S = +a[0], n + a[0].length) : -1;
}
function D6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 3));
  return a ? (e.L = +a[0], n + a[0].length) : -1;
}
function P6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), n + a[0].length) : -1;
}
function M6(e, t, n) {
  var a = v6.exec(t.slice(n, n + 1));
  return a ? n + a[0].length : -1;
}
function q6(e, t, n) {
  var a = Ot.exec(t.slice(n));
  return a ? (e.Q = +a[0], n + a[0].length) : -1;
}
function E6(e, t, n) {
  var a = Ot.exec(t.slice(n));
  return a ? (e.s = +a[0], n + a[0].length) : -1;
}
function $m(e, t) {
  return Ze(e.getDate(), t, 2);
}
function T6(e, t) {
  return Ze(e.getHours(), t, 2);
}
function A6(e, t) {
  return Ze(e.getHours() % 12 || 12, t, 2);
}
function I6(e, t) {
  return Ze(1 + qs.count(ma(e), e), t, 3);
}
function g_(e, t) {
  return Ze(e.getMilliseconds(), t, 3);
}
function O6(e, t) {
  return g_(e, t) + "000";
}
function R6(e, t) {
  return Ze(e.getMonth() + 1, t, 2);
}
function V6(e, t) {
  return Ze(e.getMinutes(), t, 2);
}
function F6(e, t) {
  return Ze(e.getSeconds(), t, 2);
}
function N6(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function L6(e, t) {
  return Ze(ou.count(ma(e) - 1, e), t, 2);
}
function y_(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Wr(e) : Wr.ceil(e);
}
function z6(e, t) {
  return e = y_(e), Ze(Wr.count(ma(e), e) + (ma(e).getDay() === 4), t, 2);
}
function H6(e) {
  return e.getDay();
}
function U6(e, t) {
  return Ze(oi.count(ma(e) - 1, e), t, 2);
}
function j6(e, t) {
  return Ze(e.getFullYear() % 100, t, 2);
}
function W6(e, t) {
  return e = y_(e), Ze(e.getFullYear() % 100, t, 2);
}
function G6(e, t) {
  return Ze(e.getFullYear() % 1e4, t, 4);
}
function K6(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Wr(e) : Wr.ceil(e), Ze(e.getFullYear() % 1e4, t, 4);
}
function Y6(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ze(t / 60 | 0, "0", 2) + Ze(t % 60, "0", 2);
}
function km(e, t) {
  return Ze(e.getUTCDate(), t, 2);
}
function X6(e, t) {
  return Ze(e.getUTCHours(), t, 2);
}
function J6(e, t) {
  return Ze(e.getUTCHours() % 12 || 12, t, 2);
}
function Z6(e, t) {
  return Ze(1 + ru.count(ha(e), e), t, 3);
}
function b_(e, t) {
  return Ze(e.getUTCMilliseconds(), t, 3);
}
function Q6(e, t) {
  return b_(e, t) + "000";
}
function e4(e, t) {
  return Ze(e.getUTCMonth() + 1, t, 2);
}
function t4(e, t) {
  return Ze(e.getUTCMinutes(), t, 2);
}
function n4(e, t) {
  return Ze(e.getUTCSeconds(), t, 2);
}
function a4(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function r4(e, t) {
  return Ze(su.count(ha(e) - 1, e), t, 2);
}
function __(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Gr(e) : Gr.ceil(e);
}
function o4(e, t) {
  return e = __(e), Ze(Gr.count(ha(e), e) + (ha(e).getUTCDay() === 4), t, 2);
}
function s4(e) {
  return e.getUTCDay();
}
function l4(e, t) {
  return Ze(si.count(ha(e) - 1, e), t, 2);
}
function i4(e, t) {
  return Ze(e.getUTCFullYear() % 100, t, 2);
}
function u4(e, t) {
  return e = __(e), Ze(e.getUTCFullYear() % 100, t, 2);
}
function d4(e, t) {
  return Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function c4(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Gr(e) : Gr.ceil(e), Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function f4() {
  return "+0000";
}
function Bm() {
  return "%";
}
function Dm(e) {
  return +e;
}
function Pm(e) {
  return Math.floor(+e / 1e3);
}
var Sr, w_, x_;
p4({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function p4(e) {
  return Sr = p6(e), w_ = Sr.format, Sr.parse, x_ = Sr.utcFormat, Sr.utcParse, Sr;
}
function v4(e) {
  return new Date(e);
}
function m4(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Xf(e, t, n, a, r, o, s, i, u, d) {
  var c = o_(), f = c.invert, p = c.domain, v = d(".%L"), m = d(":%S"), g = d("%I:%M"), w = d("%I %p"), C = d("%a %d"), S = d("%b %d"), $ = d("%B"), B = d("%Y");
  function k(P) {
    return (u(P) < P ? v : i(P) < P ? m : s(P) < P ? g : o(P) < P ? w : a(P) < P ? r(P) < P ? C : S : n(P) < P ? $ : B)(P);
  }
  return c.invert = function(P) {
    return new Date(f(P));
  }, c.domain = function(P) {
    return arguments.length ? p(Array.from(P, m4)) : p().map(v4);
  }, c.ticks = function(P) {
    var D = p();
    return e(D[0], D[D.length - 1], P ?? 10);
  }, c.tickFormat = function(P, D) {
    return D == null ? k : d(D);
  }, c.nice = function(P) {
    var D = p();
    return (!P || typeof P.range != "function") && (P = t(D[0], D[D.length - 1], P ?? 10)), P ? p(u_(D, P)) : c;
  }, c.copy = function() {
    return Ms(c, Xf(e, t, n, a, r, o, s, i, u, d));
  }, c;
}
function h4() {
  return Nn.apply(Xf(c6, f6, ma, Kf, ou, qs, Wf, Uf, Xa, w_).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function g4() {
  return Nn.apply(Xf(u6, d6, ha, Yf, su, ru, Gf, jf, Xa, x_).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function y4() {
  var e = 0, t = 1, n, a, r, o, s = nn, i = !1, u;
  function d(f) {
    return f == null || isNaN(f = +f) ? u : s(r === 0 ? 0.5 : (f = (o(f) - n) * r, i ? Math.max(0, Math.min(1, f)) : f));
  }
  d.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = o(e = +e), a = o(t = +t), r = n === a ? 0 : 1 / (a - n), d) : [e, t];
  }, d.clamp = function(f) {
    return arguments.length ? (i = !!f, d) : i;
  }, d.interpolator = function(f) {
    return arguments.length ? (s = f, d) : s;
  };
  function c(f) {
    return function(p) {
      var v, m;
      return arguments.length ? ([v, m] = p, s = f(v, m), d) : [s(0), s(1)];
    };
  }
  return d.range = c(io), d.rangeRound = c(Of), d.unknown = function(f) {
    return arguments.length ? (u = f, d) : u;
  }, function(f) {
    return o = f, n = f(e), a = f(t), r = n === a ? 0 : 1 / (a - n), d;
  };
}
function C_(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function S_() {
  var e = mr(y4()(nn));
  return e.copy = function() {
    return C_(e, S_());
  }, a_.apply(e, arguments);
}
function b4() {
  var e = 0, t = 0.5, n = 1, a = 1, r, o, s, i, u, d = nn, c, f = !1, p;
  function v(g) {
    return isNaN(g = +g) ? p : (g = 0.5 + ((g = +c(g)) - o) * (a * g < a * o ? i : u), d(f ? Math.max(0, Math.min(1, g)) : g));
  }
  v.domain = function(g) {
    return arguments.length ? ([e, t, n] = g, r = c(e = +e), o = c(t = +t), s = c(n = +n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v) : [e, t, n];
  }, v.clamp = function(g) {
    return arguments.length ? (f = !!g, v) : f;
  }, v.interpolator = function(g) {
    return arguments.length ? (d = g, v) : d;
  };
  function m(g) {
    return function(w) {
      var C, S, $;
      return arguments.length ? ([C, S, $] = w, d = C5(g, [C, S, $]), v) : [d(0), d(0.5), d(1)];
    };
  }
  return v.range = m(io), v.rangeRound = m(Of), v.unknown = function(g) {
    return arguments.length ? (p = g, v) : p;
  }, function(g) {
    return c = g, r = g(e), o = g(t), s = g(n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v;
  };
}
function $_() {
  var e = mr(b4()(nn));
  return e.copy = function() {
    return C_(e, $_());
  }, a_.apply(e, arguments);
}
const Mm = {
  scaleLinear: l_,
  scalePow: zf,
  scaleSqrt: e6,
  scaleLog: d_,
  scaleSymlog: c_,
  scaleIdentity: i_,
  scaleTime: h4,
  scaleUtc: g4,
  scaleSequential: S_,
  scaleDiverging: $_,
  scaleQuantize: p_,
  scaleQuantile: f_,
  scaleThreshold: v_,
  scaleOrdinal: Vf,
  scaleBand: Ff,
  scalePoint: BN
};
var zn;
(function(e) {
  e.X = "x", e.Y = "y";
})(zn || (zn = {}));
const k_ = {
  duration: 600,
  events: {},
  attributes: {}
};
class _4 {
  constructor(t = Ao.SVG) {
    var n, a;
    this.type = Ao.SVG, this.datamodel = new n_(), this.sizing = Ad.Fit, this.events = {}, this._defaultConfig = k_, this._width = 400, this._height = 200, this._containerWidth = void 0, this._containerHeight = void 0, this._containerMargin = { top: 0, bottom: 0, left: 0, right: 0 }, this._setUpComponentEventsThrottled = Wl(this._setUpComponentEvents, 500), this._setCustomAttributesThrottled = Wl(this._setCustomAttributes, 500), t === Ao.SVG ? this.element = document.createElementNS("http://www.w3.org/2000/svg", "g") : this.element = document.createElement("div"), this.uid = TF(), this.g = Ea(this.element);
    const r = (a = (n = this.constructor) === null || n === void 0 ? void 0 : n.selectors) === null || a === void 0 ? void 0 : a.root;
    r && this.g.attr("class", r);
  }
  /** Set the container margin. Called automatically by containers. */
  setContainerMargin(t) {
    this._containerMargin = t;
  }
  setConfig(t) {
    this.prevConfig = this.config, this.config = Ji(this._defaultConfig, t);
  }
  setData(t) {
    this.datamodel.data = t;
  }
  setSize(t, n, a, r) {
    isFinite(t) && (this._width = t), isFinite(n) && (this._height = n), isFinite(a) && (this._containerWidth = a), isFinite(r) && (this._containerHeight = r);
  }
  render(t = this.config.duration) {
    this._render(t);
    const n = "animating";
    t && (this.g.attr(n, ""), this.g.transition(n).duration(t).on("end interrupt", () => {
      this.g.attr(n, null);
    })), this._setUpComponentEventsThrottled(), this._setCustomAttributesThrottled();
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _render(t = this.config.duration) {
  }
  _setCustomAttributes() {
    const t = this.config.attributes;
    Object.keys(t).forEach((n) => {
      Object.keys(t[n]).forEach((a) => {
        this.g.selectAll(`.${n}`).attr(a, t[n][a]);
      });
    });
  }
  _setUpComponentEvents() {
    this._bindEvents(this.events), this._bindEvents(this.config.events, ".user");
  }
  _bindEvents(t = this.events, n = "") {
    Object.keys(t).forEach((a) => {
      Object.keys(t[a]).forEach((r) => {
        const o = this.g.selectAll(`.${a}`);
        o.on(r + n, (s, i) => {
          const u = o.nodes(), d = u.indexOf(s.currentTarget), c = t[a][r];
          return c?.(i, s, d, u);
        });
      });
    });
  }
  destroy() {
    var t;
    (t = this.g) === null || t === void 0 || t.remove(), this.element = void 0;
  }
  isDestroyed() {
    return !this.element;
  }
}
class w4 extends n_ {
  constructor(t) {
    super(t);
  }
  get data() {
    var t;
    return (t = this._data) !== null && t !== void 0 ? t : [];
  }
  set data(t) {
    Array.isArray(t) && (this._data = t);
  }
}
const B_ = Object.assign(Object.assign({}, k_), { x: void 0, y: void 0, id: (e, t) => {
  var n;
  return (n = e.id) !== null && n !== void 0 ? n : `${t}`;
}, color: (e) => e.color, xScale: void 0, yScale: void 0, excludeFromDomainCalculation: !1 });
class x4 extends _4 {
  constructor() {
    super(...arguments), this.datamodel = new w4(), this.clippable = !0, this.stacked = !1, this._defaultConfig = B_, this._xScale = Mm.scaleLinear(), this._yScale = Mm.scaleLinear();
  }
  get xScale() {
    return this.config.xScale || this._xScale;
  }
  get yScale() {
    return this.config.yScale || this._yScale;
  }
  setConfig(t) {
    var n, a;
    !((n = this.config) === null || n === void 0) && n.xScale && (t.xScale = this.config.xScale), !((a = this.config) === null || a === void 0) && a.yScale && (t.yScale = this.config.yScale), super.setConfig(t);
  }
  setScaleDomain(t, n) {
    var a, r;
    t === zn.X && ((a = this._xScale) === null || a === void 0 || a.domain(n)), t === zn.Y && ((r = this._yScale) === null || r === void 0 || r.domain(n));
  }
  setScaleRange(t, n) {
    var a, r;
    t === zn.X && ((a = this._xScale) === null || a === void 0 || a.range(n)), t === zn.Y && ((r = this._yScale) === null || r === void 0 || r.range(n));
  }
  setScale(t, n) {
    n && t === zn.X && (this._xScale = n), n && t === zn.Y && (this._yScale = n);
  }
  getDataExtent(t, n) {
    const { config: a, datamodel: r } = this;
    switch (t) {
      case zn.X:
        return this.getXDataExtent();
      case zn.Y:
        return this.getYDataExtent(n);
      default:
        return Nu(r.data, a[t]);
    }
  }
  getXDataExtent() {
    const { config: t, datamodel: n } = this;
    return Nu(n.data, t.x);
  }
  /** Some components override this method to provide custom data extent calculation */
  getYDataExtent(t) {
    const { config: n, datamodel: a } = this, r = this.xScale.domain(), o = t ? HV(a.data, r, n.x, !0) : a.data, s = Bf(n.y) ? n.y : [n.y];
    return Nu(o, ...s);
  }
}
var tt;
(function(e) {
  e.Top = "top", e.Bottom = "bottom", e.Left = "left", e.Right = "right", e.Center = "center", e.Auto = "auto";
})(tt || (tt = {}));
var qm;
(function(e) {
  e.Absolute = "absolute", e.Fixed = "fixed";
})(qm || (qm = {}));
var Em;
(function(e) {
  e.Inside = "inside", e.Outside = "outside", e.Center = "center";
})(Em || (Em = {}));
var Tm;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(Tm || (Tm = {}));
const C4 = {
  components: [],
  container: void 0,
  followCursor: !0,
  allowHover: !1,
  horizontalPlacement: tt.Auto,
  horizontalShift: 0,
  verticalPlacement: tt.Top,
  verticalShift: 0,
  attributes: {},
  triggers: {},
  className: void 0,
  showDelay: void 0,
  hideDelay: void 0
}, lu = ln`
  label: tooltip;
  display: inline-block;
  left: 0;
  bottom: 0;
  min-width: max-content;
  position: absolute;
  opacity: 0;
  transition: opacity;
  transition-duration: var(--vis-tooltip-transition-duration);
  z-index: 999999;
  padding: var(--vis-tooltip-padding);
  color: var(--vis-tooltip-text-color);
  border-radius: var(--vis-tooltip-border-radius);
  box-shadow: var(--vis-tooltip-box-shadow);
  border: solid 1px var(--vis-tooltip-border-color);
  background-color: var(--vis-tooltip-background-color);
  backdrop-filter: var(--vis-tooltip-backdrop-filter);
`, S4 = lu, $4 = qf`
  :root {
    --vis-tooltip-background-color: rgba(255, 255, 255, 0.95);
    --vis-tooltip-border-color: #e5e9f7;
    --vis-tooltip-text-color: #000;
    --vis-tooltip-shadow-color: rgba(172, 179, 184, 0.35);
    --vis-tooltip-backdrop-filter: none;
    --vis-tooltip-padding: 10px 15px;
    --vis-tooltip-border-radius: 5px;
    --vis-tooltip-transition-duration: 300ms;
    --vis-tooltip-box-shadow: none;

    --vis-dark-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-dark-tooltip-text-color: #e5e9f7;
    --vis-dark-tooltip-border-color: var(--vis-color-grey);
    --vis-dark-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }

  body.theme-dark ${`.${lu}`} {
    --vis-tooltip-background-color: var(--vis-dark-tooltip-background-color);
    --vis-tooltip-text-color: var(--vis-dark-tooltip-text-color);
    --vis-tooltip-border-color: var(--vis-dark-tooltip-border-color);
    --vis-tooltip-shadow-color: var(--vis-dark-tooltip-shadow-color);
  }

  body.theme-dark {
    --vis-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-tooltip-text-color: #e5e9f7;
    --vis-tooltip-border-color: var(--vis-color-grey);
    --vis-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }
`, D_ = ln`
  bottom: unset;
  position: fixed;
`, bl = ln`
  opacity: 1;
`, _l = ln`
  display: none;
`, P_ = ln`
  label: non-interactive;
  pointer-events: none;
  user-select: none;
`, k4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hidden: _l,
  nonInteractive: P_,
  positionFixed: D_,
  root: lu,
  show: bl,
  tooltip: S4,
  variables: $4
}, Symbol.toStringTag, { value: "Module" }));
class M_ {
  constructor(t = {}) {
    this._defaultConfig = C4, this.config = this._defaultConfig, this._setUpEventsThrottled = Wl(this._setUpEvents, 500), this._setContainerPositionThrottled = Wl(this._setContainerPosition, 500), this._isShown = !1, this.element = document.createElement("div"), this.div = Ea(this.element).attr("class", lu).classed(bl, !1).classed(_l, !0), this.setConfig(t), this.components = this.config.components, this._mutationObserver = new MutationObserver(() => {
      this._isShown && (!this.config.followCursor && this._hoveredElement ? this.placeByElement(this._hoveredElement) : this._position && this.place({ x: this._position[0], y: this._position[1] }));
    }), this._mutationObserver.observe(this.div.node(), { childList: !0, subtree: !0 });
  }
  setConfig(t) {
    var n;
    this.prevConfig = this.config, this.config = Ji(this._defaultConfig, t), this.prevConfig.horizontalPlacement !== this.config.horizontalPlacement && this.overrideHorizontalPlacement(void 0), this.config.container && this.config.container !== ((n = this.prevConfig) === null || n === void 0 ? void 0 : n.container) && this.setContainer(this.config.container), this._setUpAttributes();
  }
  setContainer(t) {
    var n;
    (n = this.element.parentNode) === null || n === void 0 || n.removeChild(this.element), this._container = t, this._container.appendChild(this.element), this._setContainerPositionThrottled();
  }
  getContainer() {
    return this._container;
  }
  hasContainer() {
    return !!this._container && this._container.isConnected;
  }
  setComponents(t) {
    this.components = t;
  }
  update() {
    this._container && this._setUpEventsThrottled();
  }
  /** Show the tooltip immediately by providing content and position */
  show(t, n) {
    this.render(t), this.place(n);
  }
  _hide() {
    this.div.classed(bl, !1).on("transitionend", () => {
      this.div.classed(_l, !this._isShown);
    }), this._isShown = !1;
  }
  /** Hides the tooltip after `hideDelay` */
  hide() {
    window.clearTimeout(this._showDelayTimeoutId), this.config.hideDelay ? (window.clearTimeout(this._hideDelayTimeoutId), this._hideDelayTimeoutId = setTimeout(() => this._hide(), this.config.hideDelay)) : this._hide();
  }
  _display() {
    window.clearTimeout(this._hideDelayTimeoutId), this.div.classed(_l, !1).classed(bl, !0), this._isShown = !0;
  }
  /** Simply display the tooltip with its previous content on position, taking into account `showDelay` */
  display() {
    this._isShown || (this.config.showDelay ? (window.clearTimeout(this._showDelayTimeoutId), this._showDelayTimeoutId = setTimeout(() => {
      this._display(), this.place({ x: this._position[0], y: this._position[1] });
    }, this.config.showDelay)) : this._display());
  }
  place(t) {
    if (this._position = [t.x, t.y], !this.hasContainer()) {
      console.warn("Unovis | Tooltip: Container was not set or is not initialized yet");
      return;
    }
    const { config: n } = this, a = this.element.offsetWidth, r = this.element.offsetHeight, o = this._overriddenHorizontalPlacement || (n.horizontalPlacement === tt.Auto ? tt.Center : n.horizontalPlacement), s = n.verticalPlacement === tt.Auto ? t.y - r < 0 ? tt.Bottom : tt.Top : n.verticalPlacement, i = 5, u = o === tt.Left ? -a - i - n.horizontalShift : o === tt.Center ? -a / 2 : i + n.horizontalShift, d = s === tt.Bottom ? i + n.verticalShift : s === tt.Center ? -r / 2 : -i - n.verticalShift - r, [c, f] = this._constraintPosToContainer(t.x + u, t.y + d, a, r);
    this._applyPosition(c, f, r);
  }
  placeByElement(t) {
    const { config: n } = this;
    this._hoveredElement = t;
    const a = 5, r = this.element.offsetWidth, o = this.element.offsetHeight, s = this.isContainerBody(), i = s ? window.innerWidth : this._container.scrollWidth, u = t.getBoundingClientRect(), d = s ? [u.x, u.y] : zl({
      clientX: u.x,
      clientY: u.y,
      pageX: u.x,
      pageY: u.y
    }, this._container), c = this._overriddenHorizontalPlacement || (n.horizontalPlacement === tt.Auto ? d[0] - r < 0 ? tt.Right : d[0] + r > i ? tt.Left : tt.Center : n.horizontalPlacement);
    let f = 0;
    switch (c) {
      case tt.Left:
        f = -r - a - n.horizontalShift;
        break;
      case tt.Right:
        f = u.width + a + n.horizontalShift;
        break;
      case tt.Center:
      default:
        f = (-r + u.width) / 2;
        break;
    }
    const p = n.verticalPlacement === tt.Auto ? c !== tt.Center ? tt.Center : d[1] - o < 0 ? tt.Bottom : tt.Top : n.verticalPlacement;
    let v = -o;
    switch (p) {
      case tt.Center:
        v += (o + u.height) / 2;
        break;
      case tt.Bottom:
        v += o + u.height + a + n.verticalShift;
        break;
      case tt.Top:
      default:
        v += -a - n.verticalShift;
        break;
    }
    const [m, g] = this._constraintPosToContainer(d[0] + f, d[1] + v, r, o);
    this._applyPosition(m, g, o);
  }
  isContainerBody() {
    return this._container === document.body;
  }
  /** Allows to override the horizontal placement of the tooltip which is useful when you want to define custom positioning behavior.
   * This method has been added for Crosshair to allow it position tooltip left or right of the crosshair line
   * (see the `_showTooltip` method of the Crosshair component).
   */
  overrideHorizontalPlacement(t) {
    this._overriddenHorizontalPlacement = t;
  }
  render(t) {
    var n;
    const { config: a, prevConfig: r } = this;
    t instanceof HTMLElement ? this.div.select(":first-child").node() !== t && this.div.html("").append(() => t) : t !== null && this.div.html(t || ""), this.div.classed((n = a.className) !== null && n !== void 0 ? n : "", !!a.className).classed(P_, !a.allowHover), r?.className && r.className !== a.className && this.div.classed(r.className, !1), this.display();
  }
  _applyPosition(t, n, a) {
    const r = this.isContainerBody(), o = r ? window.innerHeight : this._container.scrollHeight;
    this.div.classed(D_, r).style("top", r ? `${n}px` : "unset").style("bottom", r ? "unset" : `${o - n - a}px`).style("left", `${t}px`);
  }
  _constraintPosToContainer(t, n, a, r) {
    const o = this.isContainerBody(), s = o ? window.innerHeight : this._container.scrollHeight, i = o ? window.innerWidth : this._container.scrollWidth, u = 10, d = t > i - a - u, c = t < u, f = d ? i - a - u : c ? u : t, p = 10, v = n > s - r - p, m = n < p, g = v ? s - r - p : m ? p : n;
    return [
      i < a ? 0 : f,
      s < r ? 0 : g
    ];
  }
  _setContainerPosition() {
    var t;
    this._container !== document.body && ((t = getComputedStyle(this._container)) === null || t === void 0 ? void 0 : t.position) === "static" && (this._container.style.position = "relative");
  }
  _setUpEvents() {
    const { config: t } = this;
    this.components.forEach((n) => {
      const a = Ea(n.element);
      a.on("mousemove.tooltip", (r) => {
        const { config: o } = this, s = r.composedPath && r.composedPath() || r.path || [r.target];
        for (const i of Object.keys(o.triggers)) {
          const u = o.triggers[i];
          if (!u)
            continue;
          const d = a.selectAll(`.${i}`).nodes();
          for (const c of s) {
            if (c === a.node())
              break;
            if (c.classList.contains(i)) {
              const f = d.indexOf(c), p = Ea(c).datum(), v = u(p, f, d), [m, g] = this.isContainerBody() ? [r.clientX, r.clientY] : zl(r, this._container);
              v === null ? this.hide() : (this.render(v), o.followCursor ? this.place({ x: m, y: g }) : this.placeByElement(c)), r.stopPropagation();
              return;
            }
          }
        }
        this._isShown && this.hide();
      }).on("mouseleave.tooltip", (r) => {
        r.stopPropagation(), this.hide();
      });
    }), t.allowHover ? this.div.on("mouseenter.tooltip", this._display.bind(this)).on("mouseleave.tooltip", this.hide.bind(this)) : this.div.on("mouseenter.tooltip", null).on("mouseleave.tooltip", null);
  }
  _setUpAttributes() {
    const t = this.config.attributes;
    t && Object.keys(t).forEach((n) => {
      this.div.attr(n, t[n]);
    });
  }
  destroy() {
    var t;
    this._mutationObserver.disconnect(), window.clearTimeout(this._hideDelayTimeoutId), window.clearTimeout(this._showDelayTimeoutId), (t = this.div) === null || t === void 0 || t.remove();
  }
}
M_.selectors = k4;
function el(e) {
  return function() {
    return e;
  };
}
const q_ = Math.cos, li = Math.sin, Ln = Math.sqrt, ii = Math.PI, iu = 2 * ii, Xd = Math.PI, Jd = 2 * Xd, Wa = 1e-6, B4 = Jd - Wa;
function E_(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function D4(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return E_;
  const n = 10 ** t;
  return function(a) {
    this._ += a[0];
    for (let r = 1, o = a.length; r < o; ++r)
      this._ += Math.round(arguments[r] * n) / n + a[r];
  };
}
class P4 {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? E_ : D4(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, a, r) {
    this._append`Q${+t},${+n},${this._x1 = +a},${this._y1 = +r}`;
  }
  bezierCurveTo(t, n, a, r, o, s) {
    this._append`C${+t},${+n},${+a},${+r},${this._x1 = +o},${this._y1 = +s}`;
  }
  arcTo(t, n, a, r, o) {
    if (t = +t, n = +n, a = +a, r = +r, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let s = this._x1, i = this._y1, u = a - t, d = r - n, c = s - t, f = i - n, p = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > Wa) if (!(Math.abs(f * u - d * c) > Wa) || !o)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let v = a - s, m = r - i, g = u * u + d * d, w = v * v + m * m, C = Math.sqrt(g), S = Math.sqrt(p), $ = o * Math.tan((Xd - Math.acos((g + p - w) / (2 * C * S))) / 2), B = $ / S, k = $ / C;
      Math.abs(B - 1) > Wa && this._append`L${t + B * c},${n + B * f}`, this._append`A${o},${o},0,0,${+(f * v > c * m)},${this._x1 = t + k * u},${this._y1 = n + k * d}`;
    }
  }
  arc(t, n, a, r, o, s) {
    if (t = +t, n = +n, a = +a, s = !!s, a < 0) throw new Error(`negative radius: ${a}`);
    let i = a * Math.cos(r), u = a * Math.sin(r), d = t + i, c = n + u, f = 1 ^ s, p = s ? r - o : o - r;
    this._x1 === null ? this._append`M${d},${c}` : (Math.abs(this._x1 - d) > Wa || Math.abs(this._y1 - c) > Wa) && this._append`L${d},${c}`, a && (p < 0 && (p = p % Jd + Jd), p > B4 ? this._append`A${a},${a},0,1,${f},${t - i},${n - u}A${a},${a},0,1,${f},${this._x1 = d},${this._y1 = c}` : p > Wa && this._append`A${a},${a},0,${+(p >= Xd)},${f},${this._x1 = t + a * Math.cos(o)},${this._y1 = n + a * Math.sin(o)}`);
  }
  rect(t, n, a, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${a = +a}v${+r}h${-a}Z`;
  }
  toString() {
    return this._;
  }
}
function M4(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const a = Math.floor(n);
      if (!(a >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = a;
    }
    return e;
  }, () => new P4(t);
}
const T_ = {
  draw(e, t) {
    const n = Ln(t / ii);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, iu);
  }
}, q4 = {
  draw(e, t) {
    const n = Ln(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, A_ = Ln(1 / 3), E4 = A_ * 2, T4 = {
  draw(e, t) {
    const n = Ln(t / E4), a = n * A_;
    e.moveTo(0, -n), e.lineTo(a, 0), e.lineTo(0, n), e.lineTo(-a, 0), e.closePath();
  }
}, A4 = {
  draw(e, t) {
    const n = Ln(t), a = -n / 2;
    e.rect(a, a, n, n);
  }
}, I4 = 0.8908130915292852, I_ = li(ii / 10) / li(7 * ii / 10), O4 = li(iu / 10) * I_, R4 = -q_(iu / 10) * I_, V4 = {
  draw(e, t) {
    const n = Ln(t * I4), a = O4 * n, r = R4 * n;
    e.moveTo(0, -n), e.lineTo(a, r);
    for (let o = 1; o < 5; ++o) {
      const s = iu * o / 5, i = q_(s), u = li(s);
      e.lineTo(u * n, -i * n), e.lineTo(i * a - u * r, u * a + i * r);
    }
    e.closePath();
  }
}, Qu = Ln(3), F4 = {
  draw(e, t) {
    const n = -Ln(t / (Qu * 3));
    e.moveTo(0, n * 2), e.lineTo(-Qu * n, -n), e.lineTo(Qu * n, -n), e.closePath();
  }
}, bn = -0.5, _n = Ln(3) / 2, Zd = 1 / Ln(12), N4 = (Zd / 2 + 1) * 3, L4 = {
  draw(e, t) {
    const n = Ln(t / N4), a = n / 2, r = n * Zd, o = a, s = n * Zd + n, i = -o, u = s;
    e.moveTo(a, r), e.lineTo(o, s), e.lineTo(i, u), e.lineTo(bn * a - _n * r, _n * a + bn * r), e.lineTo(bn * o - _n * s, _n * o + bn * s), e.lineTo(bn * i - _n * u, _n * i + bn * u), e.lineTo(bn * a + _n * r, bn * r - _n * a), e.lineTo(bn * o + _n * s, bn * s - _n * o), e.lineTo(bn * i + _n * u, bn * u - _n * i), e.closePath();
  }
};
function z4(e, t) {
  let n = null, a = M4(r);
  e = typeof e == "function" ? e : el(e || T_), t = typeof t == "function" ? t : el(t === void 0 ? 64 : +t);
  function r() {
    let o;
    if (n || (n = o = a()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null;
  }
  return r.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : el(o), r) : e;
  }, r.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : el(+o), r) : t;
  }, r.context = function(o) {
    return arguments.length ? (n = o ?? null, r) : n;
  }, r;
}
function Do(e, t, n, a) {
  return Array.isArray(t) && isFinite(n) ? t[n % t.length] : Db(e, t, n) || (Oo(n) ? `var(${Lb(n)})` : null);
}
var Hn;
(function(e) {
  e.Circle = "circle", e.Cross = "cross", e.Diamond = "diamond", e.Square = "square", e.Star = "star", e.Triangle = "triangle", e.Wye = "wye";
})(Hn || (Hn = {}));
const H4 = {
  [Hn.Circle]: T_,
  [Hn.Cross]: q4,
  [Hn.Diamond]: T4,
  [Hn.Square]: A4,
  [Hn.Star]: V4,
  [Hn.Triangle]: F4,
  [Hn.Wye]: L4
}, cn = Object.assign(Object.assign({}, Hn), { Line: "line" });
var ui;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(ui || (ui = {}));
const U4 = {
  items: [],
  labelClassName: "",
  onLegendItemClick: void 0,
  labelFontSize: null,
  labelMaxWidth: null,
  bulletSize: null,
  bulletSpacing: 4,
  bulletShape: (e) => {
    var t;
    return (t = e.shape) !== null && t !== void 0 ? t : cn.Circle;
  },
  orientation: ui.Horizontal,
  renderIntoProvidedDomNode: !1
}, tl = ns * 3, j4 = {
  [cn.Circle]: Math.PI / 4,
  [cn.Cross]: 5 / 9,
  [cn.Diamond]: Math.sqrt(3) / 6,
  [cn.Square]: 1,
  [cn.Star]: 0.3,
  [cn.Triangle]: Math.sqrt(3) / 4,
  [cn.Wye]: 5 / 11
};
function O_(e, t, n) {
  return t < 1 ? 0 : e * t + n * (t - 1);
}
function W4(e) {
  e.each((t, n, a) => {
    Ea(a[n]).append("svg").attr("width", "100%").attr("height", "100%").append("path");
  });
}
function G4(e, t, n) {
  e.each((a, r, o) => {
    var s;
    const i = Db(a, t.bulletShape, r), u = UV((s = a.color) !== null && s !== void 0 ? s : Do(a, n, r)), d = u.length, c = tl, f = Ld(getComputedStyle(o[r]).getPropertyValue("--vis-legend-bullet-size")), p = t.bulletSpacing * (tl / f), v = O_(c, d, p), m = i === cn.Line ? tl / 2.5 : tl, g = Ea(o[r]).select("svg").attr("viewBox", `0 0 ${v} ${m}`);
    g.selectAll("path").remove();
    const w = a.inactive ? "var(--vis-legend-bullet-inactive-opacity)" : 1;
    u.forEach((C, S) => {
      const $ = g.append("path");
      if (i === cn.Line) {
        const B = S * (c + p), k = B + c;
        $.attr("d", `M${B},${m / 2} L${k},${m / 2}`).attr("transform", null).style("opacity", w).style("stroke", C).style("stroke-width", "3px").style("fill", null).style("fill-opacity", null).style("marker-start", "none").style("marker-end", "none");
      } else {
        const B = z4().type(H4[i]).size(c * m * j4[i]), k = (c - 2) / c;
        let P = m / 2;
        switch (i) {
          case cn.Triangle:
            P += m / 8;
            break;
          case cn.Star:
            P += m / 16;
            break;
          case cn.Wye:
            P -= m / 16;
            break;
        }
        const D = S * (c + p) + c / 2;
        $.attr("d", B).attr("transform", `translate(${D}, ${Math.round(P)}) scale(${k})`).style("stroke", C).style("stroke-width", "1px").style("opacity", null).style("fill", C).style("fill-opacity", w);
      }
    });
  });
}
const Jf = ln`
  label: bullet-legend-component;
`, K4 = qf`
  :root {
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-legend-font-family: */

    --vis-legend-label-color: #6c778c;
    --vis-legend-label-max-width: 300px;
    --vis-legend-label-font-size: 12px;
    --vis-legend-bullet-size: 9px;
    --vis-legend-bullet-inactive-opacity: 0.15;
    --vis-legend-item-spacing: 20px;
    --vis-legend-vertical-item-spacing: 5px;
    --vis-legend-bullet-label-spacing: 8px;

    --vis-dark-legend-label-color: #eee;
  }

  body.theme-dark ${`.${Jf}`} {
    --vis-legend-label-color: var(--vis-dark-legend-label-color);
  }

  body.theme-patterns {
    --vis-legend-bullet-size: 14px;
  }
`, wl = ln`
  label: legendItem;
  display: inline-flex;
  align-items: center;
  font-family: var(--vis-legend-font-family, var(--vis-font-family));
  margin-right: var(--vis-legend-item-spacing);
  white-space: nowrap;
  cursor: default;
  user-select: none;
  max-width: min-content;
`, R_ = ln`
  label: legendItemVertical;
  display: flex;
  margin-top: var(--vis-legend-vertical-item-spacing);
`, V_ = ln`
  cursor: pointer;
`, Qd = ln`
  label: legendItemLabel;
  font-size: var(--vis-legend-label-font-size);
  display: inline-block;
  vertical-align: middle;
  color: var(--vis-legend-label-color);
  max-width: var(--vis-legend-label-max-width);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`, ec = ln`
  flex: 0 0 auto;
  label: legendItemBullet;
  margin-right: var(--vis-legend-bullet-label-spacing);
  height: var(--vis-legend-bullet-size);
  width: var(--vis-legend-bullet-size);

  svg {
    display: block;
  }
`, Y4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bullet: ec,
  clickable: V_,
  item: wl,
  itemVertical: R_,
  label: Qd,
  root: Jf,
  variables: K4
}, Symbol.toStringTag, { value: "Module" }));
class Zf {
  constructor(t, n) {
    this._defaultConfig = U4, this.config = this._defaultConfig, this._colorAccessor = (a) => a.color, this._container = t, this.div = n?.renderIntoProvidedDomNode ? Ea(this._container) : Ea(this._container).append("div"), this.div.classed(Jf, !0), this.element = this.div.node(), n && this.update(n);
  }
  update(t) {
    this.prevConfig = this.config, this.config = Ji(this._defaultConfig, t), this.render();
  }
  render() {
    const { config: t } = this, n = this.div.selectAll(`.${wl}`).data(t.items), a = n.enter().append("div").on("click", this._onItemClick.bind(this)), r = a.merge(n);
    r.attr("class", (o) => {
      var s;
      return `${wl} ${(s = o.className) !== null && s !== void 0 ? s : ""}`;
    }).classed(R_, t.orientation === ui.Vertical).classed(V_, (o) => !!t.onLegendItemClick && this._isItemClickable(o)).attr("title", (o) => o.name).style("display", (o) => o.hidden ? "none" : null), a.append("span").attr("class", ec).call(W4), r.select(`.${ec}`).style("width", function(o) {
      const i = (Array.isArray(o.color) ? o.color : [o.color]).length, u = Ld(getComputedStyle(this).getPropertyValue("--vis-legend-bullet-size")) || 9, d = t.bulletSize ? Ld(t.bulletSize) : u, c = t.bulletSpacing;
      return `${O_(d, i, c)}px`;
    }).style("height", t.bulletSize).style("box-sizing", "content-box").call(G4, this.config, this._colorAccessor), a.append("span").attr("class", Qd).classed(t.labelClassName, !0).style("max-width", t.labelMaxWidth).style("font-size", t.labelFontSize), r.select(`.${Qd}`).text((o) => o.name), n.exit().remove();
  }
  _isItemClickable(t) {
    return t.pointer === void 0 ? !0 : t.pointer;
  }
  _onItemClick(t, n) {
    const { config: { onLegendItemClick: a } } = this, o = this.div.selectAll(`.${wl}`).nodes().indexOf(t.currentTarget);
    a && a(n, o);
  }
  destroy() {
    this.element !== this._container && this.div.remove();
  }
}
Zf.selectors = Y4;
const X4 = Object.assign(Object.assign({}, B_), { yStacked: void 0, baseline: null, duration: 100, tooltip: void 0, template: (e, t, n, a) => "", hideWhenFarFromPointer: !0, hideWhenFarFromPointerDistance: 100, snapToData: !0, getCircles: void 0, color: void 0, strokeColor: void 0, strokeWidth: void 0, onCrosshairMove: void 0, forceShowAt: void 0, skipRangeCheck: !1 }), J4 = qf`
  :root {
    --vis-crosshair-line-stroke-color: #888;
    --vis-crosshair-line-stroke-width: 1px;
    --vis-crosshair-line-stroke-opacity: 1;
    --vis-crosshair-circle-stroke-color: #fff;
    --vis-crosshair-circle-stroke-width: 1px;
    --vis-crosshair-circle-stroke-opacity: 0.75;
  }
`, Z4 = ln`
  label: crosshair-component;
`, F_ = ln`
  stroke: var(--vis-crosshair-line-stroke-color);
  stroke-width: var(--vis-crosshair-line-stroke-width);
  stroke-opacity: var(--vis-crosshair-line-stroke-opacity);
  pointer-events: none;
`, N_ = ln`
  stroke: var(--vis-crosshair-circle-stroke-color);
  stroke-width: var(--vis-crosshair-circle-stroke-width);
  stroke-opacity: var(--vis-crosshair-circle-stroke-opacity);
  pointer-events: none;
`, Q4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle: N_,
  globalStyles: J4,
  line: F_,
  root: Z4
}, Symbol.toStringTag, { value: "Module" }));
class L_ extends x4 {
  constructor(t) {
    super(), this.clippable = !0, this._defaultConfig = X4, this.config = this._defaultConfig, this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, this._animFrameId = null, this._accessors = {
      x: void 0,
      y: void 0,
      yStacked: void 0,
      baseline: void 0
    }, t && this.setConfig(t), this.g.style("opacity", 0), this.line = this.g.append("line").attr("class", F_);
  }
  set accessors(t) {
    this._accessors = t;
  }
  get accessors() {
    var t;
    const { config: n } = this, a = !!(n.x || n.y || n.yStacked), r = a ? n.x : this._accessors.x, o = a ? n.y : this._accessors.y, s = o ? Bf(o) ? o : [o] : void 0, i = a ? n.yStacked : this._accessors.yStacked, u = (t = n.baseline) !== null && t !== void 0 ? t : this._accessors.baseline;
    return { x: r, y: s, yStacked: i, baseline: u };
  }
  _isContainerInViewport() {
    var t;
    if (!(!((t = this.container) === null || t === void 0) && t.node()))
      return !1;
    const n = this.container.node().getBoundingClientRect(), a = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight, o = Math.max(0, Math.min(n.right, a) - Math.max(n.left, 0)), s = Math.max(0, Math.min(n.bottom, r) - Math.max(n.top, 0)), i = n.width * n.height, u = o * s;
    return i > 0 && u / i >= 0.35;
  }
  setContainer(t) {
    this.container !== t && (this.container = t, this.container.on("mousemove.crosshair", this._onMouseMove.bind(this)), this.container.on("mouseout.crosshair", this._onMouseOut.bind(this)), this.container.on("wheel.crosshair", this._onWheel.bind(this)));
  }
  _render(t) {
    var n, a, r, o, s;
    const { config: i, datamodel: u } = this, d = Oo(t) ? t : i.duration, c = i.forceShowAt !== void 0, f = c ? this.xScale(i.forceShowAt) : this._xPx, p = this.xScale.invert(f), v = !((n = u.data) === null || n === void 0) && n.length && this.accessors.x ? u.data.indexOf(Gl(u.data, p, this.accessors.x, ia.Left)) : void 0;
    let m, g;
    i.snapToData && (!this.accessors.y && !this.accessors.yStacked && (!((a = u.data) === null || a === void 0) && a.length) && console.warn("Unovis | Crosshair: Y accessors have not been configured. Please check if they're present in the configuration object"), !(!((r = u.data) === null || r === void 0) && r.length) && this._mouseEvent && console.warn("Unovis | Crosshair: No data to snap to. Make sure the data has been passed to the container or to the crosshair itself"), m = Gl(u.data, p, this.accessors.x), g = u.data.indexOf(m));
    const w = this.xScale.range(), C = this.yScale.range(), S = i.snapToData && m ? Av(Math.round(this.xScale(pn(m, this.accessors.x, g))), 0, this._width) : Av(f, w[0], w[1]), $ = f >= w[0] && f <= w[1], B = this._yPx >= Math.min(C[0], C[1]) && this._yPx <= Math.max(C[0], C[1]);
    let k = i.skipRangeCheck ? !!this._xPx : this._xPx ? $ && B : $;
    i.hideWhenFarFromPointer && Math.abs(S - +f) >= i.hideWhenFarFromPointerDistance && (k = !1);
    const P = (o = i.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (k && P && this._isContainerInViewport()) {
      const M = P.getContainer() || this.container.node(), O = P.isContainerBody();
      if (c) {
        const F = this.container.node().getBoundingClientRect(), J = (O ? f + F.left : f) + this._containerMargin.left, ne = this._height / 2 + (O ? F.top : 0), Q = [J, ne];
        this._showTooltip(m, p, Q, v);
      } else if (this._mouseEvent) {
        const F = O ? [this._mouseEvent.clientX, this._mouseEvent.clientY] : zl(this._mouseEvent, M);
        this._showTooltip(m, p, F, v);
      }
    } else
      this._hideTooltip();
    if (this._mouseEvent && ((s = i.onCrosshairMove) === null || s === void 0 || s.call(i, k ? this.xScale.invert(this._xPx) : void 0, m, g, this._mouseEvent), this._mouseEvent = void 0), Gu(this.g, d).style("opacity", k ? 1 : 0), !isFinite(f))
      return;
    this.line.attr("y1", 0).attr("y2", this._height), Gu(this.line, d, om).attr("x1", S).attr("x2", S);
    const D = kf(i.getCircles) ? i.getCircles(p, u.data, this.yScale, v) : this.getCircleData(m, g), q = this.g.selectAll("circle").data(D, (M, O) => {
      var F;
      return (F = M.id) !== null && F !== void 0 ? F : O;
    }), T = q.enter().append("circle").attr("class", N_).attr("r", 0).attr("cx", S).attr("cy", (M) => M.y).style("fill", (M) => M.color).style("stroke", (M) => M.strokeColor).style("stroke-width", (M) => M.strokeWidth);
    Gu(T.merge(q), d, om).attr("cx", S).attr("cy", (M) => M.y).attr("r", 4).style("opacity", (M) => M.opacity).style("fill", (M) => M.color).style("stroke", (M) => M.strokeColor).style("stroke-width", (M) => M.strokeWidth), q.exit().remove();
  }
  hide(t) {
    window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      var n, a;
      this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, (a = (n = this.config).onCrosshairMove) === null || a === void 0 || a.call(n, void 0, void 0, void 0, t), this._render();
    });
  }
  _onMouseMove(t) {
    var n;
    const { datamodel: a, element: r } = this;
    !this.accessors.x && (!((n = a.data) === null || n === void 0) && n.length) && console.warn("Unovis | Crosshair: X accessor function has not been configured. Please check if it's present in the configuration object");
    const [o, s] = zl(t, r);
    this._xPx = o, this._yPx = s, this._mouseEvent = t, window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      this._render();
    });
  }
  _onMouseOut(t) {
    var n;
    (!t || !(!((n = this.container) === null || n === void 0) && n.node().contains(t.relatedTarget))) && this.hide(t);
  }
  _onWheel(t) {
    this.hide(t);
  }
  _showTooltip(t, n, a, r) {
    var o;
    const { config: s, datamodel: i } = this, u = (o = s.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (!u || !a)
      return;
    const [d, c] = a, f = s.template(t, n, i.data, r);
    if (u.config.followCursor = !0, !u.config.horizontalPlacement || u.config.horizontalPlacement === tt.Auto) {
      const p = u.isContainerBody() ? d - this.container.node().getBoundingClientRect().left : d;
      u.overrideHorizontalPlacement(p > this._containerWidth / 2 ? tt.Left : tt.Right);
    }
    f && u.show(f, { x: d, y: c });
  }
  _hideTooltip() {
    var t;
    const { config: n } = this, a = (t = n.tooltip) !== null && t !== void 0 ? t : this.tooltip;
    a?.hide();
  }
  // We don't want Crosshair to be be taken in to account in domain calculations
  getYDataExtent() {
    return [void 0, void 0];
  }
  getCircleData(t, n) {
    var a, r;
    const { config: o } = this;
    if (o.snapToData && t) {
      const s = (a = this.accessors.y) !== null && a !== void 0 ? a : [], i = (r = this.accessors.yStacked) !== null && r !== void 0 ? r : [], u = pn(t, this.accessors.baseline, n) || 0, d = NV(t, n, ...i).map((f, p) => ({
        y: this.yScale(f + u),
        opacity: Oo(pn(t, i[p], p)) ? 1 : 0,
        color: Do(t, o.color, p),
        strokeColor: o.strokeColor ? Do(t, o.strokeColor, p) : void 0,
        strokeWidth: o.strokeWidth ? pn(t, o.strokeWidth, p) : void 0
      })), c = s.map((f, p) => {
        const v = pn(t, f, n);
        return {
          y: this.yScale(v),
          opacity: Oo(v) ? 1 : 0,
          color: Do(t, o.color, d.length + p),
          strokeColor: o.strokeColor ? Do(t, o.strokeColor, p) : void 0,
          strokeWidth: o.strokeWidth ? pn(t, o.strokeWidth, p) : void 0
        };
      });
      return d.concat(c);
    }
    return [];
  }
}
L_.selectors = Q4;
const eL = /* @__PURE__ */ Symbol("tooltipAccessorKey"), tL = /* @__PURE__ */ Symbol("crosshairAccessorKey");
function Qf(e, t) {
  return Vd(e, t);
}
function ep(e) {
  const t = ht(), n = t.attrs;
  return E(() => {
    const a = {}, r = t?.vnode.props ?? {};
    return Object.keys(r).forEach((o) => {
      a[xl(o)] = e[xl(o)];
    }), { ...a, ...n };
  });
}
const nL = { "data-vis-crosshair": "" }, aL = /* @__PURE__ */ b({
  __name: "index",
  props: {
    data: {}
  },
  setup(e, { expose: t }) {
    const n = Cn(tL), a = e, r = E(() => n.data.value ?? a.data), o = ep(a), s = I();
    return Ce(() => {
      ke(() => {
        var i;
        s.value = new L_(o.value), (i = s.value) == null || i.setData(r.value), n.update(s.value);
      });
    }), Qe(() => {
      var i;
      (i = s.value) == null || i.destroy(), n.destroy();
    }), ve(o, (i, u) => {
      var d;
      Qf(i, u) || (d = s.value) == null || d.setConfig(o.value);
    }), ve(r, () => {
      var i;
      (i = s.value) == null || i.setData(r.value);
    }), t({
      component: s
    }), (i, u) => (h(), G("div", nL));
  }
}), rL = { "data-vis-tooltip": "" }, z_ = /* @__PURE__ */ b({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    hideDelay: {},
    showDelay: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = Cn(eL), a = ep(e), r = I();
    return Ce(() => {
      ke(() => {
        r.value = new M_(a.value), n.update(r.value);
      });
    }), Qe(() => {
      var o;
      (o = r.value) == null || o.destroy(), n.destroy();
    }), ve(a, (o, s) => {
      var i;
      Qf(o, s) || (i = r.value) == null || i.setConfig(a.value);
    }), t({
      component: r
    }), (o, s) => (h(), G("div", rL));
  }
}), oL = /* @__PURE__ */ b({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletSpacing: {},
    bulletShape: {},
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e;
    E(() => n.data);
    const a = ep(n), r = I(), o = I();
    return Ce(() => {
      ke(() => {
        o.value && (r.value = new Zf(o.value, { ...a.value, renderIntoProvidedDomNode: !0 }));
      });
    }), Qe(() => {
      var s;
      (s = r.value) == null || s.destroy();
    }), ve(a, (s, i) => {
      var u;
      Qf(s, i) || (u = r.value) == null || u.update(a.value);
    }), t({
      component: r
    }), (s, i) => (h(), G("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: o
    }, null, 512));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-map],[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend],[data-vis-rolling-pin-legend]{display:block}")), document.head.appendChild(e);
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t);
  }
})();
const bH = /* @__PURE__ */ b({
  __name: "ChartCrosshair",
  props: {
    colors: { default: () => [] },
    index: {},
    items: {},
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(o) {
      if (n.has(o))
        return n.get(o);
      {
        const s = document.createElement("div"), i = Object.entries(kb(o, [t.index])).map(([d, c]) => ({ ...t.items.find((p) => p.name === d), value: c })), u = t.customTooltip ?? tc;
        return od(u, { title: o[t.index].toString(), data: i }).mount(
          s
        ), n.set(o, s.innerHTML), s.innerHTML;
      }
    }
    function r(o, s) {
      return t.colors[s] ?? "transparent";
    }
    return (o, s) => (h(), G(Ye, null, [
      N(l(z_), {
        "horizontal-shift": 20,
        "vertical-shift": 20
      }),
      N(l(aL), {
        template: a,
        color: r
      })
    ], 64));
  }
}), _H = /* @__PURE__ */ b({
  __name: "ChartLegend",
  props: {
    items: { default: () => [] }
  },
  emits: ["legendItemClick", "update:items"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = I();
    function o() {
      const i = `.${Zf.selectors.item}`;
      ke(() => {
        const u = r.value?.querySelectorAll(i), d = Yt({ variant: "ghost", size: "xs" }).split(" ");
        u?.forEach((c) => c.classList.add(...d, "!inline-flex", "!mr-2"));
      });
    }
    Ce(() => {
      o();
    });
    function s(i, u) {
      a("legendItemClick", i, u);
      const d = n.items[u], c = d ? !d.inactive : !0;
      n.items.some((p) => p.inactive) && c ? a(
        "update:items",
        n.items.map((p) => ({ ...p, inactive: !1 }))
      ) : a(
        "update:items",
        n.items.map(
          (p) => p.name === i.name ? { ...i, inactive: !1 } : { ...p, inactive: !0 }
        )
      ), o();
    }
    return (i, u) => (h(), G("div", {
      ref_key: "elRef",
      ref: r,
      class: "w-max",
      style: {
        "--vis-legend-bullet-size": "16px"
      }
    }, [
      N(l(oL), {
        items: e.items,
        "on-legend-item-click": s
      }, null, 8, ["items"])
    ], 512));
  }
}), wH = /* @__PURE__ */ b({
  __name: "ChartSingleTooltip",
  props: {
    selector: {},
    index: {},
    items: {},
    valueFormatter: { type: Function },
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(r, o, s) {
      const i = t.valueFormatter ?? ((u) => `${u}`);
      if (t.index in r) {
        if (n.has(r))
          return n.get(r);
        {
          const u = document.createElement("div"), d = Object.entries(kb(r, [t.index])).map(([f, p]) => ({ ...t.items?.find((m) => m.name === f), value: i(p) })), c = t.customTooltip ?? tc;
          return od(c, { title: r[t.index], data: d }).mount(u), n.set(r, u.innerHTML), u.innerHTML;
        }
      } else {
        const u = r.data;
        if (n.has(u))
          return n.get(u);
        {
          const d = s[o];
          if (!d) return "";
          const c = getComputedStyle(d), f = [
            { name: u.name, value: i(u[t.index]), color: c.fill }
          ], p = document.createElement("div"), v = t.customTooltip ?? tc;
          return od(v, { title: r[t.index], data: f }).mount(p), n.set(r, p.innerHTML), p.innerHTML;
        }
      }
    }
    return (r, o) => (h(), x(l(z_), {
      "horizontal-shift": 20,
      "vertical-shift": 20,
      triggers: {
        [e.selector]: a
      }
    }, null, 8, ["triggers"]));
  }
}), sL = { class: "flex items-center" }, lL = { class: "mr-2 h-2.5 w-2.5" }, iL = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 30 30"
}, uL = ["stroke", "fill"], dL = { class: "ml-4 font-semibold" }, tc = /* @__PURE__ */ b({
  __name: "ChartTooltip",
  props: {
    title: {},
    data: {}
  },
  setup(e) {
    return (t, n) => (h(), x(l(s3), { class: "text-sm" }, {
      default: y(() => [
        e.title ? (h(), x(l(i3), {
          key: 0,
          class: "border-b p-3"
        }, {
          default: y(() => [
            N(l(u3), null, {
              default: y(() => [
                Re(He(e.title), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : Ee("", !0),
        N(l(l3), { class: "flex min-w-[180px] flex-col gap-1 p-3" }, {
          default: y(() => [
            (h(!0), G(Ye, null, Lt(e.data, (a, r) => (h(), G("div", {
              key: r,
              class: "flex justify-between"
            }, [
              xe("div", sL, [
                xe("span", lL, [
                  (h(), G("svg", iL, [
                    xe("path", {
                      d: " M 15 15 m -14, 0 a 14,14 0 1,1 28,0 a 14,14 0 1,1 -28,0",
                      stroke: a.color,
                      fill: a.color,
                      "stroke-width": "1"
                    }, null, 8, uL)
                  ]))
                ]),
                xe("span", null, He(a.name), 1)
              ]),
              xe("span", dL, He(a.value), 1)
            ]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
function xH(e = 3) {
  const t = Math.floor(e / 2), n = e % 2, a = t + n, r = t;
  return [
    ...Array.from(new Array(a).keys()).map(
      (o) => `hsl(var(--vis-primary-color) / ${1 - 1 / a * o})`
    ),
    ...Array.from(new Array(r).keys()).map(
      (o) => `hsl(var(--vis-secondary-color) / ${1 - 1 / r * o})`
    )
  ];
}
const CH = /* @__PURE__ */ b({
  __name: "Checkbox",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null] },
    disabled: { type: Boolean },
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), o = me(r, a);
    return (s, i) => (h(), x(l(uS), A(l(o), {
      class: l(V)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: y(() => [
        N(l(cS), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: y(() => [
            _(s.$slots, "default", {}, () => [
              N(l(oo), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), SH = /* @__PURE__ */ b({
  __name: "Collapsible",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(jh), oe(le(l(r))), {
      default: y(({ open: i }) => [
        _(o.$slots, "default", { open: i })
      ]),
      _: 3
    }, 16));
  }
}), $H = /* @__PURE__ */ b({
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Wh), A(t, { class: "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down" }), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), kH = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Gh), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), BH = /* @__PURE__ */ b({
  __name: "Combobox",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    resetSearchTermOnBlur: { type: Boolean },
    resetSearchTermOnSelect: { type: Boolean },
    openOnFocus: { type: Boolean },
    openOnClick: { type: Boolean },
    ignoreFilter: { type: Boolean },
    resetModelValueOnClear: { type: Boolean },
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    highlightOnHover: { type: Boolean },
    by: { type: [String, Function] },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(Y$), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), DH = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(M$), A(l(a), {
      class: l(V)("w-[200px]", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PH = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(ak), A(l(n), {
      class: l(V)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), MH = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(sk), A(l(n), {
      class: l(V)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        e.heading ? (h(), x(l(pk), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(He(e.heading), 1)
          ]),
          _: 1
        })) : Ee("", !0),
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), qH = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: { type: Function },
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(ik), A(l(o), {
      class: l(V)(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), EH = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(dk), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center justify-between gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), TH = /* @__PURE__ */ b({
  __name: "ComboboxList",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(mk), null, {
      default: y(() => [
        N(l(tk), A(l(o), {
          class: l(V)(
            "z-50 w-[200px] rounded-md border bg-popover text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            N(l(_k), null, {
              default: y(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), AH = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(gk), A(l(n), {
      class: l(V)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cL = /* @__PURE__ */ b({
  __name: "Command",
  props: {
    modelValue: { default: "" },
    defaultValue: {},
    multiple: { type: Boolean },
    orientation: {},
    dir: {},
    disabled: { type: Boolean },
    selectionBehavior: {},
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "highlight", "entryFocus", "leave"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a), s = I(/* @__PURE__ */ new Map()), i = I(/* @__PURE__ */ new Map()), { contains: u } = Fh({ sensitivity: "base" }), d = Wt({
      search: "",
      filtered: {
        /** The count of all visible items. */
        count: 0,
        /** Map from visible item id to its search score. */
        items: /* @__PURE__ */ new Map(),
        /** Set of groups with at least one visible item. */
        groups: /* @__PURE__ */ new Set()
      }
    });
    function c() {
      if (!d.search) {
        d.filtered.count = s.value.size;
        return;
      }
      d.filtered.groups = /* @__PURE__ */ new Set();
      let f = 0;
      for (const [p, v] of s.value) {
        const m = u(v, d.search);
        d.filtered.items.set(p, m ? 1 : 0), m && f++;
      }
      for (const [p, v] of i.value)
        for (const m of v)
          if (d.filtered.items.get(m) > 0) {
            d.filtered.groups.add(p);
            break;
          }
      d.filtered.count = f;
    }
    return ve(
      () => d.search,
      () => {
        c();
      }
    ), hL({
      allItems: s,
      allGroups: i,
      filterState: d
    }), (f, p) => (h(), x(l(hg), A(l(o), {
      class: l(V)(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        n.class
      )
    }), {
      default: y(() => [
        _(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fL = /* @__PURE__ */ b({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(bi), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), IH = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Va), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pL = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(xi), null, {
      default: y(() => [
        N(l(gs), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(hs), A(l(o), {
          class: l(V)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(Va), { class: "absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-none disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground" }, {
              default: y(() => [
                N(l(so), { class: "h-4 w-4" }),
                i[0] || (i[0] = xe("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), OH = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(wi), A(l(a), {
      class: l(V)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), RH = /* @__PURE__ */ b({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), VH = /* @__PURE__ */ b({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(l(V)("flex flex-col gap-y-1.5 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), FH = /* @__PURE__ */ b({
  __name: "DialogScrollContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(xi), null, {
      default: y(() => [
        N(l(gs), { class: "fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }, {
          default: y(() => [
            N(l(hs), A({
              class: l(V)(
                "relative z-50 my-8 grid w-full max-w-lg gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full",
                n.class
              )
            }, l(o), {
              onPointerDownOutside: i[0] || (i[0] = (u) => {
                const d = u.detail.originalEvent, c = d.target;
                (d.offsetX > c.clientWidth || d.offsetY > c.clientHeight) && u.preventDefault();
              })
            }), {
              default: y(() => [
                _(s.$slots, "default"),
                N(l(Va), { class: "absolute top-4 right-4 rounded-md p-0.5 transition-colors hover:bg-secondary" }, {
                  default: y(() => [
                    N(l(so), { class: "h-4 w-4" }),
                    i[1] || (i[1] = xe("span", { class: "sr-only" }, "Close", -1))
                  ]),
                  _: 1
                })
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), NH = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Ci), A(l(a), {
      class: l(V)("text-lg leading-none font-semibold tracking-tight", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), LH = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Si), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zH = /* @__PURE__ */ b({
  __name: "CommandDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(fL), oe(le(l(r))), {
      default: y(() => [
        N(l(pL), { class: "overflow-hidden p-0 shadow-lg" }, {
          default: y(() => [
            N(cL, { class: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5" }, {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16));
  }
}), HH = /* @__PURE__ */ b({
  __name: "CommandEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { filterState: a } = uu(), r = E(() => !!a.search && a.filtered.count === 0);
    return (o, s) => r.value ? (h(), x(l(X), A({ key: 0 }, l(n), {
      class: l(V)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"])) : Ee("", !0);
  }
}), UH = /* @__PURE__ */ b({
  __name: "CommandGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { allGroups: a, filterState: r } = uu(), o = Ge(), s = E(() => r.search ? r.filtered.groups.has(o) : !0);
    return yL({ id: o }), Ce(() => {
      a.value.has(o) || a.value.set(o, /* @__PURE__ */ new Set());
    }), Qe(() => {
      a.value.delete(o);
    }), (i, u) => (h(), x(l(bg), A(l(n), {
      id: l(o),
      class: l(V)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      ),
      hidden: s.value ? void 0 : !0
    }), {
      default: y(() => [
        e.heading ? (h(), x(l(N$), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(He(e.heading), 1)
          ]),
          _: 1
        })) : Ee("", !0),
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class", "hidden"]));
  }
}), vL = {
  class: "flex items-center border-b px-3",
  "cmdk-input-wrapper": ""
}, jH = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CommandInput",
  props: {
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), { filterState: r } = uu();
    return (o, s) => (h(), G("div", vL, [
      N(l(AO), { class: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
      N(l(yg), A({ ...l(a), ...o.$attrs }, {
        modelValue: l(r).search,
        "onUpdate:modelValue": s[0] || (s[0] = (i) => l(r).search = i),
        "auto-focus": "",
        class: l(V)(
          "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      }), null, 16, ["modelValue", "class"])
    ]));
  }
}), WH = /* @__PURE__ */ b({
  __name: "CommandItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a), s = Ge(), { filterState: i, allItems: u, allGroups: d } = uu(), c = gL(), f = E(() => {
      if (i.search) {
        const m = i.filtered.items.get(s);
        return m === void 0 ? !0 : m > 0;
      } else
        return !0;
    }), p = I(), v = nI(p);
    return Ce(() => {
      if (!(v.value instanceof HTMLElement)) return;
      u.value.set(s, v.value.textContent ?? n?.value.toString());
      const m = c?.id;
      m && (d.value.has(m) ? d.value.get(m)?.add(s) : d.value.set(m, /* @__PURE__ */ new Set([s])));
    }), Qe(() => {
      u.value.delete(s);
    }), (m, g) => f.value ? (h(), x(l(_g), A({ key: 0 }, l(o), {
      id: l(s),
      ref_key: "itemRef",
      ref: p,
      class: l(V)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      ),
      onSelect: g[0] || (g[0] = () => {
        l(i).search = "";
      })
    }), {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class"])) : Ee("", !0);
  }
}), mL = { role: "presentation" }, GH = /* @__PURE__ */ b({
  __name: "CommandList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(gg), A(l(a), {
      class: l(V)("max-h-[300px] overflow-x-hidden overflow-y-auto", t.class)
    }), {
      default: y(() => [
        xe("div", mL, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), KH = /* @__PURE__ */ b({
  __name: "CommandSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(nf), A(l(n), {
      class: l(V)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), YH = /* @__PURE__ */ b({
  __name: "CommandShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: re(l(V)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), [uu, hL] = Be("Command"), [gL, yL] = Be("CommandGroup"), XH = /* @__PURE__ */ b({
  __name: "ContextMenu",
  props: {
    pressOpenDelay: {},
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(eB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bL = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, JH = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(Jk), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        xe("span", bL, [
          N(l(Bg), null, {
            default: y(() => [
              N(l(oo), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ZH = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(cB), null, {
      default: y(() => [
        N(l(nB), A(l(o), {
          class: l(V)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), QH = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(rB), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), e9 = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(sB), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), t9 = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(uB), A(l(n), {
      class: l(V)("px-2 py-1.5 text-sm font-semibold text-foreground", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), n9 = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(pB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _L = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, a9 = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(mB), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        xe("span", _L, [
          N(l(Bg), null, {
            default: y(() => [
              N(l(mf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), r9 = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(gB), A(l(n), {
      class: l(V)("-mx-1 my-1 h-px bg-border", t.class)
    }), null, 16, ["class"]));
  }
}), o9 = /* @__PURE__ */ b({
  __name: "ContextMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: re(l(V)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), s9 = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(bB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), l9 = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(wB), A(l(o), {
      class: l(V)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), i9 = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(CB), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(za), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), u9 = /* @__PURE__ */ b({
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l($B), oe(le(l(n))), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
(function() {
  var e;
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.nonce = (e = document.head.querySelector("meta[property=csp-nonce]")) == null ? void 0 : e.content, t.appendChild(document.createTextNode('[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32,.72,0,1);animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform, 100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform, 100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height, 0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height, 0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true]):after{content:"";position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]:after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]:after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]:after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]:after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:hover,[data-vaul-handle]:active{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover: hover) and (pointer: fine){[data-vaul-drawer]{-webkit-user-select:none;user-select:none}}@media (pointer: fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{0%{transform:translate3d(0,var(--initial-transform, 100%),0)}to{transform:translateZ(0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform, 100%),0)}}@keyframes slideFromTop{0%{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}to{transform:translateZ(0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}}@keyframes slideFromLeft{0%{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}to{transform:translateZ(0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}}@keyframes slideFromRight{0%{transform:translate3d(var(--initial-transform, 100%),0,0)}to{transform:translateZ(0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform, 100%),0,0)}}')), document.head.appendChild(t);
    }
  } catch (n) {
    console.error("vite-plugin-css-injected-by-js", n);
  }
})();
const wL = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const xL = (e) => typeof e < "u";
function CL(e) {
  return JSON.parse(JSON.stringify(e));
}
function Am(e, t, n, a = {}) {
  var r, o, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = ht(), m = n || v?.emit || ((r = v?.$emit) == null ? void 0 : r.bind(v)) || ((s = (o = v?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(v?.proxy));
  let g = d;
  t || (t = "modelValue"), g = g || `update:${t.toString()}`;
  const w = ($) => i ? typeof i == "function" ? i($) : CL($) : $, C = () => xL(e[t]) ? w(e[t]) : f, S = ($) => {
    p ? p($) && m(g, $) : m(g, $);
  };
  if (u) {
    const $ = C(), B = I($);
    let k = !1;
    return ve(
      () => e[t],
      (P) => {
        k || (k = !0, B.value = w(P), ke(() => k = !1));
      }
    ), ve(
      B,
      (P) => {
        !k && (P !== e[t] || c) && S(P);
      },
      { deep: c }
    ), B;
  } else
    return E({
      get() {
        return C();
      },
      set($) {
        S($);
      }
    });
}
const [tp, SL] = Be("DrawerRoot"), H_ = /* @__PURE__ */ new WeakMap();
function qt(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement) || !t)
    return;
  const a = {};
  Object.entries(t).forEach(([r, o]) => {
    if (r.startsWith("--")) {
      e.style.setProperty(r, o);
      return;
    }
    a[r] = e.style[r], e.style[r] = o;
  }), !n && H_.set(e, a);
}
function $L(e, t) {
  if (!e || !(e instanceof HTMLElement))
    return;
  const n = H_.get(e);
  n && Object.entries(n).forEach(([a, r]) => {
    e.style[a] = r;
  });
}
function nl(e, t) {
  const n = window.getComputedStyle(e), a = n.transform || n.webkitTransform || n.mozTransform;
  let r = a.match(/^matrix3d\((.+)\)$/);
  return r ? Number.parseFloat(r[1].split(", ")[_t(t) ? 13 : 12]) : (r = a.match(/^matrix\((.+)\)$/), r ? Number.parseFloat(r[1].split(", ")[_t(t) ? 5 : 4]) : null);
}
function kL(e) {
  return 8 * (Math.log(e + 1) - 2);
}
function _t(e) {
  switch (e) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return e;
  }
}
function ed(e, t) {
  if (!e)
    return () => {
    };
  const n = e.style.cssText;
  return Object.assign(e.style, t), () => {
    e.style.cssText = n;
  };
}
function BL(...e) {
  return (...t) => {
    for (const n of e)
      typeof n == "function" && n(...t);
  };
}
const ft = {
  DURATION: 0.5,
  EASE: [0.32, 0.72, 0, 1]
}, U_ = 0.4, DL = 0.25, PL = 100, j_ = 8, al = 16, W_ = 26, Im = "vaul-dragging";
function ML({
  activeSnapPoint: e,
  snapPoints: t,
  drawerRef: n,
  overlayRef: a,
  fadeFromIndex: r,
  onSnapPointChange: o,
  direction: s
}) {
  const i = I(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  function u() {
    i.value = {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    };
  }
  Ce(() => {
    typeof window < "u" && window.addEventListener("resize", u);
  }), sr(() => {
    typeof window < "u" && window.removeEventListener("resize", u);
  });
  const d = E(
    () => (t.value && e.value === t.value[t.value.length - 1]) ?? null
  ), c = E(
    () => t.value && t.value.length > 0 && (r?.value || r?.value === 0) && !Number.isNaN(r?.value) && t.value[r?.value ?? -1] === e.value || !t.value
  ), f = E(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.findIndex(($) => $ === e.value)) ?? null;
    }
  ), p = E(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.map(($) => {
        const B = typeof $ == "string";
        let k = 0;
        if (B && (k = Number.parseInt($, 10)), _t(s.value)) {
          const D = B ? k : i.value ? $ * i.value.innerHeight : 0;
          return i.value ? s.value === "bottom" ? i.value.innerHeight - D : -i.value.innerHeight + D : D;
        }
        const P = B ? k : i.value ? $ * i.value.innerWidth : 0;
        return i.value ? s.value === "right" ? i.value.innerWidth - P : -i.value.innerWidth + P : P;
      })) ?? [];
    }
  ), v = E(
    () => {
      var S;
      return f.value !== null ? (S = p.value) == null ? void 0 : S[f.value] : null;
    }
  ), m = (S) => {
    var $, B, k, P;
    const D = (($ = p.value) == null ? void 0 : $.findIndex((q) => q === S)) ?? null;
    ke(() => {
      var q;
      o(D, p.value), qt((q = n.value) == null ? void 0 : q.$el, {
        transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
        transform: _t(s.value) ? `translate3d(0, ${S}px, 0)` : `translate3d(${S}px, 0, 0)`
      });
    }), p.value && D !== p.value.length - 1 && D !== r?.value ? qt((B = a.value) == null ? void 0 : B.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "0"
    }) : qt((k = a.value) == null ? void 0 : k.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "1"
    }), e.value = D !== null ? ((P = t.value) == null ? void 0 : P[D]) ?? null : null;
  };
  ve(
    [e, p, t],
    () => {
      var S;
      if (e.value) {
        const $ = ((S = t.value) == null ? void 0 : S.findIndex((B) => B === e.value)) ?? -1;
        p.value && $ !== -1 && typeof p.value[$] == "number" && m(p.value[$]);
      }
    },
    {
      immediate: !0
      // if you want to run the effect immediately as well
    }
  );
  function g({
    draggedDistance: S,
    closeDrawer: $,
    velocity: B,
    dismissible: k
  }) {
    var P, D, q;
    if (r.value === void 0)
      return;
    const T = s.value === "bottom" || s.value === "right" ? (v.value ?? 0) - S : (v.value ?? 0) + S, M = f.value === r.value - 1, O = f.value === 0, F = S > 0;
    if (M && qt((P = a.value) == null ? void 0 : P.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`
    }), B > 2 && !F) {
      k ? $() : m(p.value[0]);
      return;
    }
    if (B > 2 && F && p && t.value) {
      m(p.value[t.value.length - 1]);
      return;
    }
    const J = (D = p.value) == null ? void 0 : D.reduce((Q, W) => typeof Q != "number" || typeof W != "number" ? Q : Math.abs(W - T) < Math.abs(Q - T) ? W : Q), ne = _t(s.value) ? window.innerHeight : window.innerWidth;
    if (B > U_ && Math.abs(S) < ne * 0.4) {
      const Q = F ? 1 : -1;
      if (Q > 0 && d) {
        m(p.value[(((q = t.value) == null ? void 0 : q.length) ?? 0) - 1]);
        return;
      }
      if (O && Q < 0 && k && $(), f.value === null)
        return;
      m(p.value[f.value + Q]);
      return;
    }
    m(J);
  }
  function w({ draggedDistance: S }) {
    var $;
    if (v.value === null)
      return;
    const B = s.value === "bottom" || s.value === "right" ? v.value - S : v.value + S;
    (s.value === "bottom" || s.value === "right") && B < p.value[p.value.length - 1] || (s.value === "top" || s.value === "left") && B > p.value[p.value.length - 1] || qt(($ = n.value) == null ? void 0 : $.$el, {
      transform: _t(s.value) ? `translate3d(0, ${B}px, 0)` : `translate3d(${B}px, 0, 0)`
    });
  }
  function C(S, $) {
    if (!t.value || typeof f.value != "number" || !p.value || r.value === void 0)
      return null;
    const B = f.value === r.value - 1;
    if (f.value >= r.value && $)
      return 0;
    if (B && !$)
      return 1;
    if (!c.value && !B)
      return null;
    const k = B ? f.value + 1 : f.value - 1, P = B ? p.value[k] - p.value[k - 1] : p.value[k + 1] - p.value[k], D = S / Math.abs(P);
    return B ? 1 - D : D;
  }
  return {
    isLastSnapPoint: d,
    shouldFade: c,
    getPercentageDragged: C,
    activeSnapPointIndex: f,
    onRelease: g,
    onDrag: w,
    snapPointsOffset: p
  };
}
function Om() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
let wo = null;
function qL(e) {
  const { isOpen: t, modal: n, nested: a, hasBeenOpened: r, preventScrollRestoration: o, noBodyStyles: s } = e, i = I(typeof window < "u" ? window.location.href : ""), u = I(0);
  function d() {
    if (Om() && wo === null && t.value && !s.value) {
      wo = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      };
      const { scrollX: f, innerHeight: p } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-u.value}px`,
        left: `${-f}px`,
        right: "0px",
        height: "auto"
      }), setTimeout(() => {
        requestAnimationFrame(() => {
          const v = p - window.innerHeight;
          v && u.value >= p && (document.body.style.top = `-${u.value + v}px`);
        });
      }, 300);
    }
  }
  function c() {
    if (Om() && wo !== null && !s.value) {
      const f = -Number.parseInt(document.body.style.top, 10), p = -Number.parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, wo), window.requestAnimationFrame(() => {
        if (o.value && i.value !== window.location.href) {
          i.value = window.location.href;
          return;
        }
        window.scrollTo(p, f);
      }), wo = null;
    }
  }
  return Ce(() => {
    function f() {
      u.value = window.scrollY;
    }
    f(), window.addEventListener("scroll", f), Qe(() => {
      window.removeEventListener("scroll", f);
    });
  }), ve([t, r, i], () => {
    a.value || !r.value || (t.value ? (window.matchMedia("(display-mode: standalone)").matches || d(), n.value || setTimeout(() => {
      c();
    }, 500)) : c());
  }), { restorePositionSetting: c };
}
function EL(e, t) {
  return e && e.value ? e : t;
}
function TL(e) {
  const {
    emitDrag: t,
    emitRelease: n,
    emitClose: a,
    emitOpenChange: r,
    open: o,
    dismissible: s,
    nested: i,
    modal: u,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    scrollLockTimeout: f,
    closeThreshold: p,
    activeSnapPoint: v,
    fadeFromIndex: m,
    direction: g,
    noBodyStyles: w,
    handleOnly: C,
    preventScrollRestoration: S
  } = e, $ = I(o.value ?? !1), B = I(!1), k = I(!1), P = I(!1), D = I(null), q = I(null), T = I(null), M = I(null), O = I(null), F = I(!1), J = I(null), ne = I(0), Q = I(!1);
  I(0);
  const W = I(null);
  I(0);
  const H = E(() => {
    var De;
    return ((De = W.value) == null ? void 0 : De.$el.getBoundingClientRect().height) || 0;
  }), U = EL(
    e.snapPoints,
    I(void 0)
  ), se = E(() => {
    var De;
    return U && (((De = U.value) == null ? void 0 : De.length) ?? 0) > 0;
  }), ee = I(null), {
    activeSnapPointIndex: de,
    onRelease: pe,
    snapPointsOffset: _e,
    onDrag: ge,
    shouldFade: Te,
    getPercentageDragged: ce
  } = ML({
    snapPoints: U,
    activeSnapPoint: v,
    drawerRef: W,
    fadeFromIndex: m,
    overlayRef: D,
    onSnapPointChange: R,
    direction: g
  });
  function R(De, Ne) {
    U.value && De === Ne.length - 1 && (q.value = /* @__PURE__ */ new Date());
  }
  qL({
    isOpen: $,
    modal: u,
    nested: i,
    hasBeenOpened: B,
    noBodyStyles: w,
    preventScrollRestoration: S
  });
  function te() {
    return (window.innerWidth - W_) / window.innerWidth;
  }
  function z(De, Ne) {
    var Ue;
    if (!De)
      return !1;
    let We = De;
    const it = (Ue = window.getSelection()) == null ? void 0 : Ue.toString(), ut = W.value ? nl(W.value.$el, g.value) : null, $t = /* @__PURE__ */ new Date();
    if (We.hasAttribute("data-vaul-no-drag") || We.closest("[data-vaul-no-drag]"))
      return !1;
    if (g.value === "right" || g.value === "left")
      return !0;
    if (q.value && $t.getTime() - q.value.getTime() < 500)
      return !1;
    if (ut !== null && (g.value === "bottom" ? ut > 0 : ut < 0))
      return !0;
    if (it && it.length > 0)
      return !1;
    if (O.value && $t.getTime() - O.value.getTime() < f.value && ut === 0 || Ne)
      return O.value = $t, !1;
    for (; We; ) {
      if (We.scrollHeight > We.clientHeight) {
        if (We.scrollTop !== 0)
          return O.value = /* @__PURE__ */ new Date(), !1;
        if (We.getAttribute("role") === "dialog")
          return !0;
      }
      We = We.parentNode;
    }
    return !0;
  }
  function ae(De) {
    !s.value && !U.value || W.value && !W.value.$el.contains(De.target) || (k.value = !0, T.value = /* @__PURE__ */ new Date(), De.target.setPointerCapture(De.pointerId), ne.value = _t(g.value) ? De.clientY : De.clientX);
  }
  function ie(De) {
    var Ne, Ue, We, it, ut, $t;
    if (W.value && k.value) {
      const un = g.value === "bottom" || g.value === "right" ? 1 : -1, gn = (ne.value - (_t(g.value) ? De.clientY : De.clientX)) * un, Oe = gn > 0, Pt = U.value && !s.value && !Oe;
      if (Pt && de.value === 0)
        return;
      const jt = Math.abs(gn), Rt = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      let K = jt / H.value;
      const Y = ce(jt, Oe);
      if (Y !== null && (K = Y), Pt && K >= 1 || !F.value && !z(De.target, Oe))
        return;
      if ((Ne = W?.value) == null || Ne.$el.classList.add(Im), F.value = !0, qt((Ue = W.value) == null ? void 0 : Ue.$el, {
        transition: "none"
      }), qt((We = D.value) == null ? void 0 : We.$el, {
        transition: "none"
      }), U.value && ge({ draggedDistance: gn }), Oe && !U.value) {
        const ye = kL(gn), Pe = Math.min(ye * -1, 0) * un;
        qt((it = W.value) == null ? void 0 : it.$el, {
          transform: _t(g.value) ? `translate3d(0, ${Pe}px, 0)` : `translate3d(${Pe}px, 0, 0)`
        });
        return;
      }
      const ue = 1 - K;
      if ((Te.value || m.value && de.value === m.value - 1) && (t(K), qt(
        (ut = D.value) == null ? void 0 : ut.$el,
        {
          opacity: `${ue}`,
          transition: "none"
        },
        !0
      )), Rt && D.value && d.value) {
        const ye = Math.min(te() + K * (1 - te()), 1), Pe = 8 - K * 8, Ae = Math.max(0, 14 - K * 14);
        qt(
          Rt,
          {
            borderRadius: `${Pe}px`,
            transform: _t(g.value) ? `scale(${ye}) translate3d(0, ${Ae}px, 0)` : `scale(${ye}) translate3d(${Ae}px, 0, 0)`,
            transition: "none"
          },
          !0
        );
      }
      if (!U.value) {
        const ye = jt * un;
        qt(($t = W.value) == null ? void 0 : $t.$el, {
          transform: _t(g.value) ? `translate3d(0, ${ye}px, 0)` : `translate3d(${ye}px, 0, 0)`
        });
      }
    }
  }
  function L() {
    var De;
    if (!W.value)
      return;
    const Ne = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]"), Ue = nl(W.value.$el, g.value);
    qt(W.value.$el, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`
    }), qt((De = D.value) == null ? void 0 : De.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "1"
    }), d.value && Ue && Ue > 0 && $.value && qt(
      Ne,
      {
        borderRadius: `${j_}px`,
        overflow: "hidden",
        ..._t(g.value) ? {
          transform: `scale(${te()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${te()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${ft.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${ft.EASE.join(",")})`
      },
      !0
    );
  }
  function be(De) {
    W.value && (a(), De || ($.value = !1), window.setTimeout(() => {
      U.value && (v.value = U.value[0]);
    }, ft.DURATION * 1e3));
  }
  Ie(() => {
    if (!$.value && d.value && wL) {
      const De = setTimeout(() => {
        $L(document.body);
      }, 200);
      return () => clearTimeout(De);
    }
  }), ve(o, () => {
    $.value = o.value, o.value || be();
  });
  function we(De) {
    if (!k.value || !W.value)
      return;
    W.value.$el.classList.remove(Im), F.value = !1, k.value = !1, M.value = /* @__PURE__ */ new Date();
    const Ne = nl(W.value.$el, g.value);
    if (!z(De.target, !1) || !Ne || Number.isNaN(Ne) || T.value === null)
      return;
    const Ue = M.value.getTime() - T.value.getTime(), We = ne.value - (_t(g.value) ? De.clientY : De.clientX), it = Math.abs(We) / Ue;
    if (it > 0.05 && (P.value = !0, window.setTimeout(() => {
      P.value = !1;
    }, 200)), U.value) {
      const $t = g.value === "bottom" || g.value === "right" ? 1 : -1;
      pe({
        draggedDistance: We * $t,
        closeDrawer: be,
        velocity: it,
        dismissible: s.value
      }), n(!0);
      return;
    }
    if (g.value === "bottom" || g.value === "right" ? We > 0 : We < 0) {
      L(), n(!0);
      return;
    }
    if (it > U_) {
      be(), n(!1);
      return;
    }
    const ut = Math.min(
      W.value.$el.getBoundingClientRect().height ?? 0,
      window.innerHeight
    );
    if (Ne >= ut * p.value) {
      be(), n(!1);
      return;
    }
    n(!0), L();
  }
  ve($, (De) => {
    De && (q.value = /* @__PURE__ */ new Date()), r(De);
  }, { immediate: !0 });
  function Fe(De) {
    var Ne, Ue;
    const We = De ? (window.innerWidth - al) / window.innerWidth : 1, it = De ? -16 : 0;
    J.value && window.clearTimeout(J.value), qt((Ne = W.value) == null ? void 0 : Ne.$el, {
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      transform: `scale(${We}) translate3d(0, ${it}px, 0)`
    }), !De && (Ue = W.value) != null && Ue.$el && (J.value = window.setTimeout(() => {
      var ut, $t;
      const un = nl((ut = W.value) == null ? void 0 : ut.$el, g.value);
      qt(($t = W.value) == null ? void 0 : $t.$el, {
        transition: "none",
        transform: _t(g.value) ? `translate3d(0, ${un}px, 0)` : `translate3d(${un}px, 0, 0)`
      });
    }, 500));
  }
  function Xe(De) {
    var Ne;
    if (De < 0)
      return;
    const Ue = _t(g.value) ? window.innerHeight : window.innerWidth, We = (Ue - al) / Ue, it = We + De * (1 - We), ut = -16 + De * al;
    qt((Ne = W.value) == null ? void 0 : Ne.$el, {
      transform: _t(g.value) ? `scale(${it}) translate3d(0, ${ut}px, 0)` : `scale(${it}) translate3d(${ut}px, 0, 0)`,
      transition: "none"
    });
  }
  function lt(De) {
    var Ne;
    const Ue = _t(g.value) ? window.innerHeight : window.innerWidth, We = De ? (Ue - al) / Ue : 1, it = De ? -16 : 0;
    De && qt((Ne = W.value) == null ? void 0 : Ne.$el, {
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      transform: _t(g.value) ? `scale(${We}) translate3d(0, ${it}px, 0)` : `scale(${We}) translate3d(${it}px, 0, 0)`
    });
  }
  return {
    open: o,
    isOpen: $,
    modal: u,
    keyboardIsOpen: Q,
    hasBeenOpened: B,
    drawerRef: W,
    drawerHeightRef: H,
    overlayRef: D,
    handleRef: ee,
    isDragging: k,
    dragStartTime: T,
    isAllowedToDrag: F,
    snapPoints: U,
    activeSnapPoint: v,
    hasSnapPoints: se,
    pointerStart: ne,
    dismissible: s,
    snapPointsOffset: _e,
    direction: g,
    shouldFade: Te,
    fadeFromIndex: m,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    onPress: ae,
    onDrag: ie,
    onRelease: we,
    closeDrawer: be,
    onNestedDrag: Xe,
    onNestedRelease: lt,
    onNestedOpenChange: Fe,
    emitClose: a,
    emitDrag: t,
    emitRelease: n,
    emitOpenChange: r,
    nested: i,
    handleOnly: C,
    noBodyStyles: w
  };
}
const AL = /* @__PURE__ */ b({
  __name: "DrawerRoot",
  props: {
    activeSnapPoint: { default: void 0 },
    closeThreshold: { default: DL },
    shouldScaleBackground: { type: Boolean, default: void 0 },
    setBackgroundColorOnScale: { type: Boolean, default: !0 },
    scrollLockTimeout: { default: PL },
    fixed: { type: Boolean, default: void 0 },
    dismissible: { type: Boolean, default: !0 },
    modal: { type: Boolean, default: !0 },
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: void 0 },
    nested: { type: Boolean, default: !1 },
    direction: { default: "bottom" },
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean, default: !1 },
    preventScrollRestoration: { type: Boolean },
    snapPoints: { default: void 0 },
    fadeFromIndex: { default: void 0 }
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n;
    B0();
    const o = E(() => a.fadeFromIndex ?? (a.snapPoints && a.snapPoints.length - 1)), s = Am(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), i = Am(a, "activeSnapPoint", r, {
      passive: a.activeSnapPoint === void 0
    }), u = {
      emitDrag: (m) => r("drag", m),
      emitRelease: (m) => r("release", m),
      emitClose: () => r("close"),
      emitOpenChange: (m) => {
        r("update:open", m), setTimeout(() => {
          r("animationEnd", m);
        }, ft.DURATION * 1e3);
      }
    }, { closeDrawer: d, hasBeenOpened: c, modal: f, isOpen: p } = SL(
      TL({
        ...u,
        ...Me(a),
        activeSnapPoint: i,
        fadeFromIndex: o,
        open: s
      })
    );
    function v(m) {
      if (s.value !== void 0) {
        u.emitOpenChange(m);
        return;
      }
      p.value = m, m ? c.value = !0 : d();
    }
    return t({
      open: p
    }), (m, g) => (h(), x(l(bi), {
      open: l(p),
      modal: l(f),
      "onUpdate:open": v
    }, {
      default: y(() => [
        _(m.$slots, "default", { open: l(p) })
      ]),
      _: 3
    }, 8, ["open", "modal"]));
  }
}), IL = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  setup(e) {
    const { overlayRef: t, hasSnapPoints: n, isOpen: a, shouldFade: r } = tp();
    return (o, s) => (h(), x(l(gs), {
      ref_key: "overlayRef",
      ref: t,
      "data-vaul-overlay": "",
      "data-vaul-snap-points": l(a) && l(n) ? "true" : "false",
      "data-vaul-snap-points-overlay": l(a) && l(r) ? "true" : "false"
    }, null, 8, ["data-vaul-snap-points", "data-vaul-snap-points-overlay"]));
  }
}), OL = () => () => {
};
function RL() {
  const { direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: a, noBodyStyles: r } = tp(), o = I(null), s = I(document.body.style.backgroundColor);
  function i() {
    return (window.innerWidth - W_) / window.innerWidth;
  }
  Ie((u) => {
    if (t.value && n.value) {
      o.value && clearTimeout(o.value);
      const d = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!d)
        return;
      BL(
        a.value && !r.value ? ed(document.body, { background: "black" }) : OL,
        ed(d, {
          transformOrigin: _t(e.value) ? "top" : "left",
          transitionProperty: "transform, border-radius",
          transitionDuration: `${ft.DURATION}s`,
          transitionTimingFunction: `cubic-bezier(${ft.EASE.join(",")})`
        })
      );
      const c = ed(d, {
        borderRadius: `${j_}px`,
        overflow: "hidden",
        ..._t(e.value) ? {
          transform: `scale(${i()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${i()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      u(() => {
        c(), o.value = window.setTimeout(() => {
          s.value ? document.body.style.background = s.value : document.body.style.removeProperty("background");
        }, ft.DURATION * 1e3);
      });
    }
  }, { flush: "pre" });
}
const VL = /* @__PURE__ */ b({
  __name: "DrawerContent",
  setup(e) {
    const {
      open: t,
      isOpen: n,
      snapPointsOffset: a,
      hasSnapPoints: r,
      drawerRef: o,
      onPress: s,
      onDrag: i,
      onRelease: u,
      modal: d,
      emitOpenChange: c,
      dismissible: f,
      keyboardIsOpen: p,
      closeDrawer: v,
      direction: m,
      handleOnly: g
    } = tp();
    RL();
    const w = I(!1), C = E(() => a.value && a.value.length > 0 ? `${a.value[0]}px` : "0");
    function S(k) {
      if (!d.value || k.defaultPrevented) {
        k.preventDefault();
        return;
      }
      p.value && (p.value = !1), f.value ? c(!1) : k.preventDefault();
    }
    function $(k) {
      g.value || s(k);
    }
    function B(k) {
      g.value || i(k);
    }
    return Ie(() => {
      r.value && window.requestAnimationFrame(() => {
        w.value = !0;
      });
    }), (k, P) => (h(), x(l(hs), {
      ref_key: "drawerRef",
      ref: o,
      "data-vaul-drawer": "",
      "data-vaul-drawer-direction": l(m),
      "data-vaul-delayed-snap-points": w.value ? "true" : "false",
      "data-vaul-snap-points": l(n) && l(r) ? "true" : "false",
      style: dt({ "--snap-point-height": C.value }),
      onPointerdown: $,
      onPointermove: B,
      onPointerup: l(u),
      onPointerDownOutside: S,
      onOpenAutoFocus: P[0] || (P[0] = Ke(() => {
      }, ["prevent"])),
      onEscapeKeyDown: P[1] || (P[1] = (D) => {
        l(f) || D.preventDefault();
      })
    }, {
      default: y(() => [
        _(k.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-vaul-drawer-direction", "data-vaul-delayed-snap-points", "data-vaul-snap-points", "style", "onPointerup"]));
  }
}), d9 = /* @__PURE__ */ b({
  __name: "Drawer",
  props: {
    activeSnapPoint: {},
    closeThreshold: {},
    shouldScaleBackground: { type: Boolean, default: !0 },
    setBackgroundColorOnScale: { type: Boolean },
    scrollLockTimeout: {},
    fixed: { type: Boolean },
    dismissible: { type: Boolean },
    modal: { type: Boolean },
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    nested: { type: Boolean },
    direction: {},
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean },
    preventScrollRestoration: { type: Boolean },
    snapPoints: {},
    fadeFromIndex: {}
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(AL), A({ "data-slot": "drawer" }, l(r)), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), c9 = /* @__PURE__ */ b({
  __name: "DrawerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Va), A({ "data-slot": "drawer-close" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), FL = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(IL), A({ "data-slot": "drawer-overlay" }, l(n), {
      class: l(V)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), f9 = /* @__PURE__ */ b({
  __name: "DrawerContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = me(n, t);
    return (o, s) => (h(), x(l(xi), null, {
      default: y(() => [
        N(FL),
        N(l(VL), A({ "data-slot": "drawer-content" }, l(r), {
          class: l(V)(
            "group/drawer-content fixed z-50 flex h-auto flex-col bg-background",
            "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg",
            "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg",
            "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm",
            "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm",
            n.class
          )
        }), {
          default: y(() => [
            s[0] || (s[0] = xe("div", { class: "mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full bg-muted group-data-[vaul-drawer-direction=bottom]/drawer-content:block" }, null, -1)),
            _(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), p9 = /* @__PURE__ */ b({
  __name: "DrawerDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(wi), A({ "data-slot": "drawer-description" }, l(n), {
      class: l(V)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), v9 = /* @__PURE__ */ b({
  __name: "DrawerFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "drawer-footer",
      class: re(l(V)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), m9 = /* @__PURE__ */ b({
  __name: "DrawerHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "drawer-header",
      class: re(l(V)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), h9 = /* @__PURE__ */ b({
  __name: "DrawerTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Ci), A({ "data-slot": "drawer-title" }, l(n), {
      class: l(V)("font-semibold text-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), g9 = /* @__PURE__ */ b({
  __name: "DrawerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Si), A({ "data-slot": "drawer-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), y9 = /* @__PURE__ */ b({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(bD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), NL = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, b9 = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(hD), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        xe("span", NL, [
          N(l(Mg), null, {
            default: y(() => [
              N(l(oo), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _9 = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(MD), null, {
      default: y(() => [
        N(l(wD), A(l(o), {
          class: l(V)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), w9 = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(CD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), x9 = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l($D), A(l(a), {
      class: l(V)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), C9 = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(DD), A(l(a), {
      class: l(V)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), S9 = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(ED), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), LL = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, $9 = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(AD), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        xe("span", LL, [
          N(l(Mg), null, {
            default: y(() => [
              N(l(mf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), k9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(OD), A(l(n), {
      class: l(V)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), B9 = /* @__PURE__ */ b({
  __name: "DropdownMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: re(l(V)("ml-auto text-xs tracking-widest opacity-60", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), D9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(VD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), P9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(ND), A(l(o), {
      class: l(V)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), M9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(zD), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent data-[state=open]:bg-accent",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(za), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), q9 = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(UD), A({ class: "outline-none" }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), E9 = /* @__PURE__ */ b({
  __name: "Empty",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty",
      class: re(
        l(V)(
          "flex min-w-0 flex-1 flex-col items-center justify-center gap-6 rounded-lg border-dashed p-6 text-center text-balance md:p-12",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), T9 = /* @__PURE__ */ b({
  __name: "EmptyContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-content",
      class: re(
        l(V)(
          "flex w-full max-w-sm min-w-0 flex-col items-center gap-4 text-sm text-balance",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), A9 = /* @__PURE__ */ b({
  __name: "EmptyDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      "data-slot": "empty-description",
      class: re(
        l(V)(
          "text-sm/relaxed text-muted-foreground [&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), I9 = /* @__PURE__ */ b({
  __name: "EmptyHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-header",
      class: re(l(V)("flex max-w-sm flex-col items-center gap-2 text-center", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), zL = ["data-variant"], O9 = /* @__PURE__ */ b({
  __name: "EmptyMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-icon",
      "data-variant": e.variant,
      class: re(l(V)(l(HL)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, zL));
  }
}), R9 = /* @__PURE__ */ b({
  __name: "EmptyTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-title",
      class: re(l(V)("text-lg font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), HL = sn(
  "mb-2 flex shrink-0 items-center justify-center [&_svg]:pointer-events-none [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground [&_svg:not([class*='size-'])]:size-6"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), UL = ["data-orientation"], V9 = /* @__PURE__ */ b({
  __name: "Field",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      role: "group",
      "data-slot": "field",
      "data-orientation": e.orientation,
      class: re(l(V)(l(YL)({ orientation: e.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, UL));
  }
}), F9 = /* @__PURE__ */ b({
  __name: "FieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-content",
      class: re(l(V)("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), N9 = /* @__PURE__ */ b({
  __name: "FieldDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      "data-slot": "field-description",
      class: re(
        l(V)(
          "text-sm leading-normal font-normal text-muted-foreground group-has-[[data-orientation=horizontal]]/field:text-balance",
          "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), jL = {
  key: 2,
  class: "ml-4 flex list-disc flex-col gap-1"
}, L9 = /* @__PURE__ */ b({
  __name: "FieldError",
  props: {
    class: {},
    errors: {}
  },
  setup(e) {
    const t = e, n = E(() => !t.errors || t.errors.length === 0 ? null : t.errors.length === 1 && t.errors[0]?.message ? t.errors[0].message : t.errors.some((a) => a?.message) ? t.errors : null);
    return (a, r) => a.$slots.default || n.value ? (h(), G("div", {
      key: 0,
      role: "alert",
      "data-slot": "field-error",
      class: re(l(V)("text-sm font-normal text-destructive", t.class))
    }, [
      a.$slots.default ? _(a.$slots, "default", { key: 0 }) : typeof n.value == "string" ? (h(), G(Ye, { key: 1 }, [
        Re(He(n.value), 1)
      ], 64)) : Array.isArray(n.value) ? (h(), G("ul", jL, [
        (h(!0), G(Ye, null, Lt(n.value, (o, s) => (h(), G("li", { key: s }, He(o?.message), 1))), 128))
      ])) : Ee("", !0)
    ], 2)) : Ee("", !0);
  }
}), z9 = /* @__PURE__ */ b({
  __name: "FieldGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-group",
      class: re(
        l(V)(
          "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), G_ = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(rP), A(l(n), {
      class: l(V)(
        "text-sm leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), H9 = /* @__PURE__ */ b({
  __name: "FieldLabel",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(G_), {
      "data-slot": "field-label",
      class: re(
        l(V)(
          "group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50",
          "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&_>[data-slot=field]]:p-3",
          "has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-primary/5 dark:has-[[data-state=checked]]:bg-primary/10",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), WL = ["data-variant"], U9 = /* @__PURE__ */ b({
  __name: "FieldLegend",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("legend", {
      "data-slot": "field-legend",
      "data-variant": e.variant,
      class: re(
        l(V)(
          "mb-3 font-medium",
          "data-[variant=legend]:text-base",
          "data-[variant=label]:text-sm",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 10, WL));
  }
}), GL = ["data-content"], KL = {
  key: 0,
  class: "relative mx-auto block w-fit bg-background px-2 text-muted-foreground",
  "data-slot": "field-separator-content"
}, j9 = /* @__PURE__ */ b({
  __name: "FieldSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-separator",
      "data-content": !!n.$slots.default,
      class: re(
        l(V)("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", t.class)
      )
    }, [
      N(l(Gi), { class: "absolute inset-0 top-1/2" }),
      n.$slots.default ? (h(), G("span", KL, [
        _(n.$slots, "default")
      ])) : Ee("", !0)
    ], 10, GL));
  }
}), W9 = /* @__PURE__ */ b({
  __name: "FieldSet",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("fieldset", {
      "data-slot": "field-set",
      class: re(
        l(V)(
          "flex flex-col gap-6",
          "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), G9 = /* @__PURE__ */ b({
  __name: "FieldTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-label",
      class: re(
        l(V)(
          "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), YL = sn(
  "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
  {
    variants: {
      orientation: {
        vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
        horizontal: [
          "flex-row items-center",
          "[&>[data-slot=field-label]]:flex-auto",
          "has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px has-[>[data-slot=field-content]]:items-start"
        ],
        responsive: [
          "@md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto flex-col [&>*]:w-full [&>.sr-only]:w-auto",
          "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
          "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
        ]
      }
    },
    defaultVariants: {
      orientation: "vertical"
    }
  }
);
function Nt(e) {
  return typeof e == "function";
}
function Br(e) {
  return e == null;
}
const Oa = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function np(e) {
  return Number(e) >= 0;
}
function XL(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function JL(e) {
  return typeof e == "object" && e !== null;
}
function ZL(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function Rm(e) {
  if (!JL(e) || ZL(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function os(e, t) {
  return Object.keys(t).forEach((n) => {
    if (Rm(t[n]) && Rm(e[n])) {
      e[n] || (e[n] = {}), os(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function Po(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let a = 1; a < t.length; a++) {
    if (np(t[a])) {
      n += `[${t[a]}]`;
      continue;
    }
    n += `.${t[a]}`;
  }
  return n;
}
const QL = {};
function e8(e) {
  return QL[e];
}
function Vm(e, t, n) {
  typeof n.value == "object" && (n.value = je(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function je(e) {
  if (typeof e != "object") return e;
  var t = 0, n, a, r, o = Object.prototype.toString.call(e);
  if (o === "[object Object]" ? r = Object.create(e.__proto__ || null) : o === "[object Array]" ? r = Array(e.length) : o === "[object Set]" ? (r = /* @__PURE__ */ new Set(), e.forEach(function(s) {
    r.add(je(s));
  })) : o === "[object Map]" ? (r = /* @__PURE__ */ new Map(), e.forEach(function(s, i) {
    r.set(je(i), je(s));
  })) : o === "[object Date]" ? r = /* @__PURE__ */ new Date(+e) : o === "[object RegExp]" ? r = new RegExp(e.source, e.flags) : o === "[object DataView]" ? r = new e.constructor(je(e.buffer)) : o === "[object ArrayBuffer]" ? r = e.slice(0) : o.slice(-6) === "Array]" && (r = new e.constructor(e)), r) {
    for (a = Object.getOwnPropertySymbols(e); t < a.length; t++)
      Vm(r, a[t], Object.getOwnPropertyDescriptor(e, a[t]));
    for (t = 0, a = Object.getOwnPropertyNames(e); t < a.length; t++)
      Object.hasOwnProperty.call(r, n = a[t]) && r[n] === e[n] || Vm(r, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return r || e;
}
const Es = /* @__PURE__ */ Symbol("vee-validate-form"), t8 = /* @__PURE__ */ Symbol("vee-validate-form-context"), K_ = /* @__PURE__ */ Symbol("vee-validate-field-instance"), di = /* @__PURE__ */ Symbol("Default empty value"), Y_ = typeof window < "u";
function nc(e) {
  return Nt(e) && !!e.__locatorRef;
}
function Pn(e) {
  return !!e && Nt(e.parse) && e.__type === "VVTypedSchema";
}
function ci(e) {
  return !!e && Nt(e.validate);
}
function Ts(e) {
  return e === "checkbox" || e === "radio";
}
function n8(e) {
  return Oa(e) || Array.isArray(e);
}
function a8(e) {
  return Array.isArray(e) ? e.length === 0 : Oa(e) && Object.keys(e).length === 0;
}
function du(e) {
  return /^\[.+\]$/i.test(e);
}
function r8(e) {
  return X_(e) && e.multiple;
}
function X_(e) {
  return e.tagName === "SELECT";
}
function o8(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function s8(e, t) {
  return !o8(e, t) && t.type !== "file" && !Ts(t.type);
}
function J_(e) {
  return ap(e) && e.target && "submit" in e.target;
}
function ap(e) {
  return e ? !!(typeof Event < "u" && Nt(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function Fm(e, t) {
  return t in e && e[t] !== di;
}
function At(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, a, r;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (!At(e[a], t[a]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      for (a of e.entries())
        if (!At(a[1], t.get(a[0])))
          return !1;
      return !0;
    }
    if (Lm(e) && Lm(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (e[a] !== t[a])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (e = Nm(e), t = Nm(t), r = Object.keys(e), n = r.length, n !== Object.keys(t).length)
      return !1;
    for (a = n; a-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, r[a]))
        return !1;
    for (a = n; a-- !== 0; ) {
      var o = r[a];
      if (!At(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Nm(e) {
  return Object.fromEntries(Object.entries(e).filter(([, t]) => t !== void 0));
}
function Lm(e) {
  return Y_ ? e instanceof File : !1;
}
function rp(e) {
  return du(e) ? e.replace(/\[|\]/gi, "") : e;
}
function pt(e, t, n) {
  return e ? du(t) ? e[rp(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((r, o) => n8(r) && o in r ? r[o] : n, e) : n;
}
function Et(e, t, n) {
  if (du(t)) {
    e[rp(t)] = n;
    return;
  }
  const a = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let o = 0; o < a.length; o++) {
    if (o === a.length - 1) {
      r[a[o]] = n;
      return;
    }
    (!(a[o] in r) || Br(r[a[o]])) && (r[a[o]] = np(a[o + 1]) ? [] : {}), r = r[a[o]];
  }
}
function td(e, t) {
  if (Array.isArray(e) && np(t)) {
    e.splice(Number(t), 1);
    return;
  }
  Oa(e) && delete e[t];
}
function zm(e, t) {
  if (du(t)) {
    delete e[rp(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let a = e;
  for (let o = 0; o < n.length; o++) {
    if (o === n.length - 1) {
      td(a, n[o]);
      break;
    }
    if (!(n[o] in a) || Br(a[n[o]]))
      break;
    a = a[n[o]];
  }
  const r = n.map((o, s) => pt(e, n.slice(0, s).join(".")));
  for (let o = r.length - 1; o >= 0; o--)
    if (a8(r[o])) {
      if (o === 0) {
        td(e, n[0]);
        continue;
      }
      td(r[o - 1], n[o - 1]);
    }
}
function Zt(e) {
  return Object.keys(e);
}
function op(e, t = void 0) {
  const n = ht();
  return n?.provides[e] || Cn(e, t);
}
function nd(e) {
  ah(`[vee-validate]: ${e}`);
}
function Hm(e, t, n) {
  if (Array.isArray(e)) {
    const a = [...e], r = a.findIndex((o) => At(o, t));
    return r >= 0 ? a.splice(r, 1) : a.push(t), a;
  }
  return At(e, t) ? n : t;
}
function l8(e, t) {
  let n, a;
  return function(...r) {
    const o = this;
    return n || (n = !0, setTimeout(() => n = !1, t), a = e.apply(o, r)), a;
  };
}
function Um(e, t = 0) {
  let n = null, a = [];
  return function(...r) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const o = e(...r);
      a.forEach((s) => s(o)), a = [];
    }, t), new Promise((o) => a.push(o));
  };
}
function i8(e, t) {
  return Oa(t) && t.number ? XL(e) : e;
}
function ac(e, t) {
  let n;
  return async function(...r) {
    const o = e(...r);
    n = o;
    const s = await o;
    return o !== n ? s : (n = void 0, t(s, r));
  };
}
function u8({ get: e, set: t }) {
  const n = I(je(e()));
  return ve(e, (a) => {
    At(a, n.value) || (n.value = je(a));
  }, {
    deep: !0
  }), ve(n, (a) => {
    At(a, e()) || t(je(a));
  }, {
    deep: !0
  }), n;
}
function rc(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function rl(e, t) {
  const n = {};
  for (const a in e)
    t.includes(a) || (n[a] = e[a]);
  return n;
}
function d8(e) {
  let t = null, n = [];
  return function(...a) {
    const r = ke(() => {
      if (t !== r)
        return;
      const o = e(...a);
      n.forEach((s) => s(o)), n = [], t = null;
    });
    return t = r, new Promise((o) => n.push(o));
  };
}
function cu(e, t, n) {
  return t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
    default: () => {
      var a, r;
      return (r = (a = t.slots).default) === null || r === void 0 ? void 0 : r.call(a, n());
    }
  } : t.slots.default;
}
function ad(e) {
  if (Z_(e))
    return e._value;
}
function Z_(e) {
  return "_value" in e;
}
function c8(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function fi(e) {
  if (!ap(e))
    return e;
  const t = e.target;
  if (Ts(t.type) && Z_(t))
    return ad(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (r8(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(ad);
  if (X_(t)) {
    const n = Array.from(t.options).find((a) => a.selected);
    return n ? ad(n) : t.value;
  }
  return c8(t);
}
function Q_(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? Oa(e) && e._$$isNormalized ? e : Oa(e) ? Object.keys(e).reduce((n, a) => {
    const r = f8(e[a]);
    return e[a] !== !1 && (n[a] = jm(r)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, a) => {
    const r = p8(a);
    return r.name && (n[r.name] = jm(r.params)), n;
  }, t) : t;
}
function f8(e) {
  return e === !0 ? [] : Array.isArray(e) || Oa(e) ? e : [e];
}
function jm(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? v8(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, a) => (n[a] = t(e[a]), n), {});
}
const p8 = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function v8(e) {
  const t = (n) => {
    var a;
    return (a = pt(n, e)) !== null && a !== void 0 ? a : n[e];
  };
  return t.__locatorRef = e, t;
}
function m8(e) {
  return Array.isArray(e) ? e.filter(nc) : Zt(e).filter((t) => nc(e[t])).map((t) => e[t]);
}
const h8 = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let g8 = Object.assign({}, h8);
const Ja = () => g8;
async function e0(e, t, n = {}) {
  const a = n?.bails, r = {
    name: n?.name || "{field}",
    rules: t,
    label: n?.label,
    bails: a ?? !0,
    formData: n?.values || {}
  }, o = await y8(r, e);
  return Object.assign(Object.assign({}, o), { valid: !o.errors.length });
}
async function y8(e, t) {
  const n = e.rules;
  if (Pn(n) || ci(n))
    return _8(t, Object.assign(Object.assign({}, e), { rules: n }));
  if (Nt(n) || Array.isArray(n)) {
    const i = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, u = Array.isArray(n) ? n : [n], d = u.length, c = [];
    for (let f = 0; f < d; f++) {
      const p = u[f], v = await p(t, i);
      if (!(typeof v != "string" && !Array.isArray(v) && v)) {
        if (Array.isArray(v))
          c.push(...v);
        else {
          const g = typeof v == "string" ? v : n0(i);
          c.push(g);
        }
        if (e.bails)
          return {
            errors: c
          };
      }
    }
    return {
      errors: c
    };
  }
  const a = Object.assign(Object.assign({}, e), { rules: Q_(n) }), r = [], o = Object.keys(a.rules), s = o.length;
  for (let i = 0; i < s; i++) {
    const u = o[i], d = await w8(a, t, {
      name: u,
      params: a.rules[u]
    });
    if (d.error && (r.push(d.error), e.bails))
      return {
        errors: r
      };
  }
  return {
    errors: r
  };
}
function b8(e) {
  return !!e && e.name === "ValidationError";
}
function t0(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n, a) {
      var r;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1, context: a?.formData || {} }),
          errors: []
        };
      } catch (o) {
        if (!b8(o))
          throw o;
        if (!(!((r = o.inner) === null || r === void 0) && r.length) && o.errors.length)
          return { errors: [{ path: o.path, errors: o.errors }] };
        const s = o.inner.reduce((i, u) => {
          const d = u.path || "";
          return i[d] || (i[d] = { errors: [], path: d }), i[d].errors.push(...u.errors), i;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function _8(e, t) {
  const a = await (Pn(t.rules) ? t.rules : t0(t.rules)).parse(e, { formData: t.formData }), r = [];
  for (const o of a.errors)
    o.errors.length && r.push(...o.errors);
  return {
    value: a.value,
    errors: r
  };
}
async function w8(e, t, n) {
  const a = e8(n.name);
  if (!a)
    throw new Error(`No such validator '${n.name}' exists.`);
  const r = x8(n.params, e.formData), o = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: r })
  }, s = await a(t, r, o);
  return typeof s == "string" ? {
    error: s
  } : {
    error: s ? void 0 : n0(o)
  };
}
function n0(e) {
  const t = Ja().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function x8(e, t) {
  const n = (a) => nc(a) ? a(t) : a;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((a, r) => (a[r] = n(e[r]), a), {});
}
async function C8(e, t) {
  const a = await (Pn(e) ? e : t0(e)).parse(je(t), { formData: je(t) }), r = {}, o = {};
  for (const s of a.errors) {
    const i = s.errors, u = (s.path || "").replace(/\["(\d+)"\]/g, (d, c) => `[${c}]`);
    r[u] = { valid: !i.length, errors: i }, i.length && (o[u] = i[0]);
  }
  return {
    valid: !a.errors.length,
    results: r,
    errors: o,
    values: a.value,
    source: "schema"
  };
}
async function S8(e, t, n) {
  const r = Zt(e).map(async (d) => {
    var c, f, p;
    const v = (c = n?.names) === null || c === void 0 ? void 0 : c[d], m = await e0(pt(t, d), e[d], {
      name: v?.name || d,
      label: v?.label,
      values: t,
      bails: (p = (f = n?.bailsMap) === null || f === void 0 ? void 0 : f[d]) !== null && p !== void 0 ? p : !0
    });
    return Object.assign(Object.assign({}, m), { path: d });
  });
  let o = !0;
  const s = await Promise.all(r), i = {}, u = {};
  for (const d of s)
    i[d.path] = {
      valid: d.valid,
      errors: d.errors
    }, d.valid || (o = !1, u[d.path] = d.errors[0]);
  return {
    valid: o,
    results: i,
    errors: u,
    source: "schema"
  };
}
let Wm = 0;
function $8(e, t) {
  const { value: n, initialValue: a, setInitialValue: r } = k8(e, t.modelValue, t.form);
  if (!t.form) {
    let p = function(v) {
      var m;
      "value" in v && (n.value = v.value), "errors" in v && d(v.errors), "touched" in v && (f.touched = (m = v.touched) !== null && m !== void 0 ? m : f.touched), "initialValue" in v && r(v.initialValue);
    };
    const { errors: u, setErrors: d } = P8(), c = Wm >= Number.MAX_SAFE_INTEGER ? 0 : ++Wm, f = D8(n, a, u, t.schema);
    return {
      id: c,
      path: e,
      value: n,
      initialValue: a,
      meta: f,
      flags: { pendingUnmount: { [c]: !1 }, pendingReset: !1 },
      errors: u,
      setState: p
    };
  }
  const o = t.form.createPathState(e, {
    bails: t.bails,
    label: t.label,
    type: t.type,
    validate: t.validate,
    schema: t.schema
  }), s = E(() => o.errors);
  function i(u) {
    var d, c, f;
    "value" in u && (n.value = u.value), "errors" in u && ((d = t.form) === null || d === void 0 || d.setFieldError(l(e), u.errors)), "touched" in u && ((c = t.form) === null || c === void 0 || c.setFieldTouched(l(e), (f = u.touched) !== null && f !== void 0 ? f : !1)), "initialValue" in u && r(u.initialValue);
  }
  return {
    id: Array.isArray(o.id) ? o.id[o.id.length - 1] : o.id,
    path: e,
    value: n,
    errors: s,
    meta: o,
    initialValue: a,
    flags: o.__flags,
    setState: i
  };
}
function k8(e, t, n) {
  const a = I(l(t));
  function r() {
    return n ? pt(n.initialValues.value, l(e), l(a)) : l(a);
  }
  function o(d) {
    if (!n) {
      a.value = d;
      return;
    }
    n.setFieldInitialValue(l(e), d, !0);
  }
  const s = E(r);
  if (!n)
    return {
      value: I(r()),
      initialValue: s,
      setInitialValue: o
    };
  const i = B8(t, n, s, e);
  return n.stageInitialValue(l(e), i, !0), {
    value: E({
      get() {
        return pt(n.values, l(e));
      },
      set(d) {
        n.setFieldValue(l(e), d, !1);
      }
    }),
    initialValue: s,
    setInitialValue: o
  };
}
function B8(e, t, n, a) {
  return mt(e) ? l(e) : e !== void 0 ? e : pt(t.values, l(a), l(n));
}
function D8(e, t, n, a) {
  const r = E(() => {
    var s, i, u;
    return (u = (i = (s = fe(a)) === null || s === void 0 ? void 0 : s.describe) === null || i === void 0 ? void 0 : i.call(s).required) !== null && u !== void 0 ? u : !1;
  }), o = Wt({
    touched: !1,
    pending: !1,
    valid: !0,
    required: r,
    validated: !!l(n).length,
    initialValue: E(() => l(t)),
    dirty: E(() => !At(l(e), l(t)))
  });
  return ve(n, (s) => {
    o.valid = !s.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), o;
}
function P8() {
  const e = I([]);
  return {
    errors: e,
    setErrors: (t) => {
      e.value = rc(t);
    }
  };
}
const Ro = {}, Vo = {}, Fo = "vee-validate-inspector", Qt = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let bt = null, ra;
async function a0(e) {
  if (process.env.NODE_ENV !== "production") {
    if (!Y_)
      return;
    (await import("./index-DyCHxFp3.js")).setupDevtoolsPlugin({
      id: "vee-validate-devtools-plugin",
      label: "VeeValidate Plugin",
      packageName: "vee-validate",
      homepage: "https://vee-validate.logaretm.com/v4",
      app: e,
      logo: "https://vee-validate.logaretm.com/v4/logo.png"
    }, (n) => {
      ra = n, n.addInspector({
        id: Fo,
        icon: "rule",
        label: "vee-validate",
        noSelectionText: "Select a vee-validate node to inspect",
        actions: [
          {
            icon: "done_outline",
            tooltip: "Validate selected item",
            action: async () => {
              if (!bt) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (bt.type === "field") {
                await bt.field.validate();
                return;
              }
              if (bt.type === "form") {
                await bt.form.validate();
                return;
              }
              bt.type === "pathState" && await bt.form.validateField(bt.state.path);
            }
          },
          {
            icon: "delete_sweep",
            tooltip: "Clear validation state of the selected item",
            action: () => {
              if (!bt) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (bt.type === "field") {
                bt.field.resetField();
                return;
              }
              bt.type === "form" && bt.form.resetForm(), bt.type === "pathState" && bt.form.resetField(bt.state.path);
            }
          }
        ]
      }), n.on.getInspectorTree((a) => {
        if (a.inspectorId !== Fo)
          return;
        const r = Object.values(Ro), o = Object.values(Vo);
        a.rootNodes = [
          ...r.map(E8),
          ...o.map((s) => A8(s))
        ];
      }), n.on.getInspectorState((a) => {
        if (a.inspectorId !== Fo)
          return;
        const { form: r, field: o, state: s, type: i } = I8(a.nodeId);
        if (n.unhighlightElement(), r && i === "form") {
          a.state = O8(r), bt = { type: "form", form: r }, n.highlightElement(r._vm);
          return;
        }
        if (s && i === "pathState" && r) {
          a.state = Gm(s), bt = { type: "pathState", state: s, form: r };
          return;
        }
        if (o && i === "field") {
          a.state = Gm({
            errors: o.errors.value,
            dirty: o.meta.dirty,
            valid: o.meta.valid,
            touched: o.meta.touched,
            value: o.value.value,
            initialValue: o.meta.initialValue
          }), bt = { field: o, type: "field" }, n.highlightElement(o._vm);
          return;
        }
        bt = null, n.unhighlightElement();
      });
    });
  }
}
const Kr = l8(() => {
  setTimeout(async () => {
    await ke(), ra?.sendInspectorState(Fo), ra?.sendInspectorTree(Fo);
  }, 100);
}, 100);
function M8(e) {
  const t = ht();
  if (!ra) {
    const n = t?.appContext.app;
    if (!n)
      return;
    a0(n);
  }
  Ro[e.formId] = Object.assign({}, e), Ro[e.formId]._vm = t, Qe(() => {
    delete Ro[e.formId], Kr();
  }), Kr();
}
function q8(e) {
  const t = ht();
  if (!ra) {
    const n = t?.appContext.app;
    if (!n)
      return;
    a0(n);
  }
  Vo[e.id] = Object.assign({}, e), Vo[e.id]._vm = t, Qe(() => {
    delete Vo[e.id], Kr();
  }), Kr();
}
function E8(e) {
  const { textColor: t, bgColor: n } = o0(e.meta.value.valid), a = {};
  Object.values(e.getAllPathStates()).forEach((s) => {
    Et(a, fe(s.path), T8(s, e));
  });
  function r(s, i = []) {
    const u = [...i].pop();
    return "id" in s ? Object.assign(Object.assign({}, s), { label: u || s.label }) : Oa(s) ? {
      id: `${i.join(".")}`,
      label: u || "",
      children: Object.keys(s).map((d) => r(s[d], [...i, d]))
    } : Array.isArray(s) ? {
      id: `${i.join(".")}`,
      label: `${u}[]`,
      children: s.map((d, c) => r(d, [...i, String(c)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: o } = r(a);
  return {
    id: sp(e),
    label: e.name,
    children: o,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${e.getAllPathStates().length} fields`,
        textColor: Qt.white,
        backgroundColor: Qt.unknown
      }
    ]
  };
}
function T8(e, t) {
  return {
    id: sp(t, e),
    label: fe(e.path),
    tags: r0(e.multiple, e.fieldsCount, e.type, e.valid, t)
  };
}
function A8(e, t) {
  return {
    id: sp(t, e),
    label: l(e.name),
    tags: r0(!1, 1, e.type, e.meta.valid, t)
  };
}
function r0(e, t, n, a, r) {
  const { textColor: o, bgColor: s } = o0(a);
  return [
    e ? void 0 : {
      label: "Field",
      textColor: o,
      backgroundColor: s
    },
    r ? void 0 : {
      label: "Standalone",
      textColor: Qt.black,
      backgroundColor: Qt.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: Qt.white,
      backgroundColor: Qt.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: Qt.white,
      backgroundColor: Qt.purple
    } : void 0,
    e ? {
      label: "Multiple",
      textColor: Qt.black,
      backgroundColor: Qt.orange
    } : void 0
  ].filter(Boolean);
}
function sp(e, t) {
  const n = t ? "path" in t ? "pathState" : "field" : "form", a = t ? "path" in t ? t?.path : fe(t?.name) : "", r = { f: e?.formId, ff: t?.id || a, type: n };
  return btoa(encodeURIComponent(JSON.stringify(r)));
}
function I8(e) {
  try {
    const t = JSON.parse(decodeURIComponent(atob(e))), n = Ro[t.f];
    if (!n && t.ff) {
      const r = Vo[t.ff];
      return r ? {
        type: t.type,
        field: r
      } : {};
    }
    if (!n)
      return {};
    const a = n.getPathState(t.ff);
    return {
      type: t.type,
      form: n,
      state: a
    };
  } catch {
  }
  return {};
}
function Gm(e) {
  return {
    "Field state": [
      { key: "errors", value: e.errors },
      {
        key: "initialValue",
        value: e.initialValue
      },
      {
        key: "currentValue",
        value: e.value
      },
      {
        key: "touched",
        value: e.touched
      },
      {
        key: "dirty",
        value: e.dirty
      },
      {
        key: "valid",
        value: e.valid
      }
    ]
  };
}
function O8(e) {
  const { errorBag: t, meta: n, values: a, isSubmitting: r, isValidating: o, submitCount: s } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: s.value
      },
      {
        key: "isSubmitting",
        value: r.value
      },
      {
        key: "isValidating",
        value: o.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: a
      },
      {
        key: "errors",
        value: Zt(t.value).reduce((i, u) => {
          var d;
          const c = (d = t.value[u]) === null || d === void 0 ? void 0 : d[0];
          return c && (i[u] = c), i;
        }, {})
      }
    ]
  };
}
function o0(e) {
  return {
    bgColor: e ? Qt.success : Qt.error,
    textColor: e ? Qt.black : Qt.white
  };
}
function R8(e, t, n) {
  return Ts(n?.type) ? F8(e, t, n) : s0(e, t, n);
}
function s0(e, t, n) {
  const { initialValue: a, validateOnMount: r, bails: o, type: s, checkedValue: i, label: u, validateOnValueUpdate: d, uncheckedValue: c, controlled: f, keepValueOnUnmount: p, syncVModel: v, form: m } = V8(n), g = f ? op(Es) : void 0, w = m || g, C = E(() => Po(fe(e))), S = E(() => {
    if (fe(w?.schema))
      return;
    const R = l(t);
    return ci(R) || Pn(R) || Nt(R) || Array.isArray(R) ? R : Q_(R);
  }), $ = !Nt(S.value) && Pn(fe(t)), { id: B, value: k, initialValue: P, meta: D, setState: q, errors: T, flags: M } = $8(C, {
    modelValue: a,
    form: w,
    bails: o,
    label: u,
    type: s,
    validate: S.value ? W : void 0,
    schema: $ ? t : void 0
  }), O = E(() => T.value[0]);
  v && N8({
    value: k,
    prop: v,
    handleChange: H,
    shouldValidate: () => d && !M.pendingReset
  });
  const F = (ce, R = !1) => {
    D.touched = !0, R && ne();
  };
  async function J(ce) {
    var R, te;
    if (w?.validateSchema) {
      const { results: z } = await w.validateSchema(ce);
      return (R = z[fe(C)]) !== null && R !== void 0 ? R : { valid: !0, errors: [] };
    }
    return S.value ? e0(k.value, S.value, {
      name: fe(C),
      label: fe(u),
      values: (te = w?.values) !== null && te !== void 0 ? te : {},
      bails: o
    }) : { valid: !0, errors: [] };
  }
  const ne = ac(async () => (D.pending = !0, D.validated = !0, J("validated-only")), (ce) => (M.pendingUnmount[ge.id] || (q({ errors: ce.errors }), D.pending = !1, D.valid = ce.valid), ce)), Q = ac(async () => J("silent"), (ce) => (D.valid = ce.valid, ce));
  function W(ce) {
    return ce?.mode === "silent" ? Q() : ne();
  }
  function H(ce, R = !0) {
    const te = fi(ce);
    de(te, R);
  }
  Ce(() => {
    if (r)
      return ne();
    (!w || !w.validateSchema) && Q();
  });
  function U(ce) {
    D.touched = ce;
  }
  function se(ce) {
    var R;
    const te = ce && "value" in ce ? ce.value : P.value;
    q({
      value: je(te),
      initialValue: je(te),
      touched: (R = ce?.touched) !== null && R !== void 0 ? R : !1,
      errors: ce?.errors || []
    }), D.pending = !1, D.validated = !1, Q();
  }
  const ee = ht();
  function de(ce, R = !0) {
    k.value = ee && v ? i8(ce, ee.props.modelModifiers) : ce, (R ? ne : Q)();
  }
  function pe(ce) {
    q({ errors: Array.isArray(ce) ? ce : [ce] });
  }
  const _e = E({
    get() {
      return k.value;
    },
    set(ce) {
      de(ce, d);
    }
  }), ge = {
    id: B,
    name: C,
    label: u,
    value: _e,
    meta: D,
    errors: T,
    errorMessage: O,
    type: s,
    checkedValue: i,
    uncheckedValue: c,
    bails: o,
    keepValueOnUnmount: p,
    resetField: se,
    handleReset: () => se(),
    validate: W,
    handleChange: H,
    handleBlur: F,
    setState: q,
    setTouched: U,
    setErrors: pe,
    setValue: de
  };
  if (Xn(K_, ge), mt(t) && typeof l(t) != "function" && ve(t, (ce, R) => {
    At(ce, R) || (D.validated ? ne() : Q());
  }, {
    deep: !0
  }), process.env.NODE_ENV !== "production" && (ge._vm = ht(), ve(() => Object.assign(Object.assign({ errors: T.value }, D), { value: k.value }), Kr, {
    deep: !0
  }), w || q8(ge)), !w)
    return ge;
  const Te = E(() => {
    const ce = S.value;
    return !ce || Nt(ce) || ci(ce) || Pn(ce) || Array.isArray(ce) ? {} : Object.keys(ce).reduce((R, te) => {
      const z = m8(ce[te]).map((ae) => ae.__locatorRef).reduce((ae, ie) => {
        const L = pt(w.values, ie) || w.values[ie];
        return L !== void 0 && (ae[ie] = L), ae;
      }, {});
      return Object.assign(R, z), R;
    }, {});
  });
  return ve(Te, (ce, R) => {
    if (!Object.keys(ce).length)
      return;
    !At(ce, R) && (D.validated ? ne() : Q());
  }), sr(() => {
    var ce;
    const R = (ce = fe(ge.keepValueOnUnmount)) !== null && ce !== void 0 ? ce : fe(w.keepValuesOnUnmount), te = fe(C);
    if (R || !w || M.pendingUnmount[ge.id]) {
      w?.removePathState(te, B);
      return;
    }
    M.pendingUnmount[ge.id] = !0;
    const z = w.getPathState(te);
    if (Array.isArray(z?.id) && z?.multiple ? z?.id.includes(ge.id) : z?.id === ge.id) {
      if (z?.multiple && Array.isArray(z.value)) {
        const ie = z.value.findIndex((L) => At(L, fe(ge.checkedValue)));
        if (ie > -1) {
          const L = [...z.value];
          L.splice(ie, 1), w.setFieldValue(te, L);
        }
        Array.isArray(z.id) && z.id.splice(z.id.indexOf(ge.id), 1);
      } else
        w.unsetPathValue(fe(C));
      w.removePathState(te, B);
    }
  }), ge;
}
function V8(e) {
  const t = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    label: void 0,
    validateOnValueUpdate: !0,
    keepValueOnUnmount: void 0,
    syncVModel: !1,
    controlled: !0
  }), n = !!e?.syncVModel, a = typeof e?.syncVModel == "string" ? e.syncVModel : e?.modelPropName || "modelValue", r = n && !("initialValue" in (e || {})) ? oc(ht(), a) : e?.initialValue;
  if (!e)
    return Object.assign(Object.assign({}, t()), { initialValue: r });
  const o = "valueProp" in e ? e.valueProp : e.checkedValue, s = "standalone" in e ? !e.standalone : e.controlled, i = e?.modelPropName || e?.syncVModel || !1;
  return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
    initialValue: r,
    controlled: s ?? !0,
    checkedValue: o,
    syncVModel: i
  });
}
function F8(e, t, n) {
  const a = n?.standalone ? void 0 : op(Es), r = n?.checkedValue, o = n?.uncheckedValue;
  function s(i) {
    const u = i.handleChange, d = E(() => {
      const f = fe(i.value), p = fe(r);
      return Array.isArray(f) ? f.findIndex((v) => At(v, p)) >= 0 : At(p, f);
    });
    function c(f, p = !0) {
      var v, m;
      if (d.value === ((v = f?.target) === null || v === void 0 ? void 0 : v.checked)) {
        p && i.validate();
        return;
      }
      const g = fe(e), w = a?.getPathState(g), C = fi(f);
      let S = (m = fe(r)) !== null && m !== void 0 ? m : C;
      a && w?.multiple && w.type === "checkbox" ? S = Hm(pt(a.values, g) || [], S, void 0) : n?.type === "checkbox" && (S = Hm(fe(i.value), S, fe(o))), u(S, p);
    }
    return Object.assign(Object.assign({}, i), {
      checked: d,
      checkedValue: r,
      uncheckedValue: o,
      handleChange: c
    });
  }
  return s(s0(e, t, n));
}
function N8({ prop: e, value: t, handleChange: n, shouldValidate: a }) {
  const r = ht();
  if (!r || !e) {
    process.env.NODE_ENV !== "production" && console.warn("Failed to setup model events because `useField` was not called in setup.");
    return;
  }
  const o = typeof e == "string" ? e : "modelValue", s = `update:${o}`;
  o in r.props && (ve(t, (i) => {
    At(i, oc(r, o)) || r.emit(s, i);
  }), ve(() => oc(r, o), (i) => {
    if (i === di && t.value === void 0)
      return;
    const u = i === di ? void 0 : i;
    At(u, t.value) || n(u, a());
  }));
}
function oc(e, t) {
  if (e)
    return e.props[t];
}
const L8 = /* @__PURE__ */ b({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => Ja().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: di
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = jn(e, "rules"), a = jn(e, "name"), r = jn(e, "label"), o = jn(e, "uncheckedValue"), s = jn(e, "keepValue"), { errors: i, value: u, errorMessage: d, validate: c, handleChange: f, handleBlur: p, setTouched: v, resetField: m, handleReset: g, meta: w, checked: C, setErrors: S, setValue: $ } = R8(a, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: H8(e, t),
      // Only for checkboxes and radio buttons
      checkedValue: t.attrs.value,
      uncheckedValue: o,
      label: r,
      validateOnValueUpdate: e.validateOnModelUpdate,
      keepValueOnUnmount: s,
      syncVModel: !0
    }), B = function(M, O = !0) {
      f(M, O);
    }, k = E(() => {
      const { validateOnInput: T, validateOnChange: M, validateOnBlur: O, validateOnModelUpdate: F } = z8(e);
      function J(H) {
        p(H, O), Nt(t.attrs.onBlur) && t.attrs.onBlur(H);
      }
      function ne(H) {
        B(H, T), Nt(t.attrs.onInput) && t.attrs.onInput(H);
      }
      function Q(H) {
        B(H, M), Nt(t.attrs.onChange) && t.attrs.onChange(H);
      }
      const W = {
        name: e.name,
        onBlur: J,
        onInput: ne,
        onChange: Q
      };
      return W["onUpdate:modelValue"] = (H) => B(H, F), W;
    }), P = E(() => {
      const T = Object.assign({}, k.value);
      Ts(t.attrs.type) && C && (T.checked = C.value);
      const M = Km(e, t);
      return s8(M, t.attrs) && (T.value = u.value), T;
    }), D = E(() => Object.assign(Object.assign({}, k.value), { modelValue: u.value }));
    function q() {
      return {
        field: P.value,
        componentField: D.value,
        value: u.value,
        meta: w,
        errors: i.value,
        errorMessage: d.value,
        validate: c,
        resetField: m,
        handleChange: B,
        handleInput: (T) => B(T, !1),
        handleReset: g,
        handleBlur: k.value.onBlur,
        setTouched: v,
        setErrors: S,
        setValue: $
      };
    }
    return t.expose({
      value: u,
      meta: w,
      errors: i,
      errorMessage: d,
      setErrors: S,
      setTouched: v,
      setValue: $,
      reset: m,
      validate: c,
      handleChange: f
    }), () => {
      const T = Tt(Km(e, t)), M = cu(T, t, q);
      return T ? an(T, Object.assign(Object.assign({}, t.attrs), P.value), M) : M;
    };
  }
});
function Km(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function z8(e) {
  var t, n, a, r;
  const { validateOnInput: o, validateOnChange: s, validateOnBlur: i, validateOnModelUpdate: u } = Ja();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : o,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : s,
    validateOnBlur: (a = e.validateOnBlur) !== null && a !== void 0 ? a : i,
    validateOnModelUpdate: (r = e.validateOnModelUpdate) !== null && r !== void 0 ? r : u
  };
}
function H8(e, t) {
  return Ts(t.attrs.type) ? Fm(e, "modelValue") ? e.modelValue : void 0 : Fm(e, "modelValue") ? e.modelValue : t.attrs.value;
}
const K9 = L8;
let U8 = 0;
const ol = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function l0(e) {
  const t = e?.initialValues || {}, n = Object.assign({}, fe(t)), a = l(e?.validationSchema);
  return a && Pn(a) && Nt(a.cast) ? je(a.cast(n) || {}) : je(n);
}
function j8(e) {
  var t;
  const n = U8++, a = e?.name || "Form";
  let r = 0;
  const o = I(!1), s = I(!1), i = I(0), u = [], d = Wt(l0(e)), c = I([]), f = I({}), p = I({}), v = d8(() => {
    p.value = c.value.reduce((K, Y) => (K[Po(fe(Y.path))] = Y, K), {});
  });
  function m(K, Y) {
    const ue = H(K);
    if (!ue) {
      typeof K == "string" && (f.value[Po(K)] = rc(Y));
      return;
    }
    if (typeof K == "string") {
      const ye = Po(K);
      f.value[ye] && delete f.value[ye];
    }
    ue.errors = rc(Y), ue.valid = !ue.errors.length;
  }
  function g(K) {
    Zt(K).forEach((Y) => {
      m(Y, K[Y]);
    });
  }
  e?.initialErrors && g(e.initialErrors);
  const w = E(() => {
    const K = c.value.reduce((Y, ue) => (ue.errors.length && (Y[fe(ue.path)] = ue.errors), Y), {});
    return Object.assign(Object.assign({}, f.value), K);
  }), C = E(() => Zt(w.value).reduce((K, Y) => {
    const ue = w.value[Y];
    return ue?.length && (K[Y] = ue[0]), K;
  }, {})), S = E(() => c.value.reduce((K, Y) => (K[fe(Y.path)] = { name: fe(Y.path) || "", label: Y.label || "" }, K), {})), $ = E(() => c.value.reduce((K, Y) => {
    var ue;
    return K[fe(Y.path)] = (ue = Y.bails) !== null && ue !== void 0 ? ue : !0, K;
  }, {})), B = Object.assign({}, e?.initialErrors || {}), k = (t = e?.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: P, originalInitialValues: D, setInitialValues: q } = G8(c, d, e), T = W8(c, d, D, C), M = E(() => c.value.reduce((K, Y) => {
    const ue = pt(d, fe(Y.path));
    return Et(K, fe(Y.path), ue), K;
  }, {})), O = e?.validationSchema;
  function F(K, Y) {
    var ue, ye;
    const Pe = E(() => pt(P.value, fe(K))), Ae = p.value[fe(K)], qe = Y?.type === "checkbox" || Y?.type === "radio";
    if (Ae && qe) {
      Ae.multiple = !0;
      const Xt = r++;
      return Array.isArray(Ae.id) ? Ae.id.push(Xt) : Ae.id = [Ae.id, Xt], Ae.fieldsCount++, Ae.__flags.pendingUnmount[Xt] = !1, Ae;
    }
    const rt = E(() => pt(d, fe(K))), ct = fe(K), Mt = se.findIndex((Xt) => Xt === ct);
    Mt !== -1 && se.splice(Mt, 1);
    const at = E(() => {
      var Xt, ba, yr, uo;
      const vu = fe(O);
      if (Pn(vu))
        return (ba = (Xt = vu.describe) === null || Xt === void 0 ? void 0 : Xt.call(vu, fe(K)).required) !== null && ba !== void 0 ? ba : !1;
      const mu = fe(Y?.schema);
      return Pn(mu) && (uo = (yr = mu.describe) === null || yr === void 0 ? void 0 : yr.call(mu).required) !== null && uo !== void 0 ? uo : !1;
    }), kt = r++, Vt = Wt({
      id: kt,
      path: K,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((ue = B[ct]) === null || ue === void 0) && ue.length),
      required: at,
      initialValue: Pe,
      errors: gt([]),
      bails: (ye = Y?.bails) !== null && ye !== void 0 ? ye : !1,
      label: Y?.label,
      type: Y?.type || "default",
      value: rt,
      multiple: !1,
      __flags: {
        pendingUnmount: { [kt]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: Y?.validate,
      dirty: E(() => !At(l(rt), l(Pe)))
    });
    return c.value.push(Vt), p.value[ct] = Vt, v(), C.value[ct] && !B[ct] && ke(() => {
      Ue(ct, { mode: "silent" });
    }), mt(K) && ve(K, (Xt) => {
      v();
      const ba = je(rt.value);
      p.value[Xt] = Vt, ke(() => {
        Et(d, Xt, ba);
      });
    }), Vt;
  }
  const J = Um($t, 5), ne = Um($t, 5), Q = ac(async (K) => await (K === "silent" ? J() : ne()), (K, [Y]) => {
    const ue = Zt(R.errorBag.value), Pe = [
      .../* @__PURE__ */ new Set([...Zt(K.results), ...c.value.map((Ae) => Ae.path), ...ue])
    ].sort().reduce((Ae, qe) => {
      var rt;
      const ct = qe, Mt = H(ct) || U(ct), at = ((rt = K.results[ct]) === null || rt === void 0 ? void 0 : rt.errors) || [], kt = fe(Mt?.path) || ct, Vt = K8({ errors: at, valid: !at.length }, Ae.results[kt]);
      return Ae.results[kt] = Vt, Vt.valid || (Ae.errors[kt] = Vt.errors[0]), Mt && f.value[kt] && delete f.value[kt], Mt ? (Mt.valid = Vt.valid, Y === "silent" || Y === "validated-only" && !Mt.validated || m(Mt, Vt.errors), Ae) : (m(kt, at), Ae);
    }, {
      valid: K.valid,
      results: {},
      errors: {},
      source: K.source
    });
    return K.values && (Pe.values = K.values, Pe.source = K.source), Zt(Pe.results).forEach((Ae) => {
      var qe;
      const rt = H(Ae);
      rt && Y !== "silent" && (Y === "validated-only" && !rt.validated || m(rt, (qe = Pe.results[Ae]) === null || qe === void 0 ? void 0 : qe.errors));
    }), Pe;
  });
  function W(K) {
    c.value.forEach(K);
  }
  function H(K) {
    const Y = typeof K == "string" ? Po(K) : K;
    return typeof Y == "string" ? p.value[Y] : Y;
  }
  function U(K) {
    return c.value.filter((ue) => K.startsWith(fe(ue.path))).reduce((ue, ye) => ue ? ye.path.length > ue.path.length ? ye : ue : ye, void 0);
  }
  let se = [], ee;
  function de(K) {
    return se.push(K), ee || (ee = ke(() => {
      [...se].sort().reverse().forEach((ue) => {
        zm(d, ue);
      }), se = [], ee = null;
    })), ee;
  }
  function pe(K) {
    return function(ue, ye) {
      return function(Ae) {
        return Ae instanceof Event && (Ae.preventDefault(), Ae.stopPropagation()), W((qe) => qe.touched = !0), o.value = !0, i.value++, Ne().then((qe) => {
          const rt = je(d);
          if (qe.valid && typeof ue == "function") {
            const ct = je(M.value);
            let Mt = K ? ct : rt;
            return qe.values && (Mt = qe.source === "schema" ? qe.values : Object.assign({}, Mt, qe.values)), ue(Mt, {
              evt: Ae,
              controlledValues: ct,
              setErrors: g,
              setFieldError: m,
              setTouched: Xe,
              setFieldTouched: L,
              setValues: ae,
              setFieldValue: te,
              resetForm: De,
              resetField: lt
            });
          }
          !qe.valid && typeof ye == "function" && ye({
            values: rt,
            evt: Ae,
            errors: qe.errors,
            results: qe.results
          });
        }).then((qe) => (o.value = !1, qe), (qe) => {
          throw o.value = !1, qe;
        });
      };
    };
  }
  const ge = pe(!1);
  ge.withControlled = pe(!0);
  function Te(K, Y) {
    const ue = c.value.findIndex((Pe) => Pe.path === K && (Array.isArray(Pe.id) ? Pe.id.includes(Y) : Pe.id === Y)), ye = c.value[ue];
    if (!(ue === -1 || !ye)) {
      if (ke(() => {
        Ue(K, { mode: "silent", warn: !1 });
      }), ye.multiple && ye.fieldsCount && ye.fieldsCount--, Array.isArray(ye.id)) {
        const Pe = ye.id.indexOf(Y);
        Pe >= 0 && ye.id.splice(Pe, 1), delete ye.__flags.pendingUnmount[Y];
      }
      (!ye.multiple || ye.fieldsCount <= 0) && (c.value.splice(ue, 1), We(K), v(), delete p.value[K]);
    }
  }
  function ce(K) {
    Zt(p.value).forEach((Y) => {
      Y.startsWith(K) && delete p.value[Y];
    }), c.value = c.value.filter((Y) => !Y.path.startsWith(K)), ke(() => {
      v();
    });
  }
  const R = {
    name: a,
    formId: n,
    values: d,
    controlledValues: M,
    errorBag: w,
    errors: C,
    schema: O,
    submitCount: i,
    meta: T,
    isSubmitting: o,
    isValidating: s,
    fieldArrays: u,
    keepValuesOnUnmount: k,
    validateSchema: l(O) ? Q : void 0,
    validate: Ne,
    setFieldError: m,
    validateField: Ue,
    setFieldValue: te,
    setValues: ae,
    setErrors: g,
    setFieldTouched: L,
    setTouched: Xe,
    resetForm: De,
    resetField: lt,
    handleSubmit: ge,
    useFieldModel: Oe,
    defineInputBinds: Pt,
    defineComponentBinds: jt,
    defineField: gn,
    stageInitialValue: it,
    unsetInitialValue: We,
    setFieldInitialValue: ut,
    createPathState: F,
    getPathState: H,
    unsetPathValue: de,
    removePathState: Te,
    initialValues: P,
    getAllPathStates: () => c.value,
    destroyPath: ce,
    isFieldTouched: be,
    isFieldDirty: we,
    isFieldValid: Fe
  };
  function te(K, Y, ue = !0) {
    const ye = je(Y), Pe = typeof K == "string" ? K : K.path;
    H(Pe) || F(Pe), Et(d, Pe, ye), ue && Ue(Pe);
  }
  function z(K, Y = !0) {
    Zt(d).forEach((ue) => {
      delete d[ue];
    }), Zt(K).forEach((ue) => {
      te(ue, K[ue], !1);
    }), Y && Ne();
  }
  function ae(K, Y = !0) {
    os(d, K), u.forEach((ue) => ue && ue.reset()), Y && Ne();
  }
  function ie(K, Y) {
    const ue = H(fe(K)) || F(K);
    return E({
      get() {
        return ue.value;
      },
      set(ye) {
        var Pe;
        const Ae = fe(K);
        te(Ae, ye, (Pe = fe(Y)) !== null && Pe !== void 0 ? Pe : !1);
      }
    });
  }
  function L(K, Y) {
    const ue = H(K);
    ue && (ue.touched = Y);
  }
  function be(K) {
    const Y = H(K);
    return Y ? Y.touched : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.touched);
  }
  function we(K) {
    const Y = H(K);
    return Y ? Y.dirty : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.dirty);
  }
  function Fe(K) {
    const Y = H(K);
    return Y ? Y.valid : c.value.filter((ue) => ue.path.startsWith(K)).every((ue) => ue.valid);
  }
  function Xe(K) {
    if (typeof K == "boolean") {
      W((Y) => {
        Y.touched = K;
      });
      return;
    }
    Zt(K).forEach((Y) => {
      L(Y, !!K[Y]);
    });
  }
  function lt(K, Y) {
    var ue;
    const ye = Y && "value" in Y ? Y.value : pt(P.value, K), Pe = H(K);
    Pe && (Pe.__flags.pendingReset = !0), ut(K, je(ye), !0), te(K, ye, !1), L(K, (ue = Y?.touched) !== null && ue !== void 0 ? ue : !1), m(K, Y?.errors || []), ke(() => {
      Pe && (Pe.__flags.pendingReset = !1);
    });
  }
  function De(K, Y) {
    let ue = je(K?.values ? K.values : D.value);
    ue = Y?.force ? ue : os(D.value, ue), ue = Pn(O) && Nt(O.cast) ? O.cast(ue) : ue, q(ue, { force: Y?.force }), W((ye) => {
      var Pe;
      ye.__flags.pendingReset = !0, ye.validated = !1, ye.touched = ((Pe = K?.touched) === null || Pe === void 0 ? void 0 : Pe[fe(ye.path)]) || !1, te(fe(ye.path), pt(ue, fe(ye.path)), !1), m(fe(ye.path), void 0);
    }), Y?.force ? z(ue, !1) : ae(ue, !1), g(K?.errors || {}), i.value = K?.submitCount || 0, ke(() => {
      Ne({ mode: "silent" }), W((ye) => {
        ye.__flags.pendingReset = !1;
      });
    });
  }
  async function Ne(K) {
    const Y = K?.mode || "force";
    if (Y === "force" && W((qe) => qe.validated = !0), R.validateSchema)
      return R.validateSchema(Y);
    s.value = !0;
    const ue = await Promise.all(c.value.map((qe) => qe.validate ? qe.validate(K).then((rt) => ({
      key: fe(qe.path),
      valid: rt.valid,
      errors: rt.errors,
      value: rt.value
    })) : Promise.resolve({
      key: fe(qe.path),
      valid: !0,
      errors: [],
      value: void 0
    })));
    s.value = !1;
    const ye = {}, Pe = {}, Ae = {};
    for (const qe of ue)
      ye[qe.key] = {
        valid: qe.valid,
        errors: qe.errors
      }, qe.value && Et(Ae, qe.key, qe.value), qe.errors.length && (Pe[qe.key] = qe.errors[0]);
    return {
      valid: ue.every((qe) => qe.valid),
      results: ye,
      errors: Pe,
      values: Ae,
      source: "fields"
    };
  }
  async function Ue(K, Y) {
    var ue;
    const ye = H(K);
    if (ye && Y?.mode !== "silent" && (ye.validated = !0), O) {
      const { results: Ae } = await Q(Y?.mode || "validated-only");
      return Ae[K] || { errors: [], valid: !0 };
    }
    return ye?.validate ? ye.validate(Y) : (!ye && (!((ue = Y?.warn) !== null && ue !== void 0) || ue) && process.env.NODE_ENV !== "production" && ah(`field with path ${K} was not found`), Promise.resolve({ errors: [], valid: !0 }));
  }
  function We(K) {
    zm(P.value, K);
  }
  function it(K, Y, ue = !1) {
    ut(K, Y), Et(d, K, Y), ue && !e?.initialValues && Et(D.value, K, je(Y));
  }
  function ut(K, Y, ue = !1) {
    Et(P.value, K, je(Y)), ue && Et(D.value, K, je(Y));
  }
  async function $t() {
    const K = l(O);
    if (!K)
      return { valid: !0, results: {}, errors: {}, source: "none" };
    s.value = !0;
    const Y = ci(K) || Pn(K) ? await C8(K, d) : await S8(K, d, {
      names: S.value,
      bailsMap: $.value
    });
    return s.value = !1, Y;
  }
  const un = ge((K, { evt: Y }) => {
    J_(Y) && Y.target.submit();
  });
  Ce(() => {
    if (e?.initialErrors && g(e.initialErrors), e?.initialTouched && Xe(e.initialTouched), e?.validateOnMount) {
      Ne();
      return;
    }
    R.validateSchema && R.validateSchema("silent");
  }), mt(O) && ve(O, () => {
    var K;
    (K = R.validateSchema) === null || K === void 0 || K.call(R, "validated-only");
  }), Xn(Es, R), process.env.NODE_ENV !== "production" && (M8(R), ve(() => Object.assign(Object.assign({ errors: w.value }, T.value), { values: d, isSubmitting: o.value, isValidating: s.value, submitCount: i.value }), Kr, {
    deep: !0
  }));
  function gn(K, Y) {
    const ue = Nt(Y) ? void 0 : Y?.label, ye = H(fe(K)) || F(K, { label: ue }), Pe = () => Nt(Y) ? Y(rl(ye, ol)) : Y || {};
    function Ae() {
      var at;
      ye.touched = !0, ((at = Pe().validateOnBlur) !== null && at !== void 0 ? at : Ja().validateOnBlur) && Ue(fe(ye.path));
    }
    function qe() {
      var at;
      ((at = Pe().validateOnInput) !== null && at !== void 0 ? at : Ja().validateOnInput) && ke(() => {
        Ue(fe(ye.path));
      });
    }
    function rt() {
      var at;
      ((at = Pe().validateOnChange) !== null && at !== void 0 ? at : Ja().validateOnChange) && ke(() => {
        Ue(fe(ye.path));
      });
    }
    const ct = E(() => {
      const at = {
        onChange: rt,
        onInput: qe,
        onBlur: Ae
      };
      return Nt(Y) ? Object.assign(Object.assign({}, at), Y(rl(ye, ol)).props || {}) : Y?.props ? Object.assign(Object.assign({}, at), Y.props(rl(ye, ol))) : at;
    });
    return [ie(K, () => {
      var at, kt, Vt;
      return (Vt = (at = Pe().validateOnModelUpdate) !== null && at !== void 0 ? at : (kt = Ja()) === null || kt === void 0 ? void 0 : kt.validateOnModelUpdate) !== null && Vt !== void 0 ? Vt : !0;
    }), ct];
  }
  function Oe(K) {
    return Array.isArray(K) ? K.map((Y) => ie(Y, !0)) : ie(K);
  }
  function Pt(K, Y) {
    const [ue, ye] = gn(K, Y);
    function Pe() {
      ye.value.onBlur();
    }
    function Ae(rt) {
      const ct = fi(rt);
      te(fe(K), ct, !1), ye.value.onInput();
    }
    function qe(rt) {
      const ct = fi(rt);
      te(fe(K), ct, !1), ye.value.onChange();
    }
    return E(() => Object.assign(Object.assign({}, ye.value), {
      onBlur: Pe,
      onInput: Ae,
      onChange: qe,
      value: ue.value
    }));
  }
  function jt(K, Y) {
    const [ue, ye] = gn(K, Y), Pe = H(fe(K));
    function Ae(qe) {
      ue.value = qe;
    }
    return E(() => {
      const qe = Nt(Y) ? Y(rl(Pe, ol)) : Y || {};
      return Object.assign({ [qe.model || "modelValue"]: ue.value, [`onUpdate:${qe.model || "modelValue"}`]: Ae }, ye.value);
    });
  }
  const Rt = Object.assign(Object.assign({}, R), { values: or(d), handleReset: () => De(), submitForm: un });
  return Xn(t8, Rt), Rt;
}
function W8(e, t, n, a) {
  const r = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, o = E(() => !At(t, l(n)));
  function s() {
    const u = e.value;
    return Zt(r).reduce((d, c) => {
      const f = r[c];
      return d[c] = u[f]((p) => p[c]), d;
    }, {});
  }
  const i = Wt(s());
  return Ie(() => {
    const u = s();
    i.touched = u.touched, i.valid = u.valid, i.pending = u.pending;
  }), E(() => Object.assign(Object.assign({ initialValues: l(n) }, i), { valid: i.valid && !Zt(a.value).length, dirty: o.value }));
}
function G8(e, t, n) {
  const a = l0(n), r = I(a), o = I(je(a));
  function s(i, u) {
    u?.force ? (r.value = je(i), o.value = je(i)) : (r.value = os(je(r.value) || {}, je(i)), o.value = os(je(o.value) || {}, je(i))), u?.updateFields && e.value.forEach((d) => {
      if (d.touched)
        return;
      const f = pt(r.value, fe(d.path));
      Et(t, fe(d.path), je(f));
    });
  }
  return {
    initialValues: r,
    originalInitialValues: o,
    setInitialValues: s
  };
}
function K8(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const Y8 = /* @__PURE__ */ b({
  name: "Form",
  inheritAttrs: !1,
  props: {
    as: {
      type: null,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: "Form"
    }
  },
  setup(e, t) {
    const n = jn(e, "validationSchema"), a = jn(e, "keepValues"), { errors: r, errorBag: o, values: s, meta: i, isSubmitting: u, isValidating: d, submitCount: c, controlledValues: f, validate: p, validateField: v, handleReset: m, resetForm: g, handleSubmit: w, setErrors: C, setFieldError: S, setFieldValue: $, setValues: B, setFieldTouched: k, setTouched: P, resetField: D } = j8({
      validationSchema: n.value ? n : void 0,
      initialValues: e.initialValues,
      initialErrors: e.initialErrors,
      initialTouched: e.initialTouched,
      validateOnMount: e.validateOnMount,
      keepValuesOnUnmount: a,
      name: e.name
    }), q = w((W, { evt: H }) => {
      J_(H) && H.target.submit();
    }, e.onInvalidSubmit), T = e.onSubmit ? w(e.onSubmit, e.onInvalidSubmit) : q;
    function M(W) {
      ap(W) && W.preventDefault(), m(), typeof t.attrs.onReset == "function" && t.attrs.onReset();
    }
    function O(W, H) {
      return w(typeof W == "function" && !H ? W : H, e.onInvalidSubmit)(W);
    }
    function F() {
      return je(s);
    }
    function J() {
      return je(i.value);
    }
    function ne() {
      return je(r.value);
    }
    function Q() {
      return {
        meta: i.value,
        errors: r.value,
        errorBag: o.value,
        values: s,
        isSubmitting: u.value,
        isValidating: d.value,
        submitCount: c.value,
        controlledValues: f.value,
        validate: p,
        validateField: v,
        handleSubmit: O,
        handleReset: m,
        submitForm: q,
        setErrors: C,
        setFieldError: S,
        setFieldValue: $,
        setValues: B,
        setFieldTouched: k,
        setTouched: P,
        resetForm: g,
        resetField: D,
        getValues: F,
        getMeta: J,
        getErrors: ne
      };
    }
    return t.expose({
      setFieldError: S,
      setErrors: C,
      setFieldValue: $,
      setValues: B,
      setFieldTouched: k,
      setTouched: P,
      resetForm: g,
      validate: p,
      validateField: v,
      resetField: D,
      getValues: F,
      getMeta: J,
      getErrors: ne,
      values: s,
      meta: i,
      errors: r
    }), function() {
      const H = e.as === "form" ? e.as : e.as ? Tt(e.as) : null, U = cu(H, t, Q);
      return H ? an(H, Object.assign(Object.assign(Object.assign({}, H === "form" ? {
        // Disables native validation as vee-validate will handle it.
        novalidate: !0
      } : {}), t.attrs), { onSubmit: T, onReset: M }), U) : U;
    };
  }
}), Y9 = Y8;
function X8(e) {
  const t = op(Es, void 0), n = I([]), a = () => {
  }, r = {
    fields: n,
    remove: a,
    push: a,
    swap: a,
    insert: a,
    update: a,
    replace: a,
    prepend: a,
    move: a
  };
  if (!t)
    return process.env.NODE_ENV !== "production" && nd("FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly"), r;
  if (!l(e))
    return process.env.NODE_ENV !== "production" && nd("FieldArray requires a field path to be provided, did you forget to pass the `name` prop?"), r;
  const o = t.fieldArrays.find((k) => l(k.path) === l(e));
  if (o)
    return o;
  let s = 0;
  function i() {
    return pt(t?.values, fe(e), []) || [];
  }
  function u() {
    const k = i();
    Array.isArray(k) && (n.value = k.map((P, D) => c(P, D, n.value)), d());
  }
  u();
  function d() {
    const k = n.value.length;
    for (let P = 0; P < k; P++) {
      const D = n.value[P];
      D.isFirst = P === 0, D.isLast = P === k - 1;
    }
  }
  function c(k, P, D) {
    if (D && !Br(P) && D[P])
      return D[P];
    const q = s++;
    return {
      key: q,
      value: u8({
        get() {
          const M = pt(t?.values, fe(e), []) || [], O = n.value.findIndex((F) => F.key === q);
          return O === -1 ? k : M[O];
        },
        set(M) {
          const O = n.value.findIndex((F) => F.key === q);
          if (O === -1) {
            process.env.NODE_ENV !== "production" && nd("Attempting to update a non-existent array item");
            return;
          }
          C(O, M);
        }
      }),
      // will be auto unwrapped
      isFirst: !1,
      isLast: !1
    };
  }
  function f() {
    d(), t?.validate({ mode: "silent" });
  }
  function p(k) {
    const P = fe(e), D = pt(t?.values, P);
    if (!D || !Array.isArray(D))
      return;
    const q = [...D];
    q.splice(k, 1);
    const T = P + `[${k}]`;
    t.destroyPath(T), t.unsetInitialValue(T), Et(t.values, P, q), n.value.splice(k, 1), f();
  }
  function v(k) {
    const P = je(k), D = fe(e), q = pt(t?.values, D), T = Br(q) ? [] : q;
    if (!Array.isArray(T))
      return;
    const M = [...T];
    M.push(P), t.stageInitialValue(D + `[${M.length - 1}]`, P), Et(t.values, D, M), n.value.push(c(P)), f();
  }
  function m(k, P) {
    const D = fe(e), q = pt(t?.values, D);
    if (!Array.isArray(q) || !(k in q) || !(P in q))
      return;
    const T = [...q], M = [...n.value], O = T[k];
    T[k] = T[P], T[P] = O;
    const F = M[k];
    M[k] = M[P], M[P] = F, Et(t.values, D, T), n.value = M, d();
  }
  function g(k, P) {
    const D = je(P), q = fe(e), T = pt(t?.values, q);
    if (!Array.isArray(T) || T.length < k)
      return;
    const M = [...T], O = [...n.value];
    M.splice(k, 0, D), O.splice(k, 0, c(D)), Et(t.values, q, M), n.value = O, f();
  }
  function w(k) {
    const P = fe(e);
    t.stageInitialValue(P, k), Et(t.values, P, k), u(), f();
  }
  function C(k, P) {
    const D = fe(e), q = pt(t?.values, D);
    !Array.isArray(q) || q.length - 1 < k || (Et(t.values, `${D}[${k}]`, P), t?.validate({ mode: "validated-only" }));
  }
  function S(k) {
    const P = je(k), D = fe(e), q = pt(t?.values, D), T = Br(q) ? [] : q;
    if (!Array.isArray(T))
      return;
    const M = [P, ...T];
    Et(t.values, D, M), t.stageInitialValue(D + "[0]", P), n.value.unshift(c(P)), f();
  }
  function $(k, P) {
    const D = fe(e), q = pt(t?.values, D), T = Br(q) ? [] : [...q];
    if (!Array.isArray(q) || !(k in q) || !(P in q))
      return;
    const M = [...n.value], O = M[k];
    M.splice(k, 1), M.splice(P, 0, O);
    const F = T[k];
    T.splice(k, 1), T.splice(P, 0, F), Et(t.values, D, T), n.value = M, f();
  }
  const B = {
    fields: n,
    remove: p,
    push: v,
    swap: m,
    insert: g,
    update: C,
    replace: w,
    prepend: S,
    move: $
  };
  return t.fieldArrays.push(Object.assign({ path: e, reset: u }, B)), sr(() => {
    const k = t.fieldArrays.findIndex((P) => fe(P.path) === fe(e));
    k >= 0 && t.fieldArrays.splice(k, 1);
  }), ve(i, (k) => {
    const P = n.value.map((D) => D.value);
    At(k, P) || u();
  }), B;
}
const J8 = /* @__PURE__ */ b({
  name: "FieldArray",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const { push: n, remove: a, swap: r, insert: o, replace: s, update: i, prepend: u, move: d, fields: c } = X8(() => e.name);
    function f() {
      return {
        fields: c.value,
        push: n,
        remove: a,
        swap: r,
        insert: o,
        update: i,
        replace: s,
        prepend: u,
        move: d
      };
    }
    return t.expose({
      push: n,
      remove: a,
      swap: r,
      insert: o,
      update: i,
      replace: s,
      prepend: u,
      move: d
    }), () => cu(void 0, t, f);
  }
}), X9 = J8, Z8 = /* @__PURE__ */ b({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const n = Cn(Es, void 0), a = E(() => n?.errors.value[e.name]);
    function r() {
      return {
        message: a.value
      };
    }
    return () => {
      if (!a.value)
        return;
      const o = e.as ? Tt(e.as) : e.as, s = cu(o, t, r), i = Object.assign({ role: "alert" }, t.attrs);
      return !o && (Array.isArray(s) || !s) && s?.length ? s : (Array.isArray(s) || !s) && !s?.length ? an(o || "span", i, a.value) : an(o, i, s);
    };
  }
}), Q8 = Z8, i0 = /* @__PURE__ */ Symbol();
function fu() {
  const e = Cn(K_), t = Cn(i0);
  if (!e) throw new Error("useFormField should be used within <FormField>");
  const { name: n, errorMessage: a, meta: r } = e, o = t, s = {
    valid: E(() => r.valid),
    isDirty: E(() => r.dirty),
    isTouched: E(() => r.touched),
    error: a
  };
  return {
    id: o,
    name: n,
    formItemId: `${o}-form-item`,
    formDescriptionId: `${o}-form-item-description`,
    formMessageId: `${o}-form-item-message`,
    ...s
  };
}
const J9 = /* @__PURE__ */ b({
  __name: "FormControl",
  setup(e) {
    const { error: t, formItemId: n, formDescriptionId: a, formMessageId: r } = fu();
    return (o, s) => (h(), x(l(Ml), {
      id: l(n),
      "aria-describedby": l(t) ? `${l(a)} ${l(r)}` : `${l(a)}`,
      "aria-invalid": !!l(t)
    }, {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "aria-describedby", "aria-invalid"]));
  }
}), ez = ["id"], Z9 = /* @__PURE__ */ b({
  __name: "FormDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { formDescriptionId: n } = fu();
    return (a, r) => (h(), G("p", {
      id: l(n),
      class: re(l(V)("text-sm text-muted-foreground", t.class))
    }, [
      _(a.$slots, "default")
    ], 10, ez));
  }
}), Q9 = /* @__PURE__ */ b({
  __name: "FormItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Ge();
    return Xn(i0, n), (a, r) => (h(), G("div", {
      class: re(l(V)("space-y-2", t.class))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), eU = /* @__PURE__ */ b({
  __name: "FormLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, { error: n, formItemId: a } = fu();
    return (r, o) => (h(), x(l(G_), {
      class: re(l(V)(l(n) && "text-destructive", t.class)),
      for: l(a)
    }, {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "for"]));
  }
}), tU = /* @__PURE__ */ b({
  __name: "FormMessage",
  setup(e) {
    const { name: t, formMessageId: n } = fu();
    return (a, r) => (h(), x(l(Q8), {
      id: l(n),
      as: "p",
      name: fe(l(t)),
      class: "text-[0.8rem] font-medium text-destructive"
    }, null, 8, ["id", "name"]));
  }
}), nU = /* @__PURE__ */ b({
  __name: "HoverCard",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    openDelay: {},
    closeDelay: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(GD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), aU = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(eP), null, {
      default: y(() => [
        N(l(ZD), A(l(a), {
          class: l(V)(
            "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), rU = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(nP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), u0 = /* @__PURE__ */ b({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ pf(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => lc((h(), G("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null),
      "data-slot": "input",
      class: re(
        l(V)(
          "h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30",
          "focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50",
          "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
          n.class
        )
      )
    }, null, 2)), [
      [rh, l(r)]
    ]);
  }
}), oU = /* @__PURE__ */ b({
  __name: "InputGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "input-group",
      role: "group",
      class: re(
        l(V)(
          "group/input-group relative flex w-full items-center rounded-md border border-input outline-none dark:bg-input/30",
          "h-9 min-w-0 has-[>textarea]:h-auto",
          // Variants based on alignment.
          "has-[>[data-align=inline-start]]:[&>input]:pl-2",
          "has-[>[data-align=inline-end]]:[&>input]:pr-2",
          "has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3",
          "has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3",
          // Focus state.
          "has-[[data-slot=input-group-control]:focus-visible]:ring-1 has-[[data-slot=input-group-control]:focus-visible]:ring-ring",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), tz = ["data-align"], sU = /* @__PURE__ */ b({
  __name: "InputGroupAddon",
  props: {
    align: { default: "inline-start" },
    class: {}
  },
  setup(e) {
    const t = e;
    function n(a) {
      const r = a.currentTarget, o = a.target;
      o && o.closest("button") || r && r?.parentElement && r.parentElement?.querySelector("input")?.focus();
    }
    return (a, r) => (h(), G("div", {
      role: "group",
      "data-slot": "input-group-addon",
      "data-align": t.align,
      class: re(l(V)(l(az)({ align: t.align }), t.class)),
      onClick: n
    }, [
      _(a.$slots, "default")
    ], 10, tz));
  }
}), lU = /* @__PURE__ */ b({
  __name: "InputGroupButton",
  props: {
    variant: { default: "ghost" },
    size: { default: "xs" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ui), {
      "data-size": t.size,
      variant: t.variant,
      class: re(l(V)(l(rz)({ size: t.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-size", "variant", "class"]));
  }
}), iU = /* @__PURE__ */ b({
  __name: "InputGroupInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(u0), {
      "data-slot": "input-group-control",
      class: re(
        l(V)(
          "flex-1 rounded-none border-0 bg-transparent ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), uU = /* @__PURE__ */ b({
  __name: "InputGroupText",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: re(
        l(V)(
          "flex items-center gap-2 text-sm text-muted-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), nz = /* @__PURE__ */ b({
  __name: "Textarea",
  props: {
    class: {},
    defaultValue: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ pf(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => lc((h(), G("textarea", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null),
      class: re(
        l(V)(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          n.class
        )
      )
    }, null, 2)), [
      [rh, l(r)]
    ]);
  }
}), dU = /* @__PURE__ */ b({
  __name: "InputGroupTextarea",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(nz), {
      "data-slot": "input-group-control",
      class: re(
        l(V)(
          "flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), az = sn(
  "flex h-auto cursor-text select-none items-center justify-center gap-2 py-1.5 text-sm font-medium text-muted-foreground group-data-[disabled=true]/input-group:opacity-50 [&>kbd]:rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-4",
  {
    variants: {
      align: {
        "inline-start": "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
        "inline-end": "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
        "block-start": "[.border-b]:pb-3 order-first w-full justify-start px-3 pt-3 group-has-[>input]/input-group:pt-2.5",
        "block-end": "[.border-t]:pt-3 order-last w-full justify-start px-3 pb-3 group-has-[>input]/input-group:pb-2.5"
      }
    },
    defaultVariants: {
      align: "inline-start"
    }
  }
), rz = sn("flex items-center gap-2 text-sm shadow-none", {
  variants: {
    size: {
      xs: "h-6 gap-1 rounded-[calc(var(--radius)-5px)] px-2 has-[>svg]:px-2 [&>svg:not([class*='size-'])]:size-3.5",
      sm: "h-8 gap-1.5 rounded-md px-2.5 has-[>svg]:px-2.5",
      "icon-xs": "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
      "icon-sm": "size-8 p-0 has-[>svg]:p-0"
    }
  },
  defaultVariants: {
    size: "xs"
  }
});
function oz(e) {
  return ss() ? (sc(e), !0) : !1;
}
function sz(e) {
  if (!mt(e))
    return Wt(e);
  const t = new Proxy({}, {
    get(n, a, r) {
      return l(Reflect.get(e.value, a, r));
    },
    set(n, a, r) {
      return mt(e.value[a]) && !mt(r) ? e.value[a].value = r : e.value[a] = r, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Wt(t);
}
function lz(e) {
  return sz(E(e));
}
function iz(e, ...t) {
  const n = t.flat(), a = n[0];
  return lz(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(fe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
const d0 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const uz = Object.prototype.toString, dz = (e) => uz.call(e) === "[object Object]", cz = () => {
};
function rd(e) {
  return Array.isArray(e) ? e : [e];
}
function fz(...e) {
  if (e.length !== 1)
    return jn(...e);
  const t = e[0];
  return typeof t == "function" ? or(pi(() => ({ get: t, set: cz }))) : I(t);
}
function pz(e, t, n) {
  return ve(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
const c0 = d0 ? window : void 0, ja = d0 ? window.document : void 0;
function vz(e) {
  var t;
  const n = fe(e);
  return (t = n?.$el) != null ? t : n;
}
function mz(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), r = E(() => {
    const i = rd(fe(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), o = pz(
    () => {
      var i, u;
      return [
        (u = (i = r.value) == null ? void 0 : i.map((d) => vz(d))) != null ? u : [c0].filter((d) => d != null),
        rd(fe(r.value ? e[1] : e[0])),
        rd(l(r.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        fe(r.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !i?.length || !u?.length || !d?.length)
        return;
      const f = dz(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return oz(n), s;
}
function hz(e, t) {
  const n = gt(t);
  return ve(
    fz(e),
    (a, r) => {
      n.value = r;
    },
    { flush: "sync" }
  ), or(n);
}
const gz = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`, yz = b({
  props: { fallback: {
    type: String,
    required: !0
  } },
  setup(e) {
    return () => an("noscript", { innerHTML: `<style>${e.fallback}</style>` });
  }
}), f0 = /* @__PURE__ */ Symbol("vue-otp-context");
function bz(e) {
  return [
    setTimeout(e, 0),
    setTimeout(e, 10),
    setTimeout(e, 50)
  ];
}
const _z = 18, p0 = 40, wz = `${p0}px`, xz = [
  "[data-lastpass-icon-root]",
  "com-1password-button",
  "[data-dashlanecreated]",
  '[style$="2147483647 !important;"]'
].join(",");
function Cz({ containerRef: e, inputRef: t, pushPasswordManagerStrategy: n, isFocused: a }) {
  const r = I({
    done: !1,
    refocused: !1
  }), o = I(!1), s = I(!1), i = I(!1), u = E(() => n === "none" ? !1 : (n === "increase-width" || n === "experimental-no-flickering") && o.value && s.value), d = () => {
    const p = e.value, v = t.value;
    if (!p || !v || i.value || n === "none") return;
    const m = p, g = m.getBoundingClientRect().left + m.offsetWidth, w = m.getBoundingClientRect().top + m.offsetHeight / 2, C = g - _z, S = w;
    if (!(document.querySelectorAll(xz).length === 0 && document.elementFromPoint(C, S) === p) && (o.value = !0, i.value = !0, !r.value.refocused && document.activeElement === v)) {
      const $ = [v.selectionStart, v.selectionEnd];
      v.blur(), v.focus(), v.setSelectionRange($[0], $[1]), r.value.refocused = !0;
    }
  }, c = () => {
    const p = e.value;
    !p || n === "none" || (s.value = window.innerWidth - p.getBoundingClientRect().right >= p0);
  };
  let f;
  return Ce(() => {
    c(), f = setInterval(c, 1e3);
  }), Qe(() => {
    clearInterval(f);
  }), ve([a, t], (p, v, m) => {
    const [g, w] = p, C = g || document.activeElement === w;
    if (n === "none" || !C) return;
    const S = setTimeout(d, 0), $ = setTimeout(d, 2e3), B = setTimeout(d, 5e3), k = setTimeout(() => {
      i.value = !0;
    }, 6e3);
    m(() => {
      clearTimeout(S), clearTimeout($), clearTimeout(B), clearTimeout(k);
    });
  }), {
    hasPWMBadge: o,
    willPushPWMBadge: u,
    PWM_BADGE_SPACE_WIDTH: wz
  };
}
const Sz = { style: {
  position: "absolute",
  inset: "0",
  "pointer-events": "none"
} }, $z = [
  "value",
  "data-input-otp-placeholder-shown",
  "data-input-otp-mss",
  "data-input-otp-mse",
  "aria-placeholder",
  "pattern"
], kz = /* @__PURE__ */ b({
  name: "OTPInput",
  inheritAttrs: !1,
  __name: "OTPInput",
  props: /* @__PURE__ */ ip({
    maxlength: {},
    textAlign: { default: "left" },
    inputmode: { default: "numeric" },
    containerClass: {},
    pushPasswordManagerStrategy: { default: "increase-width" },
    noScriptCssFallback: { default: gz },
    defaultValue: { default: "" },
    pasteTransformer: {},
    accept: {},
    alt: {},
    autocomplete: { default: "one-time-code" },
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [
      Boolean,
      Array,
      Set
    ] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {}
  }, {
    modelValue: { default(e) {
      return e.defaultValue;
    } },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ip([
    "complete",
    "change",
    "select",
    "input",
    "focus",
    "blur",
    "mouseover",
    "mouseleave",
    "paste"
  ], ["update:modelValue"]),
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, [o] = D0(e, "modelValue"), s = hz(o), i = E(() => a.pattern ? typeof a.pattern == "string" ? new RegExp(a.pattern) : a.pattern : null), u = gt(!1), d = gt(!1), c = gt(null), f = gt(null), p = gt(null), v = gt(null), m = c0?.CSS?.supports?.("-webkit-touch-callout", "none");
    let g = { prev: [
      p.value?.selectionStart,
      p.value?.selectionEnd,
      p.value?.selectionDirection
    ] };
    function w(M, O) {
      try {
        M.insertRule(O);
      } catch {
        console.error("input-otp could not insert CSS rule:", O);
      }
    }
    Ce(() => {
      const M = p.value, O = v.value;
      if (!M || !O) return;
      g.prev = [
        M.selectionStart,
        M.selectionEnd,
        M.selectionDirection ?? "none"
      ];
      const F = mz(ja, "selectionchange", J, { capture: !0 });
      function J() {
        if (!M) return;
        if (ja?.activeElement !== M) {
          c.value = null, f.value = null;
          return;
        }
        const W = M.selectionStart, H = M.selectionEnd, U = M.selectionDirection, se = M.maxLength, ee = M.value, de = g.prev;
        let pe = -1, _e = -1, ge;
        if (ee.length !== 0 && W !== null && H !== null) {
          const te = W === H, z = W === ee.length && ee.length < se;
          if (te && !z) {
            const ae = W;
            if (ae === 0)
              pe = 0, _e = 1, ge = "forward";
            else if (ae === se)
              pe = ae - 1, _e = ae, ge = "backward";
            else if (se > 1 && ee.length > 1) {
              let ie = 0;
              if (de[0] !== null && de[1] !== null) {
                ge = ae < de[1] ? "backward" : "forward";
                const L = de[0] === de[1] && de[0] < se;
                ge === "backward" && !L && (ie = -1);
              }
              pe = ie + ae, _e = ie + ae + 1;
            }
          }
          pe !== -1 && _e !== -1 && pe !== _e && M.setSelectionRange(pe, _e, ge);
        }
        const Te = pe !== -1 ? pe : W, ce = _e !== -1 ? _e : H, R = ge ?? U;
        c.value = Te, f.value = ce, g.prev = [
          Te,
          ce,
          R
        ];
      }
      if (J(), ja?.activeElement === M && (d.value = !0), !ja?.getElementById("input-otp-style")) {
        const W = ja?.createElement("style");
        if (W.id = "input-otp-style", ja?.head.appendChild(W), W.sheet) {
          const H = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
          w(W.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), w(W.sheet, `[data-input-otp]:autofill { ${H} }`), w(W.sheet, `[data-input-otp]:-webkit-autofill { ${H} }`), w(W.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), w(W.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
        }
      }
      const ne = () => {
        O && O.style.setProperty("--root-height", `${M.clientHeight}px`);
      };
      ne();
      const Q = new ResizeObserver(ne);
      Q.observe(M), Qe(() => {
        F(), Q.disconnect();
      });
    }), ve([o], () => {
      bz(() => {
        if (!p.value) return;
        p.value?.dispatchEvent(new Event("input"));
        const M = p.value?.selectionStart, O = p.value?.selectionEnd, F = p.value?.selectionDirection;
        M !== null && O !== null && (c.value = M ?? null, f.value = O ?? null, g.prev = [
          M,
          O,
          F
        ]);
      });
    }, { immediate: !0 }), Ie(() => {
      s.value !== void 0 && o.value !== s.value && s.value.length < a.maxlength && o.value.length === a.maxlength && r("complete", o.value);
    });
    const C = Cz({
      containerRef: v,
      inputRef: p,
      pushPasswordManagerStrategy: a.pushPasswordManagerStrategy,
      isFocused: d
    });
    function S(M) {
      if (M.inputType === "insertText" && M.data !== null) {
        const O = M.currentTarget, F = O.selectionStart ?? 0, J = O.selectionEnd ?? 0, ne = O.value, Q = (F !== J ? ne.slice(0, F) + M.data + ne.slice(J) : ne.slice(0, F) + M.data + ne.slice(F)).slice(0, a.maxlength);
        Q.length > 0 && i.value && !i.value.test(Q) && M.preventDefault();
      }
    }
    function $(M) {
      const O = M.currentTarget.value.slice(0, a.maxlength);
      if (O.length > 0 && i.value && !i.value.test(O)) {
        M.preventDefault();
        return;
      }
      typeof s.value == "string" && O.length < s.value.length && ja?.dispatchEvent(new Event("selectionchange")), o.value = O, r("input", O);
    }
    function B() {
      const M = p.value;
      if (M) {
        const O = Math.min(M.value.length, a.maxlength - 1), F = M.value.length;
        M.setSelectionRange(O, F), c.value = O, f.value = F;
      }
      d.value = !0;
    }
    function k(M) {
      const O = p.value;
      if (!O || !a.pasteTransformer && (!m || !M.clipboardData || !O)) return;
      const F = M?.clipboardData?.getData("text/plain"), J = a?.pasteTransformer ? a.pasteTransformer(F) : F;
      M.preventDefault();
      const ne = p.value?.selectionStart, Q = p.value?.selectionEnd, W = (ne !== Q ? o.value.slice(0, ne) + J + o.value.slice(Q) : o.value.slice(0, ne) + J + o.value.slice(ne)).slice(0, a.maxlength);
      if (W.length > 0 && i.value && !i.value.test(W)) return;
      o.value = W, r("input", W);
      const H = Math.min(W.length, a.maxlength - 1), U = W.length;
      O?.setSelectionRange(H, U), c.value = H, f.value = U;
    }
    const P = he(iz(a, "containerClass", "value", "pattern", "defaultValue", "pushPasswordManagerStrategy", "noScriptCssFallback", "modelValue")), D = E(() => ({
      position: "relative",
      cursor: a.disabled ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })), q = E(() => ({
      position: "absolute",
      inset: 0,
      width: C.willPushPWMBadge.value ? `calc(100% + ${C.PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: C.willPushPWMBadge.value ? `inset(0 ${C.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: a.textAlign,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })), T = E(() => ({
      slots: Array.from({ length: Number(a.maxlength) }).map((M, O) => {
        const F = d.value && c.value !== null && f.value !== null && (c.value === f.value && O === c.value || O >= c.value && O < f.value), J = o.value[O] !== void 0 ? o.value[O] : null;
        return {
          char: J,
          placeholderChar: J ?? a?.placeholder?.[O] ?? null,
          isActive: F,
          hasFakeCaret: F && J === null
        };
      }),
      isFocused: d.value,
      isHovering: !a.disabled && u.value
    }));
    return Xn(f0, T), t(Object.defineProperty({}, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => p
    })), (M, O) => (h(), G(Ye, null, [e.noScriptCssFallback !== null ? (h(), x(l(yz), {
      key: 0,
      fallback: e.noScriptCssFallback
    }, null, 8, ["fallback"])) : Ee("v-if", !0), xe("div", {
      ref_key: "containerRef",
      ref: v,
      "data-input-otp-container": "",
      style: dt(D.value),
      class: re(e.containerClass)
    }, [_(M.$slots, "default", {
      slots: T.value.slots,
      isFocused: d.value,
      isHovering: !e.disabled && u.value
    }), xe("div", Sz, [xe("input", A({
      ref_key: "inputRef",
      ref: p,
      value: l(o),
      "data-input-otp": "",
      "data-input-otp-placeholder-shown": l(o).length === 0 || void 0,
      "data-input-otp-mss": c.value,
      "data-input-otp-mse": f.value,
      "aria-placeholder": e.placeholder,
      style: q.value,
      pattern: i.value?.source
    }, {
      ...M.$attrs,
      ...l(P)
    }, {
      onBeforeinput: S,
      onMouseover: O[0] || (O[0] = (F) => {
        u.value = !0, r("mouseover", F);
      }),
      onMouseleave: O[1] || (O[1] = (F) => {
        u.value = !1, r("mouseleave", F);
      }),
      onPaste: O[2] || (O[2] = (F) => {
        k(F), r("paste", F);
      }),
      onInput: $,
      onFocus: O[3] || (O[3] = (F) => {
        B(), r("focus", F);
      }),
      onBlur: O[4] || (O[4] = (F) => {
        d.value = !1, r("blur", F);
      })
    }), null, 16, $z)])], 6)], 64));
  }
});
var Bz = kz;
function Dz() {
  return Cn(f0);
}
const cU = /* @__PURE__ */ b({
  __name: "InputOTP",
  props: {
    maxlength: {},
    textAlign: {},
    inputmode: {},
    containerClass: {},
    pushPasswordManagerStrategy: {},
    noScriptCssFallback: {},
    defaultValue: {},
    pasteTransformer: { type: Function },
    accept: {},
    alt: {},
    autocomplete: {},
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [Boolean, Array, Set] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {},
    class: {}
  },
  emits: ["complete", "change", "select", "input", "focus", "blur", "mouseover", "mouseleave", "paste"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(Bz), A(l(o), {
      "container-class": l(V)("flex items-center gap-2 has-disabled:opacity-50", n.class),
      "data-slot": "input-otp",
      class: "disabled:cursor-not-allowed"
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["container-class"]));
  }
}), fU = /* @__PURE__ */ b({
  __name: "InputOTPGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), G("div", A({ "data-slot": "input-otp-group" }, l(a), {
      class: l(V)("flex items-center", t.class)
    }), [
      _(r.$slots, "default")
    ], 16));
  }
}), pU = /* @__PURE__ */ b({
  __name: "InputOTPSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), G("div", A({
      "data-slot": "input-otp-separator",
      role: "separator"
    }, l(n)), [
      _(a.$slots, "default", {}, () => [
        N(l(gf))
      ])
    ], 16));
  }
}), Pz = ["data-active"], Mz = {
  key: 0,
  class: "pointer-events-none absolute inset-0 flex items-center justify-center"
}, vU = /* @__PURE__ */ b({
  __name: "InputOTPSlot",
  props: {
    index: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), r = Dz(), o = E(() => r?.value.slots[t.index]);
    return (s, i) => (h(), G("div", A(l(a), {
      "data-slot": "input-otp-slot",
      "data-active": o.value?.isActive,
      class: l(V)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md aria-invalid:border-destructive data-[active=true]:z-10 data-[active=true]:border-ring data-[active=true]:ring-[3px] data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:border-destructive data-[active=true]:aria-invalid:ring-destructive/20 dark:bg-input/30 dark:data-[active=true]:aria-invalid:ring-destructive/40",
        t.class
      )
    }), [
      Re(He(o.value?.char) + " ", 1),
      o.value?.hasFakeCaret ? (h(), G("div", Mz, [...i[0] || (i[0] = [
        xe("div", { class: "h-4 w-px animate-caret-blink bg-foreground duration-1000" }, null, -1)
      ])])) : Ee("", !0)
    ], 16, Pz));
  }
}), mU = /* @__PURE__ */ b({
  __name: "Item",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" },
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-slot": "item",
      as: e.as,
      "as-child": e.asChild,
      class: re(l(V)(l(Ez)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), hU = /* @__PURE__ */ b({
  __name: "ItemActions",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-actions",
      class: re(l(V)("flex items-center gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), gU = /* @__PURE__ */ b({
  __name: "ItemContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-content",
      class: re(l(V)("flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), yU = /* @__PURE__ */ b({
  __name: "ItemDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      "data-slot": "item-description",
      class: re(
        l(V)(
          "line-clamp-2 text-sm leading-normal font-normal text-balance text-muted-foreground",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), bU = /* @__PURE__ */ b({
  __name: "ItemFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-footer",
      class: re(l(V)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), _U = /* @__PURE__ */ b({
  __name: "ItemGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      role: "list",
      "data-slot": "item-group",
      class: re(l(V)("group/item-group flex flex-col", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), wU = /* @__PURE__ */ b({
  __name: "ItemHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-header",
      class: re(l(V)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), qz = ["data-variant"], xU = /* @__PURE__ */ b({
  __name: "ItemMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-media",
      "data-variant": t.variant,
      class: re(l(V)(l(Tz)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, qz));
  }
}), CU = /* @__PURE__ */ b({
  __name: "ItemSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Gi), {
      "data-slot": "item-separator",
      orientation: "horizontal",
      class: re(l(V)("my-0", t.class))
    }, null, 8, ["class"]));
  }
}), SU = /* @__PURE__ */ b({
  __name: "ItemTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-title",
      class: re(l(V)("flex w-fit items-center gap-2 text-sm leading-snug font-medium", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Ez = sn(
  "group/item [a]:hover:bg-accent/50 [a]:transition-colors flex flex-wrap items-center rounded-md border border-transparent text-sm outline-none transition-colors duration-100 focus-visible:border-ring focus-visible:ring-1 focus-visible:ring-ring",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border-border",
        muted: "bg-muted/50"
      },
      size: {
        default: "gap-4 p-4 ",
        sm: "gap-2.5 px-4 py-3"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Tz = sn(
  "flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:translate-y-0.5 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "size-8 rounded-sm border bg-muted [&_svg:not([class*='size-'])]:size-4",
        image: "size-10 overflow-hidden rounded-sm [&_img]:size-full [&_img]:object-cover"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), $U = /* @__PURE__ */ b({
  __name: "Kbd",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("kbd", {
      class: re(
        l(V)(
          "pointer-events-none inline-flex h-5 w-fit min-w-5 items-center justify-center gap-1 rounded-sm bg-muted px-1 font-sans text-xs font-medium text-muted-foreground select-none",
          "[&_svg:not([class*='size-'])]:size-3",
          "[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), kU = /* @__PURE__ */ b({
  __name: "KbdGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("kbd", {
      "data-slot": "kbd-group",
      class: re(l(V)("inline-flex items-center gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), BU = /* @__PURE__ */ b({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(uP), A(l(o), {
      class: l(V)(
        "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Az = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, DU = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(sP), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        xe("span", Az, [
          N(l(qg), null, {
            default: y(() => [
              N(l(oo), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PU = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    sideFlip: { type: Boolean },
    align: { default: "start" },
    alignOffset: { default: -4 },
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Eg), null, {
      default: y(() => [
        N(l(vP), A(l(a), {
          class: l(V)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), MU = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(hP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qU = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(yP), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), EU = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(wP), {
      class: re(l(V)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), TU = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(fP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), AU = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(SP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Iz = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, IU = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(kP), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        xe("span", Iz, [
          N(l(qg), null, {
            default: y(() => [
              N(l(mf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), OU = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(DP), A({
      class: l(V)("-mx-1 my-1 h-px bg-muted", t.class)
    }, l(a)), null, 16, ["class"]));
  }
}), RU = /* @__PURE__ */ b({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: re(l(V)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), VU = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(MP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), FU = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(Eg), null, {
      default: y(() => [
        N(l(EP), A(l(o), {
          class: l(V)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), NU = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(AP), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(za), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), LU = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(OP), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-3 py-1 text-sm font-medium outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Oz = { class: "absolute top-full left-0 flex justify-center" }, Rz = /* @__PURE__ */ b({
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    align: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), G("div", Oz, [
      N(l(oM), A(l(a), {
        class: l(V)(
          "origin-top-center relative left-[var(--reka-navigation-menu-viewport-left)] mt-1.5 h-[--reka-navigation-menu-viewport-height] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:zoom-in-90 md:w-[--reka-navigation-menu-viewport-width]",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), zU = /* @__PURE__ */ b({
  __name: "NavigationMenu",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    orientation: {},
    delayDuration: {},
    skipDelayDuration: {},
    disableClickTrigger: { type: Boolean },
    disableHoverTrigger: { type: Boolean },
    disablePointerLeaveClose: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(FP), A(l(o), {
      class: l(V)("relative z-10 flex max-w-max flex-1 items-center justify-center", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default"),
        N(Rz)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), HU = /* @__PURE__ */ b({
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(KP), A(l(o), {
      class: l(V)(
        "top-0 left-0 w-full data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 data-[motion^=from-]:animate-in data-[motion^=from-]:fade-in data-[motion^=to-]:animate-out data-[motion^=to-]:fade-out md:absolute md:w-auto",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), UU = /* @__PURE__ */ b({
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(XP), A(l(a), {
      class: l(V)(
        "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:animate-in data-[state=visible]:fade-in",
        t.class
      )
    }), {
      default: y(() => [...o[0] || (o[0] = [
        xe("div", { class: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" }, null, -1)
      ])]),
      _: 1
    }, 16, ["class"]));
  }
}), jU = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(UP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), WU = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(ZP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), GU = /* @__PURE__ */ b({
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(eM), A(l(a), {
      class: l(V)("group flex flex-1 list-none items-center justify-center gap-x-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), KU = /* @__PURE__ */ b({
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(aM), A(l(a), {
      class: l(V)(l(Vz)(), "group", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(ji), {
          class: "relative top-px ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180",
          "aria-hidden": "true"
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Vz = sn(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
), YU = /* @__PURE__ */ b({
  __name: "NumberField",
  props: {
    defaultValue: {},
    modelValue: {},
    min: {},
    max: {},
    step: {},
    stepSnapping: { type: Boolean },
    formatOptions: {},
    locale: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    disableWheelChange: { type: Boolean },
    invertWheelChange: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(hM), A(l(o), {
      class: l(V)("grid gap-1.5", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), XU = /* @__PURE__ */ b({
  __name: "NumberFieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: re(
        l(V)(
          "relative [&>[data-slot=input]]:has-[[data-slot=decrement]]:pl-5 [&>[data-slot=input]]:has-[[data-slot=increment]]:pr-5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), JU = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(yM), A({ "data-slot": "decrement" }, l(a), {
      class: l(V)(
        "absolute top-1/2 left-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(gf), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ZU = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(_M), A({ "data-slot": "increment" }, l(a), {
      class: l(V)(
        "absolute top-1/2 right-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(TO), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), QU = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(xM), {
      "data-slot": "input",
      class: re(
        l(V)(
          "flex h-9 w-full rounded-md border border-input bg-transparent py-1 text-center text-sm shadow-sm transition-colors placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), ej = /* @__PURE__ */ b({
  __name: "Pagination",
  props: {
    page: {},
    defaultPage: {},
    itemsPerPage: {},
    total: {},
    siblingCount: {},
    disabled: { type: Boolean },
    showEdges: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(BM), A({ "data-slot": "pagination" }, l(o), {
      class: l(V)("mx-auto flex w-full justify-center", n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), tj = /* @__PURE__ */ b({
  __name: "PaginationContent",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(IM), A({ "data-slot": "pagination-content" }, l(n), {
      class: l(V)("flex flex-row items-center gap-1", t.class)
    }), {
      default: y((o) => [
        _(a.$slots, "default", oe(le(o)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), nj = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(SM), A({ "data-slot": "pagination-ellipsis" }, l(n), {
      class: l(V)("flex size-9 items-center justify-center", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default", {}, () => [
          N(l(nb), { class: "size-4" }),
          r[0] || (r[0] = xe("span", { class: "sr-only" }, "More pages", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), aj = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(PM), A({
      "data-slot": "pagination-first",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Wi)),
          o[0] || (o[0] = xe("span", { class: "hidden sm:block" }, "First", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rj = /* @__PURE__ */ b({
  __name: "PaginationItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {},
    size: { default: "icon" },
    class: {},
    isActive: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size", "isActive");
    return (a, r) => (h(), x(l(RM), A({ "data-slot": "pagination-item" }, l(n), {
      class: l(V)(
        l(Yt)({
          variant: e.isActive ? "outline" : "ghost",
          size: e.size
        }),
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), oj = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(qM), A({
      "data-slot": "pagination-last",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = xe("span", { class: "hidden sm:block" }, "Last", -1)),
          N(l(za))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sj = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(FM), A({
      "data-slot": "pagination-next",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = xe("span", { class: "hidden sm:block" }, "Next", -1)),
          N(l(za))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lj = /* @__PURE__ */ b({
  __name: "PaginationPrevious",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(LM), A({
      "data-slot": "pagination-previous",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Wi)),
          o[0] || (o[0] = xe("span", { class: "hidden sm:block" }, "Previous", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ij = /* @__PURE__ */ b({
  __name: "PinInput",
  props: {
    modelValue: { default: () => [] },
    defaultValue: {},
    placeholder: {},
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: {},
    dir: {},
    disabled: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(jM), A(l(o), {
      class: l(V)("flex items-center gap-2", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uj = /* @__PURE__ */ b({
  __name: "PinInputGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(X), A(l(a), {
      class: l(V)("flex items-center", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dj = /* @__PURE__ */ b({
  __name: "PinInputSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(X), oe(le(l(n))), {
      default: y(() => [
        _(a.$slots, "default", {}, () => [
          N(l(gf), { class: "w-2" })
        ])
      ]),
      _: 3
    }, 16));
  }
}), cj = /* @__PURE__ */ b({
  __name: "PinInputSlot",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(GM), A(l(a), {
      class: l(V)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-center text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md focus:relative focus:z-10 focus:ring-2 focus:ring-ring focus:outline-none",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), fj = /* @__PURE__ */ b({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(DB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(VB), null, {
      default: y(() => [
        N(l(OB), A({ ...l(o), ...s.$attrs }, {
          class: l(V)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), vj = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(NB), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mj = /* @__PURE__ */ b({
  __name: "Progress",
  props: {
    modelValue: { default: 0 },
    max: {},
    getValueLabel: {},
    getValueText: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(QM), A(l(n), {
      class: l(V)("relative h-2 w-full overflow-hidden rounded-full bg-primary/20", t.class)
    }), {
      default: y(() => [
        N(l(tq), {
          class: "h-full w-full flex-1 bg-primary transition-all",
          style: dt(`transform: translateX(-${100 - (t.modelValue ?? 0)}%);`)
        }, null, 8, ["style"])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), hj = /* @__PURE__ */ b({
  __name: "RadioGroup",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(uq), A({
      class: l(V)("grid gap-2", n.class)
    }, l(o)), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), gj = /* @__PURE__ */ b({
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(pq), A(l(a), {
      class: l(V)(
        "peer aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        N(l(mq), { class: "flex items-center justify-center" }, {
          default: y(() => [
            N(l(oo), { class: "h-3.5 w-3.5 text-primary" })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Fz = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, yj = /* @__PURE__ */ b({
  __name: "RangeCalendar",
  props: {
    defaultPlaceholder: {},
    defaultValue: {},
    modelValue: {},
    placeholder: {},
    allowNonContiguousRanges: { type: Boolean },
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    maximumDays: {},
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    isDateHighlightable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    disableDaysOutsideCurrentView: { type: Boolean },
    fixedDate: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:validModelValue", "update:placeholder", "update:startValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(WB), A({
      class: l(V)("p-3", n.class)
    }, l(o)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(Wz), null, {
          default: y(() => [
            N(l(Yz)),
            N(l(Gz)),
            N(l(Kz))
          ]),
          _: 1
        }),
        xe("div", Fz, [
          (h(!0), G(Ye, null, Lt(u, (c) => (h(), x(l(zz), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(Uz), null, {
                default: y(() => [
                  N(l(Ym), null, {
                    default: y(() => [
                      (h(!0), G(Ye, null, Lt(d, (f) => (h(), x(l(jz), { key: f }, {
                        default: y(() => [
                          Re(He(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(Hz), null, {
                default: y(() => [
                  (h(!0), G(Ye, null, Lt(c.rows, (f, p) => (h(), x(l(Ym), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (h(!0), G(Ye, null, Lt(f, (v) => (h(), x(l(Nz), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(Lz), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Nz = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(KB), A({
      class: l(V)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:bg-accent first:[&:has([data-selected])]:rounded-l-md last:[&:has([data-selected])]:rounded-r-md [&:has([data-selected][data-outside-view])]:bg-accent/50 [&:has([data-selected][data-selection-end])]:rounded-r-md [&:has([data-selected][data-selection-start])]:rounded-l-md",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Lz = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(XB), A({
      class: l(V)(
        l(Yt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal data-[selected]:opacity-100",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selection Start
        "data-[selection-start]:bg-primary data-[selection-start]:text-primary-foreground data-[selection-start]:hover:bg-primary data-[selection-start]:hover:text-primary-foreground data-[selection-start]:focus:bg-primary data-[selection-start]:focus:text-primary-foreground",
        // Selection End
        "data-[selection-end]:bg-primary data-[selection-end]:text-primary-foreground data-[selection-end]:hover:bg-primary data-[selection-end]:hover:text-primary-foreground data-[selection-end]:focus:bg-primary data-[selection-end]:focus:text-primary-foreground",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), zz = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(ZB), A({
      class: l(V)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Hz = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(eD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Uz = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(nD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ym = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(rD), A({
      class: l(V)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jz = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(sD), A({
      class: l(V)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Wz = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(iD), A({
      class: l(V)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Gz = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(dD), A({
      class: l(V)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(He(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Kz = /* @__PURE__ */ b({
  __name: "RangeCalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(fD), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(za), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Yz = /* @__PURE__ */ b({
  __name: "RangeCalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(vD), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Wi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Xz = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, bj = /* @__PURE__ */ b({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    nonce: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(NE), A(l(o), {
      class: l(V)(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 focus-visible:outline-none [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:translate-x-0 [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]>div]:rotate-90",
        n.class
      )
    }), {
      default: y(() => [
        n.withHandle ? (h(), G("div", Xz, [
          N(l(qO), { class: "h-2.5 w-2.5" })
        ])) : Ee("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), _j = /* @__PURE__ */ b({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(OE), A(l(o), {
      class: l(V)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Jz = /* @__PURE__ */ b({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Oq), A(l(n), {
      class: l(V)(
        "flex touch-none transition-colors select-none",
        e.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        e.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        t.class
      )
    }), {
      default: y(() => [
        N(l(Lq), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), wj = /* @__PURE__ */ b({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(yq), A(l(n), {
      class: l(V)("relative overflow-hidden", t.class)
    }), {
      default: y(() => [
        N(l(Hq), { class: "h-full w-full rounded-[inherit]" }, {
          default: y(() => [
            _(a.$slots, "default")
          ]),
          _: 3
        }),
        N(Jz),
        N(l(xq))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xj = /* @__PURE__ */ b({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    by: { type: [String, Function] },
    dir: {},
    multiple: { type: Boolean },
    autocomplete: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(Yq), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Cj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(k2), null, {
      default: y(() => [
        N(l(d2), A({ ...l(o), ...s.$attrs }, {
          class: l(V)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            e.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: y(() => [
            N(l(e7)),
            N(l(F2), {
              class: re(
                l(V)(
                  "p-1",
                  e.position === "popper" && "h-[--reka-select-trigger-height] w-full min-w-[--reka-select-trigger-width]"
                )
              )
            }, {
              default: y(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(Qz))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Sj = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(v2), A({
      class: l(V)("w-full p-1", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Zz = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, $j = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(b2), A(l(a), {
      class: l(V)(
        "relative flex w-full cursor-default items-center rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        xe("span", Zz, [
          N(l(w2), null, {
            default: y(() => [
              N(l(oo), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        N(l(Gg), null, {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kj = /* @__PURE__ */ b({
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Gg), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Bj = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(S2), {
      class: re(l(V)("px-2 py-1.5 text-sm font-semibold", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Qz = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(P2), A(l(a), {
      class: l(V)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(ji))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), e7 = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(q2), A(l(a), {
      class: l(V)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(MO))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Dj = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(T2), A(l(n), {
      class: l(V)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), Pj = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(I2), A(l(a), {
      class: l(V)(
        "flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-start text-sm whitespace-nowrap shadow-sm ring-offset-background focus:ring-1 focus:ring-ring focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[placeholder]:text-muted-foreground [&>span]:truncate",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(h2), { "as-child": "" }, {
          default: y(() => [
            N(l(ji), { class: "h-4 w-4 shrink-0 opacity-50" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Mj = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(R2), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), t7 = /* @__PURE__ */ b({
  __name: "Sheet",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(bi), A({ "data-slot": "sheet" }, l(r)), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), qj = /* @__PURE__ */ b({
  __name: "SheetClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Va), A({ "data-slot": "sheet-close" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), n7 = /* @__PURE__ */ b({
  __name: "SheetOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(gs), A({
      "data-slot": "sheet-overlay",
      class: l(V)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), a7 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SheetContent",
  props: {
    class: {},
    side: { default: "right" },
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "side"), o = me(r, a);
    return (s, i) => (h(), x(l(xi), null, {
      default: y(() => [
        N(n7),
        N(l(hs), A({
          "data-slot": "sheet-content",
          class: l(V)(
            "fixed z-50 flex flex-col gap-4 bg-background shadow-lg transition ease-in-out data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:animate-in data-[state=open]:duration-500",
            e.side === "right" && "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
            e.side === "left" && "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
            e.side === "top" && "inset-x-0 top-0 h-auto border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
            e.side === "bottom" && "inset-x-0 bottom-0 h-auto border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
            n.class
          )
        }, { ...s.$attrs, ...l(o) }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(Va), { class: "absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none data-[state=open]:bg-secondary" }, {
              default: y(() => [
                N(l(so), { class: "size-4" }),
                i[0] || (i[0] = xe("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Ej = /* @__PURE__ */ b({
  __name: "SheetDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(wi), A({
      "data-slot": "sheet-description",
      class: l(V)("text-sm text-muted-foreground", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Tj = /* @__PURE__ */ b({
  __name: "SheetFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "sheet-footer",
      class: re(l(V)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Aj = /* @__PURE__ */ b({
  __name: "SheetHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "sheet-header",
      class: re(l(V)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Ij = /* @__PURE__ */ b({
  __name: "SheetTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Ci), A({
      "data-slot": "sheet-title",
      class: l(V)("font-semibold text-foreground", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Oj = /* @__PURE__ */ b({
  __name: "SheetTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Si), A({ "data-slot": "sheet-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Xm = "sidebar_state", r7 = 3600 * 24 * 7, o7 = "16rem", s7 = "18rem", l7 = "3rem", i7 = "b", [pu, u7] = Be("Sidebar"), d7 = { class: "flex h-full w-full flex-col" }, c7 = ["data-state", "data-collapsible", "data-variant", "data-side"], f7 = {
  "data-sidebar": "sidebar",
  class: "flex h-full w-full flex-col bg-sidebar text-sidebar-foreground group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
}, Rj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "Sidebar",
  props: {
    side: { default: "left" },
    variant: { default: "sidebar" },
    collapsible: { default: "offcanvas" },
    class: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a, openMobile: r, setOpenMobile: o } = pu();
    return (s, i) => e.collapsible === "none" ? (h(), G("div", A({
      key: 0,
      class: l(V)("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", t.class)
    }, s.$attrs), [
      _(s.$slots, "default")
    ], 16)) : l(n) ? (h(), x(l(t7), A({
      key: 1,
      open: l(r)
    }, s.$attrs, { "onUpdate:open": l(o) }), {
      default: y(() => [
        N(l(a7), {
          "data-sidebar": "sidebar",
          "data-mobile": "true",
          side: e.side,
          class: "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
          style: dt({
            "--sidebar-width": l(s7)
          })
        }, {
          default: y(() => [
            xe("div", d7, [
              _(s.$slots, "default")
            ])
          ]),
          _: 3
        }, 8, ["side", "style"])
      ]),
      _: 3
    }, 16, ["open", "onUpdate:open"])) : (h(), G("div", {
      key: 2,
      class: "group peer hidden md:block",
      "data-state": l(a),
      "data-collapsible": l(a) === "collapsed" ? e.collapsible : "",
      "data-variant": e.variant,
      "data-side": e.side
    }, [
      xe("div", {
        class: re(
          l(V)(
            "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            e.variant === "floating" || e.variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )
        )
      }, null, 2),
      xe("div", A({
        class: l(V)(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          e.side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          e.variant === "floating" || e.variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+_2px)]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          t.class
        )
      }, s.$attrs), [
        xe("div", f7, [
          _(s.$slots, "default")
        ])
      ], 16)
    ], 8, c7));
  }
}), Vj = /* @__PURE__ */ b({
  __name: "SidebarContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "content",
      class: re(
        l(V)(
          "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Fj = /* @__PURE__ */ b({
  __name: "SidebarFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "footer",
      class: re(l(V)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Nj = /* @__PURE__ */ b({
  __name: "SidebarGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "group",
      class: re(l(V)("relative flex w-full min-w-0 flex-col p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Lj = /* @__PURE__ */ b({
  __name: "SidebarGroupAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "group-action",
      as: e.as,
      "as-child": e.asChild,
      class: re(
        l(V)(
          "absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), zj = /* @__PURE__ */ b({
  __name: "SidebarGroupContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "group-content",
      class: re(l(V)("w-full text-sm", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Hj = /* @__PURE__ */ b({
  __name: "SidebarGroupLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "group-label",
      as: e.as,
      "as-child": e.asChild,
      class: re(
        l(V)(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear outline-none focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Uj = /* @__PURE__ */ b({
  __name: "SidebarHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "header",
      class: re(l(V)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), jj = /* @__PURE__ */ b({
  __name: "SidebarInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(u0), {
      "data-sidebar": "input",
      class: re(
        l(V)(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Wj = /* @__PURE__ */ b({
  __name: "SidebarInset",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("main", {
      class: re(
        l(V)(
          "relative flex min-h-svh flex-1 flex-col bg-background",
          "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Gj = /* @__PURE__ */ b({
  __name: "SidebarMenu",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("ul", {
      "data-sidebar": "menu",
      class: re(l(V)("flex w-full min-w-0 flex-col gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Kj = /* @__PURE__ */ b({
  __name: "SidebarMenuAction",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" },
    showOnHover: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "menu-action",
      class: re(
        l(V)(
          "absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          e.showOnHover && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground data-[state=open]:opacity-100 md:opacity-0",
          t.class
        )
      ),
      as: e.as,
      "as-child": e.asChild
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "as", "as-child"]));
  }
}), Yj = /* @__PURE__ */ b({
  __name: "SidebarMenuBadge",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "menu-badge",
      class: re(
        l(V)(
          "pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium text-sidebar-foreground tabular-nums select-none",
          "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Jm = /* @__PURE__ */ b({
  __name: "SidebarMenuButtonChild",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({
      "data-sidebar": "menu-button",
      "data-size": e.size,
      "data-active": e.isActive,
      class: l(V)(l(m7)({ variant: e.variant, size: e.size }), t.class),
      as: e.as,
      "as-child": e.asChild
    }, n.$attrs), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-size", "data-active", "class", "as", "as-child"]));
  }
}), Xj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SidebarMenuButton",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    tooltip: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a } = pu(), r = Z(t, "tooltip");
    return (o, s) => e.tooltip ? (h(), x(l(sb), { key: 1 }, {
      default: y(() => [
        N(l(ib), { "as-child": "" }, {
          default: y(() => [
            N(Jm, oe(le({ ...l(r), ...o.$attrs })), {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }),
        N(l(lb), {
          side: "right",
          align: "center",
          hidden: l(a) !== "collapsed" || l(n)
        }, {
          default: y(() => [
            typeof e.tooltip == "string" ? (h(), G(Ye, { key: 0 }, [
              Re(He(e.tooltip), 1)
            ], 64)) : (h(), x(Tt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        }, 8, ["hidden"])
      ]),
      _: 3
    })) : (h(), x(Jm, oe(A({ key: 0 }, { ...l(r), ...o.$attrs })), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Jj = /* @__PURE__ */ b({
  __name: "SidebarMenuItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("li", {
      "data-sidebar": "menu-item",
      class: re(l(V)("group/menu-item relative", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Zm = /* @__PURE__ */ b({
  __name: "Skeleton",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "skeleton",
      class: re(l(V)("animate-pulse rounded-md bg-primary/10", t.class))
    }, null, 2));
  }
}), Zj = /* @__PURE__ */ b({
  __name: "SidebarMenuSkeleton",
  props: {
    showIcon: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => `${Math.floor(Math.random() * 40) + 50}%`);
    return (a, r) => (h(), G("div", {
      "data-sidebar": "menu-skeleton",
      class: re(l(V)("flex h-8 items-center gap-2 rounded-md px-2", t.class))
    }, [
      e.showIcon ? (h(), x(l(Zm), {
        key: 0,
        class: "size-4 rounded-md",
        "data-sidebar": "menu-skeleton-icon"
      })) : Ee("", !0),
      N(l(Zm), {
        class: "h-4 max-w-[--skeleton-width] flex-1",
        "data-sidebar": "menu-skeleton-text",
        style: dt({ "--skeleton-width": n.value })
      }, null, 8, ["style"])
    ], 2));
  }
}), Qj = /* @__PURE__ */ b({
  __name: "SidebarMenuSub",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("ul", {
      "data-sidebar": "menu-badge",
      class: re(
        l(V)(
          "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), eW = /* @__PURE__ */ b({
  __name: "SidebarMenuSubButton",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    size: { default: "md" },
    isActive: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "menu-sub-button",
      as: e.as,
      "as-child": e.asChild,
      "data-size": e.size,
      "data-active": e.isActive,
      class: re(
        l(V)(
          "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground ring-sidebar-ring outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
          "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
          e.size === "sm" && "text-xs",
          e.size === "md" && "text-sm",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-size", "data-active", "class"]));
  }
}), p7 = {};
function v7(e, t) {
  return h(), G("li", null, [
    _(e.$slots, "default")
  ]);
}
const tW = /* @__PURE__ */ vr(p7, [["render", v7]]), nW = /* @__PURE__ */ b({
  __name: "SidebarProvider",
  props: {
    defaultOpen: { type: Boolean, default: !XA?.cookie.includes(`${Xm}=false`) },
    open: { type: Boolean, default: void 0 },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Pd("(max-width: 768px)"), o = I(!1), s = /* @__PURE__ */ pf(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, document.cookie = `${Xm}=${s.value}; path=/; max-age=${r7}`;
    }
    function u(f) {
      o.value = f;
    }
    function d() {
      return r.value ? u(!o.value) : i(!s.value);
    }
    Eo("keydown", (f) => {
      f.key === i7 && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = E(() => s.value ? "expanded" : "collapsed");
    return u7({
      state: c,
      open: s,
      setOpen: i,
      isMobile: r,
      openMobile: o,
      setOpenMobile: u,
      toggleSidebar: d
    }), (f, p) => (h(), x(l($y), { "delay-duration": 0 }, {
      default: y(() => [
        xe("div", A({
          style: {
            "--sidebar-width": l(o7),
            "--sidebar-width-icon": l(l7)
          },
          class: l(V)(
            "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
            n.class
          )
        }, f.$attrs), [
          _(f.$slots, "default")
        ], 16)
      ]),
      _: 3
    }));
  }
}), aW = /* @__PURE__ */ b({
  __name: "SidebarRail",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = pu();
    return (a, r) => (h(), G("button", {
      "data-sidebar": "rail",
      "aria-label": "Toggle Sidebar",
      tabindex: -1,
      title: "Toggle Sidebar",
      class: re(
        l(V)(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          t.class
        )
      ),
      onClick: r[0] || (r[0] = //@ts-ignore
      (...o) => l(n) && l(n)(...o))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), rW = /* @__PURE__ */ b({
  __name: "SidebarSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Gi), {
      "data-sidebar": "separator",
      class: re(l(V)("mx-2 w-auto bg-sidebar-border", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), oW = /* @__PURE__ */ b({
  __name: "SidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = pu();
    return (a, r) => (h(), x(l(Ui), {
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: re(l(V)("h-7 w-7", t.class)),
      onClick: l(n)
    }, {
      default: y(() => [
        N(l(EO)),
        r[0] || (r[0] = xe("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"]));
  }
}), m7 = sn(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), sW = /* @__PURE__ */ b({
  __name: "Slider",
  props: {
    defaultValue: {},
    modelValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    inverted: { type: Boolean },
    min: {},
    max: {},
    step: {},
    minStepsBetweenThumbs: {},
    thumbAlignment: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(aE), A({
      class: l(V)(
        "relative flex w-full touch-none items-center select-none data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5 data-[orientation=vertical]:flex-col",
        n.class
      )
    }, l(o)), {
      default: y(() => [
        N(l(fE), { class: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20 data-[orientation=vertical]:w-1.5" }, {
          default: y(() => [
            N(l(sE), { class: "absolute h-full bg-primary data-[orientation=vertical]:w-full" })
          ]),
          _: 1
        }),
        (h(!0), G(Ye, null, Lt(e.modelValue, (u, d) => (h(), x(l(dE), {
          key: d,
          class: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50"
        }))), 128))
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), lW = /* @__PURE__ */ b({
  __name: "Sonner",
  props: {
    id: {},
    invert: { type: Boolean },
    theme: {},
    position: {},
    closeButtonPosition: {},
    hotkey: {},
    richColors: { type: Boolean },
    expand: { type: Boolean },
    duration: {},
    gap: {},
    visibleToasts: {},
    closeButton: { type: Boolean },
    toastOptions: {},
    class: {},
    style: {},
    offset: {},
    mobileOffset: {},
    dir: {},
    swipeDirections: {},
    icons: {},
    containerAriaLabel: {}
  },
  setup(e) {
    const n = Z(e, "toastOptions");
    return (a, r) => (h(), x(l(eb), A({
      class: "toaster group",
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, l(n)), {
      "success-icon": y(() => [
        N(l(tb), { class: "size-4" })
      ]),
      "info-icon": y(() => [
        N(l(ab), { class: "size-4" })
      ]),
      "warning-icon": y(() => [
        N(l(ob), { class: "size-4" })
      ]),
      "error-icon": y(() => [
        N(l(rb), { class: "size-4" })
      ]),
      "loading-icon": y(() => [
        xe("div", null, [
          N(l(hf), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": y(() => [
        N(l(so), { class: "size-4" })
      ]),
      _: 1
    }, 16));
  }
}), iW = /* @__PURE__ */ b({
  __name: "Spinner",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(hf), {
      role: "status",
      "aria-label": "Loading",
      class: re(l(V)("size-4 animate-spin", t.class))
    }, null, 8, ["class"]));
  }
}), uW = /* @__PURE__ */ b({
  __name: "Stepper",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    modelValue: {},
    linear: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(UE), A({
      class: l(V)("flex gap-2", n.class)
    }, l(o)), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dW = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(YE), A(l(a), {
      class: l(V)("text-xs text-muted-foreground", t.class)
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cW = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(JE), A(l(a), {
      class: l(V)(
        "inline-flex h-8 w-8 items-center justify-center rounded-full text-muted-foreground/50",
        // Disabled
        "group-data-[disabled]:text-muted-foreground group-data-[disabled]:opacity-50",
        // Active
        "group-data-[state=active]:bg-primary group-data-[state=active]:text-primary-foreground",
        // Completed
        "group-data-[state=completed]:bg-accent group-data-[state=completed]:text-accent-foreground",
        t.class
      )
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fW = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {},
    disabled: { type: Boolean },
    completed: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(GE), A(l(a), {
      class: l(V)("group flex items-center gap-2 data-[disabled]:pointer-events-none", t.class)
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pW = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(QE), A(l(a), {
      class: l(V)(
        "bg-muted",
        // Disabled
        "group-data-[disabled]:bg-muted group-data-[disabled]:opacity-50",
        // Completed
        "group-data-[state=completed]:bg-accent-foreground",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), vW = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(tT), A(l(a), {
      class: l(V)("text-md font-semibold whitespace-nowrap", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), mW = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(aT), A(l(a), {
      class: l(V)("flex flex-col items-center gap-1 rounded-md p-1 text-center", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hW = /* @__PURE__ */ b({
  __name: "Switch",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean },
    id: {},
    value: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(lT), A(l(o), {
      class: l(V)(
        "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
        n.class
      )
    }), {
      default: y(() => [
        N(l(uT), {
          class: re(
            l(V)(
              "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
            )
          )
        }, {
          default: y(() => [
            _(s.$slots, "thumb")
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), h7 = { class: "relative w-full overflow-auto" }, gW = /* @__PURE__ */ b({
  __name: "Table",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", h7, [
      xe("table", {
        class: re(l(V)("w-full caption-bottom text-sm", t.class))
      }, [
        _(n.$slots, "default")
      ], 2)
    ]));
  }
}), yW = /* @__PURE__ */ b({
  __name: "TableBody",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("tbody", {
      class: re(l(V)("[&_tr:last-child]:border-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), g7 = /* @__PURE__ */ b({
  __name: "TableCell",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("td", {
      class: re(
        l(V)(
          "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), bW = /* @__PURE__ */ b({
  __name: "TableHead",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("th", {
      class: re(
        l(V)(
          "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), _W = /* @__PURE__ */ b({
  __name: "TableHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("thead", {
      class: re(l(V)("[&_tr]:border-b", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), wW = /* @__PURE__ */ b({
  __name: "TableFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("tfoot", {
      class: re(l(V)("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), y7 = /* @__PURE__ */ b({
  __name: "TableRow",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("tr", {
      class: re(
        l(V)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", t.class)
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), xW = /* @__PURE__ */ b({
  __name: "TableCaption",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("caption", {
      class: re(l(V)("mt-4 text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), b7 = { class: "flex items-center justify-center py-10" }, CW = /* @__PURE__ */ b({
  __name: "TableEmpty",
  props: {
    class: {},
    colspan: { default: 1 }
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...r } = t;
      return r;
    });
    return (a, r) => (h(), x(y7, null, {
      default: y(() => [
        N(g7, A({
          class: l(V)("p-4 align-middle text-sm whitespace-nowrap text-foreground", t.class)
        }, n.value), {
          default: y(() => [
            xe("div", b7, [
              _(a.$slots, "default")
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), SW = /* @__PURE__ */ b({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(fT), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), $W = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(vT), A({
      class: l(V)(
        "mt-2 ring-offset-background focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none",
        t.class
      )
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kW = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(hT), A(l(n), {
      class: l(V)(
        "inline-flex items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _7 = { class: "truncate" }, BW = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(yT), A(l(a), {
      class: l(V)(
        "inline-flex items-center justify-center rounded-md px-3 py-1 text-sm font-medium whitespace-nowrap ring-offset-background transition-all focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
        t.class
      )
    }), {
      default: y(() => [
        xe("span", _7, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), DW = /* @__PURE__ */ b({
  __name: "TagsInput",
  props: {
    modelValue: {},
    defaultValue: {},
    addOnPaste: { type: Boolean },
    addOnTab: { type: Boolean },
    addOnBlur: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: {},
    dir: {},
    max: {},
    id: {},
    convertValue: { type: Function },
    displayValue: { type: Function },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "invalid", "addTag", "removeTag"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(wT), A(l(o), {
      class: l(V)(
        "flex flex-wrap items-center gap-2 rounded-md border border-input bg-background px-3 py-1.5 text-sm",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PW = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(CT), A(l(a), {
      class: l(V)("min-h-5 flex-1 bg-transparent px-1 text-sm focus:outline-none", t.class)
    }), null, 16, ["class"]));
  }
}), MW = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(kT), A(l(a), {
      class: l(V)(
        "flex h-5 items-center rounded-md bg-secondary ring-offset-background data-[state=active]:ring-2 data-[state=active]:ring-ring data-[state=active]:ring-offset-2",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), qW = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(DT), A(l(a), {
      class: l(V)("mr-1 flex rounded bg-transparent", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(so), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), EW = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(MT), A(l(a), {
      class: l(V)("rounded bg-transparent px-2 py-0.5 text-sm", t.class)
    }), null, 16, ["class"]));
  }
}), TW = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "size", "variant"), o = me(r, a);
    return (s, i) => (h(), x(l(Sy), A(l(o), {
      class: l(V)(l(v0)({ variant: e.variant, size: e.size }), n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), v0 = sn(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 min-w-9 px-2",
        sm: "h-8 min-w-8 px-1.5",
        lg: "h-10 min-w-10 px-2.5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), AW = /* @__PURE__ */ b({
  __name: "ToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {},
    class: {},
    variant: {},
    size: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    Xn("toggleGroup", {
      variant: n.variant,
      size: n.size
    });
    const r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(TT), A(l(o), {
      class: l(V)("flex items-center justify-center gap-1", n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), IW = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e, n = Cn("toggleGroup"), a = Z(t, "class", "size", "variant"), r = he(a);
    return (o, s) => (h(), x(l(OT), A(l(r), {
      class: l(V)(
        l(v0)({
          variant: l(n)?.variant || e.variant,
          size: l(n)?.size || e.size
        }),
        t.class
      )
    }), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
export {
  j7 as Accord,
  FO as Accordion,
  NO as AccordionContent,
  LO as AccordionItem,
  zO as AccordionTrigger,
  G7 as Alert,
  K7 as AlertDescription,
  rI as AlertDialog,
  oI as AlertDialogAction,
  sI as AlertDialogCancel,
  lI as AlertDialogContent,
  iI as AlertDialogDescription,
  uI as AlertDialogFooter,
  dI as AlertDialogHeader,
  cI as AlertDialogTitle,
  A7 as AlertDialogTrigger,
  Y7 as AlertTitle,
  X7 as AspectRatio,
  J7 as Avatar,
  Z7 as AvatarFallback,
  Q7 as AvatarImage,
  eH as Badge,
  tH as Breadcrumb,
  nH as BreadcrumbEllipsis,
  aH as BreadcrumbItem,
  rH as BreadcrumbLink,
  oH as BreadcrumbList,
  sH as BreadcrumbPage,
  lH as BreadcrumbSeparator,
  Ui as Button,
  iH as ButtonGroup,
  uH as ButtonGroupSeparator,
  dH as ButtonGroupText,
  cH as Calendar,
  XO as CalendarCell,
  JO as CalendarCellTrigger,
  ZO as CalendarGrid,
  QO as CalendarGridBody,
  e3 as CalendarGridHead,
  Cv as CalendarGridRow,
  t3 as CalendarHeadCell,
  n3 as CalendarHeader,
  a3 as CalendarHeading,
  r3 as CalendarNextButton,
  o3 as CalendarPrevButton,
  s3 as Card,
  l3 as CardContent,
  fH as CardDescription,
  pH as CardFooter,
  i3 as CardHeader,
  u3 as CardTitle,
  vH as Carousel,
  mH as CarouselContent,
  hH as CarouselItem,
  yH as CarouselNext,
  gH as CarouselPrevious,
  bH as ChartCrosshair,
  _H as ChartLegend,
  wH as ChartSingleTooltip,
  tc as ChartTooltip,
  CH as Checkbox,
  SH as Collapsible,
  $H as CollapsibleContent,
  kH as CollapsibleTrigger,
  BH as Combobox,
  DH as ComboboxAnchor,
  S7 as ComboboxCancel,
  PH as ComboboxEmpty,
  MH as ComboboxGroup,
  qH as ComboboxInput,
  EH as ComboboxItem,
  $7 as ComboboxItemIndicator,
  TH as ComboboxList,
  AH as ComboboxSeparator,
  k7 as ComboboxTrigger,
  cL as Command,
  zH as CommandDialog,
  HH as CommandEmpty,
  UH as CommandGroup,
  jH as CommandInput,
  WH as CommandItem,
  GH as CommandList,
  KH as CommandSeparator,
  YH as CommandShortcut,
  I7 as ConfirmDialog,
  XH as ContextMenu,
  JH as ContextMenuCheckboxItem,
  ZH as ContextMenuContent,
  QH as ContextMenuGroup,
  e9 as ContextMenuItem,
  t9 as ContextMenuLabel,
  n9 as ContextMenuRadioGroup,
  a9 as ContextMenuRadioItem,
  r9 as ContextMenuSeparator,
  o9 as ContextMenuShortcut,
  s9 as ContextMenuSub,
  l9 as ContextMenuSubContent,
  i9 as ContextMenuSubTrigger,
  u9 as ContextMenuTrigger,
  fL as Dialog,
  IH as DialogClose,
  pL as DialogContent,
  OH as DialogDescription,
  RH as DialogFooter,
  VH as DialogHeader,
  FH as DialogScrollContent,
  NH as DialogTitle,
  LH as DialogTrigger,
  d9 as Drawer,
  c9 as DrawerClose,
  f9 as DrawerContent,
  p9 as DrawerDescription,
  v9 as DrawerFooter,
  m9 as DrawerHeader,
  FL as DrawerOverlay,
  h9 as DrawerTitle,
  g9 as DrawerTrigger,
  y9 as DropdownMenu,
  b9 as DropdownMenuCheckboxItem,
  _9 as DropdownMenuContent,
  w9 as DropdownMenuGroup,
  x9 as DropdownMenuItem,
  C9 as DropdownMenuLabel,
  MD as DropdownMenuPortal,
  S9 as DropdownMenuRadioGroup,
  $9 as DropdownMenuRadioItem,
  k9 as DropdownMenuSeparator,
  B9 as DropdownMenuShortcut,
  D9 as DropdownMenuSub,
  P9 as DropdownMenuSubContent,
  M9 as DropdownMenuSubTrigger,
  q9 as DropdownMenuTrigger,
  E9 as Empty,
  T9 as EmptyContent,
  A9 as EmptyDescription,
  I9 as EmptyHeader,
  O9 as EmptyMedia,
  R9 as EmptyTitle,
  i0 as FORM_ITEM_INJECTION_KEY,
  V9 as Field,
  F9 as FieldContent,
  N9 as FieldDescription,
  L9 as FieldError,
  z9 as FieldGroup,
  H9 as FieldLabel,
  U9 as FieldLegend,
  j9 as FieldSeparator,
  W9 as FieldSet,
  G9 as FieldTitle,
  H7 as Flasher,
  Y9 as Form,
  J9 as FormControl,
  Z9 as FormDescription,
  K9 as FormField,
  X9 as FormFieldArray,
  Q9 as FormItem,
  eU as FormLabel,
  tU as FormMessage,
  R7 as Header,
  U7 as Heading,
  nU as HoverCard,
  aU as HoverCardContent,
  rU as HoverCardTrigger,
  u0 as Input,
  oU as InputGroup,
  sU as InputGroupAddon,
  lU as InputGroupButton,
  iU as InputGroupInput,
  uU as InputGroupText,
  dU as InputGroupTextarea,
  cU as InputOTP,
  fU as InputOTPGroup,
  pU as InputOTPSeparator,
  vU as InputOTPSlot,
  mU as Item,
  hU as ItemActions,
  gU as ItemContent,
  yU as ItemDescription,
  bU as ItemFooter,
  _U as ItemGroup,
  wU as ItemHeader,
  xU as ItemMedia,
  CU as ItemSeparator,
  SU as ItemTitle,
  $U as Kbd,
  kU as KbdGroup,
  G_ as Label,
  V7 as Main,
  BU as Menubar,
  DU as MenubarCheckboxItem,
  PU as MenubarContent,
  MU as MenubarGroup,
  qU as MenubarItem,
  EU as MenubarLabel,
  TU as MenubarMenu,
  AU as MenubarRadioGroup,
  IU as MenubarRadioItem,
  OU as MenubarSeparator,
  RU as MenubarShortcut,
  VU as MenubarSub,
  FU as MenubarSubContent,
  NU as MenubarSubTrigger,
  LU as MenubarTrigger,
  zU as NavigationMenu,
  HU as NavigationMenuContent,
  UU as NavigationMenuIndicator,
  jU as NavigationMenuItem,
  WU as NavigationMenuLink,
  GU as NavigationMenuList,
  KU as NavigationMenuTrigger,
  Rz as NavigationMenuViewport,
  YU as NumberField,
  XU as NumberFieldContent,
  JU as NumberFieldDecrement,
  ZU as NumberFieldIncrement,
  QU as NumberFieldInput,
  ej as Pagination,
  tj as PaginationContent,
  nj as PaginationEllipsis,
  aj as PaginationFirst,
  rj as PaginationItem,
  oj as PaginationLast,
  sj as PaginationNext,
  lj as PaginationPrevious,
  ij as PinInput,
  uj as PinInputGroup,
  dj as PinInputSeparator,
  cj as PinInputSlot,
  fj as Popover,
  B7 as PopoverAnchor,
  pj as PopoverContent,
  vj as PopoverTrigger,
  mj as Progress,
  hj as RadioGroup,
  gj as RadioGroupItem,
  yj as RangeCalendar,
  Nz as RangeCalendarCell,
  Lz as RangeCalendarCellTrigger,
  zz as RangeCalendarGrid,
  Hz as RangeCalendarGridBody,
  Uz as RangeCalendarGridHead,
  Ym as RangeCalendarGridRow,
  jz as RangeCalendarHeadCell,
  Wz as RangeCalendarHeader,
  Gz as RangeCalendarHeading,
  Kz as RangeCalendarNextButton,
  Yz as RangeCalendarPrevButton,
  bj as ResizableHandle,
  D7 as ResizablePanel,
  _j as ResizablePanelGroup,
  wj as ScrollArea,
  Jz as ScrollBar,
  xj as Select,
  Cj as SelectContent,
  Sj as SelectGroup,
  $j as SelectItem,
  kj as SelectItemText,
  Bj as SelectLabel,
  Qz as SelectScrollDownButton,
  e7 as SelectScrollUpButton,
  Dj as SelectSeparator,
  Pj as SelectTrigger,
  Mj as SelectValue,
  Gi as Separator,
  t7 as Sheet,
  qj as SheetClose,
  a7 as SheetContent,
  Ej as SheetDescription,
  Tj as SheetFooter,
  Aj as SheetHeader,
  n7 as SheetOverlay,
  Ij as SheetTitle,
  Oj as SheetTrigger,
  Rj as Sidebar,
  Vj as SidebarContent,
  Fj as SidebarFooter,
  Nj as SidebarGroup,
  Lj as SidebarGroupAction,
  zj as SidebarGroupContent,
  Hj as SidebarGroupLabel,
  Uj as SidebarHeader,
  jj as SidebarInput,
  Wj as SidebarInset,
  Gj as SidebarMenu,
  Kj as SidebarMenuAction,
  Yj as SidebarMenuBadge,
  Xj as SidebarMenuButton,
  Jj as SidebarMenuItem,
  Zj as SidebarMenuSkeleton,
  Qj as SidebarMenuSub,
  eW as SidebarMenuSubButton,
  tW as SidebarMenuSubItem,
  nW as SidebarProvider,
  aW as SidebarRail,
  rW as SidebarSeparator,
  oW as SidebarTrigger,
  Zm as Skeleton,
  sW as Slider,
  iW as Spinner,
  uW as Stepper,
  dW as StepperDescription,
  cW as StepperIndicator,
  fW as StepperItem,
  pW as StepperSeparator,
  vW as StepperTitle,
  mW as StepperTrigger,
  hW as Switch,
  gW as Table,
  yW as TableBody,
  xW as TableCaption,
  g7 as TableCell,
  CW as TableEmpty,
  wW as TableFooter,
  bW as TableHead,
  _W as TableHeader,
  y7 as TableRow,
  SW as Tabs,
  $W as TabsContent,
  kW as TabsList,
  BW as TabsTrigger,
  DW as TagsInput,
  PW as TagsInputInput,
  MW as TagsInputItem,
  qW as TagsInputItemDelete,
  EW as TagsInputItemText,
  nz as Textarea,
  W7 as Tip,
  lW as Toaster,
  TW as Toggle,
  AW as ToggleGroup,
  IW as ToggleGroupItem,
  sb as Tooltip,
  lb as TooltipContent,
  HO as TooltipProvider,
  ib as TooltipTrigger,
  O7 as TwoColumnLayout,
  F7 as TwoColumnLayoutSidebar,
  N7 as TwoColumnLayoutSidebarDesktop,
  L7 as TwoColumnLayoutSidebarMobile,
  z7 as TwoColumnLayoutSidebarTrigger,
  UO as alertVariants,
  jO as avatarVariant,
  WO as badgeVariants,
  KO as buttonGroupVariants,
  Yt as buttonVariants,
  V as cn,
  M7 as createContext,
  xH as defaultColors,
  HL as emptyMediaVariants,
  YL as fieldVariants,
  az as inputGroupAddonVariants,
  rz as inputGroupButtonVariants,
  Tz as itemMediaVariants,
  Ez as itemVariants,
  Vz as navigationMenuTriggerStyle,
  x7 as preset,
  hL as provideCommandContext,
  yL as provideCommandGroupContext,
  m7 as sidebarMenuButtonVariants,
  v0 as toggleVariants,
  Yi as useCarousel,
  uu as useCommand,
  gL as useCommandGroup,
  vI as useConfirmDialog,
  OO as useFlasher,
  T7 as useMobileBottomNav,
  q7 as useMobileNavigation,
  pu as useSidebar,
  E7 as useSwipeNavigation,
  P7 as valueUpdater
};
