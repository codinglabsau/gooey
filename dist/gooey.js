import * as fp from "vue";
import { inject as Cn, provide as Xn, Fragment as Ke, shallowRef as gt, readonly as or, toValue as fe, getCurrentScope as ss, onScopeDispose as ic, customRef as hi, watch as ve, nextTick as Be, effectScope as oh, computed as E, watchEffect as Ie, onBeforeUnmount as sr, isRef as mt, reactive as Wt, unref as l, getCurrentInstance as ht, toRef as jn, ref as I, toRefs as Me, onMounted as Ce, toHandlerKey as b0, camelize as Sl, onUnmounted as Qe, defineComponent as b, h as an, Comment as _0, mergeProps as A, cloneVNode as w0, createBlock as x, openBlock as h, withCtx as y, renderSlot as _, createVNode as N, createCommentVNode as Ee, withKeys as Je, normalizeStyle as dt, Teleport as gi, normalizeProps as oe, guardReactiveProps as le, withModifiers as Ye, createElementBlock as W, withDirectives as uc, vShow as x0, createElementVNode as we, toDisplayString as Ne, createTextVNode as Re, markRaw as C0, renderList as Lt, resolveDynamicComponent as Pt, watchPostEffect as sh, shallowReadonly as br, mergeDefaults as lh, watchSyncEffect as S0, withMemo as $0, onBeforeMount as k0, toRaw as B0, toHandlers as D0, hasInjectionContext as ih, onUpdated as P0, normalizeClass as ae, useAttrs as M0, isVNode as fo, createApp as id, useSlots as E0, warn as uh, vModelText as dh, mergeModels as pp, useModel as q0 } from "vue";
function ch(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var bu, vp;
function T0() {
  if (vp) return bu;
  vp = 1;
  function e(n, a) {
    return { handler: n, config: a };
  }
  e.withOptions = function(n, a = () => ({})) {
    function r(o) {
      return { handler: n(o), config: a(o) };
    }
    return r.__isOptionsFunction = !0, r;
  };
  var t = e;
  return bu = t, bu;
}
var _u, mp;
function A0() {
  if (mp) return _u;
  mp = 1;
  const e = T0();
  function t(n) {
    return Object.fromEntries(
      Object.entries(n).filter(([a]) => a !== "DEFAULT")
    );
  }
  return _u = e(
    ({ addUtilities: n, matchUtilities: a, theme: r }) => {
      n({
        "@keyframes enter": r("keyframes.enter"),
        "@keyframes exit": r("keyframes.exit"),
        ".animate-in": {
          animationName: "enter",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-enter-opacity": "initial",
          "--tw-enter-scale": "initial",
          "--tw-enter-rotate": "initial",
          "--tw-enter-translate-x": "initial",
          "--tw-enter-translate-y": "initial"
        },
        ".animate-out": {
          animationName: "exit",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-exit-opacity": "initial",
          "--tw-exit-scale": "initial",
          "--tw-exit-rotate": "initial",
          "--tw-exit-translate-x": "initial",
          "--tw-exit-translate-y": "initial"
        }
      }), a(
        {
          "fade-in": (o) => ({ "--tw-enter-opacity": o }),
          "fade-out": (o) => ({ "--tw-exit-opacity": o })
        },
        { values: r("animationOpacity") }
      ), a(
        {
          "zoom-in": (o) => ({ "--tw-enter-scale": o }),
          "zoom-out": (o) => ({ "--tw-exit-scale": o })
        },
        { values: r("animationScale") }
      ), a(
        {
          "spin-in": (o) => ({ "--tw-enter-rotate": o }),
          "spin-out": (o) => ({ "--tw-exit-rotate": o })
        },
        { values: r("animationRotate") }
      ), a(
        {
          "slide-in-from-top": (o) => ({
            "--tw-enter-translate-y": `-${o}`
          }),
          "slide-in-from-bottom": (o) => ({
            "--tw-enter-translate-y": o
          }),
          "slide-in-from-left": (o) => ({
            "--tw-enter-translate-x": `-${o}`
          }),
          "slide-in-from-right": (o) => ({
            "--tw-enter-translate-x": o
          }),
          "slide-out-to-top": (o) => ({
            "--tw-exit-translate-y": `-${o}`
          }),
          "slide-out-to-bottom": (o) => ({
            "--tw-exit-translate-y": o
          }),
          "slide-out-to-left": (o) => ({
            "--tw-exit-translate-x": `-${o}`
          }),
          "slide-out-to-right": (o) => ({
            "--tw-exit-translate-x": o
          })
        },
        { values: r("animationTranslate") }
      ), a(
        { duration: (o) => ({ animationDuration: o }) },
        { values: t(r("animationDuration")) }
      ), a(
        { delay: (o) => ({ animationDelay: o }) },
        { values: r("animationDelay") }
      ), a(
        { ease: (o) => ({ animationTimingFunction: o }) },
        { values: t(r("animationTimingFunction")) }
      ), n({
        ".running": { animationPlayState: "running" },
        ".paused": { animationPlayState: "paused" }
      }), a(
        { "fill-mode": (o) => ({ animationFillMode: o }) },
        { values: r("animationFillMode") }
      ), a(
        { direction: (o) => ({ animationDirection: o }) },
        { values: r("animationDirection") }
      ), a(
        { repeat: (o) => ({ animationIterationCount: o }) },
        { values: r("animationRepeat") }
      );
    },
    {
      theme: {
        extend: {
          animationDelay: ({ theme: n }) => ({
            ...n("transitionDelay")
          }),
          animationDuration: ({ theme: n }) => ({
            0: "0ms",
            ...n("transitionDuration")
          }),
          animationTimingFunction: ({ theme: n }) => ({
            ...n("transitionTimingFunction")
          }),
          animationFillMode: {
            none: "none",
            forwards: "forwards",
            backwards: "backwards",
            both: "both"
          },
          animationDirection: {
            normal: "normal",
            reverse: "reverse",
            alternate: "alternate",
            "alternate-reverse": "alternate-reverse"
          },
          animationOpacity: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("opacity")
          }),
          animationTranslate: ({ theme: n }) => ({
            DEFAULT: "100%",
            ...n("translate")
          }),
          animationScale: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("scale")
          }),
          animationRotate: ({ theme: n }) => ({
            DEFAULT: "30deg",
            ...n("rotate")
          }),
          animationRepeat: {
            0: "0",
            1: "1",
            infinite: "infinite"
          },
          keyframes: {
            enter: {
              from: {
                opacity: "var(--tw-enter-opacity, 1)",
                transform: "translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))"
              }
            },
            exit: {
              to: {
                opacity: "var(--tw-exit-opacity, 1)",
                transform: "translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))"
              }
            }
          }
        }
      }
    }
  ), _u;
}
var I0 = A0();
const O0 = /* @__PURE__ */ ch(I0), OH = {
  darkMode: ["class"],
  safelist: ["dark"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))"
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))"
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))"
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))"
        }
      },
      borderRadius: {
        xl: "calc(var(--radius) + 4px)",
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" }
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }
        },
        "collapsible-down": {
          from: { height: "0" },
          to: { height: "var(--radix-collapsible-content-height)" }
        },
        "collapsible-up": {
          from: { height: "var(--radix-collapsible-content-height)" },
          to: { height: "0" }
        }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "collapsible-down": "collapsible-down 0.2s ease-in-out",
        "collapsible-up": "collapsible-up 0.2s ease-in-out"
      }
    }
  },
  plugins: [O0]
};
function hp(e) {
  return typeof e == "string" ? `'${e}'` : new R0().serialize(e);
}
const R0 = /* @__PURE__ */ (function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(n, a) {
      const r = typeof n, o = typeof a;
      return r === "string" && o === "string" ? n.localeCompare(a) : r === "number" && o === "number" ? n - a : String.prototype.localeCompare.call(this.serialize(n, !0), this.serialize(a, !0));
    }
    serialize(n, a) {
      if (n === null) return "null";
      switch (typeof n) {
        case "string":
          return a ? n : `'${n}'`;
        case "bigint":
          return `${n}n`;
        case "object":
          return this.$object(n);
        case "function":
          return this.$function(n);
      }
      return String(n);
    }
    serializeObject(n) {
      const a = Object.prototype.toString.call(n);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), n);
      const r = n.constructor, o = r === Object || r === void 0 ? "" : r.name;
      if (o !== "" && globalThis[o] === r) return this.serializeBuiltInType(o, n);
      if (typeof n.toJSON == "function") {
        const s = n.toJSON();
        return o + (s !== null && typeof s == "object" ? this.$object(s) : `(${this.serialize(s)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(n));
    }
    serializeBuiltInType(n, a) {
      const r = this["$" + n];
      if (r) return r.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(n, a.entries());
      throw new Error(`Cannot serialize ${n}`);
    }
    serializeObjectEntries(n, a) {
      const r = Array.from(a).sort((s, i) => this.compare(s[0], i[0]));
      let o = `${n}{`;
      for (let s = 0; s < r.length; s++) {
        const [i, u] = r[s];
        o += `${this.serialize(i, !0)}:${this.serialize(u)}`, s < r.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(n) {
      let a = this.#e.get(n);
      return a === void 0 && (this.#e.set(n, `#${this.#e.size}`), a = this.serializeObject(n), this.#e.set(n, a)), a;
    }
    $function(n) {
      const a = Function.prototype.toString.call(n);
      return a.slice(-15) === "[native code] }" ? `${n.name || ""}()[native]` : `${n.name}(${n.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(n) {
      let a = "[";
      for (let r = 0; r < n.length; r++) a += this.serialize(n[r]), r < n.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(n) {
      try {
        return `Date(${n.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(n) {
      return `ArrayBuffer[${new Uint8Array(n).join(",")}]`;
    }
    $Set(n) {
      return `Set${this.$Array(Array.from(n).sort((a, r) => this.compare(a, r)))}`;
    }
    $Map(n) {
      return this.serializeObjectEntries("Map", n.entries());
    }
  }
  for (const t of ["Error", "RegExp", "URL"]) e.prototype["$" + t] = function(n) {
    return `${t}(${n})`;
  };
  for (const t of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join(",")}]`;
  };
  for (const t of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join("n,")}${n.length > 0 ? "n" : ""}]`;
  };
  return e;
})();
function qn(e, t) {
  return e === t || hp(e) === hp(t);
}
function V0(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function F0(e, t, n) {
  const a = e.findIndex((i) => qn(i, t)), r = e.findIndex((i) => qn(i, n));
  if (a === -1 || r === -1) return [];
  const [o, s] = [a, r].sort((i, u) => i - u);
  return e.slice(o, s + 1);
}
const ls = typeof document < "u";
function Rr(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e));
}
function Os(e, t) {
  let n = e;
  const a = t.toString(), r = a.indexOf("."), o = r >= 0 ? a.length - r : 0;
  if (o > 0) {
    const s = 10 ** o;
    n = Math.round(n * s) / s;
  }
  return n;
}
function N0(e, t, n, a) {
  t = Number(t), n = Number(n);
  const r = (e - (Number.isNaN(t) ? 0 : t)) % a;
  let o = Os(Math.abs(r) * 2 >= a ? e + Math.sign(r) * (a - Math.abs(r)) : e - r, a);
  return Number.isNaN(t) ? !Number.isNaN(n) && o > n && (o = Math.floor(Os(n / a, a)) * a) : o < t ? o = t : !Number.isNaN(n) && o > n && (o = t + Math.floor(Os((n - t) / a, a)) * a), o = Os(o, a), o;
}
function Se(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = Cn(a, s);
    if (i || i === null) return i;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (s) => (Xn(a, s), s)];
}
function ot() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function is(e, t, n) {
  const a = n.originalEvent.target, r = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(r);
}
function Mn(e) {
  return e == null;
}
function $l(e, t) {
  return Mn(e) ? !1 : Array.isArray(e) ? e.some((n) => qn(n, t)) : qn(e, t);
}
function dc(e) {
  return e ? e.flatMap((t) => t.type === Ke ? dc(t.children) : [t]) : [];
}
const L0 = ["INPUT", "TEXTAREA"];
function lr(e, t, n, a = {}) {
  if (!t || a.enableIgnoredElement && L0.includes(t.nodeName)) return null;
  const { arrowKeyOptions: r = "both", attributeName: o = "[data-reka-collection-item]", itemsArray: s = [], loop: i = !0, dir: u = "ltr", preventScroll: d = !0, focus: c = !1 } = a, [f, p, v, m, g, w] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ], C = v || m, S = f || p;
  if (!g && !w && (!C && !S || r === "vertical" && S || r === "horizontal" && C)) return null;
  const $ = n ? Array.from(n.querySelectorAll(o)) : s;
  if (!$.length) return null;
  d && e.preventDefault();
  let B = null;
  return S || C ? B = fh($, t, {
    goForward: C ? m : u === "ltr" ? f : p,
    loop: i
  }) : g ? B = $.at(0) || null : w && (B = $.at(-1) || null), c && B?.focus(), B;
}
function fh(e, t, n, a = e.length) {
  if (--a === 0) return null;
  const r = e.indexOf(t), o = n.goForward ? r + 1 : r - 1;
  if (!n.loop && (o < 0 || o >= e.length)) return null;
  const s = (o + e.length) % e.length, i = e[s];
  return i ? i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false" ? fh(e, i, n, a) : i : null;
}
const [us] = Se("ConfigProvider");
function z0(e, t) {
  var n;
  const a = gt();
  return Ie(() => {
    a.value = e();
  }, {
    ...t,
    flush: (n = void 0) != null ? n : "sync"
  }), or(a);
}
function ga(e) {
  return ss() ? (ic(e), !0) : !1;
}
function Dr() {
  const e = /* @__PURE__ */ new Set(), t = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const s = () => t(o);
      return ga(s), {
        off: s
      };
    },
    off: t,
    trigger: (...o) => Promise.all(Array.from(e).map((s) => s(...o))),
    clear: () => {
      e.clear();
    }
  };
}
function H0(e) {
  let t = !1, n;
  const a = oh(!0);
  return (...r) => (t || (n = a.run(() => e(...r)), t = !0), n);
}
function ph(e) {
  let t = 0, n, a;
  const r = () => {
    t -= 1, a && t <= 0 && (a.stop(), n = void 0, a = void 0);
  };
  return (...o) => (t += 1, a || (a = oh(!0), n = a.run(() => e(...o))), ga(r), n);
}
function U0(e) {
  if (!mt(e))
    return Wt(e);
  const t = new Proxy({}, {
    get(n, a, r) {
      return l(Reflect.get(e.value, a, r));
    },
    set(n, a, r) {
      return mt(e.value[a]) && !mt(r) ? e.value[a].value = r : e.value[a] = r, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Wt(t);
}
function cc(e) {
  return U0(E(e));
}
function ds(e, ...t) {
  const n = t.flat(), a = n[0];
  return cc(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(fe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
const rn = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const j0 = (e) => typeof e < "u", W0 = (e) => e != null, G0 = Object.prototype.toString, K0 = (e) => G0.call(e) === "[object Object]", kl = () => {
}, gp = /* @__PURE__ */ Y0();
function Y0() {
  var e, t;
  return rn && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window?.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function vh(e, t) {
  function n(...a) {
    return new Promise((r, o) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(r).catch(o);
    });
  }
  return n;
}
const mh = (e) => e();
function X0(e, t = {}) {
  let n, a, r = kl;
  const o = (u) => {
    clearTimeout(u), r(), r = kl;
  };
  let s;
  return (u) => {
    const d = fe(e), c = fe(t.maxWait);
    return n && o(n), d <= 0 || c !== void 0 && c <= 0 ? (a && (o(a), a = null), Promise.resolve(u())) : new Promise((f, p) => {
      r = t.rejectOnCancel ? p : f, s = u, c && !a && (a = setTimeout(() => {
        n && o(n), a = null, f(s());
      }, c)), n = setTimeout(() => {
        a && o(a), a = null, f(u());
      }, d);
    });
  };
}
function J0(e = mh, t = {}) {
  const {
    initialState: n = "active"
  } = t, a = Q0(n === "active");
  function r() {
    a.value = !1;
  }
  function o() {
    a.value = !0;
  }
  const s = (...i) => {
    a.value && e(...i);
  };
  return { isActive: or(a), pause: r, resume: o, eventFilter: s };
}
function Z0(e) {
  return ht();
}
function il(e) {
  return Array.isArray(e) ? e : [e];
}
function Q0(...e) {
  if (e.length !== 1)
    return jn(...e);
  const t = e[0];
  return typeof t == "function" ? or(hi(() => ({ get: t, set: kl }))) : I(t);
}
function cs(e, t = 1e4) {
  return hi((n, a) => {
    let r = fe(e), o;
    const s = () => setTimeout(() => {
      r = fe(e), a();
    }, fe(t));
    return ga(() => {
      clearTimeout(o);
    }), {
      get() {
        return n(), r;
      },
      set(i) {
        r = i, a(), clearTimeout(o), o = s();
      }
    };
  });
}
function fc(e, t = 200, n = {}) {
  return vh(
    X0(t, n),
    e
  );
}
function ew(e, t, n = {}) {
  const {
    eventFilter: a = mh,
    ...r
  } = n;
  return ve(
    e,
    vh(
      a,
      t
    ),
    r
  );
}
function yp(e, t, n = {}) {
  const {
    eventFilter: a,
    initialState: r = "active",
    ...o
  } = n, { eventFilter: s, pause: i, resume: u, isActive: d } = J0(a, { initialState: r });
  return { stop: ew(
    e,
    t,
    {
      ...o,
      eventFilter: s
    }
  ), pause: i, resume: u, isActive: d };
}
function tw(e, t, ...[n]) {
  const {
    flush: a = "sync",
    deep: r = !1,
    immediate: o = !0,
    direction: s = "both",
    transform: i = {}
  } = n || {}, u = [], d = "ltr" in i && i.ltr || ((p) => p), c = "rtl" in i && i.rtl || ((p) => p);
  return (s === "both" || s === "ltr") && u.push(yp(
    e,
    (p) => {
      u.forEach((v) => v.pause()), t.value = d(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: r, immediate: o }
  )), (s === "both" || s === "rtl") && u.push(yp(
    t,
    (p) => {
      u.forEach((v) => v.pause()), e.value = c(p), u.forEach((v) => v.resume());
    },
    { flush: a, deep: r, immediate: o }
  )), () => {
    u.forEach((p) => p.stop());
  };
}
function nw(e, t) {
  Z0() && sr(e, t);
}
function hh(e, t, n = {}) {
  const {
    immediate: a = !0,
    immediateCallback: r = !1
  } = n, o = gt(!1);
  let s = null;
  function i() {
    s && (clearTimeout(s), s = null);
  }
  function u() {
    o.value = !1, i();
  }
  function d(...c) {
    r && e(), i(), o.value = !0, s = setTimeout(() => {
      o.value = !1, s = null, e(...c);
    }, fe(t));
  }
  return a && (o.value = !0, rn && d()), ga(u), {
    isPending: or(o),
    start: d,
    stop: u
  };
}
function aw(e, t, n) {
  return ve(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
function rw(e, t, n) {
  const a = ve(e, (...r) => (Be(() => a()), t(...r)), n);
  return a;
}
const Ra = rn ? window : void 0;
function Gt(e) {
  var t;
  const n = fe(e);
  return (t = n?.$el) != null ? t : n;
}
function zt(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), r = E(() => {
    const i = il(fe(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), o = aw(
    () => {
      var i, u;
      return [
        (u = (i = r.value) == null ? void 0 : i.map((d) => Gt(d))) != null ? u : [Ra].filter((d) => d != null),
        il(fe(r.value ? e[1] : e[0])),
        il(l(r.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        fe(r.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !i?.length || !u?.length || !d?.length)
        return;
      const f = K0(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return ga(n), s;
}
function pc() {
  const e = gt(!1), t = ht();
  return t && Ce(() => {
    e.value = !0;
  }, t), e;
}
function gh(e) {
  const t = pc();
  return E(() => (t.value, !!e()));
}
function ow(e, t, n = {}) {
  const { window: a = Ra, ...r } = n;
  let o;
  const s = gh(() => a && "MutationObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = E(() => {
    const p = fe(e), v = il(p).map(Gt).filter(W0);
    return new Set(v);
  }), d = ve(
    () => u.value,
    (p) => {
      i(), s.value && p.size && (o = new MutationObserver(t), p.forEach((v) => o.observe(v, r)));
    },
    { immediate: !0, flush: "post" }
  ), c = () => o?.takeRecords(), f = () => {
    d(), i();
  };
  return ga(f), {
    isSupported: s,
    stop: f,
    takeRecords: c
  };
}
function sw(e, t, n = {}) {
  const {
    window: a = Ra,
    document: r = a?.document,
    flush: o = "sync"
  } = n;
  if (!a || !r)
    return kl;
  let s;
  const i = (c) => {
    s?.(), s = c;
  }, u = Ie(() => {
    const c = Gt(e);
    if (c) {
      const { stop: f } = ow(
        r,
        (p) => {
          p.map((m) => [...m.removedNodes]).flat().some((m) => m === c || m.contains(c)) && t(p);
        },
        {
          window: a,
          childList: !0,
          subtree: !0
        }
      );
      i(f);
    }
  }, { flush: o }), d = () => {
    u(), i();
  };
  return ga(d), d;
}
function lw(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function iw(...e) {
  let t, n, a = {};
  e.length === 3 ? (t = e[0], n = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], a = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: r = Ra,
    eventName: o = "keydown",
    passive: s = !1,
    dedupe: i = !1
  } = a, u = lw(t);
  return zt(r, o, (c) => {
    c.repeat && fe(i) || u(c) && n(c);
  }, s);
}
function uw(e = {}) {
  var t;
  const {
    window: n = Ra,
    deep: a = !0,
    triggerOnRemoval: r = !1
  } = e, o = (t = e.document) != null ? t : n?.document, s = () => {
    var d;
    let c = o?.activeElement;
    if (a)
      for (; c?.shadowRoot; )
        c = (d = c?.shadowRoot) == null ? void 0 : d.activeElement;
    return c;
  }, i = gt(), u = () => {
    i.value = s();
  };
  if (n) {
    const d = {
      capture: !0,
      passive: !0
    };
    zt(
      n,
      "blur",
      (c) => {
        c.relatedTarget === null && u();
      },
      d
    ), zt(
      n,
      "focus",
      u,
      d
    );
  }
  return r && sw(i, u, { document: o }), u(), i;
}
function dw(e) {
  return JSON.parse(JSON.stringify(e));
}
function Tn(e, t, n = {}) {
  const { window: a = Ra, ...r } = n;
  let o;
  const s = gh(() => a && "ResizeObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = E(() => {
    const f = fe(e);
    return Array.isArray(f) ? f.map((p) => Gt(p)) : [Gt(f)];
  }), d = ve(
    u,
    (f) => {
      if (i(), s.value && a) {
        o = new ResizeObserver(t);
        for (const p of f)
          p && o.observe(p, r);
      }
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    i(), d();
  };
  return ga(c), {
    isSupported: s,
    stop: c
  };
}
const cw = "focusin", fw = "focusout", pw = ":focus-within";
function vw(e, t = {}) {
  const { window: n = Ra } = t, a = E(() => Gt(e)), r = gt(!1), o = E(() => r.value), s = uw(t);
  if (!n || !s.value)
    return { focused: o };
  const i = { passive: !0 };
  return zt(a, cw, () => r.value = !0, i), zt(a, fw, () => {
    var u, d, c;
    return r.value = (c = (d = (u = a.value) == null ? void 0 : u.matches) == null ? void 0 : d.call(u, pw)) != null ? c : !1;
  }, i), { focused: o };
}
function Ve(e, t, n, a = {}) {
  var r, o, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = ht(), m = n || v?.emit || ((r = v?.$emit) == null ? void 0 : r.bind(v)) || ((s = (o = v?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(v?.proxy));
  let g = d;
  t || (t = "modelValue"), g = g || `update:${t.toString()}`;
  const w = ($) => i ? typeof i == "function" ? i($) : dw($) : $, C = () => j0(e[t]) ? w(e[t]) : f, S = ($) => {
    p ? p($) && m(g, $) : m(g, $);
  };
  if (u) {
    const $ = C(), B = I($);
    let k = !1;
    return ve(
      () => e[t],
      (P) => {
        k || (k = !0, B.value = w(P), Be(() => k = !1));
      }
    ), ve(
      B,
      (P) => {
        !k && (P !== e[t] || c) && S(P);
      },
      { deep: c }
    ), B;
  } else
    return E({
      get() {
        return C();
      },
      set($) {
        S($);
      }
    });
}
function wu(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function ud(e, t, n = ".", a) {
  if (!wu(t))
    return ud(e, {}, n, a);
  const r = Object.assign({}, t);
  for (const o in e) {
    if (o === "__proto__" || o === "constructor")
      continue;
    const s = e[o];
    s != null && (a && a(r, o, s, n) || (Array.isArray(s) && Array.isArray(r[o]) ? r[o] = [...s, ...r[o]] : wu(s) && wu(r[o]) ? r[o] = ud(
      s,
      r[o],
      (n ? `${n}.` : "") + o.toString(),
      a
    ) : r[o] = s));
  }
  return r;
}
function mw(e) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((n, a) => ud(n, a, "", e), {})
  );
}
const hw = mw(), gw = ph(() => {
  const e = I(/* @__PURE__ */ new Map()), t = I(), n = E(() => {
    for (const s of e.value.values()) if (s) return !0;
    return !1;
  }), a = us({ scrollBody: I(!0) });
  let r = null;
  const o = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", gp && r?.(), t.value = void 0;
  };
  return ve(n, (s, i) => {
    if (!rn) return;
    if (!s) {
      i && o();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const u = window.innerWidth - document.documentElement.clientWidth, d = {
      padding: u,
      margin: 0
    }, c = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? hw({
      padding: a.scrollBody.value.padding === !0 ? u : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? u : a.scrollBody.value.margin
    }, d) : d : {
      padding: 0,
      margin: 0
    };
    u > 0 && (document.body.style.paddingRight = typeof c.padding == "number" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == "number" ? `${c.margin}px` : String(c.margin), document.documentElement.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), gp && (r = zt(document, "touchmove", (f) => yw(f), { passive: !1 })), Be(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function fs(e) {
  const t = Math.random().toString(36).substring(2, 7), n = gw();
  n.value.set(t, e ?? !1);
  const a = E({
    get: () => n.value.get(t) ?? !1,
    set: (r) => n.value.set(t, r)
  });
  return nw(() => {
    n.value.delete(t);
  }), a;
}
function yh(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : yh(n);
  }
}
function yw(e) {
  const t = e || window.event, n = t.target;
  return n instanceof Element && yh(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);
}
function Pr(e, t) {
  return e - t * Math.floor(e / t);
}
const bh = 1721426;
function Ka(e, t, n, a) {
  t = ps(e, t);
  let r = t - 1, o = -2;
  return n <= 2 ? o = 0 : Ma(t) && (o = -1), bh - 1 + 365 * r + Math.floor(r / 4) - Math.floor(r / 100) + Math.floor(r / 400) + Math.floor((367 * n - 362) / 12 + o + a);
}
function Ma(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function ps(e, t) {
  return e === "BC" ? 1 - t : t;
}
function yi(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const bw = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class An {
  fromJulianDay(t) {
    let n = t, a = n - bh, r = Math.floor(a / 146097), o = Pr(a, 146097), s = Math.floor(o / 36524), i = Pr(o, 36524), u = Math.floor(i / 1461), d = Pr(i, 1461), c = Math.floor(d / 365), f = r * 400 + s * 100 + u * 4 + c + (s !== 4 && c !== 4 ? 1 : 0), [p, v] = yi(f), m = n - Ka(p, v, 1, 1), g = 2;
    n < Ka(p, v, 3, 1) ? g = 0 : Ma(v) && (g = 1);
    let w = Math.floor(((m + g) * 12 + 373) / 367), C = n - Ka(p, v, w, 1) + 1;
    return new St(p, v, w, C);
  }
  toJulianDay(t) {
    return Ka(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return bw[Ma(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return Ma(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const _w = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function xt(e, t) {
  return t = en(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function vc(e, t) {
  return t = en(t, e.calendar), e = dd(e), t = dd(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function Ba(e, t) {
  return mc(e.calendar, t.calendar) && xt(e, t);
}
function bp(e, t) {
  return mc(e.calendar, t.calendar) && vc(e, t);
}
function mc(e, t) {
  var n, a, r, o;
  return (o = (r = (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && r !== void 0 ? r : (a = t.isEqual) === null || a === void 0 ? void 0 : a.call(t, e)) !== null && o !== void 0 ? o : e.identifier === t.identifier;
}
function _h(e, t) {
  return xt(e, xh(t));
}
function wh(e, t, n) {
  let a = e.calendar.toJulianDay(e), r = Sw(t), o = Math.ceil(a + 1 - r) % 7;
  return o < 0 && (o += 7), o;
}
function ww(e) {
  return sa(Date.now(), e);
}
function xh(e) {
  return Bw(ww(e));
}
function Ch(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function xw(e, t) {
  return _p(e) - _p(t);
}
function _p(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let xu = null;
function Xr() {
  return xu == null && (xu = new Intl.DateTimeFormat().resolvedOptions().timeZone), xu;
}
function dd(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function wp(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
const xp = /* @__PURE__ */ new Map(), Cu = /* @__PURE__ */ new Map();
function Cw(e) {
  if (Intl.Locale) {
    let n = xp.get(e);
    return n || (n = new Intl.Locale(e).maximize().region, n && xp.set(e, n)), n;
  }
  let t = e.split("-")[1];
  return t === "u" ? void 0 : t;
}
function Sw(e) {
  let t = Cu.get(e);
  if (!t) {
    if (Intl.Locale) {
      let a = new Intl.Locale(e);
      if ("getWeekInfo" in a && (t = a.getWeekInfo(), t))
        return Cu.set(e, t), t.firstDay;
    }
    let n = Cw(e);
    if (e.includes("-fw-")) {
      let a = e.split("-fw-")[1].split("-")[0];
      a === "mon" ? t = {
        firstDay: 1
      } : a === "tue" ? t = {
        firstDay: 2
      } : a === "wed" ? t = {
        firstDay: 3
      } : a === "thu" ? t = {
        firstDay: 4
      } : a === "fri" ? t = {
        firstDay: 5
      } : a === "sat" ? t = {
        firstDay: 6
      } : t = {
        firstDay: 0
      };
    } else e.includes("-ca-iso8601") ? t = {
      firstDay: 1
    } : t = {
      firstDay: n && _w[n] || 0
    };
    Cu.set(e, t);
  }
  return t.firstDay;
}
function Vr(e) {
  e = en(e, new An());
  let t = ps(e.era, e.year);
  return Sh(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function Sh(e, t, n, a, r, o, s) {
  let i = /* @__PURE__ */ new Date();
  return i.setUTCHours(a, r, o, s), i.setUTCFullYear(e, t - 1, n), i.getTime();
}
function cd(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === Xr()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: n, month: a, day: r, hour: o, minute: s, second: i } = $h(e, t);
  return Sh(n, a, r, o, s, i, 0) - Math.floor(e / 1e3) * 1e3;
}
const Cp = /* @__PURE__ */ new Map();
function $h(e, t) {
  let n = Cp.get(t);
  n || (n = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), Cp.set(t, n));
  let a = n.formatToParts(new Date(e)), r = {};
  for (let o of a) o.type !== "literal" && (r[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: r.era === "BC" || r.era === "B" ? -r.year + 1 : +r.year,
    month: +r.month,
    day: +r.day,
    hour: r.hour === "24" ? 0 : +r.hour,
    minute: +r.minute,
    second: +r.second
  };
}
const Sp = 864e5;
function $w(e, t, n, a) {
  return (n === a ? [
    n
  ] : [
    n,
    a
  ]).filter((o) => kw(e, t, o));
}
function kw(e, t, n) {
  let a = $h(n, t);
  return e.year === a.year && e.month === a.month && e.day === a.day && e.hour === a.hour && e.minute === a.minute && e.second === a.second;
}
function oa(e, t, n = "compatible") {
  let a = Fr(e);
  if (t === "UTC") return Vr(a);
  if (t === Xr() && n === "compatible") {
    a = en(a, new An());
    let u = /* @__PURE__ */ new Date(), d = ps(a.era, a.year);
    return u.setFullYear(d, a.month - 1, a.day), u.setHours(a.hour, a.minute, a.second, a.millisecond), u.getTime();
  }
  let r = Vr(a), o = cd(r - Sp, t), s = cd(r + Sp, t), i = $w(a, t, r - o, r - s);
  if (i.length === 1) return i[0];
  if (i.length > 1) switch (n) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return i[0];
    case "later":
      return i[i.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (n) {
    case "earlier":
      return Math.min(r - o, r - s);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(r - o, r - s);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function kh(e, t, n = "compatible") {
  return new Date(oa(e, t, n));
}
function sa(e, t) {
  let n = cd(e, t), a = new Date(e + n), r = a.getUTCFullYear(), o = a.getUTCMonth() + 1, s = a.getUTCDate(), i = a.getUTCHours(), u = a.getUTCMinutes(), d = a.getUTCSeconds(), c = a.getUTCMilliseconds();
  return new Lr(r < 1 ? "BC" : "AD", r < 1 ? -r + 1 : r, o, s, t, n, i, u, d, c);
}
function Bw(e) {
  return new St(e.calendar, e.era, e.year, e.month, e.day);
}
function Fr(e, t) {
  let n = 0, a = 0, r = 0, o = 0;
  if ("timeZone" in e) ({ hour: n, minute: a, second: r, millisecond: o } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: n, minute: a, second: r, millisecond: o } = t), new Nr(e.calendar, e.era, e.year, e.month, e.day, n, a, r, o);
}
function en(e, t) {
  if (mc(e.calendar, t)) return e;
  let n = t.fromJulianDay(e.calendar.toJulianDay(e)), a = e.copy();
  return a.calendar = t, a.era = n.era, a.year = n.year, a.month = n.month, a.day = n.day, er(a), a;
}
function Dw(e, t, n) {
  if (e instanceof Lr)
    return e.timeZone === t ? e : Mw(e, t);
  let a = oa(e, t, n);
  return sa(a, t);
}
function Pw(e) {
  let t = Vr(e) - e.offset;
  return new Date(t);
}
function Mw(e, t) {
  let n = Vr(e) - e.offset;
  return en(sa(n, t), e.calendar);
}
const po = 36e5;
function bi(e, t) {
  let n = e.copy(), a = "hour" in n ? Aw(n, t) : 0;
  fd(n, t.years || 0), n.calendar.balanceYearMonth && n.calendar.balanceYearMonth(n, e), n.month += t.months || 0, pd(n), Bh(n), n.day += (t.weeks || 0) * 7, n.day += t.days || 0, n.day += a, Ew(n), n.calendar.balanceDate && n.calendar.balanceDate(n), n.year < 1 && (n.year = 1, n.month = 1, n.day = 1);
  let r = n.calendar.getYearsInEra(n);
  if (n.year > r) {
    var o, s;
    let u = (o = (s = n.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(s, n);
    n.year = r, n.month = u ? 1 : n.calendar.getMonthsInYear(n), n.day = u ? 1 : n.calendar.getDaysInMonth(n);
  }
  n.month < 1 && (n.month = 1, n.day = 1);
  let i = n.calendar.getMonthsInYear(n);
  return n.month > i && (n.month = i, n.day = n.calendar.getDaysInMonth(n)), n.day = Math.max(1, Math.min(n.calendar.getDaysInMonth(n), n.day)), n;
}
function fd(e, t) {
  var n, a;
  !((n = (a = e.calendar).isInverseEra) === null || n === void 0) && n.call(a, e) && (t = -t), e.year += t;
}
function pd(e) {
  for (; e.month < 1; )
    fd(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, fd(e, 1);
}
function Ew(e) {
  for (; e.day < 1; )
    e.month--, pd(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, pd(e);
}
function Bh(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function er(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), Bh(e);
}
function Dh(e) {
  let t = {};
  for (let n in e) typeof e[n] == "number" && (t[n] = -e[n]);
  return t;
}
function Ph(e, t) {
  return bi(e, Dh(t));
}
function hc(e, t) {
  let n = e.copy();
  return t.era != null && (n.era = t.era), t.year != null && (n.year = t.year), t.month != null && (n.month = t.month), t.day != null && (n.day = t.day), er(n), n;
}
function Bl(e, t) {
  let n = e.copy();
  return t.hour != null && (n.hour = t.hour), t.minute != null && (n.minute = t.minute), t.second != null && (n.second = t.second), t.millisecond != null && (n.millisecond = t.millisecond), Tw(n), n;
}
function qw(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = Rs(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = Rs(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = Rs(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = Rs(e.hour, 24), t;
}
function Tw(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function Rs(e, t) {
  let n = e % t;
  return n < 0 && (n += t), n;
}
function Aw(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, qw(e);
}
function gc(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "era": {
      let i = e.calendar.getEras(), u = i.indexOf(e.era);
      if (u < 0) throw new Error("Invalid era: " + e.era);
      u = la(u, n, 0, i.length - 1, a?.round), r.era = i[u], er(r);
      break;
    }
    case "year":
      var o, s;
      !((o = (s = r.calendar).isInverseEra) === null || o === void 0) && o.call(s, r) && (n = -n), r.year = la(e.year, n, -1 / 0, 9999, a?.round), r.year === -1 / 0 && (r.year = 1), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, e);
      break;
    case "month":
      r.month = la(e.month, n, 1, e.calendar.getMonthsInYear(e), a?.round);
      break;
    case "day":
      r.day = la(e.day, n, 1, e.calendar.getDaysInMonth(e), a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(r), er(r), r;
}
function Mh(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "hour": {
      let o = e.hour, s = 0, i = 23;
      if (a?.hourCycle === 12) {
        let u = o >= 12;
        s = u ? 12 : 0, i = u ? 23 : 11;
      }
      r.hour = la(o, n, s, i, a?.round);
      break;
    }
    case "minute":
      r.minute = la(e.minute, n, 0, 59, a?.round);
      break;
    case "second":
      r.second = la(e.second, n, 0, 59, a?.round);
      break;
    case "millisecond":
      r.millisecond = la(e.millisecond, n, 0, 999, a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return r;
}
function la(e, t, n, a, r = !1) {
  if (r) {
    e += Math.sign(t), e < n && (e = a);
    let o = Math.abs(t);
    t > 0 ? e = Math.ceil(e / o) * o : e = Math.floor(e / o) * o, e > a && (e = n);
  } else
    e += t, e < n ? e = a - (n - e - 1) : e > a && (e = n + (e - a - 1));
  return e;
}
function Eh(e, t) {
  let n;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let r = bi(Fr(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    n = oa(r, e.timeZone);
  } else
    n = Vr(e) - e.offset;
  n += t.milliseconds || 0, n += (t.seconds || 0) * 1e3, n += (t.minutes || 0) * 6e4, n += (t.hours || 0) * 36e5;
  let a = sa(n, e.timeZone);
  return en(a, e.calendar);
}
function Iw(e, t) {
  return Eh(e, Dh(t));
}
function Ow(e, t, n, a) {
  switch (t) {
    case "hour": {
      let r = 0, o = 23;
      if (a?.hourCycle === 12) {
        let m = e.hour >= 12;
        r = m ? 12 : 0, o = m ? 23 : 11;
      }
      let s = Fr(e), i = en(Bl(s, {
        hour: r
      }), new An()), u = [
        oa(i, e.timeZone, "earlier"),
        oa(i, e.timeZone, "later")
      ].filter((m) => sa(m, e.timeZone).day === i.day)[0], d = en(Bl(s, {
        hour: o
      }), new An()), c = [
        oa(d, e.timeZone, "earlier"),
        oa(d, e.timeZone, "later")
      ].filter((m) => sa(m, e.timeZone).day === d.day).pop(), f = Vr(e) - e.offset, p = Math.floor(f / po), v = f % po;
      return f = la(p, n, Math.floor(u / po), Math.floor(c / po), a?.round) * po + v, en(sa(f, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return Mh(e, t, n, a);
    case "era":
    case "year":
    case "month":
    case "day": {
      let r = gc(Fr(e), t, n, a), o = oa(r, e.timeZone);
      return en(sa(o, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function Rw(e, t, n) {
  let a = Fr(e), r = Bl(hc(a, t), t);
  if (r.compare(a) === 0) return e;
  let o = oa(r, e.timeZone, n);
  return en(sa(o, e.timeZone), e.calendar);
}
function Vw(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function qh(e) {
  let t = en(e, new An()), n;
  return t.era === "BC" ? n = t.year === 1 ? "0000" : "-" + String(Math.abs(1 - t.year)).padStart(6, "00") : n = String(t.year).padStart(4, "0"), `${n}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function Th(e) {
  return `${qh(e)}T${Vw(e)}`;
}
function Fw(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let n = Math.floor(e / 36e5), a = Math.floor(e % 36e5 / 6e4), r = Math.floor(e % 36e5 % 6e4 / 1e3), o = `${t}${String(n).padStart(2, "0")}:${String(a).padStart(2, "0")}`;
  return r !== 0 && (o += `:${String(r).padStart(2, "0")}`), o;
}
function Nw(e) {
  return `${Th(e)}${Fw(e.offset)}[${e.timeZone}]`;
}
function Lw(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function yc(e, t, n) {
  Lw(e, t), t.set(e, n);
}
function bc(e) {
  let t = typeof e[0] == "object" ? e.shift() : new An(), n;
  if (typeof e[0] == "string") n = e.shift();
  else {
    let s = t.getEras();
    n = s[s.length - 1];
  }
  let a = e.shift(), r = e.shift(), o = e.shift();
  return [
    t,
    n,
    a,
    r,
    o
  ];
}
var zw = /* @__PURE__ */ new WeakMap();
class St {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new St(this.calendar, this.era, this.year, this.month, this.day) : new St(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return bi(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return Ph(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return hc(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return gc(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return kh(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return qh(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return Ch(this, t);
  }
  constructor(...t) {
    yc(this, zw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = bc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, er(this);
  }
}
var Hw = /* @__PURE__ */ new WeakMap();
class Nr {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Nr(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new Nr(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return bi(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return Ph(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return hc(Bl(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return gc(this, t, n, a);
      default:
        return Mh(this, t, n, a);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, n) {
    return kh(this, t, n);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return Th(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let n = Ch(this, t);
    return n === 0 ? xw(this, Fr(t)) : n;
  }
  constructor(...t) {
    yc(this, Hw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = bc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, er(this);
  }
}
var Uw = /* @__PURE__ */ new WeakMap();
class Lr {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Lr(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new Lr(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return Eh(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return Iw(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, n) {
    return Rw(this, t, n);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return Ow(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return Pw(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return Nw(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - Dw(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    yc(this, Uw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = bc(t), i = t.shift(), u = t.shift();
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.timeZone = i, this.offset = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, er(this);
  }
}
const Mr = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], jw = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], ul = [
  1867,
  1911,
  1925,
  1988,
  2018
], ka = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function $p(e) {
  const t = Mr.findIndex(([n, a, r]) => e.year < n || e.year === n && e.month < a || e.year === n && e.month === a && e.day < r);
  return t === -1 ? Mr.length - 1 : t === 0 ? 0 : t - 1;
}
function Su(e) {
  let t = ul[ka.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new St(e.year + t, e.month, e.day);
}
class Ww extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = $p(n);
    return new St(this, ka[a], n.year - ul[a], n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Su(t));
  }
  balanceDate(t) {
    let n = Su(t), a = $p(n);
    ka[a] !== t.era && (t.era = ka[a], t.year = n.year - ul[a]), this.constrainDate(t);
  }
  constrainDate(t) {
    let n = ka.indexOf(t.era), a = jw[n];
    if (a != null) {
      let [r, o, s] = a, i = r - ul[n];
      t.year = Math.max(1, Math.min(i, t.year)), t.year === i && (t.month = Math.min(o, t.month), t.month === o && (t.day = Math.min(s, t.day)));
    }
    if (t.year === 1 && n >= 0) {
      let [, r, o] = Mr[n];
      t.month = Math.max(r, t.month), t.month === r && (t.day = Math.max(o, t.day));
    }
  }
  getEras() {
    return ka;
  }
  getYearsInEra(t) {
    let n = ka.indexOf(t.era), a = Mr[n], r = Mr[n + 1];
    if (r == null)
      return 9999 - a[0] + 1;
    let o = r[0] - a[0];
    return (t.month < r[1] || t.month === r[1] && t.day < r[2]) && o++, o;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Su(t));
  }
  getMinimumMonthInYear(t) {
    let n = kp(t);
    return n ? n[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let n = kp(t);
    return n && t.month === n[1] ? n[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function kp(e) {
  if (e.year === 1) {
    let t = ka.indexOf(e.era);
    return Mr[t];
  }
}
const Ah = -543;
class Gw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ps(n.era, n.year);
    return new St(this, a - Ah, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Bp(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Bp(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function Bp(e) {
  let [t, n] = yi(e.year + Ah);
  return new St(t, n, e.month, e.day);
}
const Dl = 1911;
function Ih(e) {
  return e.era === "minguo" ? e.year + Dl : 1 - e.year + Dl;
}
function Dp(e) {
  let t = e - Dl;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class Kw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ps(n.era, n.year), [r, o] = Dp(a);
    return new St(this, r, o, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(Pp(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [n, a] = Dp(Ih(t));
    t.era = n, t.year = a;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(Pp(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - Dl;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function Pp(e) {
  let [t, n] = yi(Ih(e));
  return new St(t, n, e.month, e.day);
}
const Mp = 1948320, Ep = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class Yw {
  fromJulianDay(t) {
    let n = t - Mp, a = 1 + Math.floor((33 * n + 3) / 12053), r = 365 * (a - 1) + Math.floor((8 * a + 21) / 33), o = n - r, s = o < 216 ? Math.floor(o / 31) : Math.floor((o - 6) / 30), i = o - Ep[s] + 1;
    return new St(this, a, s + 1, i);
  }
  toJulianDay(t) {
    let n = Mp - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return n += Ep[t.month - 1], n += t.day, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || Pr(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const $u = 78, qp = 80;
class Xw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = n.year - $u, r = t - Ka(n.era, n.year, 1, 1), o;
    r < qp ? (a--, o = Ma(n.year - 1) ? 31 : 30, r += o + 155 + 90 + 10) : (o = Ma(n.year) ? 31 : 30, r -= qp);
    let s, i;
    if (r < o)
      s = 1, i = r + 1;
    else {
      let u = r - o;
      u < 155 ? (s = Math.floor(u / 31) + 2, i = u % 31 + 1) : (u -= 155, s = Math.floor(u / 30) + 7, i = u % 30 + 1);
    }
    return new St(this, a, s, i);
  }
  toJulianDay(t) {
    let n = t.year + $u, [a, r] = yi(n), o, s;
    return Ma(r) ? (o = 31, s = Ka(a, r, 3, 21)) : (o = 30, s = Ka(a, r, 3, 22)), t.month === 1 ? s + t.day - 1 : (s += o + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (s += (t.month - 7) * 30), s += t.day - 1, s);
  }
  getDaysInMonth(t) {
    return t.month === 1 && Ma(t.year + $u) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const Pl = 1948440, Tp = 1948439, wn = 1300, _r = 1600, Jw = 460322;
function Ml(e, t, n, a) {
  return a + Math.ceil(29.5 * (n - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function Oh(e, t, n) {
  let a = Math.floor((30 * (n - t) + 10646) / 10631), r = Math.min(12, Math.ceil((n - (29 + Ml(t, a, 1, 1))) / 29.5) + 1), o = n - Ml(t, a, r, 1) + 1;
  return new St(e, a, r, o);
}
function Ap(e) {
  return (14 + 11 * e) % 30 < 11;
}
class _c {
  fromJulianDay(t) {
    return Oh(this, Pl, t);
  }
  toJulianDay(t) {
    return Ml(Pl, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = 29 + t.month % 2;
    return t.month === 12 && Ap(t.year) && n++, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return Ap(t.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class Zw extends _c {
  fromJulianDay(t) {
    return Oh(this, Tp, t);
  }
  toJulianDay(t) {
    return Ml(Tp, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const Qw = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let vd, Er;
function dl(e) {
  return Jw + Er[e - wn];
}
function Co(e, t) {
  let n = e - wn, a = 1 << 11 - (t - 1);
  return (vd[n] & a) === 0 ? 29 : 30;
}
function Ip(e, t) {
  let n = dl(e);
  for (let a = 1; a < t; a++) n += Co(e, a);
  return n;
}
function Op(e) {
  return Er[e + 1 - wn] - Er[e - wn];
}
class e1 extends _c {
  fromJulianDay(t) {
    let n = t - Pl, a = dl(wn), r = dl(_r);
    if (n < a || n > r) return super.fromJulianDay(t);
    {
      let o = wn - 1, s = 1, i = 1;
      for (; i > 0; ) {
        o++, i = n - dl(o) + 1;
        let u = Op(o);
        if (i === u) {
          s = 12;
          break;
        } else if (i < u) {
          let d = Co(o, s);
          for (s = 1; i > d; )
            i -= d, s++, d = Co(o, s);
          break;
        }
      }
      return new St(this, o, s, n - Ip(o, s) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < wn || t.year > _r ? super.toJulianDay(t) : Pl + Ip(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < wn || t.year > _r ? super.getDaysInMonth(t) : Co(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < wn || t.year > _r ? super.getDaysInYear(t) : Op(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", vd || (vd = new Uint16Array(Uint8Array.from(atob(Qw), (t) => t.charCodeAt(0)).buffer)), !Er) {
      Er = new Uint32Array(_r - wn + 1);
      let t = 0;
      for (let n = wn; n <= _r; n++) {
        Er[n - wn] = t;
        for (let a = 1; a <= 12; a++) t += Co(n, a);
      }
    }
  }
}
const Rp = 347997, Rh = 1080, Vh = 24 * Rh, t1 = 29, n1 = 12 * Rh + 793, a1 = t1 * Vh + n1;
function Ga(e) {
  return Pr(e * 7 + 1, 19) < 7;
}
function cl(e) {
  let t = Math.floor((235 * e - 234) / 19), n = 12084 + 13753 * t, a = t * 29 + Math.floor(n / 25920);
  return Pr(3 * (a + 1), 7) < 3 && (a += 1), a;
}
function r1(e) {
  let t = cl(e - 1), n = cl(e);
  return cl(e + 1) - n === 356 ? 2 : n - t === 382 ? 1 : 0;
}
function Eo(e) {
  return cl(e) + r1(e);
}
function Fh(e) {
  return Eo(e + 1) - Eo(e);
}
function o1(e) {
  let t = Fh(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    // deficient
    case 354:
      return 1;
    // normal
    case 355:
      return 2;
  }
}
function Vs(e, t) {
  if (t >= 6 && !Ga(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let n = o1(e);
  return t === 2 ? n === 2 ? 30 : 29 : t === 3 ? n === 0 ? 29 : 30 : t === 6 ? Ga(e) ? 30 : 0 : 30;
}
class s1 {
  fromJulianDay(t) {
    let n = t - Rp, a = n * Vh / a1, r = Math.floor((19 * a + 234) / 235) + 1, o = Eo(r), s = Math.floor(n - o);
    for (; s < 1; )
      r--, o = Eo(r), s = Math.floor(n - o);
    let i = 1, u = 0;
    for (; u < s; )
      u += Vs(r, i), i++;
    i--, u -= Vs(r, i);
    let d = s - u;
    return new St(this, r, i, d);
  }
  toJulianDay(t) {
    let n = Eo(t.year);
    for (let a = 1; a < t.month; a++) n += Vs(t.year, a);
    return n + t.day + Rp;
  }
  getDaysInMonth(t) {
    return Vs(t.year, t.month);
  }
  getMonthsInYear(t) {
    return Ga(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return Fh(t.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, n) {
    n.year !== t.year && (Ga(n.year) && !Ga(t.year) && n.month > 6 ? t.month-- : !Ga(n.year) && Ga(t.year) && n.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const md = 1723856, Vp = 1824665, hd = 5500;
function El(e, t, n, a) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (n - 1) + a - 1;
}
function wc(e, t) {
  let n = Math.floor(4 * (t - e) / 1461), a = 1 + Math.floor((t - El(e, n, 1, 1)) / 30), r = t + 1 - El(e, n, a, 1);
  return [
    n,
    a,
    r
  ];
}
function Nh(e) {
  return Math.floor(e % 4 / 3);
}
function Lh(e, t) {
  return t % 13 !== 0 ? 30 : Nh(e) + 5;
}
class xc {
  fromJulianDay(t) {
    let [n, a, r] = wc(md, t), o = "AM";
    return n <= 0 && (o = "AA", n += hd), new St(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "AA" && (n -= hd), El(md, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    return Lh(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + Nh(t.year);
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class l1 extends xc {
  fromJulianDay(t) {
    let [n, a, r] = wc(md, t);
    return n += hd, new St(this, "AA", n, a, r);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class i1 extends xc {
  fromJulianDay(t) {
    let [n, a, r] = wc(Vp, t), o = "CE";
    return n <= 0 && (o = "BCE", n = 1 - n), new St(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), El(Vp, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Lh(n, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function u1(e) {
  switch (e) {
    case "buddhist":
      return new Gw();
    case "ethiopic":
      return new xc();
    case "ethioaa":
      return new l1();
    case "coptic":
      return new i1();
    case "hebrew":
      return new s1();
    case "indian":
      return new Xw();
    case "islamic-civil":
      return new _c();
    case "islamic-tbla":
      return new Zw();
    case "islamic-umalqura":
      return new e1();
    case "japanese":
      return new Ww();
    case "persian":
      return new Yw();
    case "roc":
      return new Kw();
    default:
      return new An();
  }
}
let ku = /* @__PURE__ */ new Map();
class aa {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)}  ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.formatter.formatToParts(t), r = this.formatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return f1() && (this.resolvedHourCycle || (this.resolvedHourCycle = p1(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, n = {}) {
    this.formatter = zh(t, n), this.options = n;
  }
}
const d1 = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function zh(e, t = {}) {
  if (typeof t.hour12 == "boolean" && c1()) {
    t = {
      ...t
    };
    let r = d1[String(t.hour12)][e.split("-")[0]], o = t.hour12 ? "h12" : "h23";
    t.hourCycle = r ?? o, delete t.hour12;
  }
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : "");
  if (ku.has(n)) return ku.get(n);
  let a = new Intl.DateTimeFormat(e, t);
  return ku.set(n, a), a;
}
let Bu = null;
function c1() {
  return Bu == null && (Bu = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), Bu;
}
let Du = null;
function f1() {
  return Du == null && (Du = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), Du;
}
function p1(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = zh(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), a = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), r = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (a === 0 && r === 23) return "h23";
  if (a === 24 && r === 23) return "h24";
  if (a === 0 && r === 11) return "h11";
  if (a === 12 && r === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function Bn(e, t = Xr()) {
  return Cc(e) ? e.toDate() : e.toDate(t);
}
function v1(e) {
  return e instanceof Nr;
}
function Cc(e) {
  return e instanceof Lr;
}
function m1(e) {
  return v1(e) || Cc(e);
}
function No(e) {
  if (e instanceof Date) {
    const t = e.getFullYear(), n = e.getMonth() + 1;
    return new Date(t, n, 0).getDate();
  } else return e.set({ day: 100 }).day;
}
function Za(e, t) {
  return e.compare(t) < 0;
}
function fl(e, t) {
  return e.compare(t) > 0;
}
function h1(e, t) {
  return e.compare(t) <= 0;
}
function g1(e, t) {
  return e.compare(t) >= 0;
}
function y1(e, t, n) {
  return g1(e, t) && h1(e, n);
}
function Pu(e, t, n) {
  return fl(e, t) && Za(e, n);
}
function b1(e, t, n) {
  const a = wh(e, n);
  return t > a ? e.subtract({ days: a + 7 - t }) : t === a ? e : e.subtract({ days: a - t });
}
function _1(e, t, n) {
  const a = wh(e, n), r = t === 0 ? 6 : t - 1;
  return a === r ? e : a > r ? e.add({ days: 7 - a + r }) : e.add({ days: r - a });
}
function w1(e, t, n, a, r) {
  if (n === void 0 && a === void 0 && r === void 0) return !0;
  let o = e.add({ days: 1 });
  if ((a?.(o) || n?.(o)) && !r?.(o)) return !1;
  const s = t;
  for (; o.compare(s) < 0; )
    if (o = o.add({ days: 1 }), (a?.(o) || n?.(o)) && !r?.(o)) return !1;
  return !0;
}
function Hh(e) {
  const { defaultValue: t, defaultPlaceholder: n, granularity: a = "day", locale: r = "en" } = e;
  if (Array.isArray(t) && t.length) return t.at(-1).copy();
  if (t && !Array.isArray(t)) return t.copy();
  if (n) return n.copy();
  const o = /* @__PURE__ */ new Date(), s = o.getFullYear(), i = o.getMonth() + 1, u = o.getDate(), d = [
    "hour",
    "minute",
    "second"
  ], c = new aa(r), f = u1(c.resolvedOptions().calendar);
  return d.includes(a ?? "day") ? en(new Nr(s, i, u, 0, 0, 0), f) : en(new St(s, i, u), f);
}
function x1(e, t) {
  const n = [];
  for (let a = 0; a < e.length; a += t) n.push(e.slice(a, a + t));
  return n;
}
function Uh(e) {
  const t = e.querySelector("[data-selected]");
  if (t) return t.focus();
  const n = e.querySelector("[data-today]");
  if (n) return n.focus();
  const a = e.querySelector("[data-reka-calendar-day]");
  if (a) return a.focus();
}
function gd(e, t) {
  const n = [];
  let a = e.add({ days: 1 });
  const r = t;
  for (; a.compare(r) < 0; )
    n.push(a), a = a.add({ days: 1 });
  return n;
}
function Mu(e) {
  const { dateObj: t, weekStartsOn: n, fixedWeeks: a, locale: r } = e, o = No(t), s = Array.from({ length: o }, (w, C) => t.set({ day: C + 1 })), i = dd(t), u = wp(t), d = b1(i, n, r), c = _1(u, n, r), f = gd(d.subtract({ days: 1 }), i), p = gd(u, c.add({ days: 1 })), v = f.length + s.length + p.length;
  if (a && v < 42) {
    const w = 42 - v;
    let C = p[p.length - 1];
    C || (C = wp(t));
    const S = Array.from({ length: w }, ($, B) => {
      const k = B + 1;
      return C.add({ days: k });
    });
    p.push(...S);
  }
  const m = f.concat(s, p), g = x1(m, 7);
  return {
    value: t,
    cells: m,
    rows: g
  };
}
function Ha(e) {
  const { numberOfMonths: t, dateObj: n, ...a } = e, r = [];
  if (!t || t === 1)
    return r.push(Mu({
      ...a,
      dateObj: n
    })), r;
  r.push(Mu({
    ...a,
    dateObj: n
  }));
  for (let o = 1; o < t; o++) {
    const s = n.add({ months: o });
    r.push(Mu({
      ...a,
      dateObj: s
    }));
  }
  return r;
}
function C1(e, t = {}) {
  const n = I(e);
  function a() {
    return n.value;
  }
  function r(w) {
    n.value = w;
  }
  function o(w, C) {
    return new aa(n.value, {
      ...t,
      ...C
    }).format(w);
  }
  function s(w, C = !0) {
    return m1(w) && C ? o(Bn(w), {
      dateStyle: "long",
      timeStyle: "long"
    }) : o(Bn(w), { dateStyle: "long" });
  }
  function i(w, C = {}) {
    return new aa(n.value, {
      ...t,
      month: "long",
      year: "numeric",
      ...C
    }).format(w);
  }
  function u(w, C = {}) {
    return new aa(n.value, {
      ...t,
      month: "long",
      ...C
    }).format(w);
  }
  function d() {
    const w = xh(Xr());
    return [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12
    ].map((S) => ({
      label: u(Bn(w.set({ month: S }))),
      value: S
    }));
  }
  function c(w, C = {}) {
    return new aa(n.value, {
      ...t,
      year: "numeric",
      ...C
    }).format(w);
  }
  function f(w, C) {
    return Cc(w) ? new aa(n.value, {
      ...t,
      ...C,
      timeZone: w.timeZone
    }).formatToParts(Bn(w)) : new aa(n.value, {
      ...t,
      ...C
    }).formatToParts(Bn(w));
  }
  function p(w, C = "narrow") {
    return new aa(n.value, {
      ...t,
      weekday: C
    }).format(w);
  }
  function v(w) {
    const S = new aa(n.value, {
      ...t,
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(w).find(($) => $.type === "dayPeriod")?.value;
    return S === "PM" || S === "p.m." ? "PM" : "AM";
  }
  const m = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function g(w, C, S = {}) {
    const $ = {
      ...m,
      ...S
    }, k = f(w, $).find((P) => P.type === C);
    return k ? k.value : "";
  }
  return {
    setLocale: r,
    getLocale: a,
    fullMonth: u,
    fullYear: c,
    fullMonthAndYear: i,
    toParts: f,
    custom: o,
    part: g,
    dayPeriod: v,
    selectedDate: s,
    dayOfWeek: p,
    getMonths: d
  };
}
function yt(e) {
  const t = us({ dir: I("ltr") });
  return E(() => e?.value || t.dir?.value || "ltr");
}
function Kt(e) {
  const t = ht(), n = t?.type.emits, a = {};
  return n?.length || console.warn(`No emitted event found. Please check component: ${t?.type.__name}`), n?.forEach((r) => {
    a[b0(Sl(r))] = (...o) => e(r, ...o);
  }), a;
}
function jh(e) {
  const t = E(() => l(e)), n = E(() => new Intl.Collator("en", {
    usage: "search",
    ...t.value
  }));
  return {
    startsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(0, i.length), i) === 0),
    endsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(-i.length), i) === 0),
    contains: (s, i) => {
      if (i.length === 0) return !0;
      s = s.normalize("NFC"), i = i.normalize("NFC");
      let u = 0;
      const d = i.length;
      for (; u + d <= s.length; u++) {
        const c = s.slice(u, u + d);
        if (n.value.compare(i, c) === 0) return !0;
      }
      return !1;
    }
  };
}
let Eu = 0;
function Sc() {
  Ie((e) => {
    if (!rn) return;
    const t = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", t[0] ?? Fp()), document.body.insertAdjacentElement("beforeend", t[1] ?? Fp()), Eu++, e(() => {
      Eu === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((n) => n.remove()), Eu--;
    });
  });
}
function Fp() {
  const e = document.createElement("span");
  return e.setAttribute("data-reka-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
function Rn(e) {
  return E(() => fe(e) ? !!Gt(e)?.closest("form") : !0);
}
function j() {
  const e = ht(), t = I(), n = E(() => ["#text", "#comment"].includes(t.value?.$el.nodeName) ? t.value?.$el.nextElementSibling : Gt(t)), a = Object.assign({}, e.exposed), r = {};
  for (const s in e.props) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[s]
  });
  if (Object.keys(a).length > 0) for (const s in a) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => a[s]
  });
  Object.defineProperty(r, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = r;
  function o(s) {
    if (t.value = s, !!s && (Object.defineProperty(r, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s instanceof Element ? s : s.$el
    }), !(s instanceof Element) && !Object.hasOwn(s, "$el"))) {
      const i = s.$.exposed, u = Object.assign({}, r);
      for (const d in i) Object.defineProperty(u, d, {
        enumerable: !0,
        configurable: !0,
        get: () => i[d]
      });
      e.exposed = u;
    }
  }
  return {
    forwardRef: o,
    currentRef: t,
    currentElement: n
  };
}
function he(e) {
  const t = ht(), n = Object.keys(t?.type.props ?? {}).reduce((r, o) => {
    const s = (t?.type.props[o]).default;
    return s !== void 0 && (r[o] = s), r;
  }, {}), a = jn(e);
  return E(() => {
    const r = {}, o = t?.vnode.props ?? {};
    return Object.keys(o).forEach((s) => {
      r[Sl(s)] = o[s];
    }), Object.keys({
      ...n,
      ...r
    }).reduce((s, i) => (a.value[i] !== void 0 && (s[i] = a.value[i]), s), {});
  });
}
function me(e, t) {
  const n = he(e), a = t ? Kt(t) : {};
  return E(() => ({
    ...n.value,
    ...a
  }));
}
function Wh(e, t) {
  const n = cs(!1, 300);
  ga(() => {
    n.value = !1;
  });
  const a = I(null), r = Dr();
  function o() {
    a.value = null, n.value = !1;
  }
  function s(i, u) {
    const d = i.currentTarget, c = {
      x: i.clientX,
      y: i.clientY
    }, f = S1(c, d.getBoundingClientRect()), p = $1(c, f), v = k1(u.getBoundingClientRect()), m = D1([...p, ...v]);
    a.value = m, n.value = !0;
  }
  return Ie((i) => {
    if (e.value && t.value) {
      const u = (c) => s(c, t.value), d = (c) => s(c, e.value);
      e.value.addEventListener("pointerleave", u), t.value.addEventListener("pointerleave", d), i(() => {
        e.value?.removeEventListener("pointerleave", u), t.value?.removeEventListener("pointerleave", d);
      });
    }
  }), Ie((i) => {
    if (a.value) {
      const u = (d) => {
        if (!a.value || !(d.target instanceof Element)) return;
        const c = d.target, f = {
          x: d.clientX,
          y: d.clientY
        }, p = e.value?.contains(c) || t.value?.contains(c), v = !B1(f, a.value), m = !!c.closest("[data-grace-area-trigger]");
        p ? o() : (v || m) && (o(), r.trigger());
      };
      e.value?.ownerDocument.addEventListener("pointermove", u), i(() => e.value?.ownerDocument.removeEventListener("pointermove", u));
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: r.on
  };
}
function S1(e, t) {
  const n = Math.abs(t.top - e.y), a = Math.abs(t.bottom - e.y), r = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, a, r, o)) {
    case o:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case a:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function $1(e, t, n = 5) {
  const a = [];
  switch (t) {
    case "top":
      a.push({
        x: e.x - n,
        y: e.y + n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "bottom":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y - n
      });
      break;
    case "left":
      a.push({
        x: e.x + n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "right":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x - n,
        y: e.y + n
      });
      break;
  }
  return a;
}
function k1(e) {
  const { top: t, right: n, bottom: a, left: r } = e;
  return [
    {
      x: r,
      y: t
    },
    {
      x: n,
      y: t
    },
    {
      x: n,
      y: a
    },
    {
      x: r,
      y: a
    }
  ];
}
function B1(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function D1(e) {
  const t = e.slice();
  return t.sort((n, a) => n.x < a.x ? -1 : n.x > a.x ? 1 : n.y < a.y ? -1 : n.y > a.y ? 1 : 0), P1(t);
}
function P1(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) t.pop();
      else break;
    }
    t.push(r);
  }
  t.pop();
  const n = [];
  for (let a = e.length - 1; a >= 0; a--) {
    const r = e[a];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) n.pop();
      else break;
    }
    n.push(r);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var M1 = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, wr = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), Ns = {}, qu = 0, Gh = function(e) {
  return e && (e.host || Gh(e.parentNode));
}, E1 = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var a = Gh(n);
    return a && e.contains(a) ? a : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, q1 = function(e, t, n, a) {
  var r = E1(t, Array.isArray(e) ? e : [e]);
  Ns[n] || (Ns[n] = /* @__PURE__ */ new WeakMap());
  var o = Ns[n], s = [], i = /* @__PURE__ */ new Set(), u = new Set(r), d = function(f) {
    !f || i.has(f) || (i.add(f), d(f.parentNode));
  };
  r.forEach(d);
  var c = function(f) {
    !f || u.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (i.has(p))
        c(p);
      else
        try {
          var v = p.getAttribute(a), m = v !== null && v !== "false", g = (wr.get(p) || 0) + 1, w = (o.get(p) || 0) + 1;
          wr.set(p, g), o.set(p, w), s.push(p), g === 1 && m && Fs.set(p, !0), w === 1 && p.setAttribute(n, "true"), m || p.setAttribute(a, "true");
        } catch (C) {
          console.error("aria-hidden: cannot operate on ", p, C);
        }
    });
  };
  return c(t), i.clear(), qu++, function() {
    s.forEach(function(f) {
      var p = wr.get(f) - 1, v = o.get(f) - 1;
      wr.set(f, p), o.set(f, v), p || (Fs.has(f) || f.removeAttribute(a), Fs.delete(f)), v || f.removeAttribute(n);
    }), qu--, qu || (wr = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), Fs = /* @__PURE__ */ new WeakMap(), Ns = {});
  };
}, T1 = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), r = M1(e);
  return r ? (a.push.apply(a, Array.from(r.querySelectorAll("[aria-live], script"))), q1(a, r, n, "aria-hidden")) : function() {
    return null;
  };
};
function vs(e) {
  let t;
  ve(() => Gt(e), (n) => {
    n ? t = T1(n) : t && t();
  }), Qe(() => {
    t && t();
  });
}
let A1 = 0;
function Ge(e, t = "reka") {
  if (e) return e;
  if ("useId" in fp) return `${t}-${fp.useId?.()}`;
  const n = us({ useId: void 0 });
  return n.useId ? `${t}-${n.useId()}` : `${t}-${++A1}`;
}
function ms() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function $c(e) {
  const t = us({ locale: I("en") });
  return E(() => e?.value || t.locale?.value || "en");
}
function Kh(e) {
  const t = I(), n = E(() => t.value?.width ?? 0), a = E(() => t.value?.height ?? 0);
  return Ce(() => {
    const r = Gt(e);
    if (r) {
      t.value = {
        width: r.offsetWidth,
        height: r.offsetHeight
      };
      const o = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length) return;
        const i = s[0];
        let u, d;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          u = f.inlineSize, d = f.blockSize;
        } else
          u = r.offsetWidth, d = r.offsetHeight;
        t.value = {
          width: u,
          height: d
        };
      });
      return o.observe(r, { box: "border-box" }), () => o.unobserve(r);
    } else t.value = void 0;
  }), {
    width: n,
    height: a
  };
}
function Yh(e, t) {
  const n = I(e);
  function a(o) {
    return t[n.value][o] ?? n.value;
  }
  return {
    state: n,
    dispatch: (o) => {
      n.value = a(o);
    }
  };
}
function _i(e) {
  const t = cs("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (r, o) => {
      t.value = t.value + r;
      {
        const s = ot(), i = o.map((p) => ({
          ...p,
          textValue: p.value?.textValue ?? p.ref.textContent?.trim() ?? ""
        })), u = i.find((p) => p.ref === s), d = i.map((p) => p.textValue), c = I1(d, t.value, u?.textValue), f = i.find((p) => p.textValue === c);
        return f && f.ref.focus(), f?.ref;
      }
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function kc(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
function I1(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = kc(e, Math.max(o, 0));
  r.length === 1 && (s = s.filter((d) => d !== n));
  const u = s.find((d) => d.toLowerCase().startsWith(r.toLowerCase()));
  return u !== n ? u : void 0;
}
function O1(e, t) {
  const n = I({}), a = I("none"), r = I(e), o = e.value ? "mounted" : "unmounted";
  let s;
  const i = t.value?.ownerDocument.defaultView ?? Ra, { state: u, dispatch: d } = Yh(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), c = (w) => {
    if (rn) {
      const C = new CustomEvent(w, {
        bubbles: !1,
        cancelable: !1
      });
      t.value?.dispatchEvent(C);
    }
  };
  ve(e, async (w, C) => {
    const S = C !== w;
    if (await Be(), S) {
      const $ = a.value, B = Ls(t.value);
      w ? (d("MOUNT"), c("enter"), B === "none" && c("after-enter")) : B === "none" || B === "undefined" || n.value?.display === "none" ? (d("UNMOUNT"), c("leave"), c("after-leave")) : C && $ !== B ? (d("ANIMATION_OUT"), c("leave")) : (d("UNMOUNT"), c("after-leave"));
    }
  }, { immediate: !0 });
  const f = (w) => {
    const C = Ls(t.value), S = C.includes(CSS.escape(w.animationName)), $ = u.value === "mounted" ? "enter" : "leave";
    if (w.target === t.value && S && (c(`after-${$}`), d("ANIMATION_END"), !r.value)) {
      const B = t.value.style.animationFillMode;
      t.value.style.animationFillMode = "forwards", s = i?.setTimeout(() => {
        t.value?.style.animationFillMode === "forwards" && (t.value.style.animationFillMode = B);
      });
    }
    w.target === t.value && C === "none" && d("ANIMATION_END");
  }, p = (w) => {
    w.target === t.value && (a.value = Ls(t.value));
  }, v = ve(t, (w, C) => {
    w ? (n.value = getComputedStyle(w), w.addEventListener("animationstart", p), w.addEventListener("animationcancel", f), w.addEventListener("animationend", f)) : (d("ANIMATION_END"), s !== void 0 && i?.clearTimeout(s), C?.removeEventListener("animationstart", p), C?.removeEventListener("animationcancel", f), C?.removeEventListener("animationend", f));
  }, { immediate: !0 }), m = ve(u, () => {
    const w = Ls(t.value);
    a.value = u.value === "mounted" ? w : "none";
  });
  return Qe(() => {
    v(), m();
  }), { isPresent: E(() => ["mounted", "unmountSuspended"].includes(u.value)) };
}
function Ls(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var $t = b({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: t, expose: n }) {
    const { present: a, forceMount: r } = Me(e), o = I(), { isPresent: s } = O1(a, o);
    n({ present: s });
    let i = t.default({ present: s.value });
    i = dc(i || []);
    const u = ht();
    if (i && i?.length > 1) {
      const d = u?.parent?.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${d}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((c) => `  - ${c}`).join(`
`)
      ].join(`
`));
    }
    return () => r.value || a.value || s.value ? an(t.default({ present: s.value })[0], { ref: (d) => {
      const c = Gt(d);
      return typeof c?.hasAttribute > "u" || (c?.hasAttribute("data-reka-popper-content-wrapper") ? o.value = c.firstElementChild : o.value = c), c;
    } }) : null;
  }
});
const ql = b({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: t, slots: n }) {
    return () => {
      if (!n.default) return null;
      const a = dc(n.default()), r = a.findIndex((u) => u.type !== _0);
      if (r === -1) return a;
      const o = a[r];
      delete o.props?.ref;
      const s = o.props ? A(t, o.props) : t, i = w0({
        ...o,
        props: {}
      }, s);
      return a.length === 1 ? i : (a[r] = i, a);
    };
  }
}), R1 = [
  "area",
  "img",
  "input"
], X = b({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: t, slots: n }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && R1.includes(a) ? () => an(a, t) : a !== "template" ? () => an(e.as, t, { default: n.default }) : () => an(ql, t, { default: n.default });
  }
});
function Ht() {
  const e = I(), t = E(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : Gt(e));
  return {
    primitiveElement: e,
    currentElement: t
  };
}
const [Xh, V1] = Se("CollapsibleRoot");
var F1 = /* @__PURE__ */ b({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = Ve(a, "open", n, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), { disabled: s, unmountOnHide: i } = Me(a);
    return V1({
      contentId: "",
      disabled: s,
      open: o,
      unmountOnHide: i,
      onOpenToggle: () => {
        s.value || (o.value = !o.value);
      }
    }), t({ open: o }), j(), (u, d) => (h(), x(l(X), {
      as: u.as,
      "as-child": a.asChild,
      "data-state": l(o) ? "open" : "closed",
      "data-disabled": l(s) ? "" : void 0
    }, {
      default: y(() => [_(u.$slots, "default", { open: l(o) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ]));
  }
}), Jh = F1, N1 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["contentFound"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xh();
    r.contentId ||= Ge(void 0, "reka-collapsible-content");
    const o = I(), { forwardRef: s, currentElement: i } = j(), u = I(0), d = I(0), c = E(() => r.open.value), f = I(c.value), p = I();
    ve(() => [c.value, o.value?.present], async () => {
      await Be();
      const m = i.value;
      if (!m) return;
      p.value = p.value || {
        transitionDuration: m.style.transitionDuration,
        animationName: m.style.animationName
      }, m.style.transitionDuration = "0s", m.style.animationName = "none";
      const g = m.getBoundingClientRect();
      d.value = g.height, u.value = g.width, f.value || (m.style.transitionDuration = p.value.transitionDuration, m.style.animationName = p.value.animationName);
    }, { immediate: !0 });
    const v = E(() => f.value && r.open.value);
    return Ce(() => {
      requestAnimationFrame(() => {
        f.value = !1;
      });
    }), zt(i, "beforematch", (m) => {
      requestAnimationFrame(() => {
        r.onOpenToggle(), a("contentFound");
      });
    }), (m, g) => (h(), x(l($t), {
      ref_key: "presentRef",
      ref: o,
      present: m.forceMount || l(r).open.value,
      "force-mount": !0
    }, {
      default: y(({ present: w }) => [N(l(X), A(m.$attrs, {
        id: l(r).contentId,
        ref: l(s),
        "as-child": n.asChild,
        as: m.as,
        hidden: w ? void 0 : l(r).unmountOnHide.value ? "" : "until-found",
        "data-state": v.value ? void 0 : l(r).open.value ? "open" : "closed",
        "data-disabled": l(r).disabled?.value ? "" : void 0,
        style: {
          "--reka-collapsible-content-height": `${d.value}px`,
          "--reka-collapsible-content-width": `${u.value}px`
        }
      }), {
        default: y(() => [!l(r).unmountOnHide.value || w ? _(m.$slots, "default", { key: 0 }) : Ee("v-if", !0)]),
        _: 2
      }, 1040, [
        "id",
        "as-child",
        "as",
        "hidden",
        "data-state",
        "data-disabled",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Zh = N1, L1 = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Xh();
    return (a, r) => (h(), x(l(X), {
      type: a.as === "button" ? "button" : void 0,
      as: a.as,
      "as-child": t.asChild,
      "aria-controls": l(n).contentId,
      "aria-expanded": l(n).open.value,
      "data-state": l(n).open.value ? "open" : "closed",
      "data-disabled": l(n).disabled?.value ? "" : void 0,
      disabled: l(n).disabled?.value,
      onClick: l(n).onOpenToggle
    }, {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "aria-controls",
      "aria-expanded",
      "data-state",
      "data-disabled",
      "disabled",
      "onClick"
    ]));
  }
}), Qh = L1;
function z1({ type: e, defaultValue: t, modelValue: n }) {
  const a = n || t;
  return n !== void 0 || t !== void 0 ? Array.isArray(a) ? "multiple" : "single" : e ?? "single";
}
function H1({ type: e, defaultValue: t, modelValue: n }) {
  return e || z1({
    type: e,
    defaultValue: t,
    modelValue: n
  });
}
function U1({ type: e, defaultValue: t }) {
  return t !== void 0 ? t : e === "single" ? void 0 : [];
}
function eg(e, t) {
  const n = E(() => H1(e)), a = Ve(e, "modelValue", t, {
    defaultValue: U1(e),
    passive: e.modelValue === void 0,
    deep: !0
  });
  function r(s) {
    if (n.value === "single") a.value = qn(s, a.value) ? void 0 : s;
    else {
      const i = Array.isArray(a.value) ? [...a.value || []] : [a.value].filter(Boolean);
      if ($l(i, s)) {
        const u = i.findIndex((d) => qn(d, s));
        i.splice(u, 1);
      } else i.push(s);
      a.value = i;
    }
  }
  const o = E(() => n.value === "single");
  return {
    modelValue: a,
    changeModelValue: r,
    isSingle: o
  };
}
const [wi, j1] = Se("AccordionRoot");
var W1 = /* @__PURE__ */ b({
  __name: "AccordionRoot",
  props: {
    collapsible: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, disabled: o, unmountOnHide: s } = Me(n), i = yt(r), { modelValue: u, changeModelValue: d, isSingle: c } = eg(n, a), { forwardRef: f, currentElement: p } = j();
    return j1({
      disabled: o,
      direction: i,
      orientation: n.orientation,
      parentElement: p,
      isSingle: c,
      collapsible: n.collapsible,
      modelValue: u,
      changeModelValue: d,
      unmountOnHide: s
    }), (v, m) => (h(), x(l(X), {
      ref: l(f),
      "as-child": v.asChild,
      as: v.as
    }, {
      default: y(() => [_(v.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), G1 = W1, yd = /* @__PURE__ */ (function(e) {
  return e.Open = "open", e.Closed = "closed", e;
})(yd || {});
const [Bc, K1] = Se("AccordionItem");
var Y1 = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: String,
      required: !0
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = wi(), r = E(() => a.isSingle.value ? n.value === a.modelValue.value : Array.isArray(a.modelValue.value) && a.modelValue.value.includes(n.value)), o = E(() => a.disabled.value || n.disabled), s = E(() => o.value ? "" : void 0), i = E(() => r.value ? yd.Open : yd.Closed);
    t({
      open: r,
      dataDisabled: s
    });
    const { currentRef: u, currentElement: d } = j();
    K1({
      open: r,
      dataState: i,
      disabled: o,
      dataDisabled: s,
      triggerId: "",
      currentRef: u,
      currentElement: d,
      value: E(() => n.value)
    });
    function c(f) {
      const p = f.target;
      if (Array.from(a.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []).findIndex((g) => g === p) === -1) return null;
      lr(f, p, a.parentElement.value, {
        arrowKeyOptions: a.orientation,
        dir: a.direction.value,
        focus: !0
      });
    }
    return (f, p) => (h(), x(l(Jh), {
      "data-orientation": l(a).orientation,
      "data-disabled": s.value,
      "data-state": i.value,
      disabled: o.value,
      open: r.value,
      as: n.as,
      "as-child": n.asChild,
      "unmount-on-hide": n.unmountOnHide ?? l(a).unmountOnHide.value,
      onKeydown: Je(c, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end"
      ])
    }, {
      default: y(() => [_(f.$slots, "default", { open: r.value })]),
      _: 3
    }, 8, [
      "data-orientation",
      "data-disabled",
      "data-state",
      "disabled",
      "open",
      "as",
      "as-child",
      "unmount-on-hide"
    ]));
  }
}), X1 = Y1, J1 = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = wi(), a = Bc();
    return j(), (r, o) => (h(), x(l(Zh), {
      role: "region",
      "as-child": t.asChild,
      as: r.as,
      "force-mount": t.forceMount,
      "aria-labelledby": l(a).triggerId,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      style: {
        "--reka-accordion-content-width": "var(--reka-collapsible-content-width)",
        "--reka-accordion-content-height": "var(--reka-collapsible-content-height)"
      },
      onContentFound: o[0] || (o[0] = (s) => l(n).changeModelValue(l(a).value.value))
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "force-mount",
      "aria-labelledby",
      "data-state",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), Z1 = J1, Q1 = /* @__PURE__ */ b({
  __name: "AccordionHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h3"
    }
  },
  setup(e) {
    const t = e, n = wi(), a = Bc();
    return j(), (r, o) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-orientation",
      "data-state",
      "data-disabled"
    ]));
  }
}), ex = Q1, tx = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = wi(), a = Bc();
    a.triggerId ||= Ge(void 0, "reka-accordion-trigger");
    function r() {
      const o = n.isSingle.value && a.open.value && !n.collapsible;
      a.disabled.value || o || n.changeModelValue(a.value.value);
    }
    return (o, s) => (h(), x(l(Qh), {
      id: l(a).triggerId,
      ref: l(a).currentRef,
      "data-reka-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-disabled": l(a).disabled.value || void 0,
      "aria-expanded": l(a).open.value || !1,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      disabled: l(a).disabled.value,
      onClick: r
    }, {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "aria-disabled",
      "aria-expanded",
      "data-disabled",
      "data-orientation",
      "data-state",
      "disabled"
    ]));
  }
}), nx = tx;
const [Zn, ax] = Se("DialogRoot");
var rx = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = I(), s = I(), { modal: i } = Me(n);
    return ax({
      open: r,
      modal: i,
      openModal: () => {
        r.value = !0;
      },
      onOpenChange: (u) => {
        r.value = u;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: o,
      contentElement: s
    }), (u, d) => _(u.$slots, "default", {
      open: l(r),
      close: () => r.value = !1
    });
  }
}), xi = rx, ox = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zn();
    return (a, r) => (h(), x(l(X), A(t, {
      type: a.as === "button" ? "button" : void 0,
      onClick: r[0] || (r[0] = (o) => l(n).onOpenChange(!1))
    }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), Va = ox;
const sx = "dismissableLayer.pointerDownOutside", lx = "dismissableLayer.focusOutside";
function tg(e, t) {
  const n = t.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), r = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(n && (a === n || r.indexOf(a) < r.indexOf(n)));
}
function ix(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = I(!1), o = I(() => {
  });
  return Ie((s) => {
    if (!rn || !fe(n)) return;
    const i = async (d) => {
      const c = d.target;
      if (!(!t?.value || !c)) {
        if (tg(t.value, c)) {
          r.value = !1;
          return;
        }
        if (d.target && !r.value) {
          let p = function() {
            is(sx, e, f);
          };
          const f = { originalEvent: d };
          d.pointerType === "touch" ? (a.removeEventListener("click", o.value), o.value = p, a.addEventListener("click", o.value, { once: !0 })) : p();
        } else a.removeEventListener("click", o.value);
        r.value = !1;
      }
    }, u = window.setTimeout(() => {
      a.addEventListener("pointerdown", i);
    }, 0);
    s(() => {
      window.clearTimeout(u), a.removeEventListener("pointerdown", i), a.removeEventListener("click", o.value);
    });
  }), { onPointerDownCapture: () => {
    fe(n) && (r.value = !0);
  } };
}
function ux(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = I(!1);
  return Ie((o) => {
    if (!rn || !fe(n)) return;
    const s = async (i) => {
      if (!t?.value) return;
      await Be(), await Be();
      const u = i.target;
      !t.value || !u || tg(t.value, u) || i.target && !r.value && is(lx, e, { originalEvent: i });
    };
    a.addEventListener("focusin", s), o(() => a.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => {
      fe(n) && (r.value = !0);
    },
    onBlurCapture: () => {
      fe(n) && (r.value = !1);
    }
  };
}
const yn = Wt({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  originalBodyPointerEvents: void 0,
  branches: /* @__PURE__ */ new Set()
});
var dx = /* @__PURE__ */ b({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = E(() => o.value?.ownerDocument ?? globalThis.document), i = E(() => yn.layersRoot), u = E(() => o.value ? Array.from(i.value).indexOf(o.value) : -1), d = E(() => yn.layersWithOutsidePointerEventsDisabled.size > 0), c = E(() => {
      const v = Array.from(i.value), [m] = [...yn.layersWithOutsidePointerEventsDisabled].slice(-1), g = v.indexOf(m);
      return u.value >= g;
    }), f = ix(async (v) => {
      const m = [...yn.branches].some((g) => g?.contains(v.target));
      !c.value || m || (a("pointerDownOutside", v), a("interactOutside", v), await Be(), v.defaultPrevented || a("dismiss"));
    }, o), p = ux((v) => {
      [...yn.branches].some((g) => g?.contains(v.target)) || (a("focusOutside", v), a("interactOutside", v), v.defaultPrevented || a("dismiss"));
    }, o);
    return iw("Escape", (v) => {
      u.value === i.value.size - 1 && (a("escapeKeyDown", v), v.defaultPrevented || a("dismiss"));
    }), Ie((v) => {
      o.value && (n.disableOutsidePointerEvents && (yn.layersWithOutsidePointerEventsDisabled.size === 0 && (yn.originalBodyPointerEvents = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), yn.layersWithOutsidePointerEventsDisabled.add(o.value)), i.value.add(o.value), v(() => {
        n.disableOutsidePointerEvents && yn.layersWithOutsidePointerEventsDisabled.size === 1 && !Mn(yn.originalBodyPointerEvents) && (s.value.body.style.pointerEvents = yn.originalBodyPointerEvents);
      }));
    }), Ie((v) => {
      v(() => {
        o.value && (i.value.delete(o.value), yn.layersWithOutsidePointerEventsDisabled.delete(o.value));
      });
    }), (v, m) => (h(), x(l(X), {
      ref: l(r),
      "as-child": v.asChild,
      as: v.as,
      "data-dismissable-layer": "",
      style: dt({ pointerEvents: d.value ? c.value ? "auto" : "none" : void 0 }),
      onFocusCapture: l(p).onFocusCapture,
      onBlurCapture: l(p).onBlurCapture,
      onPointerdownCapture: l(f).onPointerDownCapture
    }, {
      default: y(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), Fa = dx;
const cx = H0(() => I([]));
function fx() {
  const e = cx();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && n?.pause(), e.value = Np(e.value, t), e.value.unshift(t);
    },
    remove(t) {
      e.value = Np(e.value, t), e.value[0]?.resume();
    }
  };
}
function Np(e, t) {
  const n = [...e], a = n.indexOf(t);
  return a !== -1 && n.splice(a, 1), n;
}
function px(e) {
  return e.filter((t) => t.tagName !== "A");
}
const Tu = "focusScope.autoFocusOnMount", Au = "focusScope.autoFocusOnUnmount", Lp = {
  bubbles: !1,
  cancelable: !0
};
function vx(e, { select: t = !1 } = {}) {
  const n = ot();
  for (const a of e)
    if ($a(a, { select: t }), ot() !== n) return !0;
}
function mx(e) {
  const t = ng(e), n = zp(t, e), a = zp(t.reverse(), e);
  return [n, a];
}
function ng(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function zp(e, t) {
  for (const n of e) if (!hx(n, { upTo: t })) return n;
}
function hx(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function gx(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function $a(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = ot();
    e.focus({ preventScroll: !0 }), e !== n && gx(e) && t && e.select();
  }
}
var yx = /* @__PURE__ */ b({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    trapped: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, { currentRef: r, currentElement: o } = j(), s = I(null), i = fx(), u = Wt({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Ie((c) => {
      if (!rn) return;
      const f = o.value;
      if (!n.trapped) return;
      function p(w) {
        if (u.paused || !f) return;
        const C = w.target;
        f.contains(C) ? s.value = C : $a(s.value, { select: !0 });
      }
      function v(w) {
        if (u.paused || !f) return;
        const C = w.relatedTarget;
        C !== null && (f.contains(C) || $a(s.value, { select: !0 }));
      }
      function m(w) {
        f.contains(s.value) || $a(f);
      }
      document.addEventListener("focusin", p), document.addEventListener("focusout", v);
      const g = new MutationObserver(m);
      f && g.observe(f, {
        childList: !0,
        subtree: !0
      }), c(() => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", v), g.disconnect();
      });
    }), Ie(async (c) => {
      const f = o.value;
      if (await Be(), !f) return;
      i.add(u);
      const p = ot();
      if (!f.contains(p)) {
        const m = new CustomEvent(Tu, Lp);
        f.addEventListener(Tu, (g) => a("mountAutoFocus", g)), f.dispatchEvent(m), m.defaultPrevented || (vx(px(ng(f)), { select: !0 }), ot() === p && $a(f));
      }
      c(() => {
        f.removeEventListener(Tu, (w) => a("mountAutoFocus", w));
        const m = new CustomEvent(Au, Lp), g = (w) => {
          a("unmountAutoFocus", w);
        };
        f.addEventListener(Au, g), f.dispatchEvent(m), setTimeout(() => {
          m.defaultPrevented || $a(p ?? document.body, { select: !0 }), f.removeEventListener(Au, g), i.remove(u);
        }, 0);
      });
    });
    function d(c) {
      if (!n.loop && !n.trapped || u.paused) return;
      const f = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, p = ot();
      if (f && p) {
        const v = c.currentTarget, [m, g] = mx(v);
        m && g ? !c.shiftKey && p === g ? (c.preventDefault(), n.loop && $a(m, { select: !0 })) : c.shiftKey && p === m && (c.preventDefault(), n.loop && $a(g, { select: !0 })) : p === v && c.preventDefault();
      }
    }
    return (c, f) => (h(), x(l(X), {
      ref_key: "currentRef",
      ref: r,
      tabindex: "-1",
      "as-child": c.asChild,
      as: c.as,
      onKeydown: d
    }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), Ci = yx;
const bx = "menu.itemSelect", bd = ["Enter", " "], _x = [
  "ArrowDown",
  "PageUp",
  "Home"
], ag = [
  "ArrowUp",
  "PageDown",
  "End"
], wx = [..._x, ...ag], xx = {
  ltr: [...bd, "ArrowRight"],
  rtl: [...bd, "ArrowLeft"]
}, Cx = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function Dc(e) {
  return e ? "open" : "closed";
}
function Tl(e) {
  return e === "indeterminate";
}
function Pc(e) {
  return Tl(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function _d(e) {
  const t = ot();
  for (const n of e)
    if (n === t || (n.focus(), ot() !== t)) return;
}
function Sx(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function $x(e, t) {
  if (!t) return !1;
  const n = {
    x: e.clientX,
    y: e.clientY
  };
  return Sx(n, t);
}
function Lo(e) {
  return e.pointerType === "mouse";
}
const kx = "DialogTitle", Bx = "DialogContent";
function Dx({ titleName: e = kx, contentName: t = Bx, componentLink: n = "dialog.html#title", titleId: a, descriptionId: r, contentElement: o }) {
  const s = `Warning: \`${t}\` requires a \`${e}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${n}`, i = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${t}.`;
  Ce(() => {
    document.getElementById(a) || console.warn(s);
    const d = o.value?.getAttribute("aria-describedby");
    r && d && (document.getElementById(r) || console.warn(i));
  });
}
var Px = /* @__PURE__ */ b({
  __name: "DialogContentImpl",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Zn(), { forwardRef: o, currentElement: s } = j();
    return r.titleId ||= Ge(void 0, "reka-dialog-title"), r.descriptionId ||= Ge(void 0, "reka-dialog-description"), Ce(() => {
      r.contentElement = s, ot() !== document.body && (r.triggerElement.value = ot());
    }), process.env.NODE_ENV !== "production" && Dx({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: r.titleId,
      descriptionId: r.descriptionId,
      contentElement: s
    }), (i, u) => (h(), x(l(Ci), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [N(l(Fa), A({
        id: l(r).contentId,
        ref: l(o),
        as: i.as,
        "as-child": i.asChild,
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        role: "dialog",
        "aria-describedby": l(r).descriptionId,
        "aria-labelledby": l(r).titleId,
        "data-state": l(Dc)(l(r).open.value)
      }, i.$attrs, {
        onDismiss: u[0] || (u[0] = (d) => l(r).onOpenChange(!1)),
        onEscapeKeyDown: u[1] || (u[1] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[2] || (u[2] = (d) => a("focusOutside", d)),
        onInteractOutside: u[3] || (u[3] = (d) => a("interactOutside", d)),
        onPointerDownOutside: u[4] || (u[4] = (d) => a("pointerDownOutside", d))
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "as",
        "as-child",
        "disable-outside-pointer-events",
        "aria-describedby",
        "aria-labelledby",
        "data-state"
      ])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), rg = Px, Mx = /* @__PURE__ */ b({
  __name: "DialogContentModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Zn(), o = Kt(a), { forwardRef: s, currentElement: i } = j();
    return vs(i), (u, d) => (h(), x(rg, A({
      ...n,
      ...l(o)
    }, {
      ref: l(s),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (c.preventDefault(), l(r).triggerElement.value?.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0;
        (f.button === 2 || p) && c.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (c) => {
        c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), Ex = Mx, qx = /* @__PURE__ */ b({
  __name: "DialogContentNonModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    j();
    const o = Zn(), s = I(!1), i = I(!1);
    return (u, d) => (h(), x(rg, A({
      ...n,
      ...l(r)
    }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (s.value || l(o).triggerElement.value?.focus(), c.preventDefault()), s.value = !1, i.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = (c) => {
        c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const f = c.target;
        l(o).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && i.value && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Tx = qx, Ax = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Zn(), o = Kt(a), { forwardRef: s } = j();
    return (i, u) => (h(), x(l($t), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [l(r).modal.value ? (h(), x(Ex, A({
        key: 0,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(Tx, A({
        key: 1,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), hs = Ax, Ix = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Zn();
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).descriptionId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Si = Ix, Ox = /* @__PURE__ */ b({
  __name: "DialogOverlayImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Zn();
    return fs(!0), j(), (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": l(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state"
    ]));
  }
}), Rx = Ox, Vx = /* @__PURE__ */ b({
  __name: "DialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Zn(), { forwardRef: n } = j();
    return (a, r) => l(t)?.modal.value ? (h(), x(l($t), {
      key: 0,
      present: a.forceMount || l(t).open.value
    }, {
      default: y(() => [N(Rx, A(a.$attrs, {
        ref: l(n),
        as: a.as,
        "as-child": a.asChild
      }), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, ["as", "as-child"])]),
      _: 3
    }, 8, ["present"])) : Ee("v-if", !0);
  }
}), gs = Vx, Fx = /* @__PURE__ */ b({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: !1,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = pc();
    return (n, a) => l(t) || n.forceMount ? (h(), x(gi, {
      key: 0,
      to: n.to,
      disabled: n.disabled,
      defer: n.defer
    }, [_(n.$slots, "default")], 8, [
      "to",
      "disabled",
      "defer"
    ])) : Ee("v-if", !0);
  }
}), Na = Fx, Nx = /* @__PURE__ */ b({
  __name: "DialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $i = Nx, Lx = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e, n = Zn();
    return j(), (a, r) => (h(), x(l(X), A(t, { id: l(n).titleId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), ki = Lx, zx = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Zn(), { forwardRef: a, currentElement: r } = j();
    return n.contentId ||= Ge(void 0, "reka-dialog-content"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), x(l(X), A(t, {
      ref: l(a),
      type: o.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": l(n).open.value || !1,
      "aria-controls": l(n).open.value ? l(n).contentId : void 0,
      "data-state": l(n).open.value ? "open" : "closed",
      onClick: l(n).onOpenToggle
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "onClick"
    ]));
  }
}), Bi = zx, Hx = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Va), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ux = Hx;
const [jx, Wx] = Se("AlertDialogContent");
var Gx = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    j();
    const o = I();
    return Wx({ onCancelElementChange: (s) => {
      o.value = s;
    } }), (s, i) => (h(), x(l(hs), A({
      ...n,
      ...l(r)
    }, {
      role: "alertdialog",
      onPointerDownOutside: i[0] || (i[0] = Ye(() => {
      }, ["prevent"])),
      onInteractOutside: i[1] || (i[1] = Ye(() => {
      }, ["prevent"])),
      onOpenAutoFocus: i[2] || (i[2] = () => {
        Be(() => {
          o.value?.focus({ preventScroll: !0 });
        });
      })
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Kx = Gx, Yx = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = jx(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onCancelElementChange(r.value);
    }), (o, s) => (h(), x(l(Va), A(t, { ref: l(a) }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Xx = Yx, Jx = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Si), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Zx = Jx, Qx = /* @__PURE__ */ b({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(gs), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), eC = Qx, tC = /* @__PURE__ */ b({
  __name: "AlertDialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nC = tC, aC = /* @__PURE__ */ b({
  __name: "AlertDialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(xi), A(l(r), { modal: !0 }), {
      default: y((i) => [_(o.$slots, "default", oe(le(i)))]),
      _: 3
    }, 16));
  }
}), rC = aC, oC = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(ki), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sC = oC, lC = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Bi), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iC = lC, uC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "AspectRatio",
  props: {
    ratio: {
      type: Number,
      required: !1,
      default: 1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = E(() => 1 / t.ratio * 100);
    return (r, o) => (h(), W("div", {
      style: dt(`position: relative; width: 100%; padding-bottom: ${a.value}%`),
      "data-reka-aspect-ratio-wrapper": ""
    }, [N(l(X), A({
      ref: l(n),
      "as-child": r.asChild,
      as: r.as,
      style: {
        position: "absolute",
        inset: "0px"
      }
    }, r.$attrs), {
      default: y(() => [_(r.$slots, "default", { aspect: a.value })]),
      _: 3
    }, 16, ["as-child", "as"])], 4));
  }
}), dC = uC;
const [og, cC] = Se("AvatarRoot");
var fC = /* @__PURE__ */ b({
  __name: "AvatarRoot",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return j(), cC({ imageLoadingStatus: I("idle") }), (t, n) => (h(), x(l(X), {
      "as-child": t.asChild,
      as: t.as
    }, {
      default: y(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), pC = fC, vC = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = og();
    j();
    const a = I(t.delayMs === void 0);
    return Ie((r) => {
      if (t.delayMs && rn) {
        const o = window.setTimeout(() => {
          a.value = !0;
        }, t.delayMs);
        r(() => {
          window.clearTimeout(o);
        });
      }
    }), (r, o) => a.value && l(n).imageLoadingStatus.value !== "loaded" ? (h(), x(l(X), {
      key: 0,
      "as-child": r.asChild,
      as: r.as
    }, {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"])) : Ee("v-if", !0);
  }
}), mC = vC;
function Hp(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function hC(e, { referrerPolicy: t, crossOrigin: n } = {}) {
  const a = I(!1), r = I(null), o = E(() => a.value ? (!r.value && rn && (r.value = new window.Image()), r.value) : null), s = I(Hp(o.value, e.value)), i = (u) => () => {
    a.value && (s.value = u);
  };
  return Ce(() => {
    a.value = !0, Ie((u) => {
      const d = o.value;
      if (!d) return;
      s.value = Hp(d, e.value);
      const c = i("loaded"), f = i("error");
      d.addEventListener("load", c), d.addEventListener("error", f), t?.value && (d.referrerPolicy = t.value), typeof n?.value == "string" && (d.crossOrigin = n.value), u(() => {
        d.removeEventListener("load", c), d.removeEventListener("error", f);
      });
    });
  }), Qe(() => {
    a.value = !1;
  }), s;
}
var gC = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {
      type: String,
      required: !0
    },
    referrerPolicy: {
      type: null,
      required: !1
    },
    crossOrigin: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "img"
    }
  },
  emits: ["loadingStatusChange"],
  setup(e, { emit: t }) {
    const n = e, a = t, { src: r, referrerPolicy: o, crossOrigin: s } = Me(n);
    j();
    const i = og(), u = hC(r, {
      referrerPolicy: o,
      crossOrigin: s
    });
    return ve(u, (d) => {
      a("loadingStatusChange", d), d !== "idle" && (i.imageLoadingStatus.value = d);
    }, { immediate: !0 }), (d, c) => uc((h(), x(l(X), {
      role: "img",
      "as-child": d.asChild,
      as: d.as,
      src: l(r),
      "referrer-policy": l(o)
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "src",
      "referrer-policy"
    ])), [[x0, l(u) === "loaded"]]);
  }
}), yC = gC;
function bC(e) {
  function t(a) {
    return Array.isArray(e.date.value) ? e.date.value.some((r) => xt(r, a)) : e.date.value ? xt(e.date.value, a) : !1;
  }
  const n = E(() => {
    if (Array.isArray(e.date.value)) {
      if (!e.date.value.length) return !1;
      for (const a of e.date.value)
        if (e.isDateDisabled?.(a) || e.isDateUnavailable?.(a)) return !0;
    } else {
      if (!e.date.value) return !1;
      if (e.isDateDisabled?.(e.date.value) || e.isDateUnavailable?.(e.date.value)) return !0;
    }
    return !1;
  });
  return {
    isDateSelected: t,
    isInvalid: n
  };
}
function _C(e, t) {
  const n = t(e), a = n.compare(e), r = {};
  return a >= 7 && (r.day = 1), a >= No(e) && (r.month = 1), n.set({ ...r });
}
function wC(e, t) {
  const n = t(e), a = e.compare(n), r = {};
  return a >= 7 && (r.day = 35), a >= No(e) && (r.month = 13), n.set({ ...r });
}
function xC(e, t) {
  return t(e);
}
function CC(e, t) {
  return t(e);
}
function sg(e) {
  const t = C1(e.locale.value), n = E(() => {
    const g = { calendar: e.placeholder.value.calendar.identifier };
    return e.placeholder.value.calendar.identifier === "gregory" && e.placeholder.value.era === "BC" && (g.era = "short"), g;
  }), a = I(Ha({
    dateObj: e.placeholder.value,
    weekStartsOn: e.weekStartsOn.value,
    locale: e.locale.value,
    fixedWeeks: e.fixedWeeks.value,
    numberOfMonths: e.numberOfMonths.value
  })), r = E(() => a.value.map((g) => g.value));
  function o(g) {
    return !r.value.some((w) => bp(g, w));
  }
  const s = (g) => {
    if (!e.maxValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const w = a.value[a.value.length - 1].value;
    if (!g && !e.nextPage.value) {
      const S = w.add({ months: 1 }).set({ day: 1 });
      return fl(S, e.maxValue.value);
    }
    const C = _C(w, g || e.nextPage.value);
    return fl(C, e.maxValue.value);
  }, i = (g) => {
    if (!e.minValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const w = a.value[0].value;
    if (!g && !e.prevPage.value) {
      const S = w.subtract({ months: 1 }).set({ day: 35 });
      return Za(S, e.minValue.value);
    }
    const C = wC(w, g || e.prevPage.value);
    return Za(C, e.minValue.value);
  };
  function u(g) {
    return !!(e.isDateDisabled?.(g) || e.disabled.value || e.maxValue.value && fl(g, e.maxValue.value) || e.minValue.value && Za(g, e.minValue.value));
  }
  const d = (g) => !!e.isDateUnavailable?.(g), c = E(() => a.value.length ? a.value[0].rows[0].map((g) => t.dayOfWeek(Bn(g), e.weekdayFormat.value)) : []), f = (g) => {
    const w = a.value[0].value;
    if (!g && !e.nextPage.value) {
      const B = w.add({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), k = Ha({
        dateObj: B,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = k, e.placeholder.value = k[0].value.set({ day: 1 });
      return;
    }
    const C = xC(w, g || e.nextPage.value), S = Ha({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!g) {
      const B = S[0].value.compare(w);
      B >= No(w) && ($.day = 1), B >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  }, p = (g) => {
    const w = a.value[0].value;
    if (!g && !e.prevPage.value) {
      const B = w.subtract({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), k = Ha({
        dateObj: B,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = k, e.placeholder.value = k[0].value.set({ day: 1 });
      return;
    }
    const C = CC(w, g || e.prevPage.value), S = Ha({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!g) {
      const B = w.compare(S[0].value);
      B >= No(w) && ($.day = 1), B >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  };
  ve(e.placeholder, (g) => {
    r.value.some((w) => bp(w, g)) || (a.value = Ha({
      dateObj: g,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    }));
  }), ve([
    e.locale,
    e.weekStartsOn,
    e.fixedWeeks,
    e.numberOfMonths
  ], () => {
    a.value = Ha({
      dateObj: e.placeholder.value,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
  });
  const v = E(() => {
    if (!a.value.length) return "";
    if (e.locale.value !== t.getLocale() && t.setLocale(e.locale.value), a.value.length === 1) {
      const P = a.value[0].value;
      return `${t.fullMonthAndYear(Bn(P), n.value)}`;
    }
    const g = Bn(a.value[0].value), w = Bn(a.value[a.value.length - 1].value), C = t.fullMonth(g, n.value), S = t.fullMonth(w, n.value), $ = t.fullYear(g, n.value), B = t.fullYear(w, n.value);
    return $ === B ? `${C} - ${S} ${B}` : `${C} ${$} - ${S} ${B}`;
  }), m = E(() => `${e.calendarLabel.value ?? "Event Date"}, ${v.value}`);
  return {
    isDateDisabled: u,
    isDateUnavailable: d,
    isNextButtonDisabled: s,
    isPrevButtonDisabled: i,
    grid: a,
    weekdays: c,
    visibleView: r,
    isOutsideVisibleView: o,
    formatter: t,
    nextPage: f,
    prevPage: p,
    headingValue: v,
    fullCalendarLabel: m
  };
}
const SC = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, $C = {
  role: "heading",
  "aria-level": "2"
}, [Jr, kC] = Se("CalendarRoot");
var BC = /* @__PURE__ */ b({
  __name: "CalendarRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, multiple: f, minValue: p, maxValue: v, numberOfMonths: m, preventDeselect: g, isDateDisabled: w, isDateUnavailable: C, calendarLabel: S, defaultValue: $, nextPage: B, prevPage: k, dir: P, locale: D, disableDaysOutsideCurrentView: q } = Me(n), { primitiveElement: T, currentElement: M } = Ht(), O = $c(D), F = yt(P), J = Ve(n, "modelValue", a, {
      defaultValue: $.value,
      passive: n.modelValue === void 0
    }), ne = Hh({
      defaultPlaceholder: n.placeholder,
      defaultValue: J.value,
      locale: n.locale
    }), Q = Ve(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ne.copy(),
      passive: n.placeholder === void 0
    });
    function G(L) {
      Q.value = L.copy();
    }
    const { fullCalendarLabel: H, headingValue: U, isDateDisabled: se, isDateUnavailable: ee, isNextButtonDisabled: de, isPrevButtonDisabled: pe, weekdays: _e, isOutsideVisibleView: ge, nextPage: Te, prevPage: ce, formatter: R, grid: te } = sg({
      locale: O,
      placeholder: Q,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: m,
      minValue: p,
      maxValue: v,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: w.value,
      isDateUnavailable: C.value,
      calendarLabel: S,
      nextPage: B,
      prevPage: k
    }), { isInvalid: z, isDateSelected: re } = bC({
      date: J,
      isDateDisabled: se,
      isDateUnavailable: ee
    });
    ve(J, (L) => {
      if (Array.isArray(L) && L.length) {
        const be = L[L.length - 1];
        be && !Ba(Q.value, be) && G(be);
      } else !Array.isArray(L) && L && !Ba(Q.value, L) && G(L);
    });
    function ie(L) {
      if (f.value) {
        if (!J.value) J.value = [L.copy()];
        else if (Array.isArray(J.value)) {
          if (J.value.findIndex((xe) => xt(xe, L)) === -1) J.value = [...J.value, L];
          else if (!g.value) {
            const xe = J.value.filter((Fe) => !xt(Fe, L));
            if (!xe.length) {
              Q.value = L.copy(), J.value = void 0;
              return;
            }
            J.value = xe.map((Fe) => Fe.copy());
          }
        }
      } else {
        if (!J.value) {
          J.value = L.copy();
          return;
        }
        !g.value && Ba(J.value, L) ? (Q.value = L.copy(), J.value = void 0) : J.value = L.copy();
      }
    }
    return Ce(() => {
      s.value && Uh(M.value);
    }), kC({
      isDateUnavailable: ee,
      dir: F,
      isDateDisabled: se,
      locale: O,
      formatter: R,
      modelValue: J,
      placeholder: Q,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: te,
      weekDays: _e,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      multiple: f,
      numberOfMonths: m,
      readonly: o,
      preventDeselect: g,
      fullCalendarLabel: H,
      headingValue: U,
      isInvalid: z,
      isDateSelected: re,
      isNextButtonDisabled: de,
      isPrevButtonDisabled: pe,
      isOutsideVisibleView: ge,
      nextPage: Te,
      prevPage: ce,
      parentElement: M,
      onPlaceholderChange: G,
      onDateChange: ie,
      disableDaysOutsideCurrentView: q,
      minValue: p,
      maxValue: v
    }), (L, be) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: T,
      as: L.as,
      "as-child": L.asChild,
      "aria-label": l(H),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(z) ? "" : void 0,
      dir: l(F)
    }, {
      default: y(() => [_(L.$slots, "default", {
        date: l(Q),
        grid: l(te),
        weekDays: l(_e),
        weekStartsOn: l(u),
        locale: l(O),
        fixedWeeks: l(c),
        modelValue: l(J)
      }), we("div", SC, [we("div", $C, Ne(l(H)), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), DC = BC, PC = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = Jr();
    return (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isDateSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), MC = PC, EC = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = ms(), a = Jr(), { primitiveElement: r } = Ht(), o = E(() => t.day.day.toLocaleString(a.locale.value)), s = E(() => a.formatter.custom(Bn(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), i = E(() => a.isDateUnavailable?.(t.day) ?? !1), u = E(() => _h(t.day, Xr())), d = E(() => !vc(t.day, t.month)), c = E(() => a.isOutsideVisibleView(t.day)), f = E(() => a.isDateDisabled(t.day) || a.disableDaysOutsideCurrentView.value && d.value), p = E(() => !a.disabled.value && xt(t.day, a.placeholder.value)), v = E(() => a.isDateSelected(t.day));
    function m(C) {
      a.readonly.value || a.isDateDisabled(C) || a.isDateUnavailable?.(C) || a.onDateChange(C);
    }
    function g() {
      f.value || m(t.day);
    }
    function w(C) {
      if (f.value) return;
      C.preventDefault(), C.stopPropagation();
      const S = a.parentElement.value, $ = 7, B = a.dir.value === "rtl" ? -1 : 1;
      switch (C.code) {
        case n.ARROW_RIGHT:
          k(t.day, B);
          break;
        case n.ARROW_LEFT:
          k(t.day, -B);
          break;
        case n.ARROW_UP:
          k(t.day, -$);
          break;
        case n.ARROW_DOWN:
          k(t.day, $);
          break;
        case n.ENTER:
        case n.SPACE_CODE:
          m(t.day);
      }
      function k(P, D) {
        const q = P.add({ days: D });
        if (a.minValue.value && q.compare(a.minValue.value) < 0 || a.maxValue.value && q.compare(a.maxValue.value) > 0) return;
        const T = S.querySelector(`[data-value='${q.toString()}']:not([data-outside-view])`);
        if (!T) {
          if (D > 0) {
            if (a.isNextButtonDisabled()) return;
            a.nextPage();
          } else {
            if (a.isPrevButtonDisabled()) return;
            a.prevPage();
          }
          Be(() => {
            k(P, D);
          });
          return;
        }
        if (T && T.hasAttribute("data-disabled")) return k(q, D);
        a.onPlaceholderChange(q), T?.focus();
      }
    }
    return (C, S) => (h(), x(l(X), A({
      ref_key: "primitiveElement",
      ref: r
    }, t, {
      role: "button",
      "aria-label": s.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-disabled": f.value || i.value ? !0 : void 0,
      "data-selected": v.value ? !0 : void 0,
      "data-value": C.day.toString(),
      "data-disabled": f.value ? "" : void 0,
      "data-unavailable": i.value ? "" : void 0,
      "data-today": u.value ? "" : void 0,
      "data-outside-view": d.value ? "" : void 0,
      "data-outside-visible-view": c.value ? "" : void 0,
      "data-focused": p.value ? "" : void 0,
      tabindex: p.value ? 0 : d.value || f.value ? void 0 : -1,
      onClick: g,
      onKeydown: [Je(w, [
        "up",
        "down",
        "left",
        "right",
        "space",
        "enter"
      ]), S[0] || (S[0] = Je(Ye(() => {
      }, ["prevent"]), ["enter"]))]
    }), {
      default: y(() => [_(C.$slots, "default", {
        dayValue: o.value,
        disabled: f.value,
        today: u.value,
        selected: v.value,
        outsideView: d.value,
        outsideVisibleView: c.value,
        unavailable: i.value
      }, () => [Re(Ne(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-disabled",
      "data-selected",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-outside-visible-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), qC = EC, TC = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = Jr(), a = E(() => n.disabled.value ? !0 : void 0), r = E(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), x(l(X), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), AC = TC, IC = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OC = IC, RC = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VC = RC, FC = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), NC = FC, LC = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zC = LC, HC = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), UC = HC, jC = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Jr();
    return (a, r) => (h(), x(l(X), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Ne(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), WC = jC, GC = /* @__PURE__ */ b({
  __name: "CalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = Jr();
    return (r, o) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), KC = GC, YC = /* @__PURE__ */ b({
  __name: "CalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = Jr();
    return (r, o) => (h(), x(l(X), {
      "aria-label": "Previous page",
      as: t.as,
      "as-child": t.asChild,
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), XC = YC;
const Up = "data-reka-collection-item";
function st(e = {}) {
  const { key: t = "", isProvider: n = !1 } = e, a = `${t}CollectionProvider`;
  let r;
  if (n) {
    const c = I(/* @__PURE__ */ new Map());
    r = {
      collectionRef: I(),
      itemMap: c
    }, Xn(a, r);
  } else r = Cn(a);
  const o = (c = !1) => {
    const f = r.collectionRef.value;
    if (!f) return [];
    const p = Array.from(f.querySelectorAll(`[${Up}]`)), m = Array.from(r.itemMap.value.values()).sort((g, w) => p.indexOf(g.ref) - p.indexOf(w.ref));
    return c ? m : m.filter((g) => g.ref.dataset.disabled !== "");
  }, s = b({
    name: "CollectionSlot",
    setup(c, { slots: f }) {
      const { primitiveElement: p, currentElement: v } = Ht();
      return ve(v, () => {
        r.collectionRef.value = v.value;
      }), () => an(ql, { ref: p }, f);
    }
  }), i = b({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(c, { slots: f, attrs: p }) {
      const { primitiveElement: v, currentElement: m } = Ht();
      return Ie((g) => {
        if (m.value) {
          const w = C0(m.value);
          r.itemMap.value.set(w, {
            ref: m.value,
            value: c.value
          }), g(() => r.itemMap.value.delete(w));
        }
      }), () => an(ql, {
        ...p,
        [Up]: "",
        ref: v
      }, f);
    }
  }), u = E(() => Array.from(r.itemMap.value.values())), d = E(() => r.itemMap.value.size);
  return {
    getItems: o,
    reactiveItems: u,
    itemMapSize: d,
    CollectionSlot: s,
    CollectionItem: i
  };
}
const JC = "rovingFocusGroup.onEntryFocus", ZC = {
  bubbles: !1,
  cancelable: !0
}, QC = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function eS(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function lg(e, t, n) {
  const a = eS(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return QC[a];
}
function ig(e, t = !1) {
  const n = ot();
  for (const a of e)
    if (a === n || (a.focus({ preventScroll: t }), ot() !== n)) return;
}
function tS(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
const [nS, aS] = Se("RovingFocusGroup");
var rS = /* @__PURE__ */ b({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { loop: o, orientation: s, dir: i } = Me(a), u = yt(i), d = Ve(a, "currentTabStopId", r, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), c = I(!1), f = I(!1), p = I(0), { getItems: v, CollectionSlot: m } = st({ isProvider: !0 });
    function g(C) {
      const S = !f.value;
      if (C.currentTarget && C.target === C.currentTarget && S && !c.value) {
        const $ = new CustomEvent(JC, ZC);
        if (C.currentTarget.dispatchEvent($), r("entryFocus", $), !$.defaultPrevented) {
          const B = v().map((T) => T.ref).filter((T) => T.dataset.disabled !== ""), k = B.find((T) => T.getAttribute("data-active") === ""), P = B.find((T) => T.getAttribute("data-highlighted") === ""), D = B.find((T) => T.id === d.value), q = [
            k,
            P,
            D,
            ...B
          ].filter(Boolean);
          ig(q, a.preventScrollOnEntryFocus);
        }
      }
      f.value = !1;
    }
    function w() {
      setTimeout(() => {
        f.value = !1;
      }, 1);
    }
    return t({ getItems: v }), aS({
      loop: o,
      dir: u,
      orientation: s,
      currentTabStopId: d,
      onItemFocus: (C) => {
        d.value = C;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        p.value++;
      },
      onFocusableItemRemove: () => {
        p.value--;
      }
    }), (C, S) => (h(), x(l(m), null, {
      default: y(() => [N(l(X), {
        tabindex: c.value || p.value === 0 ? -1 : 0,
        "data-orientation": l(s),
        as: C.as,
        "as-child": C.asChild,
        dir: l(u),
        style: { outline: "none" },
        onMousedown: S[0] || (S[0] = ($) => f.value = !0),
        onMouseup: w,
        onFocus: g,
        onBlur: S[1] || (S[1] = ($) => c.value = !1)
      }, {
        default: y(() => [_(C.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), ys = rS, oS = /* @__PURE__ */ b({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = nS(), a = Ge(), r = E(() => t.tabStopId || a), o = E(() => n.currentTabStopId.value === r.value), { getItems: s, CollectionItem: i } = st();
    Ce(() => {
      t.focusable && n.onFocusableItemAdd();
    }), Qe(() => {
      t.focusable && n.onFocusableItemRemove();
    });
    function u(d) {
      if (d.key === "Tab" && d.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (d.target !== d.currentTarget) return;
      const c = lg(d, n.orientation.value, n.dir.value);
      if (c !== void 0) {
        if (d.metaKey || d.ctrlKey || d.altKey || !t.allowShiftKey && d.shiftKey) return;
        d.preventDefault();
        let f = [...s().map((p) => p.ref).filter((p) => p.dataset.disabled !== "")];
        if (c === "last") f.reverse();
        else if (c === "prev" || c === "next") {
          c === "prev" && f.reverse();
          const p = f.indexOf(d.currentTarget);
          f = n.loop.value ? tS(f, p + 1) : f.slice(p + 1);
        }
        Be(() => ig(f));
      }
    }
    return (d, c) => (h(), x(l(i), null, {
      default: y(() => [N(l(X), {
        tabindex: o.value ? 0 : -1,
        "data-orientation": l(n).orientation.value,
        "data-active": d.active ? "" : void 0,
        "data-disabled": d.focusable ? void 0 : "",
        as: d.as,
        "as-child": d.asChild,
        onMousedown: c[0] || (c[0] = (f) => {
          d.focusable ? l(n).onItemFocus(r.value) : f.preventDefault();
        }),
        onFocus: c[1] || (c[1] = (f) => l(n).onItemFocus(r.value)),
        onKeydown: u
      }, {
        default: y(() => [_(d.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), bs = oS, sS = /* @__PURE__ */ b({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), x(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-hidden": t.feature === "focusable" ? "true" : void 0,
      "data-hidden": t.feature === "fully-hidden" ? "" : void 0,
      tabindex: t.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: y(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), Di = sS, lS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Ht(), r = E(() => t.checked ?? t.value);
    return ve(r, (o, s) => {
      if (!a.value) return;
      const i = a.value, u = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(u, "value").set;
      if (c && o !== s) {
        const f = new Event("input", { bubbles: !0 }), p = new Event("change", { bubbles: !0 });
        c.call(i, o), i.dispatchEvent(f), i.dispatchEvent(p);
      }
    }), (o, s) => (h(), x(Di, A({
      ref_key: "primitiveElement",
      ref: n
    }, {
      ...t,
      ...o.$attrs
    }, { as: "input" }), null, 16));
  }
}), jp = lS, iS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, n = E(() => typeof t.value == "object" && Array.isArray(t.value) && t.value.length === 0 && t.required), a = E(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" || t.value === null || t.value === void 0 ? [{
      name: t.name,
      value: t.value
    }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((r, o) => typeof r == "object" ? Object.entries(r).map(([s, i]) => ({
      name: `${t.name}[${o}][${s}]`,
      value: i
    })) : {
      name: `${t.name}[${o}]`,
      value: r
    }) : t.value !== null && typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([r, o]) => ({
      name: `${t.name}[${r}]`,
      value: o
    })) : []);
    return (r, o) => (h(), W(Ke, null, [Ee(" We render single input if it's required "), n.value ? (h(), x(jp, A({ key: r.name }, {
      ...t,
      ...r.$attrs
    }, {
      name: r.name,
      value: r.value
    }), null, 16, ["name", "value"])) : (h(!0), W(Ke, { key: 1 }, Lt(a.value, (s) => (h(), x(jp, A({ key: s.name }, { ref_for: !0 }, {
      ...t,
      ...r.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), Vn = iS;
const [uS] = Se("CheckboxGroupRoot");
function Al(e) {
  return e === "indeterminate";
}
function ug(e) {
  return Al(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
const [dS, cS] = Se("CheckboxRoot");
var fS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultValue: {
      type: [Boolean, String],
      required: !1
    },
    modelValue: {
      type: [
        Boolean,
        String,
        null
      ],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: null,
      required: !1,
      default: "on"
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = uS(null), i = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), u = E(() => s?.disabled.value || n.disabled), d = E(() => Mn(s?.modelValue.value) ? i.value === "indeterminate" ? "indeterminate" : i.value : $l(s.modelValue.value, n.value));
    function c() {
      if (Mn(s?.modelValue.value))
        i.value = Al(i.value) ? !0 : !i.value;
      else {
        const v = [...s.modelValue.value || []];
        if ($l(v, n.value)) {
          const m = v.findIndex((g) => qn(g, n.value));
          v.splice(m, 1);
        } else v.push(n.value);
        s.modelValue.value = v;
      }
    }
    const f = Rn(o), p = E(() => n.id && o.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return cS({
      disabled: u,
      state: d
    }), (v, m) => (h(), x(Pt(l(s)?.rovingFocus.value ? l(bs) : l(X)), A(v.$attrs, {
      id: v.id,
      ref: l(r),
      role: "checkbox",
      "as-child": v.asChild,
      as: v.as,
      type: v.as === "button" ? "button" : void 0,
      "aria-checked": l(Al)(d.value) ? "mixed" : d.value,
      "aria-required": v.required,
      "aria-label": v.$attrs["aria-label"] || p.value,
      "data-state": l(ug)(d.value),
      "data-disabled": u.value ? "" : void 0,
      disabled: u.value,
      focusable: l(s)?.rovingFocus.value ? !u.value : void 0,
      onKeydown: Je(Ye(() => {
      }, ["prevent"]), ["enter"]),
      onClick: c
    }), {
      default: y(() => [_(v.$slots, "default", {
        modelValue: l(i),
        state: d.value
      }), l(f) && v.name && !l(s) ? (h(), x(l(Vn), {
        key: 0,
        type: "checkbox",
        checked: !!d.value,
        name: v.name,
        value: v.value,
        disabled: u.value,
        required: v.required
      }, null, 8, [
        "checked",
        "name",
        "value",
        "disabled",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "as-child",
      "as",
      "type",
      "aria-checked",
      "aria-required",
      "aria-label",
      "data-state",
      "data-disabled",
      "disabled",
      "focusable",
      "onKeydown"
    ]));
  }
}), pS = fS, vS = /* @__PURE__ */ b({
  __name: "CheckboxIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = dS();
    return (a, r) => (h(), x(l($t), { present: a.forceMount || l(Al)(l(n).state.value) || l(n).state.value === !0 }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "data-state": l(ug)(l(n).state.value),
        "data-disabled": l(n).disabled.value ? "" : void 0,
        style: { pointerEvents: "none" },
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), mS = vS;
const [dg, hS] = Se("PopperRoot");
var gS = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = I();
    return hS({
      anchor: t,
      onAnchorChange: (n) => t.value = n
    }), (n, a) => _(n.$slots, "default");
  }
}), ir = gS, yS = /* @__PURE__ */ b({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = dg();
    return sh(() => {
      r.onAnchorChange(t.reference ?? a.value);
    }), (o, s) => (h(), x(l(X), {
      ref: l(n),
      as: o.as,
      "as-child": o.asChild
    }, {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), ur = yS;
const bS = {
  key: 0,
  d: "M0 0L6 6L12 0"
}, _S = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
var wS = /* @__PURE__ */ b({
  __name: "Arrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, {
      width: n.width,
      height: n.height,
      viewBox: n.asChild ? void 0 : "0 0 12 6",
      preserveAspectRatio: n.asChild ? void 0 : "none"
    }), {
      default: y(() => [_(n.$slots, "default", {}, () => [n.rounded ? (h(), W("path", _S)) : (h(), W("path", bS))])]),
      _: 3
    }, 16, [
      "width",
      "height",
      "viewBox",
      "preserveAspectRatio"
    ]));
  }
}), xS = wS;
function CS(e) {
  return e !== null;
}
function SS(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: a, middlewareData: r } = t, s = r.arrow?.centerOffset !== 0, i = s ? 0 : e.arrowWidth, u = s ? 0 : e.arrowHeight, [d, c] = wd(n), f = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[c], p = (r.arrow?.x ?? 0) + i / 2, v = (r.arrow?.y ?? 0) + u / 2;
      let m = "", g = "";
      return d === "bottom" ? (m = s ? f : `${p}px`, g = `${-u}px`) : d === "top" ? (m = s ? f : `${p}px`, g = `${a.floating.height + u}px`) : d === "right" ? (m = `${-u}px`, g = s ? f : `${v}px`) : d === "left" && (m = `${a.floating.width + u}px`, g = s ? f : `${v}px`), { data: {
        x: m,
        y: g
      } };
    }
  };
}
function wd(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
const $S = ["top", "right", "bottom", "left"], Ta = Math.min, fn = Math.max, Il = Math.round, zs = Math.floor, Gn = (e) => ({
  x: e,
  y: e
}), kS = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, BS = {
  start: "end",
  end: "start"
};
function xd(e, t, n) {
  return fn(e, Ta(t, n));
}
function ca(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function fa(e) {
  return e.split("-")[0];
}
function Zr(e) {
  return e.split("-")[1];
}
function Mc(e) {
  return e === "x" ? "y" : "x";
}
function Ec(e) {
  return e === "y" ? "height" : "width";
}
const DS = /* @__PURE__ */ new Set(["top", "bottom"]);
function Wn(e) {
  return DS.has(fa(e)) ? "y" : "x";
}
function qc(e) {
  return Mc(Wn(e));
}
function PS(e, t, n) {
  n === void 0 && (n = !1);
  const a = Zr(e), r = qc(e), o = Ec(r);
  let s = r === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = Ol(s)), [s, Ol(s)];
}
function MS(e) {
  const t = Ol(e);
  return [Cd(e), t, Cd(t)];
}
function Cd(e) {
  return e.replace(/start|end/g, (t) => BS[t]);
}
const Wp = ["left", "right"], Gp = ["right", "left"], ES = ["top", "bottom"], qS = ["bottom", "top"];
function TS(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? Gp : Wp : t ? Wp : Gp;
    case "left":
    case "right":
      return t ? ES : qS;
    default:
      return [];
  }
}
function AS(e, t, n, a) {
  const r = Zr(e);
  let o = TS(fa(e), n === "start", a);
  return r && (o = o.map((s) => s + "-" + r), t && (o = o.concat(o.map(Cd)))), o;
}
function Ol(e) {
  return e.replace(/left|right|bottom|top/g, (t) => kS[t]);
}
function IS(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function cg(e) {
  return typeof e != "number" ? IS(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Rl(e) {
  const {
    x: t,
    y: n,
    width: a,
    height: r
  } = e;
  return {
    width: a,
    height: r,
    top: n,
    left: t,
    right: t + a,
    bottom: n + r,
    x: t,
    y: n
  };
}
function Kp(e, t, n) {
  let {
    reference: a,
    floating: r
  } = e;
  const o = Wn(t), s = qc(t), i = Ec(s), u = fa(t), d = o === "y", c = a.x + a.width / 2 - r.width / 2, f = a.y + a.height / 2 - r.height / 2, p = a[i] / 2 - r[i] / 2;
  let v;
  switch (u) {
    case "top":
      v = {
        x: c,
        y: a.y - r.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: a.y + a.height
      };
      break;
    case "right":
      v = {
        x: a.x + a.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: a.x - r.width,
        y: f
      };
      break;
    default:
      v = {
        x: a.x,
        y: a.y
      };
  }
  switch (Zr(t)) {
    case "start":
      v[s] -= p * (n && d ? -1 : 1);
      break;
    case "end":
      v[s] += p * (n && d ? -1 : 1);
      break;
  }
  return v;
}
const OS = async (e, t, n) => {
  const {
    placement: a = "bottom",
    strategy: r = "absolute",
    middleware: o = [],
    platform: s
  } = n, i = o.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: c,
    y: f
  } = Kp(d, a, u), p = a, v = {}, m = 0;
  for (let g = 0; g < i.length; g++) {
    const {
      name: w,
      fn: C
    } = i[g], {
      x: S,
      y: $,
      data: B,
      reset: k
    } = await C({
      x: c,
      y: f,
      initialPlacement: a,
      placement: p,
      strategy: r,
      middlewareData: v,
      rects: d,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    c = S ?? c, f = $ ?? f, v = {
      ...v,
      [w]: {
        ...v[w],
        ...B
      }
    }, k && m <= 50 && (m++, typeof k == "object" && (k.placement && (p = k.placement), k.rects && (d = k.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : k.rects), {
      x: c,
      y: f
    } = Kp(d, p, u)), g = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: r,
    middlewareData: v
  };
};
async function zo(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: a,
    y: r,
    platform: o,
    rects: s,
    elements: i,
    strategy: u
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: v = 0
  } = ca(t, e), m = cg(v), w = i[p ? f === "floating" ? "reference" : "floating" : f], C = Rl(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(w))) == null || n ? w : w.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(i.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: u
  })), S = f === "floating" ? {
    x: a,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, $ = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(i.floating)), B = await (o.isElement == null ? void 0 : o.isElement($)) ? await (o.getScale == null ? void 0 : o.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, k = Rl(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: S,
    offsetParent: $,
    strategy: u
  }) : S);
  return {
    top: (C.top - k.top + m.top) / B.y,
    bottom: (k.bottom - C.bottom + m.bottom) / B.y,
    left: (C.left - k.left + m.left) / B.x,
    right: (k.right - C.right + m.right) / B.x
  };
}
const RS = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: a,
      placement: r,
      rects: o,
      platform: s,
      elements: i,
      middlewareData: u
    } = t, {
      element: d,
      padding: c = 0
    } = ca(e, t) || {};
    if (d == null)
      return {};
    const f = cg(c), p = {
      x: n,
      y: a
    }, v = qc(r), m = Ec(v), g = await s.getDimensions(d), w = v === "y", C = w ? "top" : "left", S = w ? "bottom" : "right", $ = w ? "clientHeight" : "clientWidth", B = o.reference[m] + o.reference[v] - p[v] - o.floating[m], k = p[v] - o.reference[v], P = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d));
    let D = P ? P[$] : 0;
    (!D || !await (s.isElement == null ? void 0 : s.isElement(P))) && (D = i.floating[$] || o.floating[m]);
    const q = B / 2 - k / 2, T = D / 2 - g[m] / 2 - 1, M = Ta(f[C], T), O = Ta(f[S], T), F = M, J = D - g[m] - O, ne = D / 2 - g[m] / 2 + q, Q = xd(F, ne, J), G = !u.arrow && Zr(r) != null && ne !== Q && o.reference[m] / 2 - (ne < F ? M : O) - g[m] / 2 < 0, H = G ? ne < F ? ne - F : ne - J : 0;
    return {
      [v]: p[v] + H,
      data: {
        [v]: Q,
        centerOffset: ne - Q - H,
        ...G && {
          alignmentOffset: H
        }
      },
      reset: G
    };
  }
}), VS = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        middlewareData: o,
        rects: s,
        initialPlacement: i,
        platform: u,
        elements: d
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: g = !0,
        ...w
      } = ca(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const C = fa(r), S = Wn(i), $ = fa(i) === i, B = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)), k = p || ($ || !g ? [Ol(i)] : MS(i)), P = m !== "none";
      !p && P && k.push(...AS(i, g, m, B));
      const D = [i, ...k], q = await zo(t, w), T = [];
      let M = ((a = o.flip) == null ? void 0 : a.overflows) || [];
      if (c && T.push(q[C]), f) {
        const ne = PS(r, s, B);
        T.push(q[ne[0]], q[ne[1]]);
      }
      if (M = [...M, {
        placement: r,
        overflows: T
      }], !T.every((ne) => ne <= 0)) {
        var O, F;
        const ne = (((O = o.flip) == null ? void 0 : O.index) || 0) + 1, Q = D[ne];
        if (Q && (!(f === "alignment" ? S !== Wn(Q) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        M.every((U) => Wn(U.placement) === S ? U.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ne,
              overflows: M
            },
            reset: {
              placement: Q
            }
          };
        let G = (F = M.filter((H) => H.overflows[0] <= 0).sort((H, U) => H.overflows[1] - U.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!G)
          switch (v) {
            case "bestFit": {
              var J;
              const H = (J = M.filter((U) => {
                if (P) {
                  const se = Wn(U.placement);
                  return se === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  se === "y";
                }
                return !0;
              }).map((U) => [U.placement, U.overflows.filter((se) => se > 0).reduce((se, ee) => se + ee, 0)]).sort((U, se) => U[1] - se[1])[0]) == null ? void 0 : J[0];
              H && (G = H);
              break;
            }
            case "initialPlacement":
              G = i;
              break;
          }
        if (r !== G)
          return {
            reset: {
              placement: G
            }
          };
      }
      return {};
    }
  };
};
function Yp(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Xp(e) {
  return $S.some((t) => e[t] >= 0);
}
const FS = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: a = "referenceHidden",
        ...r
      } = ca(e, t);
      switch (a) {
        case "referenceHidden": {
          const o = await zo(t, {
            ...r,
            elementContext: "reference"
          }), s = Yp(o, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Xp(s)
            }
          };
        }
        case "escaped": {
          const o = await zo(t, {
            ...r,
            altBoundary: !0
          }), s = Yp(o, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Xp(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, fg = /* @__PURE__ */ new Set(["left", "top"]);
async function NS(e, t) {
  const {
    placement: n,
    platform: a,
    elements: r
  } = e, o = await (a.isRTL == null ? void 0 : a.isRTL(r.floating)), s = fa(n), i = Zr(n), u = Wn(n) === "y", d = fg.has(s) ? -1 : 1, c = o && u ? -1 : 1, f = ca(t, e);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return i && typeof m == "number" && (v = i === "end" ? m * -1 : m), u ? {
    x: v * c,
    y: p * d
  } : {
    x: p * d,
    y: v * c
  };
}
const LS = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, a;
      const {
        x: r,
        y: o,
        placement: s,
        middlewareData: i
      } = t, u = await NS(t, e);
      return s === ((n = i.offset) == null ? void 0 : n.placement) && (a = i.arrow) != null && a.alignmentOffset ? {} : {
        x: r + u.x,
        y: o + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, zS = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: a,
        placement: r
      } = t, {
        mainAxis: o = !0,
        crossAxis: s = !1,
        limiter: i = {
          fn: (w) => {
            let {
              x: C,
              y: S
            } = w;
            return {
              x: C,
              y: S
            };
          }
        },
        ...u
      } = ca(e, t), d = {
        x: n,
        y: a
      }, c = await zo(t, u), f = Wn(fa(r)), p = Mc(f);
      let v = d[p], m = d[f];
      if (o) {
        const w = p === "y" ? "top" : "left", C = p === "y" ? "bottom" : "right", S = v + c[w], $ = v - c[C];
        v = xd(S, v, $);
      }
      if (s) {
        const w = f === "y" ? "top" : "left", C = f === "y" ? "bottom" : "right", S = m + c[w], $ = m - c[C];
        m = xd(S, m, $);
      }
      const g = i.fn({
        ...t,
        [p]: v,
        [f]: m
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - a,
          enabled: {
            [p]: o,
            [f]: s
          }
        }
      };
    }
  };
}, HS = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: a,
        placement: r,
        rects: o,
        middlewareData: s
      } = t, {
        offset: i = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = ca(e, t), c = {
        x: n,
        y: a
      }, f = Wn(r), p = Mc(f);
      let v = c[p], m = c[f];
      const g = ca(i, t), w = typeof g == "number" ? {
        mainAxis: g,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...g
      };
      if (u) {
        const $ = p === "y" ? "height" : "width", B = o.reference[p] - o.floating[$] + w.mainAxis, k = o.reference[p] + o.reference[$] - w.mainAxis;
        v < B ? v = B : v > k && (v = k);
      }
      if (d) {
        var C, S;
        const $ = p === "y" ? "width" : "height", B = fg.has(fa(r)), k = o.reference[f] - o.floating[$] + (B && ((C = s.offset) == null ? void 0 : C[f]) || 0) + (B ? 0 : w.crossAxis), P = o.reference[f] + o.reference[$] + (B ? 0 : ((S = s.offset) == null ? void 0 : S[f]) || 0) - (B ? w.crossAxis : 0);
        m < k ? m = k : m > P && (m = P);
      }
      return {
        [p]: v,
        [f]: m
      };
    }
  };
}, US = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        rects: o,
        platform: s,
        elements: i
      } = t, {
        apply: u = () => {
        },
        ...d
      } = ca(e, t), c = await zo(t, d), f = fa(r), p = Zr(r), v = Wn(r) === "y", {
        width: m,
        height: g
      } = o.floating;
      let w, C;
      f === "top" || f === "bottom" ? (w = f, C = p === (await (s.isRTL == null ? void 0 : s.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (C = f, w = p === "end" ? "top" : "bottom");
      const S = g - c.top - c.bottom, $ = m - c.left - c.right, B = Ta(g - c[w], S), k = Ta(m - c[C], $), P = !t.middlewareData.shift;
      let D = B, q = k;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (q = $), (a = t.middlewareData.shift) != null && a.enabled.y && (D = S), P && !p) {
        const M = fn(c.left, 0), O = fn(c.right, 0), F = fn(c.top, 0), J = fn(c.bottom, 0);
        v ? q = m - 2 * (M !== 0 || O !== 0 ? M + O : fn(c.left, c.right)) : D = g - 2 * (F !== 0 || J !== 0 ? F + J : fn(c.top, c.bottom));
      }
      await u({
        ...t,
        availableWidth: q,
        availableHeight: D
      });
      const T = await s.getDimensions(i.floating);
      return m !== T.width || g !== T.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Pi() {
  return typeof window < "u";
}
function dr(e) {
  return Tc(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function vn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Qn(e) {
  var t;
  return (t = (Tc(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Tc(e) {
  return Pi() ? e instanceof Node || e instanceof vn(e).Node : !1;
}
function In(e) {
  return Pi() ? e instanceof Element || e instanceof vn(e).Element : !1;
}
function Jn(e) {
  return Pi() ? e instanceof HTMLElement || e instanceof vn(e).HTMLElement : !1;
}
function Jp(e) {
  return !Pi() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof vn(e).ShadowRoot;
}
const jS = /* @__PURE__ */ new Set(["inline", "contents"]);
function _s(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: a,
    display: r
  } = On(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !jS.has(r);
}
const WS = /* @__PURE__ */ new Set(["table", "td", "th"]);
function GS(e) {
  return WS.has(dr(e));
}
const KS = [":popover-open", ":modal"];
function Mi(e) {
  return KS.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const YS = ["transform", "translate", "scale", "rotate", "perspective"], XS = ["transform", "translate", "scale", "rotate", "perspective", "filter"], JS = ["paint", "layout", "strict", "content"];
function Ac(e) {
  const t = Ic(), n = In(e) ? On(e) : e;
  return YS.some((a) => n[a] ? n[a] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || XS.some((a) => (n.willChange || "").includes(a)) || JS.some((a) => (n.contain || "").includes(a));
}
function ZS(e) {
  let t = Aa(e);
  for (; Jn(t) && !zr(t); ) {
    if (Ac(t))
      return t;
    if (Mi(t))
      return null;
    t = Aa(t);
  }
  return null;
}
function Ic() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const QS = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function zr(e) {
  return QS.has(dr(e));
}
function On(e) {
  return vn(e).getComputedStyle(e);
}
function Ei(e) {
  return In(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Aa(e) {
  if (dr(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Jp(e) && e.host || // Fallback.
    Qn(e)
  );
  return Jp(t) ? t.host : t;
}
function pg(e) {
  const t = Aa(e);
  return zr(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Jn(t) && _s(t) ? t : pg(t);
}
function Ho(e, t, n) {
  var a;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const r = pg(e), o = r === ((a = e.ownerDocument) == null ? void 0 : a.body), s = vn(r);
  if (o) {
    const i = Sd(s);
    return t.concat(s, s.visualViewport || [], _s(r) ? r : [], i && n ? Ho(i) : []);
  }
  return t.concat(r, Ho(r, [], n));
}
function Sd(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function vg(e) {
  const t = On(e);
  let n = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const r = Jn(e), o = r ? e.offsetWidth : n, s = r ? e.offsetHeight : a, i = Il(n) !== o || Il(a) !== s;
  return i && (n = o, a = s), {
    width: n,
    height: a,
    $: i
  };
}
function Oc(e) {
  return In(e) ? e : e.contextElement;
}
function qr(e) {
  const t = Oc(e);
  if (!Jn(t))
    return Gn(1);
  const n = t.getBoundingClientRect(), {
    width: a,
    height: r,
    $: o
  } = vg(t);
  let s = (o ? Il(n.width) : n.width) / a, i = (o ? Il(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: s,
    y: i
  };
}
const e$ = /* @__PURE__ */ Gn(0);
function mg(e) {
  const t = vn(e);
  return !Ic() || !t.visualViewport ? e$ : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function t$(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== vn(e) ? !1 : t;
}
function tr(e, t, n, a) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = Oc(e);
  let s = Gn(1);
  t && (a ? In(a) && (s = qr(a)) : s = qr(e));
  const i = t$(o, n, a) ? mg(o) : Gn(0);
  let u = (r.left + i.x) / s.x, d = (r.top + i.y) / s.y, c = r.width / s.x, f = r.height / s.y;
  if (o) {
    const p = vn(o), v = a && In(a) ? vn(a) : a;
    let m = p, g = Sd(m);
    for (; g && a && v !== m; ) {
      const w = qr(g), C = g.getBoundingClientRect(), S = On(g), $ = C.left + (g.clientLeft + parseFloat(S.paddingLeft)) * w.x, B = C.top + (g.clientTop + parseFloat(S.paddingTop)) * w.y;
      u *= w.x, d *= w.y, c *= w.x, f *= w.y, u += $, d += B, m = vn(g), g = Sd(m);
    }
  }
  return Rl({
    width: c,
    height: f,
    x: u,
    y: d
  });
}
function qi(e, t) {
  const n = Ei(e).scrollLeft;
  return t ? t.left + n : tr(Qn(e)).left + n;
}
function hg(e, t) {
  const n = e.getBoundingClientRect(), a = n.left + t.scrollLeft - qi(e, n), r = n.top + t.scrollTop;
  return {
    x: a,
    y: r
  };
}
function n$(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: a,
    strategy: r
  } = e;
  const o = r === "fixed", s = Qn(a), i = t ? Mi(t.floating) : !1;
  if (a === s || i && o)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = Gn(1);
  const c = Gn(0), f = Jn(a);
  if ((f || !f && !o) && ((dr(a) !== "body" || _s(s)) && (u = Ei(a)), Jn(a))) {
    const v = tr(a);
    d = qr(a), c.x = v.x + a.clientLeft, c.y = v.y + a.clientTop;
  }
  const p = s && !f && !o ? hg(s, u) : Gn(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - u.scrollLeft * d.x + c.x + p.x,
    y: n.y * d.y - u.scrollTop * d.y + c.y + p.y
  };
}
function a$(e) {
  return Array.from(e.getClientRects());
}
function r$(e) {
  const t = Qn(e), n = Ei(e), a = e.ownerDocument.body, r = fn(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), o = fn(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let s = -n.scrollLeft + qi(e);
  const i = -n.scrollTop;
  return On(a).direction === "rtl" && (s += fn(t.clientWidth, a.clientWidth) - r), {
    width: r,
    height: o,
    x: s,
    y: i
  };
}
const Zp = 25;
function o$(e, t) {
  const n = vn(e), a = Qn(e), r = n.visualViewport;
  let o = a.clientWidth, s = a.clientHeight, i = 0, u = 0;
  if (r) {
    o = r.width, s = r.height;
    const c = Ic();
    (!c || c && t === "fixed") && (i = r.offsetLeft, u = r.offsetTop);
  }
  const d = qi(a);
  if (d <= 0) {
    const c = a.ownerDocument, f = c.body, p = getComputedStyle(f), v = c.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0, m = Math.abs(a.clientWidth - f.clientWidth - v);
    m <= Zp && (o -= m);
  } else d <= Zp && (o += d);
  return {
    width: o,
    height: s,
    x: i,
    y: u
  };
}
const s$ = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function l$(e, t) {
  const n = tr(e, !0, t === "fixed"), a = n.top + e.clientTop, r = n.left + e.clientLeft, o = Jn(e) ? qr(e) : Gn(1), s = e.clientWidth * o.x, i = e.clientHeight * o.y, u = r * o.x, d = a * o.y;
  return {
    width: s,
    height: i,
    x: u,
    y: d
  };
}
function Qp(e, t, n) {
  let a;
  if (t === "viewport")
    a = o$(e, n);
  else if (t === "document")
    a = r$(Qn(e));
  else if (In(t))
    a = l$(t, n);
  else {
    const r = mg(e);
    a = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return Rl(a);
}
function gg(e, t) {
  const n = Aa(e);
  return n === t || !In(n) || zr(n) ? !1 : On(n).position === "fixed" || gg(n, t);
}
function i$(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let a = Ho(e, [], !1).filter((i) => In(i) && dr(i) !== "body"), r = null;
  const o = On(e).position === "fixed";
  let s = o ? Aa(e) : e;
  for (; In(s) && !zr(s); ) {
    const i = On(s), u = Ac(s);
    !u && i.position === "fixed" && (r = null), (o ? !u && !r : !u && i.position === "static" && !!r && s$.has(r.position) || _s(s) && !u && gg(e, s)) ? a = a.filter((c) => c !== s) : r = i, s = Aa(s);
  }
  return t.set(e, a), a;
}
function u$(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: a,
    strategy: r
  } = e;
  const s = [...n === "clippingAncestors" ? Mi(t) ? [] : i$(t, this._c) : [].concat(n), a], i = s[0], u = s.reduce((d, c) => {
    const f = Qp(t, c, r);
    return d.top = fn(f.top, d.top), d.right = Ta(f.right, d.right), d.bottom = Ta(f.bottom, d.bottom), d.left = fn(f.left, d.left), d;
  }, Qp(t, i, r));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function d$(e) {
  const {
    width: t,
    height: n
  } = vg(e);
  return {
    width: t,
    height: n
  };
}
function c$(e, t, n) {
  const a = Jn(t), r = Qn(t), o = n === "fixed", s = tr(e, !0, o, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = Gn(0);
  function d() {
    u.x = qi(r);
  }
  if (a || !a && !o)
    if ((dr(t) !== "body" || _s(r)) && (i = Ei(t)), a) {
      const v = tr(t, !0, o, t);
      u.x = v.x + t.clientLeft, u.y = v.y + t.clientTop;
    } else r && d();
  o && !a && r && d();
  const c = r && !a && !o ? hg(r, i) : Gn(0), f = s.left + i.scrollLeft - u.x - c.x, p = s.top + i.scrollTop - u.y - c.y;
  return {
    x: f,
    y: p,
    width: s.width,
    height: s.height
  };
}
function Iu(e) {
  return On(e).position === "static";
}
function ev(e, t) {
  if (!Jn(e) || On(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Qn(e) === n && (n = n.ownerDocument.body), n;
}
function yg(e, t) {
  const n = vn(e);
  if (Mi(e))
    return n;
  if (!Jn(e)) {
    let r = Aa(e);
    for (; r && !zr(r); ) {
      if (In(r) && !Iu(r))
        return r;
      r = Aa(r);
    }
    return n;
  }
  let a = ev(e, t);
  for (; a && GS(a) && Iu(a); )
    a = ev(a, t);
  return a && zr(a) && Iu(a) && !Ac(a) ? n : a || ZS(e) || n;
}
const f$ = async function(e) {
  const t = this.getOffsetParent || yg, n = this.getDimensions, a = await n(e.floating);
  return {
    reference: c$(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function p$(e) {
  return On(e).direction === "rtl";
}
const v$ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: n$,
  getDocumentElement: Qn,
  getClippingRect: u$,
  getOffsetParent: yg,
  getElementRects: f$,
  getClientRects: a$,
  getDimensions: d$,
  getScale: qr,
  isElement: In,
  isRTL: p$
};
function bg(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function m$(e, t) {
  let n = null, a;
  const r = Qn(e);
  function o() {
    var i;
    clearTimeout(a), (i = n) == null || i.disconnect(), n = null;
  }
  function s(i, u) {
    i === void 0 && (i = !1), u === void 0 && (u = 1), o();
    const d = e.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: v
    } = d;
    if (i || t(), !p || !v)
      return;
    const m = zs(f), g = zs(r.clientWidth - (c + p)), w = zs(r.clientHeight - (f + v)), C = zs(c), $ = {
      rootMargin: -m + "px " + -g + "px " + -w + "px " + -C + "px",
      threshold: fn(0, Ta(1, u)) || 1
    };
    let B = !0;
    function k(P) {
      const D = P[0].intersectionRatio;
      if (D !== u) {
        if (!B)
          return s();
        D ? s(!1, D) : a = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      D === 1 && !bg(d, e.getBoundingClientRect()) && s(), B = !1;
    }
    try {
      n = new IntersectionObserver(k, {
        ...$,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(k, $);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function h$(e, t, n, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = a, d = Oc(e), c = r || o ? [...d ? Ho(d) : [], ...Ho(t)] : [];
  c.forEach((C) => {
    r && C.addEventListener("scroll", n, {
      passive: !0
    }), o && C.addEventListener("resize", n);
  });
  const f = d && i ? m$(d, n) : null;
  let p = -1, v = null;
  s && (v = new ResizeObserver((C) => {
    let [S] = C;
    S && S.target === d && v && (v.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var $;
      ($ = v) == null || $.observe(t);
    })), n();
  }), d && !u && v.observe(d), v.observe(t));
  let m, g = u ? tr(e) : null;
  u && w();
  function w() {
    const C = tr(e);
    g && !bg(g, C) && n(), g = C, m = requestAnimationFrame(w);
  }
  return n(), () => {
    var C;
    c.forEach((S) => {
      r && S.removeEventListener("scroll", n), o && S.removeEventListener("resize", n);
    }), f?.(), (C = v) == null || C.disconnect(), v = null, u && cancelAnimationFrame(m);
  };
}
const g$ = LS, y$ = zS, tv = VS, b$ = US, _$ = FS, w$ = RS, x$ = HS, C$ = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), r = {
    platform: v$,
    ...n
  }, o = {
    ...r.platform,
    _c: a
  };
  return OS(e, t, {
    ...r,
    platform: o
  });
};
function S$(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function $d(e) {
  if (S$(e)) {
    const t = e.$el;
    return Tc(t) && dr(t) === "#comment" ? null : t;
  }
  return e;
}
function $r(e) {
  return typeof e == "function" ? e() : l(e);
}
function $$(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = $d($r(e.element));
      return n == null ? {} : w$({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
function _g(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function nv(e, t) {
  const n = _g(e);
  return Math.round(t * n) / n;
}
function k$(e, t, n) {
  n === void 0 && (n = {});
  const a = n.whileElementsMounted, r = E(() => {
    var D;
    return (D = $r(n.open)) != null ? D : !0;
  }), o = E(() => $r(n.middleware)), s = E(() => {
    var D;
    return (D = $r(n.placement)) != null ? D : "bottom";
  }), i = E(() => {
    var D;
    return (D = $r(n.strategy)) != null ? D : "absolute";
  }), u = E(() => {
    var D;
    return (D = $r(n.transform)) != null ? D : !0;
  }), d = E(() => $d(e.value)), c = E(() => $d(t.value)), f = I(0), p = I(0), v = I(i.value), m = I(s.value), g = gt({}), w = I(!1), C = E(() => {
    const D = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return D;
    const q = nv(c.value, f.value), T = nv(c.value, p.value);
    return u.value ? {
      ...D,
      transform: "translate(" + q + "px, " + T + "px)",
      ..._g(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: q + "px",
      top: T + "px"
    };
  });
  let S;
  function $() {
    if (d.value == null || c.value == null)
      return;
    const D = r.value;
    C$(d.value, c.value, {
      middleware: o.value,
      placement: s.value,
      strategy: i.value
    }).then((q) => {
      f.value = q.x, p.value = q.y, v.value = q.strategy, m.value = q.placement, g.value = q.middlewareData, w.value = D !== !1;
    });
  }
  function B() {
    typeof S == "function" && (S(), S = void 0);
  }
  function k() {
    if (B(), a === void 0) {
      $();
      return;
    }
    if (d.value != null && c.value != null) {
      S = a(d.value, c.value, $);
      return;
    }
  }
  function P() {
    r.value || (w.value = !1);
  }
  return ve([o, s, i, r], $, {
    flush: "sync"
  }), ve([d, c], k, {
    flush: "sync"
  }), ve(r, P, {
    flush: "sync"
  }), ss() && ic(B), {
    x: br(f),
    y: br(p),
    strategy: br(v),
    placement: br(m),
    middlewareData: br(g),
    isPositioned: br(w),
    floatingStyles: C,
    update: $
  };
}
const wg = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [B$, D$] = Se("PopperContent");
var P$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ lh({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...wg }),
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = dg(), { forwardRef: o, currentElement: s } = j(), i = I(), u = I(), { width: d, height: c } = Kh(u), f = E(() => n.side + (n.align !== "center" ? `-${n.align}` : "")), p = E(() => typeof n.collisionPadding == "number" ? n.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...n.collisionPadding
    }), v = E(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = E(() => ({
      padding: p.value,
      boundary: v.value.filter(CS),
      altBoundary: v.value.length > 0
    })), g = E(() => ({
      mainAxis: n.sideFlip,
      crossAxis: n.alignFlip
    })), w = z0(() => [
      g$({
        mainAxis: n.sideOffset + c.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && tv({
        ...m.value,
        ...g.value
      }),
      n.avoidCollisions && y$({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? x$() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && tv({
        ...m.value,
        ...g.value
      }),
      b$({
        ...m.value,
        apply: ({ elements: F, rects: J, availableWidth: ne, availableHeight: Q }) => {
          const { width: G, height: H } = J.reference, U = F.floating.style;
          U.setProperty("--reka-popper-available-width", `${ne}px`), U.setProperty("--reka-popper-available-height", `${Q}px`), U.setProperty("--reka-popper-anchor-width", `${G}px`), U.setProperty("--reka-popper-anchor-height", `${H}px`);
        }
      }),
      u.value && $$({
        element: u.value,
        padding: n.arrowPadding
      }),
      SS({
        arrowWidth: d.value,
        arrowHeight: c.value
      }),
      n.hideWhenDetached && _$({
        strategy: "referenceHidden",
        ...m.value
      })
    ]), C = E(() => n.reference ?? r.anchor.value), { floatingStyles: S, placement: $, isPositioned: B, middlewareData: k } = k$(C, i, {
      strategy: n.positionStrategy,
      placement: f,
      whileElementsMounted: (...F) => h$(...F, {
        layoutShift: !n.disableUpdateOnLayoutShift,
        animationFrame: n.updatePositionStrategy === "always"
      }),
      middleware: w
    }), P = E(() => wd($.value)[0]), D = E(() => wd($.value)[1]);
    sh(() => {
      B.value && a("placed");
    });
    const q = E(() => k.value.arrow?.centerOffset !== 0), T = I("");
    Ie(() => {
      s.value && (T.value = window.getComputedStyle(s.value).zIndex);
    });
    const M = E(() => k.value.arrow?.x ?? 0), O = E(() => k.value.arrow?.y ?? 0);
    return D$({
      placedSide: P,
      onArrowChange: (F) => u.value = F,
      arrowX: M,
      arrowY: O,
      shouldHideArrow: q
    }), (F, J) => (h(), W("div", {
      ref_key: "floatingRef",
      ref: i,
      "data-reka-popper-content-wrapper": "",
      style: dt({
        ...l(S),
        transform: l(B) ? l(S).transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: T.value,
        "--reka-popper-transform-origin": [l(k).transformOrigin?.x, l(k).transformOrigin?.y].join(" "),
        ...l(k).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [N(l(X), A({ ref: l(o) }, F.$attrs, {
      "as-child": n.asChild,
      as: F.as,
      "data-side": P.value,
      "data-align": D.value,
      style: { animation: l(B) ? void 0 : "none" }
    }), {
      default: y(() => [_(F.$slots, "default")]),
      _: 3
    }, 16, [
      "as-child",
      "as",
      "data-side",
      "data-align",
      "style"
    ])], 4));
  }
}), Qr = P$;
const M$ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var E$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {
      type: Number,
      required: !1
    },
    height: {
      type: Number,
      required: !1
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = B$(), a = E(() => M$[n.placedSide.value]);
    return (r, o) => (h(), W("span", {
      ref: (s) => {
        l(n).onArrowChange(s);
      },
      style: dt({
        position: "absolute",
        left: l(n).arrowX?.value ? `${l(n).arrowX?.value}px` : void 0,
        top: l(n).arrowY?.value ? `${l(n).arrowY?.value}px` : void 0,
        [a.value]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[l(n).placedSide.value],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[l(n).placedSide.value],
        visibility: l(n).shouldHideArrow.value ? "hidden" : void 0
      })
    }, [N(xS, A(r.$attrs, {
      ref: l(t),
      style: { display: "block" },
      as: r.as,
      "as-child": r.asChild,
      rounded: r.rounded,
      width: r.width,
      height: r.height
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "rounded",
      "width",
      "height"
    ])], 4));
  }
}), q$ = E$, T$ = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: t } = j();
    return (n, a) => (h(), x(l(ur), {
      "as-child": "",
      reference: n.reference
    }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "as-child": n.asChild,
        as: n.as
      }, n.$attrs), {
        default: y(() => [_(n.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), A$ = T$;
function I$(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => qo(a, t, n)) : qo(e, t, n);
}
function qo(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : qn(e, t);
}
const [Ti, O$] = Se("ListboxRoot");
var R$ = /* @__PURE__ */ b({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { multiple: o, highlightOnHover: s, orientation: i, disabled: u, selectionBehavior: d, dir: c } = Me(a), { getItems: f } = st({ isProvider: !0 }), { handleTypeaheadSearch: p } = _i(), { primitiveElement: v, currentElement: m } = Ht(), g = ms(), w = yt(c), C = Rn(m), S = I(), $ = I(!1), B = I(!0), k = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (o.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function P(R) {
      if ($.value = !0, a.multiple) {
        const te = Array.isArray(k.value) ? [...k.value] : [], z = te.findIndex((re) => qo(re, R, a.by));
        a.selectionBehavior === "toggle" ? (z === -1 ? te.push(R) : te.splice(z, 1), k.value = te) : (k.value = [R], S.value = R);
      } else a.selectionBehavior === "toggle" && qo(k.value, R, a.by) ? k.value = void 0 : k.value = R;
      setTimeout(() => {
        $.value = !1;
      }, 1);
    }
    const D = I(null), q = I(null), T = I(!1), M = I(!1), O = Dr(), F = Dr(), J = Dr();
    function ne() {
      return f().map((R) => R.ref).filter((R) => R.dataset.disabled !== "");
    }
    function Q(R, te = !0) {
      if (!R) return;
      D.value = R, B.value && D.value.focus(), te && D.value.scrollIntoView({ block: "nearest" });
      const z = f().find((re) => re.ref === R);
      r("highlight", z);
    }
    function G(R) {
      if (T.value) J.trigger(R);
      else {
        const te = f().find((z) => qo(z.value, R, a.by));
        te && (D.value = te.ref, Q(te.ref));
      }
    }
    function H(R) {
      D.value && D.value.isConnected && (R.preventDefault(), R.stopPropagation(), M.value || D.value.click());
    }
    function U(R) {
      if (B.value) {
        if ($.value = !0, T.value) F.trigger(R);
        else {
          const te = R.altKey || R.ctrlKey || R.metaKey;
          if (te && R.key === "a" && o.value) {
            const z = f(), re = z.map((ie) => ie.value);
            k.value = [...re], R.preventDefault(), Q(z[z.length - 1].ref);
          } else if (!te) {
            const z = p(R.key, f());
            z && Q(z);
          }
        }
        setTimeout(() => {
          $.value = !1;
        }, 1);
      }
    }
    function se() {
      M.value = !0;
    }
    function ee() {
      Be(() => {
        M.value = !1;
      });
    }
    function de() {
      Be(() => {
        const R = new KeyboardEvent("keydown", { key: "PageUp" });
        ge(R);
      });
    }
    function pe(R) {
      const te = D.value;
      te?.isConnected && (q.value = te), D.value = null, r("leave", R);
    }
    function _e(R) {
      const te = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if (R.currentTarget?.dispatchEvent(te), r("entryFocus", te), !te.defaultPrevented)
        if (q.value) Q(q.value);
        else {
          const z = ne()?.[0];
          Q(z);
        }
    }
    function ge(R) {
      const te = lg(R, i.value, w.value);
      if (!te) return;
      let z = ne();
      if (D.value) {
        if (te === "last") z.reverse();
        else if (te === "prev" || te === "next") {
          te === "prev" && z.reverse();
          const re = z.indexOf(D.value);
          z = z.slice(re + 1);
        }
        Te(R, z[0]);
      }
      if (z.length) {
        const re = !D.value && te === "prev" ? z.length - 1 : 0;
        Q(z[re]);
      }
      if (T.value) return F.trigger(R);
    }
    function Te(R, te) {
      if (!(T.value || a.selectionBehavior !== "replace" || !o.value || !Array.isArray(k.value) || (R.altKey || R.ctrlKey || R.metaKey) && !R.shiftKey) && R.shiftKey) {
        const re = f().filter((be) => be.ref.dataset.disabled !== "");
        let ie = re.find((be) => be.ref === te)?.value;
        if (R.key === g.END ? ie = re[re.length - 1].value : R.key === g.HOME && (ie = re[0].value), !ie || !S.value) return;
        const L = F0(re.map((be) => be.value), S.value, ie);
        k.value = L;
      }
    }
    async function ce(R) {
      if (await Be(), T.value) O.trigger(R);
      else {
        const te = ne(), z = te.find((re) => re.dataset.state === "checked");
        z ? Q(z) : te.length && Q(te[0]);
      }
    }
    return ve(k, () => {
      $.value || Be(() => {
        ce();
      });
    }, {
      immediate: !0,
      deep: !0
    }), t({
      highlightedElement: D,
      highlightItem: G,
      highlightFirstItem: de,
      highlightSelected: ce,
      getItems: f
    }), O$({
      modelValue: k,
      onValueChange: P,
      multiple: o,
      orientation: i,
      dir: w,
      disabled: u,
      highlightOnHover: s,
      highlightedElement: D,
      isVirtual: T,
      virtualFocusHook: O,
      virtualKeydownHook: F,
      virtualHighlightHook: J,
      by: a.by,
      firstValue: S,
      selectionBehavior: d,
      focusable: B,
      onLeave: pe,
      onEnter: _e,
      changeHighlight: Q,
      onKeydownEnter: H,
      onKeydownNavigation: ge,
      onKeydownTypeAhead: U,
      onCompositionStart: se,
      onCompositionEnd: ee,
      highlightFirstItem: de
    }), (R, te) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: v,
      as: R.as,
      "as-child": R.asChild,
      dir: l(w),
      "data-disabled": l(u) ? "" : void 0,
      onPointerleave: pe,
      onFocusout: te[0] || (te[0] = async (z) => {
        const re = z.relatedTarget || z.target;
        await Be(), D.value && l(m) && !l(m).contains(re) && pe(z);
      })
    }, {
      default: y(() => [_(R.$slots, "default", { modelValue: l(k) }), l(C) && R.name ? (h(), x(l(Vn), {
        key: 0,
        name: R.name,
        value: l(k),
        disabled: l(u),
        required: R.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), xg = R$, V$ = /* @__PURE__ */ b({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: t } = st(), n = Ti(), a = cs(!1, 10);
    return (r, o) => (h(), x(l(t), null, {
      default: y(() => [N(l(X), {
        role: "listbox",
        as: r.as,
        "as-child": r.asChild,
        tabindex: l(n).focusable.value ? l(n).highlightedElement.value ? "-1" : "0" : "-1",
        "aria-orientation": l(n).orientation.value,
        "aria-multiselectable": !!l(n).multiple.value,
        "data-orientation": l(n).orientation.value,
        onMousedown: o[0] || (o[0] = Ye((s) => a.value = !0, ["left"])),
        onFocus: o[1] || (o[1] = (s) => {
          l(a) || l(n).onEnter(s);
        }),
        onKeydown: [
          o[2] || (o[2] = Je((s) => {
            l(n).orientation.value === "vertical" && (s.key === "ArrowLeft" || s.key === "ArrowRight") || l(n).orientation.value === "horizontal" && (s.key === "ArrowUp" || s.key === "ArrowDown") || (s.preventDefault(), l(n).focusable.value && l(n).onKeydownNavigation(s));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          Je(l(n).onKeydownEnter, ["enter"]),
          l(n).onKeydownTypeAhead
        ]
      }, {
        default: y(() => [_(r.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), Cg = V$, F$ = /* @__PURE__ */ b({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "modelValue", t, {
      defaultValue: "",
      passive: n.modelValue === void 0
    }), o = Ti(), { primitiveElement: s, currentElement: i } = Ht(), u = E(() => n.disabled || o.disabled.value || !1), d = I();
    return S0(() => d.value = o.highlightedElement.value?.id), Ce(() => {
      o.focusable.value = !1, setTimeout(() => {
        n.autoFocus && i.value?.focus();
      }, 1);
    }), Qe(() => {
      o.focusable.value = !0;
    }), (c, f) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: s,
      as: c.as,
      "as-child": c.asChild,
      value: l(r),
      disabled: u.value ? "" : void 0,
      "data-disabled": u.value ? "" : void 0,
      "aria-disabled": u.value ?? void 0,
      "aria-activedescendant": d.value,
      type: "text",
      onKeydown: [Je(Ye(l(o).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), Je(l(o).onKeydownEnter, ["enter"])],
      onInput: f[0] || (f[0] = (p) => {
        r.value = p.target.value, l(o).highlightFirstItem();
      }),
      onCompositionstart: l(o).onCompositionStart,
      onCompositionend: l(o).onCompositionEnd
    }, {
      default: y(() => [_(c.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), Sg = F$;
const [N$, L$] = Se("ListboxGroup");
var z$ = /* @__PURE__ */ b({
  __name: "ListboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-listbox-group");
    return L$({ id: n }), (a, r) => (h(), x(l(X), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), $g = z$, H$ = /* @__PURE__ */ b({
  __name: "ListboxGroupLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = N$({ id: "" });
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).id }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), U$ = H$;
const j$ = "listbox.select", [W$, G$] = Se("ListboxItem");
var K$ = /* @__PURE__ */ b({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ge(void 0, "reka-listbox-item"), { CollectionItem: o } = st(), { forwardRef: s, currentElement: i } = j(), u = Ti(), d = E(() => i.value === u.highlightedElement.value), c = E(() => I$(u.modelValue.value, n.value, u.by)), f = E(() => u.disabled.value || n.disabled);
    async function p(m) {
      a("select", m), !m?.defaultPrevented && !f.value && m && (u.onValueChange(n.value), u.changeHighlight(i.value));
    }
    function v(m) {
      const g = {
        originalEvent: m,
        value: n.value
      };
      is(j$, p, g);
    }
    return G$({ isSelected: c }), (m, g) => (h(), x(l(o), { value: m.value }, {
      default: y(() => [$0([d.value, c.value], () => N(l(X), A({ id: l(r) }, m.$attrs, {
        ref: l(s),
        role: "option",
        tabindex: l(u).focusable.value ? d.value ? "0" : "-1" : -1,
        "aria-selected": c.value,
        as: m.as,
        "as-child": m.asChild,
        disabled: f.value ? "" : void 0,
        "data-disabled": f.value ? "" : void 0,
        "data-highlighted": d.value ? "" : void 0,
        "data-state": c.value ? "checked" : "unchecked",
        onClick: v,
        onKeydown: Je(Ye(v, ["prevent"]), ["space"]),
        onPointermove: g[0] || (g[0] = () => {
          l(u).highlightedElement.value !== l(i) && l(u).highlightOnHover.value && !l(u).focusable.value && l(u).changeHighlight(l(i), !1);
        })
      }), {
        default: y(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), g, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), kg = K$, Y$ = /* @__PURE__ */ b({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = W$();
    return (a, r) => l(n).isSelected.value ? (h(), x(l(X), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), X$ = Y$;
const [ya, J$] = Se("ComboboxRoot");
var Z$ = /* @__PURE__ */ b({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    resetModelValueOnClear: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1,
      default: !0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { primitiveElement: o, currentElement: s } = Ht(), { multiple: i, disabled: u, ignoreFilter: d, resetSearchTermOnSelect: c, openOnFocus: f, openOnClick: p, dir: v, resetModelValueOnClear: m, highlightOnHover: g } = Me(a), w = yt(v), C = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (i.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), S = Ve(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function $(G) {
      S.value = G, J.value = "", G ? (await Be(), o.value?.highlightSelected(), k.value = !0, D.value?.focus()) : (k.value = !1, setTimeout(() => {
        !G && a.resetSearchTermOnBlur && B.trigger();
      }, 1));
    }
    const B = Dr(), k = I(!1), P = I(!1), D = I(), q = I(), T = E(() => o.value?.highlightedElement ?? void 0), M = I(/* @__PURE__ */ new Map()), O = I(/* @__PURE__ */ new Map()), { contains: F } = jh({ sensitivity: "base" }), J = I(""), ne = E((G) => {
      if (!J.value || a.ignoreFilter || P.value) return {
        count: M.value.size,
        items: G?.items ?? /* @__PURE__ */ new Map(),
        groups: G?.groups ?? new Set(O.value.keys())
      };
      let H = 0;
      const U = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Set();
      for (const [ee, de] of M.value) {
        const pe = F(de, J.value);
        U.set(ee, pe ? 1 : 0), pe && H++;
      }
      for (const [ee, de] of O.value) for (const pe of de) if (U.get(pe) > 0) {
        se.add(ee);
        break;
      }
      return {
        count: H,
        items: U,
        groups: se
      };
    }), Q = ht();
    return Ce(() => {
      Q?.exposed && (Q.exposed.highlightItem = o.value?.highlightItem, Q.exposed.highlightFirstItem = o.value?.highlightFirstItem, Q.exposed.highlightSelected = o.value?.highlightSelected);
    }), t({
      filtered: ne,
      highlightedElement: T,
      highlightItem: o.value?.highlightItem,
      highlightFirstItem: o.value?.highlightFirstItem,
      highlightSelected: o.value?.highlightSelected
    }), J$({
      modelValue: C,
      multiple: i,
      disabled: u,
      open: S,
      onOpenChange: $,
      contentId: "",
      isUserInputted: k,
      isVirtual: P,
      inputElement: D,
      highlightedElement: T,
      onInputElementChange: (G) => D.value = G,
      triggerElement: q,
      onTriggerElementChange: (G) => q.value = G,
      parentElement: s,
      resetSearchTermOnSelect: c,
      onResetSearchTerm: B.on,
      allItems: M,
      allGroups: O,
      filterSearch: J,
      filterState: ne,
      ignoreFilter: d,
      openOnFocus: f,
      openOnClick: p,
      resetModelValueOnClear: m
    }), (G, H) => (h(), x(l(ir), null, {
      default: y(() => [N(l(xg), A({
        ref_key: "primitiveElement",
        ref: o
      }, G.$attrs, {
        modelValue: l(C),
        "onUpdate:modelValue": H[0] || (H[0] = (U) => mt(C) ? C.value = U : null),
        style: { pointerEvents: l(S) ? "auto" : void 0 },
        as: G.as,
        "as-child": G.asChild,
        dir: l(w),
        multiple: l(i),
        name: G.name,
        required: G.required,
        disabled: l(u),
        "highlight-on-hover": l(g),
        by: a.by,
        onHighlight: H[1] || (H[1] = (U) => r("highlight", U))
      }), {
        default: y(() => [_(G.$slots, "default", {
          open: l(S),
          modelValue: l(C)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "highlight-on-hover",
        "by"
      ])]),
      _: 3
    }));
  }
}), Q$ = Z$;
const [RH, ek] = Se("ComboboxContent");
var tk = /* @__PURE__ */ b({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { position: r } = Me(n), o = ya(), { forwardRef: s, currentElement: i } = j();
    fs(n.bodyLock), vs(o.parentElement);
    const u = E(() => n.position === "popper" ? n : {}), d = he(u.value), c = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    ek({ position: r });
    const f = I(!1);
    return Ce(() => {
      o.inputElement.value && (f.value = i.value.contains(o.inputElement.value), f.value && o.inputElement.value.focus());
    }), Qe(() => {
      const p = ot();
      f.value && (!p || p === document.body) && o.triggerElement.value?.focus();
    }), (p, v) => (h(), x(l(Cg), { "as-child": "" }, {
      default: y(() => [N(l(Fa), {
        "as-child": "",
        "disable-outside-pointer-events": p.disableOutsidePointerEvents,
        onDismiss: v[0] || (v[0] = (m) => l(o).onOpenChange(!1)),
        onFocusOutside: v[1] || (v[1] = (m) => {
          l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("focusOutside", m);
        }),
        onInteractOutside: v[2] || (v[2] = (m) => a("interactOutside", m)),
        onEscapeKeyDown: v[3] || (v[3] = (m) => a("escapeKeyDown", m)),
        onPointerDownOutside: v[4] || (v[4] = (m) => {
          l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("pointerDownOutside", m);
        })
      }, {
        default: y(() => [(h(), x(Pt(l(r) === "popper" ? l(Qr) : l(X)), A({
          ...p.$attrs,
          ...l(d)
        }, {
          id: l(o).contentId,
          ref: l(s),
          "data-state": l(o).open.value ? "open" : "closed",
          style: {
            display: "flex",
            flexDirection: "column",
            outline: "none",
            ...l(r) === "popper" ? c : {}
          }
        }), {
          default: y(() => [_(p.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "style"
        ]))]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }));
  }
}), nk = tk, ak = /* @__PURE__ */ b({
  __name: "ComboboxCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = ya();
    function a() {
      n.filterSearch.value = "", n.inputElement.value && (n.inputElement.value.value = "", n.inputElement.value.focus()), n.resetModelValueOnClear?.value && (n.modelValue.value = n.multiple.value ? [] : null);
    }
    return (r, o) => (h(), x(l(X), A({ type: r.as === "button" ? "button" : void 0 }, t, {
      tabindex: "-1",
      onClick: a
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), VH = ak, rk = /* @__PURE__ */ b({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), { forwardRef: o } = j(), s = ya();
    return s.contentId ||= Ge(void 0, "reka-combobox-content"), (i, u) => (h(), x(l($t), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(nk, A({
        ...l(r),
        ...i.$attrs
      }, { ref: l(o) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), ok = rk, sk = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ya(), a = E(() => n.ignoreFilter.value ? n.allItems.value.size === 0 : n.filterState.value.count === 0);
    return (r, o) => a.value ? (h(), x(l(X), oe(A({ key: 0 }, t)), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[0] || (o[0] = Re("No options"))])]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), lk = sk;
const [Bg, ik] = Se("ComboboxGroup");
var uk = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-combobox-group"), a = ya(), r = E(() => a.ignoreFilter.value ? !0 : a.filterSearch.value ? a.filterState.value.groups.has(n) : !0), o = ik({
      id: n,
      labelId: ""
    });
    return Ce(() => {
      a.allGroups.value.has(n) || a.allGroups.value.set(n, /* @__PURE__ */ new Set());
    }), Qe(() => {
      a.allGroups.value.delete(n);
    }), (s, i) => (h(), x(l($g), A({
      id: l(n),
      "aria-labelledby": l(o).labelId
    }, t, { hidden: r.value ? void 0 : !0 }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "hidden"
    ]));
  }
}), dk = uk, ck = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ya(), o = Ti(), { primitiveElement: s, currentElement: i } = Ht(), u = Ve(n, "modelValue", a, { passive: n.modelValue === void 0 });
    Ce(() => {
      i.value && r.onInputElementChange(i.value);
    });
    function d(m) {
      r.open.value || r.onOpenChange(!0);
    }
    function c(m) {
      const g = m.target;
      r.open.value ? r.filterSearch.value = g.value : (r.onOpenChange(!0), Be(() => {
        g.value && (r.filterSearch.value = g.value, o.highlightFirstItem());
      }));
    }
    function f() {
      r.openOnFocus.value && !r.open.value && r.onOpenChange(!0);
    }
    function p() {
      r.openOnClick.value && !r.open.value && r.onOpenChange(!0);
    }
    function v() {
      const m = r.modelValue.value;
      n.displayValue ? u.value = n.displayValue(m) : !r.multiple.value && m && !Array.isArray(m) && typeof m != "object" ? u.value = m.toString() : u.value = "", Be(() => {
        u.value = u.value;
      });
    }
    return r.onResetSearchTerm(() => {
      v();
    }), ve(r.modelValue, async () => {
      !r.isUserInputted.value && r.resetSearchTermOnSelect.value && v();
    }, {
      immediate: !0,
      deep: !0
    }), ve(r.filterState, (m, g) => {
      !r.isVirtual.value && g.count === 0 && o.highlightFirstItem();
    }), (m, g) => (h(), x(l(Sg), {
      ref_key: "primitiveElement",
      ref: s,
      modelValue: l(u),
      "onUpdate:modelValue": g[0] || (g[0] = (w) => mt(u) ? u.value = w : null),
      as: m.as,
      "as-child": m.asChild,
      "auto-focus": m.autoFocus,
      disabled: m.disabled,
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: p,
      onInput: c,
      onKeydown: Je(Ye(d, ["prevent"]), ["down", "up"]),
      onFocus: f
    }, {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), fk = ck, pk = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ge(void 0, "reka-combobox-item"), o = ya(), s = Bg(null), { primitiveElement: i, currentElement: u } = Ht();
    if (n.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const d = E(() => {
      if (o.isVirtual.value || o.ignoreFilter.value || !o.filterSearch.value) return !0;
      {
        const c = o.filterState.value.items.get(r);
        return c === void 0 ? !0 : c > 0;
      }
    });
    return Ce(() => {
      o.allItems.value.set(r, n.textValue || u.value.textContent || u.value.innerText);
      const c = s?.id;
      c && (o.allGroups.value.has(c) ? o.allGroups.value.get(c)?.add(r) : o.allGroups.value.set(c, /* @__PURE__ */ new Set([r])));
    }), Qe(() => {
      o.allItems.value.delete(r);
    }), (c, f) => d.value ? (h(), x(l(kg), A({ key: 0 }, n, {
      id: l(r),
      ref_key: "primitiveElement",
      ref: i,
      disabled: l(o).disabled.value || c.disabled,
      onSelect: f[0] || (f[0] = (p) => {
        a("select", p), !p.defaultPrevented && !l(o).multiple.value && !c.disabled && !l(o).disabled.value && (p.preventDefault(), l(o).onOpenChange(!1), l(o).modelValue.value = n.value);
      })
    }), {
      default: y(() => [_(c.$slots, "default", {}, () => [Re(Ne(c.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : Ee("v-if", !0);
  }
}), vk = pk, mk = /* @__PURE__ */ b({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X$), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), FH = mk, hk = /* @__PURE__ */ b({
  __name: "ComboboxLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Bg({
      id: "",
      labelId: ""
    });
    return n.labelId ||= Ge(void 0, "reka-combobox-group-label"), (a, r) => (h(), x(l(X), A(t, { id: l(n).labelId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), gk = hk, yk = /* @__PURE__ */ b({
  __name: "ComboboxPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bk = yk, _k = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), wk = _k, xk = /* @__PURE__ */ b({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = ya(), o = E(() => t.disabled || r.disabled.value || !1);
    return Ce(() => {
      a.value && r.onTriggerElementChange(a.value);
    }), (s, i) => (h(), x(l(X), A(t, {
      ref: l(n),
      type: s.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "data-state": l(r).open.value ? "open" : "closed",
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "aria-disabled": o.value ?? void 0,
      onClick: i[0] || (i[0] = (u) => l(r).onOpenChange(!l(r).open.value))
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), NH = xk;
function Ai(e) {
  const t = us({ nonce: I() });
  return E(() => e?.value || t.nonce?.value);
}
var Ck = /* @__PURE__ */ b({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), { nonce: a } = Me(t), r = Ai(a), o = ya();
    return (s, i) => (h(), W(Ke, null, [N(l(X), A({
      ...s.$attrs,
      ...t
    }, {
      ref: l(n),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: l(o).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["style"]), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: y(() => i[0] || (i[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), Sk = Ck, $k = /* @__PURE__ */ b({
  __name: "MenuAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(ur), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ii = $k;
function kk() {
  const e = I(!1);
  return Ce(() => {
    zt("keydown", () => {
      e.value = !0;
    }, {
      capture: !0,
      passive: !0
    }), zt(["pointerdown", "pointermove"], () => {
      e.value = !1;
    }, {
      capture: !0,
      passive: !0
    });
  }), e;
}
const Bk = ph(kk), [cr, Dg] = Se(["MenuRoot", "MenuSub"], "MenuContext"), [ws, Dk] = Se("MenuRoot");
var Pk = /* @__PURE__ */ b({
  __name: "MenuRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r, dir: o } = Me(n), s = yt(o), i = Ve(n, "open", a), u = I(), d = Bk();
    return Dg({
      open: i,
      onOpenChange: (c) => {
        i.value = c;
      },
      content: u,
      onContentChange: (c) => {
        u.value = c;
      }
    }), Dk({
      onClose: () => {
        i.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: s,
      modal: r
    }), (c, f) => (h(), x(l(ir), null, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }));
  }
}), Rc = Pk;
const [Vc, Mk] = Se("MenuContent");
var Ek = /* @__PURE__ */ b({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ lh({
    loop: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    disableOutsideScroll: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...wg }),
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = cr(), o = ws(), { trapFocus: s, disableOutsidePointerEvents: i, loop: u } = Me(n);
    Sc(), fs(i.value);
    const d = I(""), c = I(0), f = I(0), p = I(null), v = I("right"), m = I(0), g = I(null), w = I(), { forwardRef: C, currentElement: S } = j(), { handleTypeaheadSearch: $ } = _i();
    ve(S, (T) => {
      r.onContentChange(T);
    }), Qe(() => {
      window.clearTimeout(c.value);
    });
    function B(T) {
      return v.value === p.value?.side && $x(T, p.value?.area);
    }
    async function k(T) {
      a("openAutoFocus", T), !T.defaultPrevented && (T.preventDefault(), S.value?.focus({ preventScroll: !0 }));
    }
    function P(T) {
      if (T.defaultPrevented) return;
      const O = T.target.closest("[data-reka-menu-content]") === T.currentTarget, F = T.ctrlKey || T.altKey || T.metaKey, J = T.key.length === 1, ne = lr(T, ot(), S.value, {
        loop: u.value,
        arrowKeyOptions: "vertical",
        dir: o?.dir.value,
        focus: !0,
        attributeName: "[data-reka-collection-item]:not([data-disabled])"
      });
      if (ne) return ne?.focus();
      if (T.code === "Space") return;
      const Q = w.value?.getItems() ?? [];
      if (O && (T.key === "Tab" && T.preventDefault(), !F && J && $(T.key, Q)), T.target !== S.value || !wx.includes(T.key)) return;
      T.preventDefault();
      const G = [...Q.map((H) => H.ref)];
      ag.includes(T.key) && G.reverse(), _d(G);
    }
    function D(T) {
      T?.currentTarget?.contains?.(T.target) || (window.clearTimeout(c.value), d.value = "");
    }
    function q(T) {
      if (!Lo(T)) return;
      const M = T.target, O = m.value !== T.clientX;
      if (T?.currentTarget?.contains(M) && O) {
        const F = T.clientX > m.value ? "right" : "left";
        v.value = F, m.value = T.clientX;
      }
    }
    return Mk({
      onItemEnter: (T) => !!B(T),
      onItemLeave: (T) => {
        B(T) || (S.value?.focus(), g.value = null);
      },
      onTriggerLeave: (T) => !!B(T),
      searchRef: d,
      pointerGraceTimerRef: f,
      onPointerGraceIntentChange: (T) => {
        p.value = T;
      }
    }), (T, M) => (h(), x(l(Ci), {
      "as-child": "",
      trapped: l(s),
      onMountAutoFocus: k,
      onUnmountAutoFocus: M[7] || (M[7] = (O) => a("closeAutoFocus", O))
    }, {
      default: y(() => [N(l(Fa), {
        "as-child": "",
        "disable-outside-pointer-events": l(i),
        onEscapeKeyDown: M[2] || (M[2] = (O) => a("escapeKeyDown", O)),
        onPointerDownOutside: M[3] || (M[3] = (O) => a("pointerDownOutside", O)),
        onFocusOutside: M[4] || (M[4] = (O) => a("focusOutside", O)),
        onInteractOutside: M[5] || (M[5] = (O) => a("interactOutside", O)),
        onDismiss: M[6] || (M[6] = (O) => a("dismiss"))
      }, {
        default: y(() => [N(l(ys), {
          ref_key: "rovingFocusGroupRef",
          ref: w,
          "current-tab-stop-id": g.value,
          "onUpdate:currentTabStopId": M[0] || (M[0] = (O) => g.value = O),
          "as-child": "",
          orientation: "vertical",
          dir: l(o).dir.value,
          loop: l(u),
          onEntryFocus: M[1] || (M[1] = (O) => {
            a("entryFocus", O), l(o).isUsingKeyboardRef.value || O.preventDefault();
          })
        }, {
          default: y(() => [N(l(Qr), {
            ref: l(C),
            role: "menu",
            as: T.as,
            "as-child": T.asChild,
            "aria-orientation": "vertical",
            "data-reka-menu-content": "",
            "data-state": l(Dc)(l(r).open.value),
            dir: l(o).dir.value,
            side: T.side,
            "side-offset": T.sideOffset,
            align: T.align,
            "align-offset": T.alignOffset,
            "avoid-collisions": T.avoidCollisions,
            "collision-boundary": T.collisionBoundary,
            "collision-padding": T.collisionPadding,
            "arrow-padding": T.arrowPadding,
            "prioritize-position": T.prioritizePosition,
            "position-strategy": T.positionStrategy,
            "update-position-strategy": T.updatePositionStrategy,
            sticky: T.sticky,
            "hide-when-detached": T.hideWhenDetached,
            reference: T.reference,
            onKeydown: P,
            onBlur: D,
            onPointermove: q
          }, {
            default: y(() => [_(T.$slots, "default")]),
            _: 3
          }, 8, [
            "as",
            "as-child",
            "data-state",
            "dir",
            "side",
            "side-offset",
            "align",
            "align-offset",
            "avoid-collisions",
            "collision-boundary",
            "collision-padding",
            "arrow-padding",
            "prioritize-position",
            "position-strategy",
            "update-position-strategy",
            "sticky",
            "hide-when-detached",
            "reference"
          ])]),
          _: 3
        }, 8, [
          "current-tab-stop-id",
          "dir",
          "loop"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Fc = Ek, qk = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Vc(), { forwardRef: a } = j(), { CollectionItem: r } = st(), o = I(!1);
    async function s(u) {
      u.defaultPrevented || Lo(u) && (t.disabled ? n.onItemLeave(u) : n.onItemEnter(u) || u.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function i(u) {
      await Be(), !u.defaultPrevented && Lo(u) && n.onItemLeave(u);
    }
    return (u, d) => (h(), x(l(r), { value: { textValue: u.textValue } }, {
      default: y(() => [N(l(X), A({
        ref: l(a),
        role: "menuitem",
        tabindex: "-1"
      }, u.$attrs, {
        as: u.as,
        "as-child": u.asChild,
        "aria-disabled": u.disabled || void 0,
        "data-disabled": u.disabled ? "" : void 0,
        "data-highlighted": o.value ? "" : void 0,
        onPointermove: s,
        onPointerleave: i,
        onFocus: d[0] || (d[0] = async (c) => {
          await Be(), !(c.defaultPrevented || u.disabled) && (o.value = !0);
        }),
        onBlur: d[1] || (d[1] = async (c) => {
          await Be(), !c.defaultPrevented && (o.value = !1);
        })
      }), {
        default: y(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-disabled",
        "data-disabled",
        "data-highlighted"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), Pg = qk, Tk = /* @__PURE__ */ b({
  __name: "MenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = ws(), i = Vc(), u = I(!1);
    async function d() {
      const c = o.value;
      if (!n.disabled && c) {
        const f = new CustomEvent(bx, {
          bubbles: !0,
          cancelable: !0
        });
        a("select", f), await Be(), f.defaultPrevented ? u.value = !1 : s.onClose();
      }
    }
    return (c, f) => (h(), x(Pg, A(n, {
      ref: l(r),
      onClick: d,
      onPointerdown: f[0] || (f[0] = () => {
        u.value = !0;
      }),
      onPointerup: f[1] || (f[1] = async (p) => {
        await Be(), !p.defaultPrevented && (u.value || p.currentTarget?.click());
      }),
      onKeydown: f[2] || (f[2] = async (p) => {
        const v = l(i).searchRef.value !== "";
        c.disabled || v && p.key === " " || l(bd).includes(p.key) && (p.currentTarget.click(), p.preventDefault());
      })
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xs = Tk;
const [Ak, Mg] = Se(["MenuCheckboxItem", "MenuRadioItem"], "MenuItemIndicatorContext");
var Ik = /* @__PURE__ */ b({
  __name: "MenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = Ak({ modelValue: I(!1) });
    return (n, a) => (h(), x(l($t), { present: n.forceMount || l(Tl)(l(t).modelValue.value) || l(t).modelValue.value === !0 }, {
      default: y(() => [N(l(X), {
        as: n.as,
        "as-child": n.asChild,
        "data-state": l(Pc)(l(t).modelValue.value)
      }, {
        default: y(() => [_(n.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Nc = Ik, Ok = /* @__PURE__ */ b({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ds(n, ["modelValue"]), o = he(r), s = Ve(n, "modelValue", a);
    return Mg({ modelValue: s }), (i, u) => (h(), x(xs, A({ role: "menuitemcheckbox" }, l(o), {
      "aria-checked": l(Tl)(l(s)) ? "mixed" : l(s),
      "data-state": l(Pc)(l(s)),
      onSelect: u[0] || (u[0] = async (d) => {
        a("select", d), l(Tl)(l(s)) ? s.value = !0 : s.value = !l(s);
      })
    }), {
      default: y(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Lc = Ok, Rk = /* @__PURE__ */ b({
  __name: "MenuRootContentModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = me(n, a), o = cr(), { forwardRef: s, currentElement: i } = j();
    return vs(i), (u, d) => (h(), x(Fc, A(l(r), {
      ref: l(s),
      "trap-focus": l(o).open.value,
      "disable-outside-pointer-events": l(o).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (c) => l(o).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = Ye((c) => a("focusOutside", c), ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), Vk = Rk, Fk = /* @__PURE__ */ b({
  __name: "MenuRootContentNonModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), o = cr();
    return (s, i) => (h(), x(Fc, A(l(r), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (u) => l(o).onOpenChange(!1))
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Nk = Fk, Lk = /* @__PURE__ */ b({
  __name: "MenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), o = cr(), s = ws();
    return (i, u) => (h(), x(l($t), { present: i.forceMount || l(o).open.value }, {
      default: y(() => [l(s).modal.value ? (h(), x(Vk, oe(A({ key: 0 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(Nk, oe(A({ key: 1 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), zc = Lk, zk = /* @__PURE__ */ b({
  __name: "MenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({ role: "group" }, t), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Oi = zk, Hk = /* @__PURE__ */ b({
  __name: "MenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Hc = Hk, Uk = /* @__PURE__ */ b({
  __name: "MenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Uc = Uk;
const [jk, Wk] = Se("MenuRadioGroup");
var Gk = /* @__PURE__ */ b({
  __name: "MenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ds(n, ["modelValue"]), o = he(r), s = Ve(n, "modelValue", a);
    return Wk({
      modelValue: s,
      onValueChange: (i) => {
        s.value = i;
      }
    }), (i, u) => (h(), x(Oi, oe(le(l(o))), {
      default: y(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16));
  }
}), jc = Gk, Kk = /* @__PURE__ */ b({
  __name: "MenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ds(n, ["value"]), o = he(r), { value: s } = Me(n), i = jk(), u = E(() => i.modelValue.value === s?.value);
    return Mg({ modelValue: u }), (d, c) => (h(), x(xs, A({ role: "menuitemradio" }, l(o), {
      "aria-checked": u.value,
      "data-state": l(Pc)(u.value),
      onSelect: c[0] || (c[0] = async (f) => {
        a("select", f), l(i).onValueChange(l(s));
      })
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Wc = Kk, Yk = /* @__PURE__ */ b({
  __name: "MenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Gc = Yk;
const [Eg, Xk] = Se("MenuSub");
var Jk = /* @__PURE__ */ b({
  __name: "MenuSub",
  props: { open: {
    type: Boolean,
    required: !1,
    default: void 0
  } },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      defaultValue: !1,
      passive: n.open === void 0
    }), o = cr(), s = I(), i = I();
    return Ie((u) => {
      o?.open.value === !1 && (r.value = !1), u(() => r.value = !1);
    }), Dg({
      open: r,
      onOpenChange: (u) => {
        r.value = u;
      },
      content: i,
      onContentChange: (u) => {
        i.value = u;
      }
    }), Xk({
      triggerId: "",
      contentId: "",
      trigger: s,
      onTriggerChange: (u) => {
        s.value = u;
      }
    }), (u, d) => (h(), x(l(ir), null, {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }));
  }
}), Kc = Jk, Zk = /* @__PURE__ */ b({
  __name: "MenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1,
      default: !0
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), o = cr(), s = ws(), i = Eg(), { forwardRef: u, currentElement: d } = j();
    return i.contentId ||= Ge(void 0, "reka-menu-sub-content"), (c, f) => (h(), x(l($t), { present: c.forceMount || l(o).open.value }, {
      default: y(() => [N(Fc, A(l(r), {
        id: l(i).contentId,
        ref: l(u),
        "aria-labelledby": l(i).triggerId,
        align: "start",
        side: l(s).dir.value === "rtl" ? "left" : "right",
        "disable-outside-pointer-events": !1,
        "disable-outside-scroll": !1,
        "trap-focus": !1,
        onOpenAutoFocus: f[0] || (f[0] = Ye((p) => {
          l(s).isUsingKeyboardRef.value && l(d)?.focus();
        }, ["prevent"])),
        onCloseAutoFocus: f[1] || (f[1] = Ye(() => {
        }, ["prevent"])),
        onFocusOutside: f[2] || (f[2] = (p) => {
          p.defaultPrevented || p.target !== l(i).trigger.value && l(o).onOpenChange(!1);
        }),
        onEscapeKeyDown: f[3] || (f[3] = (p) => {
          l(s).onClose(), p.preventDefault();
        }),
        onKeydown: f[4] || (f[4] = (p) => {
          const v = p.currentTarget?.contains(p.target), m = l(Cx)[l(s).dir.value].includes(p.key);
          v && m && (l(o).onOpenChange(!1), l(i).trigger.value?.focus(), p.preventDefault());
        })
      }), {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "side"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Yc = Zk, Qk = /* @__PURE__ */ b({
  __name: "MenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = cr(), a = ws(), r = Eg(), o = Vc(), s = I(null);
    r.triggerId ||= Ge(void 0, "reka-menu-sub-trigger");
    function i() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    Qe(() => {
      i();
    });
    function u(f) {
      !Lo(f) || o.onItemEnter(f) || !t.disabled && !n.open.value && !s.value && (o.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), i();
      }, 100));
    }
    async function d(f) {
      if (!Lo(f)) return;
      i();
      const p = n.content.value?.getBoundingClientRect();
      if (p?.width) {
        const v = n.content.value?.dataset.side, m = v === "right", g = m ? -5 : 5, w = p[m ? "left" : "right"], C = p[m ? "right" : "left"];
        o.onPointerGraceIntentChange({
          area: [
            {
              x: f.clientX + g,
              y: f.clientY
            },
            {
              x: w,
              y: p.top
            },
            {
              x: C,
              y: p.top
            },
            {
              x: C,
              y: p.bottom
            },
            {
              x: w,
              y: p.bottom
            }
          ],
          side: v
        }), window.clearTimeout(o.pointerGraceTimerRef.value), o.pointerGraceTimerRef.value = window.setTimeout(() => o.onPointerGraceIntentChange(null), 300);
      } else {
        if (o.onTriggerLeave(f)) return;
        o.onPointerGraceIntentChange(null);
      }
    }
    async function c(f) {
      const p = o.searchRef.value !== "";
      t.disabled || p && f.key === " " || xx[a.dir.value].includes(f.key) && (n.onOpenChange(!0), await Be(), n.content.value?.focus(), f.preventDefault());
    }
    return (f, p) => (h(), x(Ii, { "as-child": "" }, {
      default: y(() => [N(Pg, A(t, {
        id: l(r).triggerId,
        ref: (v) => {
          l(r)?.onTriggerChange(v?.$el);
        },
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(r).contentId,
        "data-state": l(Dc)(l(n).open.value),
        onClick: p[0] || (p[0] = async (v) => {
          t.disabled || v.defaultPrevented || (v.currentTarget.focus(), l(n).open.value || l(n).onOpenChange(!0));
        }),
        onPointermove: u,
        onPointerleave: d,
        onKeydown: c
      }), {
        default: y(() => [_(f.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-expanded",
        "aria-controls",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), Xc = Qk, eB = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Lc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), tB = eB;
const [qg, nB] = Se("ContextMenuRoot");
var aB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuRoot",
  props: {
    pressOpenDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, modal: o, pressOpenDelay: s } = Me(n);
    j();
    const i = yt(r), u = I(!1), d = I();
    return nB({
      open: u,
      onOpenChange: (c) => {
        u.value = c;
      },
      dir: i,
      modal: o,
      triggerElement: d,
      pressOpenDelay: s
    }), ve(u, (c) => {
      a("update:open", c);
    }), (c, f) => (h(), x(l(Rc), {
      open: u.value,
      "onUpdate:open": f[0] || (f[0] = (p) => u.value = p),
      dir: l(i),
      modal: l(o)
    }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), rB = aB, oB = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const o = qg(), s = I(!1);
    return (i, u) => (h(), x(l(zc), A(l(r), {
      side: "right",
      "side-offset": 2,
      align: "start",
      "update-position-strategy": "always",
      style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        !d.defaultPrevented && s.value && d.preventDefault(), s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        d.detail.originalEvent.button === 2 && d.target === l(o).triggerElement.value && d.preventDefault(), !d.defaultPrevented && !l(o).modal.value && (s.value = !0);
      })
    }), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sB = oB, lB = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Oi), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iB = lB, uB = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(xs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), dB = uB, cB = /* @__PURE__ */ b({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Nc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Tg = cB, fB = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Hc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), pB = fB, vB = /* @__PURE__ */ b({
  __name: "ContextMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Uc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), mB = vB, hB = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(jc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gB = hB, yB = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Wc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bB = yB, _B = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Gc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), wB = _B, xB = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (o, s) => (h(), x(l(Kc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), CB = xB, SB = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Yc), A(l(r), { style: {
      "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $B = SB, kB = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Xc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), BB = kB;
function av(e) {
  return e.pointerType !== "mouse";
}
var DB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { disabled: n } = Me(t), { forwardRef: a, currentElement: r } = j(), o = qg(), s = I({
      x: 0,
      y: 0
    }), i = E(() => ({ getBoundingClientRect: () => ({
      width: 0,
      height: 0,
      left: s.value.x,
      right: s.value.x,
      top: s.value.y,
      bottom: s.value.y,
      ...s.value
    }) })), u = I(0);
    function d() {
      window.clearTimeout(u.value);
    }
    function c(m) {
      s.value = {
        x: m.clientX,
        y: m.clientY
      }, o.onOpenChange(!0);
    }
    async function f(m) {
      n.value || (await Be(), m.defaultPrevented || (d(), c(m), m.preventDefault()));
    }
    async function p(m) {
      n.value || (await Be(), av(m) && !m.defaultPrevented && (d(), u.value = window.setTimeout(() => c(m), o.pressOpenDelay.value)));
    }
    async function v(m) {
      n.value || (await Be(), av(m) && !m.defaultPrevented && d());
    }
    return Ce(() => {
      r.value && (o.triggerElement.value = r.value);
    }), (m, g) => (h(), W(Ke, null, [N(l(Ii), {
      as: "template",
      reference: i.value
    }, null, 8, ["reference"]), N(l(X), A({
      ref: l(a),
      as: m.as,
      "as-child": m.asChild,
      "data-state": l(o).open.value ? "open" : "closed",
      "data-disabled": l(n) ? "" : void 0,
      style: {
        WebkitTouchCallout: "none",
        pointerEvents: "auto"
      }
    }, m.$attrs, {
      onContextmenu: f,
      onPointerdown: p,
      onPointermove: v,
      onPointercancel: v,
      onPointerup: v
    }), {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ])], 64));
  }
}), PB = DB;
const [eo, MB] = Se("PopoverRoot");
var EB = /* @__PURE__ */ b({
  __name: "PopoverRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r } = Me(n), o = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = I(), i = I(!1);
    return MB({
      contentId: "",
      triggerId: "",
      modal: r,
      open: o,
      onOpenChange: (u) => {
        o.value = u;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      triggerElement: s,
      hasCustomAnchor: i
    }), (u, d) => (h(), x(l(ir), null, {
      default: y(() => [_(u.$slots, "default", {
        open: l(o),
        close: () => o.value = !1
      })]),
      _: 3
    }));
  }
}), qB = EB, TB = /* @__PURE__ */ b({
  __name: "PopoverAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = eo();
    return k0(() => {
      n.hasCustomAnchor.value = !0;
    }), Qe(() => {
      n.hasCustomAnchor.value = !1;
    }), (a, r) => (h(), x(l(ur), oe(le(t)), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), LH = TB, AB = /* @__PURE__ */ b({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(ds(n, "trapFocus", "disableOutsidePointerEvents")), { forwardRef: o } = j(), s = eo();
    return Sc(), (i, u) => (h(), x(l(Ci), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: y(() => [N(l(Fa), {
        "as-child": "",
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        onPointerDownOutside: u[0] || (u[0] = (d) => a("pointerDownOutside", d)),
        onInteractOutside: u[1] || (u[1] = (d) => a("interactOutside", d)),
        onEscapeKeyDown: u[2] || (u[2] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[3] || (u[3] = (d) => a("focusOutside", d)),
        onDismiss: u[4] || (u[4] = (d) => l(s).onOpenChange(!1))
      }, {
        default: y(() => [N(l(Qr), A(l(r), {
          id: l(s).contentId,
          ref: l(o),
          "data-state": l(s).open.value ? "open" : "closed",
          "aria-labelledby": l(s).triggerId,
          style: {
            "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
            "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
            "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
          },
          role: "dialog"
        }), {
          default: y(() => [_(i.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "aria-labelledby"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Ag = AB, IB = /* @__PURE__ */ b({
  __name: "PopoverContentModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = eo(), o = I(!1);
    fs(!0);
    const s = me(n, a), { forwardRef: i, currentElement: u } = j();
    return vs(u), (d, c) => (h(), x(Ag, A(l(s), {
      ref: l(i),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: c[0] || (c[0] = Ye((f) => {
        a("closeAutoFocus", f), o.value || l(r).triggerElement.value?.focus();
      }, ["prevent"])),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        a("pointerDownOutside", f);
        const p = f.detail.originalEvent, v = p.button === 0 && p.ctrlKey === !0, m = p.button === 2 || v;
        o.value = m;
      }),
      onFocusOutside: c[2] || (c[2] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), OB = IB, RB = /* @__PURE__ */ b({
  __name: "PopoverContentNonModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = eo(), o = I(!1), s = I(!1), i = me(n, a);
    return (u, d) => (h(), x(Ag, A(l(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        a("closeAutoFocus", c), c.defaultPrevented || (o.value || l(r).triggerElement.value?.focus(), c.preventDefault()), o.value = !1, s.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = async (c) => {
        a("interactOutside", c), c.defaultPrevented || (o.value = !0, c.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const f = c.target;
        l(r).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && s.value && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VB = RB, FB = /* @__PURE__ */ b({
  __name: "PopoverContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = eo(), o = me(n, a), { forwardRef: s } = j();
    return r.contentId ||= Ge(void 0, "reka-popover-content"), (i, u) => (h(), x(l($t), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [l(r).modal.value ? (h(), x(OB, A({ key: 0 }, l(o), { ref: l(s) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), x(VB, A({ key: 1 }, l(o), { ref: l(s) }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), NB = FB, LB = /* @__PURE__ */ b({
  __name: "PopoverPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zB = LB, HB = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = eo(), { forwardRef: a, currentElement: r } = j();
    return n.triggerId ||= Ge(void 0, "reka-popover-trigger"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), x(Pt(l(n).hasCustomAnchor.value ? l(X) : l(ur)), { "as-child": "" }, {
      default: y(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).contentId,
        "data-state": l(n).open.value ? "open" : "closed",
        as: o.as,
        "as-child": t.asChild,
        onClick: l(n).onOpenToggle
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "aria-expanded",
        "aria-controls",
        "data-state",
        "as",
        "as-child",
        "onClick"
      ])]),
      _: 3
    }));
  }
}), UB = HB;
function jB(e) {
  const t = E(() => e.start.value ? !!e.isDateDisabled(e.start.value) : !1), n = E(() => e.end.value ? !!e.isDateDisabled(e.end.value) : !1), a = E(() => t.value || n.value ? !1 : !!(e.start.value && e.end.value && Za(e.end.value, e.start.value))), r = (p) => e.start.value ? xt(e.start.value, p) : !1, o = (p) => e.end.value ? xt(e.end.value, p) : !1, s = (p) => e.start.value && xt(e.start.value, p) || e.end.value && xt(e.end.value, p) ? !0 : e.end.value && e.start.value ? Pu(p, e.start.value, e.end.value) : !1, i = (p) => {
    if (e.isDateDisabled(p)) return !0;
    if (e.maximumDays?.value) {
      if (e.start.value && e.end.value) {
        if (e.fixedDate.value) {
          const v = gd(e.start.value, e.end.value).length;
          if (v <= e.maximumDays.value) {
            const m = e.maximumDays.value - v - 1, g = e.start.value.subtract({ days: m }), w = e.end.value.add({ days: m });
            return !Pu(p, g, w);
          }
        }
        return !1;
      }
      if (e.start.value) {
        const v = e.start.value.add({ days: e.maximumDays.value }), m = e.start.value.subtract({ days: e.maximumDays.value });
        return !Pu(p, m, v);
      }
    }
    return !e.start.value || e.end.value || xt(e.start.value, p), !1;
  }, u = (p) => !!e.isDateHighlightable?.(p), d = E(() => {
    if (e.start.value && e.end.value && !e.fixedDate.value || !e.start.value || !e.focusedValue.value) return null;
    const p = Za(e.start.value, e.focusedValue.value), v = p ? e.start.value : e.focusedValue.value, m = p ? e.focusedValue.value : e.start.value;
    if (xt(v, m)) return {
      start: v,
      end: m
    };
    if (e.maximumDays?.value && !e.end.value) {
      const w = p ? v.add({ days: e.maximumDays.value - 1 }) : v.subtract({ days: e.maximumDays.value });
      return {
        start: v,
        end: w
      };
    }
    return w1(v, m, e.allowNonContiguousRanges.value ? () => !1 : e.isDateUnavailable, i, e.isDateHighlightable) ? {
      start: v,
      end: m
    } : null;
  });
  return {
    isInvalid: a,
    isSelected: s,
    isDateHighlightable: u,
    highlightedRange: d,
    isSelectionStart: r,
    isSelectionEnd: o,
    isHighlightedStart: (p) => !d.value || !d.value.start ? !1 : xt(d.value.start, p),
    isHighlightedEnd: (p) => !d.value || !d.value.end ? !1 : xt(d.value.end, p),
    isDateDisabled: i
  };
}
const WB = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, GB = {
  role: "heading",
  "aria-level": "2"
}, [to, KB] = Se("RangeCalendarRoot");
var YB = /* @__PURE__ */ b({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: Object,
      required: !1,
      default: () => ({
        start: void 0,
        end: void 0
      })
    },
    modelValue: {
      type: [Object, null],
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    allowNonContiguousRanges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maximumDays: {
      type: Number,
      required: !1,
      default: void 0
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateHighlightable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    fixedDate: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: [
    "update:modelValue",
    "update:validModelValue",
    "update:placeholder",
    "update:startValue"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, numberOfMonths: f, preventDeselect: p, isDateUnavailable: v, isDateHighlightable: m, isDateDisabled: g, calendarLabel: w, maxValue: C, minValue: S, dir: $, locale: B, nextPage: k, prevPage: P, allowNonContiguousRanges: D, disableDaysOutsideCurrentView: q, fixedDate: T, maximumDays: M } = Me(n), { primitiveElement: O, currentElement: F } = Ht(), J = yt($), ne = $c(B), Q = I(), G = I(), H = I(!1), U = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: n.modelValue === void 0
    }), se = I(U.value);
    ve(se, (Oe) => {
      a("update:validModelValue", Oe);
    });
    const ee = Hh({
      defaultPlaceholder: n.placeholder,
      defaultValue: U.value.start,
      locale: n.locale
    }), de = I(U.value.start), pe = I(U.value.end), _e = Ve(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ee.copy(),
      passive: n.placeholder === void 0
    });
    function ge(Oe) {
      _e.value = Oe.copy();
    }
    const { fullCalendarLabel: Te, headingValue: ce, isDateDisabled: R, isDateUnavailable: te, isNextButtonDisabled: z, isPrevButtonDisabled: re, grid: ie, weekdays: L, isOutsideVisibleView: be, nextPage: xe, prevPage: Fe, formatter: Xe } = sg({
      locale: ne,
      placeholder: _e,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: f,
      minValue: S,
      maxValue: C,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: g.value,
      isDateUnavailable: v.value,
      calendarLabel: w,
      nextPage: k,
      prevPage: P
    }), { isInvalid: lt, isSelected: De, isDateHighlightable: Le, highlightedRange: Ue, isSelectionStart: We, isSelectionEnd: it, isHighlightedStart: ut, isHighlightedEnd: kt, isDateDisabled: un } = jB({
      start: de,
      end: pe,
      isDateDisabled: R,
      isDateUnavailable: te,
      isDateHighlightable: m.value,
      focusedValue: G,
      allowNonContiguousRanges: D,
      fixedDate: T,
      maximumDays: M
    });
    ve(U, (Oe, Et) => {
      (!Et?.start && Oe?.start || !Oe || !Oe.start || de.value && !Ba(Oe.start, de.value)) && (de.value = Oe?.start?.copy?.()), (!Et?.end && Oe.end || !Oe || !Oe.end || pe.value && !Ba(Oe.end, pe.value)) && (pe.value = Oe?.end?.copy?.());
    }), ve(de, (Oe) => {
      Oe && !Ba(Oe, _e.value) && ge(Oe), a("update:startValue", Oe);
    }), ve([de, pe], ([Oe, Et]) => {
      const jt = U.value;
      if (!(jt && jt.start && jt.end && Oe && Et && Ba(jt.start, Oe) && Ba(jt.end, Et)))
        if (H.value = !0, Et && Oe) {
          const Rt = Za(Et, Oe) ? {
            start: Et.copy(),
            end: Oe.copy()
          } : {
            start: Oe.copy(),
            end: Et.copy()
          };
          U.value = {
            start: Rt.start,
            end: Rt.end
          }, H.value = !1, se.value = {
            start: Rt.start.copy(),
            end: Rt.end.copy()
          };
        } else U.value = Oe ? {
          start: Oe.copy(),
          end: void 0
        } : {
          start: Et?.copy(),
          end: void 0
        };
    });
    const gn = ms();
    return zt("keydown", (Oe) => {
      Oe.key === gn.ESCAPE && H.value && (de.value = se.value.start?.copy(), pe.value = se.value.end?.copy());
    }), KB({
      isDateUnavailable: te,
      isDateHighlightable: Le,
      startValue: de,
      endValue: pe,
      formatter: Xe,
      modelValue: U,
      placeholder: _e,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: ie,
      weekDays: L,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      numberOfMonths: f,
      readonly: o,
      preventDeselect: p,
      fullCalendarLabel: Te,
      headingValue: ce,
      isInvalid: lt,
      isDateDisabled: un,
      allowNonContiguousRanges: D,
      highlightedRange: Ue,
      focusedValue: G,
      lastPressedDateValue: Q,
      isSelected: De,
      isSelectionEnd: it,
      isSelectionStart: We,
      isNextButtonDisabled: z,
      isPrevButtonDisabled: re,
      isOutsideVisibleView: be,
      nextPage: xe,
      prevPage: Fe,
      parentElement: F,
      onPlaceholderChange: ge,
      locale: ne,
      dir: J,
      isHighlightedStart: ut,
      isHighlightedEnd: kt,
      disableDaysOutsideCurrentView: q,
      fixedDate: T,
      maximumDays: M,
      minValue: S,
      maxValue: C
    }), Ce(() => {
      s.value && Uh(F.value);
    }), (Oe, Et) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: O,
      as: Oe.as,
      "as-child": Oe.asChild,
      "aria-label": l(Te),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(lt) ? "" : void 0,
      dir: l(J)
    }, {
      default: y(() => [we("div", WB, [we("div", GB, Ne(l(Te)), 1)]), _(Oe.$slots, "default", {
        date: l(_e),
        grid: l(ie),
        weekDays: l(L),
        weekStartsOn: l(u),
        locale: l(ne),
        fixedWeeks: l(c),
        modelValue: l(U)
      })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), XB = YB, JB = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = to();
    return (n, a) => (h(), x(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), ZB = JB, QB = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = to(), a = ms(), { primitiveElement: r } = Ht(), o = E(() => n.formatter.custom(Bn(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), s = E(() => n.isDateUnavailable?.(t.day) ?? !1), i = E(() => n.isSelected(t.day)), u = E(() => n.isSelectionStart(t.day)), d = E(() => n.isSelectionEnd(t.day)), c = E(() => n.isHighlightedStart(t.day)), f = E(() => n.isHighlightedEnd(t.day)), p = E(() => n.highlightedRange.value ? y1(t.day, n.highlightedRange.value.start, n.highlightedRange.value.end) : !1), v = E(() => n.allowNonContiguousRanges.value), m = E(() => _h(t.day, Xr())), g = E(() => !vc(t.day, t.month)), w = E(() => n.isOutsideVisibleView(t.day)), C = E(() => n.isDateDisabled(t.day) || n.disableDaysOutsideCurrentView.value && g.value), S = E(() => t.day.day.toLocaleString(n.locale.value)), $ = E(() => !n.disabled.value && xt(t.day, n.placeholder.value));
    function B(q, T) {
      if (!n.readonly.value && !(n.isDateDisabled(T) || n.isDateUnavailable?.(T))) {
        if (n.lastPressedDateValue.value = T.copy(), n.startValue.value && n.highlightedRange.value === null) {
          if (xt(T, n.startValue.value) && !n.preventDeselect.value && !n.endValue.value) {
            n.startValue.value = void 0, n.onPlaceholderChange(T);
            return;
          } else if (!n.endValue.value) {
            q.preventDefault(), n.lastPressedDateValue.value && xt(n.lastPressedDateValue.value, T) && (n.startValue.value = T.copy());
            return;
          }
        }
        if (n.startValue.value && n.endValue.value && xt(n.startValue.value, n.endValue.value) && xt(n.startValue.value, T) && !n.preventDeselect.value) {
          n.startValue.value = void 0, n.endValue.value = void 0, n.onPlaceholderChange(T);
          return;
        }
        n.startValue.value ? n.endValue.value ? n.endValue.value && n.startValue.value && (n.fixedDate.value ? n.fixedDate.value === "start" ? T.compare(n.startValue.value) < 0 ? n.startValue.value = T.copy() : n.endValue.value = T.copy() : n.fixedDate.value === "end" && (T.compare(n.endValue.value) > 0 ? n.endValue.value = T.copy() : n.startValue.value = T.copy()) : (n.endValue.value = void 0, n.startValue.value = T.copy())) : n.endValue.value = T.copy() : n.startValue.value = T.copy();
      }
    }
    function k(q) {
      C.value || B(q, t.day);
    }
    function P() {
      C.value || n.isDateUnavailable?.(t.day) || (n.focusedValue.value = t.day.copy());
    }
    function D(q) {
      if (C.value) return;
      q.preventDefault(), q.stopPropagation();
      const T = n.parentElement.value, M = 7, O = n.dir.value === "rtl" ? -1 : 1;
      switch (q.code) {
        case a.ARROW_RIGHT:
          F(t.day, O);
          break;
        case a.ARROW_LEFT:
          F(t.day, -O);
          break;
        case a.ARROW_UP:
          F(t.day, -M);
          break;
        case a.ARROW_DOWN:
          F(t.day, M);
          break;
        case a.ENTER:
        case a.SPACE_CODE:
          B(q, t.day);
      }
      function F(J, ne) {
        const Q = J.add({ days: ne });
        if (n.minValue.value && Q.compare(n.minValue.value) < 0 || n.maxValue.value && Q.compare(n.maxValue.value) > 0) return;
        const G = T.querySelector(`[data-value='${Q.toString()}']:not([data-outside-view])`);
        if (!G) {
          if (ne > 0) {
            if (n.isNextButtonDisabled()) return;
            n.nextPage();
          } else {
            if (n.isPrevButtonDisabled()) return;
            n.prevPage();
          }
          Be(() => {
            F(J, ne);
          });
          return;
        }
        if (G && G.hasAttribute("data-disabled")) return F(Q, ne);
        n.onPlaceholderChange(Q), G?.focus();
      }
    }
    return (q, T) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: r,
      as: q.as,
      "as-child": q.asChild,
      role: "button",
      "aria-label": o.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-pressed": i.value && (v.value || !s.value) ? !0 : void 0,
      "aria-disabled": C.value || s.value ? !0 : void 0,
      "data-highlighted": p.value && (v.value || !s.value) ? "" : void 0,
      "data-selection-start": u.value ? !0 : void 0,
      "data-selection-end": d.value ? !0 : void 0,
      "data-highlighted-start": c.value ? !0 : void 0,
      "data-highlighted-end": f.value ? !0 : void 0,
      "data-selected": i.value && (v.value || !s.value) ? !0 : void 0,
      "data-outside-visible-view": w.value ? "" : void 0,
      "data-value": q.day.toString(),
      "data-disabled": C.value ? "" : void 0,
      "data-unavailable": s.value ? "" : void 0,
      "data-today": m.value ? "" : void 0,
      "data-outside-view": g.value ? "" : void 0,
      "data-focused": $.value ? "" : void 0,
      tabindex: $.value ? 0 : g.value || C.value ? void 0 : -1,
      onClick: k,
      onFocusin: P,
      onMouseenter: P,
      onKeydown: Je(D, [
        "up",
        "down",
        "left",
        "right",
        "enter",
        "space"
      ])
    }, {
      default: y(() => [_(q.$slots, "default", {
        dayValue: S.value,
        disabled: C.value,
        today: m.value,
        selected: i.value,
        outsideView: g.value,
        outsideVisibleView: w.value,
        unavailable: s.value,
        highlighted: p.value && (v.value || !s.value),
        highlightedStart: c.value,
        highlightedEnd: f.value,
        selectionStart: u.value,
        selectionEnd: d.value
      }, () => [Re(Ne(S.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "aria-pressed",
      "aria-disabled",
      "data-highlighted",
      "data-selection-start",
      "data-selection-end",
      "data-highlighted-start",
      "data-highlighted-end",
      "data-selected",
      "data-outside-visible-view",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), eD = QB, tD = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = to(), a = E(() => n.disabled.value ? !0 : void 0), r = E(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), x(l(X), A(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), nD = tD, aD = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rD = aD, oD = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A(t, { "aria-hidden": "true" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sD = oD, lD = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iD = lD, uD = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), dD = uD, cD = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), fD = cD, pD = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = to();
    return (a, r) => (h(), x(l(X), A(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: y(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Ne(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), vD = pD, mD = /* @__PURE__ */ b({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = to();
    return (r, o) => (h(), x(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), hD = mD, gD = /* @__PURE__ */ b({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = E(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = to();
    return (r, o) => (h(), x(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Previous page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: y(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), yD = gD, bD = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Lc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _D = bD;
const [Ig, wD] = Se("DropdownMenuRoot");
var xD = /* @__PURE__ */ b({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = I(), { modal: s, dir: i } = Me(n), u = yt(i);
    return wD({
      open: r,
      onOpenChange: (d) => {
        r.value = d;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      triggerId: "",
      triggerElement: o,
      contentId: "",
      modal: s,
      dir: u
    }), (d, c) => (h(), x(l(Rc), {
      open: l(r),
      "onUpdate:open": c[0] || (c[0] = (f) => mt(r) ? r.value = f : null),
      dir: l(u),
      modal: l(s)
    }, {
      default: y(() => [_(d.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), CD = xD, SD = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const o = Ig(), s = I(!1);
    function i(u) {
      u.defaultPrevented || (s.value || setTimeout(() => {
        o.triggerElement.value?.focus();
      }, 0), s.value = !1, u.preventDefault());
    }
    return o.contentId ||= Ge(void 0, "reka-dropdown-menu-content"), (u, d) => (h(), x(l(zc), A(l(r), {
      id: l(o).contentId,
      "aria-labelledby": l(o)?.triggerId,
      style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: i,
      onInteractOutside: d[0] || (d[0] = (c) => {
        if (c.defaultPrevented) return;
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, v = f.button === 2 || p;
        (!l(o).modal.value || v) && (s.value = !0), l(o).triggerElement.value?.contains(c.target) && c.preventDefault();
      })
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), $D = SD, kD = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Oi), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), BD = kD, DD = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(xs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), PD = DD, MD = /* @__PURE__ */ b({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Nc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Og = MD, ED = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Hc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), qD = ED, TD = /* @__PURE__ */ b({
  __name: "DropdownMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Uc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), AD = TD, ID = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(jc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OD = ID, RD = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Wc), oe(le(l(r))), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VD = RD, FD = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Gc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ND = FD, LD = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "open", t, {
      passive: n.open === void 0,
      defaultValue: n.defaultOpen ?? !1
    });
    return j(), (o, s) => (h(), x(l(Kc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), zD = LD, HD = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Yc), A(l(r), { style: {
      "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), UD = HD, jD = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Xc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), WD = jD, GD = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Ig(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.triggerElement = r;
    }), n.triggerId ||= Ge(void 0, "reka-dropdown-menu-trigger"), (o, s) => (h(), x(l(Ii), { "as-child": "" }, {
      default: y(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "as-child": t.asChild,
        as: o.as,
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).open.value ? l(n).contentId : void 0,
        "data-disabled": o.disabled ? "" : void 0,
        disabled: o.disabled,
        "data-state": l(n).open.value ? "open" : "closed",
        onClick: s[0] || (s[0] = async (i) => {
          !o.disabled && i.button === 0 && i.ctrlKey === !1 && (l(n)?.onOpenToggle(), await Be(), l(n).open.value && i.preventDefault());
        }),
        onKeydown: s[1] || (s[1] = Je((i) => {
          o.disabled || (["Enter", " "].includes(i.key) && l(n).onOpenToggle(), i.key === "ArrowDown" && l(n).onOpenChange(!0), [
            "Enter",
            " ",
            "ArrowDown"
          ].includes(i.key) && i.preventDefault());
        }, [
          "enter",
          "space",
          "arrow-down"
        ]))
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as-child",
        "as",
        "aria-expanded",
        "aria-controls",
        "data-disabled",
        "disabled",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), KD = GD;
const [Jc, YD] = Se("HoverCardRoot");
var XD = /* @__PURE__ */ b({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    openDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    closeDelay: {
      type: Number,
      required: !1,
      default: 300
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { openDelay: r, closeDelay: o } = Me(n);
    j();
    const s = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = I(0), u = I(0), d = I(!1), c = I(!1), f = I(!1), p = I();
    function v() {
      clearTimeout(u.value), i.value = window.setTimeout(() => s.value = !0, r.value);
    }
    function m() {
      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => s.value = !1, o.value));
    }
    function g() {
      s.value = !1;
    }
    return YD({
      open: s,
      onOpenChange(w) {
        s.value = w;
      },
      onOpen: v,
      onClose: m,
      onDismiss: g,
      hasSelectionRef: d,
      isPointerDownOnContentRef: c,
      isPointerInTransitRef: f,
      triggerElement: p
    }), (w, C) => (h(), x(l(ir), null, {
      default: y(() => [_(w.$slots, "default", { open: l(s) })]),
      _: 3
    }));
  }
}), JD = XD;
function kd(e) {
  return (t) => t.pointerType === "touch" ? void 0 : e();
}
function ZD(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
var QD = /* @__PURE__ */ b({
  __name: "HoverCardContentImpl",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(n), { forwardRef: o, currentElement: s } = j(), i = Jc(), { isPointerInTransit: u, onPointerExit: d } = Wh(i.triggerElement, s);
    tw(i.isPointerInTransitRef, u, { direction: "rtl" }), d(() => {
      i.onClose();
    });
    const c = I(!1);
    let f;
    Ie((v) => {
      if (c.value) {
        const m = document.body;
        f = m.style.userSelect || m.style.webkitUserSelect, m.style.userSelect = "none", m.style.webkitUserSelect = "none", v(() => {
          m.style.userSelect = f, m.style.webkitUserSelect = f;
        });
      }
    });
    function p() {
      c.value = !1, i.isPointerDownOnContentRef.value = !1, Be(() => {
        document.getSelection()?.toString() !== "" && (i.hasSelectionRef.value = !0);
      });
    }
    return Ce(() => {
      s.value && (document.addEventListener("pointerup", p), ZD(s.value).forEach((m) => m.setAttribute("tabindex", "-1")));
    }), Qe(() => {
      document.removeEventListener("pointerup", p), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;
    }), (v, m) => (h(), x(l(Fa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: m[1] || (m[1] = (g) => a("escapeKeyDown", g)),
      onPointerDownOutside: m[2] || (m[2] = (g) => a("pointerDownOutside", g)),
      onFocusOutside: m[3] || (m[3] = Ye((g) => a("focusOutside", g), ["prevent"])),
      onDismiss: l(i).onDismiss
    }, {
      default: y(() => [N(l(Qr), A({
        ...l(r),
        ...v.$attrs
      }, {
        ref: l(o),
        "data-state": l(i).open.value ? "open" : "closed",
        style: {
          userSelect: c.value ? "text" : void 0,
          WebkitUserSelect: c.value ? "text" : void 0,
          "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
          "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
          "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onPointerdown: m[0] || (m[0] = (g) => {
          g.currentTarget.contains(g.target) && (c.value = !0), l(i).hasSelectionRef.value = !1, l(i).isPointerDownOnContentRef.value = !0;
        })
      }), {
        default: y(() => [_(v.$slots, "default")]),
        _: 3
      }, 16, ["data-state", "style"])]),
      _: 3
    }, 8, ["onDismiss"]));
  }
}), eP = QD, tP = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t), { forwardRef: o } = j(), s = Jc();
    return (i, u) => (h(), x(l($t), { present: i.forceMount || l(s).open.value }, {
      default: y(() => [N(eP, A(l(r), {
        ref: l(o),
        onPointerenter: u[0] || (u[0] = (d) => l(kd)(l(s).onOpen)(d))
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), nP = tP, aP = /* @__PURE__ */ b({
  __name: "HoverCardPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rP = aP, oP = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  setup(e) {
    const { forwardRef: t, currentElement: n } = j(), a = Jc();
    a.triggerElement = n;
    function r() {
      setTimeout(() => {
        !a.isPointerInTransitRef.value && !a.open.value && a.onClose();
      }, 0);
    }
    return (o, s) => (h(), x(l(ur), {
      "as-child": "",
      reference: o.reference
    }, {
      default: y(() => [N(l(X), {
        ref: l(t),
        "as-child": o.asChild,
        as: o.as,
        "data-state": l(a).open.value ? "open" : "closed",
        "data-grace-area-trigger": "",
        onPointerenter: s[0] || (s[0] = (i) => l(kd)(l(a).onOpen)(i)),
        onPointerleave: s[1] || (s[1] = (i) => l(kd)(r)(i)),
        onFocus: s[2] || (s[2] = (i) => l(a).onOpen()),
        onBlur: s[3] || (s[3] = (i) => l(a).onClose())
      }, {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "data-state"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), sP = oP, lP = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "label"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { onMousedown: a[0] || (a[0] = (r) => {
      !r.defaultPrevented && r.detail > 1 && r.preventDefault();
    }) }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iP = lP, uP = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(Lc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), dP = uP;
const [Ri, cP] = Se("MenubarRoot");
var fP = /* @__PURE__ */ b({
  __name: "MenubarRoot",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r } = j(), { CollectionSlot: o } = st({
      key: "Menubar",
      isProvider: !0
    }), s = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), i = I(null), { dir: u, loop: d } = Me(n), c = yt(u);
    return cP({
      modelValue: s,
      dir: c,
      loop: d,
      onMenuOpen: (f) => {
        s.value = f, i.value = f;
      },
      onMenuClose: () => {
        s.value = "";
      },
      onMenuToggle: (f) => {
        s.value = s.value ? "" : f, i.value = f;
      }
    }), (f, p) => (h(), x(l(o), null, {
      default: y(() => [N(l(ys), {
        "current-tab-stop-id": i.value,
        "onUpdate:currentTabStopId": p[0] || (p[0] = (v) => i.value = v),
        orientation: "horizontal",
        loop: l(d),
        dir: l(c),
        "as-child": ""
      }, {
        default: y(() => [N(l(X), {
          ref: l(r),
          role: "menubar"
        }, {
          default: y(() => [_(f.$slots, "default", { modelValue: l(s) })]),
          _: 3
        }, 512)]),
        _: 3
      }, 8, [
        "current-tab-stop-id",
        "loop",
        "dir"
      ])]),
      _: 3
    }));
  }
}), pP = fP;
const [Zc, vP] = Se("MenubarMenu");
var mP = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: { value: {
    type: String,
    required: !1
  } },
  setup(e) {
    const n = Ge(e.value), a = Ri();
    j();
    const r = I(), o = I(!1), s = E(() => a.modelValue.value === n);
    return ve(s, () => {
      s.value || (o.value = !1);
    }), vP({
      value: n,
      triggerElement: r,
      triggerId: n,
      contentId: "",
      wasKeyboardTriggerOpenRef: o
    }), (i, u) => (h(), x(l(Rc), {
      open: s.value,
      modal: !1,
      dir: l(a).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || l(a).onMenuClose();
      })
    }, {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), hP = mP, gP = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const o = Ri(), s = Zc();
    s.contentId ||= Ge(void 0, "reka-menubar-content");
    const { getItems: i } = st({ key: "Menubar" }), u = I(!1);
    function d(c) {
      const p = c.target.hasAttribute("data-reka-menubar-subtrigger"), m = (o.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!m && p) return;
      let w = i().filter(($) => $.ref.dataset.disabled !== "").map(($) => $.ref.dataset.value);
      m && w.reverse();
      const C = w.indexOf(s.value);
      w = o.loop.value ? kc(w, C + 1) : w.slice(C + 1);
      const [S] = w;
      S && o.onMenuOpen(S);
    }
    return (c, f) => (h(), x(l(zc), A(l(r), {
      id: l(s).contentId,
      "data-reka-menubar-content": "",
      "aria-labelledby": l(s).triggerId,
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (p) => {
        !l(o).modelValue.value && !u.value && l(s).triggerElement.value?.focus(), u.value = !1, p.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (p) => {
        const v = p.target;
        l(i)().filter((g) => g.ref.dataset.disabled !== "").some((g) => g.ref.contains(v)) && p.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (p) => {
        u.value = !0;
      }),
      onEntryFocus: f[3] || (f[3] = (p) => {
        l(s).wasKeyboardTriggerOpenRef.value || p.preventDefault();
      }),
      onKeydown: Je(d, ["arrow-right", "arrow-left"])
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), yP = gP, bP = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Oi), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _P = bP, wP = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(xs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xP = wP, CP = /* @__PURE__ */ b({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Nc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Rg = CP, SP = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Hc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $P = SP, kP = /* @__PURE__ */ b({
  __name: "MenubarPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Uc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Vg = kP, BP = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Kt(t);
    return j(), (o, s) => (h(), x(l(jc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), DP = BP, PP = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {
      type: String,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return j(), (o, s) => (h(), x(l(Wc), oe(le(l(r))), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), MP = PP, EP = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Gc), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), qP = EP, TP = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    return (o, s) => (h(), x(l(Kc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null)
    }, {
      default: y(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), AP = TP, IP = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = me(e, t);
    j();
    const { getItems: o } = st({ key: "Menubar" }), s = Ri(), i = Zc();
    function u(d) {
      if (d.target.hasAttribute("data-reka-menubar-subtrigger")) return;
      let p = o().filter((g) => g.ref.dataset.disabled !== "").map((g) => g.ref.dataset.value);
      const v = p.indexOf(i.value);
      p = s.loop.value ? kc(p, v + 1) : p.slice(v + 1);
      const [m] = p;
      m && s.onMenuOpen(m);
    }
    return (d, c) => (h(), x(l(Yc), A(l(r), {
      "data-reka-menubar-content": "",
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onKeydown: Je(u, ["arrow-right"])
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OP = IP, RP = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(Xc), A(t, { "data-reka-menubar-subtrigger": "" }), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), VP = RP, FP = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = Ri(), n = Zc(), { forwardRef: a, currentElement: r } = j(), { CollectionItem: o } = st({ key: "Menubar" }), s = I(!1), i = E(() => t.modelValue.value === n.value);
    return Ce(() => {
      n.triggerElement = r;
    }), (u, d) => (h(), x(l(bs), {
      "as-child": "",
      focusable: !u.disabled,
      "tab-stop-id": l(n).value
    }, {
      default: y(() => [N(l(o), null, {
        default: y(() => [N(l(Ii), { "as-child": "" }, {
          default: y(() => [N(l(X), {
            id: l(n).triggerId,
            ref: l(a),
            as: u.as,
            "as-child": u.asChild,
            type: u.as === "button" ? "button" : void 0,
            role: "menuitem",
            "aria-haspopup": "menu",
            "aria-expanded": i.value,
            "aria-controls": i.value ? l(n).contentId : void 0,
            "data-highlighted": s.value ? "" : void 0,
            "data-state": i.value ? "open" : "closed",
            "data-disabled": u.disabled ? "" : void 0,
            disabled: u.disabled,
            "data-value": l(n).value,
            onPointerdown: d[0] || (d[0] = (c) => {
              !u.disabled && c.button === 0 && c.ctrlKey === !1 && (l(t).onMenuOpen(l(n).value), i.value || c.preventDefault());
            }),
            onPointerenter: d[1] || (d[1] = () => {
              l(t).modelValue.value && !i.value && (l(t).onMenuOpen(l(n).value), l(r)?.focus());
            }),
            onKeydown: d[2] || (d[2] = Je((c) => {
              u.disabled || (["Enter", " "].includes(c.key) && l(t).onMenuToggle(l(n).value), c.key === "ArrowDown" && l(t).onMenuOpen(l(n).value), [
                "Enter",
                " ",
                "ArrowDown"
              ].includes(c.key) && (l(n).wasKeyboardTriggerOpenRef.value = !0, c.preventDefault()));
            }, [
              "enter",
              "space",
              "arrow-down"
            ])),
            onFocus: d[3] || (d[3] = (c) => s.value = !0),
            onBlur: d[4] || (d[4] = (c) => s.value = !1)
          }, {
            default: y(() => [_(u.$slots, "default")]),
            _: 3
          }, 8, [
            "id",
            "as",
            "as-child",
            "type",
            "aria-expanded",
            "aria-controls",
            "data-highlighted",
            "data-state",
            "data-disabled",
            "disabled",
            "data-value"
          ])]),
          _: 3
        })]),
        _: 3
      })]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), NP = FP;
const [fr, LP] = Se(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var zP = /* @__PURE__ */ b({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: void 0
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: 200
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableClickTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableHoverTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disablePointerLeaveClose: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Ve(n, "modelValue", t, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), o = I(""), { forwardRef: s, currentElement: i } = j(), u = I(), d = I(), c = I(), { getItems: f, CollectionSlot: p } = st({
      key: "NavigationMenu",
      isProvider: !0
    }), { delayDuration: v, skipDelayDuration: m, dir: g, disableClickTrigger: w, disableHoverTrigger: C, unmountOnHide: S } = Me(n), $ = yt(g), B = cs(!1, m), k = E(() => r.value !== "" || B.value ? 150 : v.value), P = fc((D) => {
      typeof D == "string" && (o.value = r.value, r.value = D);
    }, k);
    return Ie(() => {
      if (!r.value) return;
      const D = f().map((q) => q.ref);
      c.value = D.find((q) => q.id.includes(r.value));
    }), LP({
      isRootMenu: !0,
      modelValue: r,
      previousValue: o,
      baseId: Ge(void 0, "reka-navigation-menu"),
      disableClickTrigger: w,
      disableHoverTrigger: C,
      dir: $,
      unmountOnHide: S,
      orientation: n.orientation,
      rootNavigationMenu: i,
      indicatorTrack: u,
      activeTrigger: c,
      onIndicatorTrackChange: (D) => {
        u.value = D;
      },
      viewport: d,
      onViewportChange: (D) => {
        d.value = D;
      },
      onTriggerEnter: (D) => {
        P(D);
      },
      onTriggerLeave: () => {
        B.value = !0, P("");
      },
      onContentEnter: () => {
        P();
      },
      onContentLeave: () => {
        n.disablePointerLeaveClose || P("");
      },
      onItemSelect: (D) => {
        o.value = r.value, r.value = D;
      },
      onItemDismiss: () => {
        o.value = r.value, r.value = "";
      }
    }), (D, q) => (h(), x(l(p), null, {
      default: y(() => [N(l(X), {
        ref: l(s),
        "aria-label": "Main",
        as: D.as,
        "as-child": D.asChild,
        "data-orientation": D.orientation,
        dir: l($),
        "data-reka-navigation-menu": ""
      }, {
        default: y(() => [_(D.$slots, "default", { modelValue: l(r) })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-orientation",
        "dir"
      ])]),
      _: 3
    }));
  }
}), HP = zP;
function Vi(e) {
  return e ? "open" : "closed";
}
function Fg(e, t) {
  return `${e}-trigger-${t}`;
}
function Qc(e, t) {
  return `${e}-content-${t}`;
}
const UP = "navigationMenu.linkSelect", pl = "navigationMenu.rootContentDismiss";
function Bd(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Ng(e) {
  const t = ot();
  return e.some((n) => n === t ? !0 : (n.focus(), ot() !== t));
}
function jP(e) {
  return e.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    e.forEach((t) => {
      const n = t.dataset.tabindex;
      t.setAttribute("tabindex", n);
    });
  };
}
function Lg(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
const [ef, WP] = Se("NavigationMenuItem");
var GP = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  setup(e) {
    const t = e;
    j();
    const { getItems: n } = st({ key: "NavigationMenu" }), a = fr(), r = Ge(t.value), o = I(), s = I(), i = Qc(a.baseId, r);
    let u = () => ({});
    const d = I(!1);
    async function c(m = "start") {
      const g = document.getElementById(i);
      if (g) {
        u();
        const w = Bd(g);
        w.length && Ng(m === "start" ? w : w.reverse());
      }
    }
    function f() {
      const m = document.getElementById(i);
      if (m) {
        const g = Bd(m);
        g.length && (u = jP(g));
      }
    }
    WP({
      value: r,
      contentId: i,
      triggerRef: o,
      focusProxyRef: s,
      wasEscapeCloseRef: d,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function p() {
      a.onItemDismiss(), o.value?.focus();
    }
    function v(m) {
      const g = ot();
      if (m.keyCode === 32 || m.key === "Enter") if (a.modelValue.value === r) {
        p(), m.preventDefault();
        return;
      } else {
        m.target.click(), m.preventDefault();
        return;
      }
      const w = n().filter((S) => S.ref.parentElement?.hasAttribute("data-menu-item")).map((S) => S.ref);
      if (!w.includes(g)) return;
      const C = lr(m, g, void 0, {
        itemsArray: w,
        loop: !1
      });
      C && C?.focus(), m.preventDefault(), m.stopPropagation();
    }
    return (m, g) => (h(), x(l(X), {
      "as-child": m.asChild,
      as: m.as,
      "data-menu-item": "",
      onKeydown: Je(v, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end",
        "space"
      ])
    }, {
      default: y(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), KP = GP, YP = /* @__PURE__ */ b({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = fr(), u = ef(), d = Fg(i.baseId, u.value), c = Qc(i.baseId, u.value), f = I(null), p = E(() => {
      const S = r().map((q) => q.ref.id.split("trigger-")[1]);
      i.dir.value === "rtl" && S.reverse();
      const $ = S.indexOf(i.modelValue.value), B = S.indexOf(i.previousValue.value), k = u.value === i.modelValue.value, P = B === S.indexOf(u.value);
      if (!k && !P) return f.value;
      const D = (() => {
        if ($ !== B) {
          if (k && B !== -1) return $ > B ? "from-end" : "from-start";
          if (P && $ !== -1) return $ > B ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = D, D;
    });
    function v(S) {
      if (a("focusOutside", S), a("interactOutside", S), S.detail.originalEvent.target.hasAttribute("data-navigation-menu-trigger") && S.preventDefault(), !S.defaultPrevented) {
        u.onContentFocusOutside();
        const B = S.target;
        i.rootNavigationMenu?.value?.contains(B) && S.preventDefault();
      }
    }
    function m(S) {
      if (a("pointerDownOutside", S), !S.defaultPrevented) {
        const $ = S.target, B = r().some((P) => P.ref.contains($)), k = i.isRootMenu && i.viewport.value?.contains($);
        (B || k || !i.isRootMenu) && S.preventDefault();
      }
    }
    Ie((S) => {
      const $ = s.value;
      if (i.isRootMenu && $) {
        const B = () => {
          i.onItemDismiss(), u.onRootContentClose(), $.contains(ot()) && u.triggerRef.value?.focus();
        };
        $.addEventListener(pl, B), S(() => $.removeEventListener(pl, B));
      }
    });
    function g(S) {
      a("escapeKeyDown", S), S.defaultPrevented || (i.onItemDismiss(), u.triggerRef?.value?.focus(), u.wasEscapeCloseRef.value = !0);
    }
    function w(S) {
      if (S.target.closest("[data-reka-navigation-menu]") !== i.rootNavigationMenu.value) return;
      const $ = S.altKey || S.ctrlKey || S.metaKey, B = S.key === "Tab" && !$, k = Bd(S.currentTarget);
      if (B) {
        const D = ot(), q = k.findIndex((O) => O === D), M = S.shiftKey ? k.slice(0, q).reverse() : k.slice(q + 1, k.length);
        if (Ng(M)) S.preventDefault();
        else {
          u.focusProxyRef.value?.focus();
          return;
        }
      }
      lr(S, ot(), void 0, {
        itemsArray: k,
        loop: !1,
        enableIgnoredElement: !0
      })?.focus();
    }
    function C() {
      const S = new Event(pl, {
        bubbles: !0,
        cancelable: !0
      });
      s.value?.dispatchEvent(S);
    }
    return (S, $) => (h(), x(l(Fa), A({
      id: l(c),
      ref: l(o),
      "aria-labelledby": l(d),
      "data-motion": p.value,
      "data-state": l(Vi)(l(i).modelValue.value === l(u).value),
      "data-orientation": l(i).orientation
    }, n, {
      onKeydown: w,
      onEscapeKeyDown: g,
      onPointerDownOutside: m,
      onFocusOutside: v,
      onDismiss: C
    }), {
      default: y(() => [_(S.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "data-motion",
      "data-state",
      "data-orientation"
    ]));
  }
}), XP = YP, JP = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = me(ds(n, "forceMount"), a), { forwardRef: o } = j(), s = fr(), i = ef(), u = E(() => i.value === s.modelValue.value), d = E(() => s.viewport.value && !s.modelValue.value && s.previousValue.value ? s.previousValue.value === i.value : !1);
    return (c, f) => (h(), x(gi, {
      to: l(rn) && l(s).viewport.value ? l(s).viewport.value : "body",
      disabled: l(rn) && l(s).viewport.value ? !l(s).viewport.value : !0
    }, [N(l($t), {
      present: c.forceMount || u.value || d.value,
      "force-mount": !l(s).unmountOnHide.value
    }, {
      default: y(({ present: p }) => [N(XP, A({
        ref: l(o),
        "data-state": l(Vi)(u.value),
        style: { pointerEvents: !u.value && l(s).isRootMenu ? "none" : void 0 }
      }, {
        ...c.$attrs,
        ...l(r)
      }, {
        hidden: !p,
        onPointerenter: f[0] || (f[0] = (v) => l(s).onContentEnter(l(i).value)),
        onPointerleave: f[1] || (f[1] = (v) => l(Lg)(() => l(s).onContentLeave())(v)),
        onPointerDownOutside: f[2] || (f[2] = (v) => a("pointerDownOutside", v)),
        onFocusOutside: f[3] || (f[3] = (v) => a("focusOutside", v)),
        onInteractOutside: f[4] || (f[4] = (v) => a("interactOutside", v))
      }), {
        default: y(() => [_(c.$slots, "default")]),
        _: 2
      }, 1040, [
        "data-state",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"])], 8, ["to", "disabled"]));
  }
}), ZP = JP, QP = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = fr(), r = I(), o = E(() => a.orientation === "horizontal"), s = E(() => !!a.modelValue.value), { activeTrigger: i } = a;
    function u() {
      i.value && (r.value = {
        size: o.value ? i.value.offsetWidth : i.value.offsetHeight,
        position: o.value ? i.value.offsetLeft : i.value.offsetTop
      });
    }
    return Ie(() => {
      a.modelValue.value && u();
    }), Tn(i, u), Tn(a.indicatorTrack, u), (d, c) => l(a).indicatorTrack.value ? (h(), x(gi, {
      key: 0,
      to: l(a).indicatorTrack.value
    }, [N(l($t), { present: d.forceMount || s.value }, {
      default: y(() => [N(l(X), A({
        ref: l(n),
        "aria-hidden": "true",
        "data-state": s.value ? "visible" : "hidden",
        "data-orientation": l(a).orientation,
        "as-child": t.asChild,
        as: d.as,
        style: { ...r.value ? {
          "--reka-navigation-menu-indicator-size": `${r.value.size}px`,
          "--reka-navigation-menu-indicator-position": `${r.value.position}px`
        } : {} }
      }, d.$attrs), {
        default: y(() => [_(d.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }, 8, ["present"])], 8, ["to"])) : Ee("v-if", !0);
  }
}), eM = QP, tM = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { CollectionItem: r } = st({ key: "NavigationMenu" });
    j();
    async function o(s) {
      const i = new CustomEvent(UP, {
        bubbles: !0,
        cancelable: !0,
        detail: { originalEvent: s }
      });
      if (a("select", i), !i.defaultPrevented && !s.metaKey) {
        const u = new CustomEvent(pl, {
          bubbles: !0,
          cancelable: !0
        });
        s.target?.dispatchEvent(u);
      }
    }
    return (s, i) => (h(), x(l(r), null, {
      default: y(() => [N(l(X), {
        as: s.as,
        "data-active": s.active ? "" : void 0,
        "aria-current": s.active ? "page" : void 0,
        "as-child": n.asChild,
        onClick: o
      }, {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "data-active",
        "aria-current",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), nM = tM, aM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  setup(e) {
    const t = e, n = fr(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onIndicatorTrackChange(r.value);
    }), (o, s) => (h(), x(l(X), {
      ref: l(a),
      style: { position: "relative" }
    }, {
      default: y(() => [N(l(X), A(o.$attrs, {
        "as-child": t.asChild,
        as: o.as,
        "data-orientation": l(n).orientation
      }), {
        default: y(() => [_(o.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-orientation"
      ])]),
      _: 3
    }, 512));
  }
}), rM = aM;
const oM = ["aria-owns"];
var sM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = fr(), a = ef(), { CollectionItem: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = I(""), u = I(""), d = cs(!1, 300), c = I(!1), f = E(() => a.value === n.modelValue.value);
    Ce(() => {
      a.triggerRef = s, i.value = Fg(n.baseId, a.value), u.value = Qc(n.baseId, a.value);
    });
    function p() {
      n.disableHoverTrigger.value || (c.value = !1, a.wasEscapeCloseRef.value = !1);
    }
    function v($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled || c.value || a.wasEscapeCloseRef.value || d.value) return;
        n.onTriggerEnter(a.value), d.value = !0;
      }
    }
    function m($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled) return;
        n.onTriggerLeave(), d.value = !1;
      }
    }
    function g($) {
      (!("pointerType" in $) || $.pointerType === "mouse") && n.disableClickTrigger.value || d.value || (f.value ? n.onItemSelect("") : n.onItemSelect(a.value), c.value = f.value);
    }
    function w($) {
      const k = {
        horizontal: "ArrowDown",
        vertical: n.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight"
      }[n.orientation];
      f.value && $.key === k && (a.onEntryKeyDown(), $.preventDefault(), $.stopPropagation());
    }
    function C($) {
      a.focusProxyRef.value = Gt($);
    }
    function S($) {
      const B = document.getElementById(a.contentId), k = $.relatedTarget, P = k === s.value, D = B?.contains(k);
      (P || !D) && a.onFocusProxyEnter(P ? "start" : "end");
    }
    return ($, B) => (h(), W(Ke, null, [N(l(r), null, {
      default: y(() => [N(l(X), A({
        id: i.value,
        ref: l(o),
        disabled: $.disabled,
        "data-disabled": $.disabled ? "" : void 0,
        "data-state": l(Vi)(f.value),
        "data-navigation-menu-trigger": "",
        "aria-expanded": f.value,
        "aria-controls": u.value,
        "as-child": t.asChild,
        as: $.as
      }, $.$attrs, {
        onPointerenter: p,
        onPointermove: v,
        onPointerleave: m,
        onClick: g,
        onKeydown: w
      }), {
        default: y(() => [_($.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "disabled",
        "data-disabled",
        "data-state",
        "aria-expanded",
        "aria-controls",
        "as-child",
        "as"
      ])]),
      _: 3
    }), f.value ? (h(), W(Ke, { key: 0 }, [N(l(Di), {
      ref: C,
      "aria-hidden": "true",
      tabindex: 0,
      onFocus: S
    }), l(n).viewport ? (h(), W("span", {
      key: 0,
      "aria-owns": u.value
    }, null, 8, oM)) : Ee("v-if", !0)], 64)) : Ee("v-if", !0)], 64));
  }
}), lM = sM, iM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    align: {
      type: String,
      required: !1,
      default: "center"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = fr(), { activeTrigger: o, rootNavigationMenu: s, modelValue: i } = r, u = I(), d = I(), c = E(() => !!r.modelValue.value);
    ve(a, () => {
      r.onViewportChange(a.value);
    });
    const f = I();
    ve([i, c], () => {
      Be(() => {
        a.value && requestAnimationFrame(() => {
          const v = a.value?.querySelector("[data-state=open]");
          f.value = v;
        });
      });
    }, { immediate: !0 });
    function p() {
      if (f.value && o.value && s.value) {
        const v = document.documentElement.offsetWidth, m = document.documentElement.offsetHeight, g = s.value.getBoundingClientRect(), w = o.value.getBoundingClientRect(), { offsetWidth: C, offsetHeight: S } = f.value, $ = w.left - g.left, B = w.top - g.top;
        let k = null, P = null;
        switch (t.align) {
          case "start":
            k = $, P = B;
            break;
          case "end":
            k = $ - C + w.width, P = B - S + w.height;
            break;
          default:
            k = $ - C / 2 + w.width / 2, P = B - S / 2 + w.height / 2;
        }
        const D = 10;
        k + g.left < D && (k = D - g.left);
        const q = k + g.left + C;
        q > v - D && (k -= q - v + D, k < D - g.left && (k = D - g.left)), P + g.top < D && (P = D - g.top);
        const T = P + g.top + S;
        T > m - D && (P -= T - m + D, P < D - g.top && (P = D - g.top)), k = Math.round(k), P = Math.round(P), d.value = {
          left: k,
          top: P
        };
      }
    }
    return Tn(f, () => {
      f.value && (u.value = {
        width: f.value.offsetWidth,
        height: f.value.offsetHeight
      }, p());
    }), Tn([globalThis.document?.body, s], () => {
      p();
    }), (v, m) => (h(), x(l($t), {
      present: v.forceMount || c.value,
      "force-mount": !l(r).unmountOnHide.value,
      onAfterLeave: m[2] || (m[2] = () => {
        u.value = void 0, d.value = void 0;
      })
    }, {
      default: y(({ present: g }) => [N(l(X), A(v.$attrs, {
        ref: l(n),
        as: v.as,
        "as-child": v.asChild,
        "data-state": l(Vi)(c.value),
        "data-orientation": l(r).orientation,
        style: {
          pointerEvents: !c.value && l(r).isRootMenu ? "none" : void 0,
          "--reka-navigation-menu-viewport-width": u.value ? `${u.value?.width}px` : void 0,
          "--reka-navigation-menu-viewport-height": u.value ? `${u.value?.height}px` : void 0,
          "--reka-navigation-menu-viewport-left": d.value ? `${d.value?.left}px` : void 0,
          "--reka-navigation-menu-viewport-top": d.value ? `${d.value?.top}px` : void 0
        },
        hidden: !g,
        onPointerenter: m[0] || (m[0] = (w) => l(r).onContentEnter(l(r).modelValue.value)),
        onPointerleave: m[1] || (m[1] = (w) => l(Lg)(() => l(r).onContentLeave())(w))
      }), {
        default: y(() => [_(v.$slots, "default")]),
        _: 2
      }, 1040, [
        "as",
        "as-child",
        "data-state",
        "data-orientation",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"]));
  }
}), uM = iM;
let Ou = /* @__PURE__ */ new Map(), Dd = !1;
try {
  Dd = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let Vl = !1;
try {
  Vl = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const zg = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
class Hg {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let n = "";
    if (!Dd && this.options.signDisplay != null ? n = cM(this.numberFormatter, this.options.signDisplay, t) : n = this.numberFormatter.format(t), this.options.style === "unit" && !Vl) {
      var a;
      let { unit: r, unitDisplay: o = "short", locale: s } = this.resolvedOptions();
      if (!r) return n;
      let i = (a = zg[r]) === null || a === void 0 ? void 0 : a[o];
      n += i[s] || i.default;
    }
    return n;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, n) {
    if (typeof this.numberFormatter.formatRange == "function") return this.numberFormatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)}  ${this.format(n)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.numberFormatter.formatRangeToParts == "function") return this.numberFormatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.numberFormatter.formatToParts(t), r = this.numberFormatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !Dd && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !Vl && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, n = {}) {
    this.numberFormatter = dM(t, n), this.options = n;
  }
}
function dM(e, t = {}) {
  let { numberingSystem: n } = t;
  if (n && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${n}`), t.style === "unit" && !Vl) {
    var a;
    let { unit: s, unitDisplay: i = "short" } = t;
    if (!s) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((a = zg[s]) === null || a === void 0) && a[i])) throw new Error(`Unsupported unit ${s} with unitDisplay = ${i}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let r = e + (t ? Object.entries(t).sort((s, i) => s[0] < i[0] ? -1 : 1).join() : "");
  if (Ou.has(r)) return Ou.get(r);
  let o = new Intl.NumberFormat(e, t);
  return Ou.set(r, o), o;
}
function cM(e, t, n) {
  if (t === "auto") return e.format(n);
  if (t === "never") return e.format(Math.abs(n));
  {
    let a = !1;
    if (t === "always" ? a = n > 0 || Object.is(n, 0) : t === "exceptZero" && (Object.is(n, -0) || Object.is(n, 0) ? n = Math.abs(n) : a = n > 0), a) {
      let r = e.format(-n), o = e.format(n), s = r.replace(o, "").replace(/\u200e|\u061C/, "");
      return [
        ...s
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), r.replace(o, "!!!").replace(s, "+").replace("!!!", o);
    } else return e.format(n);
  }
}
const fM = new RegExp("^.*\\(.*\\).*$"), pM = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
class Ug {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return Ru(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, n, a) {
    return Ru(this.locale, this.options, t).isValidPartialNumber(t, n, a);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return Ru(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, n = {}) {
    this.locale = t, this.options = n;
  }
}
const rv = /* @__PURE__ */ new Map();
function Ru(e, t, n) {
  let a = ov(e, t);
  if (!e.includes("-nu-") && !a.isValidPartialNumber(n)) {
    for (let r of pM) if (r !== a.options.numberingSystem) {
      let o = ov(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + r, t);
      if (o.isValidPartialNumber(n)) return o;
    }
  }
  return a;
}
function ov(e, t) {
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : ""), a = rv.get(n);
  return a || (a = new vM(e, t), rv.set(n, a)), a;
}
class vM {
  parse(t) {
    let n = this.sanitize(t);
    if (this.symbols.group && (n = xr(n, this.symbols.group, "")), this.symbols.decimal && (n = n.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (n = n.replace(this.symbols.minusSign, "-")), n = n.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let s = n.indexOf("-");
      n = n.replace("-", ""), n = n.replace("+", "");
      let i = n.indexOf(".");
      i === -1 && (i = n.length), n = n.replace(".", ""), i - 2 === 0 ? n = `0.${n}` : i - 2 === -1 ? n = `0.0${n}` : i - 2 === -2 ? n = "0.00" : n = `${n.slice(0, i - 2)}.${n.slice(i - 2)}`, s > -1 && (n = `-${n}`);
    }
    let a = n ? +n : NaN;
    if (isNaN(a)) return NaN;
    if (this.options.style === "percent") {
      var r, o;
      let s = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((r = this.options.minimumFractionDigits) !== null && r !== void 0 ? r : 0) + 2, 20),
        maximumFractionDigits: Math.min(((o = this.options.maximumFractionDigits) !== null && o !== void 0 ? o : 0) + 2, 20)
      };
      return new Ug(this.locale, s).parse(new Hg(this.locale, s).format(a));
    }
    return this.options.currencySign === "accounting" && fM.test(t) && (a = -1 * a), a;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("", this.symbols.decimal)), this.symbols.group && (t = xr(t, ".", this.symbols.group))), this.symbols.group === "" && t.includes("'") && (t = xr(t, "'", this.symbols.group)), this.options.locale === "fr-FR" && this.symbols.group && (t = xr(t, " ", this.symbols.group), t = xr(t, /\u00A0/g, this.symbols.group)), t;
  }
  isValidPartialNumber(t, n = -1 / 0, a = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && n < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && a > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = xr(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, n = {}) {
    this.locale = t, n.roundingIncrement !== 1 && n.roundingIncrement != null && (n.maximumFractionDigits == null && n.minimumFractionDigits == null ? (n.maximumFractionDigits = 0, n.minimumFractionDigits = 0) : n.maximumFractionDigits == null ? n.maximumFractionDigits = n.minimumFractionDigits : n.minimumFractionDigits == null && (n.minimumFractionDigits = n.maximumFractionDigits)), this.formatter = new Intl.NumberFormat(t, n), this.options = this.formatter.resolvedOptions(), this.symbols = hM(t, this.formatter, this.options, n);
    var a, r;
    this.options.style === "percent" && (((a = this.options.minimumFractionDigits) !== null && a !== void 0 ? a : 0) > 18 || ((r = this.options.maximumFractionDigits) !== null && r !== void 0 ? r : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const sv = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), mM = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function hM(e, t, n, a) {
  var r, o, s, i;
  let u = new Intl.NumberFormat(e, {
    ...n,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  }), d = u.formatToParts(-10000.111), c = u.formatToParts(10000.111), f = mM.map((M) => u.formatToParts(M));
  var p;
  let v = (p = (r = d.find((M) => M.type === "minusSign")) === null || r === void 0 ? void 0 : r.value) !== null && p !== void 0 ? p : "-", m = (o = c.find((M) => M.type === "plusSign")) === null || o === void 0 ? void 0 : o.value;
  !m && (a?.signDisplay === "exceptZero" || a?.signDisplay === "always") && (m = "+");
  let w = (s = new Intl.NumberFormat(e, {
    ...n,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((M) => M.type === "decimal")) === null || s === void 0 ? void 0 : s.value, C = (i = d.find((M) => M.type === "group")) === null || i === void 0 ? void 0 : i.value, S = d.filter((M) => !sv.has(M.type)).map((M) => lv(M.value)), $ = f.flatMap((M) => M.filter((O) => !sv.has(O.type)).map((O) => lv(O.value))), B = [
    .../* @__PURE__ */ new Set([
      ...S,
      ...$
    ])
  ].sort((M, O) => O.length - M.length), k = B.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${B.join("|")}|[\\p{White_Space}]`, "gu"), P = [
    ...new Intl.NumberFormat(n.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), D = new Map(P.map((M, O) => [
    M,
    O
  ])), q = new RegExp(`[${P.join("")}]`, "g");
  return {
    minusSign: v,
    plusSign: m,
    decimal: w,
    group: C,
    literals: k,
    numeral: q,
    index: (M) => String(D.get(M))
  };
}
function xr(e, t, n) {
  return e.replaceAll ? e.replaceAll(t, n) : e.split(t).join(n);
}
function lv(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function jg(e) {
  const { disabled: t } = e, n = I(), a = Dr(), r = () => window.clearTimeout(n.value), o = (p) => {
    r(), !t.value && (a.trigger(), n.value = window.setTimeout(() => {
      o(60);
    }, p));
  }, s = () => {
    o(400);
  }, i = () => {
    r();
  }, u = I(!1), d = E(() => Gt(e.target)), c = (p) => {
    p.button !== 0 || u.value || (p.preventDefault(), u.value = !0, s());
  }, f = () => {
    u.value = !1, i();
  };
  return rn && (zt(d || window, "pointerdown", c), zt(window, "pointerup", f), zt(window, "pointercancel", f)), {
    isPressed: u,
    onTrigger: a.on
  };
}
function iv(e, t = I({})) {
  return cc(() => new Hg(e.value, t.value));
}
function gM(e, t = I({})) {
  return cc(() => new Ug(e.value, t.value));
}
function uv(e, t, n) {
  let a = e === "+" ? t + n : t - n;
  if (t % 1 !== 0 || n % 1 !== 0) {
    const r = t.toString().split("."), o = n.toString().split("."), s = r[1] && r[1].length || 0, i = o[1] && o[1].length || 0, u = 10 ** Math.max(s, i);
    t = Math.round(t * u), n = Math.round(n * u), a = e === "+" ? t + n : t - n, a /= u;
  }
  return a;
}
const [tf, yM] = Se("NumberFieldRoot");
var bM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NumberFieldRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: void 0
    },
    modelValue: {
      type: [Number, null],
      required: !1
    },
    min: {
      type: Number,
      required: !1
    },
    max: {
      type: Number,
      required: !1
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    stepSnapping: {
      type: Boolean,
      required: !1,
      default: !0
    },
    formatOptions: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    readonly: {
      type: Boolean,
      required: !1
    },
    disableWheelChange: {
      type: Boolean,
      required: !1
    },
    invertWheelChange: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, disableWheelChange: s, invertWheelChange: i, min: u, max: d, step: c, stepSnapping: f, formatOptions: p, id: v, locale: m } = Me(n), g = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { primitiveElement: w, currentElement: C } = Ht(), S = $c(m), $ = Rn(C), B = I(), k = E(() => !Mn(g.value) && (U(g.value) === u.value || u.value && !isNaN(g.value) ? uv("-", g.value, c.value) < u.value : !1)), P = E(() => !Mn(g.value) && (U(g.value) === d.value || d.value && !isNaN(g.value) ? uv("+", g.value, c.value) > d.value : !1));
    function D(ee, de = 1) {
      if (B.value?.focus(), n.disabled || n.readonly) return;
      const pe = F.parse(B.value?.value ?? "");
      isNaN(pe) ? g.value = u.value ?? 0 : ee === "increase" ? g.value = U(pe + (c.value ?? 1) * de) : g.value = U(pe - (c.value ?? 1) * de);
    }
    function q(ee = 1) {
      D("increase", ee);
    }
    function T(ee = 1) {
      D("decrease", ee);
    }
    function M(ee) {
      ee === "min" && u.value !== void 0 ? g.value = U(u.value) : ee === "max" && d.value !== void 0 && (g.value = U(d.value));
    }
    const O = iv(S, p), F = gM(S, p), J = E(() => O.resolvedOptions().maximumFractionDigits > 0 ? "decimal" : "numeric"), ne = iv(S, p), Q = E(() => Mn(g.value) || isNaN(g.value) ? "" : ne.format(g.value));
    function G(ee) {
      return F.isValidPartialNumber(ee, u.value, d.value);
    }
    function H(ee) {
      B.value && (B.value.value = ee);
    }
    function U(ee) {
      let de;
      return c.value === void 0 || isNaN(c.value) || !f.value ? de = Rr(ee, u.value, d.value) : de = N0(ee, u.value, d.value, c.value), de = F.parse(O.format(de)), de;
    }
    function se(ee) {
      const de = F.parse(ee);
      return g.value = isNaN(de) ? void 0 : U(de), ee.length ? (isNaN(de), H(Q.value)) : H(ee);
    }
    return yM({
      modelValue: g,
      handleDecrease: T,
      handleIncrease: q,
      handleMinMaxValue: M,
      inputMode: J,
      inputEl: B,
      onInputElement: (ee) => B.value = ee,
      textValue: Q,
      validate: G,
      applyInputValue: se,
      disabled: r,
      readonly: o,
      disableWheelChange: s,
      invertWheelChange: i,
      max: d,
      min: u,
      isDecreaseDisabled: k,
      isIncreaseDisabled: P,
      id: v
    }), (ee, de) => (h(), x(l(X), A(ee.$attrs, {
      ref_key: "primitiveElement",
      ref: w,
      role: "group",
      as: ee.as,
      "as-child": ee.asChild,
      "data-disabled": l(r) ? "" : void 0,
      "data-readonly": l(o) ? "" : void 0
    }), {
      default: y(() => [_(ee.$slots, "default", {
        modelValue: l(g),
        textValue: Q.value
      }), l($) && ee.name ? (h(), x(l(Vn), {
        key: 0,
        type: "text",
        value: l(g),
        name: ee.name,
        disabled: l(r),
        readonly: l(o),
        required: ee.required
      }, null, 8, [
        "value",
        "name",
        "disabled",
        "readonly",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-disabled",
      "data-readonly"
    ]));
  }
}), _M = bM, wM = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = tf(), a = E(() => n.disabled?.value || n.readonly.value || t.disabled || n.isDecreaseDisabled.value), { primitiveElement: r, currentElement: o } = Ht(), { isPressed: s, onTrigger: i } = jg({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleDecrease();
    }), (u, d) => (h(), x(l(X), A(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Decrease",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), xM = wM, CM = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = tf(), a = E(() => n.disabled?.value || n.readonly.value || t.disabled || n.isIncreaseDisabled.value), { primitiveElement: r, currentElement: o } = Ht(), { isPressed: s, onTrigger: i } = jg({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleIncrease();
    }), (u, d) => (h(), x(l(X), A(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Increase",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), SM = CM, $M = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Ht(), r = tf();
    function o(u) {
      r.disableWheelChange.value || u.target === ot() && (Math.abs(u.deltaY) <= Math.abs(u.deltaX) || (u.preventDefault(), u.deltaY > 0 ? r.invertWheelChange.value ? r.handleDecrease() : r.handleIncrease() : u.deltaY < 0 && (r.invertWheelChange.value ? r.handleIncrease() : r.handleDecrease())));
    }
    Ce(() => {
      r.onInputElement(a.value);
    });
    const s = I(r.textValue.value);
    ve(() => r.textValue.value, () => {
      s.value = r.textValue.value;
    }, {
      immediate: !0,
      deep: !0
    });
    function i() {
      requestAnimationFrame(() => {
        s.value = r.textValue.value;
      });
    }
    return (u, d) => (h(), x(l(X), A(t, {
      id: l(r).id.value,
      ref_key: "primitiveElement",
      ref: n,
      value: s.value,
      role: "spinbutton",
      type: "text",
      tabindex: "0",
      inputmode: l(r).inputMode.value,
      disabled: l(r).disabled.value ? "" : void 0,
      "data-disabled": l(r).disabled.value ? "" : void 0,
      readonly: l(r).readonly.value ? "" : void 0,
      "data-readonly": l(r).readonly.value ? "" : void 0,
      autocomplete: "off",
      autocorrect: "off",
      spellcheck: "false",
      "aria-roledescription": "Number field",
      "aria-valuenow": l(r).modelValue.value,
      "aria-valuemin": l(r).min.value,
      "aria-valuemax": l(r).max.value,
      onKeydown: [
        d[0] || (d[0] = Je(Ye((c) => l(r).handleIncrease(), ["prevent"]), ["up"])),
        d[1] || (d[1] = Je(Ye((c) => l(r).handleDecrease(), ["prevent"]), ["down"])),
        d[2] || (d[2] = Je(Ye((c) => l(r).handleIncrease(10), ["prevent"]), ["page-up"])),
        d[3] || (d[3] = Je(Ye((c) => l(r).handleDecrease(10), ["prevent"]), ["page-down"])),
        d[4] || (d[4] = Je(Ye((c) => l(r).handleMinMaxValue("min"), ["prevent"]), ["home"])),
        d[5] || (d[5] = Je(Ye((c) => l(r).handleMinMaxValue("max"), ["prevent"]), ["end"])),
        d[8] || (d[8] = Je((c) => l(r).applyInputValue(c.target?.value), ["enter"]))
      ],
      onWheel: o,
      onBeforeinput: d[6] || (d[6] = (c) => {
        const f = c.target;
        let p = f.value.slice(0, f.selectionStart ?? void 0) + (c.data ?? "") + f.value.slice(f.selectionEnd ?? void 0);
        l(r).validate(p) || c.preventDefault();
      }),
      onInput: d[7] || (d[7] = (c) => {
        const f = c.target;
        s.value = f.value;
      }),
      onChange: i,
      onBlur: d[9] || (d[9] = (c) => l(r).applyInputValue(c.target?.value))
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "value",
      "inputmode",
      "disabled",
      "data-disabled",
      "readonly",
      "data-readonly",
      "aria-valuenow",
      "aria-valuemin",
      "aria-valuemax"
    ]));
  }
}), kM = $M, BM = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(X), A(t, { "data-type": "ellipsis" }), {
      default: y(() => [_(n.$slots, "default", {}, () => [a[0] || (a[0] = Re(""))])]),
      _: 3
    }, 16));
  }
}), DM = BM;
const [no, PM] = Se("PaginationRoot");
var MM = /* @__PURE__ */ b({
  __name: "PaginationRoot",
  props: {
    page: {
      type: Number,
      required: !1
    },
    defaultPage: {
      type: Number,
      required: !1,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      required: !0
    },
    total: {
      type: Number,
      required: !1,
      default: 0
    },
    siblingCount: {
      type: Number,
      required: !1,
      default: 2
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    showEdges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, { siblingCount: r, disabled: o, showEdges: s } = Me(n);
    j();
    const i = Ve(n, "page", a, {
      defaultValue: n.defaultPage,
      passive: n.page === void 0
    }), u = E(() => Math.max(1, Math.ceil(n.total / (n.itemsPerPage || 1))));
    return PM({
      page: i,
      onPageChange(d) {
        i.value = d;
      },
      pageCount: u,
      siblingCount: r,
      disabled: o,
      showEdges: s
    }), (d, c) => (h(), x(l(X), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: y(() => [_(d.$slots, "default", {
        page: l(i),
        pageCount: u.value
      })]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), EM = MM, qM = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = no();
    j();
    const a = E(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "First Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("First page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), TM = qM, AM = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = no();
    j();
    const a = E(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Last Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).pageCount.value))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Last page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), IM = AM;
function _a(e, t) {
  const n = t - e + 1;
  return Array.from({ length: n }, (a, r) => r + e);
}
function OM(e) {
  return e.map((t) => typeof t == "number" ? {
    type: "page",
    value: t
  } : { type: "ellipsis" });
}
const Hs = "ellipsis";
function RM(e, t, n, a) {
  const o = t, s = Math.max(e - n, 1), i = Math.min(e + n, o);
  if (a) {
    const d = Math.min(2 * n + 5, t) - 2, c = s > 3 && Math.abs(o - d - 1 + 1) > 2 && Math.abs(s - 1) > 2, f = i < o - 2 && Math.abs(o - d) > 2 && Math.abs(o - i) > 2;
    if (!c && f)
      return [
        ..._a(1, d),
        Hs,
        o
      ];
    if (c && !f) {
      const v = _a(o - d + 1, o);
      return [
        1,
        Hs,
        ...v
      ];
    }
    if (c && f) {
      const v = _a(s, i);
      return [
        1,
        Hs,
        ...v,
        Hs,
        o
      ];
    }
    return _a(1, o);
  } else {
    const u = n * 2 + 1;
    return t < u ? _a(1, o) : e <= n + 1 ? _a(1, u) : t - e <= n ? _a(t - u + 1, o) : _a(s, i);
  }
}
var VM = /* @__PURE__ */ b({
  __name: "PaginationList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = no(), a = E(() => OM(RM(n.page.value, n.pageCount.value, n.siblingCount.value, n.showEdges.value)));
    return (r, o) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(r.$slots, "default", { items: a.value })]),
      _: 3
    }, 16));
  }
}), FM = VM, NM = /* @__PURE__ */ b({
  __name: "PaginationListItem",
  props: {
    value: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = no(), a = E(() => n.page.value === t.value), r = E(() => n.disabled.value);
    return (o, s) => (h(), x(l(X), A(t, {
      "data-type": "page",
      "aria-label": `Page ${o.value}`,
      "aria-current": a.value ? "page" : void 0,
      "data-selected": a.value ? "true" : void 0,
      disabled: r.value,
      type: o.as === "button" ? "button" : void 0,
      onClick: s[0] || (s[0] = (i) => !r.value && l(n).onPageChange(o.value))
    }), {
      default: y(() => [_(o.$slots, "default", {}, () => [Re(Ne(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-current",
      "data-selected",
      "disabled",
      "type"
    ]));
  }
}), LM = NM, zM = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = no(), a = E(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Next Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value + 1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Next page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), HM = zM, UM = /* @__PURE__ */ b({
  __name: "PaginationPrev",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = no(), a = E(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), x(l(X), A(t, {
      "aria-label": "Previous Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value - 1))
    }), {
      default: y(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Prev page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), jM = UM;
const [WM, GM] = Se("PinInputRoot");
var KM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PinInputRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    mask: {
      type: Boolean,
      required: !1
    },
    otp: {
      type: Boolean,
      required: !1
    },
    type: {
      type: null,
      required: !1,
      default: "text"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, { mask: r, otp: o, placeholder: s, type: i, disabled: u, dir: d } = Me(n), { forwardRef: c } = j(), f = yt(d), p = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? [],
      passive: !0,
      deep: !0
    }), v = E(() => Array.isArray(p.value) ? [...p.value] : []), m = I(/* @__PURE__ */ new Set());
    function g(S) {
      m.value.add(S);
    }
    const w = E(() => n.type === "number"), C = E(() => v.value.filter(($) => !!$ || w.value && $ === 0).length === m.value.size);
    return ve(p, () => {
      C.value && a("complete", p.value);
    }, { deep: !0 }), GM({
      modelValue: p,
      currentModelValue: v,
      mask: r,
      otp: o,
      placeholder: s,
      type: i,
      dir: f,
      disabled: u,
      isCompleted: C,
      inputElements: m,
      onInputElementChange: g,
      isNumericMode: w
    }), (S, $) => (h(), x(l(X), A(S.$attrs, {
      ref: l(c),
      dir: l(f),
      "data-complete": C.value ? "" : void 0,
      "data-disabled": l(u) ? "" : void 0
    }), {
      default: y(() => [_(S.$slots, "default", { modelValue: l(p) }), N(Vn, {
        id: S.id,
        as: "input",
        feature: "focusable",
        tabindex: "-1",
        value: v.value.join(""),
        name: S.name ?? "",
        disabled: l(u),
        required: S.required,
        onFocus: $[0] || ($[0] = (B) => Array.from(m.value)?.[0]?.focus())
      }, null, 8, [
        "id",
        "value",
        "name",
        "disabled",
        "required"
      ])]),
      _: 3
    }, 16, [
      "dir",
      "data-complete",
      "data-disabled"
    ]));
  }
}), YM = KM, XM = /* @__PURE__ */ b({
  __name: "PinInputInput",
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = WM(), a = E(() => Array.from(n.inputElements.value)), r = E(() => n.currentModelValue.value[t.index]), o = E(() => t.disabled || n.disabled.value), s = E(() => n.otp.value), i = E(() => n.mask.value), { primitiveElement: u, currentElement: d } = Ht();
    function c(k) {
      const P = k.target;
      if ((k.data?.length ?? 0) > 1) {
        S(P.value);
        return;
      }
      if (n.isNumericMode.value && !/^\d*$/.test(P.value)) {
        P.value = P.value.replace(/\D/g, "");
        return;
      }
      P.value = k.data || P.value.slice(-1), B(t.index, P.value);
      const D = a.value[t.index + 1];
      D && D.focus();
    }
    function f() {
      const k = d.value;
      Be(() => {
        k && !k.value && (k.placeholder = n.placeholder.value);
      });
    }
    function p(k) {
      lr(k, ot(), void 0, {
        itemsArray: a.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: "horizontal",
        dir: n.dir.value
      });
    }
    function v(k) {
      if (k.preventDefault(), k.target.value) B(t.index, "");
      else {
        const q = a.value[t.index - 1];
        q && (q.focus(), B(t.index - 1, ""));
      }
    }
    function m(k) {
      k.key === "Delete" && (k.preventDefault(), B(t.index, ""));
    }
    function g(k) {
      const P = k.target;
      P.setSelectionRange(1, 1), P.value || (P.placeholder = ""), setTimeout(() => {
        P.value || (P.placeholder = "");
      });
    }
    function w(k) {
      f();
    }
    function C(k) {
      k.preventDefault();
      const P = k.clipboardData;
      if (!P) return;
      const D = P.getData("text");
      S(D);
    }
    function S(k) {
      const P = [...n.currentModelValue.value], D = k.length >= a.value.length ? 0 : t.index, q = Math.min(D + k.length, a.value.length);
      for (let T = D; T < q; T++) {
        const M = a.value[T], O = k[T - D];
        n.isNumericMode.value && !/^\d*$/.test(O) || (P[T] = O, M.focus());
      }
      n.modelValue.value = P, a.value[q]?.focus();
    }
    function $(k) {
      let P = k.length - 1;
      for (; P >= 0 && k[P] === ""; )
        k.pop(), P--;
      return k;
    }
    function B(k, P) {
      const D = [...n.currentModelValue.value];
      if (n.isNumericMode.value) {
        const q = +P;
        P === "" || isNaN(q) ? delete D[k] : D[k] = q;
      } else D[k] = P;
      n.modelValue.value = $(D);
    }
    return ve(r, () => {
      r.value || f();
    }), Ce(() => {
      n.onInputElementChange(d.value);
    }), Qe(() => {
      n.inputElements?.value.delete(d.value);
    }), (k, P) => (h(), x(l(X), {
      ref_key: "primitiveElement",
      ref: u,
      autocapitalize: "none",
      as: k.as,
      "as-child": k.asChild,
      autocomplete: s.value ? "one-time-code" : "false",
      type: i.value ? "password" : "text",
      inputmode: l(n).isNumericMode.value ? "numeric" : "text",
      pattern: l(n).isNumericMode.value ? "[0-9]*" : void 0,
      placeholder: l(n).placeholder.value,
      value: r.value,
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "data-complete": l(n).isCompleted.value ? "" : void 0,
      "aria-label": `pin input ${k.index + 1} of ${a.value.length}`,
      onInput: P[0] || (P[0] = (D) => c(D)),
      onKeydown: [
        Je(p, [
          "left",
          "right",
          "up",
          "down",
          "home",
          "end"
        ]),
        Je(v, ["backspace"]),
        Je(m, ["delete"])
      ],
      onFocus: g,
      onBlur: w,
      onPaste: C
    }, {
      default: y(() => [_(k.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "autocomplete",
      "type",
      "inputmode",
      "pattern",
      "placeholder",
      "value",
      "disabled",
      "data-disabled",
      "data-complete",
      "aria-label"
    ]));
  }
}), JM = XM;
const Uo = 100, [ZM, QM] = Se("ProgressRoot"), Fl = (e) => typeof e == "number";
function eE(e, t) {
  return Mn(e) || Fl(e) && !Number.isNaN(e) && e <= t && e >= 0 ? e : (console.error(`Invalid prop \`value\` of value \`${e}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Uo} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function tE(e) {
  return Fl(e) && !Number.isNaN(e) && e > 0 ? e : (console.error(`Invalid prop \`max\` of value \`${e}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Uo}\`.`), Uo);
}
var nE = /* @__PURE__ */ b({
  __name: "ProgressRoot",
  props: {
    modelValue: {
      type: [Number, null],
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: Uo
    },
    getValueLabel: {
      type: Function,
      required: !1,
      default: (e, t) => Fl(e) ? `${Math.round(e / t * Uo)}%` : void 0
    },
    getValueText: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:max"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = Ve(n, "modelValue", a, { passive: n.modelValue === void 0 }), o = Ve(n, "max", a, { passive: n.max === void 0 });
    ve(() => r.value, async (i) => {
      const u = eE(i, n.max);
      u !== i && (await Be(), r.value = u);
    }, { immediate: !0 }), ve(() => n.max, (i) => {
      const u = tE(n.max);
      u !== i && (o.value = u);
    }, { immediate: !0 });
    const s = E(() => Mn(r.value) ? "indeterminate" : r.value === o.value ? "complete" : "loading");
    return QM({
      modelValue: r,
      max: o,
      progressState: s
    }), (i, u) => (h(), x(l(X), {
      "as-child": i.asChild,
      as: i.as,
      "aria-valuemax": l(o),
      "aria-valuemin": 0,
      "aria-valuenow": Fl(l(r)) ? l(r) : void 0,
      "aria-valuetext": i.getValueText?.(l(r), l(o)),
      "aria-label": i.getValueLabel(l(r), l(o)),
      role: "progressbar",
      "data-state": s.value,
      "data-value": l(r) ?? void 0,
      "data-max": l(o)
    }, {
      default: y(() => [_(i.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "aria-valuemax",
      "aria-valuenow",
      "aria-valuetext",
      "aria-label",
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), aE = nE, rE = /* @__PURE__ */ b({
  __name: "ProgressIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ZM();
    return j(), (a, r) => (h(), x(l(X), A(t, {
      "data-state": l(n).progressState.value,
      "data-value": l(n).modelValue?.value ?? void 0,
      "data-max": l(n).max.value
    }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, [
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), oE = rE;
const sE = "radio.select";
function lE(e, t, n) {
  is(sE, n, {
    originalEvent: e,
    value: t
  });
}
var iE = /* @__PURE__ */ b({
  __name: "Radio",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:checked", "select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ve(n, "checked", a, { passive: n.checked === void 0 }), { value: o } = Me(n), { forwardRef: s, currentElement: i } = j(), u = Rn(i), d = E(() => n.id && i.value ? document.querySelector(`[for="${n.id}"]`)?.innerText ?? n.value : void 0);
    function c(f) {
      n.disabled || lE(f, n.value, (p) => {
        a("select", p), !p?.defaultPrevented && (r.value = !0, u.value && p.stopPropagation());
      });
    }
    return (f, p) => (h(), x(l(X), A(f.$attrs, {
      id: f.id,
      ref: l(s),
      role: "radio",
      type: f.as === "button" ? "button" : void 0,
      as: f.as,
      "aria-checked": l(r),
      "aria-label": d.value,
      "as-child": f.asChild,
      disabled: f.disabled ? "" : void 0,
      "data-state": l(r) ? "checked" : "unchecked",
      "data-disabled": f.disabled ? "" : void 0,
      value: l(o),
      required: f.required,
      name: f.name,
      onClick: Ye(c, ["stop"])
    }), {
      default: y(() => [_(f.$slots, "default", { checked: l(r) }), l(u) && f.name ? (h(), x(l(Vn), {
        key: 0,
        type: "radio",
        tabindex: "-1",
        value: l(o),
        checked: !!l(r),
        name: f.name,
        disabled: f.disabled,
        required: f.required
      }, null, 8, [
        "value",
        "checked",
        "name",
        "disabled",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "as",
      "aria-checked",
      "aria-label",
      "as-child",
      "disabled",
      "data-state",
      "data-disabled",
      "value",
      "required",
      "name"
    ]));
  }
}), uE = iE;
const [dE, cE] = Se("RadioGroupRoot");
var fE = /* @__PURE__ */ b({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { disabled: i, loop: u, orientation: d, name: c, required: f, dir: p } = Me(n), v = yt(p), m = Rn(o);
    return cE({
      modelValue: s,
      changeModelValue: (g) => {
        s.value = g;
      },
      disabled: i,
      loop: u,
      orientation: d,
      name: c?.value,
      required: f
    }), (g, w) => (h(), x(l(ys), {
      "as-child": "",
      orientation: l(d),
      dir: l(v),
      loop: l(u)
    }, {
      default: y(() => [N(l(X), {
        ref: l(r),
        role: "radiogroup",
        "data-disabled": l(i) ? "" : void 0,
        "as-child": g.asChild,
        as: g.as,
        "aria-orientation": l(d),
        "aria-required": l(f),
        dir: l(v)
      }, {
        default: y(() => [_(g.$slots, "default", { modelValue: l(s) }), l(m) && l(c) ? (h(), x(l(Vn), {
          key: 0,
          required: l(f),
          disabled: l(i),
          value: l(s),
          name: l(c)
        }, null, 8, [
          "required",
          "disabled",
          "value",
          "name"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 8, [
        "data-disabled",
        "as-child",
        "as",
        "aria-orientation",
        "aria-required",
        "dir"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), pE = fE;
const [vE, mE] = Se("RadioGroupItem");
var hE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = dE(), i = E(() => s.disabled.value || n.disabled), u = E(() => s.required.value || n.required), d = E(() => qn(s.modelValue?.value, n.value));
    mE({
      disabled: i,
      checked: d
    });
    const c = I(!1), f = [
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ];
    zt("keydown", (v) => {
      f.includes(v.key) && (c.value = !0);
    }), zt("keyup", () => {
      c.value = !1;
    });
    function p() {
      setTimeout(() => {
        c.value && o.value?.click();
      }, 0);
    }
    return (v, m) => (h(), x(l(bs), {
      checked: d.value,
      disabled: i.value,
      "as-child": "",
      focusable: !i.value,
      active: d.value
    }, {
      default: y(() => [N(uE, A({
        ...v.$attrs,
        ...n
      }, {
        ref: l(r),
        checked: d.value,
        required: u.value,
        disabled: i.value,
        "onUpdate:checked": m[0] || (m[0] = (g) => l(s).changeModelValue(v.value)),
        onSelect: m[1] || (m[1] = (g) => a("select", g)),
        onKeydown: m[2] || (m[2] = Je(Ye(() => {
        }, ["prevent"]), ["enter"])),
        onFocus: p
      }), {
        default: y(() => [_(v.$slots, "default", {
          checked: d.value,
          required: u.value,
          disabled: i.value
        })]),
        _: 3
      }, 16, [
        "checked",
        "required",
        "disabled"
      ])]),
      _: 3
    }, 8, [
      "checked",
      "disabled",
      "focusable",
      "active"
    ]));
  }
}), gE = hE, yE = /* @__PURE__ */ b({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = vE();
    return (a, r) => (h(), x(l($t), { present: a.forceMount || l(n).checked.value }, {
      default: y(() => [N(l(X), A({
        ref: l(t),
        "data-state": l(n).checked.value ? "checked" : "unchecked",
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: y(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), bE = yE;
const [Sn, _E] = Se("ScrollAreaRoot");
var wE = /* @__PURE__ */ b({
  __name: "ScrollAreaRoot",
  props: {
    type: {
      type: String,
      required: !1,
      default: "hover"
    },
    dir: {
      type: String,
      required: !1
    },
    scrollHideDelay: {
      type: Number,
      required: !1,
      default: 600
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = I(0), r = I(0), o = I(), s = I(), i = I(), u = I(), d = I(!1), c = I(!1), { type: f, dir: p, scrollHideDelay: v } = Me(n), m = yt(p);
    function g() {
      o.value?.scrollTo({ top: 0 });
    }
    function w() {
      o.value?.scrollTo({
        top: 0,
        left: 0
      });
    }
    t({
      viewport: o,
      scrollTop: g,
      scrollTopLeft: w
    });
    const { forwardRef: C, currentElement: S } = j();
    return _E({
      type: f,
      dir: m,
      scrollHideDelay: v,
      scrollArea: S,
      viewport: o,
      onViewportChange: ($) => {
        o.value = $ || void 0;
      },
      content: s,
      onContentChange: ($) => {
        s.value = $;
      },
      scrollbarX: i,
      scrollbarXEnabled: d,
      scrollbarY: u,
      scrollbarYEnabled: c,
      onScrollbarXChange: ($) => {
        i.value = $ || void 0;
      },
      onScrollbarYChange: ($) => {
        u.value = $ || void 0;
      },
      onScrollbarXEnabledChange: ($) => {
        d.value = $;
      },
      onScrollbarYEnabledChange: ($) => {
        c.value = $;
      },
      onCornerWidthChange: ($) => {
        a.value = $;
      },
      onCornerHeightChange: ($) => {
        r.value = $;
      }
    }), ($, B) => (h(), x(l(X), {
      ref: l(C),
      "as-child": n.asChild,
      as: $.as,
      dir: l(m),
      style: dt({
        position: "relative",
        "--reka-scroll-area-corner-width": `${a.value}px`,
        "--reka-scroll-area-corner-height": `${r.value}px`
      })
    }, {
      default: y(() => [_($.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "dir",
      "style"
    ]));
  }
}), xE = wE, CE = /* @__PURE__ */ b({
  __name: "ScrollAreaCornerImpl",
  setup(e) {
    const t = Sn(), n = I(0), a = I(0), r = E(() => !!n.value && !!a.value);
    function o() {
      const i = t.scrollbarX.value?.offsetHeight || 0;
      t.onCornerHeightChange(i), a.value = i;
    }
    function s() {
      const i = t.scrollbarY.value?.offsetWidth || 0;
      t.onCornerWidthChange(i), n.value = i;
    }
    return Tn(t.scrollbarX.value, o), Tn(t.scrollbarY.value, s), ve(() => t.scrollbarX.value, o), ve(() => t.scrollbarY.value, s), (i, u) => r.value ? (h(), x(l(X), A({
      key: 0,
      style: {
        width: `${n.value}px`,
        height: `${a.value}px`,
        position: "absolute",
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: 0
      }
    }, i.$parent?.$props), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, ["style"])) : Ee("v-if", !0);
  }
}), SE = CE, $E = /* @__PURE__ */ b({
  __name: "ScrollAreaCorner",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = Sn(), r = E(() => !!a.scrollbarX.value && !!a.scrollbarY.value), o = E(() => a.type.value !== "scroll" && r.value);
    return (s, i) => o.value ? (h(), x(SE, A({ key: 0 }, t, { ref: l(n) }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), kE = $E;
function Wg(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function Fi(e) {
  const t = Gg(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, a = (e.scrollbar.size - n) * t;
  return Math.max(a, 18);
}
function Gg(e, t) {
  const n = e / t;
  return Number.isNaN(n) ? 0 : n;
}
function BE(e, t = () => {
}) {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, a = 0;
  return (function r() {
    const o = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, s = n.left !== o.left, i = n.top !== o.top;
    (s || i) && t(), n = o, a = window.requestAnimationFrame(r);
  })(), () => window.cancelAnimationFrame(a);
}
function dv(e, t, n = "ltr") {
  const a = Fi(t), r = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - r, s = t.content - t.viewport, i = o - a, u = n === "ltr" ? [0, s] : [s * -1, 0], d = Rr(e, u[0], u[1]);
  return Wg([0, s], [0, i])(d);
}
function Us(e) {
  return e ? Number.parseInt(e, 10) : 0;
}
function DE(e, t, n, a = "ltr") {
  const r = Fi(n), o = r / 2, s = t || o, i = r - s, u = n.scrollbar.paddingStart + s, d = n.scrollbar.size - n.scrollbar.paddingEnd - i, c = n.content - n.viewport, f = a === "ltr" ? [0, c] : [c * -1, 0];
  return Wg([u, d], f)(e);
}
function cv(e, t) {
  return e > 0 && e < t;
}
var PE = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarX",
  setup(e) {
    const t = Sn(), n = Li(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarXChange(r.value);
    });
    const o = E(() => n.sizes.value);
    return (s, i) => (h(), x(Yg, {
      ref: l(a),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: dt({
        bottom: 0,
        left: l(t).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
        right: l(t).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
        "--reka-scroll-area-thumb-width": o.value ? `${l(Fi)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.x))
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), ME = PE, EE = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarY",
  setup(e) {
    const t = Sn(), n = Li(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarYChange(r.value);
    });
    const o = E(() => n.sizes.value);
    return (s, i) => (h(), x(Yg, {
      ref: l(a),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: dt({
        top: 0,
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--reka-scroll-area-corner-height)",
        "--reka-scroll-area-thumb-height": o.value ? `${l(Fi)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.y))
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), qE = EE, TE = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarAuto",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Sn(), n = Ni(), { forwardRef: a } = j(), r = I(!1), o = fc(() => {
      if (t.viewport.value) {
        const s = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        r.value = n.isHorizontal.value ? s : i;
      }
    }, 10);
    return Ce(() => o()), Tn(t.viewport, o), Tn(t.content, o), (s, i) => (h(), x(l($t), { present: s.forceMount || r.value }, {
      default: y(() => [N(nf, A(s.$attrs, {
        ref: l(a),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), Kg = TE, AE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Sn(), { forwardRef: n } = j();
    let a;
    const r = I(!1);
    function o() {
      window.clearTimeout(a), r.value = !0;
    }
    function s() {
      a = window.setTimeout(() => {
        r.value = !1;
      }, t.scrollHideDelay.value);
    }
    return Ce(() => {
      const i = t.scrollArea.value;
      i && (i.addEventListener("pointerenter", o), i.addEventListener("pointerleave", s));
    }), Qe(() => {
      const i = t.scrollArea.value;
      i && (window.clearTimeout(a), i.removeEventListener("pointerenter", o), i.removeEventListener("pointerleave", s));
    }), (i, u) => (h(), x(l($t), { present: i.forceMount || r.value }, {
      default: y(() => [N(Kg, A(i.$attrs, {
        ref: l(n),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), IE = AE, OE = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarScroll",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = Sn(), n = Ni(), { forwardRef: a } = j(), { state: r, dispatch: o } = Yh("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }), s = E(() => r.value !== "hidden");
    Ie((u) => {
      if (r.value === "idle") {
        const d = window.setTimeout(() => o("HIDE"), t.scrollHideDelay.value);
        u(() => {
          window.clearTimeout(d);
        });
      }
    });
    const i = fc(() => o("SCROLL_END"), 100);
    return Ie((u) => {
      const d = t.viewport.value, c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (d) {
        let f = d[c];
        const p = () => {
          const v = d[c];
          f !== v && (o("SCROLL"), i()), f = v;
        };
        d.addEventListener("scroll", p), u(() => {
          d.removeEventListener("scroll", p);
        });
      }
    }), (u, d) => (h(), x(l($t), { present: u.forceMount || s.value }, {
      default: y(() => [N(nf, A(u.$attrs, {
        ref: l(a),
        "data-state": s.value ? "visible" : "hidden"
      }), {
        default: y(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), RE = OE;
const [Ni, VE] = Se("ScrollAreaScrollbar");
var FE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = Sn(), r = E(() => t.orientation === "horizontal");
    ve(r, () => {
      r.value ? a.onScrollbarXEnabledChange(!0) : a.onScrollbarYEnabledChange(!0);
    }, { immediate: !0 }), Qe(() => {
      a.onScrollbarXEnabledChange(!1), a.onScrollbarYEnabledChange(!1);
    });
    const { orientation: o, forceMount: s, asChild: i, as: u } = Me(t);
    return VE({
      orientation: o,
      forceMount: s,
      isHorizontal: r,
      as: u,
      asChild: i
    }), (d, c) => l(a).type.value === "hover" ? (h(), x(IE, A({ key: 0 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "scroll" ? (h(), x(RE, A({ key: 1 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "auto" ? (h(), x(Kg, A({ key: 2 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "always" ? (h(), x(nf, A({ key: 3 }, d.$attrs, {
      ref: l(n),
      "data-state": "visible"
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), NE = FE;
const [Li, LE] = Se("ScrollAreaScrollbarVisible");
var zE = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarVisible",
  setup(e) {
    const t = Sn(), n = Ni(), { forwardRef: a } = j(), r = I({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    }), o = E(() => {
      const C = Gg(r.value.viewport, r.value.content);
      return C > 0 && C < 1;
    }), s = I(), i = I(0);
    function u(C, S) {
      if (v.value) {
        const $ = t.viewport.value.scrollLeft + C.deltaY;
        t.viewport.value.scrollLeft = $, cv($, S) && C.preventDefault();
      } else {
        const $ = t.viewport.value.scrollTop + C.deltaY;
        t.viewport.value.scrollTop = $, cv($, S) && C.preventDefault();
      }
    }
    function d(C, S) {
      v.value ? i.value = S.x : i.value = S.y;
    }
    function c(C) {
      i.value = 0;
    }
    function f(C) {
      r.value = C;
    }
    function p(C, S) {
      return DE(C, i.value, r.value, S);
    }
    const v = E(() => n.isHorizontal.value);
    function m(C) {
      v.value ? t.viewport.value.scrollLeft = p(C, t.dir.value) : t.viewport.value.scrollTop = p(C);
    }
    function g() {
      if (v.value) {
        if (t.viewport.value && s.value) {
          const C = t.viewport.value.scrollLeft, S = dv(C, r.value, t.dir.value);
          s.value.style.transform = `translate3d(${S}px, 0, 0)`;
        }
      } else if (t.viewport.value && s.value) {
        const C = t.viewport.value.scrollTop, S = dv(C, r.value);
        s.value.style.transform = `translate3d(0, ${S}px, 0)`;
      }
    }
    function w(C) {
      s.value = C;
    }
    return LE({
      sizes: r,
      hasThumb: o,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: c,
      handleSizeChange: f,
      onThumbPositionChange: g,
      onThumbChange: w,
      onDragScroll: m
    }), (C, S) => v.value ? (h(), x(ME, A({ key: 0 }, C.$attrs, { ref: l(a) }), {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 16)) : (h(), x(qE, A({ key: 1 }, C.$attrs, { ref: l(a) }), {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nf = zE, HE = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarImpl",
  props: { isHorizontal: {
    type: Boolean,
    required: !0
  } },
  emits: [
    "onDragScroll",
    "onWheelScroll",
    "onThumbPointerDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Sn(), o = Li(), s = Ni(), { forwardRef: i, currentElement: u } = j(), d = I(""), c = I();
    function f(C) {
      if (c.value) {
        const S = C.clientX - c.value?.left, $ = C.clientY - c.value?.top;
        a("onDragScroll", {
          x: S,
          y: $
        });
      }
    }
    function p(C) {
      C.button === 0 && (C.target.setPointerCapture(C.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", r.viewport && (r.viewport.value.style.scrollBehavior = "auto"), f(C));
    }
    function v(C) {
      f(C);
    }
    function m(C) {
      const S = C.target;
      S.hasPointerCapture(C.pointerId) && S.releasePointerCapture(C.pointerId), document.body.style.webkitUserSelect = d.value, r.viewport && (r.viewport.value.style.scrollBehavior = ""), c.value = void 0;
    }
    function g(C) {
      const S = C.target, $ = u.value?.contains(S), B = o.sizes.value.content - o.sizes.value.viewport;
      $ && o.handleWheelScroll(C, B);
    }
    Ce(() => {
      document.addEventListener("wheel", g, { passive: !1 });
    }), Qe(() => {
      document.removeEventListener("wheel", g);
    });
    function w() {
      u.value && (n.isHorizontal ? o.handleSizeChange({
        content: r.viewport.value?.scrollWidth ?? 0,
        viewport: r.viewport.value?.offsetWidth ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: Us(getComputedStyle(u.value).paddingLeft),
          paddingEnd: Us(getComputedStyle(u.value).paddingRight)
        }
      }) : o.handleSizeChange({
        content: r.viewport.value?.scrollHeight ?? 0,
        viewport: r.viewport.value?.offsetHeight ?? 0,
        scrollbar: {
          size: u.value?.clientHeight ?? 0,
          paddingStart: Us(getComputedStyle(u.value).paddingTop),
          paddingEnd: Us(getComputedStyle(u.value).paddingBottom)
        }
      }), o.onThumbPositionChange());
    }
    return Tn(u, w), Tn(r.content, w), (C, S) => (h(), x(l(X), {
      ref: l(i),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: l(s).as.value,
      "as-child": l(s).asChild.value,
      onPointerdown: p,
      onPointermove: v,
      onPointerup: m
    }, {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Yg = HE, UE = /* @__PURE__ */ b({
  __name: "ScrollAreaThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Sn(), a = Li();
    function r(p) {
      const m = p.target.getBoundingClientRect(), g = p.clientX - m.left, w = p.clientY - m.top;
      a.handleThumbDown(p, {
        x: g,
        y: w
      });
    }
    function o(p) {
      a.handleThumbUp(p);
    }
    const { forwardRef: s, currentElement: i } = j(), u = I(), d = E(() => n.viewport.value);
    function c() {
      if (!u.value) {
        const p = BE(d.value, a.onThumbPositionChange);
        u.value = p, a.onThumbPositionChange();
      }
    }
    const f = E(() => a.sizes.value);
    return rw(f, () => {
      a.onThumbChange(i.value), d.value && (a.onThumbPositionChange(), d.value.addEventListener("scroll", c));
    }), Qe(() => {
      d.value.removeEventListener("scroll", c), n.viewport.value?.removeEventListener("scroll", c);
    }), (p, v) => (h(), x(l(X), {
      ref: l(s),
      "data-state": l(a).hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--reka-scroll-area-thumb-width)",
        height: "var(--reka-scroll-area-thumb-height)"
      },
      "as-child": t.asChild,
      as: p.as,
      onPointerdown: r,
      onPointerup: o
    }, {
      default: y(() => [_(p.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "as-child",
      "as"
    ]));
  }
}), jE = UE, WE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, { nonce: a } = Me(n), r = Ai(a), o = Sn(), s = I();
    Ce(() => {
      o.onViewportChange(s.value), o.onContentChange(u.value);
    }), t({ viewportElement: s });
    const { forwardRef: i, currentElement: u } = j();
    return (d, c) => (h(), W(Ke, null, [we("div", A({
      ref_key: "viewportElement",
      ref: s,
      "data-reka-scroll-area-viewport": "",
      style: {
        overflowX: l(o).scrollbarXEnabled.value ? "scroll" : "hidden",
        overflowY: l(o).scrollbarYEnabled.value ? "scroll" : "hidden"
      }
    }, d.$attrs, { tabindex: 0 }), [N(l(X), {
      ref: l(i),
      style: dt({ minWidth: l(o).scrollbarXEnabled.value ? "fit-content" : void 0 }),
      "as-child": n.asChild,
      as: d.as
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "style",
      "as-child",
      "as"
    ])], 16), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: y(() => c[0] || (c[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), GE = WE;
const KE = [
  " ",
  "Enter",
  "ArrowUp",
  "ArrowDown"
], YE = [" ", "Enter"], $n = 10;
function jo(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => Pd(a, t, n)) : Pd(e, t, n);
}
function Pd(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : qn(e, t);
}
function XE(e) {
  return e == null || e === "" || Array.isArray(e) && e.length === 0;
}
const JE = {
  key: 0,
  value: ""
}, [La, Xg] = Se("SelectRoot");
var ZE = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1,
      default: void 0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    autocomplete: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { required: r, disabled: o, multiple: s, dir: i } = Me(n), u = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? (s.value ? [] : void 0),
      passive: n.modelValue === void 0,
      deep: !0
    }), d = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), c = I(), f = I(), p = I({
      x: 0,
      y: 0
    }), v = E(() => s.value && Array.isArray(u.value) ? u.value?.length === 0 : Mn(u.value));
    st({ isProvider: !0 });
    const m = yt(i), g = Rn(c), w = I(/* @__PURE__ */ new Set()), C = E(() => Array.from(w.value).map((B) => B.value).join(";"));
    function S(B) {
      if (s.value) {
        const k = Array.isArray(u.value) ? [...u.value] : [], P = k.findIndex((D) => Pd(D, B, n.by));
        P === -1 ? k.push(B) : k.splice(P, 1), u.value = [...k];
      } else u.value = B;
    }
    function $(B) {
      return Array.from(w.value).find((k) => jo(B, k.value, n.by));
    }
    return Xg({
      triggerElement: c,
      onTriggerChange: (B) => {
        c.value = B;
      },
      valueElement: f,
      onValueElementChange: (B) => {
        f.value = B;
      },
      contentId: "",
      modelValue: u,
      onValueChange: S,
      by: n.by,
      open: d,
      multiple: s,
      required: r,
      onOpenChange: (B) => {
        d.value = B;
      },
      dir: m,
      triggerPointerDownPosRef: p,
      disabled: o,
      isEmptyModelValue: v,
      optionsSet: w,
      onOptionAdd: (B) => {
        const k = $(B.value);
        k && w.value.delete(k), w.value.add(B);
      },
      onOptionRemove: (B) => {
        const k = $(B.value);
        k && w.value.delete(k);
      }
    }), (B, k) => (h(), x(l(ir), null, {
      default: y(() => [_(B.$slots, "default", {
        modelValue: l(u),
        open: l(d)
      }), l(g) ? (h(), x(tq, {
        key: C.value,
        "aria-hidden": "true",
        tabindex: "-1",
        multiple: l(s),
        required: l(r),
        name: B.name,
        autocomplete: B.autocomplete,
        disabled: l(o),
        value: l(u)
      }, {
        default: y(() => [l(Mn)(l(u)) ? (h(), W("option", JE)) : Ee("v-if", !0), (h(!0), W(Ke, null, Lt(Array.from(w.value), (P) => (h(), W("option", A({ key: P.value ?? "" }, { ref_for: !0 }, P), null, 16))), 128))]),
        _: 1
      }, 8, [
        "multiple",
        "required",
        "name",
        "autocomplete",
        "disabled",
        "value"
      ])) : Ee("v-if", !0)]),
      _: 3
    }));
  }
}), QE = ZE, eq = /* @__PURE__ */ b({
  __name: "BubbleSelect",
  props: {
    autocomplete: {
      type: String,
      required: !1
    },
    autofocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    form: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    size: {
      type: Number,
      required: !1
    },
    value: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = I(), a = La();
    ve(() => t.value, (o, s) => {
      const i = window.HTMLSelectElement.prototype, d = Object.getOwnPropertyDescriptor(i, "value").set;
      if (o !== s && d && n.value) {
        const c = new Event("change", { bubbles: !0 });
        d.call(n.value, o), n.value.dispatchEvent(c);
      }
    });
    function r(o) {
      a.onValueChange(o.target.value);
    }
    return (o, s) => (h(), x(l(Di), { "as-child": "" }, {
      default: y(() => [we("select", A({
        ref_key: "selectElement",
        ref: n
      }, t, { onInput: r }), [_(o.$slots, "default")], 16)]),
      _: 3
    }));
  }
}), tq = eq, nq = /* @__PURE__ */ b({
  __name: "SelectPopperPosition",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: $n
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(Qr), A(l(n), { style: {
      boxSizing: "border-box",
      "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-select-content-available-width": "var(--reka-popper-available-width)",
      "--reka-select-content-available-height": "var(--reka-popper-available-height)",
      "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), aq = nq;
const rq = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [pr, Jg] = Se("SelectContent");
var oq = /* @__PURE__ */ b({
  __name: "SelectContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "item-aligned"
    },
    bodyLock: {
      type: Boolean,
      required: !1,
      default: !0
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = La();
    Sc(), fs(n.bodyLock);
    const { CollectionSlot: o, getItems: s } = st(), i = I();
    vs(i);
    const { search: u, handleTypeaheadSearch: d } = _i(), c = I(), f = I(), p = I(), v = I(!1), m = I(!1), g = I(!1);
    function w() {
      f.value && i.value && _d([f.value, i.value]);
    }
    ve(v, () => {
      w();
    });
    const { onOpenChange: C, triggerPointerDownPosRef: S } = r;
    Ie((P) => {
      if (!i.value) return;
      let D = {
        x: 0,
        y: 0
      };
      const q = (M) => {
        D = {
          x: Math.abs(Math.round(M.pageX) - (S.value?.x ?? 0)),
          y: Math.abs(Math.round(M.pageY) - (S.value?.y ?? 0))
        };
      }, T = (M) => {
        M.pointerType !== "touch" && (D.x <= 10 && D.y <= 10 ? M.preventDefault() : i.value?.contains(M.target) || C(!1), document.removeEventListener("pointermove", q), S.value = null);
      };
      S.value !== null && (document.addEventListener("pointermove", q), document.addEventListener("pointerup", T, {
        capture: !0,
        once: !0
      })), P(() => {
        document.removeEventListener("pointermove", q), document.removeEventListener("pointerup", T, { capture: !0 });
      });
    });
    function $(P) {
      const D = P.ctrlKey || P.altKey || P.metaKey;
      if (P.key === "Tab" && P.preventDefault(), !D && P.key.length === 1 && d(P.key, s()), [
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End"
      ].includes(P.key)) {
        let T = [...s().map((M) => M.ref)];
        if (["ArrowUp", "End"].includes(P.key) && (T = T.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(P.key)) {
          const M = P.target, O = T.indexOf(M);
          T = T.slice(O + 1);
        }
        setTimeout(() => _d(T)), P.preventDefault();
      }
    }
    const B = E(() => n.position === "popper" ? n : {}), k = he(B.value);
    return Jg({
      content: i,
      viewport: c,
      onViewportChange: (P) => {
        c.value = P;
      },
      itemRefCallback: (P, D, q) => {
        const T = !m.value && !q, M = jo(r.modelValue.value, D, r.by);
        if (r.multiple.value) {
          if (g.value) return;
          (M || T) && (f.value = P, M && (g.value = !0));
        } else (M || T) && (f.value = P);
        T && (m.value = !0);
      },
      selectedItem: f,
      selectedItemText: p,
      onItemLeave: () => {
        i.value?.focus();
      },
      itemTextRefCallback: (P, D, q) => {
        const T = !m.value && !q;
        (jo(r.modelValue.value, D, r.by) || T) && (p.value = P);
      },
      focusSelectedItem: w,
      position: n.position,
      isPositioned: v,
      searchRef: u
    }), (P, D) => (h(), x(l(o), null, {
      default: y(() => [N(l(Ci), {
        "as-child": "",
        onMountAutoFocus: D[6] || (D[6] = Ye(() => {
        }, ["prevent"])),
        onUnmountAutoFocus: D[7] || (D[7] = (q) => {
          a("closeAutoFocus", q), !q.defaultPrevented && (l(r).triggerElement.value?.focus({ preventScroll: !0 }), q.preventDefault());
        })
      }, {
        default: y(() => [N(l(Fa), {
          "as-child": "",
          "disable-outside-pointer-events": P.disableOutsidePointerEvents,
          onFocusOutside: D[2] || (D[2] = Ye(() => {
          }, ["prevent"])),
          onDismiss: D[3] || (D[3] = (q) => l(r).onOpenChange(!1)),
          onEscapeKeyDown: D[4] || (D[4] = (q) => a("escapeKeyDown", q)),
          onPointerDownOutside: D[5] || (D[5] = (q) => a("pointerDownOutside", q))
        }, {
          default: y(() => [(h(), x(Pt(P.position === "popper" ? aq : uq), A({
            ...P.$attrs,
            ...l(k)
          }, {
            id: l(r).contentId,
            ref: (q) => {
              const T = l(Gt)(q);
              T?.hasAttribute("data-reka-popper-content-wrapper") ? i.value = T.firstElementChild : i.value = T;
            },
            role: "listbox",
            "data-state": l(r).open.value ? "open" : "closed",
            dir: l(r).dir.value,
            style: {
              display: "flex",
              flexDirection: "column",
              outline: "none"
            },
            onContextmenu: D[0] || (D[0] = Ye(() => {
            }, ["prevent"])),
            onPlaced: D[1] || (D[1] = (q) => v.value = !0),
            onKeydown: $
          }), {
            default: y(() => [_(P.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "data-state",
            "dir",
            "onKeydown"
          ]))]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      })]),
      _: 3
    }));
  }
}), sq = oq;
const [af, lq] = Se("SelectItemAlignedPosition");
var iq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st(), o = La(), s = pr(), i = I(!1), u = I(!0), d = I(), { forwardRef: c, currentElement: f } = j(), { viewport: p, selectedItem: v, selectedItemText: m, focusSelectedItem: g } = s;
    function w() {
      if (o.triggerElement.value && o.valueElement.value && d.value && f.value && p?.value && v?.value && m?.value) {
        const $ = o.triggerElement.value.getBoundingClientRect(), B = f.value.getBoundingClientRect(), k = o.valueElement.value.getBoundingClientRect(), P = m.value.getBoundingClientRect();
        if (o.dir.value !== "rtl") {
          const R = P.left - B.left, te = k.left - R, z = $.left - te, re = $.width + z, ie = Math.max(re, B.width), L = window.innerWidth - $n, be = Rr(te, $n, Math.max($n, L - ie));
          d.value.style.minWidth = `${re}px`, d.value.style.left = `${be}px`;
        } else {
          const R = B.right - P.right, te = window.innerWidth - k.right - R, z = window.innerWidth - $.right - te, re = $.width + z, ie = Math.max(re, B.width), L = window.innerWidth - $n, be = Rr(te, $n, Math.max($n, L - ie));
          d.value.style.minWidth = `${re}px`, d.value.style.right = `${be}px`;
        }
        const D = r().map((R) => R.ref), q = window.innerHeight - $n * 2, T = p.value.scrollHeight, M = window.getComputedStyle(f.value), O = Number.parseInt(M.borderTopWidth, 10), F = Number.parseInt(M.paddingTop, 10), J = Number.parseInt(M.borderBottomWidth, 10), ne = Number.parseInt(M.paddingBottom, 10), Q = O + F + T + ne + J, G = Math.min(v.value.offsetHeight * 5, Q), H = window.getComputedStyle(p.value), U = Number.parseInt(H.paddingTop, 10), se = Number.parseInt(H.paddingBottom, 10), ee = $.top + $.height / 2 - $n, de = q - ee, pe = v.value.offsetHeight / 2, _e = v.value.offsetTop + pe, ge = O + F + _e, Te = Q - ge;
        if (ge <= ee) {
          const R = v.value === D[D.length - 1];
          d.value.style.bottom = "0px";
          const te = f.value.clientHeight - p.value.offsetTop - p.value.offsetHeight, z = Math.max(de, pe + (R ? se : 0) + te + J), re = ge + z;
          d.value.style.height = `${re}px`;
        } else {
          const R = v.value === D[0];
          d.value.style.top = "0px";
          const z = Math.max(ee, O + p.value.offsetTop + (R ? U : 0) + pe) + Te;
          d.value.style.height = `${z}px`, p.value.scrollTop = ge - ee + p.value.offsetTop;
        }
        d.value.style.margin = `${$n}px 0`, d.value.style.minHeight = `${G}px`, d.value.style.maxHeight = `${q}px`, a("placed"), requestAnimationFrame(() => i.value = !0);
      }
    }
    const C = I("");
    Ce(async () => {
      await Be(), w(), f.value && (C.value = window.getComputedStyle(f.value).zIndex);
    });
    function S($) {
      $ && u.value === !0 && (w(), g?.(), u.value = !1);
    }
    return Tn(o.triggerElement, () => {
      w();
    }), lq({
      contentWrapper: d,
      shouldExpandOnScrollRef: i,
      onScrollButtonChange: S
    }), ($, B) => (h(), W("div", {
      ref_key: "contentWrapperElement",
      ref: d,
      style: dt({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: C.value
      })
    }, [N(l(X), A({
      ref: l(c),
      style: {
        boxSizing: "border-box",
        maxHeight: "100%"
      }
    }, {
      ...$.$attrs,
      ...n
    }), {
      default: y(() => [_($.$slots, "default")]),
      _: 3
    }, 16)], 4));
  }
}), uq = iq, dq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectProvider",
  props: { context: {
    type: Object,
    required: !0
  } },
  setup(e) {
    return Xg(e.context), Jg(rq), (n, a) => _(n.$slots, "default");
  }
}), cq = dq;
const fq = { key: 1 };
var pq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, r = me(n, t), o = La(), s = I();
    Ce(() => {
      s.value = new DocumentFragment();
    });
    const i = I(), u = E(() => n.forceMount || o.open.value), d = I(u.value);
    return ve(u, () => {
      setTimeout(() => d.value = u.value);
    }), (c, f) => u.value || d.value || i.value?.present ? (h(), x(l($t), {
      key: 0,
      ref_key: "presenceRef",
      ref: i,
      present: u.value
    }, {
      default: y(() => [N(sq, oe(le({
        ...l(r),
        ...c.$attrs
      })), {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"])) : s.value ? (h(), W("div", fq, [(h(), x(gi, { to: s.value }, [N(cq, { context: l(o) }, {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["context"])], 8, ["to"]))])) : Ee("v-if", !0);
  }
}), vq = pq;
const [mq, hq] = Se("SelectGroup");
var gq = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ge(void 0, "reka-select-group");
    return hq({ id: n }), (a, r) => (h(), x(l(X), A({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), yq = gq, bq = /* @__PURE__ */ b({
  __name: "SelectIcon",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), x(l(X), {
      "aria-hidden": "true",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: y(() => [_(t.$slots, "default", {}, () => [n[0] || (n[0] = Re(""))])]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), _q = bq;
const [Zg, wq] = Se("SelectItem");
var xq = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = Me(n), o = La(), s = pr(), { forwardRef: i, currentElement: u } = j(), { CollectionItem: d } = st(), c = E(() => jo(o.modelValue?.value, n.value, o.by)), f = I(!1), p = I(n.textValue ?? ""), v = Ge(void 0, "reka-select-item-text"), m = "select.select";
    async function g(B) {
      if (B.defaultPrevented) return;
      const k = {
        originalEvent: B,
        value: n.value
      };
      is(m, w, k);
    }
    async function w(B) {
      await Be(), a("select", B), !B.defaultPrevented && (r.value || (o.onValueChange(n.value), o.multiple.value || o.onOpenChange(!1)));
    }
    async function C(B) {
      await Be(), !B.defaultPrevented && (r.value ? s.onItemLeave?.() : B.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function S(B) {
      await Be(), !B.defaultPrevented && B.currentTarget === ot() && s.onItemLeave?.();
    }
    async function $(B) {
      await Be(), !(B.defaultPrevented || s.searchRef?.value !== "" && B.key === " ") && (YE.includes(B.key) && g(B), B.key === " " && B.preventDefault());
    }
    if (n.value === "") throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    return Ce(() => {
      u.value && s.itemRefCallback(u.value, n.value, n.disabled);
    }), wq({
      value: n.value,
      disabled: r,
      textId: v,
      isSelected: c,
      onItemTextChange: (B) => {
        p.value = ((p.value || B?.textContent) ?? "").trim();
      }
    }), (B, k) => (h(), x(l(d), { value: { textValue: p.value } }, {
      default: y(() => [N(l(X), {
        ref: l(i),
        role: "option",
        "aria-labelledby": l(v),
        "data-highlighted": f.value ? "" : void 0,
        "aria-selected": c.value,
        "data-state": c.value ? "checked" : "unchecked",
        "aria-disabled": l(r) || void 0,
        "data-disabled": l(r) ? "" : void 0,
        tabindex: l(r) ? void 0 : -1,
        as: B.as,
        "as-child": B.asChild,
        onFocus: k[0] || (k[0] = (P) => f.value = !0),
        onBlur: k[1] || (k[1] = (P) => f.value = !1),
        onPointerup: g,
        onPointerdown: k[2] || (k[2] = (P) => {
          P.currentTarget.focus({ preventScroll: !0 });
        }),
        onTouchend: k[3] || (k[3] = Ye(() => {
        }, ["prevent", "stop"])),
        onPointermove: C,
        onPointerleave: S,
        onKeydown: $
      }, {
        default: y(() => [_(B.$slots, "default")]),
        _: 3
      }, 8, [
        "aria-labelledby",
        "data-highlighted",
        "aria-selected",
        "data-state",
        "aria-disabled",
        "data-disabled",
        "tabindex",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), Cq = xq, Sq = /* @__PURE__ */ b({
  __name: "SelectItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Zg();
    return (a, r) => l(n).isSelected.value ? (h(), x(l(X), A({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : Ee("v-if", !0);
  }
}), $q = Sq, kq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = La(), a = pr(), r = Zg(), { forwardRef: o, currentElement: s } = j(), i = E(() => ({
      value: r.value,
      disabled: r.disabled.value,
      textContent: s.value?.textContent ?? r.value?.toString() ?? ""
    }));
    return Ce(() => {
      s.value && (r.onItemTextChange(s.value), a.itemTextRefCallback(s.value, r.value, r.disabled.value), n.onOptionAdd(i.value));
    }), Qe(() => {
      n.onOptionRemove(i.value);
    }), (u, d) => (h(), x(l(X), A({
      id: l(r).textId,
      ref: l(o)
    }, {
      ...t,
      ...u.$attrs
    }), {
      default: y(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Qg = kq, Bq = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = mq({ id: "" });
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).id }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Dq = Bq, Pq = /* @__PURE__ */ b({
  __name: "SelectPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Mq = Pq, Eq = /* @__PURE__ */ b({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(e, { emit: t }) {
    const n = t, { getItems: a } = st(), r = pr(), o = I(null);
    function s() {
      o.value !== null && (window.clearInterval(o.value), o.value = null);
    }
    Ie(() => {
      a().map((c) => c.ref).find((c) => c === ot())?.scrollIntoView({ block: "nearest" });
    });
    function i() {
      o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    function u() {
      r.onItemLeave?.(), o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    return sr(() => s()), (d, c) => (h(), x(l(X), A({
      "aria-hidden": "true",
      style: { flexShrink: 0 }
    }, d.$parent?.$props, {
      onPointerdown: i,
      onPointermove: u,
      onPointerleave: c[0] || (c[0] = () => {
        s();
      })
    }), {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ey = Eq, qq = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = pr(), n = t.position === "item-aligned" ? af() : void 0, { forwardRef: a, currentElement: r } = j(), o = I(!1);
    return Ie((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          const d = i.scrollHeight - i.clientHeight;
          o.value = Math.ceil(i.scrollTop) < d;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), ve(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), x(ey, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : Ee("v-if", !0);
  }
}), Tq = qq, Aq = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = pr(), n = t.position === "item-aligned" ? af() : void 0, { forwardRef: a, currentElement: r } = j(), o = I(!1);
    return Ie((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          o.value = i.scrollTop > 0;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), ve(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), x(ey, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : Ee("v-if", !0);
  }
}), Iq = Aq, Oq = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({ "aria-hidden": "true" }, t), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Rq = Oq, Vq = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = La(), { forwardRef: a, currentElement: r } = j(), o = E(() => n.disabled?.value || t.disabled);
    n.contentId ||= Ge(void 0, "reka-select-content"), Ce(() => {
      n.onTriggerChange(r.value);
    });
    const { getItems: s } = st(), { search: i, handleTypeaheadSearch: u, resetTypeahead: d } = _i();
    function c() {
      o.value || (n.onOpenChange(!0), d());
    }
    function f(p) {
      c(), n.triggerPointerDownPosRef.value = {
        x: Math.round(p.pageX),
        y: Math.round(p.pageY)
      };
    }
    return (p, v) => (h(), x(l(ur), {
      "as-child": "",
      reference: p.reference
    }, {
      default: y(() => [N(l(X), {
        ref: l(a),
        role: "combobox",
        type: p.as === "button" ? "button" : void 0,
        "aria-controls": l(n).contentId,
        "aria-expanded": l(n).open.value || !1,
        "aria-required": l(n).required?.value,
        "aria-autocomplete": "none",
        disabled: o.value,
        dir: l(n)?.dir.value,
        "data-state": l(n)?.open.value ? "open" : "closed",
        "data-disabled": o.value ? "" : void 0,
        "data-placeholder": l(XE)(l(n).modelValue?.value) ? "" : void 0,
        "as-child": p.asChild,
        as: p.as,
        onClick: v[0] || (v[0] = (m) => {
          m?.currentTarget?.focus();
        }),
        onPointerdown: v[1] || (v[1] = (m) => {
          if (m.pointerType === "touch") return m.preventDefault();
          const g = m.target;
          g.hasPointerCapture(m.pointerId) && g.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && (f(m), m.preventDefault());
        }),
        onPointerup: v[2] || (v[2] = Ye((m) => {
          m.pointerType === "touch" && f(m);
        }, ["prevent"])),
        onKeydown: v[3] || (v[3] = (m) => {
          const g = l(i) !== "";
          !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && g && m.key === " " || (l(u)(m.key, l(s)()), l(KE).includes(m.key) && (c(), m.preventDefault()));
        })
      }, {
        default: y(() => [_(p.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "aria-controls",
        "aria-expanded",
        "aria-required",
        "disabled",
        "dir",
        "data-state",
        "data-disabled",
        "data-placeholder",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), Fq = Vq, Nq = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = La();
    Ce(() => {
      r.valueElement = a;
    });
    const o = E(() => {
      let i = [];
      const u = Array.from(r.optionsSet.value), d = (c) => u.find((f) => jo(c, f.value, r.by));
      return Array.isArray(r.modelValue.value) ? i = r.modelValue.value.map((c) => d(c)?.textContent ?? "") : i = [d(r.modelValue.value)?.textContent ?? ""], i.filter(Boolean);
    }), s = E(() => o.value.length ? o.value.join(", ") : t.placeholder);
    return (i, u) => (h(), x(l(X), {
      ref: l(n),
      as: i.as,
      "as-child": i.asChild,
      style: { pointerEvents: "none" },
      "data-placeholder": o.value.length ? void 0 : t.placeholder
    }, {
      default: y(() => [_(i.$slots, "default", {
        selectedLabel: o.value,
        modelValue: l(r).modelValue.value
      }, () => [Re(Ne(s.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-placeholder"
    ]));
  }
}), Lq = Nq, zq = /* @__PURE__ */ b({
  __name: "SelectViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { nonce: n } = Me(t), a = Ai(n), r = pr(), o = r.position === "item-aligned" ? af() : void 0, { forwardRef: s, currentElement: i } = j();
    Ce(() => {
      r?.onViewportChange(i.value);
    });
    const u = I(0);
    function d(c) {
      const f = c.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: v } = o ?? {};
      if (p?.value && v?.value) {
        const m = Math.abs(u.value - f.scrollTop);
        if (m > 0) {
          const g = window.innerHeight - $n * 2, w = Number.parseFloat(v.value.style.minHeight), C = Number.parseFloat(v.value.style.height), S = Math.max(w, C);
          if (S < g) {
            const $ = S + m, B = Math.min(g, $), k = $ - B;
            v.value.style.height = `${B}px`, v.value.style.bottom === "0px" && (f.scrollTop = k > 0 ? k : 0, v.value.style.justifyContent = "flex-end");
          }
        }
      }
      u.value = f.scrollTop;
    }
    return (c, f) => (h(), W(Ke, null, [N(l(X), A({
      ref: l(s),
      "data-reka-select-viewport": "",
      role: "presentation"
    }, {
      ...c.$attrs,
      ...t
    }, {
      style: {
        position: "relative",
        flex: 1,
        overflow: "hidden auto"
      },
      onScroll: d
    }), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16), N(l(X), {
      as: "style",
      nonce: l(a)
    }, {
      default: y(() => f[0] || (f[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), Hq = zq, Uq = /* @__PURE__ */ b({
  __name: "BaseSeparator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ["horizontal", "vertical"];
    function a(i) {
      return n.includes(i);
    }
    const r = E(() => a(t.orientation) ? t.orientation : "horizontal"), o = E(() => r.value === "vertical" ? t.orientation : void 0), s = E(() => t.decorative ? { role: "none" } : {
      "aria-orientation": o.value,
      role: "separator"
    });
    return (i, u) => (h(), x(l(X), A({
      as: i.as,
      "as-child": i.asChild,
      "data-orientation": r.value
    }, s.value), {
      default: y(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-orientation"
    ]));
  }
}), jq = Uq, Wq = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(jq, oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rf = Wq;
function Gq(e = [], t, n) {
  const a = [...e];
  return a[n] = t, a.sort((r, o) => r - o);
}
function ty(e, t, n) {
  const o = 100 / (n - t) * (e - t);
  return Rr(o, 0, 100);
}
function Kq(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function Yq(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((r) => Math.abs(r - t)), a = Math.min(...n);
  return n.indexOf(a);
}
function Xq(e, t, n) {
  const a = e / 2, o = of([0, 50], [0, a]);
  return (a - o(t) * n) * n;
}
function Jq(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function Zq(e, t) {
  if (t > 0) {
    const n = Jq(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function of(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function Qq(e) {
  return (String(e).split(".")[1] || "").length;
}
function eT(e, t) {
  const n = 10 ** t;
  return Math.round(e * n) / n;
}
const ny = ["PageUp", "PageDown"], ay = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
], ry = {
  "from-left": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-right": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowRight"
  ],
  "from-bottom": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-top": [
    "Home",
    "PageUp",
    "ArrowUp",
    "ArrowLeft"
  ]
}, [oy, sy] = Se(["SliderVertical", "SliderHorizontal"]);
var tT = /* @__PURE__ */ b({
  __name: "SliderHorizontal",
  props: {
    dir: {
      type: String,
      required: !1
    },
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, dir: s, inverted: i } = Me(n), { forwardRef: u, currentElement: d } = j(), c = ao(), f = I(), p = I(), v = E(() => s?.value !== "rtl" && !i.value || s?.value !== "ltr" && i.value);
    function m(S, $) {
      const B = p.value || d.value.getBoundingClientRect(), k = [...c.thumbElements.value][c.valueIndexToChangeRef.value], P = c.thumbAlignment.value === "contain" ? k.clientWidth : 0;
      !f.value && !$ && c.thumbAlignment.value === "contain" && (f.value = S.clientX - k.getBoundingClientRect().left);
      const D = [0, B.width - P], q = v.value ? [o.value, r.value] : [r.value, o.value], T = of(D, q);
      p.value = B;
      const M = $ ? S.clientX - B.left - P / 2 : S.clientX - B.left - (f.value ?? 0);
      return T(M);
    }
    const g = E(() => v.value ? "left" : "right"), w = E(() => v.value ? "right" : "left"), C = E(() => v.value ? 1 : -1);
    return sy({
      startEdge: g,
      endEdge: w,
      direction: C,
      size: "width"
    }), (S, $) => (h(), x(ly, {
      ref: l(u),
      dir: l(s),
      "data-orientation": "horizontal",
      style: dt({ "--reka-slider-thumb-transform": !v.value && l(c).thumbAlignment.value === "overflow" ? "translateX(50%)" : "translateX(-50%)" }),
      onSlideStart: $[0] || ($[0] = (B) => {
        const k = m(B, !0);
        a("slideStart", k);
      }),
      onSlideMove: $[1] || ($[1] = (B) => {
        const k = m(B);
        a("slideMove", k);
      }),
      onSlideEnd: $[2] || ($[2] = () => {
        p.value = void 0, f.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: $[3] || ($[3] = (B) => {
        const k = v.value ? "from-left" : "from-right", P = l(ry)[k].includes(B.key);
        a("stepKeyDown", B, P ? -1 : 1);
      }),
      onEndKeyDown: $[4] || ($[4] = (B) => a("endKeyDown", B)),
      onHomeKeyDown: $[5] || ($[5] = (B) => a("homeKeyDown", B))
    }, {
      default: y(() => [_(S.$slots, "default")]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), nT = tT, aT = /* @__PURE__ */ b({
  __name: "SliderVertical",
  props: {
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, inverted: s } = Me(n), i = ao(), { forwardRef: u, currentElement: d } = j(), c = I(), f = I(), p = E(() => !s.value);
    function v(C, S) {
      const $ = f.value || d.value.getBoundingClientRect(), B = [...i.thumbElements.value][i.valueIndexToChangeRef.value], k = i.thumbAlignment.value === "contain" ? B.clientHeight : 0;
      !c.value && !S && i.thumbAlignment.value === "contain" && (c.value = C.clientY - B.getBoundingClientRect().top);
      const P = [0, $.height - k], D = p.value ? [r.value, o.value] : [o.value, r.value], q = of(P, D), T = S ? C.clientY - $.top - k / 2 : C.clientY - $.top - (c.value ?? 0);
      return f.value = $, q(T);
    }
    const m = E(() => p.value ? "bottom" : "top"), g = E(() => p.value ? "top" : "bottom"), w = E(() => p.value ? 1 : -1);
    return sy({
      startEdge: m,
      endEdge: g,
      direction: w,
      size: "height"
    }), (C, S) => (h(), x(ly, {
      ref: l(u),
      "data-orientation": "vertical",
      style: dt({ "--reka-slider-thumb-transform": !p.value && l(i).thumbAlignment.value === "overflow" ? "translateY(-50%)" : "translateY(50%)" }),
      onSlideStart: S[0] || (S[0] = ($) => {
        const B = v($, !0);
        a("slideStart", B);
      }),
      onSlideMove: S[1] || (S[1] = ($) => {
        const B = v($);
        a("slideMove", B);
      }),
      onSlideEnd: S[2] || (S[2] = () => {
        f.value = void 0, c.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: S[3] || (S[3] = ($) => {
        const B = p.value ? "from-bottom" : "from-top", k = l(ry)[B].includes($.key);
        a("stepKeyDown", $, k ? -1 : 1);
      }),
      onEndKeyDown: S[4] || (S[4] = ($) => a("endKeyDown", $)),
      onHomeKeyDown: S[5] || (S[5] = ($) => a("homeKeyDown", $))
    }, {
      default: y(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), rT = aT;
const [ao, oT] = Se("SliderRoot");
var sT = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    defaultValue: {
      type: Array,
      required: !1,
      default: () => [0]
    },
    modelValue: {
      type: [Array, null],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    inverted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    min: {
      type: Number,
      required: !1,
      default: 0
    },
    max: {
      type: Number,
      required: !1,
      default: 100
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    minStepsBetweenThumbs: {
      type: Number,
      required: !1,
      default: 0
    },
    thumbAlignment: {
      type: String,
      required: !1,
      default: "contain"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, { min: r, max: o, step: s, minStepsBetweenThumbs: i, orientation: u, disabled: d, thumbAlignment: c, dir: f } = Me(n), p = yt(f), { forwardRef: v, currentElement: m } = j(), g = Rn(m), { CollectionSlot: w } = st({ isProvider: !0 }), C = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), S = E(() => Array.isArray(C.value) ? [...C.value] : []), $ = I(0), B = I(S.value);
    function k(M) {
      const O = Yq(S.value, M);
      q(M, O);
    }
    function P(M) {
      q(M, $.value);
    }
    function D() {
      const M = B.value[$.value];
      S.value[$.value] !== M && a("valueCommit", B0(S.value));
    }
    function q(M, O, { commit: F } = { commit: !1 }) {
      const J = Qq(s.value), ne = eT(Math.round((M - r.value) / s.value) * s.value + r.value, J), Q = Rr(ne, r.value, o.value), G = Gq(S.value, Q, O);
      if (Zq(G, i.value * s.value)) {
        $.value = G.indexOf(Q);
        const H = String(G) !== String(C.value);
        H && F && a("valueCommit", G), H && (T.value[$.value]?.focus(), C.value = G);
      }
    }
    const T = I([]);
    return oT({
      modelValue: C,
      currentModelValue: S,
      valueIndexToChangeRef: $,
      thumbElements: T,
      orientation: u,
      min: r,
      max: o,
      disabled: d,
      thumbAlignment: c
    }), (M, O) => (h(), x(l(w), null, {
      default: y(() => [(h(), x(Pt(l(u) === "horizontal" ? nT : rT), A(M.$attrs, {
        ref: l(v),
        "as-child": M.asChild,
        as: M.as,
        min: l(r),
        max: l(o),
        dir: l(p),
        inverted: M.inverted,
        "aria-disabled": l(d),
        "data-disabled": l(d) ? "" : void 0,
        onPointerdown: O[0] || (O[0] = () => {
          l(d) || (B.value = S.value);
        }),
        onSlideStart: O[1] || (O[1] = (F) => !l(d) && k(F)),
        onSlideMove: O[2] || (O[2] = (F) => !l(d) && P(F)),
        onSlideEnd: O[3] || (O[3] = (F) => !l(d) && D()),
        onHomeKeyDown: O[4] || (O[4] = (F) => !l(d) && q(l(r), 0, { commit: !0 })),
        onEndKeyDown: O[5] || (O[5] = (F) => !l(d) && q(l(o), S.value.length - 1, { commit: !0 })),
        onStepKeyDown: O[6] || (O[6] = (F, J) => {
          if (!l(d)) {
            const G = l(ny).includes(F.key) || F.shiftKey && l(ay).includes(F.key) ? 10 : 1, H = $.value, U = S.value[H], se = l(s) * G * J;
            q(U + se, H, { commit: !0 });
          }
        })
      }), {
        default: y(() => [_(M.$slots, "default", { modelValue: l(C) }), l(g) && M.name ? (h(), x(l(Vn), {
          key: 0,
          type: "number",
          value: l(C),
          name: M.name,
          required: M.required,
          disabled: l(d),
          step: l(s)
        }, null, 8, [
          "value",
          "name",
          "required",
          "disabled",
          "step"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "min",
        "max",
        "dir",
        "inverted",
        "aria-disabled",
        "data-disabled"
      ]))]),
      _: 3
    }));
  }
}), lT = sT, iT = /* @__PURE__ */ b({
  __name: "SliderImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  emits: [
    "slideStart",
    "slideMove",
    "slideEnd",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ao();
    return (o, s) => (h(), x(l(X), A({ "data-slider-impl": "" }, n, {
      onKeydown: s[0] || (s[0] = (i) => {
        i.key === "Home" ? (a("homeKeyDown", i), i.preventDefault()) : i.key === "End" ? (a("endKeyDown", i), i.preventDefault()) : l(ny).concat(l(ay)).includes(i.key) && (a("stepKeyDown", i), i.preventDefault());
      }),
      onPointerdown: s[1] || (s[1] = (i) => {
        const u = i.target;
        u.setPointerCapture(i.pointerId), i.preventDefault(), l(r).thumbElements.value.includes(u) ? u.focus() : a("slideStart", i);
      }),
      onPointermove: s[2] || (s[2] = (i) => {
        i.target.hasPointerCapture(i.pointerId) && a("slideMove", i);
      }),
      onPointerup: s[3] || (s[3] = (i) => {
        const u = i.target;
        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), a("slideEnd", i));
      })
    }), {
      default: y(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ly = iT, uT = /* @__PURE__ */ b({
  __name: "SliderRange",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = ao(), n = oy();
    j();
    const a = E(() => t.currentModelValue.value.map((s) => ty(s, t.min.value, t.max.value))), r = E(() => t.currentModelValue.value.length > 1 ? Math.min(...a.value) : 0), o = E(() => 100 - Math.max(...a.value, 0));
    return (s, i) => (h(), x(l(X), {
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      "as-child": s.asChild,
      as: s.as,
      style: dt({
        [l(n).startEdge.value]: `${r.value}%`,
        [l(n).endEdge.value]: `${o.value}%`
      })
    }, {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, [
      "data-disabled",
      "data-orientation",
      "as-child",
      "as",
      "style"
    ]));
  }
}), dT = uT, cT = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ao(), a = oy(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = E(() => n.modelValue?.value?.[t.index]), u = E(() => i.value === void 0 ? 0 : ty(i.value, n.min.value ?? 0, n.max.value ?? 100)), d = E(() => Kq(t.index, n.modelValue?.value?.length ?? 0)), c = Kh(o), f = E(() => c[a.size].value), p = E(() => n.thumbAlignment.value === "overflow" || !f.value ? 0 : Xq(f.value, u.value, a.direction.value)), v = pc();
    return Ce(() => {
      n.thumbElements.value.push(o.value);
    }), Qe(() => {
      const m = n.thumbElements.value.findIndex((g) => g === o.value) ?? -1;
      n.thumbElements.value.splice(m, 1);
    }), (m, g) => (h(), x(l(s), null, {
      default: y(() => [N(l(X), A(m.$attrs, {
        ref: l(r),
        role: "slider",
        tabindex: l(n).disabled.value ? void 0 : 0,
        "aria-label": m.$attrs["aria-label"] || d.value,
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "data-orientation": l(n).orientation.value,
        "aria-valuenow": i.value,
        "aria-valuemin": l(n).min.value,
        "aria-valuemax": l(n).max.value,
        "aria-orientation": l(n).orientation.value,
        "as-child": m.asChild,
        as: m.as,
        style: {
          transform: "var(--reka-slider-thumb-transform)",
          position: "absolute",
          [l(a).startEdge.value]: `calc(${u.value}% + ${p.value}px)`,
          display: !l(v) && i.value === void 0 ? "none" : void 0
        },
        onFocus: g[0] || (g[0] = () => {
          l(n).valueIndexToChangeRef.value = m.index;
        })
      }), {
        default: y(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "tabindex",
        "aria-label",
        "data-disabled",
        "data-orientation",
        "aria-valuenow",
        "aria-valuemin",
        "aria-valuemax",
        "aria-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }));
  }
}), fT = cT, pT = /* @__PURE__ */ b({
  __name: "SliderThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { getItems: n } = st(), { forwardRef: a, currentElement: r } = j(), o = E(() => r.value ? n(!0).findIndex((s) => s.ref === r.value) : -1);
    return (s, i) => (h(), x(fT, A({ ref: l(a) }, t, { index: o.value }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["index"]));
  }
}), vT = pT, mT = /* @__PURE__ */ b({
  __name: "SliderTrack",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = ao();
    return j(), (n, a) => (h(), x(l(X), {
      "as-child": n.asChild,
      as: n.as,
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), hT = mT;
function He(e, t = "Assertion failed!") {
  if (!e)
    throw console.error(t), new Error(t);
}
function iy(e, t = document) {
  if (!ls) return null;
  if (t instanceof HTMLElement && t?.dataset?.panelGroupId === e) return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function zi(e, t = document) {
  if (!ls) return null;
  const n = t.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return n || null;
}
function uy(e, t, n = document) {
  return ls ? Wo(e, n).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === t) ?? null : null;
}
function Wo(e, t = document) {
  return ls ? Array.from(t.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function gT(e, t, n, a = document) {
  const r = zi(t, a), o = Wo(e, a), s = r ? o.indexOf(r) : -1, i = n[s]?.id ?? null, u = n[s + 1]?.id ?? null;
  return [i, u];
}
function dy(e) {
  return e.type === "keydown";
}
function cy(e) {
  return e.type.startsWith("mouse");
}
function fy(e) {
  return e.type.startsWith("touch");
}
function Hi(e) {
  if (cy(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (fy(e)) {
    const t = e.touches[0];
    if (t && t.clientX && t.clientY) return {
      x: t.clientX,
      y: t.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function py(e, t) {
  const n = e === "horizontal", { x: a, y: r } = Hi(t);
  return n ? a : r;
}
function yT(e, t, n, a, r) {
  const o = n === "horizontal", s = zi(t, r);
  He(s);
  const i = s.getAttribute("data-panel-group-id");
  He(i);
  const { initialCursorPosition: u } = a, d = py(n, e), c = iy(i, r);
  He(c);
  const f = c.getBoundingClientRect(), p = o ? f.width : f.height;
  return (d - u) / p * 100;
}
function bT(e, t, n, a, r, o) {
  if (dy(e)) {
    const s = n === "horizontal";
    let i = 0;
    e.shiftKey ? i = 100 : i = r ?? 10;
    let u = 0;
    switch (e.key) {
      case "ArrowDown":
        u = s ? 0 : i;
        break;
      case "ArrowLeft":
        u = s ? -i : 0;
        break;
      case "ArrowRight":
        u = s ? i : 0;
        break;
      case "ArrowUp":
        u = s ? 0 : -i;
        break;
      case "End":
        u = 100;
        break;
      case "Home":
        u = -100;
        break;
    }
    return u;
  } else
    return a == null ? 0 : yT(e, t, n, a, o);
}
function _T({ layout: e, panelsArray: t, pivotIndices: n }) {
  let a = 0, r = 100, o = 0, s = 0;
  const i = n[0];
  He(i != null), t.forEach((f, p) => {
    const { constraints: v } = f, { maxSize: m = 100, minSize: g = 0 } = v;
    p === i ? (a = g, r = m) : (o += g, s += m);
  });
  const u = Math.min(r, 100 - o), d = Math.max(a, 100 - s), c = e[i];
  return {
    valueMax: u,
    valueMin: d,
    valueNow: c
  };
}
function wT({ panelDataArray: e }) {
  const t = Array.from({ length: e.length }), n = e.map((o) => o.constraints);
  let a = 0, r = 100;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    He(s);
    const { defaultSize: i } = s;
    i != null && (a++, t[o] = i, r -= i);
  }
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    He(s);
    const { defaultSize: i } = s;
    if (i != null) continue;
    const u = e.length - a, d = r / u;
    a++, t[o] = d, r -= d;
  }
  return t;
}
function vo(e, t, n) {
  t.forEach((a, r) => {
    const o = e[r];
    He(o);
    const { callbacks: s, constraints: i, id: u } = o, { collapsedSize: d = 0, collapsible: c } = i, f = n[u];
    if (f == null || a !== f) {
      n[u] = a;
      const { onCollapse: p, onExpand: v, onResize: m } = s;
      m && m(a, f), c && (p || v) && (v && (f == null || f === d) && a !== d && v(), p && (f == null || f !== d) && a === d && p());
    }
  });
}
function xT(e, t = 10) {
  let n = null;
  return (...r) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...r);
    }, t);
  };
}
const sf = 10;
function Go(e, t, n = sf) {
  e = Number.parseFloat(e.toFixed(n)), t = Number.parseFloat(t.toFixed(n));
  const a = e - t;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function dn(e, t, n) {
  return Go(e, t, n) === 0;
}
function kr({ panelConstraints: e, panelIndex: t, size: n }) {
  const a = e[t];
  He(a != null);
  const { collapsedSize: r = 0, collapsible: o, maxSize: s = 100, minSize: i = 0 } = a;
  if (Go(n, i) < 0) if (o) {
    const u = (r + i) / 2;
    Go(n, u) < 0 ? n = r : n = i;
  } else n = i;
  return n = Math.min(s, n), n = Number.parseFloat(n.toFixed(sf)), n;
}
function js(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function So({ delta: e, layout: t, panelConstraints: n, pivotIndices: a, trigger: r }) {
  if (dn(e, 0)) return t;
  const o = [...t], [s, i] = a;
  He(s != null), He(i != null);
  let u = 0;
  if (r === "keyboard") {
    {
      const c = e < 0 ? i : s, f = n[c];
      if (He(f), f.collapsible) {
        const p = t[c];
        He(p != null);
        const v = n[c];
        He(v);
        const { collapsedSize: m = 0, minSize: g = 0 } = v;
        if (dn(p, m)) {
          const w = g - p;
          Go(w, Math.abs(e)) > 0 && (e = e < 0 ? 0 - w : w);
        }
      }
    }
    {
      const c = e < 0 ? s : i, f = n[c];
      He(f);
      const { collapsible: p } = f;
      if (p) {
        const v = t[c];
        He(v != null);
        const m = n[c];
        He(m);
        const { collapsedSize: g = 0, minSize: w = 0 } = m;
        if (dn(v, w)) {
          const C = v - g;
          Go(C, Math.abs(e)) > 0 && (e = e < 0 ? 0 - C : C);
        }
      }
    }
  }
  {
    const c = e < 0 ? 1 : -1;
    let f = e < 0 ? i : s, p = 0;
    for (; ; ) {
      const m = t[f];
      He(m != null);
      const w = kr({
        panelConstraints: n,
        panelIndex: f,
        size: 100
      }) - m;
      if (p += w, f += c, f < 0 || f >= n.length) break;
    }
    const v = Math.min(Math.abs(e), Math.abs(p));
    e = e < 0 ? 0 - v : v;
  }
  {
    let f = e < 0 ? s : i;
    for (; f >= 0 && f < n.length; ) {
      const p = Math.abs(e) - Math.abs(u), v = t[f];
      He(v != null);
      const m = v - p, g = kr({
        panelConstraints: n,
        panelIndex: f,
        size: m
      });
      if (!dn(v, g) && (u += v - g, o[f] = g, u.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? f-- : f++;
    }
  }
  if (dn(u, 0)) return t;
  {
    const c = e < 0 ? i : s, f = t[c];
    He(f != null);
    const p = f + u, v = kr({
      panelConstraints: n,
      panelIndex: c,
      size: p
    });
    if (o[c] = v, !dn(v, p)) {
      let m = p - v, w = e < 0 ? i : s;
      for (; w >= 0 && w < n.length; ) {
        const C = o[w];
        He(C != null);
        const S = C + m, $ = kr({
          panelConstraints: n,
          panelIndex: w,
          size: S
        });
        if (dn(C, $) || (m -= $ - C, o[w] = $), dn(m, 0)) break;
        e > 0 ? w-- : w++;
      }
    }
  }
  const d = o.reduce((c, f) => f + c, 0);
  return dn(d, 100) ? o : t;
}
function vy(e, t, n) {
  const a = uy(e, t, n);
  return a != null ? [a, a + 1] : [-1, -1];
}
function CT(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function ST(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: vv(e),
    b: vv(t)
  };
  let a;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), a = e;
  He(a);
  const r = {
    a: pv(fv(n.a)),
    b: pv(fv(n.b))
  };
  if (r.a === r.b) {
    const o = a.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let i = o.length;
    for (; i--; ) {
      const u = o[i];
      if (u === s.a) return 1;
      if (u === s.b) return -1;
    }
  }
  return Math.sign(r.a - r.b);
}
const $T = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function kT(e) {
  const t = getComputedStyle(my(e)).display;
  return t === "flex" || t === "inline-flex";
}
function BT(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || kT(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || $T.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function fv(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (He(n), BT(n)) return n;
  }
  return null;
}
function pv(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function vv(e) {
  const t = [];
  for (; e; )
    t.push(e), e = my(e);
  return t;
}
function my(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
const hy = 1, gy = 2, yy = 4, by = 8;
function DT() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const PT = DT() === "coarse", Ia = [];
let Ui = !1;
const Da = /* @__PURE__ */ new Map(), ji = /* @__PURE__ */ new Map(), Ko = /* @__PURE__ */ new Set();
function MT(e, t, n, a, r, o) {
  const { ownerDocument: s } = t, i = {
    direction: n,
    element: t,
    hitAreaMargins: a,
    nonce: r,
    setResizeHandlerState: o
  }, u = Da.get(s) ?? 0;
  return Da.set(s, u + 1), Ko.add(i), Nl(), function() {
    ji.delete(e), Ko.delete(i);
    const c = Da.get(s) ?? 1;
    Da.set(s, c - 1), Nl(), wy(), c === 1 && Da.delete(s);
  };
}
function Ws(e) {
  const { target: t } = e, { x: n, y: a } = Hi(e);
  Ui = !0, lf({
    target: t,
    x: n,
    y: a
  }), Nl(), Ia.length > 0 && (uf("down", e), e.preventDefault());
}
function wa(e) {
  const { x: t, y: n } = Hi(e);
  if (!Ui) {
    const { target: a } = e;
    lf({
      target: a,
      x: t,
      y: n
    });
  }
  uf("move", e), _y(), Ia.length > 0 && e.preventDefault();
}
function xa(e) {
  const { target: t } = e, { x: n, y: a } = Hi(e);
  ji.clear(), Ui = !1, Ia.length > 0 && e.preventDefault(), uf("up", e), lf({
    target: t,
    x: n,
    y: a
  }), _y(), Nl();
}
function lf({ target: e, x: t, y: n }) {
  Ia.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), Ko.forEach((r) => {
    const { element: o, hitAreaMargins: s } = r, i = o.getBoundingClientRect(), { bottom: u, left: d, right: c, top: f } = i, p = PT ? s.coarse : s.fine;
    if (t >= d - p && t <= c + p && n >= f - p && n <= u + p) {
      if (a !== null && o !== a && !o.contains(a) && !a.contains(o) && ST(a, o) > 0) {
        let m = a, g = !1;
        for (; m && !m.contains(o); ) {
          if (CT(m.getBoundingClientRect(), i)) {
            g = !0;
            break;
          }
          m = m.parentElement;
        }
        if (g) return;
      }
      Ia.push(r);
    }
  });
}
function Vu(e, t) {
  ji.set(e, t);
}
function _y() {
  let e = !1, t = !1, n;
  Ia.forEach((r) => {
    const { direction: o, nonce: s } = r;
    o.value === "horizontal" ? e = !0 : t = !0, n = s.value;
  });
  let a = 0;
  ji.forEach((r) => {
    a |= r;
  }), e && t ? Fu("intersection", a, n) : e ? Fu("horizontal", a, n) : t ? Fu("vertical", a, n) : wy();
}
function Nl() {
  Da.forEach((e, t) => {
    const { body: n } = t;
    n.removeEventListener("contextmenu", xa), n.removeEventListener("mousedown", Ws), n.removeEventListener("mouseleave", wa), n.removeEventListener("mousemove", wa), n.removeEventListener("touchmove", wa), n.removeEventListener("touchstart", Ws);
  }), window.removeEventListener("mouseup", xa), window.removeEventListener("touchcancel", xa), window.removeEventListener("touchend", xa), Ko.size > 0 && (Ui ? (Ia.length > 0 && Da.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("contextmenu", xa), n.addEventListener("mouseleave", wa), n.addEventListener("mousemove", wa), n.addEventListener("touchmove", wa, { passive: !1 }));
  }), window.addEventListener("mouseup", xa), window.addEventListener("touchcancel", xa), window.addEventListener("touchend", xa)) : Da.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("mousedown", Ws), n.addEventListener("mousemove", wa), n.addEventListener("touchmove", wa, { passive: !1 }), n.addEventListener("touchstart", Ws));
  }));
}
function uf(e, t) {
  Ko.forEach((n) => {
    const { setResizeHandlerState: a } = n, r = Ia.includes(n);
    a(e, r, t);
  });
}
let Md = null, Pa = null;
function ET(e, t) {
  if (t) {
    const n = (t & hy) !== 0, a = (t & gy) !== 0, r = (t & yy) !== 0, o = (t & by) !== 0;
    if (n) return r ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (a) return r ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (r) return "s-resize";
    if (o) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function wy() {
  Pa !== null && (document.head.removeChild(Pa), Md = null, Pa = null);
}
function Fu(e, t, n) {
  const a = ET(e, t);
  Md !== a && (Md = a, Pa === null && (Pa = document.createElement("style"), n && (Pa.nonce = n), document.head.appendChild(Pa)), Pa.innerHTML = `*{cursor: ${a}!important;}`);
}
function qT({ defaultSize: e, dragState: t, layout: n, panelData: a, panelIndex: r, precision: o = 3 }) {
  const s = n[r];
  let i;
  return s == null ? i = e !== void 0 ? e.toPrecision(o) : "1" : a.length === 1 ? i = "1" : i = s.toPrecision(o), {
    flexBasis: 0,
    flexGrow: i,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: t !== null ? "none" : void 0
  };
}
function TT({ layout: e, panelConstraints: t }) {
  const n = [...e], a = n.reduce((o, s) => o + s, 0);
  if (n.length !== t.length) throw new Error(`Invalid ${t.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!dn(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${n.map((o) => `${o}%`).join(", ")}. Layout normalization will be applied.`);
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      He(s != null);
      const i = 100 / a * s;
      n[o] = i;
    }
  }
  let r = 0;
  for (let o = 0; o < t.length; o++) {
    const s = n[o];
    He(s != null);
    const i = kr({
      panelConstraints: t,
      panelIndex: o,
      size: s
    });
    s !== i && (r += s - i, n[o] = i);
  }
  if (!dn(r, 0)) for (let o = 0; o < t.length; o++) {
    const s = n[o];
    He(s != null);
    const i = s + r, u = kr({
      panelConstraints: t,
      panelIndex: o,
      size: i
    });
    if (s !== u && (r -= u - s, n[o] = u, dn(r, 0)))
      break;
  }
  return n;
}
function AT({ eagerValuesRef: e, groupId: t, layout: n, panelDataArray: a, panelGroupElement: r, setLayout: o }) {
  Ie((s) => {
    const i = r.value;
    if (!i) return;
    const u = Wo(t, i);
    for (let d = 0; d < a.length - 1; d++) {
      const { valueMax: c, valueMin: f, valueNow: p } = _T({
        layout: n.value,
        panelsArray: a,
        pivotIndices: [d, d + 1]
      }), v = u[d];
      if (v != null) {
        const m = a[d];
        He(m), v.setAttribute("aria-controls", m.id), v.setAttribute("aria-valuemax", `${Math.round(c)}`), v.setAttribute("aria-valuemin", `${Math.round(f)}`), v.setAttribute("aria-valuenow", p != null ? `${Math.round(p)}` : "");
      }
    }
    s(() => {
      u.forEach((d) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    });
  }), Ie((s) => {
    const i = r.value;
    if (!i) return;
    const u = e.value;
    He(u);
    const { panelDataArray: d } = u, c = iy(t, i);
    He(c != null, `No group found for id "${t}"`);
    const f = Wo(t, i);
    He(f);
    const p = f.map((v) => {
      const m = v.getAttribute("data-panel-resize-handle-id");
      He(m);
      const [g, w] = gT(t, m, d, i);
      if (g == null || w == null) return () => {
      };
      const C = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const $ = d.findIndex((B) => B.id === g);
              if ($ >= 0) {
                const B = d[$];
                He(B);
                const k = n.value[$], { collapsedSize: P = 0, collapsible: D, minSize: q = 0 } = B.constraints;
                if (k != null && D) {
                  const T = So({
                    delta: dn(k, P) ? q - P : P - k,
                    layout: n.value,
                    panelConstraints: d.map((M) => M.constraints),
                    pivotIndices: vy(t, m, i),
                    trigger: "keyboard"
                  });
                  n.value !== T && o(T);
                }
              }
              break;
            }
          }
      };
      return v.addEventListener("keydown", C), () => {
        v.removeEventListener("keydown", C);
      };
    });
    s(() => {
      p.forEach((v) => v());
    });
  });
}
function mv(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function xy(e) {
  return `reka:${e}`;
}
function Cy(e) {
  return e.map((t) => {
    const { constraints: n, id: a, idIsFromProps: r, order: o } = t;
    return r ? a : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function Sy(e, t) {
  try {
    const n = xy(e), a = t.getItem(n);
    if (a) {
      const r = JSON.parse(a);
      if (typeof r == "object" && r != null) return r;
    }
  } catch {
  }
  return null;
}
function IT(e, t, n) {
  const a = Sy(e, n) ?? {}, r = Cy(t);
  return a[r] ?? null;
}
function OT(e, t, n, a, r) {
  const o = xy(e), s = Cy(t), i = Sy(e, r) ?? {};
  i[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: a
  };
  try {
    r.setItem(o, JSON.stringify(i));
  } catch (u) {
    console.error(u);
  }
}
const RT = 100, $o = {
  getItem: (e) => (mv($o), $o.getItem(e)),
  setItem: (e, t) => {
    mv($o), $o.setItem(e, t);
  }
}, [$y, VT] = Se("PanelGroup");
var FT = /* @__PURE__ */ b({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => $o
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = {}, { direction: o } = Me(n), s = Ge(n.id, "reka-splitter-group"), i = yt(), { forwardRef: u, currentElement: d } = j(), c = I(null), f = I([]), p = I({}), v = I(/* @__PURE__ */ new Map()), m = I(0), g = E(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: c.value,
      id: s,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), w = I({
      layout: f.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), C = (H) => f.value = H;
    AT({
      eagerValuesRef: w,
      groupId: s,
      layout: f,
      panelDataArray: w.value.panelDataArray,
      setLayout: C,
      panelGroupElement: d
    }), Ie(() => {
      const { panelDataArray: H } = w.value, { autoSaveId: U } = n;
      if (U) {
        if (f.value.length === 0 || f.value.length !== H.length) return;
        let se = r[U];
        se || (se = xT(OT, RT), r[U] = se);
        const ee = [...H], de = new Map(v.value);
        se(U, ee, de, f.value, n.storage);
      }
    });
    function S(H, U) {
      const { panelDataArray: se } = w.value, ee = Q(se, H);
      return qT({
        defaultSize: U,
        dragState: c.value,
        layout: f.value,
        panelData: se,
        panelIndex: ee
      });
    }
    function $(H) {
      const { panelDataArray: U } = w.value;
      U.push(H), U.sort((se, ee) => {
        const de = se.order, pe = ee.order;
        return de == null && pe == null ? 0 : de == null ? -1 : pe == null ? 1 : de - pe;
      }), w.value.panelDataArrayChanged = !0;
    }
    ve(() => w.value.panelDataArrayChanged, () => {
      if (w.value.panelDataArrayChanged) {
        w.value.panelDataArrayChanged = !1;
        const { autoSaveId: H, storage: U } = g.value, { layout: se, panelDataArray: ee } = w.value;
        let de = null;
        if (H) {
          const _e = IT(H, ee, U);
          _e && (v.value = new Map(Object.entries(_e.expandToSizes)), de = _e.layout);
        }
        de === null && (de = wT({ panelDataArray: ee }));
        const pe = TT({
          layout: de,
          panelConstraints: ee.map((_e) => _e.constraints)
        });
        V0(se, pe) || (C(pe), w.value.layout = pe, a("layout", pe), vo(ee, pe, p.value));
      }
    });
    function B(H) {
      return function(se) {
        se.preventDefault();
        const ee = d.value;
        if (!ee) return () => null;
        const { direction: de, dragState: pe, id: _e, keyboardResizeBy: ge } = g.value, { layout: Te, panelDataArray: ce } = w.value, { initialLayout: R } = pe ?? {}, te = vy(_e, H, ee);
        let z = bT(se, H, de, pe, ge, ee);
        if (z === 0) return;
        const re = de === "horizontal";
        i.value === "rtl" && re && (z = -z);
        const ie = ce.map((xe) => xe.constraints), L = So({
          delta: z,
          layout: R ?? Te,
          panelConstraints: ie,
          pivotIndices: te,
          trigger: dy(se) ? "keyboard" : "mouse-or-touch"
        }), be = !js(Te, L);
        (cy(se) || fy(se)) && m.value !== z && (m.value = z, be ? Vu(H, 0) : re ? Vu(H, z < 0 ? hy : gy) : Vu(H, z < 0 ? yy : by)), be && (C(L), w.value.layout = L, a("layout", L), vo(ce, L, p.value));
      };
    }
    function k(H, U) {
      const { layout: se, panelDataArray: ee } = w.value, de = ee.map((R) => R.constraints), { panelSize: pe, pivotIndices: _e } = G(ee, H, se);
      He(pe != null);
      const Te = Q(ee, H) === ee.length - 1 ? pe - U : U - pe, ce = So({
        delta: Te,
        layout: se,
        panelConstraints: de,
        pivotIndices: _e,
        trigger: "imperative-api"
      });
      js(se, ce) || (C(ce), w.value.layout = ce, a("layout", ce), vo(ee, ce, p.value));
    }
    function P(H, U) {
      const { layout: se, panelDataArray: ee } = w.value, de = Q(ee, H);
      ee[de] = H, w.value.panelDataArrayChanged = !0;
      const { collapsedSize: pe = 0, collapsible: _e } = U, { collapsedSize: ge = 0, collapsible: Te, maxSize: ce = 100, minSize: R = 0 } = H.constraints, { panelSize: te } = G(ee, H, se);
      te !== null && (_e && Te && te === pe ? pe !== ge && k(H, ge) : te < R ? k(H, R) : te > ce && k(H, ce));
    }
    function D(H, U) {
      const { direction: se } = g.value, { layout: ee } = w.value;
      if (!d.value) return;
      const de = zi(H, d.value);
      He(de);
      const pe = py(se, U);
      c.value = {
        dragHandleId: H,
        dragHandleRect: de.getBoundingClientRect(),
        initialCursorPosition: pe,
        initialLayout: ee
      };
    }
    function q() {
      c.value = null;
    }
    function T(H) {
      const { panelDataArray: U } = w.value, se = Q(U, H);
      se >= 0 && (U.splice(se, 1), delete p.value[H.id], w.value.panelDataArrayChanged = !0);
    }
    function M(H) {
      const { layout: U, panelDataArray: se } = w.value;
      if (H.constraints.collapsible) {
        const ee = se.map((ge) => ge.constraints), { collapsedSize: de = 0, panelSize: pe, pivotIndices: _e } = G(se, H, U);
        if (He(pe != null, `Panel size not found for panel "${H.id}"`), pe !== de) {
          v.value.set(H.id, pe);
          const Te = Q(se, H) === se.length - 1 ? pe - de : de - pe, ce = So({
            delta: Te,
            layout: U,
            panelConstraints: ee,
            pivotIndices: _e,
            trigger: "imperative-api"
          });
          js(U, ce) || (C(ce), w.value.layout = ce, a("layout", ce), vo(se, ce, p.value));
        }
      }
    }
    function O(H) {
      const { layout: U, panelDataArray: se } = w.value;
      if (H.constraints.collapsible) {
        const ee = se.map((Te) => Te.constraints), { collapsedSize: de = 0, panelSize: pe, minSize: _e = 0, pivotIndices: ge } = G(se, H, U);
        if (pe === de) {
          const Te = v.value.get(H.id), ce = Te != null && Te >= _e ? Te : _e, te = Q(se, H) === se.length - 1 ? pe - ce : ce - pe, z = So({
            delta: te,
            layout: U,
            panelConstraints: ee,
            pivotIndices: ge,
            trigger: "imperative-api"
          });
          js(U, z) || (C(z), w.value.layout = z, a("layout", z), vo(se, z, p.value));
        }
      }
    }
    function F(H) {
      const { layout: U, panelDataArray: se } = w.value, { panelSize: ee } = G(se, H, U);
      return He(ee != null, `Panel size not found for panel "${H.id}"`), ee;
    }
    function J(H) {
      const { layout: U, panelDataArray: se } = w.value, { collapsedSize: ee = 0, collapsible: de, panelSize: pe } = G(se, H, U);
      return de ? pe === void 0 ? H.constraints.defaultSize === H.constraints.collapsedSize : pe === ee : !1;
    }
    function ne(H) {
      const { layout: U, panelDataArray: se } = w.value, { collapsedSize: ee = 0, collapsible: de, panelSize: pe } = G(se, H, U);
      return He(pe != null, `Panel size not found for panel "${H.id}"`), !de || pe > ee;
    }
    VT({
      direction: o,
      dragState: c.value,
      groupId: s,
      reevaluatePanelConstraints: P,
      registerPanel: $,
      registerResizeHandle: B,
      resizePanel: k,
      startDragging: D,
      stopDragging: q,
      unregisterPanel: T,
      panelGroupElement: d,
      collapsePanel: M,
      expandPanel: O,
      isPanelCollapsed: J,
      isPanelExpanded: ne,
      getPanelSize: F,
      getPanelStyle: S
    });
    function Q(H, U) {
      return H.findIndex((se) => se === U || se.id === U.id);
    }
    function G(H, U, se) {
      const ee = Q(H, U), pe = ee === H.length - 1 ? [ee - 1, ee] : [ee, ee + 1], _e = se[ee];
      return {
        ...U.constraints,
        panelSize: _e,
        pivotIndices: pe
      };
    }
    return (H, U) => (h(), x(l(X), {
      ref: l(u),
      as: H.as,
      "as-child": H.asChild,
      style: dt({
        display: "flex",
        flexDirection: l(o) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": l(o),
      "data-panel-group-id": l(s)
    }, {
      default: y(() => [_(H.$slots, "default", { layout: f.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), NT = FT, LT = /* @__PURE__ */ b({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, o = $y();
    if (o === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: s, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: f, groupId: p, reevaluatePanelConstraints: v, registerPanel: m, unregisterPanel: g } = o, w = Ge(a.id, "reka-splitter-panel"), C = E(() => ({
      callbacks: {
        onCollapse: () => r("collapse"),
        onExpand: () => r("expand"),
        onResize: (...q) => r("resize", ...q)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(sf)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: w,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    ve(() => C.value.constraints, (q, T) => {
      (T.collapsedSize !== q.collapsedSize || T.collapsible !== q.collapsible || T.maxSize !== q.maxSize || T.minSize !== q.minSize) && v(C.value, T);
    }, { deep: !0 }), Ce(() => {
      m(C.value);
    }), Qe(() => {
      g(C.value);
    });
    const S = E(() => d(C.value, a.defaultSize)), $ = E(() => c(C.value)), B = E(() => !$.value);
    function k() {
      s(C.value);
    }
    function P() {
      i(C.value);
    }
    function D(q) {
      f(C.value, q);
    }
    return t({
      collapse: k,
      expand: P,
      getSize() {
        return u(C.value);
      },
      resize: D,
      isCollapsed: $,
      isExpanded: B
    }), (q, T) => (h(), x(l(X), {
      id: l(w),
      style: dt(S.value),
      as: q.as,
      "as-child": q.asChild,
      "data-panel": "",
      "data-panel-collapsible": q.collapsible || void 0,
      "data-panel-group-id": l(p),
      "data-panel-id": l(w),
      "data-panel-size": Number.parseFloat(`${S.value.flexGrow}`).toFixed(1),
      "data-state": q.collapsible ? $.value ? "collapsed" : "expanded" : void 0
    }, {
      default: y(() => [_(q.$slots, "default", {
        isCollapsed: $.value,
        isExpanded: B.value,
        expand: P,
        collapse: k,
        resize: D
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), zH = LT;
function zT({ disabled: e, handleId: t, resizeHandler: n, panelGroupElement: a }) {
  Ie((r) => {
    const o = a.value;
    if (e.value || n.value === null || o === null) return;
    const s = zi(t, o);
    if (s == null) return;
    const i = (u) => {
      if (!u.defaultPrevented)
        switch (u.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            u.preventDefault(), n.value?.(u);
            break;
          }
          case "F6": {
            u.preventDefault();
            const d = s.getAttribute("data-panel-group-id");
            He(d);
            const c = Wo(d, o), f = uy(d, t, o);
            He(f !== null);
            const p = u.shiftKey ? f > 0 ? f - 1 : c.length - 1 : f + 1 < c.length ? f + 1 : 0;
            c[p].focus();
            break;
          }
        }
    };
    s.addEventListener("keydown", i), r(() => {
      s.removeEventListener("keydown", i);
    });
  });
}
var HT = /* @__PURE__ */ b({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), { disabled: s } = Me(n), i = $y();
    if (i === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: u, groupId: d, registerResizeHandle: c, startDragging: f, stopDragging: p, panelGroupElement: v } = i, m = Ge(n.id, "reka-splitter-resize-handle"), g = I("inactive"), w = I(!1), C = I(null), { nonce: S } = Me(n), $ = Ai(S);
    return ve(s, () => {
      ls && (s.value ? C.value = null : C.value = c(m));
    }, { immediate: !0 }), Ie((B) => {
      if (s.value || C.value === null) return;
      const k = o.value;
      if (!k) return;
      He(k);
      const P = (D, q, T) => {
        if (q) switch (D) {
          case "down": {
            g.value = "drag", f(m, T), a("dragging", !0);
            break;
          }
          case "move": {
            g.value !== "drag" && (g.value = "hover"), C.value?.(T);
            break;
          }
          case "up": {
            g.value = "hover", p(), a("dragging", !1);
            break;
          }
        }
        else g.value = "inactive";
      };
      B(MT(m, k, u, {
        coarse: n.hitAreaMargins?.coarse ?? 15,
        fine: n.hitAreaMargins?.fine ?? 5
      }, $, P));
    }), zT({
      disabled: s,
      resizeHandler: C,
      handleId: m,
      panelGroupElement: v
    }), (B, k) => (h(), x(l(X), {
      id: l(m),
      ref: l(r),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: B.as,
      "as-child": B.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: B.tabindex,
      "data-state": g.value,
      "data-disabled": l(s) ? "" : void 0,
      "data-orientation": l(u),
      "data-panel-group-id": l(d),
      "data-resize-handle-active": g.value === "drag" ? "pointer" : w.value ? "keyboard" : void 0,
      "data-resize-handle-state": g.value,
      "data-panel-resize-handle-enabled": !l(s),
      "data-panel-resize-handle-id": l(m),
      onBlur: k[0] || (k[0] = (P) => w.value = !1),
      onFocus: k[1] || (k[1] = (P) => w.value = !1)
    }, {
      default: y(() => [_(B.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), UT = HT;
const jT = {
  "aria-live": "polite",
  "aria-atomic": "true",
  role: "status",
  style: {
    transform: "translateX(-100%)",
    position: "absolute",
    pointerEvents: "none",
    opacity: 0,
    margin: 0
  }
}, [df, WT] = Se("StepperRoot");
var GT = /* @__PURE__ */ b({
  __name: "StepperRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: 1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    modelValue: {
      type: Number,
      required: !1
    },
    linear: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { dir: o, orientation: s, linear: i } = Me(a), u = yt(o), d = I(/* @__PURE__ */ new Set()), c = Ve(a, "modelValue", r, {
      defaultValue: a.defaultValue,
      passive: a.modelValue === void 0
    }), f = E(() => Array.from(d.value)), p = E(() => c.value === 1), v = E(() => c.value === f.value.length), m = E(() => d.value.size);
    function g(q) {
      q > m.value || q < 1 || d.value.size && f.value[q] && f.value[q].getAttribute("disabled") || i.value && q > (c.value ?? 1) + 1 || (c.value = q);
    }
    function w() {
      g((c.value ?? 1) + 1);
    }
    function C() {
      g((c.value ?? 1) - 1);
    }
    function S() {
      return (c.value ?? 1) < m.value;
    }
    function $() {
      return (c.value ?? 1) > 1;
    }
    const B = I(null), k = I(null), P = E(() => B.value ? B.value.getAttribute("disabled") === "" : !0), D = E(() => k.value ? k.value.getAttribute("disabled") === "" : !0);
    return ve(c, async () => {
      await Be(() => {
        B.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, k.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), ve(f, async () => {
      await Be(() => {
        B.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, k.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), WT({
      modelValue: c,
      changeModelValue: (q) => {
        c.value = q;
      },
      orientation: s,
      dir: u,
      linear: i,
      totalStepperItems: d
    }), t({
      goToStep: g,
      nextStep: w,
      prevStep: C,
      modelValue: c,
      totalSteps: m,
      isNextDisabled: P,
      isPrevDisabled: D,
      isFirstStep: p,
      isLastStep: v,
      hasNext: S,
      hasPrev: $
    }), j(), (q, T) => (h(), x(l(X), {
      role: "group",
      "aria-label": "progress",
      as: q.as,
      "as-child": q.asChild,
      "data-linear": l(i) ? "" : void 0,
      "data-orientation": q.orientation
    }, {
      default: y(() => [_(q.$slots, "default", {
        modelValue: l(c),
        totalSteps: d.value.size,
        isNextDisabled: P.value,
        isPrevDisabled: D.value,
        isFirstStep: p.value,
        isLastStep: v.value,
        goToStep: g,
        nextStep: w,
        prevStep: C,
        hasNext: S,
        hasPrev: $
      }), we("div", jT, " Step " + Ne(l(c)) + " of " + Ne(d.value.size), 1)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-linear",
      "data-orientation"
    ]));
  }
}), KT = GT;
const [Cs, YT] = Se("StepperItem");
var XT = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    completed: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { disabled: n, step: a, completed: r } = Me(t), { forwardRef: o } = j(), s = df(), i = Ge(void 0, "reka-stepper-item-title"), u = Ge(void 0, "reka-stepper-item-description"), d = E(() => r.value ? "completed" : s.modelValue.value === a.value ? "active" : s.modelValue.value > a.value ? "completed" : "inactive"), c = E(() => n.value ? !1 : s.linear.value ? a.value <= s.modelValue.value || a.value === s.modelValue.value + 1 : !0);
    return YT({
      titleId: i,
      descriptionId: u,
      state: d,
      disabled: n,
      step: a,
      isFocusable: c
    }), (f, p) => (h(), x(l(X), {
      ref: l(o),
      as: f.as,
      "as-child": f.asChild,
      "aria-current": d.value === "active" ? "true" : void 0,
      "data-state": d.value,
      disabled: l(n) || !c.value ? "" : void 0,
      "data-disabled": l(n) || !c.value ? "" : void 0,
      "data-orientation": l(s).orientation.value
    }, {
      default: y(() => [_(f.$slots, "default", { state: d.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-current",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), JT = XT, ZT = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Cs();
    return (a, r) => (h(), x(l(X), A(t, { id: l(n).descriptionId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), QT = ZT, eA = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Cs();
    return j(), (a, r) => (h(), x(l(X), oe(le(t)), {
      default: y(() => [_(a.$slots, "default", { step: l(n).step.value }, () => [Re(" Step " + Ne(l(n).step.value), 1)])]),
      _: 3
    }, 16));
  }
}), tA = eA, nA = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {
      type: String,
      required: !1
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = df(), a = Cs();
    return j(), (r, o) => (h(), x(l(rf), A(t, {
      decorative: "",
      orientation: l(n).orientation.value,
      "data-state": l(a).state.value
    }), {
      default: y(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["orientation", "data-state"]));
  }
}), aA = nA, rA = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h4"
    }
  },
  setup(e) {
    const t = e, n = Cs();
    return j(), (a, r) => (h(), x(l(X), A(t, { id: l(n).titleId }), {
      default: y(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), oA = rA, sA = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = df(), n = Cs(), a = ms(), r = E(() => Array.from(t.totalStepperItems.value));
    function o(d) {
      if (!n.disabled.value) {
        if (t.linear.value) {
          if ((n.step.value <= t.modelValue.value || n.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {
            t.changeModelValue(n.step.value);
            return;
          }
        } else if (d.ctrlKey === !1) {
          t.changeModelValue(n.step.value);
          return;
        }
        d.preventDefault();
      }
    }
    function s(d) {
      d.preventDefault(), !n.disabled.value && ((d.key === a.ENTER || d.key === a.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(n.step.value), [
        a.ARROW_LEFT,
        a.ARROW_RIGHT,
        a.ARROW_UP,
        a.ARROW_DOWN
      ].includes(d.key) && lr(d, ot(), void 0, {
        itemsArray: r.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: t.orientation.value,
        dir: t.dir.value
      }));
    }
    const { forwardRef: i, currentElement: u } = j();
    return Ce(() => {
      t.totalStepperItems.value.add(u.value);
    }), Qe(() => {
      t.totalStepperItems.value.delete(u.value);
    }), (d, c) => (h(), x(l(X), {
      ref: l(i),
      type: d.as === "button" ? "button" : void 0,
      as: d.as,
      "as-child": d.asChild,
      "data-state": l(n).state.value,
      disabled: l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-disabled": l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      tabindex: l(n).isFocusable.value ? 0 : -1,
      "aria-describedby": l(n).descriptionId,
      "aria-labelledby": l(n).titleId,
      onMousedown: Ye(o, ["left"]),
      onKeydown: Je(s, [
        "enter",
        "space",
        "left",
        "right",
        "up",
        "down"
      ])
    }, {
      default: y(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation",
      "tabindex",
      "aria-describedby",
      "aria-labelledby"
    ]));
  }
}), lA = sA;
const [iA, uA] = Se("SwitchRoot");
var dA = /* @__PURE__ */ b({
  __name: "SwitchRoot",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    value: {
      type: String,
      required: !1,
      default: "on"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = Me(n), o = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function s() {
      r.value || (o.value = !o.value);
    }
    const { forwardRef: i, currentElement: u } = j(), d = Rn(u), c = E(() => n.id && u.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return uA({
      modelValue: o,
      toggleCheck: s,
      disabled: r
    }), (f, p) => (h(), x(l(X), A(f.$attrs, {
      id: f.id,
      ref: l(i),
      role: "switch",
      type: f.as === "button" ? "button" : void 0,
      value: f.value,
      "aria-label": f.$attrs["aria-label"] || c.value,
      "aria-checked": l(o),
      "aria-required": f.required,
      "data-state": l(o) ? "checked" : "unchecked",
      "data-disabled": l(r) ? "" : void 0,
      "as-child": f.asChild,
      as: f.as,
      disabled: l(r),
      onClick: s,
      onKeydown: Je(Ye(s, ["prevent"]), ["enter"])
    }), {
      default: y(() => [_(f.$slots, "default", { modelValue: l(o) }), l(d) && f.name ? (h(), x(l(Vn), {
        key: 0,
        type: "checkbox",
        name: f.name,
        disabled: l(r),
        required: f.required,
        value: f.value,
        checked: !!l(o)
      }, null, 8, [
        "name",
        "disabled",
        "required",
        "value",
        "checked"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "value",
      "aria-label",
      "aria-checked",
      "aria-required",
      "data-state",
      "data-disabled",
      "as-child",
      "as",
      "disabled",
      "onKeydown"
    ]));
  }
}), cA = dA, fA = /* @__PURE__ */ b({
  __name: "SwitchThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = iA();
    return j(), (n, a) => (h(), x(l(X), {
      "data-state": l(t).modelValue?.value ? "checked" : "unchecked",
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "as-child": n.asChild,
      as: n.as
    }, {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "data-disabled",
      "as-child",
      "as"
    ]));
  }
}), pA = fA;
const [cf, vA] = Se("TabsRoot");
var mA = /* @__PURE__ */ b({
  __name: "TabsRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    activationMode: {
      type: String,
      required: !1,
      default: "automatic"
    },
    modelValue: {
      type: null,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { orientation: r, unmountOnHide: o, dir: s } = Me(n), i = yt(s);
    j();
    const u = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), d = I();
    return vA({
      modelValue: u,
      changeModelValue: (c) => {
        u.value = c;
      },
      orientation: r,
      dir: i,
      unmountOnHide: o,
      activationMode: n.activationMode,
      baseId: Ge(void 0, "reka-tabs"),
      tabsList: d
    }), (c, f) => (h(), x(l(X), {
      dir: l(i),
      "data-orientation": l(r),
      "as-child": c.asChild,
      as: c.as
    }, {
      default: y(() => [_(c.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, [
      "dir",
      "data-orientation",
      "as-child",
      "as"
    ]));
  }
}), hA = mA;
function ky(e, t) {
  return `${e}-trigger-${t}`;
}
function By(e, t) {
  return `${e}-content-${t}`;
}
var gA = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = cf(), r = E(() => ky(a.baseId, t.value)), o = E(() => By(a.baseId, t.value)), s = E(() => t.value === a.modelValue.value), i = I(s.value);
    return Ce(() => {
      requestAnimationFrame(() => {
        i.value = !1;
      });
    }), (u, d) => (h(), x(l($t), {
      present: u.forceMount || s.value,
      "force-mount": ""
    }, {
      default: y(({ present: c }) => [N(l(X), {
        id: o.value,
        ref: l(n),
        "as-child": u.asChild,
        as: u.as,
        role: "tabpanel",
        "data-state": s.value ? "active" : "inactive",
        "data-orientation": l(a).orientation.value,
        "aria-labelledby": r.value,
        hidden: !c,
        tabindex: "0",
        style: dt({ animationDuration: i.value ? "0s" : void 0 })
      }, {
        default: y(() => [!l(a).unmountOnHide.value || c ? _(u.$slots, "default", { key: 0 }) : Ee("v-if", !0)]),
        _: 2
      }, 1032, [
        "id",
        "as-child",
        "as",
        "data-state",
        "data-orientation",
        "aria-labelledby",
        "hidden",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), yA = gA, bA = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { loop: n } = Me(t), { forwardRef: a, currentElement: r } = j(), o = cf();
    return o.tabsList = r, (s, i) => (h(), x(l(ys), {
      "as-child": "",
      orientation: l(o).orientation.value,
      dir: l(o).dir.value,
      loop: l(n)
    }, {
      default: y(() => [N(l(X), {
        ref: l(a),
        role: "tablist",
        "as-child": s.asChild,
        as: s.as,
        "aria-orientation": l(o).orientation.value
      }, {
        default: y(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "aria-orientation"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), _A = bA, wA = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = cf(), r = E(() => ky(a.baseId, t.value)), o = E(() => By(a.baseId, t.value)), s = E(() => t.value === a.modelValue.value);
    return (i, u) => (h(), x(l(bs), {
      "as-child": "",
      focusable: !i.disabled,
      active: s.value
    }, {
      default: y(() => [N(l(X), {
        id: r.value,
        ref: l(n),
        role: "tab",
        type: i.as === "button" ? "button" : void 0,
        as: i.as,
        "as-child": i.asChild,
        "aria-selected": s.value ? "true" : "false",
        "aria-controls": o.value,
        "data-state": s.value ? "active" : "inactive",
        disabled: i.disabled,
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": l(a).orientation.value,
        onMousedown: u[0] || (u[0] = Ye((d) => {
          !i.disabled && d.ctrlKey === !1 ? l(a).changeModelValue(i.value) : d.preventDefault();
        }, ["left"])),
        onKeydown: u[1] || (u[1] = Je((d) => l(a).changeModelValue(i.value), ["enter", "space"])),
        onFocus: u[2] || (u[2] = () => {
          const d = l(a).activationMode !== "manual";
          !s.value && !i.disabled && d && l(a).changeModelValue(i.value);
        })
      }, {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as",
        "as-child",
        "aria-selected",
        "aria-controls",
        "data-state",
        "disabled",
        "data-disabled",
        "data-orientation"
      ])]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), xA = wA;
const [ff, CA] = Se("TagsInputRoot");
var SA = /* @__PURE__ */ b({
  __name: "TagsInputRoot",
  props: {
    modelValue: {
      type: [Array, null],
      required: !1
    },
    defaultValue: {
      type: Array,
      required: !1,
      default: () => []
    },
    addOnPaste: {
      type: Boolean,
      required: !1
    },
    addOnTab: {
      type: Boolean,
      required: !1
    },
    addOnBlur: {
      type: Boolean,
      required: !1
    },
    duplicate: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    delimiter: {
      type: null,
      required: !1,
      default: ","
    },
    dir: {
      type: String,
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: 0
    },
    id: {
      type: String,
      required: !1
    },
    convertValue: {
      type: Function,
      required: !1
    },
    displayValue: {
      type: Function,
      required: !1,
      default: (e) => e.toString()
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "invalid",
    "addTag",
    "removeTag"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { addOnPaste: r, disabled: o, delimiter: s, max: i, id: u, dir: d, addOnBlur: c, addOnTab: f } = Me(n), p = yt(d), v = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: !0,
      deep: !0
    }), { forwardRef: m, currentElement: g } = j(), { focused: w } = vw(g), C = Rn(g), { getItems: S, CollectionSlot: $ } = st({ isProvider: !0 }), B = I(), k = I(!1), P = E(() => Array.isArray(v.value) ? [...v.value] : []);
    function D(q) {
      if (q !== -1) {
        const T = S().filter((M) => M.ref.dataset.disabled !== "");
        v.value = v.value.filter((M, O) => O !== q), a("removeTag", T[q].value);
      }
    }
    return CA({
      modelValue: v,
      onAddValue: (q) => {
        const T = [...P.value], M = T.length > 0 && typeof T[0] == "object", O = T.length > 0 && typeof n.defaultValue[0] == "object";
        if ((M || O) && typeof n.convertValue != "function") throw new Error("You must provide a `convertValue` function when using objects as values.");
        const F = n.convertValue ? n.convertValue(q) : q;
        if (T.length >= i.value && i.value)
          return a("invalid", F), !1;
        if (n.duplicate)
          return v.value = [...T, F], a("addTag", F), !0;
        if (T.includes(F))
          k.value = !0;
        else return v.value = [...T, F], a("addTag", F), !0;
        return a("invalid", F), !1;
      },
      onRemoveValue: D,
      onInputKeydown: (q) => {
        const T = q.target, M = S().map((F) => F.ref).filter((F) => F.dataset.disabled !== "");
        if (!M.length) return;
        const O = M.at(-1);
        switch (q.key) {
          case "Delete":
          case "Backspace": {
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (B.value) {
              const F = M.findIndex((J) => J === B.value);
              D(F), B.value = B.value === O ? M.at(F - 1) : M.at(F + 1), q.preventDefault();
            } else q.key === "Backspace" && (B.value = O, q.preventDefault());
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const F = q.key === "ArrowRight" && p.value === "ltr" || q.key === "ArrowLeft" && p.value === "rtl", J = !F;
            if (T.selectionStart !== 0 || T.selectionEnd !== 0) break;
            if (J && !B.value)
              B.value = O, q.preventDefault();
            else if (F && O && B.value === O)
              B.value = void 0, q.preventDefault();
            else if (B.value) {
              const ne = lr(q, B.value, void 0, {
                itemsArray: M,
                loop: !1,
                dir: p.value
              });
              ne && (B.value = ne), q.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            B.value && q.preventDefault();
            break;
          }
          default:
            B.value = void 0;
        }
      },
      selectedElement: B,
      isInvalidInput: k,
      addOnPaste: r,
      addOnBlur: c,
      addOnTab: f,
      dir: p,
      disabled: o,
      delimiter: s,
      max: i,
      id: u,
      displayValue: n.displayValue
    }), (q, T) => (h(), x(l($), null, {
      default: y(() => [N(l(X), {
        ref: l(m),
        dir: l(p),
        as: q.as,
        "as-child": q.asChild,
        "data-invalid": k.value ? "" : void 0,
        "data-disabled": l(o) ? "" : void 0,
        "data-focused": l(w) ? "" : void 0
      }, {
        default: y(() => [_(q.$slots, "default", { modelValue: l(v) }), l(C) && q.name ? (h(), x(l(Vn), {
          key: 0,
          name: q.name,
          value: l(v),
          required: q.required,
          disabled: l(o)
        }, null, 8, [
          "name",
          "value",
          "required",
          "disabled"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 8, [
        "dir",
        "as",
        "as-child",
        "data-invalid",
        "data-disabled",
        "data-focused"
      ])]),
      _: 3
    }));
  }
}), $A = SA, kA = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    maxLength: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = ff(), { forwardRef: a, currentElement: r } = j();
    function o(v) {
      if (n.selectedElement.value = void 0, !n.addOnBlur.value) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = "");
    }
    function s(v) {
      n.addOnTab.value && c(v);
    }
    const i = I(!1);
    function u() {
      i.value = !0;
    }
    function d() {
      Be(() => {
        i.value = !1;
      });
    }
    async function c(v) {
      if (i.value || (await Be(), v.defaultPrevented)) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = ""), v.preventDefault();
    }
    function f(v) {
      if (n.isInvalidInput.value = !1, v.data === null) return;
      const m = n.delimiter.value;
      if (m === v.data || m instanceof RegExp && m.test(v.data)) {
        const w = v.target;
        if (w.value = w.value.replace(m, ""), w.value.trim() === "") {
          w.value = "";
          return;
        }
        n.onAddValue(w.value) && (w.value = "");
      }
    }
    function p(v) {
      if (n.addOnPaste.value) {
        v.preventDefault();
        const m = v.clipboardData;
        if (!m) return;
        const g = m.getData("text");
        n.delimiter.value ? g.split(n.delimiter.value).forEach((C) => {
          n.onAddValue(C);
        }) : n.onAddValue(g);
      }
    }
    return Ce(() => {
      const v = r.value.nodeName === "INPUT" ? r.value : r.value.querySelector("input");
      v && setTimeout(() => {
        t.autoFocus && v?.focus();
      }, 1);
    }), (v, m) => (h(), x(l(X), {
      id: l(n).id?.value,
      ref: l(a),
      type: "text",
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      as: v.as,
      "as-child": v.asChild,
      maxlength: v.maxLength,
      placeholder: v.placeholder,
      disabled: l(n).disabled.value,
      "data-invalid": l(n).isInvalidInput.value ? "" : void 0,
      onInput: f,
      onKeydown: [
        Je(c, ["enter"]),
        Je(s, ["tab"]),
        l(n).onInputKeydown
      ],
      onBlur: o,
      onCompositionstart: u,
      onCompositionend: d,
      onPaste: p
    }, {
      default: y(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "maxlength",
      "placeholder",
      "disabled",
      "data-invalid",
      "onKeydown"
    ]));
  }
}), BA = kA;
const [Dy, DA] = Se("TagsInputItem");
var PA = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { value: n } = Me(t), a = ff(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = E(() => a.selectedElement.value === o.value), u = E(() => t.disabled || a.disabled.value), d = DA({
      value: n,
      isSelected: i,
      disabled: u,
      textId: "",
      displayValue: E(() => a.displayValue(n.value))
    });
    return (c, f) => (h(), x(l(s), { value: l(n) }, {
      default: y(() => [N(l(X), {
        ref: l(r),
        as: c.as,
        "as-child": c.asChild,
        "aria-labelledby": l(d).textId,
        "aria-current": i.value,
        "data-disabled": u.value ? "" : void 0,
        "data-state": i.value ? "active" : "inactive"
      }, {
        default: y(() => [_(c.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-labelledby",
        "aria-current",
        "data-disabled",
        "data-state"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), MA = PA, EA = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = ff(), a = Dy(), r = E(() => a.disabled?.value || n.disabled.value);
    function o() {
      if (r.value) return;
      const s = n.modelValue.value.findIndex((i) => qn(i, a.value.value));
      n.onRemoveValue(s);
    }
    return (s, i) => (h(), x(l(X), A({ tabindex: "-1" }, t, {
      "aria-labelledby": l(a).textId,
      "aria-current": l(a).isSelected.value,
      "data-state": l(a).isSelected.value ? "active" : "inactive",
      "data-disabled": r.value ? "" : void 0,
      type: s.as === "button" ? "button" : void 0,
      onClick: o
    }), {
      default: y(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-labelledby",
      "aria-current",
      "data-state",
      "data-disabled",
      "type"
    ]));
  }
}), qA = EA, TA = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Dy();
    return j(), n.textId ||= Ge(void 0, "reka-tags-input-item-text"), (a, r) => (h(), x(l(X), A(t, { id: l(n).textId }), {
      default: y(() => [_(a.$slots, "default", {}, () => [Re(Ne(l(n).displayValue.value), 1)])]),
      _: 3
    }, 16, ["id"]));
  }
}), AA = TA;
const [Py, IA] = Se("ToggleGroupRoot");
var OA = /* @__PURE__ */ b({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: {
      type: Boolean,
      required: !1,
      default: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { loop: r, rovingFocus: o, disabled: s, dir: i } = Me(n), u = yt(i), { forwardRef: d, currentElement: c } = j(), { modelValue: f, changeModelValue: p, isSingle: v } = eg(n, a), m = Rn(c);
    return IA({
      isSingle: v,
      modelValue: f,
      changeModelValue: p,
      dir: u,
      orientation: n.orientation,
      loop: r,
      rovingFocus: o,
      disabled: s
    }), (g, w) => (h(), x(Pt(l(o) ? l(ys) : l(X)), {
      "as-child": "",
      orientation: l(o) ? g.orientation : void 0,
      dir: l(u),
      loop: l(o) ? l(r) : void 0
    }, {
      default: y(() => [N(l(X), {
        ref: l(d),
        role: "group",
        "as-child": g.asChild,
        as: g.as
      }, {
        default: y(() => [_(g.$slots, "default", { modelValue: l(f) }), l(m) && g.name ? (h(), x(Vn, {
          key: 0,
          name: g.name,
          required: g.required,
          value: l(f)
        }, null, 8, [
          "name",
          "required",
          "value"
        ])) : Ee("v-if", !0)]),
        _: 3
      }, 8, ["as-child", "as"])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), RA = OA, VA = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = Py(null), i = Ve(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function u() {
      i.value = !i.value;
    }
    const d = E(() => i.value ? "on" : "off"), c = Rn(o);
    return (f, p) => (h(), x(l(X), {
      ref: l(r),
      type: f.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: f.as,
      "aria-pressed": l(i),
      "data-state": d.value,
      "data-disabled": f.disabled ? "" : void 0,
      disabled: f.disabled,
      onClick: u
    }, {
      default: y(() => [_(f.$slots, "default", {
        modelValue: l(i),
        disabled: f.disabled,
        pressed: l(i),
        state: d.value
      }), l(c) && f.name && !l(s) ? (h(), x(Vn, {
        key: 0,
        type: "checkbox",
        name: f.name,
        value: l(i),
        required: f.required
      }, null, 8, [
        "name",
        "value",
        "required"
      ])) : Ee("v-if", !0)]),
      _: 3
    }, 8, [
      "type",
      "as-child",
      "as",
      "aria-pressed",
      "data-state",
      "data-disabled",
      "disabled"
    ]));
  }
}), My = VA, FA = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Py(), a = E(() => n.disabled?.value || t.disabled), r = E(() => $l(n.modelValue.value, t.value)), { forwardRef: o } = j();
    return (s, i) => (h(), x(Pt(l(n).rovingFocus.value ? l(bs) : l(X)), A({ "as-child": "" }, l(n).rovingFocus.value ? {
      focusable: !a.value,
      active: r.value
    } : {}), {
      default: y(() => [N(l(My), A(t, {
        ref: l(o),
        disabled: a.value,
        "model-value": r.value,
        "onUpdate:modelValue": i[0] || (i[0] = (u) => l(n).changeModelValue(s.value))
      }), {
        default: y((u) => [_(s.$slots, "default", oe(le(u)))]),
        _: 3
      }, 16, ["disabled", "model-value"])]),
      _: 3
    }, 16));
  }
}), NA = FA, LA = /* @__PURE__ */ b({
  __name: "TooltipArrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), x(l(q$), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zA = LA;
const [pf, HA] = Se("TooltipProvider");
var UA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: {
      type: Number,
      required: !1,
      default: 700
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(e) {
    const t = e, { delayDuration: n, skipDelayDuration: a, disableHoverableContent: r, disableClosingTrigger: o, ignoreNonKeyboardFocus: s, disabled: i } = Me(t);
    j();
    const u = I(!0), d = I(!1), { start: c, stop: f } = hh(() => {
      u.value = !0;
    }, a, { immediate: !1 });
    return HA({
      isOpenDelayed: u,
      delayDuration: n,
      onOpen() {
        f(), u.value = !1;
      },
      onClose() {
        c();
      },
      isPointerInTransitRef: d,
      disableHoverableContent: r,
      disableClosingTrigger: o,
      disabled: i,
      ignoreNonKeyboardFocus: s
    }), (p, v) => _(p.$slots, "default");
  }
}), vf = UA;
const Ey = "tooltip.open", [Wi, jA] = Se("TooltipRoot");
var WA = /* @__PURE__ */ b({
  __name: "TooltipRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: void 0
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = pf(), o = E(() => n.disableHoverableContent ?? r.disableHoverableContent.value), s = E(() => n.disableClosingTrigger ?? r.disableClosingTrigger.value), i = E(() => n.disabled ?? r.disabled.value), u = E(() => n.delayDuration ?? r.delayDuration.value), d = E(() => n.ignoreNonKeyboardFocus ?? r.ignoreNonKeyboardFocus.value), c = Ve(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    ve(c, ($) => {
      r.onClose && ($ ? (r.onOpen(), document.dispatchEvent(new CustomEvent(Ey))) : r.onClose());
    });
    const f = I(!1), p = I(), v = E(() => c.value ? f.value ? "delayed-open" : "instant-open" : "closed"), { start: m, stop: g } = hh(() => {
      f.value = !0, c.value = !0;
    }, u, { immediate: !1 });
    function w() {
      g(), f.value = !1, c.value = !0;
    }
    function C() {
      g(), c.value = !1;
    }
    function S() {
      m();
    }
    return jA({
      contentId: "",
      open: c,
      stateAttribute: v,
      trigger: p,
      onTriggerChange($) {
        p.value = $;
      },
      onTriggerEnter() {
        r.isOpenDelayed.value ? S() : w();
      },
      onTriggerLeave() {
        o.value ? C() : g();
      },
      onOpen: w,
      onClose: C,
      disableHoverableContent: o,
      disableClosingTrigger: s,
      disabled: i,
      ignoreNonKeyboardFocus: d
    }), ($, B) => (h(), x(l(ir), null, {
      default: y(() => [_($.$slots, "default", { open: l(c) })]),
      _: 3
    }));
  }
}), GA = WA, KA = /* @__PURE__ */ b({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    align: {
      type: null,
      required: !1,
      default: "center"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    arrowPadding: {
      type: Number,
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Wi(), { forwardRef: o, currentElement: s } = j(), i = E(() => n.ariaLabel || s.value?.textContent), u = E(() => {
      const { ariaLabel: d, ...c } = n;
      return c;
    });
    return Ce(() => {
      zt(window, "scroll", (d) => {
        d.target?.contains(r.trigger.value) && r.onClose();
      }), zt(window, Ey, r.onClose);
    }), (d, c) => (h(), x(l(Fa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: c[0] || (c[0] = (f) => a("escapeKeyDown", f)),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        l(r).disableClosingTrigger.value && l(r).trigger.value?.contains(f.target) && f.preventDefault(), a("pointerDownOutside", f);
      }),
      onFocusOutside: c[2] || (c[2] = Ye(() => {
      }, ["prevent"])),
      onDismiss: c[3] || (c[3] = (f) => l(r).onClose())
    }, {
      default: y(() => [N(l(Qr), A({
        ref: l(o),
        "data-state": l(r).stateAttribute.value
      }, {
        ...d.$attrs,
        ...u.value
      }, { style: {
        "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
        "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
        "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: y(() => [_(d.$slots, "default"), N(l(Di), {
          id: l(r).contentId,
          role: "tooltip"
        }, {
          default: y(() => [Re(Ne(i.value), 1)]),
          _: 1
        }, 8, ["id"])]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }));
  }
}), qy = KA, YA = /* @__PURE__ */ b({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  setup(e) {
    const n = he(e), { forwardRef: a, currentElement: r } = j(), { trigger: o, onClose: s } = Wi(), i = pf(), { isPointerInTransit: u, onPointerExit: d } = Wh(o, r);
    return i.isPointerInTransitRef = u, d(() => {
      s();
    }), (c, f) => (h(), x(qy, A({ ref: l(a) }, l(n)), {
      default: y(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), XA = YA, JA = /* @__PURE__ */ b({
  __name: "TooltipContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Wi(), o = me(n, a), { forwardRef: s } = j();
    return (i, u) => (h(), x(l($t), { present: i.forceMount || l(r).open.value }, {
      default: y(() => [(h(), x(Pt(l(r).disableHoverableContent.value ? qy : XA), A({ ref: l(s) }, l(o)), {
        default: y(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), ZA = JA, QA = /* @__PURE__ */ b({
  __name: "TooltipPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Na), oe(le(t)), {
      default: y(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), e2 = QA, t2 = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Wi(), a = pf();
    n.contentId ||= Ge(void 0, "reka-tooltip-content");
    const { forwardRef: r, currentElement: o } = j(), s = I(!1), i = I(!1), u = E(() => n.disabled.value ? {} : {
      click: g,
      focus: v,
      pointermove: f,
      pointerleave: p,
      pointerdown: c,
      blur: m
    });
    Ce(() => {
      n.onTriggerChange(o.value);
    });
    function d() {
      setTimeout(() => {
        s.value = !1;
      }, 1);
    }
    function c() {
      n.open && !n.disableClosingTrigger.value && n.onClose(), s.value = !0, document.addEventListener("pointerup", d, { once: !0 });
    }
    function f(w) {
      w.pointerType !== "touch" && !i.value && !a.isPointerInTransitRef.value && (n.onTriggerEnter(), i.value = !0);
    }
    function p() {
      n.onTriggerLeave(), i.value = !1;
    }
    function v(w) {
      s.value || n.ignoreNonKeyboardFocus.value && !w.target.matches?.(":focus-visible") || n.onOpen();
    }
    function m() {
      n.onClose();
    }
    function g() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (w, C) => (h(), x(l(ur), {
      "as-child": "",
      reference: w.reference
    }, {
      default: y(() => [N(l(X), A({
        ref: l(r),
        "aria-describedby": l(n).open.value ? l(n).contentId : void 0,
        "data-state": l(n).stateAttribute.value,
        as: w.as,
        "as-child": t.asChild,
        "data-grace-area-trigger": ""
      }, D0(u.value)), {
        default: y(() => [_(w.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-describedby",
        "data-state",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), n2 = t2;
function Ty(e) {
  var t, n, a = "";
  if (typeof e == "string" || typeof e == "number") a += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = Ty(e[t])) && (a && (a += " "), a += n);
  } else for (n in e) e[n] && (a && (a += " "), a += n);
  return a;
}
function Ay() {
  for (var e, t, n = 0, a = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = Ty(e)) && (a && (a += " "), a += t);
  return a;
}
const a2 = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let a = 0; a < e.length; a++)
    n[a] = e[a];
  for (let a = 0; a < t.length; a++)
    n[e.length + a] = t[a];
  return n;
}, r2 = (e, t) => ({
  classGroupId: e,
  validator: t
}), Iy = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), Ll = "-", hv = [], o2 = "arbitrary..", s2 = (e) => {
  const t = i2(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: a
  } = e;
  return {
    getClassGroupId: (s) => {
      if (s.startsWith("[") && s.endsWith("]"))
        return l2(s);
      const i = s.split(Ll), u = i[0] === "" && i.length > 1 ? 1 : 0;
      return Oy(i, u, t);
    },
    getConflictingClassGroupIds: (s, i) => {
      if (i) {
        const u = a[s], d = n[s];
        return u ? d ? a2(d, u) : u : d || hv;
      }
      return n[s] || hv;
    }
  };
}, Oy = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const r = e[t], o = n.nextPart.get(r);
  if (o) {
    const d = Oy(e, t + 1, o);
    if (d) return d;
  }
  const s = n.validators;
  if (s === null)
    return;
  const i = t === 0 ? e.join(Ll) : e.slice(t).join(Ll), u = s.length;
  for (let d = 0; d < u; d++) {
    const c = s[d];
    if (c.validator(i))
      return c.classGroupId;
  }
}, l2 = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), a = t.slice(0, n);
  return a ? o2 + a : void 0;
})(), i2 = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return u2(n, t);
}, u2 = (e, t) => {
  const n = Iy();
  for (const a in e) {
    const r = e[a];
    mf(r, n, a, t);
  }
  return n;
}, mf = (e, t, n, a) => {
  const r = e.length;
  for (let o = 0; o < r; o++) {
    const s = e[o];
    d2(s, t, n, a);
  }
}, d2 = (e, t, n, a) => {
  if (typeof e == "string") {
    c2(e, t, n);
    return;
  }
  if (typeof e == "function") {
    f2(e, t, n, a);
    return;
  }
  p2(e, t, n, a);
}, c2 = (e, t, n) => {
  const a = e === "" ? t : Ry(t, e);
  a.classGroupId = n;
}, f2 = (e, t, n, a) => {
  if (v2(e)) {
    mf(e(a), t, n, a);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(r2(n, e));
}, p2 = (e, t, n, a) => {
  const r = Object.entries(e), o = r.length;
  for (let s = 0; s < o; s++) {
    const [i, u] = r[s];
    mf(u, Ry(t, i), n, a);
  }
}, Ry = (e, t) => {
  let n = e;
  const a = t.split(Ll), r = a.length;
  for (let o = 0; o < r; o++) {
    const s = a[o];
    let i = n.nextPart.get(s);
    i || (i = Iy(), n.nextPart.set(s, i)), n = i;
  }
  return n;
}, v2 = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, m2 = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
  const r = (o, s) => {
    n[o] = s, t++, t > e && (t = 0, a = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let s = n[o];
      if (s !== void 0)
        return s;
      if ((s = a[o]) !== void 0)
        return r(o, s), s;
    },
    set(o, s) {
      o in n ? n[o] = s : r(o, s);
    }
  };
}, Ed = "!", gv = ":", h2 = [], yv = (e, t, n, a, r) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: a,
  isExternal: r
}), g2 = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let a = (r) => {
    const o = [];
    let s = 0, i = 0, u = 0, d;
    const c = r.length;
    for (let g = 0; g < c; g++) {
      const w = r[g];
      if (s === 0 && i === 0) {
        if (w === gv) {
          o.push(r.slice(u, g)), u = g + 1;
          continue;
        }
        if (w === "/") {
          d = g;
          continue;
        }
      }
      w === "[" ? s++ : w === "]" ? s-- : w === "(" ? i++ : w === ")" && i--;
    }
    const f = o.length === 0 ? r : r.slice(u);
    let p = f, v = !1;
    f.endsWith(Ed) ? (p = f.slice(0, -1), v = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      f.startsWith(Ed) && (p = f.slice(1), v = !0)
    );
    const m = d && d > u ? d - u : void 0;
    return yv(o, v, p, m);
  };
  if (t) {
    const r = t + gv, o = a;
    a = (s) => s.startsWith(r) ? o(s.slice(r.length)) : yv(h2, !1, s, void 0, !0);
  }
  if (n) {
    const r = a;
    a = (o) => n({
      className: o,
      parseClassName: r
    });
  }
  return a;
}, y2 = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, a) => {
    t.set(n, 1e6 + a);
  }), (n) => {
    const a = [];
    let r = [];
    for (let o = 0; o < n.length; o++) {
      const s = n[o], i = s[0] === "[", u = t.has(s);
      i || u ? (r.length > 0 && (r.sort(), a.push(...r), r = []), a.push(s)) : r.push(s);
    }
    return r.length > 0 && (r.sort(), a.push(...r)), a;
  };
}, b2 = (e) => ({
  cache: m2(e.cacheSize),
  parseClassName: g2(e),
  sortModifiers: y2(e),
  ...s2(e)
}), _2 = /\s+/, w2 = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: a,
    getConflictingClassGroupIds: r,
    sortModifiers: o
  } = t, s = [], i = e.trim().split(_2);
  let u = "";
  for (let d = i.length - 1; d >= 0; d -= 1) {
    const c = i[d], {
      isExternal: f,
      modifiers: p,
      hasImportantModifier: v,
      baseClassName: m,
      maybePostfixModifierPosition: g
    } = n(c);
    if (f) {
      u = c + (u.length > 0 ? " " + u : u);
      continue;
    }
    let w = !!g, C = a(w ? m.substring(0, g) : m);
    if (!C) {
      if (!w) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      if (C = a(m), !C) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      w = !1;
    }
    const S = p.length === 0 ? "" : p.length === 1 ? p[0] : o(p).join(":"), $ = v ? S + Ed : S, B = $ + C;
    if (s.indexOf(B) > -1)
      continue;
    s.push(B);
    const k = r(C, w);
    for (let P = 0; P < k.length; ++P) {
      const D = k[P];
      s.push($ + D);
    }
    u = c + (u.length > 0 ? " " + u : u);
  }
  return u;
}, x2 = (...e) => {
  let t = 0, n, a, r = "";
  for (; t < e.length; )
    (n = e[t++]) && (a = Vy(n)) && (r && (r += " "), r += a);
  return r;
}, Vy = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let a = 0; a < e.length; a++)
    e[a] && (t = Vy(e[a])) && (n && (n += " "), n += t);
  return n;
}, C2 = (e, ...t) => {
  let n, a, r, o;
  const s = (u) => {
    const d = t.reduce((c, f) => f(c), e());
    return n = b2(d), a = n.cache.get, r = n.cache.set, o = i, i(u);
  }, i = (u) => {
    const d = a(u);
    if (d)
      return d;
    const c = w2(u, n);
    return r(u, c), c;
  };
  return o = s, (...u) => o(x2(...u));
}, S2 = [], Dt = (e) => {
  const t = (n) => n[e] || S2;
  return t.isThemeGetter = !0, t;
}, Fy = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, Ny = /^\((?:(\w[\w-]*):)?(.+)\)$/i, $2 = /^\d+\/\d+$/, k2 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, B2 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, D2 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, P2 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, M2 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Cr = (e) => $2.test(e), ze = (e) => !!e && !Number.isNaN(Number(e)), Ca = (e) => !!e && Number.isInteger(Number(e)), Nu = (e) => e.endsWith("%") && ze(e.slice(0, -1)), ta = (e) => k2.test(e), E2 = () => !0, q2 = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  B2.test(e) && !D2.test(e)
), Ly = () => !1, T2 = (e) => P2.test(e), A2 = (e) => M2.test(e), I2 = (e) => !$e(e) && !ke(e), O2 = (e) => ro(e, Uy, Ly), $e = (e) => Fy.test(e), Ua = (e) => ro(e, jy, q2), Lu = (e) => ro(e, L2, ze), bv = (e) => ro(e, zy, Ly), R2 = (e) => ro(e, Hy, A2), Gs = (e) => ro(e, Wy, T2), ke = (e) => Ny.test(e), mo = (e) => oo(e, jy), V2 = (e) => oo(e, z2), _v = (e) => oo(e, zy), F2 = (e) => oo(e, Uy), N2 = (e) => oo(e, Hy), Ks = (e) => oo(e, Wy, !0), ro = (e, t, n) => {
  const a = Fy.exec(e);
  return a ? a[1] ? t(a[1]) : n(a[2]) : !1;
}, oo = (e, t, n = !1) => {
  const a = Ny.exec(e);
  return a ? a[1] ? t(a[1]) : n : !1;
}, zy = (e) => e === "position" || e === "percentage", Hy = (e) => e === "image" || e === "url", Uy = (e) => e === "length" || e === "size" || e === "bg-size", jy = (e) => e === "length", L2 = (e) => e === "number", z2 = (e) => e === "family-name", Wy = (e) => e === "shadow", H2 = () => {
  const e = Dt("color"), t = Dt("font"), n = Dt("text"), a = Dt("font-weight"), r = Dt("tracking"), o = Dt("leading"), s = Dt("breakpoint"), i = Dt("container"), u = Dt("spacing"), d = Dt("radius"), c = Dt("shadow"), f = Dt("inset-shadow"), p = Dt("text-shadow"), v = Dt("drop-shadow"), m = Dt("blur"), g = Dt("perspective"), w = Dt("aspect"), C = Dt("ease"), S = Dt("animate"), $ = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], B = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], k = () => [...B(), ke, $e], P = () => ["auto", "hidden", "clip", "visible", "scroll"], D = () => ["auto", "contain", "none"], q = () => [ke, $e, u], T = () => [Cr, "full", "auto", ...q()], M = () => [Ca, "none", "subgrid", ke, $e], O = () => ["auto", {
    span: ["full", Ca, ke, $e]
  }, Ca, ke, $e], F = () => [Ca, "auto", ke, $e], J = () => ["auto", "min", "max", "fr", ke, $e], ne = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], Q = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], G = () => ["auto", ...q()], H = () => [Cr, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...q()], U = () => [e, ke, $e], se = () => [...B(), _v, bv, {
    position: [ke, $e]
  }], ee = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], de = () => ["auto", "cover", "contain", F2, O2, {
    size: [ke, $e]
  }], pe = () => [Nu, mo, Ua], _e = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    d,
    ke,
    $e
  ], ge = () => ["", ze, mo, Ua], Te = () => ["solid", "dashed", "dotted", "double"], ce = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], R = () => [ze, Nu, _v, bv], te = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    m,
    ke,
    $e
  ], z = () => ["none", ze, ke, $e], re = () => ["none", ze, ke, $e], ie = () => [ze, ke, $e], L = () => [Cr, "full", ...q()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [ta],
      breakpoint: [ta],
      color: [E2],
      container: [ta],
      "drop-shadow": [ta],
      ease: ["in", "out", "in-out"],
      font: [I2],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [ta],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [ta],
      shadow: [ta],
      spacing: ["px", ze],
      text: [ta],
      "text-shadow": [ta],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", Cr, $e, ke, w]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [ze, $e, ke, i]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": $()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": $()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: k()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: P()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": P()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": P()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: D()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": D()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": D()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: T()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": T()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": T()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: T()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: T()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: T()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: T()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: T()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: T()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Ca, "auto", ke, $e]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [Cr, "full", "auto", i, ...q()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [ze, Cr, "auto", "initial", "none", $e]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", ze, ke, $e]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", ze, ke, $e]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Ca, "first", "last", "none", ke, $e]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": M()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: O()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": F()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": F()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": M()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: O()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": F()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": F()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": J()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": J()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: q()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": q()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": q()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ne(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...Q(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...Q()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ne()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ne()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...Q(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...Q()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: q()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: q()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: q()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: q()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: q()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: q()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: q()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: q()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: q()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: G()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: G()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: G()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: G()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: G()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: G()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: G()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: G()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: G()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": q()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": q()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: H()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [i, "screen", ...H()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          i,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...H()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          i,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...H()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...H()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...H()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...H()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, mo, Ua]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [a, ke, Lu]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Nu, $e]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [V2, $e, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [r, ke, $e]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [ze, "none", ke, Lu]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...q()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ke, $e]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", ke, $e]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: U()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: U()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Te(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [ze, "from-font", "auto", ke, Ua]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: U()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [ze, "auto", ke, $e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: q()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ke, $e]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ke, $e]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: se()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ee()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: de()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Ca, ke, $e],
          radial: ["", ke, $e],
          conic: [Ca, ke, $e]
        }, N2, R2]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: U()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: pe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: pe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: pe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: U()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: U()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: U()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: _e()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": _e()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": _e()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": _e()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": _e()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": _e()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": _e()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": _e()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": _e()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": _e()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": _e()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": _e()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": _e()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": _e()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": _e()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ge()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ge()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ge()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ge()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ge()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ge()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ge()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ge()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ge()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ge()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ge()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Te(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...Te(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: U()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": U()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": U()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": U()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": U()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": U()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": U()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": U()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": U()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: U()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...Te(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [ze, ke, $e]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", ze, mo, Ua]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: U()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          Ks,
          Gs
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: U()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", f, Ks, Gs]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": U()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ge()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: U()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [ze, Ua]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": U()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ge()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": U()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", p, Ks, Gs]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": U()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [ze, ke, $e]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...ce(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": ce()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [ze]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": R()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": R()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": U()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": U()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": R()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": R()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": U()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": U()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": R()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": R()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": U()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": U()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": R()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": R()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": U()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": U()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": R()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": R()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": U()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": U()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": R()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": R()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": U()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": U()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": R()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": R()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": U()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": U()
      }],
      "mask-image-radial": [{
        "mask-radial": [ke, $e]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": R()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": R()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": U()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": U()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": B()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [ze]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": R()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": R()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": U()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": U()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: se()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: ee()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: de()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", ke, $e]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ke,
          $e
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: te()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [ze, ke, $e]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [ze, ke, $e]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          v,
          Ks,
          Gs
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": U()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", ze, ke, $e]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [ze, ke, $e]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", ze, ke, $e]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [ze, ke, $e]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", ze, ke, $e]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ke,
          $e
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": te()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [ze, ke, $e]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [ze, ke, $e]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", ze, ke, $e]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [ze, ke, $e]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", ze, ke, $e]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [ze, ke, $e]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [ze, ke, $e]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", ze, ke, $e]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": q()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": q()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": q()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ke, $e]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [ze, "initial", ke, $e]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", C, ke, $e]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [ze, ke, $e]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", S, ke, $e]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [g, ke, $e]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": k()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: z()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": z()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": z()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": z()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: re()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": re()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": re()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": re()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: ie()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": ie()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": ie()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [ke, $e, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: k()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: L()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": L()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": L()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": L()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: U()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: U()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ke, $e]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": q()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": q()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": q()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": q()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": q()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": q()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": q()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": q()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": q()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": q()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": q()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": q()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": q()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": q()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": q()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": q()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": q()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": q()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ke, $e]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...U()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [ze, mo, Ua, Lu]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...U()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, U2 = /* @__PURE__ */ C2(H2);
function V(...e) {
  return U2(Ay(e));
}
function HH(e, t) {
  t.value = typeof e == "function" ? e(t.value) : e;
}
function UH(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = Cn(a, s);
    if (i || i === null) return i;
    throw new Error(
      `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`
    );
  }, (s) => (Xn(a, s), s)];
}
function j2(e, t, n = {}) {
  let a, r, o, s = !0;
  const i = () => {
    s = !0, o();
  };
  ve(e, i, {
    flush: "sync",
    ...n
  });
  const u = typeof t == "function" ? t : t.get, d = typeof t == "function" ? void 0 : t.set, c = hi((f, p) => (r = f, o = p, {
    get() {
      return s && (a = u(a), s = !1), r(), a;
    },
    set(v) {
      d?.(v);
    }
  }));
  return c.trigger = i, c;
}
const Tr = /* @__PURE__ */ new WeakMap(), Gy = /* @__NO_SIDE_EFFECTS__ */ (...e) => {
  var t;
  const n = e[0], a = (t = ht()) === null || t === void 0 ? void 0 : t.proxy, r = a ?? ss();
  if (r == null && !ih()) throw new Error("injectLocal must be called in setup");
  return r && Tr.has(r) && n in Tr.get(r) ? Tr.get(r)[n] : Cn(...e);
};
function W2(e, t) {
  var n;
  const a = (n = ht()) === null || n === void 0 ? void 0 : n.proxy, r = a ?? ss();
  if (r == null) throw new Error("provideLocal must be called in setup");
  Tr.has(r) || Tr.set(r, /* @__PURE__ */ Object.create(null));
  const o = Tr.get(r);
  return o[e] = t, Xn(e, t);
}
// @__NO_SIDE_EFFECTS__
function G2(e, t) {
  const n = Symbol(e.name || "InjectionState"), a = void 0;
  return [(...s) => {
    const i = e(...s);
    return W2(n, i), i;
  }, () => /* @__PURE__ */ Gy(n, a)];
}
const Ky = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const K2 = (e) => typeof e < "u", Y2 = Object.prototype.toString, X2 = (e) => Y2.call(e) === "[object Object]";
function wv(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function zu(e) {
  return Array.isArray(e) ? e : [e];
}
function J2(e) {
  return mt(e) ? Wt(new Proxy({}, {
    get(t, n, a) {
      return l(Reflect.get(e.value, n, a));
    },
    set(t, n, a) {
      return mt(e.value[n]) && !mt(a) ? e.value[n].value = a : e.value[n] = a, !0;
    },
    deleteProperty(t, n) {
      return Reflect.deleteProperty(e.value, n);
    },
    has(t, n) {
      return Reflect.has(e.value, n);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  })) : Wt(e);
}
function Z2(e) {
  return J2(E(e));
}
function Z(e, ...t) {
  const n = t.flat(), a = n[0];
  return Z2(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(fe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
function Q2(e, t, n) {
  return ve(e, t, {
    ...n,
    immediate: !0
  });
}
const Yy = Ky ? window : void 0, Xy = Ky ? window.document : void 0;
function Jy(e) {
  var t;
  const n = fe(e);
  return (t = n?.$el) !== null && t !== void 0 ? t : n;
}
function Ar(...e) {
  const t = (a, r, o, s) => (a.addEventListener(r, o, s), () => a.removeEventListener(r, o, s)), n = E(() => {
    const a = zu(fe(e[0])).filter((r) => r != null);
    return a.every((r) => typeof r != "string") ? a : void 0;
  });
  return Q2(() => {
    var a, r;
    return [
      (a = (r = n.value) === null || r === void 0 ? void 0 : r.map((o) => Jy(o))) !== null && a !== void 0 ? a : [Yy].filter((o) => o != null),
      zu(fe(n.value ? e[1] : e[0])),
      zu(l(n.value ? e[2] : e[1])),
      fe(n.value ? e[3] : e[2])
    ];
  }, ([a, r, o, s], i, u) => {
    if (!a?.length || !r?.length || !o?.length) return;
    const d = X2(s) ? { ...s } : s, c = a.flatMap((f) => r.flatMap((p) => o.map((v) => t(f, p, v, d))));
    u(() => {
      c.forEach((f) => f());
    });
  }, { flush: "post" });
}
// @__NO_SIDE_EFFECTS__
function eI() {
  const e = gt(!1), t = ht();
  return t && Ce(() => {
    e.value = !0;
  }, t), e;
}
// @__NO_SIDE_EFFECTS__
function tI(e) {
  const t = /* @__PURE__ */ eI();
  return E(() => (t.value, !!e()));
}
const nI = /* @__PURE__ */ Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function aI() {
  const e = ih() ? /* @__PURE__ */ Gy(nI, null) : null;
  return typeof e == "number" ? e : void 0;
}
function zl(e, t = {}) {
  const { window: n = Yy, ssrWidth: a = /* @__PURE__ */ aI() } = t, r = /* @__PURE__ */ tI(() => n && "matchMedia" in n && typeof n.matchMedia == "function"), o = gt(typeof a == "number"), s = gt(), i = gt(!1), u = (d) => {
    i.value = d.matches;
  };
  return Ie(() => {
    if (o.value) {
      o.value = !r.value, i.value = fe(e).split(",").some((d) => {
        const c = d.includes("not all"), f = d.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), p = d.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let v = !!(f || p);
        return f && v && (v = a >= wv(f[1])), p && v && (v = a <= wv(p[1])), c ? !v : v;
      });
      return;
    }
    r.value && (s.value = n.matchMedia(fe(e)), i.value = s.value.matches);
  }), Ar(s, "change", u, { passive: !0 }), E(() => i.value);
}
function rI(e) {
  return JSON.parse(JSON.stringify(e));
}
function oI(e) {
  const t = ht(), n = j2(() => null, () => e ? Jy(e) : t.proxy.$el);
  return P0(n.trigger), Ce(n.trigger), n;
}
function sI(e, t = {}) {
  const { threshold: n = 50, onSwipe: a, onSwipeEnd: r, onSwipeStart: o, passive: s = !0 } = t, i = Wt({
    x: 0,
    y: 0
  }), u = Wt({
    x: 0,
    y: 0
  }), d = E(() => i.x - u.x), c = E(() => i.y - u.y), { max: f, abs: p } = Math, v = E(() => f(p(d.value), p(c.value)) >= n), m = gt(!1), g = E(() => v.value ? p(d.value) > p(c.value) ? d.value > 0 ? "left" : "right" : c.value > 0 ? "up" : "down" : "none"), w = (D) => [D.touches[0].clientX, D.touches[0].clientY], C = (D, q) => {
    i.x = D, i.y = q;
  }, S = (D, q) => {
    u.x = D, u.y = q;
  }, $ = {
    passive: s,
    capture: !s
  }, B = (D) => {
    m.value && r?.(D, g.value), m.value = !1;
  }, k = [
    Ar(e, "touchstart", (D) => {
      if (D.touches.length !== 1) return;
      const [q, T] = w(D);
      C(q, T), S(q, T), o?.(D);
    }, $),
    Ar(e, "touchmove", (D) => {
      if (D.touches.length !== 1) return;
      const [q, T] = w(D);
      S(q, T), $.capture && !$.passive && Math.abs(d.value) > Math.abs(c.value) && D.preventDefault(), !m.value && v.value && (m.value = !0), m.value && a?.(D);
    }, $),
    Ar(e, ["touchend", "touchcancel"], B, $)
  ];
  return {
    isSwiping: m,
    direction: g,
    coordsStart: i,
    coordsEnd: u,
    lengthX: d,
    lengthY: c,
    stop: () => k.forEach((D) => D())
  };
}
// @__NO_SIDE_EFFECTS__
function Gi(e, t, n, a = {}) {
  var r, o;
  const { clone: s = !1, passive: i = !1, eventName: u, deep: d = !1, defaultValue: c, shouldEmit: f } = a, p = ht(), v = n || p?.emit || (p == null || (r = p.$emit) === null || r === void 0 ? void 0 : r.bind(p)) || (p == null || (o = p.proxy) === null || o === void 0 || (o = o.$emit) === null || o === void 0 ? void 0 : o.bind(p?.proxy));
  let m = u;
  t || (t = "modelValue"), m = m || `update:${t.toString()}`;
  const g = (S) => s ? typeof s == "function" ? s(S) : rI(S) : S, w = () => K2(e[t]) ? g(e[t]) : c, C = (S) => {
    f ? f(S) && v(m, S) : v(m, S);
  };
  if (i) {
    const S = I(w());
    let $ = !1;
    return ve(() => e[t], (B) => {
      $ || ($ = !0, S.value = g(B), Be(() => $ = !1));
    }), ve(S, (B) => {
      !$ && (B !== e[t] || d) && C(B);
    }, { deep: d }), S;
  } else return E({
    get() {
      return w();
    },
    set(S) {
      C(S);
    }
  });
}
function jH() {
  const e = zl("(max-width: 768px)"), t = zl("(min-width: 769px) and (max-width: 1024px)"), n = I(!1);
  Ce(() => {
    n.value = "ontouchstart" in window || navigator.maxTouchPoints > 0;
  });
  const a = E(() => e.value || t.value);
  return {
    isMobile: e,
    isTablet: t,
    isTouchDevice: n,
    isSmallScreen: a
  };
}
function WH(e, t = {}) {
  const { threshold: n = 50, enabled: a = !0, onSwipeLeft: r, onSwipeRight: o } = t, { direction: s, lengthX: i } = sI(e, {
    passive: !0,
    onSwipeEnd() {
      a && Math.abs(i.value) >= n && (s.value === "left" && r ? r() : s.value === "right" && o && o());
    }
  });
  return {
    direction: s,
    lengthX: i
  };
}
function GH() {
  const e = I(!0);
  let t = 0, n = !1;
  const a = () => {
    n || (window.requestAnimationFrame(() => {
      const r = window.scrollY, o = r - t;
      o > 10 && r > 100 ? e.value = !1 : o < -10 && (e.value = !0), t = r, n = !1;
    }), n = !0);
  };
  return Ce(() => {
    window.addEventListener("scroll", a, { passive: !0 });
  }), Qe(() => {
    window.removeEventListener("scroll", a);
  }), {
    isVisible: e
  };
}
const lI = /* @__PURE__ */ b({
  __name: "AlertDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(rC), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), xv = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Cv = Ay, sn = (e, t) => (n) => {
  var a;
  if (t?.variants == null) return Cv(e, n?.class, n?.className);
  const { variants: r, defaultVariants: o } = t, s = Object.keys(r).map((d) => {
    const c = n?.[d], f = o?.[d];
    if (c === null) return null;
    const p = xv(c) || xv(f);
    return r[d][p];
  }), i = n && Object.entries(n).reduce((d, c) => {
    let [f, p] = c;
    return p === void 0 || (d[f] = p), d;
  }, {}), u = t == null || (a = t.compoundVariants) === null || a === void 0 ? void 0 : a.reduce((d, c) => {
    let { class: f, className: p, ...v } = c;
    return Object.entries(v).every((m) => {
      let [g, w] = m;
      return Array.isArray(w) ? w.includes({
        ...o,
        ...i
      }[g]) : {
        ...o,
        ...i
      }[g] === w;
    }) ? [
      ...d,
      f,
      p
    ] : d;
  }, []);
  return Cv(e, s, u, n?.class, n?.className);
}, Ss = /* @__PURE__ */ b({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-slot": "button",
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(V)(l(Yt)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Yt = sn(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        xs: "h-7 rounded px-2",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), iI = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Ux), A(l(n), {
      class: l(V)(l(Yt)(), t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uI = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Xx), A(l(n), {
      class: l(V)(l(Yt)({ variant: "outline" }), "mt-2 sm:mt-0", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dI = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(nC), null, {
      default: y(() => [
        N(l(eC), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(Kx), A(l(o), {
          class: l(V)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), cI = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Zx), A(l(n), {
      class: l(V)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fI = /* @__PURE__ */ b({
  __name: "AlertDialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), pI = /* @__PURE__ */ b({
  __name: "AlertDialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("flex flex-col gap-y-2 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), vI = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(sC), A(l(n), {
      class: l(V)("text-lg font-semibold", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), KH = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(iC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), YH = /* @__PURE__ */ b({
  __name: "ConfirmDialog",
  setup(e) {
    const { isOpen: t, close: n, cancelButton: a, actionButton: r, title: o, description: s, variant: i } = gI();
    return (u, d) => (h(), x(l(lI), { open: l(t) }, {
      default: y(() => [
        N(l(dI), {
          onEscapeKeyDown: l(n),
          onPointerDownOutside: l(n)
        }, {
          default: y(() => [
            N(l(pI), null, {
              default: y(() => [
                N(l(vI), null, {
                  default: y(() => [
                    Re(Ne(l(o)), 1)
                  ]),
                  _: 1
                }),
                N(l(cI), null, {
                  default: y(() => [
                    Re(Ne(l(s)), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            N(l(fI), null, {
              default: y(() => [
                N(l(uI), {
                  onClick: l(a).handler
                }, {
                  default: y(() => [
                    Re(Ne(l(a).label ?? "Cancel"), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                N(l(iI), {
                  variant: l(i),
                  onClick: l(r).handler
                }, {
                  default: y(() => [
                    Re(Ne(l(r).label ?? "Confirm"), 1)
                  ]),
                  _: 1
                }, 8, ["variant", "onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onEscapeKeyDown", "onPointerDownOutside"])
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), hf = I(!1), Zy = I(""), Qy = I(""), eb = I(null), tb = I({
  label: void 0,
  handler: () => {
  }
}), nb = I({
  label: void 0,
  handler: () => {
  }
}), mI = (e) => {
  Zy.value = e.title, Qy.value = e.description, eb.value = e.variant, tb.value = Sv(e.cancelAction), nb.value = Sv(e.action), hI();
}, Sv = (e) => typeof e == "string" ? {
  label: e,
  handler: vl
} : typeof e == "function" ? {
  label: void 0,
  handler: e
} : typeof e == "object" && e !== void 0 ? {
  label: e.label ?? void 0,
  handler: e.handler ?? vl
} : {
  label: void 0,
  handler: vl
}, vl = () => {
  hf.value = !1;
}, hI = () => {
  hf.value = !0;
};
function gI() {
  return {
    confirmDialog: (e) => mI(e),
    title: Zy,
    description: Qy,
    variant: eb,
    isOpen: hf,
    close: vl,
    cancelButton: tb,
    actionButton: nb
  };
}
const vr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t)
    n[a] = r;
  return n;
}, yI = {}, bI = { class: "h-full bg-background dark:text-white" };
function _I(e, t) {
  return h(), W("div", bI, [
    _(e.$slots, "default")
  ]);
}
const XH = /* @__PURE__ */ vr(yI, [["render", _I]]), wI = {}, xI = { class: "sticky top-0 z-50 flex h-16 shrink-0 items-center gap-x-4 bg-background/60 px-4 backdrop-blur sm:gap-x-6 sm:px-6 lg:px-8" };
function CI(e, t) {
  return h(), W("header", xI, [
    _(e.$slots, "default")
  ]);
}
const JH = /* @__PURE__ */ vr(wI, [["render", CI]]), SI = {}, $I = { class: "px-4 py-6 sm:px-6 lg:px-8 lg:pl-72" };
function kI(e, t) {
  return h(), W("main", $I, [
    _(e.$slots, "default")
  ]);
}
const ZH = /* @__PURE__ */ vr(SI, [["render", kI]]), BI = {};
function DI(e, t) {
  return _(e.$slots, "default");
}
const QH = /* @__PURE__ */ vr(BI, [["render", DI]]), PI = {}, MI = { class: "hidden px-6 py-6 lg:fixed lg:inset-y-0 lg:top-16 lg:z-50 lg:flex lg:w-72 lg:flex-col" }, EI = { class: "gap-y-5 overflow-y-auto" };
function qI(e, t) {
  return h(), W("div", MI, [
    we("div", EI, [
      _(e.$slots, "default")
    ])
  ]);
}
const e7 = /* @__PURE__ */ vr(PI, [["render", qI]]), TI = {};
function AI(e, t) {
  return _(e.$slots, "default");
}
const t7 = /* @__PURE__ */ vr(TI, [["render", AI]]);
const $v = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), II = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, a) => a ? a.toUpperCase() : n.toLowerCase()
), OI = (e) => {
  const t = II(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, RI = (...e) => e.filter((t, n, a) => !!t && t.trim() !== "" && a.indexOf(t) === n).join(" ").trim(), kv = (e) => e === "";
var ho = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const VI = ({
  name: e,
  iconNode: t,
  absoluteStrokeWidth: n,
  "absolute-stroke-width": a,
  strokeWidth: r,
  "stroke-width": o,
  size: s = ho.width,
  color: i = ho.stroke,
  ...u
}, { slots: d }) => an(
  "svg",
  {
    ...ho,
    ...u,
    width: s,
    height: s,
    stroke: i,
    "stroke-width": kv(n) || kv(a) || n === !0 || a === !0 ? Number(r || o || ho["stroke-width"]) * 24 / Number(s) : r || o || ho["stroke-width"],
    class: RI(
      "lucide",
      u.class,
      ...e ? [`lucide-${$v(OI(e))}-icon`, `lucide-${$v(e)}`] : ["lucide-icon"]
    )
  },
  [...t.map((c) => an(...c)), ...d.default ? [d.default()] : []]
);
const bt = (e, t) => (n, { slots: a, attrs: r }) => an(
  VI,
  {
    ...r,
    ...n,
    iconNode: t,
    name: e
  },
  a
);
const FI = bt("arrow-left", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
const NI = bt("arrow-right", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
const so = bt("check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
const Ki = bt("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
const Yi = bt("chevron-left", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
const za = bt("chevron-right", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
const LI = bt("chevron-up", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }]
]);
const ab = bt("circle-check", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
const gf = bt("circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
const rb = bt("ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
const zI = bt("grip-vertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
const ob = bt("info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
const yf = bt("loader-circle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
const HI = bt("menu", [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
]);
const bf = bt("minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
const sb = bt("octagon-x", [
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  [
    "path",
    {
      d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z",
      key: "2d38gg"
    }
  ],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
const lb = bt("panel-left", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
const UI = bt("plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
const jI = bt("search", [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
]);
const ib = bt("triangle-alert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
const lo = bt("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), WI = {
  type: "button",
  class: "-m-2.5 p-2.5 lg:hidden"
}, n7 = /* @__PURE__ */ b({
  __name: "TwoColumnLayoutSidebarTrigger",
  setup(e) {
    return (t, n) => (h(), W("button", WI, [
      n[0] || (n[0] = we("span", { class: "sr-only" }, "Open sidebar", -1)),
      N(l(HI), {
        class: "h-6 w-6",
        "aria-hidden": "true"
      })
    ]));
  }
}), Bv = "sidebar_state", GI = 3600 * 24 * 7, KI = "18rem", YI = "3rem", a7 = "18rem", XI = "b", [$s, JI] = Se("CollapsibleTwoColumnLayout"), ZI = ["data-state", "data-collapsible"], r7 = /* @__PURE__ */ b({
  __name: "CollapsibleTwoColumnLayout",
  props: {
    defaultOpen: { type: Boolean, default: !Xy?.cookie.includes(`${Bv}=false`) },
    open: { type: Boolean, default: void 0 },
    collapsible: { default: "icon" },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = zl("(max-width: 1023px)"), o = I(!1), s = /* @__PURE__ */ Gi(n, "open", a, {
      defaultValue: n.defaultOpen ?? !0,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, n.collapsible !== "none" && (document.cookie = `${Bv}=${s.value}; path=/; max-age=${GI}`);
    }
    function u(f) {
      o.value = f;
    }
    function d() {
      return r.value ? u(!o.value) : i(!s.value);
    }
    n.collapsible !== "none" && Ar("keydown", (f) => {
      f.key === XI && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = E(() => s.value ? "expanded" : "collapsed");
    return JI({
      state: c,
      open: s,
      setOpen: i,
      isMobile: r,
      openMobile: o,
      setOpenMobile: u,
      toggleSidebar: d,
      collapsible: n.collapsible
    }), (f, p) => (h(), x(l(vf), { "delay-duration": 0 }, {
      default: y(() => [
        we("div", A({
          style: {
            "--collapsible-sidebar-width": l(KI),
            "--collapsible-sidebar-width-icon": l(YI)
          },
          class: l(V)("group/collapsible-layout h-full bg-background dark:text-white", n.class),
          "data-state": c.value,
          "data-collapsible": e.collapsible
        }, f.$attrs), [
          _(f.$slots, "default")
        ], 16, ZI)
      ]),
      _: 3
    }));
  }
}), QI = ["data-state", "data-collapsible"], eO = { class: "flex-1 overflow-y-auto" }, o7 = /* @__PURE__ */ b({
  __name: "CollapsibleSidebarDesktop",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = $s(), o = E(() => r === "icon" && n.value === "collapsed");
    return (s, i) => l(a) ? Ee("", !0) : (h(), W("div", {
      key: 0,
      class: ae(
        l(V)(
          "fixed inset-y-0 top-16 z-50 flex flex-col px-6 py-6 transition-[width] duration-200 ease-linear",
          o.value ? "w-[var(--collapsible-sidebar-width-icon)] px-2" : "w-[var(--collapsible-sidebar-width)]",
          t.class
        )
      ),
      "data-state": l(n),
      "data-collapsible": l(r)
    }, [
      we("div", eO, [
        _(s.$slots, "default")
      ])
    ], 10, QI));
  }
}), tO = ["data-state"], s7 = /* @__PURE__ */ b({
  __name: "CollapsibleMain",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = $s(), o = E(() => r === "icon" && n.value === "collapsed");
    return (s, i) => (h(), W("main", {
      class: ae(
        l(V)(
          "px-4 py-6 transition-[padding-left] duration-200 ease-linear sm:px-6 lg:px-8",
          !l(a) && (o.value ? "lg:pl-[var(--collapsible-sidebar-width-icon)]" : "lg:pl-[var(--collapsible-sidebar-width)]"),
          t.class
        )
      ),
      "data-state": l(n)
    }, [
      _(s.$slots, "default")
    ], 10, tO));
  }
}), l7 = /* @__PURE__ */ b({
  __name: "CollapsibleSidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n, collapsible: a } = $s();
    return (r, o) => l(a) !== "none" ? (h(), x(l(Ss), {
      key: 0,
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: ae(l(V)("h-7 w-7", t.class)),
      onClick: l(n)
    }, {
      default: y(() => [
        N(l(lb), { class: "h-5 w-5" }),
        o[0] || (o[0] = we("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"])) : Ee("", !0);
  }
}), i7 = /* @__PURE__ */ b({
  __name: "Tip",
  props: {
    tooltip: {},
    indicator: { type: Boolean },
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(nO), null, {
      default: y(() => [
        N(l(_f), oe(le(l(r))), {
          default: y(() => [
            N(l(xf), {
              class: ae(e.indicator ? "underline decoration-dotted underline-offset-4" : "")
            }, {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(wf), oe(le(o.$attrs)), {
              default: y(() => [
                _(o.$slots, "tooltip", {}, () => [
                  Re(Ne(e.tooltip), 1)
                ])
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), _f = /* @__PURE__ */ b({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(GA), A({ "data-slot": "tooltip" }, l(r)), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), wf = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(e2), null, {
      default: y(() => [
        N(l(ZA), A({ "data-slot": "tooltip-content" }, { ...l(o), ...s.$attrs }, {
          class: l(V)(
            "z-50 w-fit animate-in rounded-md bg-foreground px-3 py-1.5 text-xs text-balance text-background fade-in-0 zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(zA), { class: "z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] bg-foreground fill-foreground" })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), nO = /* @__PURE__ */ b({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 0 },
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(vf), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), xf = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(n2), A({ "data-slot": "tooltip-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), aO = ["data-active", "data-collapsed"], rO = ["data-active", "data-collapsed"], u7 = /* @__PURE__ */ b({
  __name: "CollapsibleMenuButton",
  props: {
    tooltip: {},
    active: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = $s(), o = E(() => r === "icon" && n.value === "collapsed"), s = E(() => t.tooltip && o.value && !a.value);
    return (i, u) => s.value ? (h(), x(l(_f), { key: 0 }, {
      default: y(() => [
        N(l(xf), { "as-child": "" }, {
          default: y(() => [
            we("button", {
              type: "button",
              class: ae(
                l(V)(
                  "flex w-full items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors",
                  "hover:bg-accent hover:text-accent-foreground",
                  e.active && "bg-accent text-accent-foreground",
                  o.value && "justify-center px-2",
                  t.class
                )
              ),
              "data-active": e.active,
              "data-collapsed": o.value
            }, [
              _(i.$slots, "default")
            ], 10, aO)
          ]),
          _: 3
        }),
        N(l(wf), {
          side: "right",
          align: "center"
        }, {
          default: y(() => [
            typeof e.tooltip == "string" ? (h(), W(Ke, { key: 0 }, [
              Re(Ne(e.tooltip), 1)
            ], 64)) : (h(), x(Pt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        })
      ]),
      _: 3
    })) : (h(), W("button", {
      key: 1,
      type: "button",
      class: ae(
        l(V)(
          "flex w-full items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors",
          "hover:bg-accent hover:text-accent-foreground",
          e.active && "bg-accent text-accent-foreground",
          o.value && "justify-center px-2",
          t.class
        )
      ),
      "data-active": e.active,
      "data-collapsed": o.value
    }, [
      _(i.$slots, "default")
    ], 10, rO));
  }
}), oO = {
  key: 0,
  class: "mb-2 block px-3 text-xs font-semibold tracking-wider text-muted-foreground uppercase"
}, d7 = /* @__PURE__ */ b({
  __name: "CollapsibleMenuGroup",
  props: {
    label: {},
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = $s(), o = E(
      () => r === "icon" && n.value === "collapsed" && !a.value
    );
    return (s, i) => (h(), W("div", {
      class: ae(l(V)("space-y-1", t.class))
    }, [
      e.label && !o.value ? (h(), W("span", oO, Ne(e.label), 1)) : Ee("", !0),
      _(s.$slots, "default")
    ], 2));
  }
});
let qd = 1;
var sO = class {
  subscribers;
  toasts;
  dismissedToasts;
  constructor() {
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
  subscribe = (e) => (this.subscribers.push(e), () => {
    const t = this.subscribers.indexOf(e);
    this.subscribers.splice(t, 1);
  });
  publish = (e) => {
    this.subscribers.forEach((t) => t(e));
  };
  addToast = (e) => {
    this.publish(e), this.toasts = [...this.toasts, e];
  };
  create = (e) => {
    const { message: t, ...n } = e, a = typeof e.id == "number" || e.id && e.id?.length > 0 ? e.id : qd++, r = this.toasts.find((s) => s.id === a), o = e.dismissible === void 0 ? !0 : e.dismissible;
    return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a), r ? this.toasts = this.toasts.map((s) => s.id === a ? (this.publish({
      ...s,
      ...e,
      id: a,
      title: t
    }), {
      ...s,
      ...e,
      id: a,
      dismissible: o,
      title: t
    }) : s) : this.addToast({
      title: t,
      ...n,
      dismissible: o,
      id: a
    }), a;
  };
  dismiss = (e) => (e ? (this.dismissedToasts.add(e), requestAnimationFrame(() => this.subscribers.forEach((t) => t({
    id: e,
    dismiss: !0
  })))) : this.toasts.forEach((t) => {
    this.subscribers.forEach((n) => n({
      id: t.id,
      dismiss: !0
    }));
  }), e);
  message = (e, t) => this.create({
    ...t,
    message: e,
    type: "default"
  });
  error = (e, t) => this.create({
    ...t,
    type: "error",
    message: e
  });
  success = (e, t) => this.create({
    ...t,
    type: "success",
    message: e
  });
  info = (e, t) => this.create({
    ...t,
    type: "info",
    message: e
  });
  warning = (e, t) => this.create({
    ...t,
    type: "warning",
    message: e
  });
  loading = (e, t) => this.create({
    ...t,
    type: "loading",
    message: e
  });
  promise = (e, t) => {
    if (!t) return;
    let n;
    t.loading !== void 0 && (n = this.create({
      ...t,
      promise: e,
      type: "loading",
      message: t.loading,
      description: typeof t.description != "function" ? t.description : void 0
    }));
    const a = Promise.resolve(e instanceof Function ? e() : e);
    let r = n !== void 0, o;
    const s = a.then(async (u) => {
      if (o = ["resolve", u], fo(u))
        r = !1, this.create({
          id: n,
          type: "default",
          message: u
        });
      else if (iO(u) && !u.ok) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(`HTTP error! status: ${u.status}`) : t.error, f = typeof t.description == "function" ? await t.description(`HTTP error! status: ${u.status}`) : t.description, v = typeof c == "object" && !fo(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (u instanceof Error) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(u) : t.error, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !fo(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (t.success !== void 0) {
        r = !1;
        const c = typeof t.success == "function" ? await t.success(u) : t.success, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !fo(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "success",
          description: f,
          ...v
        });
      }
    }).catch(async (u) => {
      if (o = ["reject", u], t.error !== void 0) {
        r = !1;
        const d = typeof t.error == "function" ? await t.error(u) : t.error, c = typeof t.description == "function" ? await t.description(u) : t.description, p = typeof d == "object" && !fo(d) ? d : {
          message: d || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: c,
          ...p
        });
      }
    }).finally(() => {
      r && (this.dismiss(n), n = void 0), t.finally?.();
    }), i = () => new Promise((u, d) => s.then(() => o[0] === "reject" ? d(o[1]) : u(o[1])).catch(d));
    return typeof n != "string" && typeof n != "number" ? { unwrap: i } : Object.assign(n, { unwrap: i });
  };
  custom = (e, t) => {
    const n = t?.id || qd++, a = this.toasts.find((o) => o.id === n), r = t?.dismissible === void 0 ? !0 : t.dismissible;
    return this.dismissedToasts.has(n) && this.dismissedToasts.delete(n), a ? this.toasts = this.toasts.map((o) => o.id === n ? (this.publish({
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), {
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }) : o) : this.addToast({
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), n;
  };
  getActiveToasts = () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id));
};
const Jt = new sO();
function lO(e, t) {
  const n = t?.id || qd++;
  return Jt.create({
    message: e,
    id: n,
    type: "default",
    ...t
  }), n;
}
const iO = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", uO = lO, dO = () => Jt.toasts, cO = () => Jt.getActiveToasts(), Ys = Object.assign(uO, {
  success: Jt.success,
  info: Jt.info,
  warning: Jt.warning,
  error: Jt.error,
  custom: Jt.custom,
  message: Jt.message,
  promise: Jt.promise,
  dismiss: Jt.dismiss,
  loading: Jt.loading
}, {
  getHistory: dO,
  getToasts: cO
});
function Xs(e) {
  return e.label !== void 0;
}
const fO = 3, ub = "24px", db = "16px", Dv = 4e3, pO = 356, vO = 14, mO = 45, cb = 200;
function hO() {
  const e = I(!1);
  return Ie(() => {
    const t = () => {
      e.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
  }), { isDocumentHidden: e };
}
function Sa(...e) {
  return e.filter(Boolean).join(" ");
}
function gO(e) {
  const [t, n] = e.split("-"), a = [];
  return t && a.push(t), n && a.push(n), a;
}
function yO(e, t) {
  const n = {};
  return [e, t].forEach((a, r) => {
    const o = r === 1, s = o ? "--mobile-offset" : "--offset", i = o ? db : ub;
    function u(d) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((c) => {
        n[`${s}-${c}`] = typeof d == "number" ? `${d}px` : d;
      });
    }
    typeof a == "number" || typeof a == "string" ? u(a) : typeof a == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((d) => {
      a[d] === void 0 ? n[`${s}-${d}`] = i : n[`${s}-${d}`] = typeof a[d] == "number" ? `${a[d]}px` : a[d];
    }) : u(i);
  }), n;
}
const bO = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded",
  "data-testid"
], _O = [
  "aria-label",
  "data-disabled",
  "data-close-button-position"
];
var wO = /* @__PURE__ */ b({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    closeButtonPosition: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = I(null), o = I(null), s = I(!1), i = I(!1), u = I(!1), d = I(!1), c = I(!1), f = I(0), p = I(0), v = I(n.toast.duration || n.duration || Dv), m = I(null), g = I(null), w = E(() => n.index === 0), C = E(() => n.index + 1 <= n.visibleToasts), S = E(() => n.toast.type), $ = E(() => n.toast.dismissible !== !1), B = E(() => n.toast.class || ""), k = E(() => n.descriptionClass || ""), P = E(() => {
      const R = n.toast.position || n.position, z = n.heights.filter((re) => re.position === R).findIndex((re) => re.toastId === n.toast.id);
      return z >= 0 ? z : 0;
    }), D = E(() => {
      const R = n.toast.position || n.position;
      return n.heights.filter((z) => z.position === R).reduce((z, re, ie) => ie >= P.value ? z : z + re.height, 0);
    }), q = E(() => P.value * n.gap + D.value || 0), T = E(() => n.toast.closeButton ?? n.closeButton), M = E(() => n.toast.duration || n.duration || Dv), O = I(0), F = I(0), J = I(null), ne = E(() => n.position.split("-")), Q = E(() => ne.value[0]), G = E(() => ne.value[1]), H = E(() => typeof n.toast.title != "string"), U = E(() => typeof n.toast.description != "string"), { isDocumentHidden: se } = hO(), ee = E(() => S.value && S.value === "loading");
    Ce(() => {
      s.value = !0, v.value = M.value;
    }), Ie(async () => {
      if (!s.value || !g.value) return;
      await Be();
      const R = g.value, te = R.style.height;
      R.style.height = "auto";
      const z = R.getBoundingClientRect().height;
      R.style.height = te, p.value = z, a("update:height", {
        toastId: n.toast.id,
        height: z,
        position: n.toast.position || n.position
      });
    });
    function de() {
      i.value = !0, f.value = q.value, setTimeout(() => {
        a("removeToast", n.toast);
      }, cb);
    }
    function pe() {
      if (ee.value || !$.value) return {};
      de(), n.toast.onDismiss?.(n.toast);
    }
    function _e(R) {
      R.button !== 2 && (ee.value || !$.value || (m.value = /* @__PURE__ */ new Date(), f.value = q.value, R.target.setPointerCapture(R.pointerId), R.target.tagName !== "BUTTON" && (u.value = !0, J.value = {
        x: R.clientX,
        y: R.clientY
      })));
    }
    function ge() {
      if (d.value || !$.value) return;
      J.value = null;
      const R = Number(g.value?.style.getPropertyValue("--swipe-amount-x").replace("px", "") || 0), te = Number(g.value?.style.getPropertyValue("--swipe-amount-y").replace("px", "") || 0), z = (/* @__PURE__ */ new Date()).getTime() - (m.value?.getTime() || 0), re = r.value === "x" ? R : te, ie = Math.abs(re) / z;
      if (Math.abs(re) >= mO || ie > 0.11) {
        f.value = q.value, n.toast.onDismiss?.(n.toast), r.value === "x" ? o.value = R > 0 ? "right" : "left" : o.value = te > 0 ? "down" : "up", de(), d.value = !0;
        return;
      } else
        g.value?.style.setProperty("--swipe-amount-x", "0px"), g.value?.style.setProperty("--swipe-amount-y", "0px");
      c.value = !1, u.value = !1, r.value = null;
    }
    function Te(R) {
      if (!J.value || !$.value || (window?.getSelection()?.toString()?.length ?? !1)) return;
      const z = R.clientY - J.value.y, re = R.clientX - J.value.x, ie = n.swipeDirections ?? gO(n.position);
      !r.value && (Math.abs(re) > 1 || Math.abs(z) > 1) && (r.value = Math.abs(re) > Math.abs(z) ? "x" : "y");
      let L = {
        x: 0,
        y: 0
      };
      const be = (xe) => 1 / (1.5 + Math.abs(xe) / 20);
      if (r.value === "y") {
        if (ie.includes("top") || ie.includes("bottom")) if (ie.includes("top") && z < 0 || ie.includes("bottom") && z > 0) L.y = z;
        else {
          const xe = z * be(z);
          L.y = Math.abs(xe) < Math.abs(z) ? xe : z;
        }
      } else if (r.value === "x" && (ie.includes("left") || ie.includes("right")))
        if (ie.includes("left") && re < 0 || ie.includes("right") && re > 0) L.x = re;
        else {
          const xe = re * be(re);
          L.x = Math.abs(xe) < Math.abs(re) ? xe : re;
        }
      (Math.abs(L.x) > 0 || Math.abs(L.y) > 0) && (c.value = !0), g.value?.style.setProperty("--swipe-amount-x", `${L.x}px`), g.value?.style.setProperty("--swipe-amount-y", `${L.y}px`);
    }
    Ce(() => {
      if (s.value = !0, !g.value) return;
      const R = g.value.getBoundingClientRect().height;
      p.value = R;
      const te = [{
        toastId: n.toast.id,
        height: R,
        position: n.toast.position
      }, ...n.heights];
      a("update:heights", te);
    }), sr(() => {
      g.value && a("removeToast", n.toast);
    }), Ie((R) => {
      if (n.toast.promise && S.value === "loading" || n.toast.duration === 1 / 0 || n.toast.type === "loading") return;
      let te;
      const z = () => {
        if (F.value < O.value) {
          const ie = (/* @__PURE__ */ new Date()).getTime() - O.value;
          v.value = v.value - ie;
        }
        F.value = (/* @__PURE__ */ new Date()).getTime();
      }, re = () => {
        v.value !== 1 / 0 && (O.value = (/* @__PURE__ */ new Date()).getTime(), te = setTimeout(() => {
          n.toast.onAutoClose?.(n.toast), de();
        }, v.value));
      };
      n.expanded || n.interacting || se.value ? z() : re(), R(() => {
        clearTimeout(te);
      });
    }), ve(() => n.toast.delete, (R) => {
      R !== void 0 && R && (de(), n.toast.onDismiss?.(n.toast));
    }, { deep: !0 });
    function ce() {
      u.value = !1, r.value = null, J.value = null;
    }
    return (R, te) => (h(), W("li", {
      tabindex: "0",
      ref_key: "toastRef",
      ref: g,
      class: ae(l(Sa)(n.class, B.value, R.classes?.toast, R.toast.classes?.toast, R.classes?.[S.value], R.toast?.classes?.[S.value])),
      "data-sonner-toast": "",
      "data-rich-colors": R.toast.richColors ?? R.defaultRichColors,
      "data-styled": !(R.toast.component || R.toast?.unstyled || R.unstyled),
      "data-mounted": s.value,
      "data-promise": !!R.toast.promise,
      "data-swiped": c.value,
      "data-removed": i.value,
      "data-visible": C.value,
      "data-y-position": Q.value,
      "data-x-position": G.value,
      "data-index": R.index,
      "data-front": w.value,
      "data-swiping": u.value,
      "data-dismissible": $.value,
      "data-type": S.value,
      "data-invert": R.toast.invert || R.invert,
      "data-swipe-out": d.value,
      "data-swipe-direction": o.value,
      "data-expanded": !!(R.expanded || R.expandByDefault && s.value),
      "data-testid": R.toast.testId,
      style: dt({
        "--index": R.index,
        "--toasts-before": R.index,
        "--z-index": R.toasts.length - R.index,
        "--offset": `${i.value ? f.value : q.value}px`,
        "--initial-height": R.expandByDefault ? "auto" : `${p.value}px`,
        ...R.style,
        ...n.toast.style
      }),
      onDragend: ce,
      onPointerdown: _e,
      onPointerup: ge,
      onPointermove: Te
    }, [T.value && !R.toast.component && S.value !== "loading" ? (h(), W("button", {
      key: 0,
      "aria-label": R.closeButtonAriaLabel || "Close toast",
      "data-disabled": ee.value,
      "data-close-button": "true",
      "data-close-button-position": R.closeButtonPosition,
      class: ae(l(Sa)(R.classes?.closeButton, R.toast?.classes?.closeButton)),
      onClick: pe
    }, [R.icons?.close ? (h(), x(Pt(R.icons?.close), { key: 0 })) : _(R.$slots, "close-icon", { key: 1 })], 10, _O)) : Ee("v-if", !0), R.toast.component ? (h(), x(Pt(R.toast.component), A({ key: 1 }, R.toast.componentProps, {
      onCloseToast: pe,
      isPaused: R.$props.expanded || R.$props.interacting || l(se)
    }), null, 16, ["isPaused"])) : (h(), W(Ke, { key: 2 }, [
      S.value !== "default" || R.toast.icon || R.toast.promise ? (h(), W("div", {
        key: 0,
        "data-icon": "",
        class: ae(l(Sa)(R.classes?.icon, R.toast?.classes?.icon))
      }, [R.toast.icon ? (h(), x(Pt(R.toast.icon), { key: 0 })) : (h(), W(Ke, { key: 1 }, [S.value === "loading" ? _(R.$slots, "loading-icon", { key: 0 }) : S.value === "success" ? _(R.$slots, "success-icon", { key: 1 }) : S.value === "error" ? _(R.$slots, "error-icon", { key: 2 }) : S.value === "warning" ? _(R.$slots, "warning-icon", { key: 3 }) : S.value === "info" ? _(R.$slots, "info-icon", { key: 4 }) : Ee("v-if", !0)], 64))], 2)) : Ee("v-if", !0),
      we("div", {
        "data-content": "",
        class: ae(l(Sa)(R.classes?.content, R.toast?.classes?.content))
      }, [we("div", {
        "data-title": "",
        class: ae(l(Sa)(R.classes?.title, R.toast.classes?.title))
      }, [H.value ? (h(), x(Pt(R.toast.title), oe(A({ key: 0 }, R.toast.componentProps)), null, 16)) : (h(), W(Ke, { key: 1 }, [Re(Ne(R.toast.title), 1)], 64))], 2), R.toast.description ? (h(), W("div", {
        key: 0,
        "data-description": "",
        class: ae(l(Sa)(R.descriptionClass, k.value, R.classes?.description, R.toast.classes?.description))
      }, [U.value ? (h(), x(Pt(R.toast.description), oe(A({ key: 0 }, R.toast.componentProps)), null, 16)) : (h(), W(Ke, { key: 1 }, [Re(Ne(R.toast.description), 1)], 64))], 2)) : Ee("v-if", !0)], 2),
      R.toast.cancel ? (h(), W("button", {
        key: 1,
        style: dt(R.toast.cancelButtonStyle || R.cancelButtonStyle),
        class: ae(l(Sa)(R.classes?.cancelButton, R.toast.classes?.cancelButton)),
        "data-button": "",
        "data-cancel": "",
        onClick: te[0] || (te[0] = (z) => {
          l(Xs)(R.toast.cancel) && $.value && (R.toast.cancel.onClick?.(z), de());
        })
      }, Ne(l(Xs)(R.toast.cancel) ? R.toast.cancel?.label : R.toast.cancel), 7)) : Ee("v-if", !0),
      R.toast.action ? (h(), W("button", {
        key: 2,
        style: dt(R.toast.actionButtonStyle || R.actionButtonStyle),
        class: ae(l(Sa)(R.classes?.actionButton, R.toast.classes?.actionButton)),
        "data-button": "",
        "data-action": "",
        onClick: te[1] || (te[1] = (z) => {
          l(Xs)(R.toast.action) && (R.toast.action.onClick?.(z), !z.defaultPrevented && de());
        })
      }, Ne(l(Xs)(R.toast.action) ? R.toast.action?.label : R.toast.action), 7)) : Ee("v-if", !0)
    ], 64))], 46, bO));
  }
}), xO = wO, ks = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t) n[a] = r;
  return n;
};
const CO = {}, SO = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function $O(e, t) {
  return h(), W("svg", SO, t[0] || (t[0] = [we("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), we("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var kO = /* @__PURE__ */ ks(CO, [["render", $O]]);
const BO = ["data-visible"], DO = { class: "sonner-spinner" };
var PO = /* @__PURE__ */ b({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(e) {
    const t = Array(12).fill(0);
    return (n, a) => (h(), W("div", {
      class: "sonner-loading-wrapper",
      "data-visible": n.visible
    }, [we("div", DO, [(h(!0), W(Ke, null, Lt(l(t), (r) => (h(), W("div", {
      key: `spinner-bar-${r}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, BO));
  }
}), MO = PO;
const EO = {}, qO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function TO(e, t) {
  return h(), W("svg", qO, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var AO = /* @__PURE__ */ ks(EO, [["render", TO]]);
const IO = {}, OO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function RO(e, t) {
  return h(), W("svg", OO, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var VO = /* @__PURE__ */ ks(IO, [["render", RO]]);
const FO = {}, NO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function LO(e, t) {
  return h(), W("svg", NO, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var zO = /* @__PURE__ */ ks(FO, [["render", LO]]);
const HO = {}, UO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function jO(e, t) {
  return h(), W("svg", UO, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var WO = /* @__PURE__ */ ks(HO, [["render", jO]]);
const GO = ["aria-label"], KO = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position"
], YO = typeof window < "u" && typeof document < "u";
function XO() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const e = document.documentElement.getAttribute("dir");
  return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e;
}
var JO = /* @__PURE__ */ b({
  name: "Toaster",
  inheritAttrs: !1,
  __name: "Toaster",
  props: {
    id: {},
    invert: {
      type: Boolean,
      default: !1
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    closeButtonPosition: { default: "top-left" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: !1
    },
    expand: {
      type: Boolean,
      default: !1
    },
    duration: {},
    gap: { default: vO },
    visibleToasts: { default: fO },
    closeButton: {
      type: Boolean,
      default: !1
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: ub },
    mobileOffset: { default: db },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(e) {
    const t = e, n = M0(), a = I([]), r = E(() => t.id ? a.value.filter((M) => M.toasterId === t.id) : a.value.filter((M) => !M.toasterId));
    function o(M, O) {
      return r.value.filter((F) => !F.position && O === 0 || F.position === M);
    }
    const s = E(() => {
      const M = r.value.filter((O) => O.position).map((O) => O.position);
      return M.length > 0 ? Array.from(new Set([t.position].concat(M))) : [t.position];
    }), i = E(() => {
      const M = {};
      return s.value.forEach((O) => {
        M[O] = a.value.filter((F) => F.position === O);
      }), M;
    }), u = I([]), d = I({}), c = I(!1);
    Ie(() => {
      s.value.forEach((M) => {
        M in d.value || (d.value[M] = !1);
      });
    });
    const f = I(t.theme !== "system" ? t.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = I(null), v = I(null), m = I(!1), g = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function w(M) {
      a.value.find((O) => O.id === M.id)?.delete || Jt.dismiss(M.id), a.value = a.value.filter(({ id: O }) => O !== M.id), setTimeout(() => {
        a.value.find((O) => O.id === M.id) || (u.value = u.value.filter((O) => O.toastId !== M.id));
      }, cb + 50);
    }
    function C(M) {
      m.value && !M.currentTarget?.contains?.(M.relatedTarget) && (m.value = !1, v.value && (v.value.focus({ preventScroll: !0 }), v.value = null));
    }
    function S(M) {
      M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || m.value || (m.value = !0, v.value = M.relatedTarget);
    }
    function $(M) {
      M.target && M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || (c.value = !0);
    }
    Ie((M) => {
      const O = Jt.subscribe((F) => {
        if (F.dismiss) {
          requestAnimationFrame(() => {
            a.value = a.value.map((J) => J.id === F.id ? {
              ...J,
              delete: !0
            } : J);
          });
          return;
        }
        Be(() => {
          const J = a.value.findIndex((ne) => ne.id === F.id);
          J !== -1 ? a.value = [
            ...a.value.slice(0, J),
            {
              ...a.value[J],
              ...F
            },
            ...a.value.slice(J + 1)
          ] : a.value = [F, ...a.value];
        });
      });
      M(O);
    }), Ie((M) => {
      if (typeof window > "u") return;
      if (t.theme !== "system") {
        f.value = t.theme;
        return;
      }
      const O = window.matchMedia("(prefers-color-scheme: dark)"), F = (ne) => {
        f.value = ne ? "dark" : "light";
      };
      F(O.matches);
      const J = (ne) => {
        F(ne.matches);
      };
      try {
        O.addEventListener("change", J);
      } catch {
        O.addListener(J);
      }
      M(() => {
        try {
          O.removeEventListener("change", J);
        } catch {
          O.removeListener(J);
        }
      });
    }), Ie(() => {
      p.value && v.value && (v.value.focus({ preventScroll: !0 }), v.value = null, m.value = !1);
    }), Ie(() => {
      a.value.length <= 1 && Object.keys(d.value).forEach((M) => {
        d.value[M] = !1;
      });
    }), Ie((M) => {
      function O(F) {
        const J = t.hotkey.every((G) => F[G] || F.code === G), ne = Array.isArray(p.value) ? p.value[0] : p.value;
        J && (s.value.forEach((G) => {
          d.value[G] = !0;
        }), ne?.focus());
        const Q = document.activeElement === p.value || ne?.contains(document.activeElement);
        F.code === "Escape" && Q && s.value.forEach((G) => {
          d.value[G] = !1;
        });
      }
      YO && (document.addEventListener("keydown", O), M(() => {
        document.removeEventListener("keydown", O);
      }));
    });
    function B(M) {
      const O = M.currentTarget, F = O.getAttribute("data-y-position") + "-" + O.getAttribute("data-x-position");
      d.value[F] = !0;
    }
    function k(M) {
      if (!c.value) {
        const O = M.currentTarget, F = O.getAttribute("data-y-position") + "-" + O.getAttribute("data-x-position");
        d.value[F] = !1;
      }
    }
    function P() {
      Object.keys(d.value).forEach((M) => {
        d.value[M] = !1;
      });
    }
    function D() {
      c.value = !1;
    }
    function q(M) {
      u.value = M;
    }
    function T(M) {
      const O = u.value.findIndex((F) => F.toastId === M.toastId);
      if (O !== -1) u.value[O] = M;
      else {
        const F = u.value.findIndex((J) => J.position === M.position);
        F !== -1 ? u.value.splice(F, 0, M) : u.value.unshift(M);
      }
    }
    return (M, O) => (h(), W(Ke, null, [Ee(" Remove item from normal navigation flow, only available via hotkey "), we("section", {
      "aria-label": `${M.containerAriaLabel} ${l(g)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(h(!0), W(Ke, null, Lt(s.value, (F, J) => (h(), W("ol", A({
      key: F,
      ref_for: !0,
      ref_key: "listRef",
      ref: p,
      "data-sonner-toaster": "",
      "data-sonner-theme": f.value,
      class: t.class,
      dir: M.dir === "auto" ? XO() : M.dir,
      tabIndex: -1,
      "data-theme": M.theme,
      "data-rich-colors": M.richColors,
      "data-y-position": F.split("-")[0],
      "data-x-position": F.split("-")[1],
      style: {
        "--front-toast-height": `${u.value[0]?.height || 0}px`,
        "--width": `${l(pO)}px`,
        "--gap": `${M.gap}px`,
        ...M.style,
        ...l(n).style,
        ...l(yO)(M.offset, M.mobileOffset)
      }
    }, { ref_for: !0 }, M.$attrs, {
      onBlur: C,
      onFocus: S,
      onMouseenter: B,
      onMousemove: B,
      onMouseleave: k,
      onDragend: P,
      onPointerdown: $,
      onPointerup: D
    }), [(h(!0), W(Ke, null, Lt(o(F, J), (ne, Q) => (h(), x(xO, {
      key: ne.id,
      heights: u.value,
      icons: M.icons,
      index: Q,
      toast: ne,
      defaultRichColors: M.richColors,
      duration: M.toastOptions?.duration ?? M.duration,
      class: ae(M.toastOptions?.class ?? ""),
      descriptionClass: M.toastOptions?.descriptionClass,
      invert: M.invert,
      visibleToasts: M.visibleToasts,
      closeButton: M.toastOptions?.closeButton ?? M.closeButton,
      interacting: c.value,
      position: F,
      closeButtonPosition: M.toastOptions?.closeButtonPosition ?? M.closeButtonPosition,
      style: dt(M.toastOptions?.style),
      unstyled: M.toastOptions?.unstyled,
      classes: M.toastOptions?.classes,
      cancelButtonStyle: M.toastOptions?.cancelButtonStyle,
      actionButtonStyle: M.toastOptions?.actionButtonStyle,
      "close-button-aria-label": M.toastOptions?.closeButtonAriaLabel,
      toasts: i.value[F],
      expandByDefault: M.expand,
      gap: M.gap,
      expanded: d.value[F] || !1,
      swipeDirections: t.swipeDirections,
      "onUpdate:heights": q,
      "onUpdate:height": T,
      onRemoveToast: w
    }, {
      "close-icon": y(() => [_(M.$slots, "close-icon", {}, () => [N(kO)])]),
      "loading-icon": y(() => [_(M.$slots, "loading-icon", {}, () => [N(MO, { visible: ne.type === "loading" }, null, 8, ["visible"])])]),
      "success-icon": y(() => [_(M.$slots, "success-icon", {}, () => [N(AO)])]),
      "error-icon": y(() => [_(M.$slots, "error-icon", {}, () => [N(WO)])]),
      "warning-icon": y(() => [_(M.$slots, "warning-icon", {}, () => [N(zO)])]),
      "info-icon": y(() => [_(M.$slots, "info-icon", {}, () => [N(VO)])]),
      _: 2
    }, 1032, [
      "heights",
      "icons",
      "index",
      "toast",
      "defaultRichColors",
      "duration",
      "class",
      "descriptionClass",
      "invert",
      "visibleToasts",
      "closeButton",
      "interacting",
      "position",
      "closeButtonPosition",
      "style",
      "unstyled",
      "classes",
      "cancelButtonStyle",
      "actionButtonStyle",
      "close-button-aria-label",
      "toasts",
      "expandByDefault",
      "gap",
      "expanded",
      "swipeDirections"
    ]))), 128))], 16, KO))), 128))], 8, GO)], 2112));
  }
}), fb = JO;
function ZO(e, t) {
  return Object.entries(e).map(([n, a]) => t === "key" ? n : t === "both" ? `${n}: ${a}` : a).join(`
`);
}
function QO() {
  return {
    info: (e) => {
      Ys.info("FYI", {
        description: e
      });
    },
    success: (e) => {
      Ys.success("Success", {
        description: e
      });
    },
    warning: (e) => {
      Ys.warning("Warning", {
        description: e
      });
    },
    error: (e, t = "value") => {
      Ys.error("Oh snap! Some errors were encountered.", {
        description: ZO(e, t)
      });
    }
  };
}
const c7 = /* @__PURE__ */ b({
  __name: "Flasher",
  props: {
    class: {},
    info: {},
    success: {},
    warning: {},
    errors: {},
    objectFormat: { default: "value" }
  },
  setup(e) {
    const t = e, {
      info: n,
      success: a,
      warning: r,
      error: o
    } = QO();
    return ve(
      () => t.info,
      (s) => {
        s && n(t.info);
      },
      {
        immediate: !0
      }
    ), ve(
      () => t.success,
      (s) => {
        s && a(t.success);
      },
      { immediate: !0 }
    ), ve(
      () => t.warning,
      (s) => {
        s && r(t.warning);
      },
      { immediate: !0 }
    ), ve(
      () => t.errors,
      () => {
        t.errors !== void 0 && Object.keys(t.errors).length > 0 && o(t.errors, t.objectFormat);
      }
    ), (s, i) => (h(), x(l(fb), {
      class: ae(l(V)("toaster group", t.class)),
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          success: "group-[.toaster]:border-success",
          error: "group-[.toaster]:border-destructive",
          warning: "group-[.toaster]:border-warning",
          info: "group-[.toaster]:border-primary",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, {
      "success-icon": y(() => [
        N(l(ab), { class: "size-4 text-success" })
      ]),
      "info-icon": y(() => [
        N(l(ob), { class: "size-4 text-primary" })
      ]),
      "warning-icon": y(() => [
        N(l(ib), { class: "size-4 text-warning" })
      ]),
      "error-icon": y(() => [
        N(l(sb), { class: "size-4 text-destructive" })
      ]),
      "loading-icon": y(() => [
        we("div", null, [
          N(l(yf), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": y(() => [
        N(l(lo), { class: "size-4" })
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), e3 = { class: "flex items-center justify-between space-y-2" }, t3 = { class: "flex items-center space-x-2" }, f7 = /* @__PURE__ */ b({
  __name: "Heading",
  props: {
    as: { default: "h2" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", e3, [
      (h(), x(Pt(e.as), {
        class: ae(l(V)("text-3xl font-bold tracking-tight", t.class))
      }, {
        default: y(() => [
          _(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])),
      we("div", t3, [
        _(n.$slots, "actions")
      ])
    ]));
  }
}), n3 = /* @__PURE__ */ b({
  __name: "Accordion",
  props: {
    collapsible: { type: Boolean },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(G1), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), p7 = /* @__PURE__ */ b({
  __name: "Accord",
  props: {
    content: {},
    collapsible: { type: Boolean, default: !0 },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: { default: "single" },
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(n3, oe(le(l(r))), {
      default: y(() => [
        (h(!0), W(Ke, null, Lt(e.content, (i, u) => (h(), x(l(r3), {
          key: u,
          value: "item-" + u
        }, {
          default: y(() => [
            N(l(o3), null, {
              default: y(() => [
                _(o.$slots, u + ".title", { item: i }, () => [
                  Re(Ne(i.title), 1)
                ])
              ]),
              _: 2
            }, 1024),
            N(l(a3), null, {
              default: y(() => [
                _(o.$slots, u + ".content", { item: i }, () => [
                  Re(Ne(i.content), 1)
                ])
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1032, ["value"]))), 128))
      ]),
      _: 3
    }, 16));
  }
}), a3 = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Z1), A(l(n), { class: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down" }), {
      default: y(() => [
        we("div", {
          class: ae(l(V)("pt-0 pb-4", t.class))
        }, [
          _(a.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16));
  }
}), r3 = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(X1), A(l(a), {
      class: l(V)("border-b", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), o3 = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(ex), { class: "flex" }, {
      default: y(() => [
        N(l(nx), A(l(n), {
          class: l(V)(
            "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
            t.class
          )
        }), {
          default: y(() => [
            _(a.$slots, "default"),
            _(a.$slots, "icon", {}, () => [
              N(l(Ki), { class: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), v7 = /* @__PURE__ */ b({
  __name: "Alert",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)(l(s3)({ variant: e.variant }), t.class)),
      role: "alert"
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), m7 = /* @__PURE__ */ b({
  __name: "AlertDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("text-sm [&_p]:leading-relaxed", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), h7 = /* @__PURE__ */ b({
  __name: "AlertTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("h5", {
      class: ae(l(V)("mb-1 leading-none font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), s3 = sn(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), g7 = /* @__PURE__ */ b({
  __name: "AspectRatio",
  props: {
    ratio: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(dC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), y7 = /* @__PURE__ */ b({
  __name: "Avatar",
  props: {
    class: {},
    size: { default: "sm" },
    shape: { default: "circle" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(pC), {
      class: ae(l(V)(l(l3)({ size: e.size, shape: e.shape }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), b7 = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(mC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _7 = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {},
    referrerPolicy: {},
    crossOrigin: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(yC), A(t, { class: "h-full w-full object-cover" }), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), l3 = sn(
  "inline-flex items-center justify-center font-normal text-foreground select-none shrink-0 bg-secondary overflow-hidden",
  {
    variants: {
      size: {
        sm: "h-10 w-10 text-xs",
        base: "h-16 w-16 text-2xl",
        lg: "h-32 w-32 text-5xl"
      },
      shape: {
        circle: "rounded-full",
        square: "rounded-md"
      }
    }
  }
), w7 = /* @__PURE__ */ b({
  __name: "Badge",
  props: {
    variant: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)(l(i3)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), i3 = sn(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        success: "border-transparent bg-success text-success-foreground shadow hover:bg-success/80",
        warning: "border-transparent bg-warning text-warning-foreground shadow hover:bg-warning/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), x7 = /* @__PURE__ */ b({
  __name: "Breadcrumb",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("nav", {
      "aria-label": "breadcrumb",
      class: ae(t.class)
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), C7 = /* @__PURE__ */ b({
  __name: "BreadcrumbEllipsis",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(V)("flex h-9 w-9 items-center justify-center", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(rb), { class: "h-4 w-4" })
      ]),
      a[0] || (a[0] = we("span", { class: "sr-only" }, "More", -1))
    ], 2));
  }
}), S7 = /* @__PURE__ */ b({
  __name: "BreadcrumbItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("li", {
      class: ae(l(V)("inline-flex items-center gap-1.5", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), $7 = /* @__PURE__ */ b({
  __name: "BreadcrumbLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(V)("transition-colors hover:text-foreground", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), k7 = /* @__PURE__ */ b({
  __name: "BreadcrumbList",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("ol", {
      class: ae(
        l(V)(
          "flex flex-wrap items-center gap-1.5 text-sm break-words text-muted-foreground sm:gap-2.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), B7 = /* @__PURE__ */ b({
  __name: "BreadcrumbPage",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      role: "link",
      "aria-disabled": "true",
      "aria-current": "page",
      class: ae(l(V)("font-normal text-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), D7 = /* @__PURE__ */ b({
  __name: "BreadcrumbSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("li", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(V)("[&>svg]:size-3.5", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(za))
      ])
    ], 2));
  }
}), u3 = ["data-orientation"], P7 = /* @__PURE__ */ b({
  __name: "ButtonGroup",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      class: ae(l(V)(l(d3)({ orientation: t.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, u3));
  }
}), Xi = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(rf), A({ "data-slot": "separator" }, l(n), {
      class: l(V)(
        "shrink-0 bg-border data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), M7 = /* @__PURE__ */ b({
  __name: "ButtonGroupSeparator",
  props: {
    orientation: { default: "vertical" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Xi), A({ "data-slot": "button-group-separator" }, l(n), {
      orientation: t.orientation,
      class: l(V)("relative !m-0 self-stretch bg-input data-[orientation=vertical]:h-auto", t.class)
    }), null, 16, ["orientation", "class"]));
  }
}), E7 = /* @__PURE__ */ b({
  __name: "ButtonGroupText",
  props: {
    class: {},
    orientation: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(V)(
          "flex items-center gap-2 rounded-md border bg-muted px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as", "as-child", "class"]));
  }
}), d3 = sn(
  "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*:focus-visible]:relative [&>*:focus-visible]:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  {
    variants: {
      orientation: {
        horizontal: "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
        vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
      }
    },
    defaultVariants: {
      orientation: "horizontal"
    }
  }
), c3 = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, q7 = /* @__PURE__ */ b({
  __name: "Calendar",
  props: {
    defaultValue: {},
    defaultPlaceholder: {},
    placeholder: {},
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    modelValue: {},
    multiple: { type: Boolean },
    disableDaysOutsideCurrentView: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(DC), A({
      class: l(V)("p-3", n.class)
    }, l(o)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(y3), null, {
          default: y(() => [
            N(l(w3)),
            N(l(b3)),
            N(l(_3))
          ]),
          _: 1
        }),
        we("div", c3, [
          (h(!0), W(Ke, null, Lt(u, (c) => (h(), x(l(v3), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(h3), null, {
                default: y(() => [
                  N(l(Pv), null, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Lt(d, (f) => (h(), x(l(g3), { key: f }, {
                        default: y(() => [
                          Re(Ne(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(m3), null, {
                default: y(() => [
                  (h(!0), W(Ke, null, Lt(c.rows, (f, p) => (h(), x(l(Pv), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Lt(f, (v) => (h(), x(l(f3), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(p3), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), f3 = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(MC), A({
      class: l(V)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:rounded-md [&:has([data-selected])]:bg-accent [&:has([data-selected][data-outside-view])]:bg-accent/50",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), p3 = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(qC), A({
      class: l(V)(
        l(Yt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selected
        "data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:opacity-100 data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:bg-accent/50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), v3 = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(AC), A({
      class: l(V)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), m3 = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(OC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), h3 = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(VC), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Pv = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(NC), A({
      class: l(V)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), g3 = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(zC), A({
      class: l(V)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), y3 = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(UC), A({
      class: l(V)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), b3 = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(WC), A({
      class: l(V)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(Ne(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _3 = /* @__PURE__ */ b({
  __name: "CalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(KC), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(za), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), w3 = /* @__PURE__ */ b({
  __name: "CalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(XC), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Yi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), x3 = /* @__PURE__ */ b({
  __name: "Card",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("rounded-xl border bg-card text-card-foreground shadow", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), C3 = /* @__PURE__ */ b({
  __name: "CardContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), T7 = /* @__PURE__ */ b({
  __name: "CardDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      class: ae(l(V)("text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), A7 = /* @__PURE__ */ b({
  __name: "CardFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("flex items-center p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), S3 = /* @__PURE__ */ b({
  __name: "CardHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("flex flex-col gap-y-1.5 p-6", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), $3 = /* @__PURE__ */ b({
  __name: "CardTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("h3", {
      class: ae(l(V)("leading-none font-semibold tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
});
function k3(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Mv(e) {
  return k3(e) || Array.isArray(e);
}
function B3() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Cf(e, t) {
  const n = Object.keys(e), a = Object.keys(t);
  if (n.length !== a.length) return !1;
  const r = JSON.stringify(Object.keys(e.breakpoints || {})), o = JSON.stringify(Object.keys(t.breakpoints || {}));
  return r !== o ? !1 : n.every((s) => {
    const i = e[s], u = t[s];
    return typeof i == "function" ? `${i}` == `${u}` : !Mv(i) || !Mv(u) ? i === u : Cf(i, u);
  });
}
function Ev(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function D3(e, t) {
  if (e.length !== t.length) return !1;
  const n = Ev(e), a = Ev(t);
  return n.every((r, o) => {
    const s = a[o];
    return Cf(r, s);
  });
}
function Sf(e) {
  return typeof e == "number";
}
function Td(e) {
  return typeof e == "string";
}
function Ji(e) {
  return typeof e == "boolean";
}
function qv(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function vt(e) {
  return Math.abs(e);
}
function $f(e) {
  return Math.sign(e);
}
function To(e, t) {
  return vt(e - t);
}
function P3(e, t) {
  if (e === 0 || t === 0 || vt(e) <= vt(t)) return 0;
  const n = To(vt(e), vt(t));
  return vt(n / e);
}
function M3(e) {
  return Math.round(e * 100) / 100;
}
function Yo(e) {
  return Xo(e).map(Number);
}
function En(e) {
  return e[Bs(e)];
}
function Bs(e) {
  return Math.max(0, e.length - 1);
}
function kf(e, t) {
  return t === Bs(e);
}
function Tv(e, t = 0) {
  return Array.from(Array(e), (n, a) => t + a);
}
function Xo(e) {
  return Object.keys(e);
}
function pb(e, t) {
  return [e, t].reduce((n, a) => (Xo(a).forEach((r) => {
    const o = n[r], s = a[r], i = qv(o) && qv(s);
    n[r] = i ? pb(o, s) : s;
  }), n), {});
}
function Ad(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function E3(e, t) {
  const n = {
    start: a,
    center: r,
    end: o
  };
  function a() {
    return 0;
  }
  function r(u) {
    return o(u) / 2;
  }
  function o(u) {
    return t - u;
  }
  function s(u, d) {
    return Td(e) ? n[e](u) : e(t, u, d);
  }
  return {
    measure: s
  };
}
function Jo() {
  let e = [];
  function t(r, o, s, i = {
    passive: !0
  }) {
    let u;
    if ("addEventListener" in r)
      r.addEventListener(o, s, i), u = () => r.removeEventListener(o, s, i);
    else {
      const d = r;
      d.addListener(s), u = () => d.removeListener(s);
    }
    return e.push(u), a;
  }
  function n() {
    e = e.filter((r) => r());
  }
  const a = {
    add: t,
    clear: n
  };
  return a;
}
function q3(e, t, n, a) {
  const r = Jo(), o = 1e3 / 60;
  let s = null, i = 0, u = 0;
  function d() {
    r.add(e, "visibilitychange", () => {
      e.hidden && m();
    });
  }
  function c() {
    v(), r.clear();
  }
  function f(w) {
    if (!u) return;
    s || (s = w, n(), n());
    const C = w - s;
    for (s = w, i += C; i >= o; )
      n(), i -= o;
    const S = i / o;
    a(S), u && (u = t.requestAnimationFrame(f));
  }
  function p() {
    u || (u = t.requestAnimationFrame(f));
  }
  function v() {
    t.cancelAnimationFrame(u), s = null, i = 0, u = 0;
  }
  function m() {
    s = null, i = 0;
  }
  return {
    init: d,
    destroy: c,
    start: p,
    stop: v,
    update: n,
    render: a
  };
}
function T3(e, t) {
  const n = t === "rtl", a = e === "y", r = a ? "y" : "x", o = a ? "x" : "y", s = !a && n ? -1 : 1, i = c(), u = f();
  function d(m) {
    const {
      height: g,
      width: w
    } = m;
    return a ? g : w;
  }
  function c() {
    return a ? "top" : n ? "right" : "left";
  }
  function f() {
    return a ? "bottom" : n ? "left" : "right";
  }
  function p(m) {
    return m * s;
  }
  return {
    scroll: r,
    cross: o,
    startEdge: i,
    endEdge: u,
    measureSize: d,
    direction: p
  };
}
function nr(e = 0, t = 0) {
  const n = vt(e - t);
  function a(d) {
    return d < e;
  }
  function r(d) {
    return d > t;
  }
  function o(d) {
    return a(d) || r(d);
  }
  function s(d) {
    return o(d) ? a(d) ? e : t : d;
  }
  function i(d) {
    return n ? d - n * Math.ceil((d - t) / n) : d;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: s,
    reachedAny: o,
    reachedMax: r,
    reachedMin: a,
    removeOffset: i
  };
}
function vb(e, t, n) {
  const {
    constrain: a
  } = nr(0, e), r = e + 1;
  let o = s(t);
  function s(p) {
    return n ? vt((r + p) % r) : a(p);
  }
  function i() {
    return o;
  }
  function u(p) {
    return o = s(p), f;
  }
  function d(p) {
    return c().set(i() + p);
  }
  function c() {
    return vb(e, i(), n);
  }
  const f = {
    get: i,
    set: u,
    add: d,
    clone: c
  };
  return f;
}
function A3(e, t, n, a, r, o, s, i, u, d, c, f, p, v, m, g, w, C, S) {
  const {
    cross: $,
    direction: B
  } = e, k = ["INPUT", "SELECT", "TEXTAREA"], P = {
    passive: !1
  }, D = Jo(), q = Jo(), T = nr(50, 225).constrain(v.measure(20)), M = {
    mouse: 300,
    touch: 400
  }, O = {
    mouse: 500,
    touch: 600
  }, F = m ? 43 : 25;
  let J = !1, ne = 0, Q = 0, G = !1, H = !1, U = !1, se = !1;
  function ee(L) {
    if (!S) return;
    function be(Fe) {
      (Ji(S) || S(L, Fe)) && ce(Fe);
    }
    const xe = t;
    D.add(xe, "dragstart", (Fe) => Fe.preventDefault(), P).add(xe, "touchmove", () => {
    }, P).add(xe, "touchend", () => {
    }).add(xe, "touchstart", be).add(xe, "mousedown", be).add(xe, "touchcancel", te).add(xe, "contextmenu", te).add(xe, "click", z, !0);
  }
  function de() {
    D.clear(), q.clear();
  }
  function pe() {
    const L = se ? n : t;
    q.add(L, "touchmove", R, P).add(L, "touchend", te).add(L, "mousemove", R, P).add(L, "mouseup", te);
  }
  function _e(L) {
    const be = L.nodeName || "";
    return k.includes(be);
  }
  function ge() {
    return (m ? O : M)[se ? "mouse" : "touch"];
  }
  function Te(L, be) {
    const xe = f.add($f(L) * -1), Fe = c.byDistance(L, !m).distance;
    return m || vt(L) < T ? Fe : w && be ? Fe * 0.5 : c.byIndex(xe.get(), 0).distance;
  }
  function ce(L) {
    const be = Ad(L, a);
    se = be, U = m && be && !L.buttons && J, J = To(r.get(), s.get()) >= 2, !(be && L.button !== 0) && (_e(L.target) || (G = !0, o.pointerDown(L), d.useFriction(0).useDuration(0), r.set(s), pe(), ne = o.readPoint(L), Q = o.readPoint(L, $), p.emit("pointerDown")));
  }
  function R(L) {
    if (!Ad(L, a) && L.touches.length >= 2) return te(L);
    const xe = o.readPoint(L), Fe = o.readPoint(L, $), Xe = To(xe, ne), lt = To(Fe, Q);
    if (!H && !se && (!L.cancelable || (H = Xe > lt, !H)))
      return te(L);
    const De = o.pointerMove(L);
    Xe > g && (U = !0), d.useFriction(0.3).useDuration(0.75), i.start(), r.add(B(De)), L.preventDefault();
  }
  function te(L) {
    const xe = c.byDistance(0, !1).index !== f.get(), Fe = o.pointerUp(L) * ge(), Xe = Te(B(Fe), xe), lt = P3(Fe, Xe), De = F - 10 * lt, Le = C + lt / 50;
    H = !1, G = !1, q.clear(), d.useDuration(De).useFriction(Le), u.distance(Xe, !m), se = !1, p.emit("pointerUp");
  }
  function z(L) {
    U && (L.stopPropagation(), L.preventDefault(), U = !1);
  }
  function re() {
    return G;
  }
  return {
    init: ee,
    destroy: de,
    pointerDown: re
  };
}
function I3(e, t) {
  let a, r;
  function o(f) {
    return f.timeStamp;
  }
  function s(f, p) {
    const m = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (Ad(f, t) ? f : f.touches[0])[m];
  }
  function i(f) {
    return a = f, r = f, s(f);
  }
  function u(f) {
    const p = s(f) - s(r), v = o(f) - o(a) > 170;
    return r = f, v && (a = f), p;
  }
  function d(f) {
    if (!a || !r) return 0;
    const p = s(r) - s(a), v = o(f) - o(a), m = o(f) - o(r) > 170, g = p / v;
    return v && !m && vt(g) > 0.1 ? g : 0;
  }
  return {
    pointerDown: i,
    pointerMove: u,
    pointerUp: d,
    readPoint: s
  };
}
function O3() {
  function e(n) {
    const {
      offsetTop: a,
      offsetLeft: r,
      offsetWidth: o,
      offsetHeight: s
    } = n;
    return {
      top: a,
      right: r + o,
      bottom: a + s,
      left: r,
      width: o,
      height: s
    };
  }
  return {
    measure: e
  };
}
function R3(e) {
  function t(a) {
    return e * (a / 100);
  }
  return {
    measure: t
  };
}
function V3(e, t, n, a, r, o, s) {
  const i = [e].concat(a);
  let u, d, c = [], f = !1;
  function p(w) {
    return r.measureSize(s.measure(w));
  }
  function v(w) {
    if (!o) return;
    d = p(e), c = a.map(p);
    function C(S) {
      for (const $ of S) {
        if (f) return;
        const B = $.target === e, k = a.indexOf($.target), P = B ? d : c[k], D = p(B ? e : a[k]);
        if (vt(D - P) >= 0.5) {
          w.reInit(), t.emit("resize");
          break;
        }
      }
    }
    u = new ResizeObserver((S) => {
      (Ji(o) || o(w, S)) && C(S);
    }), n.requestAnimationFrame(() => {
      i.forEach((S) => u.observe(S));
    });
  }
  function m() {
    f = !0, u && u.disconnect();
  }
  return {
    init: v,
    destroy: m
  };
}
function F3(e, t, n, a, r, o) {
  let s = 0, i = 0, u = r, d = o, c = e.get(), f = 0;
  function p() {
    const P = a.get() - e.get(), D = !u;
    let q = 0;
    return D ? (s = 0, n.set(a), e.set(a), q = P) : (n.set(e), s += P / u, s *= d, c += s, e.add(s), q = c - f), i = $f(q), f = c, k;
  }
  function v() {
    const P = a.get() - t.get();
    return vt(P) < 1e-3;
  }
  function m() {
    return u;
  }
  function g() {
    return i;
  }
  function w() {
    return s;
  }
  function C() {
    return $(r);
  }
  function S() {
    return B(o);
  }
  function $(P) {
    return u = P, k;
  }
  function B(P) {
    return d = P, k;
  }
  const k = {
    direction: g,
    duration: m,
    velocity: w,
    seek: p,
    settled: v,
    useBaseFriction: S,
    useBaseDuration: C,
    useFriction: B,
    useDuration: $
  };
  return k;
}
function N3(e, t, n, a, r) {
  const o = r.measure(10), s = r.measure(50), i = nr(0.1, 0.99);
  let u = !1;
  function d() {
    return !(u || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function c(v) {
    if (!d()) return;
    const m = e.reachedMin(t.get()) ? "min" : "max", g = vt(e[m] - t.get()), w = n.get() - t.get(), C = i.constrain(g / s);
    n.subtract(w * C), !v && vt(w) < o && (n.set(e.constrain(n.get())), a.useDuration(25).useBaseFriction());
  }
  function f(v) {
    u = !v;
  }
  return {
    shouldConstrain: d,
    constrain: c,
    toggleActive: f
  };
}
function L3(e, t, n, a, r) {
  const o = nr(-t + e, 0), s = f(), i = c(), u = p();
  function d(m, g) {
    return To(m, g) <= 1;
  }
  function c() {
    const m = s[0], g = En(s), w = s.lastIndexOf(m), C = s.indexOf(g) + 1;
    return nr(w, C);
  }
  function f() {
    return n.map((m, g) => {
      const {
        min: w,
        max: C
      } = o, S = o.constrain(m), $ = !g, B = kf(n, g);
      return $ ? C : B || d(w, S) ? w : d(C, S) ? C : S;
    }).map((m) => parseFloat(m.toFixed(3)));
  }
  function p() {
    if (t <= e + r) return [o.max];
    if (a === "keepSnaps") return s;
    const {
      min: m,
      max: g
    } = i;
    return s.slice(m, g);
  }
  return {
    snapsContained: u,
    scrollContainLimit: i
  };
}
function z3(e, t, n) {
  const a = t[0], r = n ? a - e : En(t);
  return {
    limit: nr(r, a)
  };
}
function H3(e, t, n, a) {
  const o = t.min + 0.1, s = t.max + 0.1, {
    reachedMin: i,
    reachedMax: u
  } = nr(o, s);
  function d(p) {
    return p === 1 ? u(n.get()) : p === -1 ? i(n.get()) : !1;
  }
  function c(p) {
    if (!d(p)) return;
    const v = e * (p * -1);
    a.forEach((m) => m.add(v));
  }
  return {
    loop: c
  };
}
function U3(e) {
  const {
    max: t,
    length: n
  } = e;
  function a(o) {
    const s = o - t;
    return n ? s / -n : 0;
  }
  return {
    get: a
  };
}
function j3(e, t, n, a, r) {
  const {
    startEdge: o,
    endEdge: s
  } = e, {
    groupSlides: i
  } = r, u = f().map(t.measure), d = p(), c = v();
  function f() {
    return i(a).map((g) => En(g)[s] - g[0][o]).map(vt);
  }
  function p() {
    return a.map((g) => n[o] - g[o]).map((g) => -vt(g));
  }
  function v() {
    return i(d).map((g) => g[0]).map((g, w) => g + u[w]);
  }
  return {
    snaps: d,
    snapsAligned: c
  };
}
function W3(e, t, n, a, r, o) {
  const {
    groupSlides: s
  } = r, {
    min: i,
    max: u
  } = a, d = c();
  function c() {
    const p = s(o), v = !e || t === "keepSnaps";
    return n.length === 1 ? [o] : v ? p : p.slice(i, u).map((m, g, w) => {
      const C = !g, S = kf(w, g);
      if (C) {
        const $ = En(w[0]) + 1;
        return Tv($);
      }
      if (S) {
        const $ = Bs(o) - En(w)[0] + 1;
        return Tv($, En(w)[0]);
      }
      return m;
    });
  }
  return {
    slideRegistry: d
  };
}
function G3(e, t, n, a, r) {
  const {
    reachedAny: o,
    removeOffset: s,
    constrain: i
  } = a;
  function u(m) {
    return m.concat().sort((g, w) => vt(g) - vt(w))[0];
  }
  function d(m) {
    const g = e ? s(m) : i(m), w = t.map((S, $) => ({
      diff: c(S - g, 0),
      index: $
    })).sort((S, $) => vt(S.diff) - vt($.diff)), {
      index: C
    } = w[0];
    return {
      index: C,
      distance: g
    };
  }
  function c(m, g) {
    const w = [m, m + n, m - n];
    if (!e) return m;
    if (!g) return u(w);
    const C = w.filter((S) => $f(S) === g);
    return C.length ? u(C) : En(w) - n;
  }
  function f(m, g) {
    const w = t[m] - r.get(), C = c(w, g);
    return {
      index: m,
      distance: C
    };
  }
  function p(m, g) {
    const w = r.get() + m, {
      index: C,
      distance: S
    } = d(w), $ = !e && o(w);
    if (!g || $) return {
      index: C,
      distance: m
    };
    const B = t[C] - S, k = m + c(B, 0);
    return {
      index: C,
      distance: k
    };
  }
  return {
    byDistance: p,
    byIndex: f,
    shortcut: c
  };
}
function K3(e, t, n, a, r, o, s) {
  function i(f) {
    const p = f.distance, v = f.index !== t.get();
    o.add(p), p && (a.duration() ? e.start() : (e.update(), e.render(1), e.update())), v && (n.set(t.get()), t.set(f.index), s.emit("select"));
  }
  function u(f, p) {
    const v = r.byDistance(f, p);
    i(v);
  }
  function d(f, p) {
    const v = t.clone().set(f), m = r.byIndex(v.get(), p);
    i(m);
  }
  return {
    distance: u,
    index: d
  };
}
function Y3(e, t, n, a, r, o, s, i) {
  const u = {
    passive: !0,
    capture: !0
  };
  let d = 0;
  function c(v) {
    if (!i) return;
    function m(g) {
      if ((/* @__PURE__ */ new Date()).getTime() - d > 10) return;
      s.emit("slideFocusStart"), e.scrollLeft = 0;
      const S = n.findIndex(($) => $.includes(g));
      Sf(S) && (r.useDuration(0), a.index(S, 0), s.emit("slideFocus"));
    }
    o.add(document, "keydown", f, !1), t.forEach((g, w) => {
      o.add(g, "focus", (C) => {
        (Ji(i) || i(v, C)) && m(w);
      }, u);
    });
  }
  function f(v) {
    v.code === "Tab" && (d = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: c
  };
}
function ko(e) {
  let t = e;
  function n() {
    return t;
  }
  function a(u) {
    t = s(u);
  }
  function r(u) {
    t += s(u);
  }
  function o(u) {
    t -= s(u);
  }
  function s(u) {
    return Sf(u) ? u : u.get();
  }
  return {
    get: n,
    set: a,
    add: r,
    subtract: o
  };
}
function mb(e, t) {
  const n = e.scroll === "x" ? s : i, a = t.style;
  let r = null, o = !1;
  function s(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function i(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function u(p) {
    if (o) return;
    const v = M3(e.direction(p));
    v !== r && (a.transform = n(v), r = v);
  }
  function d(p) {
    o = !p;
  }
  function c() {
    o || (a.transform = "", t.getAttribute("style") || t.removeAttribute("style"));
  }
  return {
    clear: c,
    to: u,
    toggleActive: d
  };
}
function X3(e, t, n, a, r, o, s, i, u) {
  const c = Yo(r), f = Yo(r).reverse(), p = C().concat(S());
  function v(D, q) {
    return D.reduce((T, M) => T - r[M], q);
  }
  function m(D, q) {
    return D.reduce((T, M) => v(T, q) > 0 ? T.concat([M]) : T, []);
  }
  function g(D) {
    return o.map((q, T) => ({
      start: q - a[T] + 0.5 + D,
      end: q + t - 0.5 + D
    }));
  }
  function w(D, q, T) {
    const M = g(q);
    return D.map((O) => {
      const F = T ? 0 : -n, J = T ? n : 0, ne = T ? "end" : "start", Q = M[O][ne];
      return {
        index: O,
        loopPoint: Q,
        slideLocation: ko(-1),
        translate: mb(e, u[O]),
        target: () => i.get() > Q ? F : J
      };
    });
  }
  function C() {
    const D = s[0], q = m(f, D);
    return w(q, n, !1);
  }
  function S() {
    const D = t - s[0] - 1, q = m(c, D);
    return w(q, -n, !0);
  }
  function $() {
    return p.every(({
      index: D
    }) => {
      const q = c.filter((T) => T !== D);
      return v(q, t) <= 0.1;
    });
  }
  function B() {
    p.forEach((D) => {
      const {
        target: q,
        translate: T,
        slideLocation: M
      } = D, O = q();
      O !== M.get() && (T.to(O), M.set(O));
    });
  }
  function k() {
    p.forEach((D) => D.translate.clear());
  }
  return {
    canLoop: $,
    clear: k,
    loop: B,
    loopPoints: p
  };
}
function J3(e, t, n) {
  let a, r = !1;
  function o(u) {
    if (!n) return;
    function d(c) {
      for (const f of c)
        if (f.type === "childList") {
          u.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    a = new MutationObserver((c) => {
      r || (Ji(n) || n(u, c)) && d(c);
    }), a.observe(e, {
      childList: !0
    });
  }
  function s() {
    a && a.disconnect(), r = !0;
  }
  return {
    init: o,
    destroy: s
  };
}
function Z3(e, t, n, a) {
  const r = {};
  let o = null, s = null, i, u = !1;
  function d() {
    i = new IntersectionObserver((m) => {
      u || (m.forEach((g) => {
        const w = t.indexOf(g.target);
        r[w] = g;
      }), o = null, s = null, n.emit("slidesInView"));
    }, {
      root: e.parentElement,
      threshold: a
    }), t.forEach((m) => i.observe(m));
  }
  function c() {
    i && i.disconnect(), u = !0;
  }
  function f(m) {
    return Xo(r).reduce((g, w) => {
      const C = parseInt(w), {
        isIntersecting: S
      } = r[C];
      return (m && S || !m && !S) && g.push(C), g;
    }, []);
  }
  function p(m = !0) {
    if (m && o) return o;
    if (!m && s) return s;
    const g = f(m);
    return m && (o = g), m || (s = g), g;
  }
  return {
    init: d,
    destroy: c,
    get: p
  };
}
function Q3(e, t, n, a, r, o) {
  const {
    measureSize: s,
    startEdge: i,
    endEdge: u
  } = e, d = n[0] && r, c = m(), f = g(), p = n.map(s), v = w();
  function m() {
    if (!d) return 0;
    const S = n[0];
    return vt(t[i] - S[i]);
  }
  function g() {
    if (!d) return 0;
    const S = o.getComputedStyle(En(a));
    return parseFloat(S.getPropertyValue(`margin-${u}`));
  }
  function w() {
    return n.map((S, $, B) => {
      const k = !$, P = kf(B, $);
      return k ? p[$] + c : P ? p[$] + f : B[$ + 1][i] - S[i];
    }).map(vt);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: v,
    startGap: c,
    endGap: f
  };
}
function eR(e, t, n, a, r, o, s, i, u) {
  const {
    startEdge: d,
    endEdge: c,
    direction: f
  } = e, p = Sf(n);
  function v(C, S) {
    return Yo(C).filter(($) => $ % S === 0).map(($) => C.slice($, $ + S));
  }
  function m(C) {
    return C.length ? Yo(C).reduce((S, $, B) => {
      const k = En(S) || 0, P = k === 0, D = $ === Bs(C), q = r[d] - o[k][d], T = r[d] - o[$][c], M = !a && P ? f(s) : 0, O = !a && D ? f(i) : 0, F = vt(T - O - (q + M));
      return B && F > t + u && S.push($), D && S.push(C.length), S;
    }, []).map((S, $, B) => {
      const k = Math.max(B[$ - 1] || 0);
      return C.slice(k, S);
    }) : [];
  }
  function g(C) {
    return p ? v(C, n) : m(C);
  }
  return {
    groupSlides: g
  };
}
function tR(e, t, n, a, r, o, s) {
  const {
    align: i,
    axis: u,
    direction: d,
    startIndex: c,
    loop: f,
    duration: p,
    dragFree: v,
    dragThreshold: m,
    inViewThreshold: g,
    slidesToScroll: w,
    skipSnaps: C,
    containScroll: S,
    watchResize: $,
    watchSlides: B,
    watchDrag: k,
    watchFocus: P
  } = o, D = 2, q = O3(), T = q.measure(t), M = n.map(q.measure), O = T3(u, d), F = O.measureSize(T), J = R3(F), ne = E3(i, F), Q = !f && !!S, G = f || !!S, {
    slideSizes: H,
    slideSizesWithGaps: U,
    startGap: se,
    endGap: ee
  } = Q3(O, T, M, n, G, r), de = eR(O, F, w, f, T, M, se, ee, D), {
    snaps: pe,
    snapsAligned: _e
  } = j3(O, ne, T, M, de), ge = -En(pe) + En(U), {
    snapsContained: Te,
    scrollContainLimit: ce
  } = L3(F, ge, _e, S, D), R = Q ? Te : _e, {
    limit: te
  } = z3(ge, R, f), z = vb(Bs(R), c, f), re = z.clone(), ie = Yo(n), L = ({
    dragHandler: Rt,
    scrollBody: K,
    scrollBounds: Y,
    options: {
      loop: ue
    }
  }) => {
    ue || Y.constrain(Rt.pointerDown()), K.seek();
  }, be = ({
    scrollBody: Rt,
    translate: K,
    location: Y,
    offsetLocation: ue,
    previousLocation: ye,
    scrollLooper: Pe,
    slideLooper: Ae,
    dragHandler: qe,
    animation: rt,
    eventHandler: ct,
    scrollBounds: qt,
    options: {
      loop: at
    }
  }, Bt) => {
    const Vt = Rt.settled(), Xt = !qt.shouldConstrain(), ba = at ? Vt : Vt && Xt, yr = ba && !qe.pointerDown();
    yr && rt.stop();
    const co = Y.get() * Bt + ye.get() * (1 - Bt);
    ue.set(co), at && (Pe.loop(Rt.direction()), Ae.loop()), K.to(ue.get()), yr && ct.emit("settle"), ba || ct.emit("scroll");
  }, xe = q3(a, r, () => L(jt), (Rt) => be(jt, Rt)), Fe = 0.68, Xe = R[z.get()], lt = ko(Xe), De = ko(Xe), Le = ko(Xe), Ue = ko(Xe), We = F3(lt, Le, De, Ue, p, Fe), it = G3(f, R, ge, te, Ue), ut = K3(xe, z, re, We, it, Ue, s), kt = U3(te), un = Jo(), gn = Z3(t, n, s, g), {
    slideRegistry: Oe
  } = W3(Q, S, R, ce, de, ie), Et = Y3(e, n, Oe, ut, We, un, s, P), jt = {
    ownerDocument: a,
    ownerWindow: r,
    eventHandler: s,
    containerRect: T,
    slideRects: M,
    animation: xe,
    axis: O,
    dragHandler: A3(O, e, a, r, Ue, I3(O, r), lt, xe, ut, We, it, z, s, J, v, m, C, Fe, k),
    eventStore: un,
    percentOfView: J,
    index: z,
    indexPrevious: re,
    limit: te,
    location: lt,
    offsetLocation: Le,
    previousLocation: De,
    options: o,
    resizeHandler: V3(t, s, r, n, O, $, q),
    scrollBody: We,
    scrollBounds: N3(te, Le, Ue, We, J),
    scrollLooper: H3(ge, te, Le, [lt, Le, De, Ue]),
    scrollProgress: kt,
    scrollSnapList: R.map(kt.get),
    scrollSnaps: R,
    scrollTarget: it,
    scrollTo: ut,
    slideLooper: X3(O, F, ge, H, U, pe, R, Le, n),
    slideFocus: Et,
    slidesHandler: J3(t, s, B),
    slidesInView: gn,
    slideIndexes: ie,
    slideRegistry: Oe,
    slidesToScroll: de,
    target: Ue,
    translate: mb(O, t)
  };
  return jt;
}
function nR() {
  let e = {}, t;
  function n(d) {
    t = d;
  }
  function a(d) {
    return e[d] || [];
  }
  function r(d) {
    return a(d).forEach((c) => c(t, d)), u;
  }
  function o(d, c) {
    return e[d] = a(d).concat([c]), u;
  }
  function s(d, c) {
    return e[d] = a(d).filter((f) => f !== c), u;
  }
  function i() {
    e = {};
  }
  const u = {
    init: n,
    emit: r,
    off: s,
    on: o,
    clear: i
  };
  return u;
}
const aR = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function rR(e) {
  function t(o, s) {
    return pb(o, s || {});
  }
  function n(o) {
    const s = o.breakpoints || {}, i = Xo(s).filter((u) => e.matchMedia(u).matches).map((u) => s[u]).reduce((u, d) => t(u, d), {});
    return t(o, i);
  }
  function a(o) {
    return o.map((s) => Xo(s.breakpoints || {})).reduce((s, i) => s.concat(i), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: a
  };
}
function oR(e) {
  let t = [];
  function n(o, s) {
    return t = s.filter(({
      options: i
    }) => e.optionsAtMedia(i).active !== !1), t.forEach((i) => i.init(o, e)), s.reduce((i, u) => Object.assign(i, {
      [u.name]: u
    }), {});
  }
  function a() {
    t = t.filter((o) => o.destroy());
  }
  return {
    init: n,
    destroy: a
  };
}
function Hl(e, t, n) {
  const a = e.ownerDocument, r = a.defaultView, o = rR(r), s = oR(o), i = Jo(), u = nR(), {
    mergeOptions: d,
    optionsAtMedia: c,
    optionsMediaQueries: f
  } = o, {
    on: p,
    off: v,
    emit: m
  } = u, g = O;
  let w = !1, C, S = d(aR, Hl.globalOptions), $ = d(S), B = [], k, P, D;
  function q() {
    const {
      container: ie,
      slides: L
    } = $;
    P = (Td(ie) ? e.querySelector(ie) : ie) || e.children[0];
    const xe = Td(L) ? P.querySelectorAll(L) : L;
    D = [].slice.call(xe || P.children);
  }
  function T(ie) {
    const L = tR(e, P, D, a, r, ie, u);
    if (ie.loop && !L.slideLooper.canLoop()) {
      const be = Object.assign({}, ie, {
        loop: !1
      });
      return T(be);
    }
    return L;
  }
  function M(ie, L) {
    w || (S = d(S, ie), $ = c(S), B = L || B, q(), C = T($), f([S, ...B.map(({
      options: be
    }) => be)]).forEach((be) => i.add(be, "change", O)), $.active && (C.translate.to(C.location.get()), C.animation.init(), C.slidesInView.init(), C.slideFocus.init(re), C.eventHandler.init(re), C.resizeHandler.init(re), C.slidesHandler.init(re), C.options.loop && C.slideLooper.loop(), P.offsetParent && D.length && C.dragHandler.init(re), k = s.init(re, B)));
  }
  function O(ie, L) {
    const be = de();
    F(), M(d({
      startIndex: be
    }, ie), L), u.emit("reInit");
  }
  function F() {
    C.dragHandler.destroy(), C.eventStore.clear(), C.translate.clear(), C.slideLooper.clear(), C.resizeHandler.destroy(), C.slidesHandler.destroy(), C.slidesInView.destroy(), C.animation.destroy(), s.destroy(), i.clear();
  }
  function J() {
    w || (w = !0, i.clear(), F(), u.emit("destroy"), u.clear());
  }
  function ne(ie, L, be) {
    !$.active || w || (C.scrollBody.useBaseFriction().useDuration(L === !0 ? 0 : $.duration), C.scrollTo.index(ie, be || 0));
  }
  function Q(ie) {
    const L = C.index.add(1).get();
    ne(L, ie, -1);
  }
  function G(ie) {
    const L = C.index.add(-1).get();
    ne(L, ie, 1);
  }
  function H() {
    return C.index.add(1).get() !== de();
  }
  function U() {
    return C.index.add(-1).get() !== de();
  }
  function se() {
    return C.scrollSnapList;
  }
  function ee() {
    return C.scrollProgress.get(C.offsetLocation.get());
  }
  function de() {
    return C.index.get();
  }
  function pe() {
    return C.indexPrevious.get();
  }
  function _e() {
    return C.slidesInView.get();
  }
  function ge() {
    return C.slidesInView.get(!1);
  }
  function Te() {
    return k;
  }
  function ce() {
    return C;
  }
  function R() {
    return e;
  }
  function te() {
    return P;
  }
  function z() {
    return D;
  }
  const re = {
    canScrollNext: H,
    canScrollPrev: U,
    containerNode: te,
    internalEngine: ce,
    destroy: J,
    off: v,
    on: p,
    emit: m,
    plugins: Te,
    previousScrollSnap: pe,
    reInit: g,
    rootNode: R,
    scrollNext: Q,
    scrollPrev: G,
    scrollProgress: ee,
    scrollSnapList: se,
    scrollTo: ne,
    selectedScrollSnap: de,
    slideNodes: z,
    slidesInView: _e,
    slidesNotInView: ge
  };
  return M(t, n), setTimeout(() => u.emit("init"), 0), re;
}
Hl.globalOptions = void 0;
function Bf(e = {}, t = []) {
  const n = mt(e), a = mt(t);
  let r = n ? e.value : e, o = a ? t.value : t;
  const s = gt(), i = gt();
  function u() {
    i.value && i.value.reInit(r, o);
  }
  return Ce(() => {
    !B3() || !s.value || (Hl.globalOptions = Bf.globalOptions, i.value = Hl(s.value, r, o));
  }), sr(() => {
    i.value && i.value.destroy();
  }), n && ve(e, (d) => {
    Cf(r, d) || (r = d, u());
  }), a && ve(t, (d) => {
    D3(o, d) || (o = d, u());
  }), [s, i];
}
Bf.globalOptions = void 0;
const [sR, lR] = /* @__PURE__ */ G2(
  ({ opts: e, orientation: t, plugins: n }, a) => {
    const [r, o] = Bf(
      {
        ...e,
        axis: t === "horizontal" ? "x" : "y"
      },
      n
    );
    function s() {
      o.value?.scrollPrev();
    }
    function i() {
      o.value?.scrollNext();
    }
    const u = I(!1), d = I(!1);
    function c(f) {
      u.value = f?.canScrollNext() || !1, d.value = f?.canScrollPrev() || !1;
    }
    return Ce(() => {
      o.value && (o.value?.on("init", c), o.value?.on("reInit", c), o.value?.on("select", c), a("init-api", o.value));
    }), {
      carouselRef: r,
      carouselApi: o,
      canScrollPrev: d,
      canScrollNext: u,
      scrollPrev: s,
      scrollNext: i,
      orientation: t
    };
  }
);
function Zi() {
  const e = lR();
  if (!e) throw new Error("useCarousel must be used within a <Carousel />");
  return e;
}
const I7 = /* @__PURE__ */ b({
  __name: "Carousel",
  props: {
    opts: {},
    plugins: {},
    orientation: { default: "horizontal" },
    class: {}
  },
  emits: ["init-api"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, {
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    } = sR(a, r);
    t({
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    });
    function p(v) {
      const m = a.orientation === "vertical" ? "ArrowUp" : "ArrowLeft", g = a.orientation === "vertical" ? "ArrowDown" : "ArrowRight";
      if (v.key === m) {
        v.preventDefault(), f();
        return;
      }
      v.key === g && (v.preventDefault(), c());
    }
    return (v, m) => (h(), W("div", {
      class: ae(l(V)("relative", a.class)),
      role: "region",
      "aria-roledescription": "carousel",
      tabindex: "0",
      onKeydown: p
    }, [
      _(v.$slots, "default", {
        canScrollNext: l(o),
        canScrollPrev: l(s),
        carouselApi: l(i),
        carouselRef: l(u),
        orientation: l(d),
        scrollNext: l(c),
        scrollPrev: l(f)
      })
    ], 34));
  }
}), O7 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CarouselContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { carouselRef: n, orientation: a } = Zi();
    return (r, o) => (h(), W("div", {
      ref_key: "carouselRef",
      ref: n,
      class: "overflow-hidden"
    }, [
      we("div", A({
        class: l(V)("flex", l(a) === "horizontal" ? "-ml-4" : "-mt-4 flex-col", t.class)
      }, r.$attrs), [
        _(r.$slots, "default")
      ], 16)
    ], 512));
  }
}), R7 = /* @__PURE__ */ b({
  __name: "CarouselItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n } = Zi();
    return (a, r) => (h(), W("div", {
      role: "group",
      "aria-roledescription": "slide",
      class: ae(
        l(V)(
          "min-w-0 shrink-0 grow-0 basis-full",
          l(n) === "horizontal" ? "pl-4" : "pt-4",
          t.class
        )
      )
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), V7 = /* @__PURE__ */ b({
  __name: "CarouselPrevious",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollPrev: a, scrollPrev: r } = Zi();
    return (o, s) => (h(), x(l(Ss), {
      disabled: !l(a),
      class: ae(
        l(V)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -left-12 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: y(() => [
        _(o.$slots, "default", {}, () => [
          N(l(FI), { class: "size-4 text-current" }),
          s[0] || (s[0] = we("span", { class: "sr-only" }, "Previous Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
}), F7 = /* @__PURE__ */ b({
  __name: "CarouselNext",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollNext: a, scrollNext: r } = Zi();
    return (o, s) => (h(), x(l(Ss), {
      disabled: !l(a),
      class: ae(
        l(V)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -right-12 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: y(() => [
        _(o.$slots, "default", {}, () => [
          N(l(NI), { class: "size-4 text-current" }),
          s[0] || (s[0] = we("span", { class: "sr-only" }, "Next Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
});
var Id = "http://www.w3.org/1999/xhtml";
const Av = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Id,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Qi(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Av.hasOwnProperty(t) ? { space: Av[t], local: e } : e;
}
function iR(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Id && t.documentElement.namespaceURI === Id ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function uR(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function hb(e) {
  var t = Qi(e);
  return (t.local ? uR : iR)(t);
}
function dR() {
}
function Df(e) {
  return e == null ? dR : function() {
    return this.querySelector(e);
  };
}
function cR(e) {
  typeof e != "function" && (e = Df(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = new Array(s), u, d, c = 0; c < s; ++c)
      (u = o[c]) && (d = e.call(u, u.__data__, c, o)) && ("__data__" in u && (d.__data__ = u.__data__), i[c] = d);
  return new hn(a, this._parents);
}
function fR(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function pR() {
  return [];
}
function gb(e) {
  return e == null ? pR : function() {
    return this.querySelectorAll(e);
  };
}
function vR(e) {
  return function() {
    return fR(e.apply(this, arguments));
  };
}
function mR(e) {
  typeof e == "function" ? e = vR(e) : e = gb(e);
  for (var t = this._groups, n = t.length, a = [], r = [], o = 0; o < n; ++o)
    for (var s = t[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && (a.push(e.call(u, u.__data__, d, s)), r.push(u));
  return new hn(a, r);
}
function yb(e) {
  return function() {
    return this.matches(e);
  };
}
function bb(e) {
  return function(t) {
    return t.matches(e);
  };
}
var hR = Array.prototype.find;
function gR(e) {
  return function() {
    return hR.call(this.children, e);
  };
}
function yR() {
  return this.firstElementChild;
}
function bR(e) {
  return this.select(e == null ? yR : gR(typeof e == "function" ? e : bb(e)));
}
var _R = Array.prototype.filter;
function wR() {
  return Array.from(this.children);
}
function xR(e) {
  return function() {
    return _R.call(this.children, e);
  };
}
function CR(e) {
  return this.selectAll(e == null ? wR : xR(typeof e == "function" ? e : bb(e)));
}
function SR(e) {
  typeof e != "function" && (e = yb(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new hn(a, this._parents);
}
function _b(e) {
  return new Array(e.length);
}
function $R() {
  return new hn(this._enter || this._groups.map(_b), this._parents);
}
function Ul(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Ul.prototype = {
  constructor: Ul,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function kR(e) {
  return function() {
    return e;
  };
}
function BR(e, t, n, a, r, o) {
  for (var s = 0, i, u = t.length, d = o.length; s < d; ++s)
    (i = t[s]) ? (i.__data__ = o[s], a[s] = i) : n[s] = new Ul(e, o[s]);
  for (; s < u; ++s)
    (i = t[s]) && (r[s] = i);
}
function DR(e, t, n, a, r, o, s) {
  var i, u, d = /* @__PURE__ */ new Map(), c = t.length, f = o.length, p = new Array(c), v;
  for (i = 0; i < c; ++i)
    (u = t[i]) && (p[i] = v = s.call(u, u.__data__, i, t) + "", d.has(v) ? r[i] = u : d.set(v, u));
  for (i = 0; i < f; ++i)
    v = s.call(e, o[i], i, o) + "", (u = d.get(v)) ? (a[i] = u, u.__data__ = o[i], d.delete(v)) : n[i] = new Ul(e, o[i]);
  for (i = 0; i < c; ++i)
    (u = t[i]) && d.get(p[i]) === u && (r[i] = u);
}
function PR(e) {
  return e.__data__;
}
function MR(e, t) {
  if (!arguments.length) return Array.from(this, PR);
  var n = t ? DR : BR, a = this._parents, r = this._groups;
  typeof e != "function" && (e = kR(e));
  for (var o = r.length, s = new Array(o), i = new Array(o), u = new Array(o), d = 0; d < o; ++d) {
    var c = a[d], f = r[d], p = f.length, v = ER(e.call(c, c && c.__data__, d, a)), m = v.length, g = i[d] = new Array(m), w = s[d] = new Array(m), C = u[d] = new Array(p);
    n(c, f, g, w, C, v, t);
    for (var S = 0, $ = 0, B, k; S < m; ++S)
      if (B = g[S]) {
        for (S >= $ && ($ = S + 1); !(k = w[$]) && ++$ < m; ) ;
        B._next = k || null;
      }
  }
  return s = new hn(s, a), s._enter = i, s._exit = u, s;
}
function ER(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function qR() {
  return new hn(this._exit || this._groups.map(_b), this._parents);
}
function TR(e, t, n) {
  var a = this.enter(), r = this, o = this.exit();
  return typeof e == "function" ? (a = e(a), a && (a = a.selection())) : a = a.append(e + ""), t != null && (r = t(r), r && (r = r.selection())), n == null ? o.remove() : n(o), a && r ? a.merge(r).order() : r;
}
function AR(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, a = t._groups, r = n.length, o = a.length, s = Math.min(r, o), i = new Array(r), u = 0; u < s; ++u)
    for (var d = n[u], c = a[u], f = d.length, p = i[u] = new Array(f), v, m = 0; m < f; ++m)
      (v = d[m] || c[m]) && (p[m] = v);
  for (; u < r; ++u)
    i[u] = n[u];
  return new hn(i, this._parents);
}
function IR() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var a = e[t], r = a.length - 1, o = a[r], s; --r >= 0; )
      (s = a[r]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
  return this;
}
function OR(e) {
  e || (e = RR);
  function t(f, p) {
    return f && p ? e(f.__data__, p.__data__) : !f - !p;
  }
  for (var n = this._groups, a = n.length, r = new Array(a), o = 0; o < a; ++o) {
    for (var s = n[o], i = s.length, u = r[o] = new Array(i), d, c = 0; c < i; ++c)
      (d = s[c]) && (u[c] = d);
    u.sort(t);
  }
  return new hn(r, this._parents).order();
}
function RR(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function VR() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function FR() {
  return Array.from(this);
}
function NR() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length; r < o; ++r) {
      var s = a[r];
      if (s) return s;
    }
  return null;
}
function LR() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function zR() {
  return !this.node();
}
function HR(e) {
  for (var t = this._groups, n = 0, a = t.length; n < a; ++n)
    for (var r = t[n], o = 0, s = r.length, i; o < s; ++o)
      (i = r[o]) && e.call(i, i.__data__, o, r);
  return this;
}
function UR(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function jR(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function WR(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function GR(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function KR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function YR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function XR(e, t) {
  var n = Qi(e);
  if (arguments.length < 2) {
    var a = this.node();
    return n.local ? a.getAttributeNS(n.space, n.local) : a.getAttribute(n);
  }
  return this.each((t == null ? n.local ? jR : UR : typeof t == "function" ? n.local ? YR : KR : n.local ? GR : WR)(n, t));
}
function wb(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function JR(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function ZR(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function QR(e, t, n) {
  return function() {
    var a = t.apply(this, arguments);
    a == null ? this.style.removeProperty(e) : this.style.setProperty(e, a, n);
  };
}
function eV(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? JR : typeof t == "function" ? QR : ZR)(e, t, n ?? "")) : Hr(this.node(), e);
}
function Hr(e, t) {
  return e.style.getPropertyValue(t) || wb(e).getComputedStyle(e, null).getPropertyValue(t);
}
function tV(e) {
  return function() {
    delete this[e];
  };
}
function nV(e, t) {
  return function() {
    this[e] = t;
  };
}
function aV(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function rV(e, t) {
  return arguments.length > 1 ? this.each((t == null ? tV : typeof t == "function" ? aV : nV)(e, t)) : this.node()[e];
}
function xb(e) {
  return e.trim().split(/^|\s+/);
}
function Pf(e) {
  return e.classList || new Cb(e);
}
function Cb(e) {
  this._node = e, this._names = xb(e.getAttribute("class") || "");
}
Cb.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Sb(e, t) {
  for (var n = Pf(e), a = -1, r = t.length; ++a < r; ) n.add(t[a]);
}
function $b(e, t) {
  for (var n = Pf(e), a = -1, r = t.length; ++a < r; ) n.remove(t[a]);
}
function oV(e) {
  return function() {
    Sb(this, e);
  };
}
function sV(e) {
  return function() {
    $b(this, e);
  };
}
function lV(e, t) {
  return function() {
    (t.apply(this, arguments) ? Sb : $b)(this, e);
  };
}
function iV(e, t) {
  var n = xb(e + "");
  if (arguments.length < 2) {
    for (var a = Pf(this.node()), r = -1, o = n.length; ++r < o; ) if (!a.contains(n[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? lV : t ? oV : sV)(n, t));
}
function uV() {
  this.textContent = "";
}
function dV(e) {
  return function() {
    this.textContent = e;
  };
}
function cV(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function fV(e) {
  return arguments.length ? this.each(e == null ? uV : (typeof e == "function" ? cV : dV)(e)) : this.node().textContent;
}
function pV() {
  this.innerHTML = "";
}
function vV(e) {
  return function() {
    this.innerHTML = e;
  };
}
function mV(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function hV(e) {
  return arguments.length ? this.each(e == null ? pV : (typeof e == "function" ? mV : vV)(e)) : this.node().innerHTML;
}
function gV() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function yV() {
  return this.each(gV);
}
function bV() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function _V() {
  return this.each(bV);
}
function wV(e) {
  var t = typeof e == "function" ? e : hb(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function xV() {
  return null;
}
function CV(e, t) {
  var n = typeof e == "function" ? e : hb(e), a = t == null ? xV : typeof t == "function" ? t : Df(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), a.apply(this, arguments) || null);
  });
}
function SV() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function $V() {
  return this.each(SV);
}
function kV() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function BV() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function DV(e) {
  return this.select(e ? BV : kV);
}
function PV(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function MV(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function EV(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", a = t.indexOf(".");
    return a >= 0 && (n = t.slice(a + 1), t = t.slice(0, a)), { type: t, name: n };
  });
}
function qV(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, a = -1, r = t.length, o; n < r; ++n)
        o = t[n], (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++a] = o;
      ++a ? t.length = a : delete this.__on;
    }
  };
}
function TV(e, t, n) {
  return function() {
    var a = this.__on, r, o = MV(t);
    if (a) {
      for (var s = 0, i = a.length; s < i; ++s)
        if ((r = a[s]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = o, r.options = n), r.value = t;
          return;
        }
    }
    this.addEventListener(e.type, o, n), r = { type: e.type, name: e.name, value: t, listener: o, options: n }, a ? a.push(r) : this.__on = [r];
  };
}
function AV(e, t, n) {
  var a = EV(e + ""), r, o = a.length, s;
  if (arguments.length < 2) {
    var i = this.node().__on;
    if (i) {
      for (var u = 0, d = i.length, c; u < d; ++u)
        for (r = 0, c = i[u]; r < o; ++r)
          if ((s = a[r]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (i = t ? TV : qV, r = 0; r < o; ++r) this.each(i(a[r], t, n));
  return this;
}
function kb(e, t, n) {
  var a = wb(e), r = a.CustomEvent;
  typeof r == "function" ? r = new r(t, n) : (r = a.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r);
}
function IV(e, t) {
  return function() {
    return kb(this, e, t);
  };
}
function OV(e, t) {
  return function() {
    return kb(this, e, t.apply(this, arguments));
  };
}
function RV(e, t) {
  return this.each((typeof t == "function" ? OV : IV)(e, t));
}
function* VV() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length, s; r < o; ++r)
      (s = a[r]) && (yield s);
}
var Bb = [null];
function hn(e, t) {
  this._groups = e, this._parents = t;
}
function Ds() {
  return new hn([[document.documentElement]], Bb);
}
function FV() {
  return this;
}
hn.prototype = Ds.prototype = {
  constructor: hn,
  select: cR,
  selectAll: mR,
  selectChild: bR,
  selectChildren: CR,
  filter: SR,
  data: MR,
  enter: $R,
  exit: qR,
  join: TR,
  merge: AR,
  selection: FV,
  order: IR,
  sort: OR,
  call: VR,
  nodes: FR,
  node: NR,
  size: LR,
  empty: zR,
  each: HR,
  attr: XR,
  style: eV,
  property: rV,
  classed: iV,
  text: fV,
  html: hV,
  raise: yV,
  lower: _V,
  append: wV,
  insert: CV,
  remove: $V,
  clone: DV,
  datum: PV,
  on: AV,
  dispatch: RV,
  [Symbol.iterator]: VV
};
function qa(e) {
  return typeof e == "string" ? new hn([[document.querySelector(e)]], [document.documentElement]) : new hn([[e]], Bb);
}
function NV(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function jl(e, t) {
  if (e = NV(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var a = n.createSVGPoint();
      return a.x = e.clientX, a.y = e.clientY, a = a.matrixTransform(t.getScreenCTM().inverse()), [a.x, a.y];
    }
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect();
      return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
var Ao;
(function(e) {
  e[e.SVG = 0] = "SVG", e[e.HTML = 1] = "HTML";
})(Ao || (Ao = {}));
var Od;
(function(e) {
  e.Fit = "fit", e.Extend = "extend", e.FitWidth = "fit_width";
})(Od || (Od = {}));
function Io(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function LV(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Mf(e) {
  let t, n, a;
  e.length !== 2 ? (t = Io, n = (i, u) => Io(e(i), u), a = (i, u) => e(i) - u) : (t = e === Io || e === LV ? e : zV, n = e, a = e);
  function r(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) < 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function o(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) <= 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function s(i, u, d = 0, c = i.length) {
    const f = r(i, u, d, c - 1);
    return f > d && a(i[f - 1], u) > -a(i[f], u) ? f - 1 : f;
  }
  return { left: r, center: s, right: o };
}
function zV() {
  return 0;
}
function Db(e) {
  return e === null ? NaN : +e;
}
const Pb = Mf(Io), Ps = Pb.right, HV = Pb.left;
Mf(Db).center;
class Iv extends Map {
  constructor(t, n = WV) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [a, r] of t) this.set(a, r);
  }
  get(t) {
    return super.get(Ov(this, t));
  }
  has(t) {
    return super.has(Ov(this, t));
  }
  set(t, n) {
    return super.set(UV(this, t), n);
  }
  delete(t) {
    return super.delete(jV(this, t));
  }
}
function Ov({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : n;
}
function UV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : (e.set(a, n), n);
}
function jV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) && (n = e.get(a), e.delete(a)), n;
}
function WV(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const GV = Math.sqrt(50), KV = Math.sqrt(10), YV = Math.sqrt(2);
function Wl(e, t, n) {
  const a = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(a)), o = a / Math.pow(10, r), s = o >= GV ? 10 : o >= KV ? 5 : o >= YV ? 2 : 1;
  let i, u, d;
  return r < 0 ? (d = Math.pow(10, -r) / s, i = Math.round(e * d), u = Math.round(t * d), i / d < e && ++i, u / d > t && --u, d = -d) : (d = Math.pow(10, r) * s, i = Math.round(e / d), u = Math.round(t / d), i * d < e && ++i, u * d > t && --u), u < i && 0.5 <= n && n < 2 ? Wl(e, t, n * 2) : [i, u, d];
}
function Rd(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const a = t < e, [r, o, s] = a ? Wl(t, e, n) : Wl(e, t, n);
  if (!(o >= r)) return [];
  const i = o - r + 1, u = new Array(i);
  if (a)
    if (s < 0) for (let d = 0; d < i; ++d) u[d] = (o - d) / -s;
    else for (let d = 0; d < i; ++d) u[d] = (o - d) * s;
  else if (s < 0) for (let d = 0; d < i; ++d) u[d] = (r + d) / -s;
  else for (let d = 0; d < i; ++d) u[d] = (r + d) * s;
  return u;
}
function Vd(e, t, n) {
  return t = +t, e = +e, n = +n, Wl(e, t, n)[2];
}
function Fd(e, t, n) {
  t = +t, e = +e, n = +n;
  const a = t < e, r = a ? Vd(t, e, n) : Vd(e, t, n);
  return (a ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function Rv(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function Vv(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function XV(e, t, n = Db) {
  if (!(!(a = e.length) || isNaN(t = +t))) {
    if (t <= 0 || a < 2) return +n(e[0], 0, e);
    if (t >= 1) return +n(e[a - 1], a - 1, e);
    var a, r = (a - 1) * t, o = Math.floor(r), s = +n(e[o], o, e), i = +n(e[o + 1], o + 1, e);
    return s + (i - s) * (r - o);
  }
}
function JV(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var a = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++a < r; )
    o[a] = e + a * n;
  return o;
}
function ZV(e, t, n) {
  var a = {}, r = a.noTrailing, o = r === void 0 ? !1 : r, s = a.noLeading, i = s === void 0 ? !1 : s, u = a.debounceMode, d = u === void 0 ? void 0 : u, c, f = !1, p = 0;
  function v() {
    c && clearTimeout(c);
  }
  function m(w) {
    var C = w || {}, S = C.upcomingOnly, $ = S === void 0 ? !1 : S;
    v(), f = !$;
  }
  function g() {
    for (var w = arguments.length, C = new Array(w), S = 0; S < w; S++)
      C[S] = arguments[S];
    var $ = this, B = Date.now() - p;
    if (f)
      return;
    function k() {
      p = Date.now(), t.apply($, C);
    }
    function P() {
      c = void 0;
    }
    !i && d && !c && k(), v(), d === void 0 && B > e ? i ? (p = Date.now(), o || (c = setTimeout(d ? P : k, e))) : k() : o !== !0 && (c = setTimeout(d ? P : k, d === void 0 ? e - B : e));
  }
  return g.cancel = m, g;
}
var ia;
(function(e) {
  e.Left = "left", e.Right = "right", e.Auto = "auto";
})(ia || (ia = {}));
const Oo = (e) => typeof e == "number", Ef = (e) => typeof e == "function", qf = (e) => Array.isArray(e), QV = (e) => e instanceof Object, Gl = (e) => e.constructor.name !== "Function" && e.constructor.name !== "Object", Fv = (e) => QV(e) && !qf(e) && !Ef(e) && !Gl(e), Nd = (e, t, n = [], a = /* @__PURE__ */ new Set()) => {
  if (Array.isArray(e)) {
    if (!Array.isArray(t) || e.length !== t.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (let r = 0; r < e.length; r++)
      if (!Nd(e[r], t[r], n, a))
        return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (typeof e == "object" && e !== null && t !== null) {
    if (typeof t != "object")
      return !1;
    if (e === t)
      return !0;
    const r = Object.keys(e).filter((s) => !n.includes(s)), o = Object.keys(t).filter((s) => !n.includes(s));
    if (r.length !== o.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (const s of r)
      if (!Nd(e[s], t[s], n, a))
        return !1;
    return !0;
  }
  return e === t;
}, Kl = (e, t = /* @__PURE__ */ new Map()) => {
  if (typeof e != "object" || e === null)
    return e;
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof Array) {
    const n = [];
    t.set(e, n);
    for (const a of e)
      n.push(t.has(a) ? t.get(a) : Kl(a, t));
    return n;
  }
  if (Gl(e))
    return e;
  if (e instanceof Object) {
    const n = {};
    t.set(e, n);
    const a = e;
    return Object.keys(e).reduce((r, o) => (r[o] = t.has(a[o]) ? t.get(a[o]) : Kl(a[o], t), r), n), n;
  }
  return e;
}, eu = (e, t, n = /* @__PURE__ */ new Map()) => {
  if (!e || !t || e === t)
    return e;
  const a = Gl(e) ? e : Kl(e);
  return n.has(t) ? n.get(t) : (n.set(t, a), Object.keys(t).forEach((r) => {
    r === "__proto__" || r === "constructor" || (Fv(e[r]) && Fv(t[r]) ? a[r] = eu(e[r], t[r], n) : Gl(t) ? a[r] = t : a[r] = Kl(t[r]));
  }), a);
}, Mb = (e, t) => (e = Object.assign({}, e), t.forEach((n) => delete e[n]), e), Yl = (e, t, n) => ZV(t, e);
function Eb(e, t, n) {
  return Ef(t) ? t(e, n) : t;
}
function qb(e, t, n) {
  return Eb(e, t, n);
}
function pn(e, t, n) {
  return Eb(e, t, n);
}
function Nv(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function eF(e, t, ...n) {
  const a = [];
  let r = 0, o = 0;
  for (const s of n) {
    const i = pn(e, s, t) || 0;
    i >= 0 ? a.push(r += i) : a.push(o += i);
  }
  return a;
}
function tF(e, ...t) {
  return e ? Vv(e, (a, r) => Vv(t, (o) => pn(a, o, r))) : void 0;
}
function nF(e, ...t) {
  return e ? Rv(e, (a, r) => Rv(t, (o) => pn(a, o, r))) : void 0;
}
function Hu(e, ...t) {
  return [tF(e, ...t), nF(e, ...t)];
}
function Xl(e, t, n, a = ia.Auto) {
  if (e.length <= 1)
    return e[0];
  const o = e.map((u, d) => [u, d]).sort(([u, d], [c, f]) => pn(u, n, d) - pn(c, n, f)), s = o.map(([u, d]) => pn(u, n, d)), i = a === ia.Right ? HV(s, t, 0, e.length - 1) : Ps(s, t, 1, e.length);
  return a === ia.Right ? o[i][0] : a === ia.Left ? o[i - 1][0] : t - s[i - 1] > s[i] - t ? o[i][0] : o[i - 1][0];
}
function aF(e, t, n, a = !1) {
  if (!n)
    return [];
  const r = e.filter((o, s) => {
    const i = pn(o, n, s);
    return i >= t[0] && i <= t[1];
  });
  if (a) {
    if (r.length === 0) {
      const f = Xl(e, t[0], n, ia.Left), p = Xl(e, t[1], n, ia.Right);
      return [f, p].filter(Boolean);
    }
    const o = r[0], s = r[r.length - 1], i = e.findIndex((f) => f === o), u = e.findIndex((f) => f === s), d = Math.max(0, i - 1), c = Math.min(e.length - 1, u + 1);
    return e.slice(d, c + 1);
  }
  return r;
}
const rF = (e) => e == null ? [] : Array.isArray(e) ? e : [e];
function oF(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function sF(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var lF = /* @__PURE__ */ (function() {
  function e(n) {
    var a = this;
    this._insertTag = function(r) {
      var o;
      a.tags.length === 0 ? a.insertionPoint ? o = a.insertionPoint.nextSibling : a.prepend ? o = a.container.firstChild : o = a.before : o = a.tags[a.tags.length - 1].nextSibling, a.container.insertBefore(r, o), a.tags.push(r);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(a) {
    a.forEach(this._insertTag);
  }, t.insert = function(a) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(sF(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = oF(r);
      try {
        o.insertRule(a, o.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(a));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(a) {
      var r;
      return (r = a.parentNode) == null ? void 0 : r.removeChild(a);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), Ut = "-ms-", Jl = "-moz-", et = "-webkit-", Tb = "comm", Tf = "rule", Af = "decl", iF = "@import", Ab = "@keyframes", uF = "@layer", dF = Math.abs, tu = String.fromCharCode, cF = Object.assign;
function fF(e, t) {
  return Ft(e, 0) ^ 45 ? (((t << 2 ^ Ft(e, 0)) << 2 ^ Ft(e, 1)) << 2 ^ Ft(e, 2)) << 2 ^ Ft(e, 3) : 0;
}
function Ib(e) {
  return e.trim();
}
function pF(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function nt(e, t, n) {
  return e.replace(t, n);
}
function Ld(e, t) {
  return e.indexOf(t);
}
function Ft(e, t) {
  return e.charCodeAt(t) | 0;
}
function Zo(e, t, n) {
  return e.slice(t, n);
}
function Un(e) {
  return e.length;
}
function If(e) {
  return e.length;
}
function Js(e, t) {
  return t.push(e), e;
}
function vF(e, t) {
  return e.map(t).join("");
}
var nu = 1, Ur = 1, Ob = 0, on = 0, Ct = 0, io = "";
function au(e, t, n, a, r, o, s) {
  return { value: e, root: t, parent: n, type: a, props: r, children: o, line: nu, column: Ur, length: s, return: "" };
}
function go(e, t) {
  return cF(au("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function mF() {
  return Ct;
}
function hF() {
  return Ct = on > 0 ? Ft(io, --on) : 0, Ur--, Ct === 10 && (Ur = 1, nu--), Ct;
}
function mn() {
  return Ct = on < Ob ? Ft(io, on++) : 0, Ur++, Ct === 10 && (Ur = 1, nu++), Ct;
}
function Kn() {
  return Ft(io, on);
}
function ml() {
  return on;
}
function Ms(e, t) {
  return Zo(io, e, t);
}
function Qo(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Rb(e) {
  return nu = Ur = 1, Ob = Un(io = e), on = 0, [];
}
function Vb(e) {
  return io = "", e;
}
function hl(e) {
  return Ib(Ms(on - 1, zd(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function gF(e) {
  for (; (Ct = Kn()) && Ct < 33; )
    mn();
  return Qo(e) > 2 || Qo(Ct) > 3 ? "" : " ";
}
function yF(e, t) {
  for (; --t && mn() && !(Ct < 48 || Ct > 102 || Ct > 57 && Ct < 65 || Ct > 70 && Ct < 97); )
    ;
  return Ms(e, ml() + (t < 6 && Kn() == 32 && mn() == 32));
}
function zd(e) {
  for (; mn(); )
    switch (Ct) {
      // ] ) " '
      case e:
        return on;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && zd(Ct);
        break;
      // (
      case 40:
        e === 41 && zd(e);
        break;
      // \
      case 92:
        mn();
        break;
    }
  return on;
}
function bF(e, t) {
  for (; mn() && e + Ct !== 57; )
    if (e + Ct === 84 && Kn() === 47)
      break;
  return "/*" + Ms(t, on - 1) + "*" + tu(e === 47 ? e : mn());
}
function _F(e) {
  for (; !Qo(Kn()); )
    mn();
  return Ms(e, on);
}
function wF(e) {
  return Vb(gl("", null, null, null, [""], e = Rb(e), 0, [0], e));
}
function gl(e, t, n, a, r, o, s, i, u) {
  for (var d = 0, c = 0, f = s, p = 0, v = 0, m = 0, g = 1, w = 1, C = 1, S = 0, $ = "", B = r, k = o, P = a, D = $; w; )
    switch (m = S, S = mn()) {
      // (
      case 40:
        if (m != 108 && Ft(D, f - 1) == 58) {
          Ld(D += nt(hl(S), "&", "&\f"), "&\f") != -1 && (C = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        D += hl(S);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        D += gF(m);
        break;
      // \
      case 92:
        D += yF(ml() - 1, 7);
        continue;
      // /
      case 47:
        switch (Kn()) {
          case 42:
          case 47:
            Js(xF(bF(mn(), ml()), t, n), u);
            break;
          default:
            D += "/";
        }
        break;
      // {
      case 123 * g:
        i[d++] = Un(D) * C;
      // } ; \0
      case 125 * g:
      case 59:
      case 0:
        switch (S) {
          // \0 }
          case 0:
          case 125:
            w = 0;
          // ;
          case 59 + c:
            C == -1 && (D = nt(D, /\f/g, "")), v > 0 && Un(D) - f && Js(v > 32 ? zv(D + ";", a, n, f - 1) : zv(nt(D, " ", "") + ";", a, n, f - 2), u);
            break;
          // @ ;
          case 59:
            D += ";";
          // { rule/at-rule
          default:
            if (Js(P = Lv(D, t, n, d, c, r, i, $, B = [], k = [], f), o), S === 123)
              if (c === 0)
                gl(D, t, P, P, B, o, f, i, k);
              else
                switch (p === 99 && Ft(D, 3) === 110 ? 100 : p) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    gl(e, P, P, a && Js(Lv(e, P, P, 0, 0, r, i, $, r, B = [], f), k), r, k, f, i, a ? B : k);
                    break;
                  default:
                    gl(D, P, P, P, [""], k, 0, i, k);
                }
        }
        d = c = v = 0, g = C = 1, $ = D = "", f = s;
        break;
      // :
      case 58:
        f = 1 + Un(D), v = m;
      default:
        if (g < 1) {
          if (S == 123)
            --g;
          else if (S == 125 && g++ == 0 && hF() == 125)
            continue;
        }
        switch (D += tu(S), S * g) {
          // &
          case 38:
            C = c > 0 ? 1 : (D += "\f", -1);
            break;
          // ,
          case 44:
            i[d++] = (Un(D) - 1) * C, C = 1;
            break;
          // @
          case 64:
            Kn() === 45 && (D += hl(mn())), p = Kn(), c = f = Un($ = D += _F(ml())), S++;
            break;
          // -
          case 45:
            m === 45 && Un(D) == 2 && (g = 0);
        }
    }
  return o;
}
function Lv(e, t, n, a, r, o, s, i, u, d, c) {
  for (var f = r - 1, p = r === 0 ? o : [""], v = If(p), m = 0, g = 0, w = 0; m < a; ++m)
    for (var C = 0, S = Zo(e, f + 1, f = dF(g = s[m])), $ = e; C < v; ++C)
      ($ = Ib(g > 0 ? p[C] + " " + S : nt(S, /&\f/g, p[C]))) && (u[w++] = $);
  return au(e, t, n, r === 0 ? Tf : i, u, d, c);
}
function xF(e, t, n) {
  return au(e, t, n, Tb, tu(mF()), Zo(e, 2, -2), 0);
}
function zv(e, t, n, a) {
  return au(e, t, n, Af, Zo(e, 0, a), Zo(e, a + 1, -1), a);
}
function Ir(e, t) {
  for (var n = "", a = If(e), r = 0; r < a; r++)
    n += t(e[r], r, e, t) || "";
  return n;
}
function CF(e, t, n, a) {
  switch (e.type) {
    case uF:
      if (e.children.length) break;
    case iF:
    case Af:
      return e.return = e.return || e.value;
    case Tb:
      return "";
    case Ab:
      return e.return = e.value + "{" + Ir(e.children, a) + "}";
    case Tf:
      e.value = e.props.join(",");
  }
  return Un(n = Ir(e.children, a)) ? e.return = e.value + "{" + n + "}" : "";
}
function SF(e) {
  var t = If(e);
  return function(n, a, r, o) {
    for (var s = "", i = 0; i < t; i++)
      s += e[i](n, a, r, o) || "";
    return s;
  };
}
function $F(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function kF(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var BF = function(t, n, a) {
  for (var r = 0, o = 0; r = o, o = Kn(), r === 38 && o === 12 && (n[a] = 1), !Qo(o); )
    mn();
  return Ms(t, on);
}, DF = function(t, n) {
  var a = -1, r = 44;
  do
    switch (Qo(r)) {
      case 0:
        r === 38 && Kn() === 12 && (n[a] = 1), t[a] += BF(on - 1, n, a);
        break;
      case 2:
        t[a] += hl(r);
        break;
      case 4:
        if (r === 44) {
          t[++a] = Kn() === 58 ? "&\f" : "", n[a] = t[a].length;
          break;
        }
      // fallthrough
      default:
        t[a] += tu(r);
    }
  while (r = mn());
  return t;
}, PF = function(t, n) {
  return Vb(DF(Rb(t), n));
}, Hv = /* @__PURE__ */ new WeakMap(), MF = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, a = t.parent, r = t.column === a.column && t.line === a.line; a.type !== "rule"; )
      if (a = a.parent, !a) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Hv.get(a)) && !r) {
      Hv.set(t, !0);
      for (var o = [], s = PF(n, o), i = a.props, u = 0, d = 0; u < s.length; u++)
        for (var c = 0; c < i.length; c++, d++)
          t.props[d] = o[u] ? s[u].replace(/&\f/g, i[c]) : i[c] + " " + s[u];
    }
  }
}, EF = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function Fb(e, t) {
  switch (fF(e, t)) {
    // color-adjust
    case 5103:
      return et + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return et + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return et + e + Jl + e + Ut + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return et + e + Ut + e + e;
    // order
    case 6165:
      return et + e + Ut + "flex-" + e + e;
    // align-items
    case 5187:
      return et + e + nt(e, /(\w+).+(:[^]+)/, et + "box-$1$2" + Ut + "flex-$1$2") + e;
    // align-self
    case 5443:
      return et + e + Ut + "flex-item-" + nt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return et + e + Ut + "flex-line-pack" + nt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return et + e + Ut + nt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return et + e + Ut + nt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return et + "box-" + nt(e, "-grow", "") + et + e + Ut + nt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return et + nt(e, /([^-])(transform)/g, "$1" + et + "$2") + e;
    // cursor
    case 6187:
      return nt(nt(nt(e, /(zoom-|grab)/, et + "$1"), /(image-set)/, et + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return nt(e, /(image-set\([^]*)/, et + "$1$`$1");
    // justify-content
    case 4968:
      return nt(nt(e, /(.+:)(flex-)?(.*)/, et + "box-pack:$3" + Ut + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + et + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return nt(e, /(.+)-inline(.+)/, et + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Un(e) - 1 - t > 6) switch (Ft(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (Ft(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return nt(e, /(.+:)(.+)-([^]+)/, "$1" + et + "$2-$3$1" + Jl + (Ft(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Ld(e, "stretch") ? Fb(nt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (Ft(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (Ft(e, Un(e) - 3 - (~Ld(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return nt(e, ":", ":" + et) + e;
        // (inline-)?fl(e)x
        case 101:
          return nt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + et + (Ft(e, 14) === 45 ? "inline-" : "") + "box$3$1" + et + "$2$3$1" + Ut + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (Ft(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return et + e + Ut + nt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return et + e + Ut + nt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return et + e + Ut + nt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return et + e + Ut + e + e;
  }
  return e;
}
var qF = function(t, n, a, r) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Af:
      t.return = Fb(t.value, t.length);
      break;
    case Ab:
      return Ir([go(t, {
        value: nt(t.value, "@", "@" + et)
      })], r);
    case Tf:
      if (t.length) return vF(t.props, function(o) {
        switch (pF(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Ir([go(t, {
              props: [nt(o, /:(read-\w+)/, ":" + Jl + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return Ir([go(t, {
              props: [nt(o, /:(plac\w+)/, ":" + et + "input-$1")]
            }), go(t, {
              props: [nt(o, /:(plac\w+)/, ":" + Jl + "$1")]
            }), go(t, {
              props: [nt(o, /:(plac\w+)/, Ut + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, TF = [qF], AF = function(t) {
  var n = t.key;
  if (n === "css") {
    var a = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(a, function(g) {
      var w = g.getAttribute("data-emotion");
      w.indexOf(" ") !== -1 && (document.head.appendChild(g), g.setAttribute("data-s", ""));
    });
  }
  var r = t.stylisPlugins || TF, o = {}, s, i = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(g) {
      for (var w = g.getAttribute("data-emotion").split(" "), C = 1; C < w.length; C++)
        o[w[C]] = !0;
      i.push(g);
    }
  );
  var u, d = [MF, EF];
  {
    var c, f = [CF, $F(function(g) {
      c.insert(g);
    })], p = SF(d.concat(r, f)), v = function(w) {
      return Ir(wF(w), p);
    };
    u = function(w, C, S, $) {
      c = S, v(w ? w + "{" + C.styles + "}" : C.styles), $ && (m.inserted[C.name] = !0);
    };
  }
  var m = {
    key: n,
    sheet: new lF({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return m.sheet.hydrate(i), m;
};
function IF(e) {
  for (var t = 0, n, a = 0, r = e.length; r >= 4; ++a, r -= 4)
    n = e.charCodeAt(a) & 255 | (e.charCodeAt(++a) & 255) << 8 | (e.charCodeAt(++a) & 255) << 16 | (e.charCodeAt(++a) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (r) {
    case 3:
      t ^= (e.charCodeAt(a + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(a + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(a) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var OF = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, RF = /[A-Z]|^ms/g, VF = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Nb = function(t) {
  return t.charCodeAt(1) === 45;
}, Uv = function(t) {
  return t != null && typeof t != "boolean";
}, Uu = /* @__PURE__ */ kF(function(e) {
  return Nb(e) ? e : e.replace(RF, "-$&").toLowerCase();
}), jv = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(VF, function(a, r, o) {
          return Ea = {
            name: r,
            styles: o,
            next: Ea
          }, r;
        });
  }
  return OF[t] !== 1 && !Nb(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Zl(e, t, n) {
  if (n == null)
    return "";
  var a = n;
  if (a.__emotion_styles !== void 0)
    return a;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var r = n;
      if (r.anim === 1)
        return Ea = {
          name: r.name,
          styles: r.styles,
          next: Ea
        }, r.name;
      var o = n;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            Ea = {
              name: s.name,
              styles: s.styles,
              next: Ea
            }, s = s.next;
        var i = o.styles + ";";
        return i;
      }
      return FF(e, t, n);
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function FF(e, t, n) {
  var a = "";
  if (Array.isArray(n))
    for (var r = 0; r < n.length; r++)
      a += Zl(e, t, n[r]) + ";";
  else
    for (var o in n) {
      var s = n[o];
      if (typeof s != "object") {
        var i = s;
        t != null && t[i] !== void 0 ? a += o + "{" + t[i] + "}" : Uv(i) && (a += Uu(o) + ":" + jv(o, i) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var u = 0; u < s.length; u++)
          Uv(s[u]) && (a += Uu(o) + ":" + jv(o, s[u]) + ";");
      else {
        var d = Zl(e, t, s);
        switch (o) {
          case "animation":
          case "animationName": {
            a += Uu(o) + ":" + d + ";";
            break;
          }
          default:
            a += o + "{" + d + "}";
        }
      }
    }
  return a;
}
var Wv = /label:\s*([^\s;{]+)\s*(;|$)/g, Ea;
function ju(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var a = !0, r = "";
  Ea = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    a = !1, r += Zl(n, t, o);
  else {
    var s = o;
    r += s[0];
  }
  for (var i = 1; i < e.length; i++)
    if (r += Zl(n, t, e[i]), a) {
      var u = o;
      r += u[i];
    }
  Wv.lastIndex = 0;
  for (var d = "", c; (c = Wv.exec(r)) !== null; )
    d += "-" + c[1];
  var f = IF(r) + d;
  return {
    name: f,
    styles: r,
    next: Ea
  };
}
function Lb(e, t, n) {
  var a = "";
  return n.split(" ").forEach(function(r) {
    e[r] !== void 0 ? t.push(e[r] + ";") : r && (a += r + " ");
  }), a;
}
var NF = function(t, n, a) {
  var r = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[r] === void 0 && (t.registered[r] = n.styles);
}, LF = function(t, n, a) {
  NF(t, n);
  var r = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + r : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function Gv(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function Kv(e, t, n) {
  var a = [], r = Lb(e, a, n);
  return a.length < 2 ? n : r + t(a);
}
var zF = function(t) {
  var n = AF(t);
  n.sheet.speedy = function(i) {
    this.isSpeedy = i;
  }, n.compat = !0;
  var a = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = ju(d, n.registered, void 0);
    return LF(n, f), n.key + "-" + f.name;
  }, r = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = ju(d, n.registered), p = "animation-" + f.name;
    return Gv(n, {
      name: f.name,
      styles: "@keyframes " + p + "{" + f.styles + "}"
    }), p;
  }, o = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = ju(d, n.registered);
    Gv(n, f);
  }, s = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    return Kv(n.registered, a, HF(d));
  };
  return {
    css: a,
    cx: s,
    injectGlobal: o,
    keyframes: r,
    hydrate: function(u) {
      u.forEach(function(d) {
        n.inserted[d] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: Lb.bind(null, n.registered),
    merge: Kv.bind(null, n.registered, a)
  };
}, HF = function e(t) {
  for (var n = "", a = 0; a < t.length; a++) {
    var r = t[a];
    if (r != null) {
      var o = void 0;
      switch (typeof r) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(r))
            o = e(r);
          else {
            o = "";
            for (var s in r)
              r[s] && s && (o && (o += " "), o += s);
          }
          break;
        }
        default:
          o = r;
      }
      o && (n && (n += " "), n += o);
    }
  }
  return n;
}, zb = zF({
  key: "css"
}), Of = zb.injectGlobal, ln = zb.css, Wu, Yv;
function UF() {
  return Yv || (Yv = 1, Wu = function(t, n) {
    n || (n = [0, ""]), t = String(t);
    var a = parseFloat(t, 10);
    return n[0] = a, n[1] = t.match(/[\d.\-\+]*\s*(.*)/)[1] || "", n;
  }), Wu;
}
var Gu, Xv;
function jF() {
  if (Xv) return Gu;
  Xv = 1;
  var e = UF();
  Gu = r;
  var t = a("in", document.body);
  function n(o, s) {
    var i = e(getComputedStyle(o).getPropertyValue(s));
    return i[0] * r(i[1], o);
  }
  function a(o, s) {
    var i = document.createElement("div");
    i.style.height = "128" + o, s.appendChild(i);
    var u = n(i, "height") / 128;
    return s.removeChild(i), u;
  }
  function r(o, s) {
    if (!o) return null;
    switch (s = s || document.body, o = (o + "" || "px").trim().toLowerCase(), (s === window || s === document) && (s = document.body), o) {
      case "%":
        return s.clientHeight / 100;
      case "ch":
      case "ex":
        return a(o, s);
      case "em":
        return n(s, "font-size");
      case "rem":
        return n(document.body, "font-size");
      case "vw":
        return window.innerWidth / 100;
      case "vh":
        return window.innerHeight / 100;
      case "vmin":
        return Math.min(window.innerWidth, window.innerHeight) / 100;
      case "vmax":
        return Math.max(window.innerWidth, window.innerHeight) / 100;
      case "in":
        return t;
      case "cm":
        return t / 2.54;
      case "mm":
        return t / 25.4;
      case "pt":
        return t / 72;
      case "pc":
        return t / 6;
      case "px":
        return 1;
    }
    var i = e(o);
    if (!isNaN(i[0]) && i[1]) {
      var u = r(i[1], s);
      return typeof u == "number" ? i[0] * u : null;
    }
    return null;
  }
  return Gu;
}
var WF = jF();
const Hd = /* @__PURE__ */ ch(WF);
function GF() {
  const e = () => Math.floor((1 + crypto.getRandomValues(new Uint32Array(1))[0]) * 65536).toString(16).substring(1);
  return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`;
}
function Rf(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Hb(e, t) {
  var n = Object.create(e.prototype);
  for (var a in t) n[a] = t[a];
  return n;
}
function Es() {
}
var es = 0.7, Ql = 1 / es, Or = "\\s*([+-]?\\d+)\\s*", ts = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Yn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", KF = /^#([0-9a-f]{3,8})$/, YF = new RegExp(`^rgb\\(${Or},${Or},${Or}\\)$`), XF = new RegExp(`^rgb\\(${Yn},${Yn},${Yn}\\)$`), JF = new RegExp(`^rgba\\(${Or},${Or},${Or},${ts}\\)$`), ZF = new RegExp(`^rgba\\(${Yn},${Yn},${Yn},${ts}\\)$`), QF = new RegExp(`^hsl\\(${ts},${Yn},${Yn}\\)$`), eN = new RegExp(`^hsla\\(${ts},${Yn},${Yn},${ts}\\)$`), Jv = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Rf(Es, ar, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Zv,
  // Deprecated! Use color.formatHex.
  formatHex: Zv,
  formatHex8: tN,
  formatHsl: nN,
  formatRgb: Qv,
  toString: Qv
});
function Zv() {
  return this.rgb().formatHex();
}
function tN() {
  return this.rgb().formatHex8();
}
function nN() {
  return Ub(this).formatHsl();
}
function Qv() {
  return this.rgb().formatRgb();
}
function ar(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = KF.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? em(t) : n === 3 ? new tn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Zs(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Zs(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = YF.exec(e)) ? new tn(t[1], t[2], t[3], 1) : (t = XF.exec(e)) ? new tn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = JF.exec(e)) ? Zs(t[1], t[2], t[3], t[4]) : (t = ZF.exec(e)) ? Zs(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = QF.exec(e)) ? am(t[1], t[2] / 100, t[3] / 100, 1) : (t = eN.exec(e)) ? am(t[1], t[2] / 100, t[3] / 100, t[4]) : Jv.hasOwnProperty(e) ? em(Jv[e]) : e === "transparent" ? new tn(NaN, NaN, NaN, 0) : null;
}
function em(e) {
  return new tn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Zs(e, t, n, a) {
  return a <= 0 && (e = t = n = NaN), new tn(e, t, n, a);
}
function aN(e) {
  return e instanceof Es || (e = ar(e)), e ? (e = e.rgb(), new tn(e.r, e.g, e.b, e.opacity)) : new tn();
}
function Ud(e, t, n, a) {
  return arguments.length === 1 ? aN(e) : new tn(e, t, n, a ?? 1);
}
function tn(e, t, n, a) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +a;
}
Rf(tn, Ud, Hb(Es, {
  brighter(e) {
    return e = e == null ? Ql : Math.pow(Ql, e), new tn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? es : Math.pow(es, e), new tn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new tn(Qa(this.r), Qa(this.g), Qa(this.b), ei(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: tm,
  // Deprecated! Use color.formatHex.
  formatHex: tm,
  formatHex8: rN,
  formatRgb: nm,
  toString: nm
}));
function tm() {
  return `#${Ya(this.r)}${Ya(this.g)}${Ya(this.b)}`;
}
function rN() {
  return `#${Ya(this.r)}${Ya(this.g)}${Ya(this.b)}${Ya((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function nm() {
  const e = ei(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Qa(this.r)}, ${Qa(this.g)}, ${Qa(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function ei(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Qa(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ya(e) {
  return e = Qa(e), (e < 16 ? "0" : "") + e.toString(16);
}
function am(e, t, n, a) {
  return a <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Dn(e, t, n, a);
}
function Ub(e) {
  if (e instanceof Dn) return new Dn(e.h, e.s, e.l, e.opacity);
  if (e instanceof Es || (e = ar(e)), !e) return new Dn();
  if (e instanceof Dn) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, a = e.b / 255, r = Math.min(t, n, a), o = Math.max(t, n, a), s = NaN, i = o - r, u = (o + r) / 2;
  return i ? (t === o ? s = (n - a) / i + (n < a) * 6 : n === o ? s = (a - t) / i + 2 : s = (t - n) / i + 4, i /= u < 0.5 ? o + r : 2 - o - r, s *= 60) : i = u > 0 && u < 1 ? 0 : s, new Dn(s, i, u, e.opacity);
}
function oN(e, t, n, a) {
  return arguments.length === 1 ? Ub(e) : new Dn(e, t, n, a ?? 1);
}
function Dn(e, t, n, a) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +a;
}
Rf(Dn, oN, Hb(Es, {
  brighter(e) {
    return e = e == null ? Ql : Math.pow(Ql, e), new Dn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? es : Math.pow(es, e), new Dn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, a = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - a;
    return new tn(
      Ku(e >= 240 ? e - 240 : e + 120, r, a),
      Ku(e, r, a),
      Ku(e < 120 ? e + 240 : e - 120, r, a),
      this.opacity
    );
  },
  clamp() {
    return new Dn(rm(this.h), Qs(this.s), Qs(this.l), ei(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = ei(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${rm(this.h)}, ${Qs(this.s) * 100}%, ${Qs(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function rm(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Qs(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Ku(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const sN = globalThis?.UNOVIS_COLORS || ["#4D8CFD", "#FF6B7E", "#F4B83E", "#A6CC74", "#00C19A", "#6859BE"], jb = (e) => `--vis-${Oo(e) ? `color${e % sN.length}` : e}`, ns = 10, lN = [
  { id: "stripes-diagonal", svg: '<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="#000"/>' },
  { id: "dots", svg: '<path d="m0-1.5a1 1 0 010 3m10-3a1 1 0 000 3M5 3.5a1 1 0 010 3 1 1 0 010-3M0 8.5 a1 1 0 010 3m10-3a1 1 0 000 3" fill"#000"/>' },
  { id: "stripes-vertical", svg: '<path d="M 5,-1 L5,11" stroke="#000"/>' },
  { id: "crosshatch", svg: '<path d="M0 0L10 10ZM10 0L0 10Z" stroke="#000"/>' },
  { id: "waves", svg: '<path d="M0 4Q2.5 1 5 4 7.5 7 10 4v2Q7.5 9 5 6 2.5 3 0 6Z" fill="#000"/>' },
  { id: "circles", svg: '<circle cx="5" cy="5" r="3" stroke="#000" fill="#fff"/>' }
], iN = [
  { id: "circle", marker: '<circle cx="5" cy="5" r="5"/>', dashArray: [] },
  { id: "triangle", marker: '<path d="M5,0 L10,9 L0,9Z">', dashArray: [9, 1] },
  { id: "diamond", marker: '<path d="M 0 5 L5 0 L 10 5 L 5 10 L 0 5Z">', dashArray: [2] },
  { id: "arrow", marker: '<path d="M4 0 0 0 6 5 0 10 4 10 10 5Z">', dashArray: [2, 3, 8, 3] },
  { id: "square", marker: '<rect x="1" y="1" width="8" height="8"/>', dashArray: [6] },
  { id: "star", marker: '<path d="m2 9 3-9 3 9L0 3h10Z"/>', dashArray: [1, 6] }
];
function Wb(e) {
  return `vis-${`pattern-${e.svg ? "fill" : "marker"}`}-${e.id}`;
}
const uN = (e) => `<mask id="${Wb(e)}">
    <pattern id="${e.id}" viewBox="0 0 10 10" width="${ns}" height="${ns}" patternUnits="userSpaceOnUse">
      <rect width="100%" height="100%" fill="#fff"/>
      ${e.svg}
    </pattern>
    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#${e.id})"/>
  </mask>`, dN = (e, t) => `<marker id="${Wb(e)}"
    fill="var(${jb(t)})"
    markerUnits="userSpaceOnUse"
    refX="5"
    refY="5"
    markerWidth="${ns}"
    markerHeight="${ns}">
    ${e.marker}
  </marker>`;
function cN() {
  const e = lN.map(uN).concat(iN.map(dN)).join(""), t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.style.position = "fixed", t.style.zIndex = "-99999999", t.innerHTML = `<defs>${e}</defs>`, document.body.appendChild(t);
}
typeof window < "u" && cN();
var fN = { value: () => {
} };
function Gb() {
  for (var e = 0, t = arguments.length, n = {}, a; e < t; ++e) {
    if (!(a = arguments[e] + "") || a in n || /[\s.]/.test(a)) throw new Error("illegal type: " + a);
    n[a] = [];
  }
  return new yl(n);
}
function yl(e) {
  this._ = e;
}
function pN(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var a = "", r = n.indexOf(".");
    if (r >= 0 && (a = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: a };
  });
}
yl.prototype = Gb.prototype = {
  constructor: yl,
  on: function(e, t) {
    var n = this._, a = pN(e + "", n), r, o = -1, s = a.length;
    if (arguments.length < 2) {
      for (; ++o < s; ) if ((r = (e = a[o]).type) && (r = vN(n[r], e.name))) return r;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++o < s; )
      if (r = (e = a[o]).type) n[r] = om(n[r], e.name, t);
      else if (t == null) for (r in n) n[r] = om(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new yl(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0) for (var n = new Array(r), a = 0, r, o; a < r; ++a) n[a] = arguments[a + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (o = this._[e], a = 0, r = o.length; a < r; ++a) o[a].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
  }
};
function vN(e, t) {
  for (var n = 0, a = e.length, r; n < a; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function om(e, t, n) {
  for (var a = 0, r = e.length; a < r; ++a)
    if (e[a].name === t) {
      e[a] = fN, e = e.slice(0, a).concat(e.slice(a + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var jr = 0, Bo = 0, yo = 0, Kb = 1e3, ti, Do, ni = 0, rr = 0, ru = 0, as = typeof performance == "object" && performance.now ? performance : Date, Yb = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Vf() {
  return rr || (Yb(mN), rr = as.now() + ru);
}
function mN() {
  rr = 0;
}
function ai() {
  this._call = this._time = this._next = null;
}
ai.prototype = Xb.prototype = {
  constructor: ai,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Vf() : +n) + (t == null ? 0 : +t), !this._next && Do !== this && (Do ? Do._next = this : ti = this, Do = this), this._call = e, this._time = n, jd();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, jd());
  }
};
function Xb(e, t, n) {
  var a = new ai();
  return a.restart(e, t, n), a;
}
function hN() {
  Vf(), ++jr;
  for (var e = ti, t; e; )
    (t = rr - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --jr;
}
function sm() {
  rr = (ni = as.now()) + ru, jr = Bo = 0;
  try {
    hN();
  } finally {
    jr = 0, yN(), rr = 0;
  }
}
function gN() {
  var e = as.now(), t = e - ni;
  t > Kb && (ru -= t, ni = e);
}
function yN() {
  for (var e, t = ti, n, a = 1 / 0; t; )
    t._call ? (a > t._time && (a = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : ti = n);
  Do = e, jd(a);
}
function jd(e) {
  if (!jr) {
    Bo && (Bo = clearTimeout(Bo));
    var t = e - rr;
    t > 24 ? (e < 1 / 0 && (Bo = setTimeout(sm, e - as.now() - ru)), yo && (yo = clearInterval(yo))) : (yo || (ni = as.now(), yo = setInterval(gN, Kb)), jr = 1, Yb(sm));
  }
}
function lm(e, t, n) {
  var a = new ai();
  return t = t == null ? 0 : +t, a.restart((r) => {
    a.stop(), e(r + t);
  }, t, n), a;
}
var bN = Gb("start", "end", "cancel", "interrupt"), _N = [], Jb = 0, im = 1, Wd = 2, bl = 3, um = 4, Gd = 5, _l = 6;
function ou(e, t, n, a, r, o) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  wN(e, n, {
    name: t,
    index: a,
    // For context during callback.
    group: r,
    // For context during callback.
    on: bN,
    tween: _N,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: Jb
  });
}
function Ff(e, t) {
  var n = Fn(e, t);
  if (n.state > Jb) throw new Error("too late; already scheduled");
  return n;
}
function ea(e, t) {
  var n = Fn(e, t);
  if (n.state > bl) throw new Error("too late; already running");
  return n;
}
function Fn(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function wN(e, t, n) {
  var a = e.__transition, r;
  a[t] = n, n.timer = Xb(o, 0, n.time);
  function o(d) {
    n.state = im, n.timer.restart(s, n.delay, n.time), n.delay <= d && s(d - n.delay);
  }
  function s(d) {
    var c, f, p, v;
    if (n.state !== im) return u();
    for (c in a)
      if (v = a[c], v.name === n.name) {
        if (v.state === bl) return lm(s);
        v.state === um ? (v.state = _l, v.timer.stop(), v.on.call("interrupt", e, e.__data__, v.index, v.group), delete a[c]) : +c < t && (v.state = _l, v.timer.stop(), v.on.call("cancel", e, e.__data__, v.index, v.group), delete a[c]);
      }
    if (lm(function() {
      n.state === bl && (n.state = um, n.timer.restart(i, n.delay, n.time), i(d));
    }), n.state = Wd, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Wd) {
      for (n.state = bl, r = new Array(p = n.tween.length), c = 0, f = -1; c < p; ++c)
        (v = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (r[++f] = v);
      r.length = f + 1;
    }
  }
  function i(d) {
    for (var c = d < n.duration ? n.ease.call(null, d / n.duration) : (n.timer.restart(u), n.state = Gd, 1), f = -1, p = r.length; ++f < p; )
      r[f].call(e, c);
    n.state === Gd && (n.on.call("end", e, e.__data__, n.index, n.group), u());
  }
  function u() {
    n.state = _l, n.timer.stop(), delete a[t];
    for (var d in a) return;
    delete e.__transition;
  }
}
function Zb(e, t) {
  var n = e.__transition, a, r, o = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((a = n[s]).name !== t) {
        o = !1;
        continue;
      }
      r = a.state > Wd && a.state < Gd, a.state = _l, a.timer.stop(), a.on.call(r ? "interrupt" : "cancel", e, e.__data__, a.index, a.group), delete n[s];
    }
    o && delete e.__transition;
  }
}
function xN(e) {
  return this.each(function() {
    Zb(this, e);
  });
}
const Nf = (e) => () => e;
function CN(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function SN(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(a) {
    return Math.pow(e + a * t, n);
  };
}
function $N(e) {
  return (e = +e) == 1 ? Qb : function(t, n) {
    return n - t ? SN(t, n, e) : Nf(isNaN(t) ? n : t);
  };
}
function Qb(e, t) {
  var n = t - e;
  return n ? CN(e, n) : Nf(isNaN(e) ? t : e);
}
const ri = (function e(t) {
  var n = $N(t);
  function a(r, o) {
    var s = n((r = Ud(r)).r, (o = Ud(o)).r), i = n(r.g, o.g), u = n(r.b, o.b), d = Qb(r.opacity, o.opacity);
    return function(c) {
      return r.r = s(c), r.g = i(c), r.b = u(c), r.opacity = d(c), r + "";
    };
  }
  return a.gamma = e, a;
})(1);
function kN(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, a = t.slice(), r;
  return function(o) {
    for (r = 0; r < n; ++r) a[r] = e[r] * (1 - o) + t[r] * o;
    return a;
  };
}
function BN(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function DN(e, t) {
  var n = t ? t.length : 0, a = e ? Math.min(n, e.length) : 0, r = new Array(a), o = new Array(n), s;
  for (s = 0; s < a; ++s) r[s] = uo(e[s], t[s]);
  for (; s < n; ++s) o[s] = t[s];
  return function(i) {
    for (s = 0; s < a; ++s) o[s] = r[s](i);
    return o;
  };
}
function PN(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(a) {
    return n.setTime(e * (1 - a) + t * a), n;
  };
}
function kn(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function MN(e, t) {
  var n = {}, a = {}, r;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in e ? n[r] = uo(e[r], t[r]) : a[r] = t[r];
  return function(o) {
    for (r in n) a[r] = n[r](o);
    return a;
  };
}
var Kd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Yu = new RegExp(Kd.source, "g");
function EN(e) {
  return function() {
    return e;
  };
}
function qN(e) {
  return function(t) {
    return e(t) + "";
  };
}
function e_(e, t) {
  var n = Kd.lastIndex = Yu.lastIndex = 0, a, r, o, s = -1, i = [], u = [];
  for (e = e + "", t = t + ""; (a = Kd.exec(e)) && (r = Yu.exec(t)); )
    (o = r.index) > n && (o = t.slice(n, o), i[s] ? i[s] += o : i[++s] = o), (a = a[0]) === (r = r[0]) ? i[s] ? i[s] += r : i[++s] = r : (i[++s] = null, u.push({ i: s, x: kn(a, r) })), n = Yu.lastIndex;
  return n < t.length && (o = t.slice(n), i[s] ? i[s] += o : i[++s] = o), i.length < 2 ? u[0] ? qN(u[0].x) : EN(t) : (t = u.length, function(d) {
    for (var c = 0, f; c < t; ++c) i[(f = u[c]).i] = f.x(d);
    return i.join("");
  });
}
function uo(e, t) {
  var n = typeof t, a;
  return t == null || n === "boolean" ? Nf(t) : (n === "number" ? kn : n === "string" ? (a = ar(t)) ? (t = a, ri) : e_ : t instanceof ar ? ri : t instanceof Date ? PN : BN(t) ? kN : Array.isArray(t) ? DN : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? MN : kn)(e, t);
}
function Lf(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var dm = 180 / Math.PI, Yd = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function t_(e, t, n, a, r, o) {
  var s, i, u;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (u = e * n + t * a) && (n -= e * u, a -= t * u), (i = Math.sqrt(n * n + a * a)) && (n /= i, a /= i, u /= i), e * a < t * n && (e = -e, t = -t, u = -u, s = -s), {
    translateX: r,
    translateY: o,
    rotate: Math.atan2(t, e) * dm,
    skewX: Math.atan(u) * dm,
    scaleX: s,
    scaleY: i
  };
}
var el;
function TN(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Yd : t_(t.a, t.b, t.c, t.d, t.e, t.f);
}
function AN(e) {
  return e == null || (el || (el = document.createElementNS("http://www.w3.org/2000/svg", "g")), el.setAttribute("transform", e), !(e = el.transform.baseVal.consolidate())) ? Yd : (e = e.matrix, t_(e.a, e.b, e.c, e.d, e.e, e.f));
}
function n_(e, t, n, a) {
  function r(d) {
    return d.length ? d.pop() + " " : "";
  }
  function o(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var g = v.push("translate(", null, t, null, n);
      m.push({ i: g - 4, x: kn(d, f) }, { i: g - 2, x: kn(c, p) });
    } else (f || p) && v.push("translate(" + f + t + p + n);
  }
  function s(d, c, f, p) {
    d !== c ? (d - c > 180 ? c += 360 : c - d > 180 && (d += 360), p.push({ i: f.push(r(f) + "rotate(", null, a) - 2, x: kn(d, c) })) : c && f.push(r(f) + "rotate(" + c + a);
  }
  function i(d, c, f, p) {
    d !== c ? p.push({ i: f.push(r(f) + "skewX(", null, a) - 2, x: kn(d, c) }) : c && f.push(r(f) + "skewX(" + c + a);
  }
  function u(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var g = v.push(r(v) + "scale(", null, ",", null, ")");
      m.push({ i: g - 4, x: kn(d, f) }, { i: g - 2, x: kn(c, p) });
    } else (f !== 1 || p !== 1) && v.push(r(v) + "scale(" + f + "," + p + ")");
  }
  return function(d, c) {
    var f = [], p = [];
    return d = e(d), c = e(c), o(d.translateX, d.translateY, c.translateX, c.translateY, f, p), s(d.rotate, c.rotate, f, p), i(d.skewX, c.skewX, f, p), u(d.scaleX, d.scaleY, c.scaleX, c.scaleY, f, p), d = c = null, function(v) {
      for (var m = -1, g = p.length, w; ++m < g; ) f[(w = p[m]).i] = w.x(v);
      return f.join("");
    };
  };
}
var IN = n_(TN, "px, ", "px)", "deg)"), ON = n_(AN, ", ", ")", ")");
function RN(e, t) {
  t === void 0 && (t = e, e = uo);
  for (var n = 0, a = t.length - 1, r = t[0], o = new Array(a < 0 ? 0 : a); n < a; ) o[n] = e(r, r = t[++n]);
  return function(s) {
    var i = Math.max(0, Math.min(a - 1, Math.floor(s *= a)));
    return o[i](s - i);
  };
}
function VN(e, t) {
  var n, a;
  return function() {
    var r = ea(this, e), o = r.tween;
    if (o !== n) {
      a = n = o;
      for (var s = 0, i = a.length; s < i; ++s)
        if (a[s].name === t) {
          a = a.slice(), a.splice(s, 1);
          break;
        }
    }
    r.tween = a;
  };
}
function FN(e, t, n) {
  var a, r;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = ea(this, e), s = o.tween;
    if (s !== a) {
      r = (a = s).slice();
      for (var i = { name: t, value: n }, u = 0, d = r.length; u < d; ++u)
        if (r[u].name === t) {
          r[u] = i;
          break;
        }
      u === d && r.push(i);
    }
    o.tween = r;
  };
}
function NN(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var a = Fn(this.node(), n).tween, r = 0, o = a.length, s; r < o; ++r)
      if ((s = a[r]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? VN : FN)(n, e, t));
}
function zf(e, t, n) {
  var a = e._id;
  return e.each(function() {
    var r = ea(this, a);
    (r.value || (r.value = {}))[t] = n.apply(this, arguments);
  }), function(r) {
    return Fn(r, a).value[t];
  };
}
function a_(e, t) {
  var n;
  return (typeof t == "number" ? kn : t instanceof ar ? ri : (n = ar(t)) ? (t = n, ri) : e_)(e, t);
}
function LN(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function zN(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function HN(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttribute(e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function UN(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function jN(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function WN(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function GN(e, t) {
  var n = Qi(e), a = n === "transform" ? ON : a_;
  return this.attrTween(e, typeof t == "function" ? (n.local ? WN : jN)(n, a, zf(this, "attr." + e, t)) : t == null ? (n.local ? zN : LN)(n) : (n.local ? UN : HN)(n, a, t));
}
function KN(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function YN(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function XN(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && YN(e, o)), n;
  }
  return r._value = t, r;
}
function JN(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && KN(e, o)), n;
  }
  return r._value = t, r;
}
function ZN(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var a = Qi(e);
  return this.tween(n, (a.local ? XN : JN)(a, t));
}
function QN(e, t) {
  return function() {
    Ff(this, e).delay = +t.apply(this, arguments);
  };
}
function e5(e, t) {
  return t = +t, function() {
    Ff(this, e).delay = t;
  };
}
function t5(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? QN : e5)(t, e)) : Fn(this.node(), t).delay;
}
function n5(e, t) {
  return function() {
    ea(this, e).duration = +t.apply(this, arguments);
  };
}
function a5(e, t) {
  return t = +t, function() {
    ea(this, e).duration = t;
  };
}
function r5(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? n5 : a5)(t, e)) : Fn(this.node(), t).duration;
}
function o5(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    ea(this, e).ease = t;
  };
}
function s5(e) {
  var t = this._id;
  return arguments.length ? this.each(o5(t, e)) : Fn(this.node(), t).ease;
}
function l5(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    ea(this, e).ease = n;
  };
}
function i5(e) {
  if (typeof e != "function") throw new Error();
  return this.each(l5(this._id, e));
}
function u5(e) {
  typeof e != "function" && (e = yb(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new pa(a, this._parents, this._name, this._id);
}
function d5(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, a = t.length, r = n.length, o = Math.min(a, r), s = new Array(a), i = 0; i < o; ++i)
    for (var u = t[i], d = n[i], c = u.length, f = s[i] = new Array(c), p, v = 0; v < c; ++v)
      (p = u[v] || d[v]) && (f[v] = p);
  for (; i < a; ++i)
    s[i] = t[i];
  return new pa(s, this._parents, this._name, this._id);
}
function c5(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function f5(e, t, n) {
  var a, r, o = c5(t) ? Ff : ea;
  return function() {
    var s = o(this, e), i = s.on;
    i !== a && (r = (a = i).copy()).on(t, n), s.on = r;
  };
}
function p5(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Fn(this.node(), n).on.on(e) : this.each(f5(n, e, t));
}
function v5(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function m5() {
  return this.on("end.remove", v5(this._id));
}
function h5(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Df(e));
  for (var a = this._groups, r = a.length, o = new Array(r), s = 0; s < r; ++s)
    for (var i = a[s], u = i.length, d = o[s] = new Array(u), c, f, p = 0; p < u; ++p)
      (c = i[p]) && (f = e.call(c, c.__data__, p, i)) && ("__data__" in c && (f.__data__ = c.__data__), d[p] = f, ou(d[p], t, n, p, d, Fn(c, n)));
  return new pa(o, this._parents, t, n);
}
function g5(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = gb(e));
  for (var a = this._groups, r = a.length, o = [], s = [], i = 0; i < r; ++i)
    for (var u = a[i], d = u.length, c, f = 0; f < d; ++f)
      if (c = u[f]) {
        for (var p = e.call(c, c.__data__, f, u), v, m = Fn(c, n), g = 0, w = p.length; g < w; ++g)
          (v = p[g]) && ou(v, t, n, g, p, m);
        o.push(p), s.push(c);
      }
  return new pa(o, s, t, n);
}
var y5 = Ds.prototype.constructor;
function b5() {
  return new y5(this._groups, this._parents);
}
function _5(e, t) {
  var n, a, r;
  return function() {
    var o = Hr(this, e), s = (this.style.removeProperty(e), Hr(this, e));
    return o === s ? null : o === n && s === a ? r : r = t(n = o, a = s);
  };
}
function r_(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function w5(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = Hr(this, e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function x5(e, t, n) {
  var a, r, o;
  return function() {
    var s = Hr(this, e), i = n(this), u = i + "";
    return i == null && (u = i = (this.style.removeProperty(e), Hr(this, e))), s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i));
  };
}
function C5(e, t) {
  var n, a, r, o = "style." + t, s = "end." + o, i;
  return function() {
    var u = ea(this, e), d = u.on, c = u.value[o] == null ? i || (i = r_(t)) : void 0;
    (d !== n || r !== c) && (a = (n = d).copy()).on(s, r = c), u.on = a;
  };
}
function S5(e, t, n) {
  var a = (e += "") == "transform" ? IN : a_;
  return t == null ? this.styleTween(e, _5(e, a)).on("end.style." + e, r_(e)) : typeof t == "function" ? this.styleTween(e, x5(e, a, zf(this, "style." + e, t))).each(C5(this._id, e)) : this.styleTween(e, w5(e, a, t), n).on("end.style." + e, null);
}
function $5(e, t, n) {
  return function(a) {
    this.style.setProperty(e, t.call(this, a), n);
  };
}
function k5(e, t, n) {
  var a, r;
  function o() {
    var s = t.apply(this, arguments);
    return s !== r && (a = (r = s) && $5(e, s, n)), a;
  }
  return o._value = t, o;
}
function B5(e, t, n) {
  var a = "style." + (e += "");
  if (arguments.length < 2) return (a = this.tween(a)) && a._value;
  if (t == null) return this.tween(a, null);
  if (typeof t != "function") throw new Error();
  return this.tween(a, k5(e, t, n ?? ""));
}
function D5(e) {
  return function() {
    this.textContent = e;
  };
}
function P5(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function M5(e) {
  return this.tween("text", typeof e == "function" ? P5(zf(this, "text", e)) : D5(e == null ? "" : e + ""));
}
function E5(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function q5(e) {
  var t, n;
  function a() {
    var r = e.apply(this, arguments);
    return r !== n && (t = (n = r) && E5(r)), t;
  }
  return a._value = e, a;
}
function T5(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, q5(e));
}
function A5() {
  for (var e = this._name, t = this._id, n = o_(), a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      if (u = s[d]) {
        var c = Fn(u, t);
        ou(u, e, n, d, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new pa(a, this._parents, e, n);
}
function I5() {
  var e, t, n = this, a = n._id, r = n.size();
  return new Promise(function(o, s) {
    var i = { value: s }, u = { value: function() {
      --r === 0 && o();
    } };
    n.each(function() {
      var d = ea(this, a), c = d.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(i), t._.interrupt.push(i), t._.end.push(u)), d.on = t;
    }), r === 0 && o();
  });
}
var O5 = 0;
function pa(e, t, n, a) {
  this._groups = e, this._parents = t, this._name = n, this._id = a;
}
function o_() {
  return ++O5;
}
var na = Ds.prototype;
pa.prototype = {
  constructor: pa,
  select: h5,
  selectAll: g5,
  selectChild: na.selectChild,
  selectChildren: na.selectChildren,
  filter: u5,
  merge: d5,
  selection: b5,
  transition: A5,
  call: na.call,
  nodes: na.nodes,
  node: na.node,
  size: na.size,
  empty: na.empty,
  each: na.each,
  on: p5,
  attr: GN,
  attrTween: ZN,
  style: S5,
  styleTween: B5,
  text: M5,
  textTween: T5,
  remove: m5,
  tween: NN,
  delay: t5,
  duration: r5,
  ease: s5,
  easeVarying: i5,
  end: I5,
  [Symbol.iterator]: na[Symbol.iterator]
};
const cm = (e) => +e;
function R5(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var V5 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: R5
};
function F5(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function N5(e) {
  var t, n;
  e instanceof pa ? (t = e._id, e = e._name) : (t = o_(), (n = V5).time = Vf(), e = e == null ? null : e + "");
  for (var a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && ou(u, e, t, d, s, n || F5(u, t));
  return new pa(a, this._parents, e, t);
}
Ds.prototype.interrupt = xN;
Ds.prototype.transition = N5;
function Xu(e, t, n) {
  if (e.nodes().forEach((a) => Zb(a)), t) {
    const a = e.transition().duration(t);
    return n && a.ease(n), a;
  } else
    return e;
}
class s_ {
  constructor(t) {
    this.data = t;
  }
  get data() {
    return this._data;
  }
  set data(t) {
    this._data = t;
  }
}
function Nn(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function l_(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const fm = /* @__PURE__ */ Symbol("implicit");
function Hf() {
  var e = new Iv(), t = [], n = [], a = fm;
  function r(o) {
    let s = e.get(o);
    if (s === void 0) {
      if (a !== fm) return a;
      e.set(o, s = t.push(o) - 1);
    }
    return n[s % n.length];
  }
  return r.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new Iv();
    for (const s of o)
      e.has(s) || e.set(s, t.push(s) - 1);
    return r;
  }, r.range = function(o) {
    return arguments.length ? (n = Array.from(o), r) : n.slice();
  }, r.unknown = function(o) {
    return arguments.length ? (a = o, r) : a;
  }, r.copy = function() {
    return Hf(t, n).unknown(a);
  }, Nn.apply(r, arguments), r;
}
function Uf() {
  var e = Hf().unknown(void 0), t = e.domain, n = e.range, a = 0, r = 1, o, s, i = !1, u = 0, d = 0, c = 0.5;
  delete e.unknown;
  function f() {
    var p = t().length, v = r < a, m = v ? r : a, g = v ? a : r;
    o = (g - m) / Math.max(1, p - u + d * 2), i && (o = Math.floor(o)), m += (g - m - o * (p - u)) * c, s = o * (1 - u), i && (m = Math.round(m), s = Math.round(s));
    var w = JV(p).map(function(C) {
      return m + o * C;
    });
    return n(v ? w.reverse() : w);
  }
  return e.domain = function(p) {
    return arguments.length ? (t(p), f()) : t();
  }, e.range = function(p) {
    return arguments.length ? ([a, r] = p, a = +a, r = +r, f()) : [a, r];
  }, e.rangeRound = function(p) {
    return [a, r] = p, a = +a, r = +r, i = !0, f();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return o;
  }, e.round = function(p) {
    return arguments.length ? (i = !!p, f()) : i;
  }, e.padding = function(p) {
    return arguments.length ? (u = Math.min(1, d = +p), f()) : u;
  }, e.paddingInner = function(p) {
    return arguments.length ? (u = Math.min(1, p), f()) : u;
  }, e.paddingOuter = function(p) {
    return arguments.length ? (d = +p, f()) : d;
  }, e.align = function(p) {
    return arguments.length ? (c = Math.max(0, Math.min(1, p)), f()) : c;
  }, e.copy = function() {
    return Uf(t(), [a, r]).round(i).paddingInner(u).paddingOuter(d).align(c);
  }, Nn.apply(f(), arguments);
}
function i_(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return i_(t());
  }, e;
}
function L5() {
  return i_(Uf.apply(null, arguments).paddingInner(1));
}
function z5(e) {
  return function() {
    return e;
  };
}
function Xd(e) {
  return +e;
}
var pm = [0, 1];
function nn(e) {
  return e;
}
function Jd(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : z5(isNaN(t) ? NaN : 0.5);
}
function H5(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(a) {
    return Math.max(e, Math.min(t, a));
  };
}
function U5(e, t, n) {
  var a = e[0], r = e[1], o = t[0], s = t[1];
  return r < a ? (a = Jd(r, a), o = n(s, o)) : (a = Jd(a, r), o = n(o, s)), function(i) {
    return o(a(i));
  };
}
function j5(e, t, n) {
  var a = Math.min(e.length, t.length) - 1, r = new Array(a), o = new Array(a), s = -1;
  for (e[a] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < a; )
    r[s] = Jd(e[s], e[s + 1]), o[s] = n(t[s], t[s + 1]);
  return function(i) {
    var u = Ps(e, i, 1, a) - 1;
    return o[u](r[u](i));
  };
}
function qs(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function su() {
  var e = pm, t = pm, n = uo, a, r, o, s = nn, i, u, d;
  function c() {
    var p = Math.min(e.length, t.length);
    return s !== nn && (s = H5(e[0], e[p - 1])), i = p > 2 ? j5 : U5, u = d = null, f;
  }
  function f(p) {
    return p == null || isNaN(p = +p) ? o : (u || (u = i(e.map(a), t, n)))(a(s(p)));
  }
  return f.invert = function(p) {
    return s(r((d || (d = i(t, e.map(a), kn)))(p)));
  }, f.domain = function(p) {
    return arguments.length ? (e = Array.from(p, Xd), c()) : e.slice();
  }, f.range = function(p) {
    return arguments.length ? (t = Array.from(p), c()) : t.slice();
  }, f.rangeRound = function(p) {
    return t = Array.from(p), n = Lf, c();
  }, f.clamp = function(p) {
    return arguments.length ? (s = p ? !0 : nn, c()) : s !== nn;
  }, f.interpolate = function(p) {
    return arguments.length ? (n = p, c()) : n;
  }, f.unknown = function(p) {
    return arguments.length ? (o = p, f) : o;
  }, function(p, v) {
    return a = p, r = v, c();
  };
}
function u_() {
  return su()(nn, nn);
}
function W5(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function oi(e, t) {
  if (!isFinite(e) || e === 0) return null;
  var n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e"), a = e.slice(0, n);
  return [
    a.length > 1 ? a[0] + a.slice(2) : a,
    +e.slice(n + 1)
  ];
}
function Wr(e) {
  return e = oi(Math.abs(e)), e ? e[1] : NaN;
}
function G5(e, t) {
  return function(n, a) {
    for (var r = n.length, o = [], s = 0, i = e[0], u = 0; r > 0 && i > 0 && (u + i + 1 > a && (i = Math.max(1, a - u)), o.push(n.substring(r -= i, r + i)), !((u += i + 1) > a)); )
      i = e[s = (s + 1) % e.length];
    return o.reverse().join(t);
  };
}
function K5(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var Y5 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function rs(e) {
  if (!(t = Y5.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new jf({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
rs.prototype = jf.prototype;
function jf(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
jf.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function X5(e) {
  e: for (var t = e.length, n = 1, a = -1, r; n < t; ++n)
    switch (e[n]) {
      case ".":
        a = r = n;
        break;
      case "0":
        a === 0 && (a = n), r = n;
        break;
      default:
        if (!+e[n]) break e;
        a > 0 && (a = 0);
        break;
    }
  return a > 0 ? e.slice(0, a) + e.slice(r + 1) : e;
}
var si;
function J5(e, t) {
  var n = oi(e, t);
  if (!n) return si = void 0, e.toPrecision(t);
  var a = n[0], r = n[1], o = r - (si = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, s = a.length;
  return o === s ? a : o > s ? a + new Array(o - s + 1).join("0") : o > 0 ? a.slice(0, o) + "." + a.slice(o) : "0." + new Array(1 - o).join("0") + oi(e, Math.max(0, t + o - 1))[0];
}
function vm(e, t) {
  var n = oi(e, t);
  if (!n) return e + "";
  var a = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + a : a.length > r + 1 ? a.slice(0, r + 1) + "." + a.slice(r + 1) : a + new Array(r - a.length + 2).join("0");
}
const mm = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: W5,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => vm(e * 100, t),
  r: vm,
  s: J5,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function hm(e) {
  return e;
}
var gm = Array.prototype.map, ym = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Z5(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? hm : G5(gm.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", a = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? hm : K5(gm.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", i = e.minus === void 0 ? "" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function d(f, p) {
    f = rs(f);
    var v = f.fill, m = f.align, g = f.sign, w = f.symbol, C = f.zero, S = f.width, $ = f.comma, B = f.precision, k = f.trim, P = f.type;
    P === "n" ? ($ = !0, P = "g") : mm[P] || (B === void 0 && (B = 12), k = !0, P = "g"), (C || v === "0" && m === "=") && (C = !0, v = "0", m = "=");
    var D = (p && p.prefix !== void 0 ? p.prefix : "") + (w === "$" ? n : w === "#" && /[boxX]/.test(P) ? "0" + P.toLowerCase() : ""), q = (w === "$" ? a : /[%p]/.test(P) ? s : "") + (p && p.suffix !== void 0 ? p.suffix : ""), T = mm[P], M = /[defgprs%]/.test(P);
    B = B === void 0 ? 6 : /[gprs]/.test(P) ? Math.max(1, Math.min(21, B)) : Math.max(0, Math.min(20, B));
    function O(F) {
      var J = D, ne = q, Q, G, H;
      if (P === "c")
        ne = T(F) + ne, F = "";
      else {
        F = +F;
        var U = F < 0 || 1 / F < 0;
        if (F = isNaN(F) ? u : T(Math.abs(F), B), k && (F = X5(F)), U && +F == 0 && g !== "+" && (U = !1), J = (U ? g === "(" ? g : i : g === "-" || g === "(" ? "" : g) + J, ne = (P === "s" && !isNaN(F) && si !== void 0 ? ym[8 + si / 3] : "") + ne + (U && g === "(" ? ")" : ""), M) {
          for (Q = -1, G = F.length; ++Q < G; )
            if (H = F.charCodeAt(Q), 48 > H || H > 57) {
              ne = (H === 46 ? r + F.slice(Q + 1) : F.slice(Q)) + ne, F = F.slice(0, Q);
              break;
            }
        }
      }
      $ && !C && (F = t(F, 1 / 0));
      var se = J.length + F.length + ne.length, ee = se < S ? new Array(S - se + 1).join(v) : "";
      switch ($ && C && (F = t(ee + F, ee.length ? S - ne.length : 1 / 0), ee = ""), m) {
        case "<":
          F = J + F + ne + ee;
          break;
        case "=":
          F = J + ee + F + ne;
          break;
        case "^":
          F = ee.slice(0, se = ee.length >> 1) + J + F + ne + ee.slice(se);
          break;
        default:
          F = ee + J + F + ne;
          break;
      }
      return o(F);
    }
    return O.toString = function() {
      return f + "";
    }, O;
  }
  function c(f, p) {
    var v = Math.max(-8, Math.min(8, Math.floor(Wr(p) / 3))) * 3, m = Math.pow(10, -v), g = d((f = rs(f), f.type = "f", f), { suffix: ym[8 + v / 3] });
    return function(w) {
      return g(m * w);
    };
  }
  return {
    format: d,
    formatPrefix: c
  };
}
var tl, Wf, d_;
Q5({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Q5(e) {
  return tl = Z5(e), Wf = tl.format, d_ = tl.formatPrefix, tl;
}
function e6(e) {
  return Math.max(0, -Wr(Math.abs(e)));
}
function t6(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Wr(t) / 3))) * 3 - Wr(Math.abs(e)));
}
function n6(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Wr(t) - Wr(e)) + 1;
}
function a6(e, t, n, a) {
  var r = Fd(e, t, n), o;
  switch (a = rs(a ?? ",f"), a.type) {
    case "s": {
      var s = Math.max(Math.abs(e), Math.abs(t));
      return a.precision == null && !isNaN(o = t6(r, s)) && (a.precision = o), d_(a, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      a.precision == null && !isNaN(o = n6(r, Math.max(Math.abs(e), Math.abs(t)))) && (a.precision = o - (a.type === "e"));
      break;
    }
    case "f":
    case "%": {
      a.precision == null && !isNaN(o = e6(r)) && (a.precision = o - (a.type === "%") * 2);
      break;
    }
  }
  return Wf(a);
}
function mr(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var a = t();
    return Rd(a[0], a[a.length - 1], n ?? 10);
  }, e.tickFormat = function(n, a) {
    var r = t();
    return a6(r[0], r[r.length - 1], n ?? 10, a);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var a = t(), r = 0, o = a.length - 1, s = a[r], i = a[o], u, d, c = 10;
    for (i < s && (d = s, s = i, i = d, d = r, r = o, o = d); c-- > 0; ) {
      if (d = Vd(s, i, n), d === u)
        return a[r] = s, a[o] = i, t(a);
      if (d > 0)
        s = Math.floor(s / d) * d, i = Math.ceil(i / d) * d;
      else if (d < 0)
        s = Math.ceil(s * d) / d, i = Math.floor(i * d) / d;
      else
        break;
      u = d;
    }
    return e;
  }, e;
}
function c_() {
  var e = u_();
  return e.copy = function() {
    return qs(e, c_());
  }, Nn.apply(e, arguments), mr(e);
}
function f_(e) {
  var t;
  function n(a) {
    return a == null || isNaN(a = +a) ? t : a;
  }
  return n.invert = n, n.domain = n.range = function(a) {
    return arguments.length ? (e = Array.from(a, Xd), n) : e.slice();
  }, n.unknown = function(a) {
    return arguments.length ? (t = a, n) : t;
  }, n.copy = function() {
    return f_(e).unknown(t);
  }, e = arguments.length ? Array.from(e, Xd) : [0, 1], mr(n);
}
function p_(e, t) {
  e = e.slice();
  var n = 0, a = e.length - 1, r = e[n], o = e[a], s;
  return o < r && (s = n, n = a, a = s, s = r, r = o, o = s), e[n] = t.floor(r), e[a] = t.ceil(o), e;
}
function bm(e) {
  return Math.log(e);
}
function _m(e) {
  return Math.exp(e);
}
function r6(e) {
  return -Math.log(-e);
}
function o6(e) {
  return -Math.exp(-e);
}
function s6(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function l6(e) {
  return e === 10 ? s6 : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function i6(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function wm(e) {
  return (t, n) => -e(-t, n);
}
function u6(e) {
  const t = e(bm, _m), n = t.domain;
  let a = 10, r, o;
  function s() {
    return r = i6(a), o = l6(a), n()[0] < 0 ? (r = wm(r), o = wm(o), e(r6, o6)) : e(bm, _m), t;
  }
  return t.base = function(i) {
    return arguments.length ? (a = +i, s()) : a;
  }, t.domain = function(i) {
    return arguments.length ? (n(i), s()) : n();
  }, t.ticks = (i) => {
    const u = n();
    let d = u[0], c = u[u.length - 1];
    const f = c < d;
    f && ([d, c] = [c, d]);
    let p = r(d), v = r(c), m, g;
    const w = i == null ? 10 : +i;
    let C = [];
    if (!(a % 1) && v - p < w) {
      if (p = Math.floor(p), v = Math.ceil(v), d > 0) {
        for (; p <= v; ++p)
          for (m = 1; m < a; ++m)
            if (g = p < 0 ? m / o(-p) : m * o(p), !(g < d)) {
              if (g > c) break;
              C.push(g);
            }
      } else for (; p <= v; ++p)
        for (m = a - 1; m >= 1; --m)
          if (g = p > 0 ? m / o(-p) : m * o(p), !(g < d)) {
            if (g > c) break;
            C.push(g);
          }
      C.length * 2 < w && (C = Rd(d, c, w));
    } else
      C = Rd(p, v, Math.min(v - p, w)).map(o);
    return f ? C.reverse() : C;
  }, t.tickFormat = (i, u) => {
    if (i == null && (i = 10), u == null && (u = a === 10 ? "s" : ","), typeof u != "function" && (!(a % 1) && (u = rs(u)).precision == null && (u.trim = !0), u = Wf(u)), i === 1 / 0) return u;
    const d = Math.max(1, a * i / t.ticks().length);
    return (c) => {
      let f = c / o(Math.round(r(c)));
      return f * a < a - 0.5 && (f *= a), f <= d ? u(c) : "";
    };
  }, t.nice = () => n(p_(n(), {
    floor: (i) => o(Math.floor(r(i))),
    ceil: (i) => o(Math.ceil(r(i)))
  })), t;
}
function v_() {
  const e = u6(su()).domain([1, 10]);
  return e.copy = () => qs(e, v_()).base(e.base()), Nn.apply(e, arguments), e;
}
function xm(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function Cm(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function d6(e) {
  var t = 1, n = e(xm(t), Cm(t));
  return n.constant = function(a) {
    return arguments.length ? e(xm(t = +a), Cm(t)) : t;
  }, mr(n);
}
function m_() {
  var e = d6(su());
  return e.copy = function() {
    return qs(e, m_()).constant(e.constant());
  }, Nn.apply(e, arguments);
}
function Sm(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function c6(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function f6(e) {
  return e < 0 ? -e * e : e * e;
}
function p6(e) {
  var t = e(nn, nn), n = 1;
  function a() {
    return n === 1 ? e(nn, nn) : n === 0.5 ? e(c6, f6) : e(Sm(n), Sm(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, a()) : n;
  }, mr(t);
}
function Gf() {
  var e = p6(su());
  return e.copy = function() {
    return qs(e, Gf()).exponent(e.exponent());
  }, Nn.apply(e, arguments), e;
}
function v6() {
  return Gf.apply(null, arguments).exponent(0.5);
}
function h_() {
  var e = [], t = [], n = [], a;
  function r() {
    var s = 0, i = Math.max(1, t.length);
    for (n = new Array(i - 1); ++s < i; ) n[s - 1] = XV(e, s / i);
    return o;
  }
  function o(s) {
    return s == null || isNaN(s = +s) ? a : t[Ps(n, s)];
  }
  return o.invertExtent = function(s) {
    var i = t.indexOf(s);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? n[i - 1] : e[0],
      i < n.length ? n[i] : e[e.length - 1]
    ];
  }, o.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of s) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort(Io), r();
  }, o.range = function(s) {
    return arguments.length ? (t = Array.from(s), r()) : t.slice();
  }, o.unknown = function(s) {
    return arguments.length ? (a = s, o) : a;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return h_().domain(e).range(t).unknown(a);
  }, Nn.apply(o, arguments);
}
function g_() {
  var e = 0, t = 1, n = 1, a = [0.5], r = [0, 1], o;
  function s(u) {
    return u != null && u <= u ? r[Ps(a, u, 0, n)] : o;
  }
  function i() {
    var u = -1;
    for (a = new Array(n); ++u < n; ) a[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return s;
  }
  return s.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, i()) : [e, t];
  }, s.range = function(u) {
    return arguments.length ? (n = (r = Array.from(u)).length - 1, i()) : r.slice();
  }, s.invertExtent = function(u) {
    var d = r.indexOf(u);
    return d < 0 ? [NaN, NaN] : d < 1 ? [e, a[0]] : d >= n ? [a[n - 1], t] : [a[d - 1], a[d]];
  }, s.unknown = function(u) {
    return arguments.length && (o = u), s;
  }, s.thresholds = function() {
    return a.slice();
  }, s.copy = function() {
    return g_().domain([e, t]).range(r).unknown(o);
  }, Nn.apply(mr(s), arguments);
}
function y_() {
  var e = [0.5], t = [0, 1], n, a = 1;
  function r(o) {
    return o != null && o <= o ? t[Ps(e, o, 0, a)] : n;
  }
  return r.domain = function(o) {
    return arguments.length ? (e = Array.from(o), a = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(o) {
    return arguments.length ? (t = Array.from(o), a = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(o) {
    var s = t.indexOf(o);
    return [e[s - 1], e[s]];
  }, r.unknown = function(o) {
    return arguments.length ? (n = o, r) : n;
  }, r.copy = function() {
    return y_().domain(e).range(t).unknown(n);
  }, Nn.apply(r, arguments);
}
const Ju = /* @__PURE__ */ new Date(), Zu = /* @__PURE__ */ new Date();
function Mt(e, t, n, a) {
  function r(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return r.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), r.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), r.round = (o) => {
    const s = r(o), i = r.ceil(o);
    return o - s < i - o ? s : i;
  }, r.offset = (o, s) => (t(o = /* @__PURE__ */ new Date(+o), s == null ? 1 : Math.floor(s)), o), r.range = (o, s, i) => {
    const u = [];
    if (o = r.ceil(o), i = i == null ? 1 : Math.floor(i), !(o < s) || !(i > 0)) return u;
    let d;
    do
      u.push(d = /* @__PURE__ */ new Date(+o)), t(o, i), e(o);
    while (d < o && o < s);
    return u;
  }, r.filter = (o) => Mt((s) => {
    if (s >= s) for (; e(s), !o(s); ) s.setTime(s - 1);
  }, (s, i) => {
    if (s >= s)
      if (i < 0) for (; ++i <= 0; )
        for (; t(s, -1), !o(s); )
          ;
      else for (; --i >= 0; )
        for (; t(s, 1), !o(s); )
          ;
  }), n && (r.count = (o, s) => (Ju.setTime(+o), Zu.setTime(+s), e(Ju), e(Zu), Math.floor(n(Ju, Zu))), r.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(a ? (s) => a(s) % o === 0 : (s) => r.count(0, s) % o === 0) : r)), r;
}
const li = Mt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
li.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Mt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : li);
li.range;
const ua = 1e3, xn = ua * 60, da = xn * 60, va = da * 24, Kf = va * 7, $m = va * 30, Qu = va * 365, Xa = Mt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * ua);
}, (e, t) => (t - e) / ua, (e) => e.getUTCSeconds());
Xa.range;
const Yf = Mt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ua);
}, (e, t) => {
  e.setTime(+e + t * xn);
}, (e, t) => (t - e) / xn, (e) => e.getMinutes());
Yf.range;
const Xf = Mt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * xn);
}, (e, t) => (t - e) / xn, (e) => e.getUTCMinutes());
Xf.range;
const Jf = Mt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * ua - e.getMinutes() * xn);
}, (e, t) => {
  e.setTime(+e + t * da);
}, (e, t) => (t - e) / da, (e) => e.getHours());
Jf.range;
const Zf = Mt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * da);
}, (e, t) => (t - e) / da, (e) => e.getUTCHours());
Zf.range;
const Ts = Mt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * xn) / va,
  (e) => e.getDate() - 1
);
Ts.range;
const lu = Mt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / va, (e) => e.getUTCDate() - 1);
lu.range;
const b_ = Mt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / va, (e) => Math.floor(e / va));
b_.range;
function hr(e) {
  return Mt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * xn) / Kf);
}
const iu = hr(0), ii = hr(1), m6 = hr(2), h6 = hr(3), Gr = hr(4), g6 = hr(5), y6 = hr(6);
iu.range;
ii.range;
m6.range;
h6.range;
Gr.range;
g6.range;
y6.range;
function gr(e) {
  return Mt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / Kf);
}
const uu = gr(0), ui = gr(1), b6 = gr(2), _6 = gr(3), Kr = gr(4), w6 = gr(5), x6 = gr(6);
uu.range;
ui.range;
b6.range;
_6.range;
Kr.range;
w6.range;
x6.range;
const Qf = Mt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
Qf.range;
const ep = Mt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
ep.range;
const ma = Mt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
ma.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Mt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
ma.range;
const ha = Mt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
ha.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Mt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
ha.range;
function __(e, t, n, a, r, o) {
  const s = [
    [Xa, 1, ua],
    [Xa, 5, 5 * ua],
    [Xa, 15, 15 * ua],
    [Xa, 30, 30 * ua],
    [o, 1, xn],
    [o, 5, 5 * xn],
    [o, 15, 15 * xn],
    [o, 30, 30 * xn],
    [r, 1, da],
    [r, 3, 3 * da],
    [r, 6, 6 * da],
    [r, 12, 12 * da],
    [a, 1, va],
    [a, 2, 2 * va],
    [n, 1, Kf],
    [t, 1, $m],
    [t, 3, 3 * $m],
    [e, 1, Qu]
  ];
  function i(d, c, f) {
    const p = c < d;
    p && ([d, c] = [c, d]);
    const v = f && typeof f.range == "function" ? f : u(d, c, f), m = v ? v.range(d, +c + 1) : [];
    return p ? m.reverse() : m;
  }
  function u(d, c, f) {
    const p = Math.abs(c - d) / f, v = Mf(([, , w]) => w).right(s, p);
    if (v === s.length) return e.every(Fd(d / Qu, c / Qu, f));
    if (v === 0) return li.every(Math.max(Fd(d, c, f), 1));
    const [m, g] = s[p / s[v - 1][2] < s[v][2] / p ? v - 1 : v];
    return m.every(g);
  }
  return [i, u];
}
const [C6, S6] = __(ha, ep, uu, b_, Zf, Xf), [$6, k6] = __(ma, Qf, iu, Ts, Jf, Yf);
function ed(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function td(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function bo(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function B6(e) {
  var t = e.dateTime, n = e.date, a = e.time, r = e.periods, o = e.days, s = e.shortDays, i = e.months, u = e.shortMonths, d = _o(r), c = wo(r), f = _o(o), p = wo(o), v = _o(s), m = wo(s), g = _o(i), w = wo(i), C = _o(u), S = wo(u), $ = {
    a: H,
    A: U,
    b: se,
    B: ee,
    c: null,
    d: Em,
    e: Em,
    f: X6,
    g: sL,
    G: iL,
    H: G6,
    I: K6,
    j: Y6,
    L: w_,
    m: J6,
    M: Z6,
    p: de,
    q: pe,
    Q: Am,
    s: Im,
    S: Q6,
    u: eL,
    U: tL,
    V: nL,
    w: aL,
    W: rL,
    x: null,
    X: null,
    y: oL,
    Y: lL,
    Z: uL,
    "%": Tm
  }, B = {
    a: _e,
    A: ge,
    b: Te,
    B: ce,
    c: null,
    d: qm,
    e: qm,
    f: pL,
    g: CL,
    G: $L,
    H: dL,
    I: cL,
    j: fL,
    L: C_,
    m: vL,
    M: mL,
    p: R,
    q: te,
    Q: Am,
    s: Im,
    S: hL,
    u: gL,
    U: yL,
    V: bL,
    w: _L,
    W: wL,
    x: null,
    X: null,
    y: xL,
    Y: SL,
    Z: kL,
    "%": Tm
  }, k = {
    a: M,
    A: O,
    b: F,
    B: J,
    c: ne,
    d: Pm,
    e: Pm,
    f: H6,
    g: Dm,
    G: Bm,
    H: Mm,
    I: Mm,
    j: F6,
    L: z6,
    m: V6,
    M: N6,
    p: T,
    q: R6,
    Q: j6,
    s: W6,
    S: L6,
    u: q6,
    U: T6,
    V: A6,
    w: E6,
    W: I6,
    x: Q,
    X: G,
    y: Dm,
    Y: Bm,
    Z: O6,
    "%": U6
  };
  $.x = P(n, $), $.X = P(a, $), $.c = P(t, $), B.x = P(n, B), B.X = P(a, B), B.c = P(t, B);
  function P(z, re) {
    return function(ie) {
      var L = [], be = -1, xe = 0, Fe = z.length, Xe, lt, De;
      for (ie instanceof Date || (ie = /* @__PURE__ */ new Date(+ie)); ++be < Fe; )
        z.charCodeAt(be) === 37 && (L.push(z.slice(xe, be)), (lt = km[Xe = z.charAt(++be)]) != null ? Xe = z.charAt(++be) : lt = Xe === "e" ? " " : "0", (De = re[Xe]) && (Xe = De(ie, lt)), L.push(Xe), xe = be + 1);
      return L.push(z.slice(xe, be)), L.join("");
    };
  }
  function D(z, re) {
    return function(ie) {
      var L = bo(1900, void 0, 1), be = q(L, z, ie += "", 0), xe, Fe;
      if (be != ie.length) return null;
      if ("Q" in L) return new Date(L.Q);
      if ("s" in L) return new Date(L.s * 1e3 + ("L" in L ? L.L : 0));
      if (re && !("Z" in L) && (L.Z = 0), "p" in L && (L.H = L.H % 12 + L.p * 12), L.m === void 0 && (L.m = "q" in L ? L.q : 0), "V" in L) {
        if (L.V < 1 || L.V > 53) return null;
        "w" in L || (L.w = 1), "Z" in L ? (xe = td(bo(L.y, 0, 1)), Fe = xe.getUTCDay(), xe = Fe > 4 || Fe === 0 ? ui.ceil(xe) : ui(xe), xe = lu.offset(xe, (L.V - 1) * 7), L.y = xe.getUTCFullYear(), L.m = xe.getUTCMonth(), L.d = xe.getUTCDate() + (L.w + 6) % 7) : (xe = ed(bo(L.y, 0, 1)), Fe = xe.getDay(), xe = Fe > 4 || Fe === 0 ? ii.ceil(xe) : ii(xe), xe = Ts.offset(xe, (L.V - 1) * 7), L.y = xe.getFullYear(), L.m = xe.getMonth(), L.d = xe.getDate() + (L.w + 6) % 7);
      } else ("W" in L || "U" in L) && ("w" in L || (L.w = "u" in L ? L.u % 7 : "W" in L ? 1 : 0), Fe = "Z" in L ? td(bo(L.y, 0, 1)).getUTCDay() : ed(bo(L.y, 0, 1)).getDay(), L.m = 0, L.d = "W" in L ? (L.w + 6) % 7 + L.W * 7 - (Fe + 5) % 7 : L.w + L.U * 7 - (Fe + 6) % 7);
      return "Z" in L ? (L.H += L.Z / 100 | 0, L.M += L.Z % 100, td(L)) : ed(L);
    };
  }
  function q(z, re, ie, L) {
    for (var be = 0, xe = re.length, Fe = ie.length, Xe, lt; be < xe; ) {
      if (L >= Fe) return -1;
      if (Xe = re.charCodeAt(be++), Xe === 37) {
        if (Xe = re.charAt(be++), lt = k[Xe in km ? re.charAt(be++) : Xe], !lt || (L = lt(z, ie, L)) < 0) return -1;
      } else if (Xe != ie.charCodeAt(L++))
        return -1;
    }
    return L;
  }
  function T(z, re, ie) {
    var L = d.exec(re.slice(ie));
    return L ? (z.p = c.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function M(z, re, ie) {
    var L = v.exec(re.slice(ie));
    return L ? (z.w = m.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function O(z, re, ie) {
    var L = f.exec(re.slice(ie));
    return L ? (z.w = p.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function F(z, re, ie) {
    var L = C.exec(re.slice(ie));
    return L ? (z.m = S.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function J(z, re, ie) {
    var L = g.exec(re.slice(ie));
    return L ? (z.m = w.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function ne(z, re, ie) {
    return q(z, t, re, ie);
  }
  function Q(z, re, ie) {
    return q(z, n, re, ie);
  }
  function G(z, re, ie) {
    return q(z, a, re, ie);
  }
  function H(z) {
    return s[z.getDay()];
  }
  function U(z) {
    return o[z.getDay()];
  }
  function se(z) {
    return u[z.getMonth()];
  }
  function ee(z) {
    return i[z.getMonth()];
  }
  function de(z) {
    return r[+(z.getHours() >= 12)];
  }
  function pe(z) {
    return 1 + ~~(z.getMonth() / 3);
  }
  function _e(z) {
    return s[z.getUTCDay()];
  }
  function ge(z) {
    return o[z.getUTCDay()];
  }
  function Te(z) {
    return u[z.getUTCMonth()];
  }
  function ce(z) {
    return i[z.getUTCMonth()];
  }
  function R(z) {
    return r[+(z.getUTCHours() >= 12)];
  }
  function te(z) {
    return 1 + ~~(z.getUTCMonth() / 3);
  }
  return {
    format: function(z) {
      var re = P(z += "", $);
      return re.toString = function() {
        return z;
      }, re;
    },
    parse: function(z) {
      var re = D(z += "", !1);
      return re.toString = function() {
        return z;
      }, re;
    },
    utcFormat: function(z) {
      var re = P(z += "", B);
      return re.toString = function() {
        return z;
      }, re;
    },
    utcParse: function(z) {
      var re = D(z += "", !0);
      return re.toString = function() {
        return z;
      }, re;
    }
  };
}
var km = { "-": "", _: " ", 0: "0" }, Ot = /^\s*\d+/, D6 = /^%/, P6 = /[\\^$*+?|[\]().{}]/g;
function Ze(e, t, n) {
  var a = e < 0 ? "-" : "", r = (a ? -e : e) + "", o = r.length;
  return a + (o < n ? new Array(n - o + 1).join(t) + r : r);
}
function M6(e) {
  return e.replace(P6, "\\$&");
}
function _o(e) {
  return new RegExp("^(?:" + e.map(M6).join("|") + ")", "i");
}
function wo(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function E6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 1));
  return a ? (e.w = +a[0], n + a[0].length) : -1;
}
function q6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 1));
  return a ? (e.u = +a[0], n + a[0].length) : -1;
}
function T6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.U = +a[0], n + a[0].length) : -1;
}
function A6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.V = +a[0], n + a[0].length) : -1;
}
function I6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.W = +a[0], n + a[0].length) : -1;
}
function Bm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 4));
  return a ? (e.y = +a[0], n + a[0].length) : -1;
}
function Dm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), n + a[0].length) : -1;
}
function O6(e, t, n) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), n + a[0].length) : -1;
}
function R6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 1));
  return a ? (e.q = a[0] * 3 - 3, n + a[0].length) : -1;
}
function V6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.m = a[0] - 1, n + a[0].length) : -1;
}
function Pm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.d = +a[0], n + a[0].length) : -1;
}
function F6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 3));
  return a ? (e.m = 0, e.d = +a[0], n + a[0].length) : -1;
}
function Mm(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.H = +a[0], n + a[0].length) : -1;
}
function N6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.M = +a[0], n + a[0].length) : -1;
}
function L6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 2));
  return a ? (e.S = +a[0], n + a[0].length) : -1;
}
function z6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 3));
  return a ? (e.L = +a[0], n + a[0].length) : -1;
}
function H6(e, t, n) {
  var a = Ot.exec(t.slice(n, n + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), n + a[0].length) : -1;
}
function U6(e, t, n) {
  var a = D6.exec(t.slice(n, n + 1));
  return a ? n + a[0].length : -1;
}
function j6(e, t, n) {
  var a = Ot.exec(t.slice(n));
  return a ? (e.Q = +a[0], n + a[0].length) : -1;
}
function W6(e, t, n) {
  var a = Ot.exec(t.slice(n));
  return a ? (e.s = +a[0], n + a[0].length) : -1;
}
function Em(e, t) {
  return Ze(e.getDate(), t, 2);
}
function G6(e, t) {
  return Ze(e.getHours(), t, 2);
}
function K6(e, t) {
  return Ze(e.getHours() % 12 || 12, t, 2);
}
function Y6(e, t) {
  return Ze(1 + Ts.count(ma(e), e), t, 3);
}
function w_(e, t) {
  return Ze(e.getMilliseconds(), t, 3);
}
function X6(e, t) {
  return w_(e, t) + "000";
}
function J6(e, t) {
  return Ze(e.getMonth() + 1, t, 2);
}
function Z6(e, t) {
  return Ze(e.getMinutes(), t, 2);
}
function Q6(e, t) {
  return Ze(e.getSeconds(), t, 2);
}
function eL(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function tL(e, t) {
  return Ze(iu.count(ma(e) - 1, e), t, 2);
}
function x_(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Gr(e) : Gr.ceil(e);
}
function nL(e, t) {
  return e = x_(e), Ze(Gr.count(ma(e), e) + (ma(e).getDay() === 4), t, 2);
}
function aL(e) {
  return e.getDay();
}
function rL(e, t) {
  return Ze(ii.count(ma(e) - 1, e), t, 2);
}
function oL(e, t) {
  return Ze(e.getFullYear() % 100, t, 2);
}
function sL(e, t) {
  return e = x_(e), Ze(e.getFullYear() % 100, t, 2);
}
function lL(e, t) {
  return Ze(e.getFullYear() % 1e4, t, 4);
}
function iL(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Gr(e) : Gr.ceil(e), Ze(e.getFullYear() % 1e4, t, 4);
}
function uL(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ze(t / 60 | 0, "0", 2) + Ze(t % 60, "0", 2);
}
function qm(e, t) {
  return Ze(e.getUTCDate(), t, 2);
}
function dL(e, t) {
  return Ze(e.getUTCHours(), t, 2);
}
function cL(e, t) {
  return Ze(e.getUTCHours() % 12 || 12, t, 2);
}
function fL(e, t) {
  return Ze(1 + lu.count(ha(e), e), t, 3);
}
function C_(e, t) {
  return Ze(e.getUTCMilliseconds(), t, 3);
}
function pL(e, t) {
  return C_(e, t) + "000";
}
function vL(e, t) {
  return Ze(e.getUTCMonth() + 1, t, 2);
}
function mL(e, t) {
  return Ze(e.getUTCMinutes(), t, 2);
}
function hL(e, t) {
  return Ze(e.getUTCSeconds(), t, 2);
}
function gL(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function yL(e, t) {
  return Ze(uu.count(ha(e) - 1, e), t, 2);
}
function S_(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Kr(e) : Kr.ceil(e);
}
function bL(e, t) {
  return e = S_(e), Ze(Kr.count(ha(e), e) + (ha(e).getUTCDay() === 4), t, 2);
}
function _L(e) {
  return e.getUTCDay();
}
function wL(e, t) {
  return Ze(ui.count(ha(e) - 1, e), t, 2);
}
function xL(e, t) {
  return Ze(e.getUTCFullYear() % 100, t, 2);
}
function CL(e, t) {
  return e = S_(e), Ze(e.getUTCFullYear() % 100, t, 2);
}
function SL(e, t) {
  return Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function $L(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Kr(e) : Kr.ceil(e), Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function kL() {
  return "+0000";
}
function Tm() {
  return "%";
}
function Am(e) {
  return +e;
}
function Im(e) {
  return Math.floor(+e / 1e3);
}
var Sr, $_, k_;
BL({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function BL(e) {
  return Sr = B6(e), $_ = Sr.format, Sr.parse, k_ = Sr.utcFormat, Sr.utcParse, Sr;
}
function DL(e) {
  return new Date(e);
}
function PL(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function tp(e, t, n, a, r, o, s, i, u, d) {
  var c = u_(), f = c.invert, p = c.domain, v = d(".%L"), m = d(":%S"), g = d("%I:%M"), w = d("%I %p"), C = d("%a %d"), S = d("%b %d"), $ = d("%B"), B = d("%Y");
  function k(P) {
    return (u(P) < P ? v : i(P) < P ? m : s(P) < P ? g : o(P) < P ? w : a(P) < P ? r(P) < P ? C : S : n(P) < P ? $ : B)(P);
  }
  return c.invert = function(P) {
    return new Date(f(P));
  }, c.domain = function(P) {
    return arguments.length ? p(Array.from(P, PL)) : p().map(DL);
  }, c.ticks = function(P) {
    var D = p();
    return e(D[0], D[D.length - 1], P ?? 10);
  }, c.tickFormat = function(P, D) {
    return D == null ? k : d(D);
  }, c.nice = function(P) {
    var D = p();
    return (!P || typeof P.range != "function") && (P = t(D[0], D[D.length - 1], P ?? 10)), P ? p(p_(D, P)) : c;
  }, c.copy = function() {
    return qs(c, tp(e, t, n, a, r, o, s, i, u, d));
  }, c;
}
function ML() {
  return Nn.apply(tp($6, k6, ma, Qf, iu, Ts, Jf, Yf, Xa, $_).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function EL() {
  return Nn.apply(tp(C6, S6, ha, ep, uu, lu, Zf, Xf, Xa, k_).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function qL() {
  var e = 0, t = 1, n, a, r, o, s = nn, i = !1, u;
  function d(f) {
    return f == null || isNaN(f = +f) ? u : s(r === 0 ? 0.5 : (f = (o(f) - n) * r, i ? Math.max(0, Math.min(1, f)) : f));
  }
  d.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = o(e = +e), a = o(t = +t), r = n === a ? 0 : 1 / (a - n), d) : [e, t];
  }, d.clamp = function(f) {
    return arguments.length ? (i = !!f, d) : i;
  }, d.interpolator = function(f) {
    return arguments.length ? (s = f, d) : s;
  };
  function c(f) {
    return function(p) {
      var v, m;
      return arguments.length ? ([v, m] = p, s = f(v, m), d) : [s(0), s(1)];
    };
  }
  return d.range = c(uo), d.rangeRound = c(Lf), d.unknown = function(f) {
    return arguments.length ? (u = f, d) : u;
  }, function(f) {
    return o = f, n = f(e), a = f(t), r = n === a ? 0 : 1 / (a - n), d;
  };
}
function B_(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function D_() {
  var e = mr(qL()(nn));
  return e.copy = function() {
    return B_(e, D_());
  }, l_.apply(e, arguments);
}
function TL() {
  var e = 0, t = 0.5, n = 1, a = 1, r, o, s, i, u, d = nn, c, f = !1, p;
  function v(g) {
    return isNaN(g = +g) ? p : (g = 0.5 + ((g = +c(g)) - o) * (a * g < a * o ? i : u), d(f ? Math.max(0, Math.min(1, g)) : g));
  }
  v.domain = function(g) {
    return arguments.length ? ([e, t, n] = g, r = c(e = +e), o = c(t = +t), s = c(n = +n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v) : [e, t, n];
  }, v.clamp = function(g) {
    return arguments.length ? (f = !!g, v) : f;
  }, v.interpolator = function(g) {
    return arguments.length ? (d = g, v) : d;
  };
  function m(g) {
    return function(w) {
      var C, S, $;
      return arguments.length ? ([C, S, $] = w, d = RN(g, [C, S, $]), v) : [d(0), d(0.5), d(1)];
    };
  }
  return v.range = m(uo), v.rangeRound = m(Lf), v.unknown = function(g) {
    return arguments.length ? (p = g, v) : p;
  }, function(g) {
    return c = g, r = g(e), o = g(t), s = g(n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v;
  };
}
function P_() {
  var e = mr(TL()(nn));
  return e.copy = function() {
    return B_(e, P_());
  }, l_.apply(e, arguments);
}
const Om = {
  scaleLinear: c_,
  scalePow: Gf,
  scaleSqrt: v6,
  scaleLog: v_,
  scaleSymlog: m_,
  scaleIdentity: f_,
  scaleTime: ML,
  scaleUtc: EL,
  scaleSequential: D_,
  scaleDiverging: P_,
  scaleQuantize: g_,
  scaleQuantile: h_,
  scaleThreshold: y_,
  scaleOrdinal: Hf,
  scaleBand: Uf,
  scalePoint: L5
};
var zn;
(function(e) {
  e.X = "x", e.Y = "y";
})(zn || (zn = {}));
const M_ = {
  duration: 600,
  events: {},
  attributes: {}
};
class AL {
  constructor(t = Ao.SVG) {
    var n, a;
    this.type = Ao.SVG, this.datamodel = new s_(), this.sizing = Od.Fit, this.events = {}, this._defaultConfig = M_, this._width = 400, this._height = 200, this._containerWidth = void 0, this._containerHeight = void 0, this._containerMargin = { top: 0, bottom: 0, left: 0, right: 0 }, this._setUpComponentEventsThrottled = Yl(this._setUpComponentEvents, 500), this._setCustomAttributesThrottled = Yl(this._setCustomAttributes, 500), t === Ao.SVG ? this.element = document.createElementNS("http://www.w3.org/2000/svg", "g") : this.element = document.createElement("div"), this.uid = GF(), this.g = qa(this.element);
    const r = (a = (n = this.constructor) === null || n === void 0 ? void 0 : n.selectors) === null || a === void 0 ? void 0 : a.root;
    r && this.g.attr("class", r);
  }
  /** Set the container margin. Called automatically by containers. */
  setContainerMargin(t) {
    this._containerMargin = t;
  }
  setConfig(t) {
    this.prevConfig = this.config, this.config = eu(this._defaultConfig, t);
  }
  setData(t) {
    this.datamodel.data = t;
  }
  setSize(t, n, a, r) {
    isFinite(t) && (this._width = t), isFinite(n) && (this._height = n), isFinite(a) && (this._containerWidth = a), isFinite(r) && (this._containerHeight = r);
  }
  render(t = this.config.duration) {
    this._render(t);
    const n = "animating";
    t && (this.g.attr(n, ""), this.g.transition(n).duration(t).on("end interrupt", () => {
      this.g.attr(n, null);
    })), this._setUpComponentEventsThrottled(), this._setCustomAttributesThrottled();
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _render(t = this.config.duration) {
  }
  _setCustomAttributes() {
    const t = this.config.attributes;
    Object.keys(t).forEach((n) => {
      Object.keys(t[n]).forEach((a) => {
        this.g.selectAll(`.${n}`).attr(a, t[n][a]);
      });
    });
  }
  _setUpComponentEvents() {
    this._bindEvents(this.events), this._bindEvents(this.config.events, ".user");
  }
  _bindEvents(t = this.events, n = "") {
    Object.keys(t).forEach((a) => {
      Object.keys(t[a]).forEach((r) => {
        const o = this.g.selectAll(`.${a}`);
        o.on(r + n, (s, i) => {
          const u = o.nodes(), d = u.indexOf(s.currentTarget), c = t[a][r];
          return c?.(i, s, d, u);
        });
      });
    });
  }
  destroy() {
    var t;
    (t = this.g) === null || t === void 0 || t.remove(), this.element = void 0;
  }
  isDestroyed() {
    return !this.element;
  }
}
class IL extends s_ {
  constructor(t) {
    super(t);
  }
  get data() {
    var t;
    return (t = this._data) !== null && t !== void 0 ? t : [];
  }
  set data(t) {
    Array.isArray(t) && (this._data = t);
  }
}
const E_ = Object.assign(Object.assign({}, M_), { x: void 0, y: void 0, id: (e, t) => {
  var n;
  return (n = e.id) !== null && n !== void 0 ? n : `${t}`;
}, color: (e) => e.color, xScale: void 0, yScale: void 0, excludeFromDomainCalculation: !1 });
class OL extends AL {
  constructor() {
    super(...arguments), this.datamodel = new IL(), this.clippable = !0, this.stacked = !1, this._defaultConfig = E_, this._xScale = Om.scaleLinear(), this._yScale = Om.scaleLinear();
  }
  get xScale() {
    return this.config.xScale || this._xScale;
  }
  get yScale() {
    return this.config.yScale || this._yScale;
  }
  setConfig(t) {
    var n, a;
    !((n = this.config) === null || n === void 0) && n.xScale && (t.xScale = this.config.xScale), !((a = this.config) === null || a === void 0) && a.yScale && (t.yScale = this.config.yScale), super.setConfig(t);
  }
  setScaleDomain(t, n) {
    var a, r;
    t === zn.X && ((a = this._xScale) === null || a === void 0 || a.domain(n)), t === zn.Y && ((r = this._yScale) === null || r === void 0 || r.domain(n));
  }
  setScaleRange(t, n) {
    var a, r;
    t === zn.X && ((a = this._xScale) === null || a === void 0 || a.range(n)), t === zn.Y && ((r = this._yScale) === null || r === void 0 || r.range(n));
  }
  setScale(t, n) {
    n && t === zn.X && (this._xScale = n), n && t === zn.Y && (this._yScale = n);
  }
  getDataExtent(t, n) {
    const { config: a, datamodel: r } = this;
    switch (t) {
      case zn.X:
        return this.getXDataExtent();
      case zn.Y:
        return this.getYDataExtent(n);
      default:
        return Hu(r.data, a[t]);
    }
  }
  getXDataExtent() {
    const { config: t, datamodel: n } = this;
    return Hu(n.data, t.x);
  }
  /** Some components override this method to provide custom data extent calculation */
  getYDataExtent(t) {
    const { config: n, datamodel: a } = this, r = this.xScale.domain(), o = t ? aF(a.data, r, n.x, !0) : a.data, s = qf(n.y) ? n.y : [n.y];
    return Hu(o, ...s);
  }
}
var tt;
(function(e) {
  e.Top = "top", e.Bottom = "bottom", e.Left = "left", e.Right = "right", e.Center = "center", e.Auto = "auto";
})(tt || (tt = {}));
var Rm;
(function(e) {
  e.Absolute = "absolute", e.Fixed = "fixed";
})(Rm || (Rm = {}));
var Vm;
(function(e) {
  e.Inside = "inside", e.Outside = "outside", e.Center = "center";
})(Vm || (Vm = {}));
var Fm;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(Fm || (Fm = {}));
const RL = {
  components: [],
  container: void 0,
  followCursor: !0,
  allowHover: !1,
  horizontalPlacement: tt.Auto,
  horizontalShift: 0,
  verticalPlacement: tt.Top,
  verticalShift: 0,
  attributes: {},
  triggers: {},
  className: void 0,
  showDelay: void 0,
  hideDelay: void 0
}, du = ln`
  label: tooltip;
  display: inline-block;
  left: 0;
  bottom: 0;
  min-width: max-content;
  position: absolute;
  opacity: 0;
  transition: opacity;
  transition-duration: var(--vis-tooltip-transition-duration);
  z-index: 999999;
  padding: var(--vis-tooltip-padding);
  color: var(--vis-tooltip-text-color);
  border-radius: var(--vis-tooltip-border-radius);
  box-shadow: var(--vis-tooltip-box-shadow);
  border: solid 1px var(--vis-tooltip-border-color);
  background-color: var(--vis-tooltip-background-color);
  backdrop-filter: var(--vis-tooltip-backdrop-filter);
`, VL = du, FL = Of`
  :root {
    --vis-tooltip-background-color: rgba(255, 255, 255, 0.95);
    --vis-tooltip-border-color: #e5e9f7;
    --vis-tooltip-text-color: #000;
    --vis-tooltip-shadow-color: rgba(172, 179, 184, 0.35);
    --vis-tooltip-backdrop-filter: none;
    --vis-tooltip-padding: 10px 15px;
    --vis-tooltip-border-radius: 5px;
    --vis-tooltip-transition-duration: 300ms;
    --vis-tooltip-box-shadow: none;

    --vis-dark-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-dark-tooltip-text-color: #e5e9f7;
    --vis-dark-tooltip-border-color: var(--vis-color-grey);
    --vis-dark-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }

  body.theme-dark ${`.${du}`} {
    --vis-tooltip-background-color: var(--vis-dark-tooltip-background-color);
    --vis-tooltip-text-color: var(--vis-dark-tooltip-text-color);
    --vis-tooltip-border-color: var(--vis-dark-tooltip-border-color);
    --vis-tooltip-shadow-color: var(--vis-dark-tooltip-shadow-color);
  }

  body.theme-dark {
    --vis-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-tooltip-text-color: #e5e9f7;
    --vis-tooltip-border-color: var(--vis-color-grey);
    --vis-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }
`, q_ = ln`
  bottom: unset;
  position: fixed;
`, wl = ln`
  opacity: 1;
`, xl = ln`
  display: none;
`, T_ = ln`
  label: non-interactive;
  pointer-events: none;
  user-select: none;
`, NL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hidden: xl,
  nonInteractive: T_,
  positionFixed: q_,
  root: du,
  show: wl,
  tooltip: VL,
  variables: FL
}, Symbol.toStringTag, { value: "Module" }));
class A_ {
  constructor(t = {}) {
    this._defaultConfig = RL, this.config = this._defaultConfig, this._setUpEventsThrottled = Yl(this._setUpEvents, 500), this._setContainerPositionThrottled = Yl(this._setContainerPosition, 500), this._isShown = !1, this.element = document.createElement("div"), this.div = qa(this.element).attr("class", du).classed(wl, !1).classed(xl, !0), this.setConfig(t), this.components = this.config.components, this._mutationObserver = new MutationObserver(() => {
      this._isShown && (!this.config.followCursor && this._hoveredElement ? this.placeByElement(this._hoveredElement) : this._position && this.place({ x: this._position[0], y: this._position[1] }));
    }), this._mutationObserver.observe(this.div.node(), { childList: !0, subtree: !0 });
  }
  setConfig(t) {
    var n;
    this.prevConfig = this.config, this.config = eu(this._defaultConfig, t), this.prevConfig.horizontalPlacement !== this.config.horizontalPlacement && this.overrideHorizontalPlacement(void 0), this.config.container && this.config.container !== ((n = this.prevConfig) === null || n === void 0 ? void 0 : n.container) && this.setContainer(this.config.container), this._setUpAttributes();
  }
  setContainer(t) {
    var n;
    (n = this.element.parentNode) === null || n === void 0 || n.removeChild(this.element), this._container = t, this._container.appendChild(this.element), this._setContainerPositionThrottled();
  }
  getContainer() {
    return this._container;
  }
  hasContainer() {
    return !!this._container && this._container.isConnected;
  }
  setComponents(t) {
    this.components = t;
  }
  update() {
    this._container && this._setUpEventsThrottled();
  }
  /** Show the tooltip immediately by providing content and position */
  show(t, n) {
    this.render(t), this.place(n);
  }
  _hide() {
    this.div.classed(wl, !1).on("transitionend", () => {
      this.div.classed(xl, !this._isShown);
    }), this._isShown = !1;
  }
  /** Hides the tooltip after `hideDelay` */
  hide() {
    window.clearTimeout(this._showDelayTimeoutId), this.config.hideDelay ? (window.clearTimeout(this._hideDelayTimeoutId), this._hideDelayTimeoutId = setTimeout(() => this._hide(), this.config.hideDelay)) : this._hide();
  }
  _display() {
    window.clearTimeout(this._hideDelayTimeoutId), this.div.classed(xl, !1).classed(wl, !0), this._isShown = !0;
  }
  /** Simply display the tooltip with its previous content on position, taking into account `showDelay` */
  display() {
    this._isShown || (this.config.showDelay ? (window.clearTimeout(this._showDelayTimeoutId), this._showDelayTimeoutId = setTimeout(() => {
      this._display(), this.place({ x: this._position[0], y: this._position[1] });
    }, this.config.showDelay)) : this._display());
  }
  place(t) {
    if (this._position = [t.x, t.y], !this.hasContainer()) {
      console.warn("Unovis | Tooltip: Container was not set or is not initialized yet");
      return;
    }
    const { config: n } = this, a = this.element.offsetWidth, r = this.element.offsetHeight, o = this._overriddenHorizontalPlacement || (n.horizontalPlacement === tt.Auto ? tt.Center : n.horizontalPlacement), s = n.verticalPlacement === tt.Auto ? t.y - r < 0 ? tt.Bottom : tt.Top : n.verticalPlacement, i = 5, u = o === tt.Left ? -a - i - n.horizontalShift : o === tt.Center ? -a / 2 : i + n.horizontalShift, d = s === tt.Bottom ? i + n.verticalShift : s === tt.Center ? -r / 2 : -i - n.verticalShift - r, [c, f] = this._constraintPosToContainer(t.x + u, t.y + d, a, r);
    this._applyPosition(c, f, r);
  }
  placeByElement(t) {
    const { config: n } = this;
    this._hoveredElement = t;
    const a = 5, r = this.element.offsetWidth, o = this.element.offsetHeight, s = this.isContainerBody(), i = s ? window.innerWidth : this._container.scrollWidth, u = t.getBoundingClientRect(), d = s ? [u.x, u.y] : jl({
      clientX: u.x,
      clientY: u.y,
      pageX: u.x,
      pageY: u.y
    }, this._container), c = this._overriddenHorizontalPlacement || (n.horizontalPlacement === tt.Auto ? d[0] - r < 0 ? tt.Right : d[0] + r > i ? tt.Left : tt.Center : n.horizontalPlacement);
    let f = 0;
    switch (c) {
      case tt.Left:
        f = -r - a - n.horizontalShift;
        break;
      case tt.Right:
        f = u.width + a + n.horizontalShift;
        break;
      case tt.Center:
      default:
        f = (-r + u.width) / 2;
        break;
    }
    const p = n.verticalPlacement === tt.Auto ? c !== tt.Center ? tt.Center : d[1] - o < 0 ? tt.Bottom : tt.Top : n.verticalPlacement;
    let v = -o;
    switch (p) {
      case tt.Center:
        v += (o + u.height) / 2;
        break;
      case tt.Bottom:
        v += o + u.height + a + n.verticalShift;
        break;
      case tt.Top:
      default:
        v += -a - n.verticalShift;
        break;
    }
    const [m, g] = this._constraintPosToContainer(d[0] + f, d[1] + v, r, o);
    this._applyPosition(m, g, o);
  }
  isContainerBody() {
    return this._container === document.body;
  }
  /** Allows to override the horizontal placement of the tooltip which is useful when you want to define custom positioning behavior.
   * This method has been added for Crosshair to allow it position tooltip left or right of the crosshair line
   * (see the `_showTooltip` method of the Crosshair component).
   */
  overrideHorizontalPlacement(t) {
    this._overriddenHorizontalPlacement = t;
  }
  render(t) {
    var n;
    const { config: a, prevConfig: r } = this;
    t instanceof HTMLElement ? this.div.select(":first-child").node() !== t && this.div.html("").append(() => t) : t !== null && this.div.html(t || ""), this.div.classed((n = a.className) !== null && n !== void 0 ? n : "", !!a.className).classed(T_, !a.allowHover), r?.className && r.className !== a.className && this.div.classed(r.className, !1), this.display();
  }
  _applyPosition(t, n, a) {
    const r = this.isContainerBody(), o = r ? window.innerHeight : this._container.scrollHeight;
    this.div.classed(q_, r).style("top", r ? `${n}px` : "unset").style("bottom", r ? "unset" : `${o - n - a}px`).style("left", `${t}px`);
  }
  _constraintPosToContainer(t, n, a, r) {
    const o = this.isContainerBody(), s = o ? window.innerHeight : this._container.scrollHeight, i = o ? window.innerWidth : this._container.scrollWidth, u = 10, d = t > i - a - u, c = t < u, f = d ? i - a - u : c ? u : t, p = 10, v = n > s - r - p, m = n < p, g = v ? s - r - p : m ? p : n;
    return [
      i < a ? 0 : f,
      s < r ? 0 : g
    ];
  }
  _setContainerPosition() {
    var t;
    this._container !== document.body && ((t = getComputedStyle(this._container)) === null || t === void 0 ? void 0 : t.position) === "static" && (this._container.style.position = "relative");
  }
  _setUpEvents() {
    const { config: t } = this;
    this.components.forEach((n) => {
      const a = qa(n.element);
      a.on("mousemove.tooltip", (r) => {
        const { config: o } = this, s = r.composedPath && r.composedPath() || r.path || [r.target];
        for (const i of Object.keys(o.triggers)) {
          const u = o.triggers[i];
          if (!u)
            continue;
          const d = a.selectAll(`.${i}`).nodes();
          for (const c of s) {
            if (c === a.node())
              break;
            if (c.classList.contains(i)) {
              const f = d.indexOf(c), p = qa(c).datum(), v = u(p, f, d), [m, g] = this.isContainerBody() ? [r.clientX, r.clientY] : jl(r, this._container);
              v === null ? this.hide() : (this.render(v), o.followCursor ? this.place({ x: m, y: g }) : this.placeByElement(c)), r.stopPropagation();
              return;
            }
          }
        }
        this._isShown && this.hide();
      }).on("mouseleave.tooltip", (r) => {
        r.stopPropagation(), this.hide();
      });
    }), t.allowHover ? this.div.on("mouseenter.tooltip", this._display.bind(this)).on("mouseleave.tooltip", this.hide.bind(this)) : this.div.on("mouseenter.tooltip", null).on("mouseleave.tooltip", null);
  }
  _setUpAttributes() {
    const t = this.config.attributes;
    t && Object.keys(t).forEach((n) => {
      this.div.attr(n, t[n]);
    });
  }
  destroy() {
    var t;
    this._mutationObserver.disconnect(), window.clearTimeout(this._hideDelayTimeoutId), window.clearTimeout(this._showDelayTimeoutId), (t = this.div) === null || t === void 0 || t.remove();
  }
}
A_.selectors = NL;
function nl(e) {
  return function() {
    return e;
  };
}
const I_ = Math.cos, di = Math.sin, Ln = Math.sqrt, ci = Math.PI, cu = 2 * ci, Zd = Math.PI, Qd = 2 * Zd, Wa = 1e-6, LL = Qd - Wa;
function O_(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function zL(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return O_;
  const n = 10 ** t;
  return function(a) {
    this._ += a[0];
    for (let r = 1, o = a.length; r < o; ++r)
      this._ += Math.round(arguments[r] * n) / n + a[r];
  };
}
class HL {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? O_ : zL(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, a, r) {
    this._append`Q${+t},${+n},${this._x1 = +a},${this._y1 = +r}`;
  }
  bezierCurveTo(t, n, a, r, o, s) {
    this._append`C${+t},${+n},${+a},${+r},${this._x1 = +o},${this._y1 = +s}`;
  }
  arcTo(t, n, a, r, o) {
    if (t = +t, n = +n, a = +a, r = +r, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let s = this._x1, i = this._y1, u = a - t, d = r - n, c = s - t, f = i - n, p = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > Wa) if (!(Math.abs(f * u - d * c) > Wa) || !o)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let v = a - s, m = r - i, g = u * u + d * d, w = v * v + m * m, C = Math.sqrt(g), S = Math.sqrt(p), $ = o * Math.tan((Zd - Math.acos((g + p - w) / (2 * C * S))) / 2), B = $ / S, k = $ / C;
      Math.abs(B - 1) > Wa && this._append`L${t + B * c},${n + B * f}`, this._append`A${o},${o},0,0,${+(f * v > c * m)},${this._x1 = t + k * u},${this._y1 = n + k * d}`;
    }
  }
  arc(t, n, a, r, o, s) {
    if (t = +t, n = +n, a = +a, s = !!s, a < 0) throw new Error(`negative radius: ${a}`);
    let i = a * Math.cos(r), u = a * Math.sin(r), d = t + i, c = n + u, f = 1 ^ s, p = s ? r - o : o - r;
    this._x1 === null ? this._append`M${d},${c}` : (Math.abs(this._x1 - d) > Wa || Math.abs(this._y1 - c) > Wa) && this._append`L${d},${c}`, a && (p < 0 && (p = p % Qd + Qd), p > LL ? this._append`A${a},${a},0,1,${f},${t - i},${n - u}A${a},${a},0,1,${f},${this._x1 = d},${this._y1 = c}` : p > Wa && this._append`A${a},${a},0,${+(p >= Zd)},${f},${this._x1 = t + a * Math.cos(o)},${this._y1 = n + a * Math.sin(o)}`);
  }
  rect(t, n, a, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${a = +a}v${+r}h${-a}Z`;
  }
  toString() {
    return this._;
  }
}
function UL(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const a = Math.floor(n);
      if (!(a >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = a;
    }
    return e;
  }, () => new HL(t);
}
const R_ = {
  draw(e, t) {
    const n = Ln(t / ci);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, cu);
  }
}, jL = {
  draw(e, t) {
    const n = Ln(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, V_ = Ln(1 / 3), WL = V_ * 2, GL = {
  draw(e, t) {
    const n = Ln(t / WL), a = n * V_;
    e.moveTo(0, -n), e.lineTo(a, 0), e.lineTo(0, n), e.lineTo(-a, 0), e.closePath();
  }
}, KL = {
  draw(e, t) {
    const n = Ln(t), a = -n / 2;
    e.rect(a, a, n, n);
  }
}, YL = 0.8908130915292852, F_ = di(ci / 10) / di(7 * ci / 10), XL = di(cu / 10) * F_, JL = -I_(cu / 10) * F_, ZL = {
  draw(e, t) {
    const n = Ln(t * YL), a = XL * n, r = JL * n;
    e.moveTo(0, -n), e.lineTo(a, r);
    for (let o = 1; o < 5; ++o) {
      const s = cu * o / 5, i = I_(s), u = di(s);
      e.lineTo(u * n, -i * n), e.lineTo(i * a - u * r, u * a + i * r);
    }
    e.closePath();
  }
}, nd = Ln(3), QL = {
  draw(e, t) {
    const n = -Ln(t / (nd * 3));
    e.moveTo(0, n * 2), e.lineTo(-nd * n, -n), e.lineTo(nd * n, -n), e.closePath();
  }
}, bn = -0.5, _n = Ln(3) / 2, ec = 1 / Ln(12), e4 = (ec / 2 + 1) * 3, t4 = {
  draw(e, t) {
    const n = Ln(t / e4), a = n / 2, r = n * ec, o = a, s = n * ec + n, i = -o, u = s;
    e.moveTo(a, r), e.lineTo(o, s), e.lineTo(i, u), e.lineTo(bn * a - _n * r, _n * a + bn * r), e.lineTo(bn * o - _n * s, _n * o + bn * s), e.lineTo(bn * i - _n * u, _n * i + bn * u), e.lineTo(bn * a + _n * r, bn * r - _n * a), e.lineTo(bn * o + _n * s, bn * s - _n * o), e.lineTo(bn * i + _n * u, bn * u - _n * i), e.closePath();
  }
};
function n4(e, t) {
  let n = null, a = UL(r);
  e = typeof e == "function" ? e : nl(e || R_), t = typeof t == "function" ? t : nl(t === void 0 ? 64 : +t);
  function r() {
    let o;
    if (n || (n = o = a()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null;
  }
  return r.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : nl(o), r) : e;
  }, r.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : nl(+o), r) : t;
  }, r.context = function(o) {
    return arguments.length ? (n = o ?? null, r) : n;
  }, r;
}
function Po(e, t, n, a) {
  return Array.isArray(t) && isFinite(n) ? t[n % t.length] : qb(e, t, n) || (Oo(n) ? `var(${jb(n)})` : null);
}
var Hn;
(function(e) {
  e.Circle = "circle", e.Cross = "cross", e.Diamond = "diamond", e.Square = "square", e.Star = "star", e.Triangle = "triangle", e.Wye = "wye";
})(Hn || (Hn = {}));
const a4 = {
  [Hn.Circle]: R_,
  [Hn.Cross]: jL,
  [Hn.Diamond]: GL,
  [Hn.Square]: KL,
  [Hn.Star]: ZL,
  [Hn.Triangle]: QL,
  [Hn.Wye]: t4
}, cn = Object.assign(Object.assign({}, Hn), { Line: "line" });
var fi;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(fi || (fi = {}));
const r4 = {
  items: [],
  labelClassName: "",
  onLegendItemClick: void 0,
  labelFontSize: null,
  labelMaxWidth: null,
  bulletSize: null,
  bulletSpacing: 4,
  bulletShape: (e) => {
    var t;
    return (t = e.shape) !== null && t !== void 0 ? t : cn.Circle;
  },
  orientation: fi.Horizontal,
  renderIntoProvidedDomNode: !1
}, al = ns * 3, o4 = {
  [cn.Circle]: Math.PI / 4,
  [cn.Cross]: 5 / 9,
  [cn.Diamond]: Math.sqrt(3) / 6,
  [cn.Square]: 1,
  [cn.Star]: 0.3,
  [cn.Triangle]: Math.sqrt(3) / 4,
  [cn.Wye]: 5 / 11
};
function N_(e, t, n) {
  return t < 1 ? 0 : e * t + n * (t - 1);
}
function s4(e) {
  e.each((t, n, a) => {
    qa(a[n]).append("svg").attr("width", "100%").attr("height", "100%").append("path");
  });
}
function l4(e, t, n) {
  e.each((a, r, o) => {
    var s;
    const i = qb(a, t.bulletShape, r), u = rF((s = a.color) !== null && s !== void 0 ? s : Po(a, n, r)), d = u.length, c = al, f = Hd(getComputedStyle(o[r]).getPropertyValue("--vis-legend-bullet-size")), p = t.bulletSpacing * (al / f), v = N_(c, d, p), m = i === cn.Line ? al / 2.5 : al, g = qa(o[r]).select("svg").attr("viewBox", `0 0 ${v} ${m}`);
    g.selectAll("path").remove();
    const w = a.inactive ? "var(--vis-legend-bullet-inactive-opacity)" : 1;
    u.forEach((C, S) => {
      const $ = g.append("path");
      if (i === cn.Line) {
        const B = S * (c + p), k = B + c;
        $.attr("d", `M${B},${m / 2} L${k},${m / 2}`).attr("transform", null).style("opacity", w).style("stroke", C).style("stroke-width", "3px").style("fill", null).style("fill-opacity", null).style("marker-start", "none").style("marker-end", "none");
      } else {
        const B = n4().type(a4[i]).size(c * m * o4[i]), k = (c - 2) / c;
        let P = m / 2;
        switch (i) {
          case cn.Triangle:
            P += m / 8;
            break;
          case cn.Star:
            P += m / 16;
            break;
          case cn.Wye:
            P -= m / 16;
            break;
        }
        const D = S * (c + p) + c / 2;
        $.attr("d", B).attr("transform", `translate(${D}, ${Math.round(P)}) scale(${k})`).style("stroke", C).style("stroke-width", "1px").style("opacity", null).style("fill", C).style("fill-opacity", w);
      }
    });
  });
}
const np = ln`
  label: bullet-legend-component;
`, i4 = Of`
  :root {
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-legend-font-family: */

    --vis-legend-label-color: #6c778c;
    --vis-legend-label-max-width: 300px;
    --vis-legend-label-font-size: 12px;
    --vis-legend-bullet-size: 9px;
    --vis-legend-bullet-inactive-opacity: 0.15;
    --vis-legend-item-spacing: 20px;
    --vis-legend-vertical-item-spacing: 5px;
    --vis-legend-bullet-label-spacing: 8px;

    --vis-dark-legend-label-color: #eee;
  }

  body.theme-dark ${`.${np}`} {
    --vis-legend-label-color: var(--vis-dark-legend-label-color);
  }

  body.theme-patterns {
    --vis-legend-bullet-size: 14px;
  }
`, Cl = ln`
  label: legendItem;
  display: inline-flex;
  align-items: center;
  font-family: var(--vis-legend-font-family, var(--vis-font-family));
  margin-right: var(--vis-legend-item-spacing);
  white-space: nowrap;
  cursor: default;
  user-select: none;
  max-width: min-content;
`, L_ = ln`
  label: legendItemVertical;
  display: flex;
  margin-top: var(--vis-legend-vertical-item-spacing);
`, z_ = ln`
  cursor: pointer;
`, tc = ln`
  label: legendItemLabel;
  font-size: var(--vis-legend-label-font-size);
  display: inline-block;
  vertical-align: middle;
  color: var(--vis-legend-label-color);
  max-width: var(--vis-legend-label-max-width);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`, nc = ln`
  flex: 0 0 auto;
  label: legendItemBullet;
  margin-right: var(--vis-legend-bullet-label-spacing);
  height: var(--vis-legend-bullet-size);
  width: var(--vis-legend-bullet-size);

  svg {
    display: block;
  }
`, u4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bullet: nc,
  clickable: z_,
  item: Cl,
  itemVertical: L_,
  label: tc,
  root: np,
  variables: i4
}, Symbol.toStringTag, { value: "Module" }));
class ap {
  constructor(t, n) {
    this._defaultConfig = r4, this.config = this._defaultConfig, this._colorAccessor = (a) => a.color, this._container = t, this.div = n?.renderIntoProvidedDomNode ? qa(this._container) : qa(this._container).append("div"), this.div.classed(np, !0), this.element = this.div.node(), n && this.update(n);
  }
  update(t) {
    this.prevConfig = this.config, this.config = eu(this._defaultConfig, t), this.render();
  }
  render() {
    const { config: t } = this, n = this.div.selectAll(`.${Cl}`).data(t.items), a = n.enter().append("div").on("click", this._onItemClick.bind(this)), r = a.merge(n);
    r.attr("class", (o) => {
      var s;
      return `${Cl} ${(s = o.className) !== null && s !== void 0 ? s : ""}`;
    }).classed(L_, t.orientation === fi.Vertical).classed(z_, (o) => !!t.onLegendItemClick && this._isItemClickable(o)).attr("title", (o) => o.name).style("display", (o) => o.hidden ? "none" : null), a.append("span").attr("class", nc).call(s4), r.select(`.${nc}`).style("width", function(o) {
      const i = (Array.isArray(o.color) ? o.color : [o.color]).length, u = Hd(getComputedStyle(this).getPropertyValue("--vis-legend-bullet-size")) || 9, d = t.bulletSize ? Hd(t.bulletSize) : u, c = t.bulletSpacing;
      return `${N_(d, i, c)}px`;
    }).style("height", t.bulletSize).style("box-sizing", "content-box").call(l4, this.config, this._colorAccessor), a.append("span").attr("class", tc).classed(t.labelClassName, !0).style("max-width", t.labelMaxWidth).style("font-size", t.labelFontSize), r.select(`.${tc}`).text((o) => o.name), n.exit().remove();
  }
  _isItemClickable(t) {
    return t.pointer === void 0 ? !0 : t.pointer;
  }
  _onItemClick(t, n) {
    const { config: { onLegendItemClick: a } } = this, o = this.div.selectAll(`.${Cl}`).nodes().indexOf(t.currentTarget);
    a && a(n, o);
  }
  destroy() {
    this.element !== this._container && this.div.remove();
  }
}
ap.selectors = u4;
const d4 = Object.assign(Object.assign({}, E_), { yStacked: void 0, baseline: null, duration: 100, tooltip: void 0, template: (e, t, n, a) => "", hideWhenFarFromPointer: !0, hideWhenFarFromPointerDistance: 100, snapToData: !0, getCircles: void 0, color: void 0, strokeColor: void 0, strokeWidth: void 0, onCrosshairMove: void 0, forceShowAt: void 0, skipRangeCheck: !1 }), c4 = Of`
  :root {
    --vis-crosshair-line-stroke-color: #888;
    --vis-crosshair-line-stroke-width: 1px;
    --vis-crosshair-line-stroke-opacity: 1;
    --vis-crosshair-circle-stroke-color: #fff;
    --vis-crosshair-circle-stroke-width: 1px;
    --vis-crosshair-circle-stroke-opacity: 0.75;
  }
`, f4 = ln`
  label: crosshair-component;
`, H_ = ln`
  stroke: var(--vis-crosshair-line-stroke-color);
  stroke-width: var(--vis-crosshair-line-stroke-width);
  stroke-opacity: var(--vis-crosshair-line-stroke-opacity);
  pointer-events: none;
`, U_ = ln`
  stroke: var(--vis-crosshair-circle-stroke-color);
  stroke-width: var(--vis-crosshair-circle-stroke-width);
  stroke-opacity: var(--vis-crosshair-circle-stroke-opacity);
  pointer-events: none;
`, p4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle: U_,
  globalStyles: c4,
  line: H_,
  root: f4
}, Symbol.toStringTag, { value: "Module" }));
class j_ extends OL {
  constructor(t) {
    super(), this.clippable = !0, this._defaultConfig = d4, this.config = this._defaultConfig, this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, this._animFrameId = null, this._accessors = {
      x: void 0,
      y: void 0,
      yStacked: void 0,
      baseline: void 0
    }, t && this.setConfig(t), this.g.style("opacity", 0), this.line = this.g.append("line").attr("class", H_);
  }
  set accessors(t) {
    this._accessors = t;
  }
  get accessors() {
    var t;
    const { config: n } = this, a = !!(n.x || n.y || n.yStacked), r = a ? n.x : this._accessors.x, o = a ? n.y : this._accessors.y, s = o ? qf(o) ? o : [o] : void 0, i = a ? n.yStacked : this._accessors.yStacked, u = (t = n.baseline) !== null && t !== void 0 ? t : this._accessors.baseline;
    return { x: r, y: s, yStacked: i, baseline: u };
  }
  _isContainerInViewport() {
    var t;
    if (!(!((t = this.container) === null || t === void 0) && t.node()))
      return !1;
    const n = this.container.node().getBoundingClientRect(), a = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight, o = Math.max(0, Math.min(n.right, a) - Math.max(n.left, 0)), s = Math.max(0, Math.min(n.bottom, r) - Math.max(n.top, 0)), i = n.width * n.height, u = o * s;
    return i > 0 && u / i >= 0.35;
  }
  setContainer(t) {
    this.container !== t && (this.container = t, this.container.on("mousemove.crosshair", this._onMouseMove.bind(this)), this.container.on("mouseout.crosshair", this._onMouseOut.bind(this)), this.container.on("wheel.crosshair", this._onWheel.bind(this)));
  }
  _render(t) {
    var n, a, r, o, s;
    const { config: i, datamodel: u } = this, d = Oo(t) ? t : i.duration, c = i.forceShowAt !== void 0, f = c ? this.xScale(i.forceShowAt) : this._xPx, p = this.xScale.invert(f), v = !((n = u.data) === null || n === void 0) && n.length && this.accessors.x ? u.data.indexOf(Xl(u.data, p, this.accessors.x, ia.Left)) : void 0;
    let m, g;
    i.snapToData && (!this.accessors.y && !this.accessors.yStacked && (!((a = u.data) === null || a === void 0) && a.length) && console.warn("Unovis | Crosshair: Y accessors have not been configured. Please check if they're present in the configuration object"), !(!((r = u.data) === null || r === void 0) && r.length) && this._mouseEvent && console.warn("Unovis | Crosshair: No data to snap to. Make sure the data has been passed to the container or to the crosshair itself"), m = Xl(u.data, p, this.accessors.x), g = u.data.indexOf(m));
    const w = this.xScale.range(), C = this.yScale.range(), S = i.snapToData && m ? Nv(Math.round(this.xScale(pn(m, this.accessors.x, g))), 0, this._width) : Nv(f, w[0], w[1]), $ = f >= w[0] && f <= w[1], B = this._yPx >= Math.min(C[0], C[1]) && this._yPx <= Math.max(C[0], C[1]);
    let k = i.skipRangeCheck ? !!this._xPx : this._xPx ? $ && B : $;
    i.hideWhenFarFromPointer && Math.abs(S - +f) >= i.hideWhenFarFromPointerDistance && (k = !1);
    const P = (o = i.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (k && P && this._isContainerInViewport()) {
      const M = P.getContainer() || this.container.node(), O = P.isContainerBody();
      if (c) {
        const F = this.container.node().getBoundingClientRect(), J = (O ? f + F.left : f) + this._containerMargin.left, ne = this._height / 2 + (O ? F.top : 0), Q = [J, ne];
        this._showTooltip(m, p, Q, v);
      } else if (this._mouseEvent) {
        const F = O ? [this._mouseEvent.clientX, this._mouseEvent.clientY] : jl(this._mouseEvent, M);
        this._showTooltip(m, p, F, v);
      }
    } else
      this._hideTooltip();
    if (this._mouseEvent && ((s = i.onCrosshairMove) === null || s === void 0 || s.call(i, k ? this.xScale.invert(this._xPx) : void 0, m, g, this._mouseEvent), this._mouseEvent = void 0), Xu(this.g, d).style("opacity", k ? 1 : 0), !isFinite(f))
      return;
    this.line.attr("y1", 0).attr("y2", this._height), Xu(this.line, d, cm).attr("x1", S).attr("x2", S);
    const D = Ef(i.getCircles) ? i.getCircles(p, u.data, this.yScale, v) : this.getCircleData(m, g), q = this.g.selectAll("circle").data(D, (M, O) => {
      var F;
      return (F = M.id) !== null && F !== void 0 ? F : O;
    }), T = q.enter().append("circle").attr("class", U_).attr("r", 0).attr("cx", S).attr("cy", (M) => M.y).style("fill", (M) => M.color).style("stroke", (M) => M.strokeColor).style("stroke-width", (M) => M.strokeWidth);
    Xu(T.merge(q), d, cm).attr("cx", S).attr("cy", (M) => M.y).attr("r", 4).style("opacity", (M) => M.opacity).style("fill", (M) => M.color).style("stroke", (M) => M.strokeColor).style("stroke-width", (M) => M.strokeWidth), q.exit().remove();
  }
  hide(t) {
    window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      var n, a;
      this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, (a = (n = this.config).onCrosshairMove) === null || a === void 0 || a.call(n, void 0, void 0, void 0, t), this._render();
    });
  }
  _onMouseMove(t) {
    var n;
    const { datamodel: a, element: r } = this;
    !this.accessors.x && (!((n = a.data) === null || n === void 0) && n.length) && console.warn("Unovis | Crosshair: X accessor function has not been configured. Please check if it's present in the configuration object");
    const [o, s] = jl(t, r);
    this._xPx = o, this._yPx = s, this._mouseEvent = t, window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      this._render();
    });
  }
  _onMouseOut(t) {
    var n;
    (!t || !(!((n = this.container) === null || n === void 0) && n.node().contains(t.relatedTarget))) && this.hide(t);
  }
  _onWheel(t) {
    this.hide(t);
  }
  _showTooltip(t, n, a, r) {
    var o;
    const { config: s, datamodel: i } = this, u = (o = s.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (!u || !a)
      return;
    const [d, c] = a, f = s.template(t, n, i.data, r);
    if (u.config.followCursor = !0, !u.config.horizontalPlacement || u.config.horizontalPlacement === tt.Auto) {
      const p = u.isContainerBody() ? d - this.container.node().getBoundingClientRect().left : d;
      u.overrideHorizontalPlacement(p > this._containerWidth / 2 ? tt.Left : tt.Right);
    }
    f && u.show(f, { x: d, y: c });
  }
  _hideTooltip() {
    var t;
    const { config: n } = this, a = (t = n.tooltip) !== null && t !== void 0 ? t : this.tooltip;
    a?.hide();
  }
  // We don't want Crosshair to be be taken in to account in domain calculations
  getYDataExtent() {
    return [void 0, void 0];
  }
  getCircleData(t, n) {
    var a, r;
    const { config: o } = this;
    if (o.snapToData && t) {
      const s = (a = this.accessors.y) !== null && a !== void 0 ? a : [], i = (r = this.accessors.yStacked) !== null && r !== void 0 ? r : [], u = pn(t, this.accessors.baseline, n) || 0, d = eF(t, n, ...i).map((f, p) => ({
        y: this.yScale(f + u),
        opacity: Oo(pn(t, i[p], p)) ? 1 : 0,
        color: Po(t, o.color, p),
        strokeColor: o.strokeColor ? Po(t, o.strokeColor, p) : void 0,
        strokeWidth: o.strokeWidth ? pn(t, o.strokeWidth, p) : void 0
      })), c = s.map((f, p) => {
        const v = pn(t, f, n);
        return {
          y: this.yScale(v),
          opacity: Oo(v) ? 1 : 0,
          color: Po(t, o.color, d.length + p),
          strokeColor: o.strokeColor ? Po(t, o.strokeColor, p) : void 0,
          strokeWidth: o.strokeWidth ? pn(t, o.strokeWidth, p) : void 0
        };
      });
      return d.concat(c);
    }
    return [];
  }
}
j_.selectors = p4;
const v4 = /* @__PURE__ */ Symbol("tooltipAccessorKey"), m4 = /* @__PURE__ */ Symbol("crosshairAccessorKey");
function rp(e, t) {
  return Nd(e, t);
}
function op(e) {
  const t = ht(), n = t.attrs;
  return E(() => {
    const a = {}, r = t?.vnode.props ?? {};
    return Object.keys(r).forEach((o) => {
      a[Sl(o)] = e[Sl(o)];
    }), { ...a, ...n };
  });
}
const h4 = { "data-vis-crosshair": "" }, g4 = /* @__PURE__ */ b({
  __name: "index",
  props: {
    data: {}
  },
  setup(e, { expose: t }) {
    const n = Cn(m4), a = e, r = E(() => n.data.value ?? a.data), o = op(a), s = I();
    return Ce(() => {
      Be(() => {
        var i;
        s.value = new j_(o.value), (i = s.value) == null || i.setData(r.value), n.update(s.value);
      });
    }), Qe(() => {
      var i;
      (i = s.value) == null || i.destroy(), n.destroy();
    }), ve(o, (i, u) => {
      var d;
      rp(i, u) || (d = s.value) == null || d.setConfig(o.value);
    }), ve(r, () => {
      var i;
      (i = s.value) == null || i.setData(r.value);
    }), t({
      component: s
    }), (i, u) => (h(), W("div", h4));
  }
}), y4 = { "data-vis-tooltip": "" }, W_ = /* @__PURE__ */ b({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    hideDelay: {},
    showDelay: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = Cn(v4), a = op(e), r = I();
    return Ce(() => {
      Be(() => {
        r.value = new A_(a.value), n.update(r.value);
      });
    }), Qe(() => {
      var o;
      (o = r.value) == null || o.destroy(), n.destroy();
    }), ve(a, (o, s) => {
      var i;
      rp(o, s) || (i = r.value) == null || i.setConfig(a.value);
    }), t({
      component: r
    }), (o, s) => (h(), W("div", y4));
  }
}), b4 = /* @__PURE__ */ b({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletSpacing: {},
    bulletShape: {},
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e;
    E(() => n.data);
    const a = op(n), r = I(), o = I();
    return Ce(() => {
      Be(() => {
        o.value && (r.value = new ap(o.value, { ...a.value, renderIntoProvidedDomNode: !0 }));
      });
    }), Qe(() => {
      var s;
      (s = r.value) == null || s.destroy();
    }), ve(a, (s, i) => {
      var u;
      rp(s, i) || (u = r.value) == null || u.update(a.value);
    }), t({
      component: r
    }), (s, i) => (h(), W("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: o
    }, null, 512));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-map],[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend],[data-vis-rolling-pin-legend]{display:block}")), document.head.appendChild(e);
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t);
  }
})();
const N7 = /* @__PURE__ */ b({
  __name: "ChartCrosshair",
  props: {
    colors: { default: () => [] },
    index: {},
    items: {},
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(o) {
      if (n.has(o))
        return n.get(o);
      {
        const s = document.createElement("div"), i = Object.entries(Mb(o, [t.index])).map(([d, c]) => ({ ...t.items.find((p) => p.name === d), value: c })), u = t.customTooltip ?? ac;
        return id(u, { title: o[t.index].toString(), data: i }).mount(
          s
        ), n.set(o, s.innerHTML), s.innerHTML;
      }
    }
    function r(o, s) {
      return t.colors[s] ?? "transparent";
    }
    return (o, s) => (h(), W(Ke, null, [
      N(l(W_), {
        "horizontal-shift": 20,
        "vertical-shift": 20
      }),
      N(l(g4), {
        template: a,
        color: r
      })
    ], 64));
  }
}), L7 = /* @__PURE__ */ b({
  __name: "ChartLegend",
  props: {
    items: { default: () => [] }
  },
  emits: ["legendItemClick", "update:items"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = I();
    function o() {
      const i = `.${ap.selectors.item}`;
      Be(() => {
        const u = r.value?.querySelectorAll(i), d = Yt({ variant: "ghost", size: "xs" }).split(" ");
        u?.forEach((c) => c.classList.add(...d, "!inline-flex", "!mr-2"));
      });
    }
    Ce(() => {
      o();
    });
    function s(i, u) {
      a("legendItemClick", i, u);
      const d = n.items[u], c = d ? !d.inactive : !0;
      n.items.some((p) => p.inactive) && c ? a(
        "update:items",
        n.items.map((p) => ({ ...p, inactive: !1 }))
      ) : a(
        "update:items",
        n.items.map(
          (p) => p.name === i.name ? { ...i, inactive: !1 } : { ...p, inactive: !0 }
        )
      ), o();
    }
    return (i, u) => (h(), W("div", {
      ref_key: "elRef",
      ref: r,
      class: "w-max",
      style: {
        "--vis-legend-bullet-size": "16px"
      }
    }, [
      N(l(b4), {
        items: e.items,
        "on-legend-item-click": s
      }, null, 8, ["items"])
    ], 512));
  }
}), z7 = /* @__PURE__ */ b({
  __name: "ChartSingleTooltip",
  props: {
    selector: {},
    index: {},
    items: {},
    valueFormatter: { type: Function },
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(r, o, s) {
      const i = t.valueFormatter ?? ((u) => `${u}`);
      if (t.index in r) {
        if (n.has(r))
          return n.get(r);
        {
          const u = document.createElement("div"), d = Object.entries(Mb(r, [t.index])).map(([f, p]) => ({ ...t.items?.find((m) => m.name === f), value: i(p) })), c = t.customTooltip ?? ac;
          return id(c, { title: r[t.index], data: d }).mount(u), n.set(r, u.innerHTML), u.innerHTML;
        }
      } else {
        const u = r.data;
        if (n.has(u))
          return n.get(u);
        {
          const d = s[o];
          if (!d) return "";
          const c = getComputedStyle(d), f = [
            { name: u.name, value: i(u[t.index]), color: c.fill }
          ], p = document.createElement("div"), v = t.customTooltip ?? ac;
          return id(v, { title: r[t.index], data: f }).mount(p), n.set(r, p.innerHTML), p.innerHTML;
        }
      }
    }
    return (r, o) => (h(), x(l(W_), {
      "horizontal-shift": 20,
      "vertical-shift": 20,
      triggers: {
        [e.selector]: a
      }
    }, null, 8, ["triggers"]));
  }
}), _4 = { class: "flex items-center" }, w4 = { class: "mr-2 h-2.5 w-2.5" }, x4 = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 30 30"
}, C4 = ["stroke", "fill"], S4 = { class: "ml-4 font-semibold" }, ac = /* @__PURE__ */ b({
  __name: "ChartTooltip",
  props: {
    title: {},
    data: {}
  },
  setup(e) {
    return (t, n) => (h(), x(l(x3), { class: "text-sm" }, {
      default: y(() => [
        e.title ? (h(), x(l(S3), {
          key: 0,
          class: "border-b p-3"
        }, {
          default: y(() => [
            N(l($3), null, {
              default: y(() => [
                Re(Ne(e.title), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : Ee("", !0),
        N(l(C3), { class: "flex min-w-[180px] flex-col gap-1 p-3" }, {
          default: y(() => [
            (h(!0), W(Ke, null, Lt(e.data, (a, r) => (h(), W("div", {
              key: r,
              class: "flex justify-between"
            }, [
              we("div", _4, [
                we("span", w4, [
                  (h(), W("svg", x4, [
                    we("path", {
                      d: " M 15 15 m -14, 0 a 14,14 0 1,1 28,0 a 14,14 0 1,1 -28,0",
                      stroke: a.color,
                      fill: a.color,
                      "stroke-width": "1"
                    }, null, 8, C4)
                  ]))
                ]),
                we("span", null, Ne(a.name), 1)
              ]),
              we("span", S4, Ne(a.value), 1)
            ]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
function H7(e = 3) {
  const t = Math.floor(e / 2), n = e % 2, a = t + n, r = t;
  return [
    ...Array.from(new Array(a).keys()).map(
      (o) => `hsl(var(--vis-primary-color) / ${1 - 1 / a * o})`
    ),
    ...Array.from(new Array(r).keys()).map(
      (o) => `hsl(var(--vis-secondary-color) / ${1 - 1 / r * o})`
    )
  ];
}
const U7 = /* @__PURE__ */ b({
  __name: "Checkbox",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null] },
    disabled: { type: Boolean },
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = E(() => {
      const { class: s, ...i } = n;
      return i;
    }), o = me(r, a);
    return (s, i) => (h(), x(l(pS), A(l(o), {
      class: l(V)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: y(() => [
        N(l(mS), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: y(() => [
            _(s.$slots, "default", {}, () => [
              N(l(so), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), j7 = /* @__PURE__ */ b({
  __name: "Collapsible",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(Jh), oe(le(l(r))), {
      default: y(({ open: i }) => [
        _(o.$slots, "default", { open: i })
      ]),
      _: 3
    }, 16));
  }
}), W7 = /* @__PURE__ */ b({
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Zh), A(t, { class: "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down" }), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), G7 = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Qh), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), K7 = /* @__PURE__ */ b({
  __name: "Combobox",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    resetSearchTermOnBlur: { type: Boolean },
    resetSearchTermOnSelect: { type: Boolean },
    openOnFocus: { type: Boolean },
    openOnClick: { type: Boolean },
    ignoreFilter: { type: Boolean },
    resetModelValueOnClear: { type: Boolean },
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    highlightOnHover: { type: Boolean },
    by: { type: [String, Function] },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(Q$), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Y7 = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(A$), A(l(a), {
      class: l(V)("w-[200px]", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), X7 = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(lk), A(l(n), {
      class: l(V)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), J7 = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(dk), A(l(n), {
      class: l(V)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        e.heading ? (h(), x(l(gk), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(Ne(e.heading), 1)
          ]),
          _: 1
        })) : Ee("", !0),
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Z7 = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: { type: Function },
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(fk), A(l(o), {
      class: l(V)(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Q7 = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(vk), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center justify-between gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), eU = /* @__PURE__ */ b({
  __name: "ComboboxList",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(bk), null, {
      default: y(() => [
        N(l(ok), A(l(o), {
          class: l(V)(
            "z-50 w-[200px] rounded-md border bg-popover text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            N(l(Sk), null, {
              default: y(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), tU = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(wk), A(l(n), {
      class: l(V)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $4 = /* @__PURE__ */ b({
  __name: "Command",
  props: {
    modelValue: { default: "" },
    defaultValue: {},
    multiple: { type: Boolean },
    orientation: {},
    dir: {},
    disabled: { type: Boolean },
    selectionBehavior: {},
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "highlight", "entryFocus", "leave"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a), s = I(/* @__PURE__ */ new Map()), i = I(/* @__PURE__ */ new Map()), { contains: u } = jh({ sensitivity: "base" }), d = Wt({
      search: "",
      filtered: {
        /** The count of all visible items. */
        count: 0,
        /** Map from visible item id to its search score. */
        items: /* @__PURE__ */ new Map(),
        /** Set of groups with at least one visible item. */
        groups: /* @__PURE__ */ new Set()
      }
    });
    function c() {
      if (!d.search) {
        d.filtered.count = s.value.size;
        return;
      }
      d.filtered.groups = /* @__PURE__ */ new Set();
      let f = 0;
      for (const [p, v] of s.value) {
        const m = u(v, d.search);
        d.filtered.items.set(p, m ? 1 : 0), m && f++;
      }
      for (const [p, v] of i.value)
        for (const m of v)
          if (d.filtered.items.get(m) > 0) {
            d.filtered.groups.add(p);
            break;
          }
      d.filtered.count = f;
    }
    return ve(
      () => d.search,
      () => {
        c();
      }
    ), M4({
      allItems: s,
      allGroups: i,
      filterState: d
    }), (f, p) => (h(), x(l(xg), A(l(o), {
      class: l(V)(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        n.class
      )
    }), {
      default: y(() => [
        _(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), k4 = /* @__PURE__ */ b({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(xi), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nU = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Va), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), B4 = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l($i), null, {
      default: y(() => [
        N(l(gs), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(hs), A(l(o), {
          class: l(V)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(Va), { class: "absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-none disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground" }, {
              default: y(() => [
                N(l(lo), { class: "h-4 w-4" }),
                i[0] || (i[0] = we("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), aU = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Si), A(l(a), {
      class: l(V)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), rU = /* @__PURE__ */ b({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), oU = /* @__PURE__ */ b({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(l(V)("flex flex-col gap-y-1.5 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), sU = /* @__PURE__ */ b({
  __name: "DialogScrollContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l($i), null, {
      default: y(() => [
        N(l(gs), { class: "fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }, {
          default: y(() => [
            N(l(hs), A({
              class: l(V)(
                "relative z-50 my-8 grid w-full max-w-lg gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full",
                n.class
              )
            }, l(o), {
              onPointerDownOutside: i[0] || (i[0] = (u) => {
                const d = u.detail.originalEvent, c = d.target;
                (d.offsetX > c.clientWidth || d.offsetY > c.clientHeight) && u.preventDefault();
              })
            }), {
              default: y(() => [
                _(s.$slots, "default"),
                N(l(Va), { class: "absolute top-4 right-4 rounded-md p-0.5 transition-colors hover:bg-secondary" }, {
                  default: y(() => [
                    N(l(lo), { class: "h-4 w-4" }),
                    i[1] || (i[1] = we("span", { class: "sr-only" }, "Close", -1))
                  ]),
                  _: 1
                })
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), lU = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(ki), A(l(a), {
      class: l(V)("text-lg leading-none font-semibold tracking-tight", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), iU = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Bi), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), uU = /* @__PURE__ */ b({
  __name: "CommandDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(k4), oe(le(l(r))), {
      default: y(() => [
        N(l(B4), { class: "overflow-hidden p-0 shadow-lg" }, {
          default: y(() => [
            N($4, { class: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5" }, {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16));
  }
}), dU = /* @__PURE__ */ b({
  __name: "CommandEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { filterState: a } = fu(), r = E(() => !!a.search && a.filtered.count === 0);
    return (o, s) => r.value ? (h(), x(l(X), A({ key: 0 }, l(n), {
      class: l(V)("py-6 text-center text-sm", t.class)
    }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"])) : Ee("", !0);
  }
}), cU = /* @__PURE__ */ b({
  __name: "CommandGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { allGroups: a, filterState: r } = fu(), o = Ge(), s = E(() => r.search ? r.filtered.groups.has(o) : !0);
    return q4({ id: o }), Ce(() => {
      a.value.has(o) || a.value.set(o, /* @__PURE__ */ new Set());
    }), Qe(() => {
      a.value.delete(o);
    }), (i, u) => (h(), x(l($g), A(l(n), {
      id: l(o),
      class: l(V)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      ),
      hidden: s.value ? void 0 : !0
    }), {
      default: y(() => [
        e.heading ? (h(), x(l(U$), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: y(() => [
            Re(Ne(e.heading), 1)
          ]),
          _: 1
        })) : Ee("", !0),
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class", "hidden"]));
  }
}), D4 = {
  class: "flex items-center border-b px-3",
  "cmdk-input-wrapper": ""
}, fU = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CommandInput",
  props: {
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), { filterState: r } = fu();
    return (o, s) => (h(), W("div", D4, [
      N(l(jI), { class: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
      N(l(Sg), A({ ...l(a), ...o.$attrs }, {
        modelValue: l(r).search,
        "onUpdate:modelValue": s[0] || (s[0] = (i) => l(r).search = i),
        "auto-focus": "",
        class: l(V)(
          "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      }), null, 16, ["modelValue", "class"])
    ]));
  }
}), pU = /* @__PURE__ */ b({
  __name: "CommandItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a), s = Ge(), { filterState: i, allItems: u, allGroups: d } = fu(), c = E4(), f = E(() => {
      if (i.search) {
        const m = i.filtered.items.get(s);
        return m === void 0 ? !0 : m > 0;
      } else
        return !0;
    }), p = I(), v = oI(p);
    return Ce(() => {
      if (!(v.value instanceof HTMLElement)) return;
      u.value.set(s, v.value.textContent ?? n?.value.toString());
      const m = c?.id;
      m && (d.value.has(m) ? d.value.get(m)?.add(s) : d.value.set(m, /* @__PURE__ */ new Set([s])));
    }), Qe(() => {
      u.value.delete(s);
    }), (m, g) => f.value ? (h(), x(l(kg), A({ key: 0 }, l(o), {
      id: l(s),
      ref_key: "itemRef",
      ref: p,
      class: l(V)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      ),
      onSelect: g[0] || (g[0] = () => {
        l(i).search = "";
      })
    }), {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class"])) : Ee("", !0);
  }
}), P4 = { role: "presentation" }, vU = /* @__PURE__ */ b({
  __name: "CommandList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Cg), A(l(a), {
      class: l(V)("max-h-[300px] overflow-x-hidden overflow-y-auto", t.class)
    }), {
      default: y(() => [
        we("div", P4, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), mU = /* @__PURE__ */ b({
  __name: "CommandSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(rf), A(l(n), {
      class: l(V)("-mx-1 h-px bg-border", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hU = /* @__PURE__ */ b({
  __name: "CommandShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(V)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), [fu, M4] = Se("Command"), [E4, q4] = Se("CommandGroup"), gU = /* @__PURE__ */ b({
  __name: "ContextMenu",
  props: {
    pressOpenDelay: {},
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(rB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), T4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, yU = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(tB), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", T4, [
          N(l(Tg), null, {
            default: y(() => [
              N(l(so), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bU = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(mB), null, {
      default: y(() => [
        N(l(sB), A(l(o), {
          class: l(V)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), _U = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(iB), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wU = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(dB), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xU = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(pB), A(l(n), {
      class: l(V)("px-2 py-1.5 text-sm font-semibold text-foreground", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), CU = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(gB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), A4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, SU = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(bB), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", A4, [
          N(l(Tg), null, {
            default: y(() => [
              N(l(gf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $U = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(wB), A(l(n), {
      class: l(V)("-mx-1 my-1 h-px bg-border", t.class)
    }), null, 16, ["class"]));
  }
}), kU = /* @__PURE__ */ b({
  __name: "ContextMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(V)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), BU = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(CB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), DU = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l($B), A(l(o), {
      class: l(V)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PU = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(BB), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(za), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), MU = /* @__PURE__ */ b({
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(PB), oe(le(l(n))), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
(function() {
  var e;
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.nonce = (e = document.head.querySelector("meta[property=csp-nonce]")) == null ? void 0 : e.content, t.appendChild(document.createTextNode('[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32,.72,0,1);animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform, 100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform, 100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height, 0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height, 0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true]):after{content:"";position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]:after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]:after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]:after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]:after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:hover,[data-vaul-handle]:active{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover: hover) and (pointer: fine){[data-vaul-drawer]{-webkit-user-select:none;user-select:none}}@media (pointer: fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{0%{transform:translate3d(0,var(--initial-transform, 100%),0)}to{transform:translateZ(0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform, 100%),0)}}@keyframes slideFromTop{0%{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}to{transform:translateZ(0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}}@keyframes slideFromLeft{0%{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}to{transform:translateZ(0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}}@keyframes slideFromRight{0%{transform:translate3d(var(--initial-transform, 100%),0,0)}to{transform:translateZ(0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform, 100%),0,0)}}')), document.head.appendChild(t);
    }
  } catch (n) {
    console.error("vite-plugin-css-injected-by-js", n);
  }
})();
const I4 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const O4 = (e) => typeof e < "u";
function R4(e) {
  return JSON.parse(JSON.stringify(e));
}
function Nm(e, t, n, a = {}) {
  var r, o, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = ht(), m = n || v?.emit || ((r = v?.$emit) == null ? void 0 : r.bind(v)) || ((s = (o = v?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(v?.proxy));
  let g = d;
  t || (t = "modelValue"), g = g || `update:${t.toString()}`;
  const w = ($) => i ? typeof i == "function" ? i($) : R4($) : $, C = () => O4(e[t]) ? w(e[t]) : f, S = ($) => {
    p ? p($) && m(g, $) : m(g, $);
  };
  if (u) {
    const $ = C(), B = I($);
    let k = !1;
    return ve(
      () => e[t],
      (P) => {
        k || (k = !0, B.value = w(P), Be(() => k = !1));
      }
    ), ve(
      B,
      (P) => {
        !k && (P !== e[t] || c) && S(P);
      },
      { deep: c }
    ), B;
  } else
    return E({
      get() {
        return C();
      },
      set($) {
        S($);
      }
    });
}
const [sp, V4] = Se("DrawerRoot"), G_ = /* @__PURE__ */ new WeakMap();
function Tt(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement) || !t)
    return;
  const a = {};
  Object.entries(t).forEach(([r, o]) => {
    if (r.startsWith("--")) {
      e.style.setProperty(r, o);
      return;
    }
    a[r] = e.style[r], e.style[r] = o;
  }), !n && G_.set(e, a);
}
function F4(e, t) {
  if (!e || !(e instanceof HTMLElement))
    return;
  const n = G_.get(e);
  n && Object.entries(n).forEach(([a, r]) => {
    e.style[a] = r;
  });
}
function rl(e, t) {
  const n = window.getComputedStyle(e), a = n.transform || n.webkitTransform || n.mozTransform;
  let r = a.match(/^matrix3d\((.+)\)$/);
  return r ? Number.parseFloat(r[1].split(", ")[wt(t) ? 13 : 12]) : (r = a.match(/^matrix\((.+)\)$/), r ? Number.parseFloat(r[1].split(", ")[wt(t) ? 5 : 4]) : null);
}
function N4(e) {
  return 8 * (Math.log(e + 1) - 2);
}
function wt(e) {
  switch (e) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return e;
  }
}
function ad(e, t) {
  if (!e)
    return () => {
    };
  const n = e.style.cssText;
  return Object.assign(e.style, t), () => {
    e.style.cssText = n;
  };
}
function L4(...e) {
  return (...t) => {
    for (const n of e)
      typeof n == "function" && n(...t);
  };
}
const ft = {
  DURATION: 0.5,
  EASE: [0.32, 0.72, 0, 1]
}, K_ = 0.4, z4 = 0.25, H4 = 100, Y_ = 8, ol = 16, X_ = 26, Lm = "vaul-dragging";
function U4({
  activeSnapPoint: e,
  snapPoints: t,
  drawerRef: n,
  overlayRef: a,
  fadeFromIndex: r,
  onSnapPointChange: o,
  direction: s
}) {
  const i = I(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  function u() {
    i.value = {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    };
  }
  Ce(() => {
    typeof window < "u" && window.addEventListener("resize", u);
  }), sr(() => {
    typeof window < "u" && window.removeEventListener("resize", u);
  });
  const d = E(
    () => (t.value && e.value === t.value[t.value.length - 1]) ?? null
  ), c = E(
    () => t.value && t.value.length > 0 && (r?.value || r?.value === 0) && !Number.isNaN(r?.value) && t.value[r?.value ?? -1] === e.value || !t.value
  ), f = E(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.findIndex(($) => $ === e.value)) ?? null;
    }
  ), p = E(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.map(($) => {
        const B = typeof $ == "string";
        let k = 0;
        if (B && (k = Number.parseInt($, 10)), wt(s.value)) {
          const D = B ? k : i.value ? $ * i.value.innerHeight : 0;
          return i.value ? s.value === "bottom" ? i.value.innerHeight - D : -i.value.innerHeight + D : D;
        }
        const P = B ? k : i.value ? $ * i.value.innerWidth : 0;
        return i.value ? s.value === "right" ? i.value.innerWidth - P : -i.value.innerWidth + P : P;
      })) ?? [];
    }
  ), v = E(
    () => {
      var S;
      return f.value !== null ? (S = p.value) == null ? void 0 : S[f.value] : null;
    }
  ), m = (S) => {
    var $, B, k, P;
    const D = (($ = p.value) == null ? void 0 : $.findIndex((q) => q === S)) ?? null;
    Be(() => {
      var q;
      o(D, p.value), Tt((q = n.value) == null ? void 0 : q.$el, {
        transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
        transform: wt(s.value) ? `translate3d(0, ${S}px, 0)` : `translate3d(${S}px, 0, 0)`
      });
    }), p.value && D !== p.value.length - 1 && D !== r?.value ? Tt((B = a.value) == null ? void 0 : B.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "0"
    }) : Tt((k = a.value) == null ? void 0 : k.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "1"
    }), e.value = D !== null ? ((P = t.value) == null ? void 0 : P[D]) ?? null : null;
  };
  ve(
    [e, p, t],
    () => {
      var S;
      if (e.value) {
        const $ = ((S = t.value) == null ? void 0 : S.findIndex((B) => B === e.value)) ?? -1;
        p.value && $ !== -1 && typeof p.value[$] == "number" && m(p.value[$]);
      }
    },
    {
      immediate: !0
      // if you want to run the effect immediately as well
    }
  );
  function g({
    draggedDistance: S,
    closeDrawer: $,
    velocity: B,
    dismissible: k
  }) {
    var P, D, q;
    if (r.value === void 0)
      return;
    const T = s.value === "bottom" || s.value === "right" ? (v.value ?? 0) - S : (v.value ?? 0) + S, M = f.value === r.value - 1, O = f.value === 0, F = S > 0;
    if (M && Tt((P = a.value) == null ? void 0 : P.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`
    }), B > 2 && !F) {
      k ? $() : m(p.value[0]);
      return;
    }
    if (B > 2 && F && p && t.value) {
      m(p.value[t.value.length - 1]);
      return;
    }
    const J = (D = p.value) == null ? void 0 : D.reduce((Q, G) => typeof Q != "number" || typeof G != "number" ? Q : Math.abs(G - T) < Math.abs(Q - T) ? G : Q), ne = wt(s.value) ? window.innerHeight : window.innerWidth;
    if (B > K_ && Math.abs(S) < ne * 0.4) {
      const Q = F ? 1 : -1;
      if (Q > 0 && d) {
        m(p.value[(((q = t.value) == null ? void 0 : q.length) ?? 0) - 1]);
        return;
      }
      if (O && Q < 0 && k && $(), f.value === null)
        return;
      m(p.value[f.value + Q]);
      return;
    }
    m(J);
  }
  function w({ draggedDistance: S }) {
    var $;
    if (v.value === null)
      return;
    const B = s.value === "bottom" || s.value === "right" ? v.value - S : v.value + S;
    (s.value === "bottom" || s.value === "right") && B < p.value[p.value.length - 1] || (s.value === "top" || s.value === "left") && B > p.value[p.value.length - 1] || Tt(($ = n.value) == null ? void 0 : $.$el, {
      transform: wt(s.value) ? `translate3d(0, ${B}px, 0)` : `translate3d(${B}px, 0, 0)`
    });
  }
  function C(S, $) {
    if (!t.value || typeof f.value != "number" || !p.value || r.value === void 0)
      return null;
    const B = f.value === r.value - 1;
    if (f.value >= r.value && $)
      return 0;
    if (B && !$)
      return 1;
    if (!c.value && !B)
      return null;
    const k = B ? f.value + 1 : f.value - 1, P = B ? p.value[k] - p.value[k - 1] : p.value[k + 1] - p.value[k], D = S / Math.abs(P);
    return B ? 1 - D : D;
  }
  return {
    isLastSnapPoint: d,
    shouldFade: c,
    getPercentageDragged: C,
    activeSnapPointIndex: f,
    onRelease: g,
    onDrag: w,
    snapPointsOffset: p
  };
}
function zm() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
let xo = null;
function j4(e) {
  const { isOpen: t, modal: n, nested: a, hasBeenOpened: r, preventScrollRestoration: o, noBodyStyles: s } = e, i = I(typeof window < "u" ? window.location.href : ""), u = I(0);
  function d() {
    if (zm() && xo === null && t.value && !s.value) {
      xo = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      };
      const { scrollX: f, innerHeight: p } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-u.value}px`,
        left: `${-f}px`,
        right: "0px",
        height: "auto"
      }), setTimeout(() => {
        requestAnimationFrame(() => {
          const v = p - window.innerHeight;
          v && u.value >= p && (document.body.style.top = `-${u.value + v}px`);
        });
      }, 300);
    }
  }
  function c() {
    if (zm() && xo !== null && !s.value) {
      const f = -Number.parseInt(document.body.style.top, 10), p = -Number.parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, xo), window.requestAnimationFrame(() => {
        if (o.value && i.value !== window.location.href) {
          i.value = window.location.href;
          return;
        }
        window.scrollTo(p, f);
      }), xo = null;
    }
  }
  return Ce(() => {
    function f() {
      u.value = window.scrollY;
    }
    f(), window.addEventListener("scroll", f), Qe(() => {
      window.removeEventListener("scroll", f);
    });
  }), ve([t, r, i], () => {
    a.value || !r.value || (t.value ? (window.matchMedia("(display-mode: standalone)").matches || d(), n.value || setTimeout(() => {
      c();
    }, 500)) : c());
  }), { restorePositionSetting: c };
}
function W4(e, t) {
  return e && e.value ? e : t;
}
function G4(e) {
  const {
    emitDrag: t,
    emitRelease: n,
    emitClose: a,
    emitOpenChange: r,
    open: o,
    dismissible: s,
    nested: i,
    modal: u,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    scrollLockTimeout: f,
    closeThreshold: p,
    activeSnapPoint: v,
    fadeFromIndex: m,
    direction: g,
    noBodyStyles: w,
    handleOnly: C,
    preventScrollRestoration: S
  } = e, $ = I(o.value ?? !1), B = I(!1), k = I(!1), P = I(!1), D = I(null), q = I(null), T = I(null), M = I(null), O = I(null), F = I(!1), J = I(null), ne = I(0), Q = I(!1);
  I(0);
  const G = I(null);
  I(0);
  const H = E(() => {
    var De;
    return ((De = G.value) == null ? void 0 : De.$el.getBoundingClientRect().height) || 0;
  }), U = W4(
    e.snapPoints,
    I(void 0)
  ), se = E(() => {
    var De;
    return U && (((De = U.value) == null ? void 0 : De.length) ?? 0) > 0;
  }), ee = I(null), {
    activeSnapPointIndex: de,
    onRelease: pe,
    snapPointsOffset: _e,
    onDrag: ge,
    shouldFade: Te,
    getPercentageDragged: ce
  } = U4({
    snapPoints: U,
    activeSnapPoint: v,
    drawerRef: G,
    fadeFromIndex: m,
    overlayRef: D,
    onSnapPointChange: R,
    direction: g
  });
  function R(De, Le) {
    U.value && De === Le.length - 1 && (q.value = /* @__PURE__ */ new Date());
  }
  j4({
    isOpen: $,
    modal: u,
    nested: i,
    hasBeenOpened: B,
    noBodyStyles: w,
    preventScrollRestoration: S
  });
  function te() {
    return (window.innerWidth - X_) / window.innerWidth;
  }
  function z(De, Le) {
    var Ue;
    if (!De)
      return !1;
    let We = De;
    const it = (Ue = window.getSelection()) == null ? void 0 : Ue.toString(), ut = G.value ? rl(G.value.$el, g.value) : null, kt = /* @__PURE__ */ new Date();
    if (We.hasAttribute("data-vaul-no-drag") || We.closest("[data-vaul-no-drag]"))
      return !1;
    if (g.value === "right" || g.value === "left")
      return !0;
    if (q.value && kt.getTime() - q.value.getTime() < 500)
      return !1;
    if (ut !== null && (g.value === "bottom" ? ut > 0 : ut < 0))
      return !0;
    if (it && it.length > 0)
      return !1;
    if (O.value && kt.getTime() - O.value.getTime() < f.value && ut === 0 || Le)
      return O.value = kt, !1;
    for (; We; ) {
      if (We.scrollHeight > We.clientHeight) {
        if (We.scrollTop !== 0)
          return O.value = /* @__PURE__ */ new Date(), !1;
        if (We.getAttribute("role") === "dialog")
          return !0;
      }
      We = We.parentNode;
    }
    return !0;
  }
  function re(De) {
    !s.value && !U.value || G.value && !G.value.$el.contains(De.target) || (k.value = !0, T.value = /* @__PURE__ */ new Date(), De.target.setPointerCapture(De.pointerId), ne.value = wt(g.value) ? De.clientY : De.clientX);
  }
  function ie(De) {
    var Le, Ue, We, it, ut, kt;
    if (G.value && k.value) {
      const un = g.value === "bottom" || g.value === "right" ? 1 : -1, gn = (ne.value - (wt(g.value) ? De.clientY : De.clientX)) * un, Oe = gn > 0, Et = U.value && !s.value && !Oe;
      if (Et && de.value === 0)
        return;
      const jt = Math.abs(gn), Rt = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      let K = jt / H.value;
      const Y = ce(jt, Oe);
      if (Y !== null && (K = Y), Et && K >= 1 || !F.value && !z(De.target, Oe))
        return;
      if ((Le = G?.value) == null || Le.$el.classList.add(Lm), F.value = !0, Tt((Ue = G.value) == null ? void 0 : Ue.$el, {
        transition: "none"
      }), Tt((We = D.value) == null ? void 0 : We.$el, {
        transition: "none"
      }), U.value && ge({ draggedDistance: gn }), Oe && !U.value) {
        const ye = N4(gn), Pe = Math.min(ye * -1, 0) * un;
        Tt((it = G.value) == null ? void 0 : it.$el, {
          transform: wt(g.value) ? `translate3d(0, ${Pe}px, 0)` : `translate3d(${Pe}px, 0, 0)`
        });
        return;
      }
      const ue = 1 - K;
      if ((Te.value || m.value && de.value === m.value - 1) && (t(K), Tt(
        (ut = D.value) == null ? void 0 : ut.$el,
        {
          opacity: `${ue}`,
          transition: "none"
        },
        !0
      )), Rt && D.value && d.value) {
        const ye = Math.min(te() + K * (1 - te()), 1), Pe = 8 - K * 8, Ae = Math.max(0, 14 - K * 14);
        Tt(
          Rt,
          {
            borderRadius: `${Pe}px`,
            transform: wt(g.value) ? `scale(${ye}) translate3d(0, ${Ae}px, 0)` : `scale(${ye}) translate3d(${Ae}px, 0, 0)`,
            transition: "none"
          },
          !0
        );
      }
      if (!U.value) {
        const ye = jt * un;
        Tt((kt = G.value) == null ? void 0 : kt.$el, {
          transform: wt(g.value) ? `translate3d(0, ${ye}px, 0)` : `translate3d(${ye}px, 0, 0)`
        });
      }
    }
  }
  function L() {
    var De;
    if (!G.value)
      return;
    const Le = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]"), Ue = rl(G.value.$el, g.value);
    Tt(G.value.$el, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`
    }), Tt((De = D.value) == null ? void 0 : De.$el, {
      transition: `opacity ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      opacity: "1"
    }), d.value && Ue && Ue > 0 && $.value && Tt(
      Le,
      {
        borderRadius: `${Y_}px`,
        overflow: "hidden",
        ...wt(g.value) ? {
          transform: `scale(${te()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${te()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${ft.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${ft.EASE.join(",")})`
      },
      !0
    );
  }
  function be(De) {
    G.value && (a(), De || ($.value = !1), window.setTimeout(() => {
      U.value && (v.value = U.value[0]);
    }, ft.DURATION * 1e3));
  }
  Ie(() => {
    if (!$.value && d.value && I4) {
      const De = setTimeout(() => {
        F4(document.body);
      }, 200);
      return () => clearTimeout(De);
    }
  }), ve(o, () => {
    $.value = o.value, o.value || be();
  });
  function xe(De) {
    if (!k.value || !G.value)
      return;
    G.value.$el.classList.remove(Lm), F.value = !1, k.value = !1, M.value = /* @__PURE__ */ new Date();
    const Le = rl(G.value.$el, g.value);
    if (!z(De.target, !1) || !Le || Number.isNaN(Le) || T.value === null)
      return;
    const Ue = M.value.getTime() - T.value.getTime(), We = ne.value - (wt(g.value) ? De.clientY : De.clientX), it = Math.abs(We) / Ue;
    if (it > 0.05 && (P.value = !0, window.setTimeout(() => {
      P.value = !1;
    }, 200)), U.value) {
      const kt = g.value === "bottom" || g.value === "right" ? 1 : -1;
      pe({
        draggedDistance: We * kt,
        closeDrawer: be,
        velocity: it,
        dismissible: s.value
      }), n(!0);
      return;
    }
    if (g.value === "bottom" || g.value === "right" ? We > 0 : We < 0) {
      L(), n(!0);
      return;
    }
    if (it > K_) {
      be(), n(!1);
      return;
    }
    const ut = Math.min(
      G.value.$el.getBoundingClientRect().height ?? 0,
      window.innerHeight
    );
    if (Le >= ut * p.value) {
      be(), n(!1);
      return;
    }
    n(!0), L();
  }
  ve($, (De) => {
    De && (q.value = /* @__PURE__ */ new Date()), r(De);
  }, { immediate: !0 });
  function Fe(De) {
    var Le, Ue;
    const We = De ? (window.innerWidth - ol) / window.innerWidth : 1, it = De ? -16 : 0;
    J.value && window.clearTimeout(J.value), Tt((Le = G.value) == null ? void 0 : Le.$el, {
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      transform: `scale(${We}) translate3d(0, ${it}px, 0)`
    }), !De && (Ue = G.value) != null && Ue.$el && (J.value = window.setTimeout(() => {
      var ut, kt;
      const un = rl((ut = G.value) == null ? void 0 : ut.$el, g.value);
      Tt((kt = G.value) == null ? void 0 : kt.$el, {
        transition: "none",
        transform: wt(g.value) ? `translate3d(0, ${un}px, 0)` : `translate3d(${un}px, 0, 0)`
      });
    }, 500));
  }
  function Xe(De) {
    var Le;
    if (De < 0)
      return;
    const Ue = wt(g.value) ? window.innerHeight : window.innerWidth, We = (Ue - ol) / Ue, it = We + De * (1 - We), ut = -16 + De * ol;
    Tt((Le = G.value) == null ? void 0 : Le.$el, {
      transform: wt(g.value) ? `scale(${it}) translate3d(0, ${ut}px, 0)` : `scale(${it}) translate3d(${ut}px, 0, 0)`,
      transition: "none"
    });
  }
  function lt(De) {
    var Le;
    const Ue = wt(g.value) ? window.innerHeight : window.innerWidth, We = De ? (Ue - ol) / Ue : 1, it = De ? -16 : 0;
    De && Tt((Le = G.value) == null ? void 0 : Le.$el, {
      transition: `transform ${ft.DURATION}s cubic-bezier(${ft.EASE.join(",")})`,
      transform: wt(g.value) ? `scale(${We}) translate3d(0, ${it}px, 0)` : `scale(${We}) translate3d(${it}px, 0, 0)`
    });
  }
  return {
    open: o,
    isOpen: $,
    modal: u,
    keyboardIsOpen: Q,
    hasBeenOpened: B,
    drawerRef: G,
    drawerHeightRef: H,
    overlayRef: D,
    handleRef: ee,
    isDragging: k,
    dragStartTime: T,
    isAllowedToDrag: F,
    snapPoints: U,
    activeSnapPoint: v,
    hasSnapPoints: se,
    pointerStart: ne,
    dismissible: s,
    snapPointsOffset: _e,
    direction: g,
    shouldFade: Te,
    fadeFromIndex: m,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    onPress: re,
    onDrag: ie,
    onRelease: xe,
    closeDrawer: be,
    onNestedDrag: Xe,
    onNestedRelease: lt,
    onNestedOpenChange: Fe,
    emitClose: a,
    emitDrag: t,
    emitRelease: n,
    emitOpenChange: r,
    nested: i,
    handleOnly: C,
    noBodyStyles: w
  };
}
const K4 = /* @__PURE__ */ b({
  __name: "DrawerRoot",
  props: {
    activeSnapPoint: { default: void 0 },
    closeThreshold: { default: z4 },
    shouldScaleBackground: { type: Boolean, default: void 0 },
    setBackgroundColorOnScale: { type: Boolean, default: !0 },
    scrollLockTimeout: { default: H4 },
    fixed: { type: Boolean, default: void 0 },
    dismissible: { type: Boolean, default: !0 },
    modal: { type: Boolean, default: !0 },
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: void 0 },
    nested: { type: Boolean, default: !1 },
    direction: { default: "bottom" },
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean, default: !1 },
    preventScrollRestoration: { type: Boolean },
    snapPoints: { default: void 0 },
    fadeFromIndex: { default: void 0 }
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n;
    E0();
    const o = E(() => a.fadeFromIndex ?? (a.snapPoints && a.snapPoints.length - 1)), s = Nm(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), i = Nm(a, "activeSnapPoint", r, {
      passive: a.activeSnapPoint === void 0
    }), u = {
      emitDrag: (m) => r("drag", m),
      emitRelease: (m) => r("release", m),
      emitClose: () => r("close"),
      emitOpenChange: (m) => {
        r("update:open", m), setTimeout(() => {
          r("animationEnd", m);
        }, ft.DURATION * 1e3);
      }
    }, { closeDrawer: d, hasBeenOpened: c, modal: f, isOpen: p } = V4(
      G4({
        ...u,
        ...Me(a),
        activeSnapPoint: i,
        fadeFromIndex: o,
        open: s
      })
    );
    function v(m) {
      if (s.value !== void 0) {
        u.emitOpenChange(m);
        return;
      }
      p.value = m, m ? c.value = !0 : d();
    }
    return t({
      open: p
    }), (m, g) => (h(), x(l(xi), {
      open: l(p),
      modal: l(f),
      "onUpdate:open": v
    }, {
      default: y(() => [
        _(m.$slots, "default", { open: l(p) })
      ]),
      _: 3
    }, 8, ["open", "modal"]));
  }
}), Y4 = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  setup(e) {
    const { overlayRef: t, hasSnapPoints: n, isOpen: a, shouldFade: r } = sp();
    return (o, s) => (h(), x(l(gs), {
      ref_key: "overlayRef",
      ref: t,
      "data-vaul-overlay": "",
      "data-vaul-snap-points": l(a) && l(n) ? "true" : "false",
      "data-vaul-snap-points-overlay": l(a) && l(r) ? "true" : "false"
    }, null, 8, ["data-vaul-snap-points", "data-vaul-snap-points-overlay"]));
  }
}), X4 = () => () => {
};
function J4() {
  const { direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: a, noBodyStyles: r } = sp(), o = I(null), s = I(document.body.style.backgroundColor);
  function i() {
    return (window.innerWidth - X_) / window.innerWidth;
  }
  Ie((u) => {
    if (t.value && n.value) {
      o.value && clearTimeout(o.value);
      const d = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!d)
        return;
      L4(
        a.value && !r.value ? ad(document.body, { background: "black" }) : X4,
        ad(d, {
          transformOrigin: wt(e.value) ? "top" : "left",
          transitionProperty: "transform, border-radius",
          transitionDuration: `${ft.DURATION}s`,
          transitionTimingFunction: `cubic-bezier(${ft.EASE.join(",")})`
        })
      );
      const c = ad(d, {
        borderRadius: `${Y_}px`,
        overflow: "hidden",
        ...wt(e.value) ? {
          transform: `scale(${i()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${i()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      u(() => {
        c(), o.value = window.setTimeout(() => {
          s.value ? document.body.style.background = s.value : document.body.style.removeProperty("background");
        }, ft.DURATION * 1e3);
      });
    }
  }, { flush: "pre" });
}
const Z4 = /* @__PURE__ */ b({
  __name: "DrawerContent",
  setup(e) {
    const {
      open: t,
      isOpen: n,
      snapPointsOffset: a,
      hasSnapPoints: r,
      drawerRef: o,
      onPress: s,
      onDrag: i,
      onRelease: u,
      modal: d,
      emitOpenChange: c,
      dismissible: f,
      keyboardIsOpen: p,
      closeDrawer: v,
      direction: m,
      handleOnly: g
    } = sp();
    J4();
    const w = I(!1), C = E(() => a.value && a.value.length > 0 ? `${a.value[0]}px` : "0");
    function S(k) {
      if (!d.value || k.defaultPrevented) {
        k.preventDefault();
        return;
      }
      p.value && (p.value = !1), f.value ? c(!1) : k.preventDefault();
    }
    function $(k) {
      g.value || s(k);
    }
    function B(k) {
      g.value || i(k);
    }
    return Ie(() => {
      r.value && window.requestAnimationFrame(() => {
        w.value = !0;
      });
    }), (k, P) => (h(), x(l(hs), {
      ref_key: "drawerRef",
      ref: o,
      "data-vaul-drawer": "",
      "data-vaul-drawer-direction": l(m),
      "data-vaul-delayed-snap-points": w.value ? "true" : "false",
      "data-vaul-snap-points": l(n) && l(r) ? "true" : "false",
      style: dt({ "--snap-point-height": C.value }),
      onPointerdown: $,
      onPointermove: B,
      onPointerup: l(u),
      onPointerDownOutside: S,
      onOpenAutoFocus: P[0] || (P[0] = Ye(() => {
      }, ["prevent"])),
      onEscapeKeyDown: P[1] || (P[1] = (D) => {
        l(f) || D.preventDefault();
      })
    }, {
      default: y(() => [
        _(k.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-vaul-drawer-direction", "data-vaul-delayed-snap-points", "data-vaul-snap-points", "style", "onPointerup"]));
  }
}), EU = /* @__PURE__ */ b({
  __name: "Drawer",
  props: {
    activeSnapPoint: {},
    closeThreshold: {},
    shouldScaleBackground: { type: Boolean, default: !0 },
    setBackgroundColorOnScale: { type: Boolean },
    scrollLockTimeout: {},
    fixed: { type: Boolean },
    dismissible: { type: Boolean },
    modal: { type: Boolean },
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    nested: { type: Boolean },
    direction: {},
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean },
    preventScrollRestoration: { type: Boolean },
    snapPoints: {},
    fadeFromIndex: {}
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(K4), A({ "data-slot": "drawer" }, l(r)), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qU = /* @__PURE__ */ b({
  __name: "DrawerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Va), A({ "data-slot": "drawer-close" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Q4 = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Y4), A({ "data-slot": "drawer-overlay" }, l(n), {
      class: l(V)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), TU = /* @__PURE__ */ b({
  __name: "DrawerContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = me(n, t);
    return (o, s) => (h(), x(l($i), null, {
      default: y(() => [
        N(Q4),
        N(l(Z4), A({ "data-slot": "drawer-content" }, l(r), {
          class: l(V)(
            "group/drawer-content fixed z-50 flex h-auto flex-col bg-background",
            "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg",
            "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg",
            "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm",
            "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm",
            n.class
          )
        }), {
          default: y(() => [
            s[0] || (s[0] = we("div", { class: "mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full bg-muted group-data-[vaul-drawer-direction=bottom]/drawer-content:block" }, null, -1)),
            _(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), AU = /* @__PURE__ */ b({
  __name: "DrawerDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Si), A({ "data-slot": "drawer-description" }, l(n), {
      class: l(V)("text-sm text-muted-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), IU = /* @__PURE__ */ b({
  __name: "DrawerFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "drawer-footer",
      class: ae(l(V)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), OU = /* @__PURE__ */ b({
  __name: "DrawerHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "drawer-header",
      class: ae(l(V)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), RU = /* @__PURE__ */ b({
  __name: "DrawerTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(ki), A({ "data-slot": "drawer-title" }, l(n), {
      class: l(V)("font-semibold text-foreground", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), VU = /* @__PURE__ */ b({
  __name: "DrawerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Bi), A({ "data-slot": "drawer-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), FU = /* @__PURE__ */ b({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(CD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ez = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, NU = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(_D), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", ez, [
          N(l(Og), null, {
            default: y(() => [
              N(l(so), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), LU = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(AD), null, {
      default: y(() => [
        N(l($D), A(l(o), {
          class: l(V)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), zU = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(BD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), HU = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(PD), A(l(a), {
      class: l(V)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), UU = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(qD), A(l(a), {
      class: l(V)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jU = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(OD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tz = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, WU = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(VD), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", tz, [
          N(l(Og), null, {
            default: y(() => [
              N(l(gf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), GU = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(ND), A(l(n), {
      class: l(V)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), KU = /* @__PURE__ */ b({
  __name: "DropdownMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(V)("ml-auto text-xs tracking-widest opacity-60", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), YU = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(zD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), XU = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(UD), A(l(o), {
      class: l(V)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), JU = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(WD), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent data-[state=open]:bg-accent",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(za), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ZU = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(KD), A({ class: "outline-none" }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), QU = /* @__PURE__ */ b({
  __name: "Empty",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty",
      class: ae(
        l(V)(
          "flex min-w-0 flex-1 flex-col items-center justify-center gap-6 rounded-lg border-dashed p-6 text-center text-balance md:p-12",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), e9 = /* @__PURE__ */ b({
  __name: "EmptyContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-content",
      class: ae(
        l(V)(
          "flex w-full max-w-sm min-w-0 flex-col items-center gap-4 text-sm text-balance",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), t9 = /* @__PURE__ */ b({
  __name: "EmptyDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      "data-slot": "empty-description",
      class: ae(
        l(V)(
          "text-sm/relaxed text-muted-foreground [&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), n9 = /* @__PURE__ */ b({
  __name: "EmptyHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-header",
      class: ae(l(V)("flex max-w-sm flex-col items-center gap-2 text-center", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), nz = ["data-variant"], a9 = /* @__PURE__ */ b({
  __name: "EmptyMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-icon",
      "data-variant": e.variant,
      class: ae(l(V)(l(az)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, nz));
  }
}), r9 = /* @__PURE__ */ b({
  __name: "EmptyTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "empty-title",
      class: ae(l(V)("text-lg font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), az = sn(
  "mb-2 flex shrink-0 items-center justify-center [&_svg]:pointer-events-none [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground [&_svg:not([class*='size-'])]:size-6"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), rz = ["data-orientation"], o9 = /* @__PURE__ */ b({
  __name: "Field",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      role: "group",
      "data-slot": "field",
      "data-orientation": e.orientation,
      class: ae(l(V)(l(uz)({ orientation: e.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, rz));
  }
}), s9 = /* @__PURE__ */ b({
  __name: "FieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-content",
      class: ae(l(V)("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), l9 = /* @__PURE__ */ b({
  __name: "FieldDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      "data-slot": "field-description",
      class: ae(
        l(V)(
          "text-sm leading-normal font-normal text-muted-foreground group-has-[[data-orientation=horizontal]]/field:text-balance",
          "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), oz = {
  key: 2,
  class: "ml-4 flex list-disc flex-col gap-1"
}, i9 = /* @__PURE__ */ b({
  __name: "FieldError",
  props: {
    class: {},
    errors: {}
  },
  setup(e) {
    const t = e, n = E(() => !t.errors || t.errors.length === 0 ? null : t.errors.length === 1 && t.errors[0]?.message ? t.errors[0].message : t.errors.some((a) => a?.message) ? t.errors : null);
    return (a, r) => a.$slots.default || n.value ? (h(), W("div", {
      key: 0,
      role: "alert",
      "data-slot": "field-error",
      class: ae(l(V)("text-sm font-normal text-destructive", t.class))
    }, [
      a.$slots.default ? _(a.$slots, "default", { key: 0 }) : typeof n.value == "string" ? (h(), W(Ke, { key: 1 }, [
        Re(Ne(n.value), 1)
      ], 64)) : Array.isArray(n.value) ? (h(), W("ul", oz, [
        (h(!0), W(Ke, null, Lt(n.value, (o, s) => (h(), W("li", { key: s }, Ne(o?.message), 1))), 128))
      ])) : Ee("", !0)
    ], 2)) : Ee("", !0);
  }
}), u9 = /* @__PURE__ */ b({
  __name: "FieldGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-group",
      class: ae(
        l(V)(
          "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), J_ = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(iP), A(l(n), {
      class: l(V)(
        "text-sm leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), d9 = /* @__PURE__ */ b({
  __name: "FieldLabel",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(J_), {
      "data-slot": "field-label",
      class: ae(
        l(V)(
          "group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50",
          "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&_>[data-slot=field]]:p-3",
          "has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-primary/5 dark:has-[[data-state=checked]]:bg-primary/10",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), sz = ["data-variant"], c9 = /* @__PURE__ */ b({
  __name: "FieldLegend",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("legend", {
      "data-slot": "field-legend",
      "data-variant": e.variant,
      class: ae(
        l(V)(
          "mb-3 font-medium",
          "data-[variant=legend]:text-base",
          "data-[variant=label]:text-sm",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 10, sz));
  }
}), lz = ["data-content"], iz = {
  key: 0,
  class: "relative mx-auto block w-fit bg-background px-2 text-muted-foreground",
  "data-slot": "field-separator-content"
}, f9 = /* @__PURE__ */ b({
  __name: "FieldSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-separator",
      "data-content": !!n.$slots.default,
      class: ae(
        l(V)("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", t.class)
      )
    }, [
      N(l(Xi), { class: "absolute inset-0 top-1/2" }),
      n.$slots.default ? (h(), W("span", iz, [
        _(n.$slots, "default")
      ])) : Ee("", !0)
    ], 10, lz));
  }
}), p9 = /* @__PURE__ */ b({
  __name: "FieldSet",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("fieldset", {
      "data-slot": "field-set",
      class: ae(
        l(V)(
          "flex flex-col gap-6",
          "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), v9 = /* @__PURE__ */ b({
  __name: "FieldTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "field-label",
      class: ae(
        l(V)(
          "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), uz = sn(
  "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
  {
    variants: {
      orientation: {
        vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
        horizontal: [
          "flex-row items-center",
          "[&>[data-slot=field-label]]:flex-auto",
          "has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px has-[>[data-slot=field-content]]:items-start"
        ],
        responsive: [
          "@md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto flex-col [&>*]:w-full [&>.sr-only]:w-auto",
          "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
          "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
        ]
      }
    },
    defaultVariants: {
      orientation: "vertical"
    }
  }
);
function Nt(e) {
  return typeof e == "function";
}
function Br(e) {
  return e == null;
}
const Oa = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function lp(e) {
  return Number(e) >= 0;
}
function dz(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function cz(e) {
  return typeof e == "object" && e !== null;
}
function fz(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function Hm(e) {
  if (!cz(e) || fz(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function os(e, t) {
  return Object.keys(t).forEach((n) => {
    if (Hm(t[n]) && Hm(e[n])) {
      e[n] || (e[n] = {}), os(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function Mo(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let a = 1; a < t.length; a++) {
    if (lp(t[a])) {
      n += `[${t[a]}]`;
      continue;
    }
    n += `.${t[a]}`;
  }
  return n;
}
const pz = {};
function vz(e) {
  return pz[e];
}
function Um(e, t, n) {
  typeof n.value == "object" && (n.value = je(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function je(e) {
  if (typeof e != "object") return e;
  var t = 0, n, a, r, o = Object.prototype.toString.call(e);
  if (o === "[object Object]" ? r = Object.create(e.__proto__ || null) : o === "[object Array]" ? r = Array(e.length) : o === "[object Set]" ? (r = /* @__PURE__ */ new Set(), e.forEach(function(s) {
    r.add(je(s));
  })) : o === "[object Map]" ? (r = /* @__PURE__ */ new Map(), e.forEach(function(s, i) {
    r.set(je(i), je(s));
  })) : o === "[object Date]" ? r = /* @__PURE__ */ new Date(+e) : o === "[object RegExp]" ? r = new RegExp(e.source, e.flags) : o === "[object DataView]" ? r = new e.constructor(je(e.buffer)) : o === "[object ArrayBuffer]" ? r = e.slice(0) : o.slice(-6) === "Array]" && (r = new e.constructor(e)), r) {
    for (a = Object.getOwnPropertySymbols(e); t < a.length; t++)
      Um(r, a[t], Object.getOwnPropertyDescriptor(e, a[t]));
    for (t = 0, a = Object.getOwnPropertyNames(e); t < a.length; t++)
      Object.hasOwnProperty.call(r, n = a[t]) && r[n] === e[n] || Um(r, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return r || e;
}
const As = /* @__PURE__ */ Symbol("vee-validate-form"), mz = /* @__PURE__ */ Symbol("vee-validate-form-context"), Z_ = /* @__PURE__ */ Symbol("vee-validate-field-instance"), pi = /* @__PURE__ */ Symbol("Default empty value"), Q_ = typeof window < "u";
function rc(e) {
  return Nt(e) && !!e.__locatorRef;
}
function Pn(e) {
  return !!e && Nt(e.parse) && e.__type === "VVTypedSchema";
}
function vi(e) {
  return !!e && Nt(e.validate);
}
function Is(e) {
  return e === "checkbox" || e === "radio";
}
function hz(e) {
  return Oa(e) || Array.isArray(e);
}
function gz(e) {
  return Array.isArray(e) ? e.length === 0 : Oa(e) && Object.keys(e).length === 0;
}
function pu(e) {
  return /^\[.+\]$/i.test(e);
}
function yz(e) {
  return e0(e) && e.multiple;
}
function e0(e) {
  return e.tagName === "SELECT";
}
function bz(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function _z(e, t) {
  return !bz(e, t) && t.type !== "file" && !Is(t.type);
}
function t0(e) {
  return ip(e) && e.target && "submit" in e.target;
}
function ip(e) {
  return e ? !!(typeof Event < "u" && Nt(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function jm(e, t) {
  return t in e && e[t] !== pi;
}
function It(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, a, r;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (!It(e[a], t[a]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      for (a of e.entries())
        if (!It(a[1], t.get(a[0])))
          return !1;
      return !0;
    }
    if (Gm(e) && Gm(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (e[a] !== t[a])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (e = Wm(e), t = Wm(t), r = Object.keys(e), n = r.length, n !== Object.keys(t).length)
      return !1;
    for (a = n; a-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, r[a]))
        return !1;
    for (a = n; a-- !== 0; ) {
      var o = r[a];
      if (!It(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Wm(e) {
  return Object.fromEntries(Object.entries(e).filter(([, t]) => t !== void 0));
}
function Gm(e) {
  return Q_ ? e instanceof File : !1;
}
function up(e) {
  return pu(e) ? e.replace(/\[|\]/gi, "") : e;
}
function pt(e, t, n) {
  return e ? pu(t) ? e[up(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((r, o) => hz(r) && o in r ? r[o] : n, e) : n;
}
function At(e, t, n) {
  if (pu(t)) {
    e[up(t)] = n;
    return;
  }
  const a = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let o = 0; o < a.length; o++) {
    if (o === a.length - 1) {
      r[a[o]] = n;
      return;
    }
    (!(a[o] in r) || Br(r[a[o]])) && (r[a[o]] = lp(a[o + 1]) ? [] : {}), r = r[a[o]];
  }
}
function rd(e, t) {
  if (Array.isArray(e) && lp(t)) {
    e.splice(Number(t), 1);
    return;
  }
  Oa(e) && delete e[t];
}
function Km(e, t) {
  if (pu(t)) {
    delete e[up(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let a = e;
  for (let o = 0; o < n.length; o++) {
    if (o === n.length - 1) {
      rd(a, n[o]);
      break;
    }
    if (!(n[o] in a) || Br(a[n[o]]))
      break;
    a = a[n[o]];
  }
  const r = n.map((o, s) => pt(e, n.slice(0, s).join(".")));
  for (let o = r.length - 1; o >= 0; o--)
    if (gz(r[o])) {
      if (o === 0) {
        rd(e, n[0]);
        continue;
      }
      rd(r[o - 1], n[o - 1]);
    }
}
function Zt(e) {
  return Object.keys(e);
}
function dp(e, t = void 0) {
  const n = ht();
  return n?.provides[e] || Cn(e, t);
}
function od(e) {
  uh(`[vee-validate]: ${e}`);
}
function Ym(e, t, n) {
  if (Array.isArray(e)) {
    const a = [...e], r = a.findIndex((o) => It(o, t));
    return r >= 0 ? a.splice(r, 1) : a.push(t), a;
  }
  return It(e, t) ? n : t;
}
function wz(e, t) {
  let n, a;
  return function(...r) {
    const o = this;
    return n || (n = !0, setTimeout(() => n = !1, t), a = e.apply(o, r)), a;
  };
}
function Xm(e, t = 0) {
  let n = null, a = [];
  return function(...r) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const o = e(...r);
      a.forEach((s) => s(o)), a = [];
    }, t), new Promise((o) => a.push(o));
  };
}
function xz(e, t) {
  return Oa(t) && t.number ? dz(e) : e;
}
function oc(e, t) {
  let n;
  return async function(...r) {
    const o = e(...r);
    n = o;
    const s = await o;
    return o !== n ? s : (n = void 0, t(s, r));
  };
}
function Cz({ get: e, set: t }) {
  const n = I(je(e()));
  return ve(e, (a) => {
    It(a, n.value) || (n.value = je(a));
  }, {
    deep: !0
  }), ve(n, (a) => {
    It(a, e()) || t(je(a));
  }, {
    deep: !0
  }), n;
}
function sc(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function sl(e, t) {
  const n = {};
  for (const a in e)
    t.includes(a) || (n[a] = e[a]);
  return n;
}
function Sz(e) {
  let t = null, n = [];
  return function(...a) {
    const r = Be(() => {
      if (t !== r)
        return;
      const o = e(...a);
      n.forEach((s) => s(o)), n = [], t = null;
    });
    return t = r, new Promise((o) => n.push(o));
  };
}
function vu(e, t, n) {
  return t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
    default: () => {
      var a, r;
      return (r = (a = t.slots).default) === null || r === void 0 ? void 0 : r.call(a, n());
    }
  } : t.slots.default;
}
function sd(e) {
  if (n0(e))
    return e._value;
}
function n0(e) {
  return "_value" in e;
}
function $z(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function mi(e) {
  if (!ip(e))
    return e;
  const t = e.target;
  if (Is(t.type) && n0(t))
    return sd(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (yz(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(sd);
  if (e0(t)) {
    const n = Array.from(t.options).find((a) => a.selected);
    return n ? sd(n) : t.value;
  }
  return $z(t);
}
function a0(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? Oa(e) && e._$$isNormalized ? e : Oa(e) ? Object.keys(e).reduce((n, a) => {
    const r = kz(e[a]);
    return e[a] !== !1 && (n[a] = Jm(r)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, a) => {
    const r = Bz(a);
    return r.name && (n[r.name] = Jm(r.params)), n;
  }, t) : t;
}
function kz(e) {
  return e === !0 ? [] : Array.isArray(e) || Oa(e) ? e : [e];
}
function Jm(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? Dz(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, a) => (n[a] = t(e[a]), n), {});
}
const Bz = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function Dz(e) {
  const t = (n) => {
    var a;
    return (a = pt(n, e)) !== null && a !== void 0 ? a : n[e];
  };
  return t.__locatorRef = e, t;
}
function Pz(e) {
  return Array.isArray(e) ? e.filter(rc) : Zt(e).filter((t) => rc(e[t])).map((t) => e[t]);
}
const Mz = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let Ez = Object.assign({}, Mz);
const Ja = () => Ez;
async function r0(e, t, n = {}) {
  const a = n?.bails, r = {
    name: n?.name || "{field}",
    rules: t,
    label: n?.label,
    bails: a ?? !0,
    formData: n?.values || {}
  }, o = await qz(r, e);
  return Object.assign(Object.assign({}, o), { valid: !o.errors.length });
}
async function qz(e, t) {
  const n = e.rules;
  if (Pn(n) || vi(n))
    return Az(t, Object.assign(Object.assign({}, e), { rules: n }));
  if (Nt(n) || Array.isArray(n)) {
    const i = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, u = Array.isArray(n) ? n : [n], d = u.length, c = [];
    for (let f = 0; f < d; f++) {
      const p = u[f], v = await p(t, i);
      if (!(typeof v != "string" && !Array.isArray(v) && v)) {
        if (Array.isArray(v))
          c.push(...v);
        else {
          const g = typeof v == "string" ? v : s0(i);
          c.push(g);
        }
        if (e.bails)
          return {
            errors: c
          };
      }
    }
    return {
      errors: c
    };
  }
  const a = Object.assign(Object.assign({}, e), { rules: a0(n) }), r = [], o = Object.keys(a.rules), s = o.length;
  for (let i = 0; i < s; i++) {
    const u = o[i], d = await Iz(a, t, {
      name: u,
      params: a.rules[u]
    });
    if (d.error && (r.push(d.error), e.bails))
      return {
        errors: r
      };
  }
  return {
    errors: r
  };
}
function Tz(e) {
  return !!e && e.name === "ValidationError";
}
function o0(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n, a) {
      var r;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1, context: a?.formData || {} }),
          errors: []
        };
      } catch (o) {
        if (!Tz(o))
          throw o;
        if (!(!((r = o.inner) === null || r === void 0) && r.length) && o.errors.length)
          return { errors: [{ path: o.path, errors: o.errors }] };
        const s = o.inner.reduce((i, u) => {
          const d = u.path || "";
          return i[d] || (i[d] = { errors: [], path: d }), i[d].errors.push(...u.errors), i;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function Az(e, t) {
  const a = await (Pn(t.rules) ? t.rules : o0(t.rules)).parse(e, { formData: t.formData }), r = [];
  for (const o of a.errors)
    o.errors.length && r.push(...o.errors);
  return {
    value: a.value,
    errors: r
  };
}
async function Iz(e, t, n) {
  const a = vz(n.name);
  if (!a)
    throw new Error(`No such validator '${n.name}' exists.`);
  const r = Oz(n.params, e.formData), o = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: r })
  }, s = await a(t, r, o);
  return typeof s == "string" ? {
    error: s
  } : {
    error: s ? void 0 : s0(o)
  };
}
function s0(e) {
  const t = Ja().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function Oz(e, t) {
  const n = (a) => rc(a) ? a(t) : a;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((a, r) => (a[r] = n(e[r]), a), {});
}
async function Rz(e, t) {
  const a = await (Pn(e) ? e : o0(e)).parse(je(t), { formData: je(t) }), r = {}, o = {};
  for (const s of a.errors) {
    const i = s.errors, u = (s.path || "").replace(/\["(\d+)"\]/g, (d, c) => `[${c}]`);
    r[u] = { valid: !i.length, errors: i }, i.length && (o[u] = i[0]);
  }
  return {
    valid: !a.errors.length,
    results: r,
    errors: o,
    values: a.value,
    source: "schema"
  };
}
async function Vz(e, t, n) {
  const r = Zt(e).map(async (d) => {
    var c, f, p;
    const v = (c = n?.names) === null || c === void 0 ? void 0 : c[d], m = await r0(pt(t, d), e[d], {
      name: v?.name || d,
      label: v?.label,
      values: t,
      bails: (p = (f = n?.bailsMap) === null || f === void 0 ? void 0 : f[d]) !== null && p !== void 0 ? p : !0
    });
    return Object.assign(Object.assign({}, m), { path: d });
  });
  let o = !0;
  const s = await Promise.all(r), i = {}, u = {};
  for (const d of s)
    i[d.path] = {
      valid: d.valid,
      errors: d.errors
    }, d.valid || (o = !1, u[d.path] = d.errors[0]);
  return {
    valid: o,
    results: i,
    errors: u,
    source: "schema"
  };
}
let Zm = 0;
function Fz(e, t) {
  const { value: n, initialValue: a, setInitialValue: r } = Nz(e, t.modelValue, t.form);
  if (!t.form) {
    let p = function(v) {
      var m;
      "value" in v && (n.value = v.value), "errors" in v && d(v.errors), "touched" in v && (f.touched = (m = v.touched) !== null && m !== void 0 ? m : f.touched), "initialValue" in v && r(v.initialValue);
    };
    const { errors: u, setErrors: d } = Hz(), c = Zm >= Number.MAX_SAFE_INTEGER ? 0 : ++Zm, f = zz(n, a, u, t.schema);
    return {
      id: c,
      path: e,
      value: n,
      initialValue: a,
      meta: f,
      flags: { pendingUnmount: { [c]: !1 }, pendingReset: !1 },
      errors: u,
      setState: p
    };
  }
  const o = t.form.createPathState(e, {
    bails: t.bails,
    label: t.label,
    type: t.type,
    validate: t.validate,
    schema: t.schema
  }), s = E(() => o.errors);
  function i(u) {
    var d, c, f;
    "value" in u && (n.value = u.value), "errors" in u && ((d = t.form) === null || d === void 0 || d.setFieldError(l(e), u.errors)), "touched" in u && ((c = t.form) === null || c === void 0 || c.setFieldTouched(l(e), (f = u.touched) !== null && f !== void 0 ? f : !1)), "initialValue" in u && r(u.initialValue);
  }
  return {
    id: Array.isArray(o.id) ? o.id[o.id.length - 1] : o.id,
    path: e,
    value: n,
    errors: s,
    meta: o,
    initialValue: a,
    flags: o.__flags,
    setState: i
  };
}
function Nz(e, t, n) {
  const a = I(l(t));
  function r() {
    return n ? pt(n.initialValues.value, l(e), l(a)) : l(a);
  }
  function o(d) {
    if (!n) {
      a.value = d;
      return;
    }
    n.setFieldInitialValue(l(e), d, !0);
  }
  const s = E(r);
  if (!n)
    return {
      value: I(r()),
      initialValue: s,
      setInitialValue: o
    };
  const i = Lz(t, n, s, e);
  return n.stageInitialValue(l(e), i, !0), {
    value: E({
      get() {
        return pt(n.values, l(e));
      },
      set(d) {
        n.setFieldValue(l(e), d, !1);
      }
    }),
    initialValue: s,
    setInitialValue: o
  };
}
function Lz(e, t, n, a) {
  return mt(e) ? l(e) : e !== void 0 ? e : pt(t.values, l(a), l(n));
}
function zz(e, t, n, a) {
  const r = E(() => {
    var s, i, u;
    return (u = (i = (s = fe(a)) === null || s === void 0 ? void 0 : s.describe) === null || i === void 0 ? void 0 : i.call(s).required) !== null && u !== void 0 ? u : !1;
  }), o = Wt({
    touched: !1,
    pending: !1,
    valid: !0,
    required: r,
    validated: !!l(n).length,
    initialValue: E(() => l(t)),
    dirty: E(() => !It(l(e), l(t)))
  });
  return ve(n, (s) => {
    o.valid = !s.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), o;
}
function Hz() {
  const e = I([]);
  return {
    errors: e,
    setErrors: (t) => {
      e.value = sc(t);
    }
  };
}
const Ro = {}, Vo = {}, Fo = "vee-validate-inspector", Qt = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let _t = null, ra;
async function l0(e) {
  if (process.env.NODE_ENV !== "production") {
    if (!Q_)
      return;
    (await import("./index-DyCHxFp3.js")).setupDevtoolsPlugin({
      id: "vee-validate-devtools-plugin",
      label: "VeeValidate Plugin",
      packageName: "vee-validate",
      homepage: "https://vee-validate.logaretm.com/v4",
      app: e,
      logo: "https://vee-validate.logaretm.com/v4/logo.png"
    }, (n) => {
      ra = n, n.addInspector({
        id: Fo,
        icon: "rule",
        label: "vee-validate",
        noSelectionText: "Select a vee-validate node to inspect",
        actions: [
          {
            icon: "done_outline",
            tooltip: "Validate selected item",
            action: async () => {
              if (!_t) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (_t.type === "field") {
                await _t.field.validate();
                return;
              }
              if (_t.type === "form") {
                await _t.form.validate();
                return;
              }
              _t.type === "pathState" && await _t.form.validateField(_t.state.path);
            }
          },
          {
            icon: "delete_sweep",
            tooltip: "Clear validation state of the selected item",
            action: () => {
              if (!_t) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (_t.type === "field") {
                _t.field.resetField();
                return;
              }
              _t.type === "form" && _t.form.resetForm(), _t.type === "pathState" && _t.form.resetField(_t.state.path);
            }
          }
        ]
      }), n.on.getInspectorTree((a) => {
        if (a.inspectorId !== Fo)
          return;
        const r = Object.values(Ro), o = Object.values(Vo);
        a.rootNodes = [
          ...r.map(Wz),
          ...o.map((s) => Kz(s))
        ];
      }), n.on.getInspectorState((a) => {
        if (a.inspectorId !== Fo)
          return;
        const { form: r, field: o, state: s, type: i } = Yz(a.nodeId);
        if (n.unhighlightElement(), r && i === "form") {
          a.state = Xz(r), _t = { type: "form", form: r }, n.highlightElement(r._vm);
          return;
        }
        if (s && i === "pathState" && r) {
          a.state = Qm(s), _t = { type: "pathState", state: s, form: r };
          return;
        }
        if (o && i === "field") {
          a.state = Qm({
            errors: o.errors.value,
            dirty: o.meta.dirty,
            valid: o.meta.valid,
            touched: o.meta.touched,
            value: o.value.value,
            initialValue: o.meta.initialValue
          }), _t = { field: o, type: "field" }, n.highlightElement(o._vm);
          return;
        }
        _t = null, n.unhighlightElement();
      });
    });
  }
}
const Yr = wz(() => {
  setTimeout(async () => {
    await Be(), ra?.sendInspectorState(Fo), ra?.sendInspectorTree(Fo);
  }, 100);
}, 100);
function Uz(e) {
  const t = ht();
  if (!ra) {
    const n = t?.appContext.app;
    if (!n)
      return;
    l0(n);
  }
  Ro[e.formId] = Object.assign({}, e), Ro[e.formId]._vm = t, Qe(() => {
    delete Ro[e.formId], Yr();
  }), Yr();
}
function jz(e) {
  const t = ht();
  if (!ra) {
    const n = t?.appContext.app;
    if (!n)
      return;
    l0(n);
  }
  Vo[e.id] = Object.assign({}, e), Vo[e.id]._vm = t, Qe(() => {
    delete Vo[e.id], Yr();
  }), Yr();
}
function Wz(e) {
  const { textColor: t, bgColor: n } = u0(e.meta.value.valid), a = {};
  Object.values(e.getAllPathStates()).forEach((s) => {
    At(a, fe(s.path), Gz(s, e));
  });
  function r(s, i = []) {
    const u = [...i].pop();
    return "id" in s ? Object.assign(Object.assign({}, s), { label: u || s.label }) : Oa(s) ? {
      id: `${i.join(".")}`,
      label: u || "",
      children: Object.keys(s).map((d) => r(s[d], [...i, d]))
    } : Array.isArray(s) ? {
      id: `${i.join(".")}`,
      label: `${u}[]`,
      children: s.map((d, c) => r(d, [...i, String(c)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: o } = r(a);
  return {
    id: cp(e),
    label: e.name,
    children: o,
    tags: [
      {
        label: "Form",
        textColor: t,
        backgroundColor: n
      },
      {
        label: `${e.getAllPathStates().length} fields`,
        textColor: Qt.white,
        backgroundColor: Qt.unknown
      }
    ]
  };
}
function Gz(e, t) {
  return {
    id: cp(t, e),
    label: fe(e.path),
    tags: i0(e.multiple, e.fieldsCount, e.type, e.valid, t)
  };
}
function Kz(e, t) {
  return {
    id: cp(t, e),
    label: l(e.name),
    tags: i0(!1, 1, e.type, e.meta.valid, t)
  };
}
function i0(e, t, n, a, r) {
  const { textColor: o, bgColor: s } = u0(a);
  return [
    e ? void 0 : {
      label: "Field",
      textColor: o,
      backgroundColor: s
    },
    r ? void 0 : {
      label: "Standalone",
      textColor: Qt.black,
      backgroundColor: Qt.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: Qt.white,
      backgroundColor: Qt.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: Qt.white,
      backgroundColor: Qt.purple
    } : void 0,
    e ? {
      label: "Multiple",
      textColor: Qt.black,
      backgroundColor: Qt.orange
    } : void 0
  ].filter(Boolean);
}
function cp(e, t) {
  const n = t ? "path" in t ? "pathState" : "field" : "form", a = t ? "path" in t ? t?.path : fe(t?.name) : "", r = { f: e?.formId, ff: t?.id || a, type: n };
  return btoa(encodeURIComponent(JSON.stringify(r)));
}
function Yz(e) {
  try {
    const t = JSON.parse(decodeURIComponent(atob(e))), n = Ro[t.f];
    if (!n && t.ff) {
      const r = Vo[t.ff];
      return r ? {
        type: t.type,
        field: r
      } : {};
    }
    if (!n)
      return {};
    const a = n.getPathState(t.ff);
    return {
      type: t.type,
      form: n,
      state: a
    };
  } catch {
  }
  return {};
}
function Qm(e) {
  return {
    "Field state": [
      { key: "errors", value: e.errors },
      {
        key: "initialValue",
        value: e.initialValue
      },
      {
        key: "currentValue",
        value: e.value
      },
      {
        key: "touched",
        value: e.touched
      },
      {
        key: "dirty",
        value: e.dirty
      },
      {
        key: "valid",
        value: e.valid
      }
    ]
  };
}
function Xz(e) {
  const { errorBag: t, meta: n, values: a, isSubmitting: r, isValidating: o, submitCount: s } = e;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: s.value
      },
      {
        key: "isSubmitting",
        value: r.value
      },
      {
        key: "isValidating",
        value: o.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: a
      },
      {
        key: "errors",
        value: Zt(t.value).reduce((i, u) => {
          var d;
          const c = (d = t.value[u]) === null || d === void 0 ? void 0 : d[0];
          return c && (i[u] = c), i;
        }, {})
      }
    ]
  };
}
function u0(e) {
  return {
    bgColor: e ? Qt.success : Qt.error,
    textColor: e ? Qt.black : Qt.white
  };
}
function Jz(e, t, n) {
  return Is(n?.type) ? Qz(e, t, n) : d0(e, t, n);
}
function d0(e, t, n) {
  const { initialValue: a, validateOnMount: r, bails: o, type: s, checkedValue: i, label: u, validateOnValueUpdate: d, uncheckedValue: c, controlled: f, keepValueOnUnmount: p, syncVModel: v, form: m } = Zz(n), g = f ? dp(As) : void 0, w = m || g, C = E(() => Mo(fe(e))), S = E(() => {
    if (fe(w?.schema))
      return;
    const R = l(t);
    return vi(R) || Pn(R) || Nt(R) || Array.isArray(R) ? R : a0(R);
  }), $ = !Nt(S.value) && Pn(fe(t)), { id: B, value: k, initialValue: P, meta: D, setState: q, errors: T, flags: M } = Fz(C, {
    modelValue: a,
    form: w,
    bails: o,
    label: u,
    type: s,
    validate: S.value ? G : void 0,
    schema: $ ? t : void 0
  }), O = E(() => T.value[0]);
  v && e8({
    value: k,
    prop: v,
    handleChange: H,
    shouldValidate: () => d && !M.pendingReset
  });
  const F = (ce, R = !1) => {
    D.touched = !0, R && ne();
  };
  async function J(ce) {
    var R, te;
    if (w?.validateSchema) {
      const { results: z } = await w.validateSchema(ce);
      return (R = z[fe(C)]) !== null && R !== void 0 ? R : { valid: !0, errors: [] };
    }
    return S.value ? r0(k.value, S.value, {
      name: fe(C),
      label: fe(u),
      values: (te = w?.values) !== null && te !== void 0 ? te : {},
      bails: o
    }) : { valid: !0, errors: [] };
  }
  const ne = oc(async () => (D.pending = !0, D.validated = !0, J("validated-only")), (ce) => (M.pendingUnmount[ge.id] || (q({ errors: ce.errors }), D.pending = !1, D.valid = ce.valid), ce)), Q = oc(async () => J("silent"), (ce) => (D.valid = ce.valid, ce));
  function G(ce) {
    return ce?.mode === "silent" ? Q() : ne();
  }
  function H(ce, R = !0) {
    const te = mi(ce);
    de(te, R);
  }
  Ce(() => {
    if (r)
      return ne();
    (!w || !w.validateSchema) && Q();
  });
  function U(ce) {
    D.touched = ce;
  }
  function se(ce) {
    var R;
    const te = ce && "value" in ce ? ce.value : P.value;
    q({
      value: je(te),
      initialValue: je(te),
      touched: (R = ce?.touched) !== null && R !== void 0 ? R : !1,
      errors: ce?.errors || []
    }), D.pending = !1, D.validated = !1, Q();
  }
  const ee = ht();
  function de(ce, R = !0) {
    k.value = ee && v ? xz(ce, ee.props.modelModifiers) : ce, (R ? ne : Q)();
  }
  function pe(ce) {
    q({ errors: Array.isArray(ce) ? ce : [ce] });
  }
  const _e = E({
    get() {
      return k.value;
    },
    set(ce) {
      de(ce, d);
    }
  }), ge = {
    id: B,
    name: C,
    label: u,
    value: _e,
    meta: D,
    errors: T,
    errorMessage: O,
    type: s,
    checkedValue: i,
    uncheckedValue: c,
    bails: o,
    keepValueOnUnmount: p,
    resetField: se,
    handleReset: () => se(),
    validate: G,
    handleChange: H,
    handleBlur: F,
    setState: q,
    setTouched: U,
    setErrors: pe,
    setValue: de
  };
  if (Xn(Z_, ge), mt(t) && typeof l(t) != "function" && ve(t, (ce, R) => {
    It(ce, R) || (D.validated ? ne() : Q());
  }, {
    deep: !0
  }), process.env.NODE_ENV !== "production" && (ge._vm = ht(), ve(() => Object.assign(Object.assign({ errors: T.value }, D), { value: k.value }), Yr, {
    deep: !0
  }), w || jz(ge)), !w)
    return ge;
  const Te = E(() => {
    const ce = S.value;
    return !ce || Nt(ce) || vi(ce) || Pn(ce) || Array.isArray(ce) ? {} : Object.keys(ce).reduce((R, te) => {
      const z = Pz(ce[te]).map((re) => re.__locatorRef).reduce((re, ie) => {
        const L = pt(w.values, ie) || w.values[ie];
        return L !== void 0 && (re[ie] = L), re;
      }, {});
      return Object.assign(R, z), R;
    }, {});
  });
  return ve(Te, (ce, R) => {
    if (!Object.keys(ce).length)
      return;
    !It(ce, R) && (D.validated ? ne() : Q());
  }), sr(() => {
    var ce;
    const R = (ce = fe(ge.keepValueOnUnmount)) !== null && ce !== void 0 ? ce : fe(w.keepValuesOnUnmount), te = fe(C);
    if (R || !w || M.pendingUnmount[ge.id]) {
      w?.removePathState(te, B);
      return;
    }
    M.pendingUnmount[ge.id] = !0;
    const z = w.getPathState(te);
    if (Array.isArray(z?.id) && z?.multiple ? z?.id.includes(ge.id) : z?.id === ge.id) {
      if (z?.multiple && Array.isArray(z.value)) {
        const ie = z.value.findIndex((L) => It(L, fe(ge.checkedValue)));
        if (ie > -1) {
          const L = [...z.value];
          L.splice(ie, 1), w.setFieldValue(te, L);
        }
        Array.isArray(z.id) && z.id.splice(z.id.indexOf(ge.id), 1);
      } else
        w.unsetPathValue(fe(C));
      w.removePathState(te, B);
    }
  }), ge;
}
function Zz(e) {
  const t = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    label: void 0,
    validateOnValueUpdate: !0,
    keepValueOnUnmount: void 0,
    syncVModel: !1,
    controlled: !0
  }), n = !!e?.syncVModel, a = typeof e?.syncVModel == "string" ? e.syncVModel : e?.modelPropName || "modelValue", r = n && !("initialValue" in (e || {})) ? lc(ht(), a) : e?.initialValue;
  if (!e)
    return Object.assign(Object.assign({}, t()), { initialValue: r });
  const o = "valueProp" in e ? e.valueProp : e.checkedValue, s = "standalone" in e ? !e.standalone : e.controlled, i = e?.modelPropName || e?.syncVModel || !1;
  return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
    initialValue: r,
    controlled: s ?? !0,
    checkedValue: o,
    syncVModel: i
  });
}
function Qz(e, t, n) {
  const a = n?.standalone ? void 0 : dp(As), r = n?.checkedValue, o = n?.uncheckedValue;
  function s(i) {
    const u = i.handleChange, d = E(() => {
      const f = fe(i.value), p = fe(r);
      return Array.isArray(f) ? f.findIndex((v) => It(v, p)) >= 0 : It(p, f);
    });
    function c(f, p = !0) {
      var v, m;
      if (d.value === ((v = f?.target) === null || v === void 0 ? void 0 : v.checked)) {
        p && i.validate();
        return;
      }
      const g = fe(e), w = a?.getPathState(g), C = mi(f);
      let S = (m = fe(r)) !== null && m !== void 0 ? m : C;
      a && w?.multiple && w.type === "checkbox" ? S = Ym(pt(a.values, g) || [], S, void 0) : n?.type === "checkbox" && (S = Ym(fe(i.value), S, fe(o))), u(S, p);
    }
    return Object.assign(Object.assign({}, i), {
      checked: d,
      checkedValue: r,
      uncheckedValue: o,
      handleChange: c
    });
  }
  return s(d0(e, t, n));
}
function e8({ prop: e, value: t, handleChange: n, shouldValidate: a }) {
  const r = ht();
  if (!r || !e) {
    process.env.NODE_ENV !== "production" && console.warn("Failed to setup model events because `useField` was not called in setup.");
    return;
  }
  const o = typeof e == "string" ? e : "modelValue", s = `update:${o}`;
  o in r.props && (ve(t, (i) => {
    It(i, lc(r, o)) || r.emit(s, i);
  }), ve(() => lc(r, o), (i) => {
    if (i === pi && t.value === void 0)
      return;
    const u = i === pi ? void 0 : i;
    It(u, t.value) || n(u, a());
  }));
}
function lc(e, t) {
  if (e)
    return e.props[t];
}
const t8 = /* @__PURE__ */ b({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => Ja().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: pi
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = jn(e, "rules"), a = jn(e, "name"), r = jn(e, "label"), o = jn(e, "uncheckedValue"), s = jn(e, "keepValue"), { errors: i, value: u, errorMessage: d, validate: c, handleChange: f, handleBlur: p, setTouched: v, resetField: m, handleReset: g, meta: w, checked: C, setErrors: S, setValue: $ } = Jz(a, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: a8(e, t),
      // Only for checkboxes and radio buttons
      checkedValue: t.attrs.value,
      uncheckedValue: o,
      label: r,
      validateOnValueUpdate: e.validateOnModelUpdate,
      keepValueOnUnmount: s,
      syncVModel: !0
    }), B = function(M, O = !0) {
      f(M, O);
    }, k = E(() => {
      const { validateOnInput: T, validateOnChange: M, validateOnBlur: O, validateOnModelUpdate: F } = n8(e);
      function J(H) {
        p(H, O), Nt(t.attrs.onBlur) && t.attrs.onBlur(H);
      }
      function ne(H) {
        B(H, T), Nt(t.attrs.onInput) && t.attrs.onInput(H);
      }
      function Q(H) {
        B(H, M), Nt(t.attrs.onChange) && t.attrs.onChange(H);
      }
      const G = {
        name: e.name,
        onBlur: J,
        onInput: ne,
        onChange: Q
      };
      return G["onUpdate:modelValue"] = (H) => B(H, F), G;
    }), P = E(() => {
      const T = Object.assign({}, k.value);
      Is(t.attrs.type) && C && (T.checked = C.value);
      const M = eh(e, t);
      return _z(M, t.attrs) && (T.value = u.value), T;
    }), D = E(() => Object.assign(Object.assign({}, k.value), { modelValue: u.value }));
    function q() {
      return {
        field: P.value,
        componentField: D.value,
        value: u.value,
        meta: w,
        errors: i.value,
        errorMessage: d.value,
        validate: c,
        resetField: m,
        handleChange: B,
        handleInput: (T) => B(T, !1),
        handleReset: g,
        handleBlur: k.value.onBlur,
        setTouched: v,
        setErrors: S,
        setValue: $
      };
    }
    return t.expose({
      value: u,
      meta: w,
      errors: i,
      errorMessage: d,
      setErrors: S,
      setTouched: v,
      setValue: $,
      reset: m,
      validate: c,
      handleChange: f
    }), () => {
      const T = Pt(eh(e, t)), M = vu(T, t, q);
      return T ? an(T, Object.assign(Object.assign({}, t.attrs), P.value), M) : M;
    };
  }
});
function eh(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function n8(e) {
  var t, n, a, r;
  const { validateOnInput: o, validateOnChange: s, validateOnBlur: i, validateOnModelUpdate: u } = Ja();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : o,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : s,
    validateOnBlur: (a = e.validateOnBlur) !== null && a !== void 0 ? a : i,
    validateOnModelUpdate: (r = e.validateOnModelUpdate) !== null && r !== void 0 ? r : u
  };
}
function a8(e, t) {
  return Is(t.attrs.type) ? jm(e, "modelValue") ? e.modelValue : void 0 : jm(e, "modelValue") ? e.modelValue : t.attrs.value;
}
const m9 = t8;
let r8 = 0;
const ll = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function c0(e) {
  const t = e?.initialValues || {}, n = Object.assign({}, fe(t)), a = l(e?.validationSchema);
  return a && Pn(a) && Nt(a.cast) ? je(a.cast(n) || {}) : je(n);
}
function o8(e) {
  var t;
  const n = r8++, a = e?.name || "Form";
  let r = 0;
  const o = I(!1), s = I(!1), i = I(0), u = [], d = Wt(c0(e)), c = I([]), f = I({}), p = I({}), v = Sz(() => {
    p.value = c.value.reduce((K, Y) => (K[Mo(fe(Y.path))] = Y, K), {});
  });
  function m(K, Y) {
    const ue = H(K);
    if (!ue) {
      typeof K == "string" && (f.value[Mo(K)] = sc(Y));
      return;
    }
    if (typeof K == "string") {
      const ye = Mo(K);
      f.value[ye] && delete f.value[ye];
    }
    ue.errors = sc(Y), ue.valid = !ue.errors.length;
  }
  function g(K) {
    Zt(K).forEach((Y) => {
      m(Y, K[Y]);
    });
  }
  e?.initialErrors && g(e.initialErrors);
  const w = E(() => {
    const K = c.value.reduce((Y, ue) => (ue.errors.length && (Y[fe(ue.path)] = ue.errors), Y), {});
    return Object.assign(Object.assign({}, f.value), K);
  }), C = E(() => Zt(w.value).reduce((K, Y) => {
    const ue = w.value[Y];
    return ue?.length && (K[Y] = ue[0]), K;
  }, {})), S = E(() => c.value.reduce((K, Y) => (K[fe(Y.path)] = { name: fe(Y.path) || "", label: Y.label || "" }, K), {})), $ = E(() => c.value.reduce((K, Y) => {
    var ue;
    return K[fe(Y.path)] = (ue = Y.bails) !== null && ue !== void 0 ? ue : !0, K;
  }, {})), B = Object.assign({}, e?.initialErrors || {}), k = (t = e?.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: P, originalInitialValues: D, setInitialValues: q } = l8(c, d, e), T = s8(c, d, D, C), M = E(() => c.value.reduce((K, Y) => {
    const ue = pt(d, fe(Y.path));
    return At(K, fe(Y.path), ue), K;
  }, {})), O = e?.validationSchema;
  function F(K, Y) {
    var ue, ye;
    const Pe = E(() => pt(P.value, fe(K))), Ae = p.value[fe(K)], qe = Y?.type === "checkbox" || Y?.type === "radio";
    if (Ae && qe) {
      Ae.multiple = !0;
      const Xt = r++;
      return Array.isArray(Ae.id) ? Ae.id.push(Xt) : Ae.id = [Ae.id, Xt], Ae.fieldsCount++, Ae.__flags.pendingUnmount[Xt] = !1, Ae;
    }
    const rt = E(() => pt(d, fe(K))), ct = fe(K), qt = se.findIndex((Xt) => Xt === ct);
    qt !== -1 && se.splice(qt, 1);
    const at = E(() => {
      var Xt, ba, yr, co;
      const gu = fe(O);
      if (Pn(gu))
        return (ba = (Xt = gu.describe) === null || Xt === void 0 ? void 0 : Xt.call(gu, fe(K)).required) !== null && ba !== void 0 ? ba : !1;
      const yu = fe(Y?.schema);
      return Pn(yu) && (co = (yr = yu.describe) === null || yr === void 0 ? void 0 : yr.call(yu).required) !== null && co !== void 0 ? co : !1;
    }), Bt = r++, Vt = Wt({
      id: Bt,
      path: K,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((ue = B[ct]) === null || ue === void 0) && ue.length),
      required: at,
      initialValue: Pe,
      errors: gt([]),
      bails: (ye = Y?.bails) !== null && ye !== void 0 ? ye : !1,
      label: Y?.label,
      type: Y?.type || "default",
      value: rt,
      multiple: !1,
      __flags: {
        pendingUnmount: { [Bt]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: Y?.validate,
      dirty: E(() => !It(l(rt), l(Pe)))
    });
    return c.value.push(Vt), p.value[ct] = Vt, v(), C.value[ct] && !B[ct] && Be(() => {
      Ue(ct, { mode: "silent" });
    }), mt(K) && ve(K, (Xt) => {
      v();
      const ba = je(rt.value);
      p.value[Xt] = Vt, Be(() => {
        At(d, Xt, ba);
      });
    }), Vt;
  }
  const J = Xm(kt, 5), ne = Xm(kt, 5), Q = oc(async (K) => await (K === "silent" ? J() : ne()), (K, [Y]) => {
    const ue = Zt(R.errorBag.value), Pe = [
      .../* @__PURE__ */ new Set([...Zt(K.results), ...c.value.map((Ae) => Ae.path), ...ue])
    ].sort().reduce((Ae, qe) => {
      var rt;
      const ct = qe, qt = H(ct) || U(ct), at = ((rt = K.results[ct]) === null || rt === void 0 ? void 0 : rt.errors) || [], Bt = fe(qt?.path) || ct, Vt = i8({ errors: at, valid: !at.length }, Ae.results[Bt]);
      return Ae.results[Bt] = Vt, Vt.valid || (Ae.errors[Bt] = Vt.errors[0]), qt && f.value[Bt] && delete f.value[Bt], qt ? (qt.valid = Vt.valid, Y === "silent" || Y === "validated-only" && !qt.validated || m(qt, Vt.errors), Ae) : (m(Bt, at), Ae);
    }, {
      valid: K.valid,
      results: {},
      errors: {},
      source: K.source
    });
    return K.values && (Pe.values = K.values, Pe.source = K.source), Zt(Pe.results).forEach((Ae) => {
      var qe;
      const rt = H(Ae);
      rt && Y !== "silent" && (Y === "validated-only" && !rt.validated || m(rt, (qe = Pe.results[Ae]) === null || qe === void 0 ? void 0 : qe.errors));
    }), Pe;
  });
  function G(K) {
    c.value.forEach(K);
  }
  function H(K) {
    const Y = typeof K == "string" ? Mo(K) : K;
    return typeof Y == "string" ? p.value[Y] : Y;
  }
  function U(K) {
    return c.value.filter((ue) => K.startsWith(fe(ue.path))).reduce((ue, ye) => ue ? ye.path.length > ue.path.length ? ye : ue : ye, void 0);
  }
  let se = [], ee;
  function de(K) {
    return se.push(K), ee || (ee = Be(() => {
      [...se].sort().reverse().forEach((ue) => {
        Km(d, ue);
      }), se = [], ee = null;
    })), ee;
  }
  function pe(K) {
    return function(ue, ye) {
      return function(Ae) {
        return Ae instanceof Event && (Ae.preventDefault(), Ae.stopPropagation()), G((qe) => qe.touched = !0), o.value = !0, i.value++, Le().then((qe) => {
          const rt = je(d);
          if (qe.valid && typeof ue == "function") {
            const ct = je(M.value);
            let qt = K ? ct : rt;
            return qe.values && (qt = qe.source === "schema" ? qe.values : Object.assign({}, qt, qe.values)), ue(qt, {
              evt: Ae,
              controlledValues: ct,
              setErrors: g,
              setFieldError: m,
              setTouched: Xe,
              setFieldTouched: L,
              setValues: re,
              setFieldValue: te,
              resetForm: De,
              resetField: lt
            });
          }
          !qe.valid && typeof ye == "function" && ye({
            values: rt,
            evt: Ae,
            errors: qe.errors,
            results: qe.results
          });
        }).then((qe) => (o.value = !1, qe), (qe) => {
          throw o.value = !1, qe;
        });
      };
    };
  }
  const ge = pe(!1);
  ge.withControlled = pe(!0);
  function Te(K, Y) {
    const ue = c.value.findIndex((Pe) => Pe.path === K && (Array.isArray(Pe.id) ? Pe.id.includes(Y) : Pe.id === Y)), ye = c.value[ue];
    if (!(ue === -1 || !ye)) {
      if (Be(() => {
        Ue(K, { mode: "silent", warn: !1 });
      }), ye.multiple && ye.fieldsCount && ye.fieldsCount--, Array.isArray(ye.id)) {
        const Pe = ye.id.indexOf(Y);
        Pe >= 0 && ye.id.splice(Pe, 1), delete ye.__flags.pendingUnmount[Y];
      }
      (!ye.multiple || ye.fieldsCount <= 0) && (c.value.splice(ue, 1), We(K), v(), delete p.value[K]);
    }
  }
  function ce(K) {
    Zt(p.value).forEach((Y) => {
      Y.startsWith(K) && delete p.value[Y];
    }), c.value = c.value.filter((Y) => !Y.path.startsWith(K)), Be(() => {
      v();
    });
  }
  const R = {
    name: a,
    formId: n,
    values: d,
    controlledValues: M,
    errorBag: w,
    errors: C,
    schema: O,
    submitCount: i,
    meta: T,
    isSubmitting: o,
    isValidating: s,
    fieldArrays: u,
    keepValuesOnUnmount: k,
    validateSchema: l(O) ? Q : void 0,
    validate: Le,
    setFieldError: m,
    validateField: Ue,
    setFieldValue: te,
    setValues: re,
    setErrors: g,
    setFieldTouched: L,
    setTouched: Xe,
    resetForm: De,
    resetField: lt,
    handleSubmit: ge,
    useFieldModel: Oe,
    defineInputBinds: Et,
    defineComponentBinds: jt,
    defineField: gn,
    stageInitialValue: it,
    unsetInitialValue: We,
    setFieldInitialValue: ut,
    createPathState: F,
    getPathState: H,
    unsetPathValue: de,
    removePathState: Te,
    initialValues: P,
    getAllPathStates: () => c.value,
    destroyPath: ce,
    isFieldTouched: be,
    isFieldDirty: xe,
    isFieldValid: Fe
  };
  function te(K, Y, ue = !0) {
    const ye = je(Y), Pe = typeof K == "string" ? K : K.path;
    H(Pe) || F(Pe), At(d, Pe, ye), ue && Ue(Pe);
  }
  function z(K, Y = !0) {
    Zt(d).forEach((ue) => {
      delete d[ue];
    }), Zt(K).forEach((ue) => {
      te(ue, K[ue], !1);
    }), Y && Le();
  }
  function re(K, Y = !0) {
    os(d, K), u.forEach((ue) => ue && ue.reset()), Y && Le();
  }
  function ie(K, Y) {
    const ue = H(fe(K)) || F(K);
    return E({
      get() {
        return ue.value;
      },
      set(ye) {
        var Pe;
        const Ae = fe(K);
        te(Ae, ye, (Pe = fe(Y)) !== null && Pe !== void 0 ? Pe : !1);
      }
    });
  }
  function L(K, Y) {
    const ue = H(K);
    ue && (ue.touched = Y);
  }
  function be(K) {
    const Y = H(K);
    return Y ? Y.touched : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.touched);
  }
  function xe(K) {
    const Y = H(K);
    return Y ? Y.dirty : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.dirty);
  }
  function Fe(K) {
    const Y = H(K);
    return Y ? Y.valid : c.value.filter((ue) => ue.path.startsWith(K)).every((ue) => ue.valid);
  }
  function Xe(K) {
    if (typeof K == "boolean") {
      G((Y) => {
        Y.touched = K;
      });
      return;
    }
    Zt(K).forEach((Y) => {
      L(Y, !!K[Y]);
    });
  }
  function lt(K, Y) {
    var ue;
    const ye = Y && "value" in Y ? Y.value : pt(P.value, K), Pe = H(K);
    Pe && (Pe.__flags.pendingReset = !0), ut(K, je(ye), !0), te(K, ye, !1), L(K, (ue = Y?.touched) !== null && ue !== void 0 ? ue : !1), m(K, Y?.errors || []), Be(() => {
      Pe && (Pe.__flags.pendingReset = !1);
    });
  }
  function De(K, Y) {
    let ue = je(K?.values ? K.values : D.value);
    ue = Y?.force ? ue : os(D.value, ue), ue = Pn(O) && Nt(O.cast) ? O.cast(ue) : ue, q(ue, { force: Y?.force }), G((ye) => {
      var Pe;
      ye.__flags.pendingReset = !0, ye.validated = !1, ye.touched = ((Pe = K?.touched) === null || Pe === void 0 ? void 0 : Pe[fe(ye.path)]) || !1, te(fe(ye.path), pt(ue, fe(ye.path)), !1), m(fe(ye.path), void 0);
    }), Y?.force ? z(ue, !1) : re(ue, !1), g(K?.errors || {}), i.value = K?.submitCount || 0, Be(() => {
      Le({ mode: "silent" }), G((ye) => {
        ye.__flags.pendingReset = !1;
      });
    });
  }
  async function Le(K) {
    const Y = K?.mode || "force";
    if (Y === "force" && G((qe) => qe.validated = !0), R.validateSchema)
      return R.validateSchema(Y);
    s.value = !0;
    const ue = await Promise.all(c.value.map((qe) => qe.validate ? qe.validate(K).then((rt) => ({
      key: fe(qe.path),
      valid: rt.valid,
      errors: rt.errors,
      value: rt.value
    })) : Promise.resolve({
      key: fe(qe.path),
      valid: !0,
      errors: [],
      value: void 0
    })));
    s.value = !1;
    const ye = {}, Pe = {}, Ae = {};
    for (const qe of ue)
      ye[qe.key] = {
        valid: qe.valid,
        errors: qe.errors
      }, qe.value && At(Ae, qe.key, qe.value), qe.errors.length && (Pe[qe.key] = qe.errors[0]);
    return {
      valid: ue.every((qe) => qe.valid),
      results: ye,
      errors: Pe,
      values: Ae,
      source: "fields"
    };
  }
  async function Ue(K, Y) {
    var ue;
    const ye = H(K);
    if (ye && Y?.mode !== "silent" && (ye.validated = !0), O) {
      const { results: Ae } = await Q(Y?.mode || "validated-only");
      return Ae[K] || { errors: [], valid: !0 };
    }
    return ye?.validate ? ye.validate(Y) : (!ye && (!((ue = Y?.warn) !== null && ue !== void 0) || ue) && process.env.NODE_ENV !== "production" && uh(`field with path ${K} was not found`), Promise.resolve({ errors: [], valid: !0 }));
  }
  function We(K) {
    Km(P.value, K);
  }
  function it(K, Y, ue = !1) {
    ut(K, Y), At(d, K, Y), ue && !e?.initialValues && At(D.value, K, je(Y));
  }
  function ut(K, Y, ue = !1) {
    At(P.value, K, je(Y)), ue && At(D.value, K, je(Y));
  }
  async function kt() {
    const K = l(O);
    if (!K)
      return { valid: !0, results: {}, errors: {}, source: "none" };
    s.value = !0;
    const Y = vi(K) || Pn(K) ? await Rz(K, d) : await Vz(K, d, {
      names: S.value,
      bailsMap: $.value
    });
    return s.value = !1, Y;
  }
  const un = ge((K, { evt: Y }) => {
    t0(Y) && Y.target.submit();
  });
  Ce(() => {
    if (e?.initialErrors && g(e.initialErrors), e?.initialTouched && Xe(e.initialTouched), e?.validateOnMount) {
      Le();
      return;
    }
    R.validateSchema && R.validateSchema("silent");
  }), mt(O) && ve(O, () => {
    var K;
    (K = R.validateSchema) === null || K === void 0 || K.call(R, "validated-only");
  }), Xn(As, R), process.env.NODE_ENV !== "production" && (Uz(R), ve(() => Object.assign(Object.assign({ errors: w.value }, T.value), { values: d, isSubmitting: o.value, isValidating: s.value, submitCount: i.value }), Yr, {
    deep: !0
  }));
  function gn(K, Y) {
    const ue = Nt(Y) ? void 0 : Y?.label, ye = H(fe(K)) || F(K, { label: ue }), Pe = () => Nt(Y) ? Y(sl(ye, ll)) : Y || {};
    function Ae() {
      var at;
      ye.touched = !0, ((at = Pe().validateOnBlur) !== null && at !== void 0 ? at : Ja().validateOnBlur) && Ue(fe(ye.path));
    }
    function qe() {
      var at;
      ((at = Pe().validateOnInput) !== null && at !== void 0 ? at : Ja().validateOnInput) && Be(() => {
        Ue(fe(ye.path));
      });
    }
    function rt() {
      var at;
      ((at = Pe().validateOnChange) !== null && at !== void 0 ? at : Ja().validateOnChange) && Be(() => {
        Ue(fe(ye.path));
      });
    }
    const ct = E(() => {
      const at = {
        onChange: rt,
        onInput: qe,
        onBlur: Ae
      };
      return Nt(Y) ? Object.assign(Object.assign({}, at), Y(sl(ye, ll)).props || {}) : Y?.props ? Object.assign(Object.assign({}, at), Y.props(sl(ye, ll))) : at;
    });
    return [ie(K, () => {
      var at, Bt, Vt;
      return (Vt = (at = Pe().validateOnModelUpdate) !== null && at !== void 0 ? at : (Bt = Ja()) === null || Bt === void 0 ? void 0 : Bt.validateOnModelUpdate) !== null && Vt !== void 0 ? Vt : !0;
    }), ct];
  }
  function Oe(K) {
    return Array.isArray(K) ? K.map((Y) => ie(Y, !0)) : ie(K);
  }
  function Et(K, Y) {
    const [ue, ye] = gn(K, Y);
    function Pe() {
      ye.value.onBlur();
    }
    function Ae(rt) {
      const ct = mi(rt);
      te(fe(K), ct, !1), ye.value.onInput();
    }
    function qe(rt) {
      const ct = mi(rt);
      te(fe(K), ct, !1), ye.value.onChange();
    }
    return E(() => Object.assign(Object.assign({}, ye.value), {
      onBlur: Pe,
      onInput: Ae,
      onChange: qe,
      value: ue.value
    }));
  }
  function jt(K, Y) {
    const [ue, ye] = gn(K, Y), Pe = H(fe(K));
    function Ae(qe) {
      ue.value = qe;
    }
    return E(() => {
      const qe = Nt(Y) ? Y(sl(Pe, ll)) : Y || {};
      return Object.assign({ [qe.model || "modelValue"]: ue.value, [`onUpdate:${qe.model || "modelValue"}`]: Ae }, ye.value);
    });
  }
  const Rt = Object.assign(Object.assign({}, R), { values: or(d), handleReset: () => De(), submitForm: un });
  return Xn(mz, Rt), Rt;
}
function s8(e, t, n, a) {
  const r = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, o = E(() => !It(t, l(n)));
  function s() {
    const u = e.value;
    return Zt(r).reduce((d, c) => {
      const f = r[c];
      return d[c] = u[f]((p) => p[c]), d;
    }, {});
  }
  const i = Wt(s());
  return Ie(() => {
    const u = s();
    i.touched = u.touched, i.valid = u.valid, i.pending = u.pending;
  }), E(() => Object.assign(Object.assign({ initialValues: l(n) }, i), { valid: i.valid && !Zt(a.value).length, dirty: o.value }));
}
function l8(e, t, n) {
  const a = c0(n), r = I(a), o = I(je(a));
  function s(i, u) {
    u?.force ? (r.value = je(i), o.value = je(i)) : (r.value = os(je(r.value) || {}, je(i)), o.value = os(je(o.value) || {}, je(i))), u?.updateFields && e.value.forEach((d) => {
      if (d.touched)
        return;
      const f = pt(r.value, fe(d.path));
      At(t, fe(d.path), je(f));
    });
  }
  return {
    initialValues: r,
    originalInitialValues: o,
    setInitialValues: s
  };
}
function i8(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const u8 = /* @__PURE__ */ b({
  name: "Form",
  inheritAttrs: !1,
  props: {
    as: {
      type: null,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: "Form"
    }
  },
  setup(e, t) {
    const n = jn(e, "validationSchema"), a = jn(e, "keepValues"), { errors: r, errorBag: o, values: s, meta: i, isSubmitting: u, isValidating: d, submitCount: c, controlledValues: f, validate: p, validateField: v, handleReset: m, resetForm: g, handleSubmit: w, setErrors: C, setFieldError: S, setFieldValue: $, setValues: B, setFieldTouched: k, setTouched: P, resetField: D } = o8({
      validationSchema: n.value ? n : void 0,
      initialValues: e.initialValues,
      initialErrors: e.initialErrors,
      initialTouched: e.initialTouched,
      validateOnMount: e.validateOnMount,
      keepValuesOnUnmount: a,
      name: e.name
    }), q = w((G, { evt: H }) => {
      t0(H) && H.target.submit();
    }, e.onInvalidSubmit), T = e.onSubmit ? w(e.onSubmit, e.onInvalidSubmit) : q;
    function M(G) {
      ip(G) && G.preventDefault(), m(), typeof t.attrs.onReset == "function" && t.attrs.onReset();
    }
    function O(G, H) {
      return w(typeof G == "function" && !H ? G : H, e.onInvalidSubmit)(G);
    }
    function F() {
      return je(s);
    }
    function J() {
      return je(i.value);
    }
    function ne() {
      return je(r.value);
    }
    function Q() {
      return {
        meta: i.value,
        errors: r.value,
        errorBag: o.value,
        values: s,
        isSubmitting: u.value,
        isValidating: d.value,
        submitCount: c.value,
        controlledValues: f.value,
        validate: p,
        validateField: v,
        handleSubmit: O,
        handleReset: m,
        submitForm: q,
        setErrors: C,
        setFieldError: S,
        setFieldValue: $,
        setValues: B,
        setFieldTouched: k,
        setTouched: P,
        resetForm: g,
        resetField: D,
        getValues: F,
        getMeta: J,
        getErrors: ne
      };
    }
    return t.expose({
      setFieldError: S,
      setErrors: C,
      setFieldValue: $,
      setValues: B,
      setFieldTouched: k,
      setTouched: P,
      resetForm: g,
      validate: p,
      validateField: v,
      resetField: D,
      getValues: F,
      getMeta: J,
      getErrors: ne,
      values: s,
      meta: i,
      errors: r
    }), function() {
      const H = e.as === "form" ? e.as : e.as ? Pt(e.as) : null, U = vu(H, t, Q);
      return H ? an(H, Object.assign(Object.assign(Object.assign({}, H === "form" ? {
        // Disables native validation as vee-validate will handle it.
        novalidate: !0
      } : {}), t.attrs), { onSubmit: T, onReset: M }), U) : U;
    };
  }
}), h9 = u8;
function d8(e) {
  const t = dp(As, void 0), n = I([]), a = () => {
  }, r = {
    fields: n,
    remove: a,
    push: a,
    swap: a,
    insert: a,
    update: a,
    replace: a,
    prepend: a,
    move: a
  };
  if (!t)
    return process.env.NODE_ENV !== "production" && od("FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly"), r;
  if (!l(e))
    return process.env.NODE_ENV !== "production" && od("FieldArray requires a field path to be provided, did you forget to pass the `name` prop?"), r;
  const o = t.fieldArrays.find((k) => l(k.path) === l(e));
  if (o)
    return o;
  let s = 0;
  function i() {
    return pt(t?.values, fe(e), []) || [];
  }
  function u() {
    const k = i();
    Array.isArray(k) && (n.value = k.map((P, D) => c(P, D, n.value)), d());
  }
  u();
  function d() {
    const k = n.value.length;
    for (let P = 0; P < k; P++) {
      const D = n.value[P];
      D.isFirst = P === 0, D.isLast = P === k - 1;
    }
  }
  function c(k, P, D) {
    if (D && !Br(P) && D[P])
      return D[P];
    const q = s++;
    return {
      key: q,
      value: Cz({
        get() {
          const M = pt(t?.values, fe(e), []) || [], O = n.value.findIndex((F) => F.key === q);
          return O === -1 ? k : M[O];
        },
        set(M) {
          const O = n.value.findIndex((F) => F.key === q);
          if (O === -1) {
            process.env.NODE_ENV !== "production" && od("Attempting to update a non-existent array item");
            return;
          }
          C(O, M);
        }
      }),
      // will be auto unwrapped
      isFirst: !1,
      isLast: !1
    };
  }
  function f() {
    d(), t?.validate({ mode: "silent" });
  }
  function p(k) {
    const P = fe(e), D = pt(t?.values, P);
    if (!D || !Array.isArray(D))
      return;
    const q = [...D];
    q.splice(k, 1);
    const T = P + `[${k}]`;
    t.destroyPath(T), t.unsetInitialValue(T), At(t.values, P, q), n.value.splice(k, 1), f();
  }
  function v(k) {
    const P = je(k), D = fe(e), q = pt(t?.values, D), T = Br(q) ? [] : q;
    if (!Array.isArray(T))
      return;
    const M = [...T];
    M.push(P), t.stageInitialValue(D + `[${M.length - 1}]`, P), At(t.values, D, M), n.value.push(c(P)), f();
  }
  function m(k, P) {
    const D = fe(e), q = pt(t?.values, D);
    if (!Array.isArray(q) || !(k in q) || !(P in q))
      return;
    const T = [...q], M = [...n.value], O = T[k];
    T[k] = T[P], T[P] = O;
    const F = M[k];
    M[k] = M[P], M[P] = F, At(t.values, D, T), n.value = M, d();
  }
  function g(k, P) {
    const D = je(P), q = fe(e), T = pt(t?.values, q);
    if (!Array.isArray(T) || T.length < k)
      return;
    const M = [...T], O = [...n.value];
    M.splice(k, 0, D), O.splice(k, 0, c(D)), At(t.values, q, M), n.value = O, f();
  }
  function w(k) {
    const P = fe(e);
    t.stageInitialValue(P, k), At(t.values, P, k), u(), f();
  }
  function C(k, P) {
    const D = fe(e), q = pt(t?.values, D);
    !Array.isArray(q) || q.length - 1 < k || (At(t.values, `${D}[${k}]`, P), t?.validate({ mode: "validated-only" }));
  }
  function S(k) {
    const P = je(k), D = fe(e), q = pt(t?.values, D), T = Br(q) ? [] : q;
    if (!Array.isArray(T))
      return;
    const M = [P, ...T];
    At(t.values, D, M), t.stageInitialValue(D + "[0]", P), n.value.unshift(c(P)), f();
  }
  function $(k, P) {
    const D = fe(e), q = pt(t?.values, D), T = Br(q) ? [] : [...q];
    if (!Array.isArray(q) || !(k in q) || !(P in q))
      return;
    const M = [...n.value], O = M[k];
    M.splice(k, 1), M.splice(P, 0, O);
    const F = T[k];
    T.splice(k, 1), T.splice(P, 0, F), At(t.values, D, T), n.value = M, f();
  }
  const B = {
    fields: n,
    remove: p,
    push: v,
    swap: m,
    insert: g,
    update: C,
    replace: w,
    prepend: S,
    move: $
  };
  return t.fieldArrays.push(Object.assign({ path: e, reset: u }, B)), sr(() => {
    const k = t.fieldArrays.findIndex((P) => fe(P.path) === fe(e));
    k >= 0 && t.fieldArrays.splice(k, 1);
  }), ve(i, (k) => {
    const P = n.value.map((D) => D.value);
    It(k, P) || u();
  }), B;
}
const c8 = /* @__PURE__ */ b({
  name: "FieldArray",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const { push: n, remove: a, swap: r, insert: o, replace: s, update: i, prepend: u, move: d, fields: c } = d8(() => e.name);
    function f() {
      return {
        fields: c.value,
        push: n,
        remove: a,
        swap: r,
        insert: o,
        update: i,
        replace: s,
        prepend: u,
        move: d
      };
    }
    return t.expose({
      push: n,
      remove: a,
      swap: r,
      insert: o,
      update: i,
      replace: s,
      prepend: u,
      move: d
    }), () => vu(void 0, t, f);
  }
}), g9 = c8, f8 = /* @__PURE__ */ b({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const n = Cn(As, void 0), a = E(() => n?.errors.value[e.name]);
    function r() {
      return {
        message: a.value
      };
    }
    return () => {
      if (!a.value)
        return;
      const o = e.as ? Pt(e.as) : e.as, s = vu(o, t, r), i = Object.assign({ role: "alert" }, t.attrs);
      return !o && (Array.isArray(s) || !s) && s?.length ? s : (Array.isArray(s) || !s) && !s?.length ? an(o || "span", i, a.value) : an(o, i, s);
    };
  }
}), p8 = f8, f0 = /* @__PURE__ */ Symbol();
function mu() {
  const e = Cn(Z_), t = Cn(f0);
  if (!e) throw new Error("useFormField should be used within <FormField>");
  const { name: n, errorMessage: a, meta: r } = e, o = t, s = {
    valid: E(() => r.valid),
    isDirty: E(() => r.dirty),
    isTouched: E(() => r.touched),
    error: a
  };
  return {
    id: o,
    name: n,
    formItemId: `${o}-form-item`,
    formDescriptionId: `${o}-form-item-description`,
    formMessageId: `${o}-form-item-message`,
    ...s
  };
}
const y9 = /* @__PURE__ */ b({
  __name: "FormControl",
  setup(e) {
    const { error: t, formItemId: n, formDescriptionId: a, formMessageId: r } = mu();
    return (o, s) => (h(), x(l(ql), {
      id: l(n),
      "aria-describedby": l(t) ? `${l(a)} ${l(r)}` : `${l(a)}`,
      "aria-invalid": !!l(t)
    }, {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "aria-describedby", "aria-invalid"]));
  }
}), v8 = ["id"], b9 = /* @__PURE__ */ b({
  __name: "FormDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { formDescriptionId: n } = mu();
    return (a, r) => (h(), W("p", {
      id: l(n),
      class: ae(l(V)("text-sm text-muted-foreground", t.class))
    }, [
      _(a.$slots, "default")
    ], 10, v8));
  }
}), _9 = /* @__PURE__ */ b({
  __name: "FormItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Ge();
    return Xn(f0, n), (a, r) => (h(), W("div", {
      class: ae(l(V)("space-y-2", t.class))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), w9 = /* @__PURE__ */ b({
  __name: "FormLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, { error: n, formItemId: a } = mu();
    return (r, o) => (h(), x(l(J_), {
      class: ae(l(V)(l(n) && "text-destructive", t.class)),
      for: l(a)
    }, {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "for"]));
  }
}), x9 = /* @__PURE__ */ b({
  __name: "FormMessage",
  setup(e) {
    const { name: t, formMessageId: n } = mu();
    return (a, r) => (h(), x(l(p8), {
      id: l(n),
      as: "p",
      name: fe(l(t)),
      class: "text-[0.8rem] font-medium text-destructive"
    }, null, 8, ["id", "name"]));
  }
}), C9 = /* @__PURE__ */ b({
  __name: "HoverCard",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    openDelay: {},
    closeDelay: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(JD), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), S9 = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(rP), null, {
      default: y(() => [
        N(l(nP), A(l(a), {
          class: l(V)(
            "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), $9 = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(sP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), p0 = /* @__PURE__ */ b({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Gi(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => uc((h(), W("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null),
      "data-slot": "input",
      class: ae(
        l(V)(
          "h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30",
          "focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50",
          "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
          n.class
        )
      )
    }, null, 2)), [
      [dh, l(r)]
    ]);
  }
}), k9 = /* @__PURE__ */ b({
  __name: "InputGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "input-group",
      role: "group",
      class: ae(
        l(V)(
          "group/input-group relative flex w-full items-center rounded-md border border-input outline-none dark:bg-input/30",
          "h-9 min-w-0 has-[>textarea]:h-auto",
          // Variants based on alignment.
          "has-[>[data-align=inline-start]]:[&>input]:pl-2",
          "has-[>[data-align=inline-end]]:[&>input]:pr-2",
          "has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3",
          "has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3",
          // Focus state.
          "has-[[data-slot=input-group-control]:focus-visible]:ring-1 has-[[data-slot=input-group-control]:focus-visible]:ring-ring",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), m8 = ["data-align"], B9 = /* @__PURE__ */ b({
  __name: "InputGroupAddon",
  props: {
    align: { default: "inline-start" },
    class: {}
  },
  setup(e) {
    const t = e;
    function n(a) {
      const r = a.currentTarget, o = a.target;
      o && o.closest("button") || r && r?.parentElement && r.parentElement?.querySelector("input")?.focus();
    }
    return (a, r) => (h(), W("div", {
      role: "group",
      "data-slot": "input-group-addon",
      "data-align": t.align,
      class: ae(l(V)(l(g8)({ align: t.align }), t.class)),
      onClick: n
    }, [
      _(a.$slots, "default")
    ], 10, m8));
  }
}), D9 = /* @__PURE__ */ b({
  __name: "InputGroupButton",
  props: {
    variant: { default: "ghost" },
    size: { default: "xs" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Ss), {
      "data-size": t.size,
      variant: t.variant,
      class: ae(l(V)(l(y8)({ size: t.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-size", "variant", "class"]));
  }
}), P9 = /* @__PURE__ */ b({
  __name: "InputGroupInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(p0), {
      "data-slot": "input-group-control",
      class: ae(
        l(V)(
          "flex-1 rounded-none border-0 bg-transparent ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), M9 = /* @__PURE__ */ b({
  __name: "InputGroupText",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(
        l(V)(
          "flex items-center gap-2 text-sm text-muted-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), h8 = /* @__PURE__ */ b({
  __name: "Textarea",
  props: {
    class: {},
    defaultValue: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Gi(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => uc((h(), W("textarea", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => mt(r) ? r.value = i : null),
      class: ae(
        l(V)(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          n.class
        )
      )
    }, null, 2)), [
      [dh, l(r)]
    ]);
  }
}), E9 = /* @__PURE__ */ b({
  __name: "InputGroupTextarea",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(h8), {
      "data-slot": "input-group-control",
      class: ae(
        l(V)(
          "flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), g8 = sn(
  "flex h-auto cursor-text select-none items-center justify-center gap-2 py-1.5 text-sm font-medium text-muted-foreground group-data-[disabled=true]/input-group:opacity-50 [&>kbd]:rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-4",
  {
    variants: {
      align: {
        "inline-start": "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
        "inline-end": "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
        "block-start": "[.border-b]:pb-3 order-first w-full justify-start px-3 pt-3 group-has-[>input]/input-group:pt-2.5",
        "block-end": "[.border-t]:pt-3 order-last w-full justify-start px-3 pb-3 group-has-[>input]/input-group:pb-2.5"
      }
    },
    defaultVariants: {
      align: "inline-start"
    }
  }
), y8 = sn("flex items-center gap-2 text-sm shadow-none", {
  variants: {
    size: {
      xs: "h-6 gap-1 rounded-[calc(var(--radius)-5px)] px-2 has-[>svg]:px-2 [&>svg:not([class*='size-'])]:size-3.5",
      sm: "h-8 gap-1.5 rounded-md px-2.5 has-[>svg]:px-2.5",
      "icon-xs": "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
      "icon-sm": "size-8 p-0 has-[>svg]:p-0"
    }
  },
  defaultVariants: {
    size: "xs"
  }
});
function b8(e) {
  return ss() ? (ic(e), !0) : !1;
}
function _8(e) {
  if (!mt(e))
    return Wt(e);
  const t = new Proxy({}, {
    get(n, a, r) {
      return l(Reflect.get(e.value, a, r));
    },
    set(n, a, r) {
      return mt(e.value[a]) && !mt(r) ? e.value[a].value = r : e.value[a] = r, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Wt(t);
}
function w8(e) {
  return _8(E(e));
}
function x8(e, ...t) {
  const n = t.flat(), a = n[0];
  return w8(() => Object.fromEntries(typeof a == "function" ? Object.entries(Me(e)).filter(([r, o]) => !a(fe(o), r)) : Object.entries(Me(e)).filter((r) => !n.includes(r[0]))));
}
const v0 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const C8 = Object.prototype.toString, S8 = (e) => C8.call(e) === "[object Object]", $8 = () => {
};
function ld(e) {
  return Array.isArray(e) ? e : [e];
}
function k8(...e) {
  if (e.length !== 1)
    return jn(...e);
  const t = e[0];
  return typeof t == "function" ? or(hi(() => ({ get: t, set: $8 }))) : I(t);
}
function B8(e, t, n) {
  return ve(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
const m0 = v0 ? window : void 0, ja = v0 ? window.document : void 0;
function D8(e) {
  var t;
  const n = fe(e);
  return (t = n?.$el) != null ? t : n;
}
function P8(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), r = E(() => {
    const i = ld(fe(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), o = B8(
    () => {
      var i, u;
      return [
        (u = (i = r.value) == null ? void 0 : i.map((d) => D8(d))) != null ? u : [m0].filter((d) => d != null),
        ld(fe(r.value ? e[1] : e[0])),
        ld(l(r.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        fe(r.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !i?.length || !u?.length || !d?.length)
        return;
      const f = S8(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return b8(n), s;
}
function M8(e, t) {
  const n = gt(t);
  return ve(
    k8(e),
    (a, r) => {
      n.value = r;
    },
    { flush: "sync" }
  ), or(n);
}
const E8 = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`, q8 = b({
  props: { fallback: {
    type: String,
    required: !0
  } },
  setup(e) {
    return () => an("noscript", { innerHTML: `<style>${e.fallback}</style>` });
  }
}), h0 = /* @__PURE__ */ Symbol("vue-otp-context");
function T8(e) {
  return [
    setTimeout(e, 0),
    setTimeout(e, 10),
    setTimeout(e, 50)
  ];
}
const A8 = 18, g0 = 40, I8 = `${g0}px`, O8 = [
  "[data-lastpass-icon-root]",
  "com-1password-button",
  "[data-dashlanecreated]",
  '[style$="2147483647 !important;"]'
].join(",");
function R8({ containerRef: e, inputRef: t, pushPasswordManagerStrategy: n, isFocused: a }) {
  const r = I({
    done: !1,
    refocused: !1
  }), o = I(!1), s = I(!1), i = I(!1), u = E(() => n === "none" ? !1 : (n === "increase-width" || n === "experimental-no-flickering") && o.value && s.value), d = () => {
    const p = e.value, v = t.value;
    if (!p || !v || i.value || n === "none") return;
    const m = p, g = m.getBoundingClientRect().left + m.offsetWidth, w = m.getBoundingClientRect().top + m.offsetHeight / 2, C = g - A8, S = w;
    if (!(document.querySelectorAll(O8).length === 0 && document.elementFromPoint(C, S) === p) && (o.value = !0, i.value = !0, !r.value.refocused && document.activeElement === v)) {
      const $ = [v.selectionStart, v.selectionEnd];
      v.blur(), v.focus(), v.setSelectionRange($[0], $[1]), r.value.refocused = !0;
    }
  }, c = () => {
    const p = e.value;
    !p || n === "none" || (s.value = window.innerWidth - p.getBoundingClientRect().right >= g0);
  };
  let f;
  return Ce(() => {
    c(), f = setInterval(c, 1e3);
  }), Qe(() => {
    clearInterval(f);
  }), ve([a, t], (p, v, m) => {
    const [g, w] = p, C = g || document.activeElement === w;
    if (n === "none" || !C) return;
    const S = setTimeout(d, 0), $ = setTimeout(d, 2e3), B = setTimeout(d, 5e3), k = setTimeout(() => {
      i.value = !0;
    }, 6e3);
    m(() => {
      clearTimeout(S), clearTimeout($), clearTimeout(B), clearTimeout(k);
    });
  }), {
    hasPWMBadge: o,
    willPushPWMBadge: u,
    PWM_BADGE_SPACE_WIDTH: I8
  };
}
const V8 = { style: {
  position: "absolute",
  inset: "0",
  "pointer-events": "none"
} }, F8 = [
  "value",
  "data-input-otp-placeholder-shown",
  "data-input-otp-mss",
  "data-input-otp-mse",
  "aria-placeholder",
  "pattern"
], N8 = /* @__PURE__ */ b({
  name: "OTPInput",
  inheritAttrs: !1,
  __name: "OTPInput",
  props: /* @__PURE__ */ pp({
    maxlength: {},
    textAlign: { default: "left" },
    inputmode: { default: "numeric" },
    containerClass: {},
    pushPasswordManagerStrategy: { default: "increase-width" },
    noScriptCssFallback: { default: E8 },
    defaultValue: { default: "" },
    pasteTransformer: {},
    accept: {},
    alt: {},
    autocomplete: { default: "one-time-code" },
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [
      Boolean,
      Array,
      Set
    ] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {}
  }, {
    modelValue: { default(e) {
      return e.defaultValue;
    } },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ pp([
    "complete",
    "change",
    "select",
    "input",
    "focus",
    "blur",
    "mouseover",
    "mouseleave",
    "paste"
  ], ["update:modelValue"]),
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, [o] = q0(e, "modelValue"), s = M8(o), i = E(() => a.pattern ? typeof a.pattern == "string" ? new RegExp(a.pattern) : a.pattern : null), u = gt(!1), d = gt(!1), c = gt(null), f = gt(null), p = gt(null), v = gt(null), m = m0?.CSS?.supports?.("-webkit-touch-callout", "none");
    let g = { prev: [
      p.value?.selectionStart,
      p.value?.selectionEnd,
      p.value?.selectionDirection
    ] };
    function w(M, O) {
      try {
        M.insertRule(O);
      } catch {
        console.error("input-otp could not insert CSS rule:", O);
      }
    }
    Ce(() => {
      const M = p.value, O = v.value;
      if (!M || !O) return;
      g.prev = [
        M.selectionStart,
        M.selectionEnd,
        M.selectionDirection ?? "none"
      ];
      const F = P8(ja, "selectionchange", J, { capture: !0 });
      function J() {
        if (!M) return;
        if (ja?.activeElement !== M) {
          c.value = null, f.value = null;
          return;
        }
        const G = M.selectionStart, H = M.selectionEnd, U = M.selectionDirection, se = M.maxLength, ee = M.value, de = g.prev;
        let pe = -1, _e = -1, ge;
        if (ee.length !== 0 && G !== null && H !== null) {
          const te = G === H, z = G === ee.length && ee.length < se;
          if (te && !z) {
            const re = G;
            if (re === 0)
              pe = 0, _e = 1, ge = "forward";
            else if (re === se)
              pe = re - 1, _e = re, ge = "backward";
            else if (se > 1 && ee.length > 1) {
              let ie = 0;
              if (de[0] !== null && de[1] !== null) {
                ge = re < de[1] ? "backward" : "forward";
                const L = de[0] === de[1] && de[0] < se;
                ge === "backward" && !L && (ie = -1);
              }
              pe = ie + re, _e = ie + re + 1;
            }
          }
          pe !== -1 && _e !== -1 && pe !== _e && M.setSelectionRange(pe, _e, ge);
        }
        const Te = pe !== -1 ? pe : G, ce = _e !== -1 ? _e : H, R = ge ?? U;
        c.value = Te, f.value = ce, g.prev = [
          Te,
          ce,
          R
        ];
      }
      if (J(), ja?.activeElement === M && (d.value = !0), !ja?.getElementById("input-otp-style")) {
        const G = ja?.createElement("style");
        if (G.id = "input-otp-style", ja?.head.appendChild(G), G.sheet) {
          const H = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
          w(G.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), w(G.sheet, `[data-input-otp]:autofill { ${H} }`), w(G.sheet, `[data-input-otp]:-webkit-autofill { ${H} }`), w(G.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), w(G.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
        }
      }
      const ne = () => {
        O && O.style.setProperty("--root-height", `${M.clientHeight}px`);
      };
      ne();
      const Q = new ResizeObserver(ne);
      Q.observe(M), Qe(() => {
        F(), Q.disconnect();
      });
    }), ve([o], () => {
      T8(() => {
        if (!p.value) return;
        p.value?.dispatchEvent(new Event("input"));
        const M = p.value?.selectionStart, O = p.value?.selectionEnd, F = p.value?.selectionDirection;
        M !== null && O !== null && (c.value = M ?? null, f.value = O ?? null, g.prev = [
          M,
          O,
          F
        ]);
      });
    }, { immediate: !0 }), Ie(() => {
      s.value !== void 0 && o.value !== s.value && s.value.length < a.maxlength && o.value.length === a.maxlength && r("complete", o.value);
    });
    const C = R8({
      containerRef: v,
      inputRef: p,
      pushPasswordManagerStrategy: a.pushPasswordManagerStrategy,
      isFocused: d
    });
    function S(M) {
      if (M.inputType === "insertText" && M.data !== null) {
        const O = M.currentTarget, F = O.selectionStart ?? 0, J = O.selectionEnd ?? 0, ne = O.value, Q = (F !== J ? ne.slice(0, F) + M.data + ne.slice(J) : ne.slice(0, F) + M.data + ne.slice(F)).slice(0, a.maxlength);
        Q.length > 0 && i.value && !i.value.test(Q) && M.preventDefault();
      }
    }
    function $(M) {
      const O = M.currentTarget.value.slice(0, a.maxlength);
      if (O.length > 0 && i.value && !i.value.test(O)) {
        M.preventDefault();
        return;
      }
      typeof s.value == "string" && O.length < s.value.length && ja?.dispatchEvent(new Event("selectionchange")), o.value = O, r("input", O);
    }
    function B() {
      const M = p.value;
      if (M) {
        const O = Math.min(M.value.length, a.maxlength - 1), F = M.value.length;
        M.setSelectionRange(O, F), c.value = O, f.value = F;
      }
      d.value = !0;
    }
    function k(M) {
      const O = p.value;
      if (!O || !a.pasteTransformer && (!m || !M.clipboardData || !O)) return;
      const F = M?.clipboardData?.getData("text/plain"), J = a?.pasteTransformer ? a.pasteTransformer(F) : F;
      M.preventDefault();
      const ne = p.value?.selectionStart, Q = p.value?.selectionEnd, G = (ne !== Q ? o.value.slice(0, ne) + J + o.value.slice(Q) : o.value.slice(0, ne) + J + o.value.slice(ne)).slice(0, a.maxlength);
      if (G.length > 0 && i.value && !i.value.test(G)) return;
      o.value = G, r("input", G);
      const H = Math.min(G.length, a.maxlength - 1), U = G.length;
      O?.setSelectionRange(H, U), c.value = H, f.value = U;
    }
    const P = he(x8(a, "containerClass", "value", "pattern", "defaultValue", "pushPasswordManagerStrategy", "noScriptCssFallback", "modelValue")), D = E(() => ({
      position: "relative",
      cursor: a.disabled ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })), q = E(() => ({
      position: "absolute",
      inset: 0,
      width: C.willPushPWMBadge.value ? `calc(100% + ${C.PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: C.willPushPWMBadge.value ? `inset(0 ${C.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: a.textAlign,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })), T = E(() => ({
      slots: Array.from({ length: Number(a.maxlength) }).map((M, O) => {
        const F = d.value && c.value !== null && f.value !== null && (c.value === f.value && O === c.value || O >= c.value && O < f.value), J = o.value[O] !== void 0 ? o.value[O] : null;
        return {
          char: J,
          placeholderChar: J ?? a?.placeholder?.[O] ?? null,
          isActive: F,
          hasFakeCaret: F && J === null
        };
      }),
      isFocused: d.value,
      isHovering: !a.disabled && u.value
    }));
    return Xn(h0, T), t(Object.defineProperty({}, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => p
    })), (M, O) => (h(), W(Ke, null, [e.noScriptCssFallback !== null ? (h(), x(l(q8), {
      key: 0,
      fallback: e.noScriptCssFallback
    }, null, 8, ["fallback"])) : Ee("v-if", !0), we("div", {
      ref_key: "containerRef",
      ref: v,
      "data-input-otp-container": "",
      style: dt(D.value),
      class: ae(e.containerClass)
    }, [_(M.$slots, "default", {
      slots: T.value.slots,
      isFocused: d.value,
      isHovering: !e.disabled && u.value
    }), we("div", V8, [we("input", A({
      ref_key: "inputRef",
      ref: p,
      value: l(o),
      "data-input-otp": "",
      "data-input-otp-placeholder-shown": l(o).length === 0 || void 0,
      "data-input-otp-mss": c.value,
      "data-input-otp-mse": f.value,
      "aria-placeholder": e.placeholder,
      style: q.value,
      pattern: i.value?.source
    }, {
      ...M.$attrs,
      ...l(P)
    }, {
      onBeforeinput: S,
      onMouseover: O[0] || (O[0] = (F) => {
        u.value = !0, r("mouseover", F);
      }),
      onMouseleave: O[1] || (O[1] = (F) => {
        u.value = !1, r("mouseleave", F);
      }),
      onPaste: O[2] || (O[2] = (F) => {
        k(F), r("paste", F);
      }),
      onInput: $,
      onFocus: O[3] || (O[3] = (F) => {
        B(), r("focus", F);
      }),
      onBlur: O[4] || (O[4] = (F) => {
        d.value = !1, r("blur", F);
      })
    }), null, 16, F8)])], 6)], 64));
  }
});
var L8 = N8;
function z8() {
  return Cn(h0);
}
const q9 = /* @__PURE__ */ b({
  __name: "InputOTP",
  props: {
    maxlength: {},
    textAlign: {},
    inputmode: {},
    containerClass: {},
    pushPasswordManagerStrategy: {},
    noScriptCssFallback: {},
    defaultValue: {},
    pasteTransformer: { type: Function },
    accept: {},
    alt: {},
    autocomplete: {},
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [Boolean, Array, Set] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {},
    class: {}
  },
  emits: ["complete", "change", "select", "input", "focus", "blur", "mouseover", "mouseleave", "paste"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(L8), A(l(o), {
      "container-class": l(V)("flex items-center gap-2 has-disabled:opacity-50", n.class),
      "data-slot": "input-otp",
      class: "disabled:cursor-not-allowed"
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["container-class"]));
  }
}), T9 = /* @__PURE__ */ b({
  __name: "InputOTPGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), W("div", A({ "data-slot": "input-otp-group" }, l(a), {
      class: l(V)("flex items-center", t.class)
    }), [
      _(r.$slots, "default")
    ], 16));
  }
}), A9 = /* @__PURE__ */ b({
  __name: "InputOTPSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), W("div", A({
      "data-slot": "input-otp-separator",
      role: "separator"
    }, l(n)), [
      _(a.$slots, "default", {}, () => [
        N(l(bf))
      ])
    ], 16));
  }
}), H8 = ["data-active"], U8 = {
  key: 0,
  class: "pointer-events-none absolute inset-0 flex items-center justify-center"
}, I9 = /* @__PURE__ */ b({
  __name: "InputOTPSlot",
  props: {
    index: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), r = z8(), o = E(() => r?.value.slots[t.index]);
    return (s, i) => (h(), W("div", A(l(a), {
      "data-slot": "input-otp-slot",
      "data-active": o.value?.isActive,
      class: l(V)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md aria-invalid:border-destructive data-[active=true]:z-10 data-[active=true]:border-ring data-[active=true]:ring-[3px] data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:border-destructive data-[active=true]:aria-invalid:ring-destructive/20 dark:bg-input/30 dark:data-[active=true]:aria-invalid:ring-destructive/40",
        t.class
      )
    }), [
      Re(Ne(o.value?.char) + " ", 1),
      o.value?.hasFakeCaret ? (h(), W("div", U8, [...i[0] || (i[0] = [
        we("div", { class: "h-4 w-px animate-caret-blink bg-foreground duration-1000" }, null, -1)
      ])])) : Ee("", !0)
    ], 16, H8));
  }
}), O9 = /* @__PURE__ */ b({
  __name: "Item",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" },
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-slot": "item",
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(V)(l(W8)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), R9 = /* @__PURE__ */ b({
  __name: "ItemActions",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-actions",
      class: ae(l(V)("flex items-center gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), V9 = /* @__PURE__ */ b({
  __name: "ItemContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-content",
      class: ae(l(V)("flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), F9 = /* @__PURE__ */ b({
  __name: "ItemDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("p", {
      "data-slot": "item-description",
      class: ae(
        l(V)(
          "line-clamp-2 text-sm leading-normal font-normal text-balance text-muted-foreground",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), N9 = /* @__PURE__ */ b({
  __name: "ItemFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-footer",
      class: ae(l(V)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), L9 = /* @__PURE__ */ b({
  __name: "ItemGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      role: "list",
      "data-slot": "item-group",
      class: ae(l(V)("group/item-group flex flex-col", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), z9 = /* @__PURE__ */ b({
  __name: "ItemHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-header",
      class: ae(l(V)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), j8 = ["data-variant"], H9 = /* @__PURE__ */ b({
  __name: "ItemMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-media",
      "data-variant": t.variant,
      class: ae(l(V)(l(G8)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, j8));
  }
}), U9 = /* @__PURE__ */ b({
  __name: "ItemSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Xi), {
      "data-slot": "item-separator",
      orientation: "horizontal",
      class: ae(l(V)("my-0", t.class))
    }, null, 8, ["class"]));
  }
}), j9 = /* @__PURE__ */ b({
  __name: "ItemTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "item-title",
      class: ae(l(V)("flex w-fit items-center gap-2 text-sm leading-snug font-medium", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), W8 = sn(
  "group/item [a]:hover:bg-accent/50 [a]:transition-colors flex flex-wrap items-center rounded-md border border-transparent text-sm outline-none transition-colors duration-100 focus-visible:border-ring focus-visible:ring-1 focus-visible:ring-ring",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border-border",
        muted: "bg-muted/50"
      },
      size: {
        default: "gap-4 p-4 ",
        sm: "gap-2.5 px-4 py-3"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), G8 = sn(
  "flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:translate-y-0.5 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "size-8 rounded-sm border bg-muted [&_svg:not([class*='size-'])]:size-4",
        image: "size-10 overflow-hidden rounded-sm [&_img]:size-full [&_img]:object-cover"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), W9 = /* @__PURE__ */ b({
  __name: "Kbd",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("kbd", {
      class: ae(
        l(V)(
          "pointer-events-none inline-flex h-5 w-fit min-w-5 items-center justify-center gap-1 rounded-sm bg-muted px-1 font-sans text-xs font-medium text-muted-foreground select-none",
          "[&_svg:not([class*='size-'])]:size-3",
          "[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), G9 = /* @__PURE__ */ b({
  __name: "KbdGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("kbd", {
      "data-slot": "kbd-group",
      class: ae(l(V)("inline-flex items-center gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), K9 = /* @__PURE__ */ b({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(pP), A(l(o), {
      class: l(V)(
        "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), K8 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, Y9 = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(dP), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", K8, [
          N(l(Rg), null, {
            default: y(() => [
              N(l(so), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), X9 = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    sideFlip: { type: Boolean },
    align: { default: "start" },
    alignOffset: { default: -4 },
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Vg), null, {
      default: y(() => [
        N(l(yP), A(l(a), {
          class: l(V)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), J9 = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(_P), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Z9 = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(xP), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Q9 = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l($P), {
      class: ae(l(V)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ej = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(hP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tj = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(DP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Y8 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, nj = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(MP), A(l(o), {
      class: l(V)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: y(() => [
        we("span", Y8, [
          N(l(Rg), null, {
            default: y(() => [
              N(l(gf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), aj = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(qP), A({
      class: l(V)("-mx-1 my-1 h-px bg-muted", t.class)
    }, l(a)), null, 16, ["class"]));
  }
}), rj = /* @__PURE__ */ b({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("span", {
      class: ae(l(V)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), oj = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(AP), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sj = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(Vg), null, {
      default: y(() => [
        N(l(OP), A(l(o), {
          class: l(V)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), lj = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(VP), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(za), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ij = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(NP), A(l(a), {
      class: l(V)(
        "flex cursor-default items-center rounded-sm px-3 py-1 text-sm font-medium outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), X8 = { class: "absolute top-full left-0 flex justify-center" }, J8 = /* @__PURE__ */ b({
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    align: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), W("div", X8, [
      N(l(uM), A(l(a), {
        class: l(V)(
          "origin-top-center relative left-[var(--reka-navigation-menu-viewport-left)] mt-1.5 h-[--reka-navigation-menu-viewport-height] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:zoom-in-90 md:w-[--reka-navigation-menu-viewport-width]",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), uj = /* @__PURE__ */ b({
  __name: "NavigationMenu",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    orientation: {},
    delayDuration: {},
    skipDelayDuration: {},
    disableClickTrigger: { type: Boolean },
    disableHoverTrigger: { type: Boolean },
    disablePointerLeaveClose: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(HP), A(l(o), {
      class: l(V)("relative z-10 flex max-w-max flex-1 items-center justify-center", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default"),
        N(J8)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dj = /* @__PURE__ */ b({
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(ZP), A(l(o), {
      class: l(V)(
        "top-0 left-0 w-full data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 data-[motion^=from-]:animate-in data-[motion^=from-]:fade-in data-[motion^=to-]:animate-out data-[motion^=to-]:fade-out md:absolute md:w-auto",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cj = /* @__PURE__ */ b({
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(eM), A(l(a), {
      class: l(V)(
        "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:animate-in data-[state=visible]:fade-in",
        t.class
      )
    }), {
      default: y(() => [...o[0] || (o[0] = [
        we("div", { class: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" }, null, -1)
      ])]),
      _: 1
    }, 16, ["class"]));
  }
}), fj = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(KP), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pj = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(nM), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vj = /* @__PURE__ */ b({
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(rM), A(l(a), {
      class: l(V)("group flex flex-1 list-none items-center justify-center gap-x-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), mj = /* @__PURE__ */ b({
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(lM), A(l(a), {
      class: l(V)(l(Z8)(), "group", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(Ki), {
          class: "relative top-px ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180",
          "aria-hidden": "true"
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Z8 = sn(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
), hj = /* @__PURE__ */ b({
  __name: "NumberField",
  props: {
    defaultValue: {},
    modelValue: {},
    min: {},
    max: {},
    step: {},
    stepSnapping: { type: Boolean },
    formatOptions: {},
    locale: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    disableWheelChange: { type: Boolean },
    invertWheelChange: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(_M), A(l(o), {
      class: l(V)("grid gap-1.5", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), gj = /* @__PURE__ */ b({
  __name: "NumberFieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      class: ae(
        l(V)(
          "relative [&>[data-slot=input]]:has-[[data-slot=decrement]]:pl-5 [&>[data-slot=input]]:has-[[data-slot=increment]]:pr-5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), yj = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(xM), A({ "data-slot": "decrement" }, l(a), {
      class: l(V)(
        "absolute top-1/2 left-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(bf), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), bj = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(SM), A({ "data-slot": "increment" }, l(a), {
      class: l(V)(
        "absolute top-1/2 right-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(UI), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _j = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(kM), {
      "data-slot": "input",
      class: ae(
        l(V)(
          "flex h-9 w-full rounded-md border border-input bg-transparent py-1 text-center text-sm shadow-sm transition-colors placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), wj = /* @__PURE__ */ b({
  __name: "Pagination",
  props: {
    page: {},
    defaultPage: {},
    itemsPerPage: {},
    total: {},
    siblingCount: {},
    disabled: { type: Boolean },
    showEdges: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(EM), A({ "data-slot": "pagination" }, l(o), {
      class: l(V)("mx-auto flex w-full justify-center", n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), xj = /* @__PURE__ */ b({
  __name: "PaginationContent",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(FM), A({ "data-slot": "pagination-content" }, l(n), {
      class: l(V)("flex flex-row items-center gap-1", t.class)
    }), {
      default: y((o) => [
        _(a.$slots, "default", oe(le(o)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Cj = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(DM), A({ "data-slot": "pagination-ellipsis" }, l(n), {
      class: l(V)("flex size-9 items-center justify-center", t.class)
    }), {
      default: y(() => [
        _(a.$slots, "default", {}, () => [
          N(l(rb), { class: "size-4" }),
          r[0] || (r[0] = we("span", { class: "sr-only" }, "More pages", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Sj = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(TM), A({
      "data-slot": "pagination-first",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Yi)),
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "First", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $j = /* @__PURE__ */ b({
  __name: "PaginationItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {},
    size: { default: "icon" },
    class: {},
    isActive: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size", "isActive");
    return (a, r) => (h(), x(l(LM), A({ "data-slot": "pagination-item" }, l(n), {
      class: l(V)(
        l(Yt)({
          variant: e.isActive ? "outline" : "ghost",
          size: e.size
        }),
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kj = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(IM), A({
      "data-slot": "pagination-last",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Last", -1)),
          N(l(za))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Bj = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(HM), A({
      "data-slot": "pagination-next",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Next", -1)),
          N(l(za))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Dj = /* @__PURE__ */ b({
  __name: "PaginationPrevious",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), x(l(jM), A({
      "data-slot": "pagination-previous",
      class: l(V)(l(Yt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Yi)),
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Previous", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Pj = /* @__PURE__ */ b({
  __name: "PinInput",
  props: {
    modelValue: { default: () => [] },
    defaultValue: {},
    placeholder: {},
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: {},
    dir: {},
    disabled: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(YM), A(l(o), {
      class: l(V)("flex items-center gap-2", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Mj = /* @__PURE__ */ b({
  __name: "PinInputGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(X), A(l(a), {
      class: l(V)("flex items-center", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Ej = /* @__PURE__ */ b({
  __name: "PinInputSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), x(l(X), oe(le(l(n))), {
      default: y(() => [
        _(a.$slots, "default", {}, () => [
          N(l(bf), { class: "w-2" })
        ])
      ]),
      _: 3
    }, 16));
  }
}), qj = /* @__PURE__ */ b({
  __name: "PinInputSlot",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(JM), A(l(a), {
      class: l(V)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-center text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md focus:relative focus:z-10 focus:ring-2 focus:ring-ring focus:outline-none",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), Tj = /* @__PURE__ */ b({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(qB), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Aj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(zB), null, {
      default: y(() => [
        N(l(NB), A({ ...l(o), ...s.$attrs }, {
          class: l(V)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Ij = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(UB), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Oj = /* @__PURE__ */ b({
  __name: "Progress",
  props: {
    modelValue: { default: 0 },
    max: {},
    getValueLabel: {},
    getValueText: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(aE), A(l(n), {
      class: l(V)("relative h-2 w-full overflow-hidden rounded-full bg-primary/20", t.class)
    }), {
      default: y(() => [
        N(l(oE), {
          class: "h-full w-full flex-1 bg-primary transition-all",
          style: dt(`transform: translateX(-${100 - (t.modelValue ?? 0)}%);`)
        }, null, 8, ["style"])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Rj = /* @__PURE__ */ b({
  __name: "RadioGroup",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(pE), A({
      class: l(V)("grid gap-2", n.class)
    }, l(o)), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Vj = /* @__PURE__ */ b({
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(gE), A(l(a), {
      class: l(V)(
        "peer aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        N(l(bE), { class: "flex items-center justify-center" }, {
          default: y(() => [
            N(l(so), { class: "h-3.5 w-3.5 text-primary" })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Q8 = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, Fj = /* @__PURE__ */ b({
  __name: "RangeCalendar",
  props: {
    defaultPlaceholder: {},
    defaultValue: {},
    modelValue: {},
    placeholder: {},
    allowNonContiguousRanges: { type: Boolean },
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    maximumDays: {},
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    isDateHighlightable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    disableDaysOutsideCurrentView: { type: Boolean },
    fixedDate: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:validModelValue", "update:placeholder", "update:startValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(XB), A({
      class: l(V)("p-3", n.class)
    }, l(o)), {
      default: y(({ grid: u, weekDays: d }) => [
        N(l(sH), null, {
          default: y(() => [
            N(l(uH)),
            N(l(lH)),
            N(l(iH))
          ]),
          _: 1
        }),
        we("div", Q8, [
          (h(!0), W(Ke, null, Lt(u, (c) => (h(), x(l(nH), {
            key: c.value.toString()
          }, {
            default: y(() => [
              N(l(rH), null, {
                default: y(() => [
                  N(l(th), null, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Lt(d, (f) => (h(), x(l(oH), { key: f }, {
                        default: y(() => [
                          Re(Ne(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(aH), null, {
                default: y(() => [
                  (h(!0), W(Ke, null, Lt(c.rows, (f, p) => (h(), x(l(th), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: y(() => [
                      (h(!0), W(Ke, null, Lt(f, (v) => (h(), x(l(eH), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: y(() => [
                          N(l(tH), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), eH = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(ZB), A({
      class: l(V)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:bg-accent first:[&:has([data-selected])]:rounded-l-md last:[&:has([data-selected])]:rounded-r-md [&:has([data-selected][data-outside-view])]:bg-accent/50 [&:has([data-selected][data-selection-end])]:rounded-r-md [&:has([data-selected][data-selection-start])]:rounded-l-md",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), tH = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(eD), A({
      class: l(V)(
        l(Yt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal data-[selected]:opacity-100",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selection Start
        "data-[selection-start]:bg-primary data-[selection-start]:text-primary-foreground data-[selection-start]:hover:bg-primary data-[selection-start]:hover:text-primary-foreground data-[selection-start]:focus:bg-primary data-[selection-start]:focus:text-primary-foreground",
        // Selection End
        "data-[selection-end]:bg-primary data-[selection-end]:text-primary-foreground data-[selection-end]:hover:bg-primary data-[selection-end]:hover:text-primary-foreground data-[selection-end]:focus:bg-primary data-[selection-end]:focus:text-primary-foreground",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), nH = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(nD), A({
      class: l(V)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), aH = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(rD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), rH = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(sD), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), th = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(iD), A({
      class: l(V)("flex", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), oH = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(dD), A({
      class: l(V)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sH = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(fD), A({
      class: l(V)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lH = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(vD), A({
      class: l(V)("text-sm font-medium", t.class)
    }, l(a)), {
      default: y(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(Ne(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), iH = /* @__PURE__ */ b({
  __name: "RangeCalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(hD), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(za), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uH = /* @__PURE__ */ b({
  __name: "RangeCalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(yD), A({
      class: l(V)(
        l(Yt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Yi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), dH = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, Nj = /* @__PURE__ */ b({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    nonce: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(UT), A(l(o), {
      class: l(V)(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 focus-visible:outline-none [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:translate-x-0 [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]>div]:rotate-90",
        n.class
      )
    }), {
      default: y(() => [
        n.withHandle ? (h(), W("div", dH, [
          N(l(zI), { class: "h-2.5 w-2.5" })
        ])) : Ee("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Lj = /* @__PURE__ */ b({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(NT), A(l(o), {
      class: l(V)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cH = /* @__PURE__ */ b({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(NE), A(l(n), {
      class: l(V)(
        "flex touch-none transition-colors select-none",
        e.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        e.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        t.class
      )
    }), {
      default: y(() => [
        N(l(jE), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), zj = /* @__PURE__ */ b({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(xE), A(l(n), {
      class: l(V)("relative overflow-hidden", t.class)
    }), {
      default: y(() => [
        N(l(GE), { class: "h-full w-full rounded-[inherit]" }, {
          default: y(() => [
            _(a.$slots, "default")
          ]),
          _: 3
        }),
        N(cH),
        N(l(kE))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Hj = /* @__PURE__ */ b({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    by: { type: [String, Function] },
    dir: {},
    multiple: { type: Boolean },
    autocomplete: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(QE), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Uj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(Mq), null, {
      default: y(() => [
        N(l(vq), A({ ...l(o), ...s.$attrs }, {
          class: l(V)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            e.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: y(() => [
            N(l(vH)),
            N(l(Hq), {
              class: ae(
                l(V)(
                  "p-1",
                  e.position === "popper" && "h-[--reka-select-trigger-height] w-full min-w-[--reka-select-trigger-width]"
                )
              )
            }, {
              default: y(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(pH))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), jj = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(yq), A({
      class: l(V)("w-full p-1", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fH = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, Wj = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Cq), A(l(a), {
      class: l(V)(
        "relative flex w-full cursor-default items-center rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        t.class
      )
    }), {
      default: y(() => [
        we("span", fH, [
          N(l($q), null, {
            default: y(() => [
              N(l(so), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        N(l(Qg), null, {
          default: y(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Gj = /* @__PURE__ */ b({
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Qg), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Kj = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Dq), {
      class: ae(l(V)("px-2 py-1.5 text-sm font-semibold", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), pH = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Tq), A(l(a), {
      class: l(V)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Ki))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), vH = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Iq), A(l(a), {
      class: l(V)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(LI))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Yj = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Rq), A(l(n), {
      class: l(V)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), Xj = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(Fq), A(l(a), {
      class: l(V)(
        "flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-start text-sm whitespace-nowrap shadow-sm ring-offset-background focus:ring-1 focus:ring-ring focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[placeholder]:text-muted-foreground [&>span]:truncate",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default"),
        N(l(_q), { "as-child": "" }, {
          default: y(() => [
            N(l(Ki), { class: "h-4 w-4 shrink-0 opacity-50" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Jj = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Lq), oe(le(t)), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mH = /* @__PURE__ */ b({
  __name: "Sheet",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(xi), A({ "data-slot": "sheet" }, l(r)), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), Zj = /* @__PURE__ */ b({
  __name: "SheetClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Va), A({ "data-slot": "sheet-close" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hH = /* @__PURE__ */ b({
  __name: "SheetOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(gs), A({
      "data-slot": "sheet-overlay",
      class: l(V)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), gH = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SheetContent",
  props: {
    class: {},
    side: { default: "right" },
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "side"), o = me(r, a);
    return (s, i) => (h(), x(l($i), null, {
      default: y(() => [
        N(hH),
        N(l(hs), A({
          "data-slot": "sheet-content",
          class: l(V)(
            "fixed z-50 flex flex-col gap-4 bg-background shadow-lg transition ease-in-out data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:animate-in data-[state=open]:duration-500",
            e.side === "right" && "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
            e.side === "left" && "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
            e.side === "top" && "inset-x-0 top-0 h-auto border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
            e.side === "bottom" && "inset-x-0 bottom-0 h-auto border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
            n.class
          )
        }, { ...s.$attrs, ...l(o) }), {
          default: y(() => [
            _(s.$slots, "default"),
            N(l(Va), { class: "absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none data-[state=open]:bg-secondary" }, {
              default: y(() => [
                N(l(lo), { class: "size-4" }),
                i[0] || (i[0] = we("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), Qj = /* @__PURE__ */ b({
  __name: "SheetDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(Si), A({
      "data-slot": "sheet-description",
      class: l(V)("text-sm text-muted-foreground", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), eW = /* @__PURE__ */ b({
  __name: "SheetFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "sheet-footer",
      class: ae(l(V)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), tW = /* @__PURE__ */ b({
  __name: "SheetHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "sheet-header",
      class: ae(l(V)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), nW = /* @__PURE__ */ b({
  __name: "SheetTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(ki), A({
      "data-slot": "sheet-title",
      class: l(V)("font-semibold text-foreground", t.class)
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), aW = /* @__PURE__ */ b({
  __name: "SheetTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Bi), A({ "data-slot": "sheet-trigger" }, t), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nh = "sidebar_state", yH = 3600 * 24 * 7, bH = "16rem", _H = "18rem", wH = "3rem", xH = "b", [hu, CH] = Se("Sidebar"), SH = { class: "flex h-full w-full flex-col" }, $H = ["data-state", "data-collapsible", "data-variant", "data-side"], kH = {
  "data-sidebar": "sidebar",
  class: "flex h-full w-full flex-col bg-sidebar text-sidebar-foreground group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
}, rW = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "Sidebar",
  props: {
    side: { default: "left" },
    variant: { default: "sidebar" },
    collapsible: { default: "offcanvas" },
    class: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a, openMobile: r, setOpenMobile: o } = hu();
    return (s, i) => e.collapsible === "none" ? (h(), W("div", A({
      key: 0,
      class: l(V)("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", t.class)
    }, s.$attrs), [
      _(s.$slots, "default")
    ], 16)) : l(n) ? (h(), x(l(mH), A({
      key: 1,
      open: l(r)
    }, s.$attrs, { "onUpdate:open": l(o) }), {
      default: y(() => [
        N(l(gH), {
          "data-sidebar": "sidebar",
          "data-mobile": "true",
          side: e.side,
          class: "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
          style: dt({
            "--sidebar-width": l(_H)
          })
        }, {
          default: y(() => [
            we("div", SH, [
              _(s.$slots, "default")
            ])
          ]),
          _: 3
        }, 8, ["side", "style"])
      ]),
      _: 3
    }, 16, ["open", "onUpdate:open"])) : (h(), W("div", {
      key: 2,
      class: "group peer hidden md:block",
      "data-state": l(a),
      "data-collapsible": l(a) === "collapsed" ? e.collapsible : "",
      "data-variant": e.variant,
      "data-side": e.side
    }, [
      we("div", {
        class: ae(
          l(V)(
            "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            e.variant === "floating" || e.variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )
        )
      }, null, 2),
      we("div", A({
        class: l(V)(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          e.side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          e.variant === "floating" || e.variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+_2px)]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          t.class
        )
      }, s.$attrs), [
        we("div", kH, [
          _(s.$slots, "default")
        ])
      ], 16)
    ], 8, $H));
  }
}), oW = /* @__PURE__ */ b({
  __name: "SidebarContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "content",
      class: ae(
        l(V)(
          "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), sW = /* @__PURE__ */ b({
  __name: "SidebarFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "footer",
      class: ae(l(V)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), lW = /* @__PURE__ */ b({
  __name: "SidebarGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "group",
      class: ae(l(V)("relative flex w-full min-w-0 flex-col p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), iW = /* @__PURE__ */ b({
  __name: "SidebarGroupAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "group-action",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(V)(
          "absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), uW = /* @__PURE__ */ b({
  __name: "SidebarGroupContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "group-content",
      class: ae(l(V)("w-full text-sm", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), dW = /* @__PURE__ */ b({
  __name: "SidebarGroupLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "group-label",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(V)(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear outline-none focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), cW = /* @__PURE__ */ b({
  __name: "SidebarHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "header",
      class: ae(l(V)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), fW = /* @__PURE__ */ b({
  __name: "SidebarInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(p0), {
      "data-sidebar": "input",
      class: ae(
        l(V)(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), pW = /* @__PURE__ */ b({
  __name: "SidebarInset",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("main", {
      class: ae(
        l(V)(
          "relative flex min-h-svh flex-1 flex-col bg-background",
          "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), vW = /* @__PURE__ */ b({
  __name: "SidebarMenu",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("ul", {
      "data-sidebar": "menu",
      class: ae(l(V)("flex w-full min-w-0 flex-col gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), mW = /* @__PURE__ */ b({
  __name: "SidebarMenuAction",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" },
    showOnHover: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "menu-action",
      class: ae(
        l(V)(
          "absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          e.showOnHover && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground data-[state=open]:opacity-100 md:opacity-0",
          t.class
        )
      ),
      as: e.as,
      "as-child": e.asChild
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "as", "as-child"]));
  }
}), hW = /* @__PURE__ */ b({
  __name: "SidebarMenuBadge",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(V)(
          "pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium text-sidebar-foreground tabular-nums select-none",
          "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), ah = /* @__PURE__ */ b({
  __name: "SidebarMenuButtonChild",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), A({
      "data-sidebar": "menu-button",
      "data-size": e.size,
      "data-active": e.isActive,
      class: l(V)(l(PH)({ variant: e.variant, size: e.size }), t.class),
      as: e.as,
      "as-child": e.asChild
    }, n.$attrs), {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-size", "data-active", "class", "as", "as-child"]));
  }
}), gW = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SidebarMenuButton",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    tooltip: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a } = hu(), r = Z(t, "tooltip");
    return (o, s) => e.tooltip ? (h(), x(l(_f), { key: 1 }, {
      default: y(() => [
        N(l(xf), { "as-child": "" }, {
          default: y(() => [
            N(ah, oe(le({ ...l(r), ...o.$attrs })), {
              default: y(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }),
        N(l(wf), {
          side: "right",
          align: "center",
          hidden: l(a) !== "collapsed" || l(n)
        }, {
          default: y(() => [
            typeof e.tooltip == "string" ? (h(), W(Ke, { key: 0 }, [
              Re(Ne(e.tooltip), 1)
            ], 64)) : (h(), x(Pt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        }, 8, ["hidden"])
      ]),
      _: 3
    })) : (h(), x(ah, oe(A({ key: 0 }, { ...l(r), ...o.$attrs })), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yW = /* @__PURE__ */ b({
  __name: "SidebarMenuItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("li", {
      "data-sidebar": "menu-item",
      class: ae(l(V)("group/menu-item relative", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), rh = /* @__PURE__ */ b({
  __name: "Skeleton",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", {
      "data-slot": "skeleton",
      class: ae(l(V)("animate-pulse rounded-md bg-primary/10", t.class))
    }, null, 2));
  }
}), bW = /* @__PURE__ */ b({
  __name: "SidebarMenuSkeleton",
  props: {
    showIcon: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = E(() => `${Math.floor(Math.random() * 40) + 50}%`);
    return (a, r) => (h(), W("div", {
      "data-sidebar": "menu-skeleton",
      class: ae(l(V)("flex h-8 items-center gap-2 rounded-md px-2", t.class))
    }, [
      e.showIcon ? (h(), x(l(rh), {
        key: 0,
        class: "size-4 rounded-md",
        "data-sidebar": "menu-skeleton-icon"
      })) : Ee("", !0),
      N(l(rh), {
        class: "h-4 max-w-[--skeleton-width] flex-1",
        "data-sidebar": "menu-skeleton-text",
        style: dt({ "--skeleton-width": n.value })
      }, null, 8, ["style"])
    ], 2));
  }
}), _W = /* @__PURE__ */ b({
  __name: "SidebarMenuSub",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("ul", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(V)(
          "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), wW = /* @__PURE__ */ b({
  __name: "SidebarMenuSubButton",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    size: { default: "md" },
    isActive: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(X), {
      "data-sidebar": "menu-sub-button",
      as: e.as,
      "as-child": e.asChild,
      "data-size": e.size,
      "data-active": e.isActive,
      class: ae(
        l(V)(
          "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground ring-sidebar-ring outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
          "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
          e.size === "sm" && "text-xs",
          e.size === "md" && "text-sm",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-size", "data-active", "class"]));
  }
}), BH = {};
function DH(e, t) {
  return h(), W("li", null, [
    _(e.$slots, "default")
  ]);
}
const xW = /* @__PURE__ */ vr(BH, [["render", DH]]), CW = /* @__PURE__ */ b({
  __name: "SidebarProvider",
  props: {
    defaultOpen: { type: Boolean, default: !Xy?.cookie.includes(`${nh}=false`) },
    open: { type: Boolean, default: void 0 },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = zl("(max-width: 768px)"), o = I(!1), s = /* @__PURE__ */ Gi(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, document.cookie = `${nh}=${s.value}; path=/; max-age=${yH}`;
    }
    function u(f) {
      o.value = f;
    }
    function d() {
      return r.value ? u(!o.value) : i(!s.value);
    }
    Ar("keydown", (f) => {
      f.key === xH && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = E(() => s.value ? "expanded" : "collapsed");
    return CH({
      state: c,
      open: s,
      setOpen: i,
      isMobile: r,
      openMobile: o,
      setOpenMobile: u,
      toggleSidebar: d
    }), (f, p) => (h(), x(l(vf), { "delay-duration": 0 }, {
      default: y(() => [
        we("div", A({
          style: {
            "--sidebar-width": l(bH),
            "--sidebar-width-icon": l(wH)
          },
          class: l(V)(
            "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
            n.class
          )
        }, f.$attrs), [
          _(f.$slots, "default")
        ], 16)
      ]),
      _: 3
    }));
  }
}), SW = /* @__PURE__ */ b({
  __name: "SidebarRail",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = hu();
    return (a, r) => (h(), W("button", {
      "data-sidebar": "rail",
      "aria-label": "Toggle Sidebar",
      tabindex: -1,
      title: "Toggle Sidebar",
      class: ae(
        l(V)(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          t.class
        )
      ),
      onClick: r[0] || (r[0] = //@ts-ignore
      (...o) => l(n) && l(n)(...o))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), $W = /* @__PURE__ */ b({
  __name: "SidebarSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(Xi), {
      "data-sidebar": "separator",
      class: ae(l(V)("mx-2 w-auto bg-sidebar-border", t.class))
    }, {
      default: y(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), kW = /* @__PURE__ */ b({
  __name: "SidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = hu();
    return (a, r) => (h(), x(l(Ss), {
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: ae(l(V)("h-7 w-7", t.class)),
      onClick: l(n)
    }, {
      default: y(() => [
        N(l(lb)),
        r[0] || (r[0] = we("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"]));
  }
}), PH = sn(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), BW = /* @__PURE__ */ b({
  __name: "Slider",
  props: {
    defaultValue: {},
    modelValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    inverted: { type: Boolean },
    min: {},
    max: {},
    step: {},
    minStepsBetweenThumbs: {},
    thumbAlignment: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(lT), A({
      class: l(V)(
        "relative flex w-full touch-none items-center select-none data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5 data-[orientation=vertical]:flex-col",
        n.class
      )
    }, l(o)), {
      default: y(() => [
        N(l(hT), { class: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20 data-[orientation=vertical]:w-1.5" }, {
          default: y(() => [
            N(l(dT), { class: "absolute h-full bg-primary data-[orientation=vertical]:w-full" })
          ]),
          _: 1
        }),
        (h(!0), W(Ke, null, Lt(e.modelValue, (u, d) => (h(), x(l(vT), {
          key: d,
          class: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50"
        }))), 128))
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), DW = /* @__PURE__ */ b({
  __name: "Sonner",
  props: {
    id: {},
    invert: { type: Boolean },
    theme: {},
    position: {},
    closeButtonPosition: {},
    hotkey: {},
    richColors: { type: Boolean },
    expand: { type: Boolean },
    duration: {},
    gap: {},
    visibleToasts: {},
    closeButton: { type: Boolean },
    toastOptions: {},
    class: {},
    style: {},
    offset: {},
    mobileOffset: {},
    dir: {},
    swipeDirections: {},
    icons: {},
    containerAriaLabel: {}
  },
  setup(e) {
    const n = Z(e, "toastOptions");
    return (a, r) => (h(), x(l(fb), A({
      class: "toaster group",
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, l(n)), {
      "success-icon": y(() => [
        N(l(ab), { class: "size-4" })
      ]),
      "info-icon": y(() => [
        N(l(ob), { class: "size-4" })
      ]),
      "warning-icon": y(() => [
        N(l(ib), { class: "size-4" })
      ]),
      "error-icon": y(() => [
        N(l(sb), { class: "size-4" })
      ]),
      "loading-icon": y(() => [
        we("div", null, [
          N(l(yf), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": y(() => [
        N(l(lo), { class: "size-4" })
      ]),
      _: 1
    }, 16));
  }
}), PW = /* @__PURE__ */ b({
  __name: "Spinner",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), x(l(yf), {
      role: "status",
      "aria-label": "Loading",
      class: ae(l(V)("size-4 animate-spin", t.class))
    }, null, 8, ["class"]));
  }
}), MW = /* @__PURE__ */ b({
  __name: "Stepper",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    modelValue: {},
    linear: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(KT), A({
      class: l(V)("flex gap-2", n.class)
    }, l(o)), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), EW = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(QT), A(l(a), {
      class: l(V)("text-xs text-muted-foreground", t.class)
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), qW = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(tA), A(l(a), {
      class: l(V)(
        "inline-flex h-8 w-8 items-center justify-center rounded-full text-muted-foreground/50",
        // Disabled
        "group-data-[disabled]:text-muted-foreground group-data-[disabled]:opacity-50",
        // Active
        "group-data-[state=active]:bg-primary group-data-[state=active]:text-primary-foreground",
        // Completed
        "group-data-[state=completed]:bg-accent group-data-[state=completed]:text-accent-foreground",
        t.class
      )
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), TW = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {},
    disabled: { type: Boolean },
    completed: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(JT), A(l(a), {
      class: l(V)("group flex items-center gap-2 data-[disabled]:pointer-events-none", t.class)
    }), {
      default: y((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), AW = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(aA), A(l(a), {
      class: l(V)(
        "bg-muted",
        // Disabled
        "group-data-[disabled]:bg-muted group-data-[disabled]:opacity-50",
        // Completed
        "group-data-[state=completed]:bg-accent-foreground",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), IW = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(oA), A(l(a), {
      class: l(V)("text-md font-semibold whitespace-nowrap", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), OW = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(lA), A(l(a), {
      class: l(V)("flex flex-col items-center gap-1 rounded-md p-1 text-center", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), RW = /* @__PURE__ */ b({
  __name: "Switch",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean },
    id: {},
    value: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(cA), A(l(o), {
      class: l(V)(
        "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
        n.class
      )
    }), {
      default: y(() => [
        N(l(pA), {
          class: ae(
            l(V)(
              "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
            )
          )
        }, {
          default: y(() => [
            _(s.$slots, "thumb")
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), MH = { class: "relative w-full overflow-auto" }, VW = /* @__PURE__ */ b({
  __name: "Table",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("div", MH, [
      we("table", {
        class: ae(l(V)("w-full caption-bottom text-sm", t.class))
      }, [
        _(n.$slots, "default")
      ], 2)
    ]));
  }
}), FW = /* @__PURE__ */ b({
  __name: "TableBody",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("tbody", {
      class: ae(l(V)("[&_tr:last-child]:border-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), EH = /* @__PURE__ */ b({
  __name: "TableCell",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("td", {
      class: ae(
        l(V)(
          "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), NW = /* @__PURE__ */ b({
  __name: "TableHead",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("th", {
      class: ae(
        l(V)(
          "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), LW = /* @__PURE__ */ b({
  __name: "TableHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("thead", {
      class: ae(l(V)("[&_tr]:border-b", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), zW = /* @__PURE__ */ b({
  __name: "TableFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("tfoot", {
      class: ae(l(V)("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), qH = /* @__PURE__ */ b({
  __name: "TableRow",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("tr", {
      class: ae(
        l(V)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", t.class)
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), HW = /* @__PURE__ */ b({
  __name: "TableCaption",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), W("caption", {
      class: ae(l(V)("mt-4 text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), TH = { class: "flex items-center justify-center py-10" }, UW = /* @__PURE__ */ b({
  __name: "TableEmpty",
  props: {
    class: {},
    colspan: { default: 1 }
  },
  setup(e) {
    const t = e, n = E(() => {
      const { class: a, ...r } = t;
      return r;
    });
    return (a, r) => (h(), x(qH, null, {
      default: y(() => [
        N(EH, A({
          class: l(V)("p-4 align-middle text-sm whitespace-nowrap text-foreground", t.class)
        }, n.value), {
          default: y(() => [
            we("div", TH, [
              _(a.$slots, "default")
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), jW = /* @__PURE__ */ b({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = me(e, t);
    return (o, s) => (h(), x(l(hA), oe(le(l(r))), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), WW = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(yA), A({
      class: l(V)(
        "mt-2 ring-offset-background focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none",
        t.class
      )
    }, l(n)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), GW = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), x(l(_A), A(l(n), {
      class: l(V)(
        "inline-flex items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
        t.class
      )
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), AH = { class: "truncate" }, KW = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(xA), A(l(a), {
      class: l(V)(
        "inline-flex items-center justify-center rounded-md px-3 py-1 text-sm font-medium whitespace-nowrap ring-offset-background transition-all focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
        t.class
      )
    }), {
      default: y(() => [
        we("span", AH, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), YW = /* @__PURE__ */ b({
  __name: "TagsInput",
  props: {
    modelValue: {},
    defaultValue: {},
    addOnPaste: { type: Boolean },
    addOnTab: { type: Boolean },
    addOnBlur: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: {},
    dir: {},
    max: {},
    id: {},
    convertValue: { type: Function },
    displayValue: { type: Function },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "invalid", "addTag", "removeTag"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l($A), A(l(o), {
      class: l(V)(
        "flex flex-wrap items-center gap-2 rounded-md border border-input bg-background px-3 py-1.5 text-sm",
        n.class
      )
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), XW = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(BA), A(l(a), {
      class: l(V)("min-h-5 flex-1 bg-transparent px-1 text-sm focus:outline-none", t.class)
    }), null, 16, ["class"]));
  }
}), JW = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(MA), A(l(a), {
      class: l(V)(
        "flex h-5 items-center rounded-md bg-secondary ring-offset-background data-[state=active]:ring-2 data-[state=active]:ring-ring data-[state=active]:ring-offset-2",
        t.class
      )
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ZW = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(qA), A(l(a), {
      class: l(V)("mr-1 flex rounded bg-transparent", t.class)
    }), {
      default: y(() => [
        _(r.$slots, "default", {}, () => [
          N(l(lo), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), QW = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), x(l(AA), A(l(a), {
      class: l(V)("rounded bg-transparent px-2 py-0.5 text-sm", t.class)
    }), null, 16, ["class"]));
  }
}), eG = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "size", "variant"), o = me(r, a);
    return (s, i) => (h(), x(l(My), A(l(o), {
      class: l(V)(l(y0)({ variant: e.variant, size: e.size }), n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), y0 = sn(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 min-w-9 px-2",
        sm: "h-8 min-w-8 px-1.5",
        lg: "h-10 min-w-10 px-2.5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), tG = /* @__PURE__ */ b({
  __name: "ToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {},
    class: {},
    variant: {},
    size: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    Xn("toggleGroup", {
      variant: n.variant,
      size: n.size
    });
    const r = Z(n, "class"), o = me(r, a);
    return (s, i) => (h(), x(l(RA), A(l(o), {
      class: l(V)("flex items-center justify-center gap-1", n.class)
    }), {
      default: y((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), nG = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e, n = Cn("toggleGroup"), a = Z(t, "class", "size", "variant"), r = he(a);
    return (o, s) => (h(), x(l(NA), A(l(r), {
      class: l(V)(
        l(y0)({
          variant: l(n)?.variant || e.variant,
          size: l(n)?.size || e.size
        }),
        t.class
      )
    }), {
      default: y((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
export {
  p7 as Accord,
  n3 as Accordion,
  a3 as AccordionContent,
  r3 as AccordionItem,
  o3 as AccordionTrigger,
  v7 as Alert,
  m7 as AlertDescription,
  lI as AlertDialog,
  iI as AlertDialogAction,
  uI as AlertDialogCancel,
  dI as AlertDialogContent,
  cI as AlertDialogDescription,
  fI as AlertDialogFooter,
  pI as AlertDialogHeader,
  vI as AlertDialogTitle,
  KH as AlertDialogTrigger,
  h7 as AlertTitle,
  g7 as AspectRatio,
  y7 as Avatar,
  b7 as AvatarFallback,
  _7 as AvatarImage,
  w7 as Badge,
  x7 as Breadcrumb,
  C7 as BreadcrumbEllipsis,
  S7 as BreadcrumbItem,
  $7 as BreadcrumbLink,
  k7 as BreadcrumbList,
  B7 as BreadcrumbPage,
  D7 as BreadcrumbSeparator,
  Ss as Button,
  P7 as ButtonGroup,
  M7 as ButtonGroupSeparator,
  E7 as ButtonGroupText,
  KI as COLLAPSIBLE_SIDEBAR_WIDTH,
  YI as COLLAPSIBLE_SIDEBAR_WIDTH_ICON,
  a7 as COLLAPSIBLE_SIDEBAR_WIDTH_MOBILE,
  q7 as Calendar,
  f3 as CalendarCell,
  p3 as CalendarCellTrigger,
  v3 as CalendarGrid,
  m3 as CalendarGridBody,
  h3 as CalendarGridHead,
  Pv as CalendarGridRow,
  g3 as CalendarHeadCell,
  y3 as CalendarHeader,
  b3 as CalendarHeading,
  _3 as CalendarNextButton,
  w3 as CalendarPrevButton,
  x3 as Card,
  C3 as CardContent,
  T7 as CardDescription,
  A7 as CardFooter,
  S3 as CardHeader,
  $3 as CardTitle,
  I7 as Carousel,
  O7 as CarouselContent,
  R7 as CarouselItem,
  F7 as CarouselNext,
  V7 as CarouselPrevious,
  N7 as ChartCrosshair,
  L7 as ChartLegend,
  z7 as ChartSingleTooltip,
  ac as ChartTooltip,
  U7 as Checkbox,
  j7 as Collapsible,
  W7 as CollapsibleContent,
  s7 as CollapsibleMain,
  u7 as CollapsibleMenuButton,
  d7 as CollapsibleMenuGroup,
  o7 as CollapsibleSidebarDesktop,
  l7 as CollapsibleSidebarTrigger,
  G7 as CollapsibleTrigger,
  r7 as CollapsibleTwoColumnLayout,
  K7 as Combobox,
  Y7 as ComboboxAnchor,
  VH as ComboboxCancel,
  X7 as ComboboxEmpty,
  J7 as ComboboxGroup,
  Z7 as ComboboxInput,
  Q7 as ComboboxItem,
  FH as ComboboxItemIndicator,
  eU as ComboboxList,
  tU as ComboboxSeparator,
  NH as ComboboxTrigger,
  $4 as Command,
  uU as CommandDialog,
  dU as CommandEmpty,
  cU as CommandGroup,
  fU as CommandInput,
  pU as CommandItem,
  vU as CommandList,
  mU as CommandSeparator,
  hU as CommandShortcut,
  YH as ConfirmDialog,
  gU as ContextMenu,
  yU as ContextMenuCheckboxItem,
  bU as ContextMenuContent,
  _U as ContextMenuGroup,
  wU as ContextMenuItem,
  xU as ContextMenuLabel,
  CU as ContextMenuRadioGroup,
  SU as ContextMenuRadioItem,
  $U as ContextMenuSeparator,
  kU as ContextMenuShortcut,
  BU as ContextMenuSub,
  DU as ContextMenuSubContent,
  PU as ContextMenuSubTrigger,
  MU as ContextMenuTrigger,
  k4 as Dialog,
  nU as DialogClose,
  B4 as DialogContent,
  aU as DialogDescription,
  rU as DialogFooter,
  oU as DialogHeader,
  sU as DialogScrollContent,
  lU as DialogTitle,
  iU as DialogTrigger,
  EU as Drawer,
  qU as DrawerClose,
  TU as DrawerContent,
  AU as DrawerDescription,
  IU as DrawerFooter,
  OU as DrawerHeader,
  Q4 as DrawerOverlay,
  RU as DrawerTitle,
  VU as DrawerTrigger,
  FU as DropdownMenu,
  NU as DropdownMenuCheckboxItem,
  LU as DropdownMenuContent,
  zU as DropdownMenuGroup,
  HU as DropdownMenuItem,
  UU as DropdownMenuLabel,
  AD as DropdownMenuPortal,
  jU as DropdownMenuRadioGroup,
  WU as DropdownMenuRadioItem,
  GU as DropdownMenuSeparator,
  KU as DropdownMenuShortcut,
  YU as DropdownMenuSub,
  XU as DropdownMenuSubContent,
  JU as DropdownMenuSubTrigger,
  ZU as DropdownMenuTrigger,
  QU as Empty,
  e9 as EmptyContent,
  t9 as EmptyDescription,
  n9 as EmptyHeader,
  a9 as EmptyMedia,
  r9 as EmptyTitle,
  f0 as FORM_ITEM_INJECTION_KEY,
  o9 as Field,
  s9 as FieldContent,
  l9 as FieldDescription,
  i9 as FieldError,
  u9 as FieldGroup,
  d9 as FieldLabel,
  c9 as FieldLegend,
  f9 as FieldSeparator,
  p9 as FieldSet,
  v9 as FieldTitle,
  c7 as Flasher,
  h9 as Form,
  y9 as FormControl,
  b9 as FormDescription,
  m9 as FormField,
  g9 as FormFieldArray,
  _9 as FormItem,
  w9 as FormLabel,
  x9 as FormMessage,
  JH as Header,
  f7 as Heading,
  C9 as HoverCard,
  S9 as HoverCardContent,
  $9 as HoverCardTrigger,
  p0 as Input,
  k9 as InputGroup,
  B9 as InputGroupAddon,
  D9 as InputGroupButton,
  P9 as InputGroupInput,
  M9 as InputGroupText,
  E9 as InputGroupTextarea,
  q9 as InputOTP,
  T9 as InputOTPGroup,
  A9 as InputOTPSeparator,
  I9 as InputOTPSlot,
  O9 as Item,
  R9 as ItemActions,
  V9 as ItemContent,
  F9 as ItemDescription,
  N9 as ItemFooter,
  L9 as ItemGroup,
  z9 as ItemHeader,
  H9 as ItemMedia,
  U9 as ItemSeparator,
  j9 as ItemTitle,
  W9 as Kbd,
  G9 as KbdGroup,
  J_ as Label,
  ZH as Main,
  K9 as Menubar,
  Y9 as MenubarCheckboxItem,
  X9 as MenubarContent,
  J9 as MenubarGroup,
  Z9 as MenubarItem,
  Q9 as MenubarLabel,
  ej as MenubarMenu,
  tj as MenubarRadioGroup,
  nj as MenubarRadioItem,
  aj as MenubarSeparator,
  rj as MenubarShortcut,
  oj as MenubarSub,
  sj as MenubarSubContent,
  lj as MenubarSubTrigger,
  ij as MenubarTrigger,
  uj as NavigationMenu,
  dj as NavigationMenuContent,
  cj as NavigationMenuIndicator,
  fj as NavigationMenuItem,
  pj as NavigationMenuLink,
  vj as NavigationMenuList,
  mj as NavigationMenuTrigger,
  J8 as NavigationMenuViewport,
  hj as NumberField,
  gj as NumberFieldContent,
  yj as NumberFieldDecrement,
  bj as NumberFieldIncrement,
  _j as NumberFieldInput,
  wj as Pagination,
  xj as PaginationContent,
  Cj as PaginationEllipsis,
  Sj as PaginationFirst,
  $j as PaginationItem,
  kj as PaginationLast,
  Bj as PaginationNext,
  Dj as PaginationPrevious,
  Pj as PinInput,
  Mj as PinInputGroup,
  Ej as PinInputSeparator,
  qj as PinInputSlot,
  Tj as Popover,
  LH as PopoverAnchor,
  Aj as PopoverContent,
  Ij as PopoverTrigger,
  Oj as Progress,
  Rj as RadioGroup,
  Vj as RadioGroupItem,
  Fj as RangeCalendar,
  eH as RangeCalendarCell,
  tH as RangeCalendarCellTrigger,
  nH as RangeCalendarGrid,
  aH as RangeCalendarGridBody,
  rH as RangeCalendarGridHead,
  th as RangeCalendarGridRow,
  oH as RangeCalendarHeadCell,
  sH as RangeCalendarHeader,
  lH as RangeCalendarHeading,
  iH as RangeCalendarNextButton,
  uH as RangeCalendarPrevButton,
  Nj as ResizableHandle,
  zH as ResizablePanel,
  Lj as ResizablePanelGroup,
  zj as ScrollArea,
  cH as ScrollBar,
  Hj as Select,
  Uj as SelectContent,
  jj as SelectGroup,
  Wj as SelectItem,
  Gj as SelectItemText,
  Kj as SelectLabel,
  pH as SelectScrollDownButton,
  vH as SelectScrollUpButton,
  Yj as SelectSeparator,
  Xj as SelectTrigger,
  Jj as SelectValue,
  Xi as Separator,
  mH as Sheet,
  Zj as SheetClose,
  gH as SheetContent,
  Qj as SheetDescription,
  eW as SheetFooter,
  tW as SheetHeader,
  hH as SheetOverlay,
  nW as SheetTitle,
  aW as SheetTrigger,
  rW as Sidebar,
  oW as SidebarContent,
  sW as SidebarFooter,
  lW as SidebarGroup,
  iW as SidebarGroupAction,
  uW as SidebarGroupContent,
  dW as SidebarGroupLabel,
  cW as SidebarHeader,
  fW as SidebarInput,
  pW as SidebarInset,
  vW as SidebarMenu,
  mW as SidebarMenuAction,
  hW as SidebarMenuBadge,
  gW as SidebarMenuButton,
  yW as SidebarMenuItem,
  bW as SidebarMenuSkeleton,
  _W as SidebarMenuSub,
  wW as SidebarMenuSubButton,
  xW as SidebarMenuSubItem,
  CW as SidebarProvider,
  SW as SidebarRail,
  $W as SidebarSeparator,
  kW as SidebarTrigger,
  rh as Skeleton,
  BW as Slider,
  PW as Spinner,
  MW as Stepper,
  EW as StepperDescription,
  qW as StepperIndicator,
  TW as StepperItem,
  AW as StepperSeparator,
  IW as StepperTitle,
  OW as StepperTrigger,
  RW as Switch,
  VW as Table,
  FW as TableBody,
  HW as TableCaption,
  EH as TableCell,
  UW as TableEmpty,
  zW as TableFooter,
  NW as TableHead,
  LW as TableHeader,
  qH as TableRow,
  jW as Tabs,
  WW as TabsContent,
  GW as TabsList,
  KW as TabsTrigger,
  YW as TagsInput,
  XW as TagsInputInput,
  JW as TagsInputItem,
  ZW as TagsInputItemDelete,
  QW as TagsInputItemText,
  h8 as Textarea,
  i7 as Tip,
  DW as Toaster,
  eG as Toggle,
  tG as ToggleGroup,
  nG as ToggleGroupItem,
  _f as Tooltip,
  wf as TooltipContent,
  nO as TooltipProvider,
  xf as TooltipTrigger,
  XH as TwoColumnLayout,
  QH as TwoColumnLayoutSidebar,
  e7 as TwoColumnLayoutSidebarDesktop,
  t7 as TwoColumnLayoutSidebarMobile,
  n7 as TwoColumnLayoutSidebarTrigger,
  s3 as alertVariants,
  l3 as avatarVariant,
  i3 as badgeVariants,
  d3 as buttonGroupVariants,
  Yt as buttonVariants,
  V as cn,
  UH as createContext,
  H7 as defaultColors,
  az as emptyMediaVariants,
  uz as fieldVariants,
  g8 as inputGroupAddonVariants,
  y8 as inputGroupButtonVariants,
  G8 as itemMediaVariants,
  W8 as itemVariants,
  Z8 as navigationMenuTriggerStyle,
  OH as preset,
  M4 as provideCommandContext,
  q4 as provideCommandGroupContext,
  PH as sidebarMenuButtonVariants,
  y0 as toggleVariants,
  Zi as useCarousel,
  $s as useCollapsibleSidebar,
  fu as useCommand,
  E4 as useCommandGroup,
  gI as useConfirmDialog,
  QO as useFlasher,
  GH as useMobileBottomNav,
  jH as useMobileNavigation,
  hu as useSidebar,
  WH as useSwipeNavigation,
  HH as valueUpdater
};
