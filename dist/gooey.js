import * as ap from "vue";
import { inject as xn, provide as Kn, Fragment as Ge, watch as me, shallowRef as ht, shallowReadonly as Ha, getCurrentInstance as zt, getCurrentScope as es, hasInjectionContext as Wm, toValue as pe, onScopeDispose as Qd, computed as A, customRef as di, isRef as Ct, reactive as pn, unref as l, watchEffect as Te, readonly as Ur, onBeforeUnmount as Ea, effectScope as Gm, toRef as Hn, ref as I, toRefs as qe, nextTick as Pe, onMounted as Ce, onUpdated as Z_, toHandlerKey as Q_, camelize as yl, onUnmounted as nt, defineComponent as b, h as tn, Comment as e0, mergeProps as T, cloneVNode as t0, openBlock as h, createBlock as w, withCtx as g, renderSlot as _, createVNode as N, createCommentVNode as De, withKeys as Je, normalizeStyle as dt, Teleport as ci, normalizeProps as oe, guardReactiveProps as le, withModifiers as Ye, createElementBlock as G, withDirectives as ec, vShow as n0, createElementVNode as we, toDisplayString as Fe, createTextVNode as Re, markRaw as a0, renderList as Et, resolveDynamicComponent as Pt, watchPostEffect as Km, mergeDefaults as Ym, watchSyncEffect as r0, withMemo as o0, onBeforeMount as s0, toRaw as l0, toHandlers as i0, normalizeClass as ae, useAttrs as u0, isVNode as so, createApp as Ju, useSlots as d0, vModelText as Xm, useModel as Jm, mergeModels as Zu } from "vue";
function c0(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var fu, rp;
function f0() {
  if (rp) return fu;
  rp = 1;
  function e(n, a) {
    return { handler: n, config: a };
  }
  e.withOptions = function(n, a = () => ({})) {
    function r(o) {
      return { handler: n(o), config: a(o) };
    }
    return r.__isOptionsFunction = !0, r;
  };
  var t = e;
  return fu = t, fu;
}
var pu, op;
function p0() {
  if (op) return pu;
  op = 1;
  const e = f0();
  function t(n) {
    return Object.fromEntries(
      Object.entries(n).filter(([a]) => a !== "DEFAULT")
    );
  }
  return pu = e(
    ({ addUtilities: n, matchUtilities: a, theme: r }) => {
      n({
        "@keyframes enter": r("keyframes.enter"),
        "@keyframes exit": r("keyframes.exit"),
        ".animate-in": {
          animationName: "enter",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-enter-opacity": "initial",
          "--tw-enter-scale": "initial",
          "--tw-enter-rotate": "initial",
          "--tw-enter-translate-x": "initial",
          "--tw-enter-translate-y": "initial"
        },
        ".animate-out": {
          animationName: "exit",
          animationDuration: r("animationDuration.DEFAULT"),
          "--tw-exit-opacity": "initial",
          "--tw-exit-scale": "initial",
          "--tw-exit-rotate": "initial",
          "--tw-exit-translate-x": "initial",
          "--tw-exit-translate-y": "initial"
        }
      }), a(
        {
          "fade-in": (o) => ({ "--tw-enter-opacity": o }),
          "fade-out": (o) => ({ "--tw-exit-opacity": o })
        },
        { values: r("animationOpacity") }
      ), a(
        {
          "zoom-in": (o) => ({ "--tw-enter-scale": o }),
          "zoom-out": (o) => ({ "--tw-exit-scale": o })
        },
        { values: r("animationScale") }
      ), a(
        {
          "spin-in": (o) => ({ "--tw-enter-rotate": o }),
          "spin-out": (o) => ({ "--tw-exit-rotate": o })
        },
        { values: r("animationRotate") }
      ), a(
        {
          "slide-in-from-top": (o) => ({
            "--tw-enter-translate-y": `-${o}`
          }),
          "slide-in-from-bottom": (o) => ({
            "--tw-enter-translate-y": o
          }),
          "slide-in-from-left": (o) => ({
            "--tw-enter-translate-x": `-${o}`
          }),
          "slide-in-from-right": (o) => ({
            "--tw-enter-translate-x": o
          }),
          "slide-out-to-top": (o) => ({
            "--tw-exit-translate-y": `-${o}`
          }),
          "slide-out-to-bottom": (o) => ({
            "--tw-exit-translate-y": o
          }),
          "slide-out-to-left": (o) => ({
            "--tw-exit-translate-x": `-${o}`
          }),
          "slide-out-to-right": (o) => ({
            "--tw-exit-translate-x": o
          })
        },
        { values: r("animationTranslate") }
      ), a(
        { duration: (o) => ({ animationDuration: o }) },
        { values: t(r("animationDuration")) }
      ), a(
        { delay: (o) => ({ animationDelay: o }) },
        { values: r("animationDelay") }
      ), a(
        { ease: (o) => ({ animationTimingFunction: o }) },
        { values: t(r("animationTimingFunction")) }
      ), n({
        ".running": { animationPlayState: "running" },
        ".paused": { animationPlayState: "paused" }
      }), a(
        { "fill-mode": (o) => ({ animationFillMode: o }) },
        { values: r("animationFillMode") }
      ), a(
        { direction: (o) => ({ animationDirection: o }) },
        { values: r("animationDirection") }
      ), a(
        { repeat: (o) => ({ animationIterationCount: o }) },
        { values: r("animationRepeat") }
      );
    },
    {
      theme: {
        extend: {
          animationDelay: ({ theme: n }) => ({
            ...n("transitionDelay")
          }),
          animationDuration: ({ theme: n }) => ({
            0: "0ms",
            ...n("transitionDuration")
          }),
          animationTimingFunction: ({ theme: n }) => ({
            ...n("transitionTimingFunction")
          }),
          animationFillMode: {
            none: "none",
            forwards: "forwards",
            backwards: "backwards",
            both: "both"
          },
          animationDirection: {
            normal: "normal",
            reverse: "reverse",
            alternate: "alternate",
            "alternate-reverse": "alternate-reverse"
          },
          animationOpacity: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("opacity")
          }),
          animationTranslate: ({ theme: n }) => ({
            DEFAULT: "100%",
            ...n("translate")
          }),
          animationScale: ({ theme: n }) => ({
            DEFAULT: 0,
            ...n("scale")
          }),
          animationRotate: ({ theme: n }) => ({
            DEFAULT: "30deg",
            ...n("rotate")
          }),
          animationRepeat: {
            0: "0",
            1: "1",
            infinite: "infinite"
          },
          keyframes: {
            enter: {
              from: {
                opacity: "var(--tw-enter-opacity, 1)",
                transform: "translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0))"
              }
            },
            exit: {
              to: {
                opacity: "var(--tw-exit-opacity, 1)",
                transform: "translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0))"
              }
            }
          }
        }
      }
    }
  ), pu;
}
var v0 = p0();
const m0 = /* @__PURE__ */ c0(v0), Q8 = {
  darkMode: ["class"],
  safelist: ["dark"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))"
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))"
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))"
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))"
        }
      },
      borderRadius: {
        xl: "calc(var(--radius) + 4px)",
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" }
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }
        },
        "collapsible-down": {
          from: { height: "0" },
          to: { height: "var(--radix-collapsible-content-height)" }
        },
        "collapsible-up": {
          from: { height: "var(--radix-collapsible-content-height)" },
          to: { height: "0" }
        }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "collapsible-down": "collapsible-down 0.2s ease-in-out",
        "collapsible-up": "collapsible-up 0.2s ease-in-out"
      }
    }
  },
  plugins: [m0]
};
function sp(e) {
  return typeof e == "string" ? `'${e}'` : new h0().serialize(e);
}
const h0 = /* @__PURE__ */ (function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(n, a) {
      const r = typeof n, o = typeof a;
      return r === "string" && o === "string" ? n.localeCompare(a) : r === "number" && o === "number" ? n - a : String.prototype.localeCompare.call(this.serialize(n, !0), this.serialize(a, !0));
    }
    serialize(n, a) {
      if (n === null) return "null";
      switch (typeof n) {
        case "string":
          return a ? n : `'${n}'`;
        case "bigint":
          return `${n}n`;
        case "object":
          return this.$object(n);
        case "function":
          return this.$function(n);
      }
      return String(n);
    }
    serializeObject(n) {
      const a = Object.prototype.toString.call(n);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), n);
      const r = n.constructor, o = r === Object || r === void 0 ? "" : r.name;
      if (o !== "" && globalThis[o] === r) return this.serializeBuiltInType(o, n);
      if (typeof n.toJSON == "function") {
        const s = n.toJSON();
        return o + (s !== null && typeof s == "object" ? this.$object(s) : `(${this.serialize(s)})`);
      }
      return this.serializeObjectEntries(o, Object.entries(n));
    }
    serializeBuiltInType(n, a) {
      const r = this["$" + n];
      if (r) return r.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(n, a.entries());
      throw new Error(`Cannot serialize ${n}`);
    }
    serializeObjectEntries(n, a) {
      const r = Array.from(a).sort((s, i) => this.compare(s[0], i[0]));
      let o = `${n}{`;
      for (let s = 0; s < r.length; s++) {
        const [i, u] = r[s];
        o += `${this.serialize(i, !0)}:${this.serialize(u)}`, s < r.length - 1 && (o += ",");
      }
      return o + "}";
    }
    $object(n) {
      let a = this.#e.get(n);
      return a === void 0 && (this.#e.set(n, `#${this.#e.size}`), a = this.serializeObject(n), this.#e.set(n, a)), a;
    }
    $function(n) {
      const a = Function.prototype.toString.call(n);
      return a.slice(-15) === "[native code] }" ? `${n.name || ""}()[native]` : `${n.name}(${n.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(n) {
      let a = "[";
      for (let r = 0; r < n.length; r++) a += this.serialize(n[r]), r < n.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(n) {
      try {
        return `Date(${n.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(n) {
      return `ArrayBuffer[${new Uint8Array(n).join(",")}]`;
    }
    $Set(n) {
      return `Set${this.$Array(Array.from(n).sort((a, r) => this.compare(a, r)))}`;
    }
    $Map(n) {
      return this.serializeObjectEntries("Map", n.entries());
    }
  }
  for (const t of ["Error", "RegExp", "URL"]) e.prototype["$" + t] = function(n) {
    return `${t}(${n})`;
  };
  for (const t of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join(",")}]`;
  };
  for (const t of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join("n,")}${n.length > 0 ? "n" : ""}]`;
  };
  return e;
})();
function Dn(e, t) {
  return e === t || sp(e) === sp(t);
}
function g0(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function y0(e, t, n) {
  const a = e.findIndex((i) => Dn(i, t)), r = e.findIndex((i) => Dn(i, n));
  if (a === -1 || r === -1) return [];
  const [o, s] = [a, r].sort((i, u) => i - u);
  return e.slice(o, s + 1);
}
const ts = typeof document < "u";
function Ar(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e));
}
function As(e, t) {
  let n = e;
  const a = t.toString(), r = a.indexOf("."), o = r >= 0 ? a.length - r : 0;
  if (o > 0) {
    const s = 10 ** o;
    n = Math.round(n * s) / s;
  }
  return n;
}
function b0(e, t, n, a) {
  t = Number(t), n = Number(n);
  const r = (e - (Number.isNaN(t) ? 0 : t)) % a;
  let o = As(Math.abs(r) * 2 >= a ? e + Math.sign(r) * (a - Math.abs(r)) : e - r, a);
  return Number.isNaN(t) ? !Number.isNaN(n) && o > n && (o = Math.floor(As(n / a, a)) * a) : o < t ? o = t : !Number.isNaN(n) && o > n && (o = t + Math.floor(As((n - t) / a, a)) * a), o = As(o, a), o;
}
function Se(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = xn(a, s);
    if (i || i === null) return i;
    throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`);
  }, (s) => (Kn(a, s), s)];
}
function rt() {
  let e = document.activeElement;
  if (e == null) return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; ) e = e.shadowRoot.activeElement;
  return e;
}
function ns(e, t, n) {
  const a = n.originalEvent.target, r = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(r);
}
function Pn(e) {
  return e == null;
}
function bl(e, t) {
  return Pn(e) ? !1 : Array.isArray(e) ? e.some((n) => Dn(n, t)) : Dn(e, t);
}
function tc(e) {
  return e ? e.flatMap((t) => t.type === Ge ? tc(t.children) : [t]) : [];
}
const _0 = ["INPUT", "TEXTAREA"];
function rr(e, t, n, a = {}) {
  if (!t || a.enableIgnoredElement && _0.includes(t.nodeName)) return null;
  const { arrowKeyOptions: r = "both", attributeName: o = "[data-reka-collection-item]", itemsArray: s = [], loop: i = !0, dir: u = "ltr", preventScroll: d = !0, focus: c = !1 } = a, [f, p, v, m, y, x] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ], C = v || m, S = f || p;
  if (!y && !x && (!C && !S || r === "vertical" && S || r === "horizontal" && C)) return null;
  const $ = n ? Array.from(n.querySelectorAll(o)) : s;
  if (!$.length) return null;
  d && e.preventDefault();
  let k = null;
  return S || C ? k = Zm($, t, {
    goForward: C ? m : u === "ltr" ? f : p,
    loop: i
  }) : y ? k = $.at(0) || null : x && (k = $.at(-1) || null), c && k?.focus(), k;
}
function Zm(e, t, n, a = e.length) {
  if (--a === 0) return null;
  const r = e.indexOf(t), o = n.goForward ? r + 1 : r - 1;
  if (!n.loop && (o < 0 || o >= e.length)) return null;
  const s = (o + e.length) % e.length, i = e[s];
  return i ? i.hasAttribute("disabled") && i.getAttribute("disabled") !== "false" ? Zm(e, i, n, a) : i : null;
}
const [as] = Se("ConfigProvider");
function w0(e, t) {
  var n;
  const a = ht();
  return Te(() => {
    a.value = e();
  }, {
    ...t,
    flush: (n = t?.flush) !== null && n !== void 0 ? n : "sync"
  }), Ur(a);
}
function x0(e, t, n = {}) {
  let a, r, o, s = !0;
  const i = () => {
    s = !0, o();
  };
  me(e, i, {
    flush: "sync",
    ...n
  });
  const u = typeof t == "function" ? t : t.get, d = typeof t == "function" ? void 0 : t.set, c = di((f, p) => (r = f, o = p, {
    get() {
      return s && (a = u(a), s = !1), r(), a;
    },
    set(v) {
      d?.(v);
    }
  }));
  return c.trigger = i, c;
}
function Ta(e, t) {
  return es() ? (Qd(e, t), !0) : !1;
}
// @__NO_SIDE_EFFECTS__
function Sr() {
  const e = /* @__PURE__ */ new Set(), t = (o) => {
    e.delete(o);
  };
  return {
    on: (o) => {
      e.add(o);
      const s = () => t(o);
      return Ta(s), { off: s };
    },
    off: t,
    trigger: (...o) => Promise.all(Array.from(e).map((s) => s(...o))),
    clear: () => {
      e.clear();
    }
  };
}
// @__NO_SIDE_EFFECTS__
function C0(e) {
  let t = !1, n;
  const a = Gm(!0);
  return ((...r) => (t || (n = a.run(() => e(...r)), t = !0), n));
}
const $r = /* @__PURE__ */ new WeakMap(), Qm = /* @__NO_SIDE_EFFECTS__ */ (...e) => {
  var t;
  const n = e[0], a = (t = zt()) === null || t === void 0 ? void 0 : t.proxy, r = a ?? es();
  if (r == null && !Wm()) throw new Error("injectLocal must be called in setup");
  return r && $r.has(r) && n in $r.get(r) ? $r.get(r)[n] : xn(...e);
};
function S0(e, t) {
  var n;
  const a = (n = zt()) === null || n === void 0 ? void 0 : n.proxy, r = a ?? es();
  if (r == null) throw new Error("provideLocal must be called in setup");
  $r.has(r) || $r.set(r, /* @__PURE__ */ Object.create(null));
  const o = $r.get(r);
  return o[e] = t, Kn(e, t);
}
// @__NO_SIDE_EFFECTS__
function $0(e, t) {
  const n = Symbol(e.name || "InjectionState"), a = void 0;
  return [(...s) => {
    const i = e(...s);
    return S0(n, i), i;
  }, () => /* @__PURE__ */ Qm(n, a)];
}
const Ut = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const B0 = (e) => typeof e < "u", k0 = (e) => e != null, P0 = Object.prototype.toString, M0 = (e) => P0.call(e) === "[object Object]", _l = () => {
}, lp = /* @__PURE__ */ D0();
function D0() {
  var e, t, n;
  return Ut && !!(!((e = window) === null || e === void 0 || (e = e.navigator) === null || e === void 0) && e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window) === null || t === void 0 || (t = t.navigator) === null || t === void 0 ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test((n = window) === null || n === void 0 ? void 0 : n.navigator.userAgent));
}
function q0(...e) {
  if (e.length !== 1) return Hn(...e);
  const t = e[0];
  return typeof t == "function" ? Ur(di(() => ({
    get: t,
    set: _l
  }))) : I(t);
}
function eh(e, t) {
  function n(...a) {
    return new Promise((r, o) => {
      Promise.resolve(e(() => t.apply(this, a), {
        fn: t,
        thisArg: this,
        args: a
      })).then(r).catch(o);
    });
  }
  return n;
}
const th = (e) => e();
function A0(e, t = {}) {
  let n, a, r = _l;
  const o = (u) => {
    clearTimeout(u), r(), r = _l;
  };
  let s;
  return (u) => {
    const d = pe(e), c = pe(t.maxWait);
    return n && o(n), d <= 0 || c !== void 0 && c <= 0 ? (a && (o(a), a = void 0), Promise.resolve(u())) : new Promise((f, p) => {
      r = t.rejectOnCancel ? p : f, s = u, c && !a && (a = setTimeout(() => {
        n && o(n), a = void 0, f(s());
      }, c)), n = setTimeout(() => {
        a && o(a), a = void 0, f(u());
      }, d);
    });
  };
}
function E0(e = th, t = {}) {
  const { initialState: n = "active" } = t, a = q0(n === "active");
  function r() {
    a.value = !1;
  }
  function o() {
    a.value = !0;
  }
  const s = (...i) => {
    a.value && e(...i);
  };
  return {
    isActive: Ur(a),
    pause: r,
    resume: o,
    eventFilter: s
  };
}
function ip(e) {
  return e.endsWith("rem") ? Number.parseFloat(e) * 16 : Number.parseFloat(e);
}
function al(e) {
  return Array.isArray(e) ? e : [e];
}
function T0(e) {
  return zt();
}
// @__NO_SIDE_EFFECTS__
function nh(e) {
  if (!Ut) return e;
  let t = 0, n, a;
  const r = () => {
    t -= 1, a && t <= 0 && (a.stop(), n = void 0, a = void 0);
  };
  return ((...o) => (t += 1, a || (a = Gm(!0), n = a.run(() => e(...o))), Ta(r), n));
}
function I0(e) {
  return Ct(e) ? pn(new Proxy({}, {
    get(t, n, a) {
      return l(Reflect.get(e.value, n, a));
    },
    set(t, n, a) {
      return Ct(e.value[n]) && !Ct(a) ? e.value[n].value = a : e.value[n] = a, !0;
    },
    deleteProperty(t, n) {
      return Reflect.deleteProperty(e.value, n);
    },
    has(t, n) {
      return Reflect.has(e.value, n);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  })) : pn(e);
}
function nc(e) {
  return I0(A(e));
}
function Z(e, ...t) {
  const n = t.flat(), a = n[0];
  return nc(() => Object.fromEntries(typeof a == "function" ? Object.entries(qe(e)).filter(([r, o]) => !a(pe(o), r)) : Object.entries(qe(e)).filter((r) => !n.includes(r[0]))));
}
function rs(e, t = 1e4) {
  return di((n, a) => {
    let r = pe(e), o;
    const s = () => setTimeout(() => {
      r = pe(e), a();
    }, pe(t));
    return Ta(() => {
      clearTimeout(o);
    }), {
      get() {
        return n(), r;
      },
      set(i) {
        r = i, a(), clearTimeout(o), o = s();
      }
    };
  });
}
// @__NO_SIDE_EFFECTS__
function fi(e, t = 200, n = {}) {
  return eh(A0(t, n), e);
}
function O0(e, t, n = {}) {
  const { eventFilter: a = th, ...r } = n;
  return me(e, eh(a, t), r);
}
function up(e, t, n = {}) {
  const { eventFilter: a, initialState: r = "active", ...o } = n, { eventFilter: s, pause: i, resume: u, isActive: d } = E0(a, { initialState: r });
  return {
    stop: O0(e, t, {
      ...o,
      eventFilter: s
    }),
    pause: i,
    resume: u,
    isActive: d
  };
}
function R0(e, t, ...[n]) {
  const { flush: a = "sync", deep: r = !1, immediate: o = !0, direction: s = "both", transform: i = {} } = n || {}, u = [], d = "ltr" in i && i.ltr || ((p) => p), c = "rtl" in i && i.rtl || ((p) => p);
  return (s === "both" || s === "ltr") && u.push(up(e, (p) => {
    u.forEach((v) => v.pause()), t.value = d(p), u.forEach((v) => v.resume());
  }, {
    flush: a,
    deep: r,
    immediate: o
  })), (s === "both" || s === "rtl") && u.push(up(t, (p) => {
    u.forEach((v) => v.pause()), e.value = c(p), u.forEach((v) => v.resume());
  }, {
    flush: a,
    deep: r,
    immediate: o
  })), () => {
    u.forEach((p) => p.stop());
  };
}
function V0(e, t) {
  T0() && Ea(e, t);
}
function ah(e, t, n = {}) {
  const { immediate: a = !0, immediateCallback: r = !1 } = n, o = ht(!1);
  let s;
  function i() {
    s && (clearTimeout(s), s = void 0);
  }
  function u() {
    o.value = !1, i();
  }
  function d(...c) {
    r && e(), i(), o.value = !0, s = setTimeout(() => {
      o.value = !1, s = void 0, e(...c);
    }, pe(t));
  }
  return a && (o.value = !0, Ut && d()), Ta(u), {
    isPending: Ha(o),
    start: d,
    stop: u
  };
}
function F0(e, t, n) {
  return me(e, t, {
    ...n,
    immediate: !0
  });
}
function N0(e, t, n) {
  return me(e, t, {
    ...n,
    once: !0
  });
}
const va = Ut ? window : void 0, rh = Ut ? window.document : void 0;
function jt(e) {
  var t;
  const n = pe(e);
  return (t = n?.$el) !== null && t !== void 0 ? t : n;
}
function ct(...e) {
  const t = (a, r, o, s) => (a.addEventListener(r, o, s), () => a.removeEventListener(r, o, s)), n = A(() => {
    const a = al(pe(e[0])).filter((r) => r != null);
    return a.every((r) => typeof r != "string") ? a : void 0;
  });
  return F0(() => {
    var a, r;
    return [
      (a = (r = n.value) === null || r === void 0 ? void 0 : r.map((o) => jt(o))) !== null && a !== void 0 ? a : [va].filter((o) => o != null),
      al(pe(n.value ? e[1] : e[0])),
      al(l(n.value ? e[2] : e[1])),
      pe(n.value ? e[3] : e[2])
    ];
  }, ([a, r, o, s], i, u) => {
    if (!a?.length || !r?.length || !o?.length) return;
    const d = M0(s) ? { ...s } : s, c = a.flatMap((f) => r.flatMap((p) => o.map((v) => t(f, p, v, d))));
    u(() => {
      c.forEach((f) => f());
    });
  }, { flush: "post" });
}
// @__NO_SIDE_EFFECTS__
function ac() {
  const e = ht(!1), t = zt();
  return t && Ce(() => {
    e.value = !0;
  }, t), e;
}
// @__NO_SIDE_EFFECTS__
function rc(e) {
  const t = /* @__PURE__ */ ac();
  return A(() => (t.value, !!e()));
}
function L0(e, t, n = {}) {
  const { window: a = va, ...r } = n;
  let o;
  const s = /* @__PURE__ */ rc(() => a && "MutationObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = me(A(() => {
    const f = al(pe(e)).map(jt).filter(k0);
    return new Set(f);
  }), (f) => {
    i(), s.value && f.size && (o = new MutationObserver(t), f.forEach((p) => o.observe(p, r)));
  }, {
    immediate: !0,
    flush: "post"
  }), d = () => o?.takeRecords(), c = () => {
    u(), i();
  };
  return Ta(c), {
    isSupported: s,
    stop: c,
    takeRecords: d
  };
}
function z0(e, t, n = {}) {
  const { window: a = va, document: r = a?.document, flush: o = "sync" } = n;
  if (!a || !r) return _l;
  let s;
  const i = (c) => {
    s?.(), s = c;
  }, u = Te(() => {
    const c = jt(e);
    if (c) {
      const { stop: f } = L0(r, (p) => {
        p.map((v) => [...v.removedNodes]).flat().some((v) => v === c || v.contains(c)) && t(p);
      }, {
        window: a,
        childList: !0,
        subtree: !0
      });
      i(f);
    }
  }, { flush: o }), d = () => {
    u(), i();
  };
  return Ta(d), d;
}
function H0(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function U0(...e) {
  let t, n, a = {};
  e.length === 3 ? (t = e[0], n = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], a = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const { target: r = va, eventName: o = "keydown", passive: s = !1, dedupe: i = !1 } = a, u = H0(t);
  return ct(r, o, (c) => {
    c.repeat && pe(i) || u(c) && n(c);
  }, s);
}
// @__NO_SIDE_EFFECTS__
function j0(e = {}) {
  var t;
  const { window: n = va, deep: a = !0, triggerOnRemoval: r = !1 } = e, o = (t = e.document) !== null && t !== void 0 ? t : n?.document, s = () => {
    let d = o?.activeElement;
    if (a)
      for (var c; d?.shadowRoot; ) d = d == null || (c = d.shadowRoot) === null || c === void 0 ? void 0 : c.activeElement;
    return d;
  }, i = ht(), u = () => {
    i.value = s();
  };
  if (n) {
    const d = {
      capture: !0,
      passive: !0
    };
    ct(n, "blur", (c) => {
      c.relatedTarget === null && u();
    }, d), ct(n, "focus", u, d);
  }
  return r && z0(i, u, { document: o }), u(), i;
}
const W0 = /* @__PURE__ */ Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function G0() {
  const e = Wm() ? /* @__PURE__ */ Qm(W0, null) : null;
  return typeof e == "number" ? e : void 0;
}
function wl(e, t = {}) {
  const { window: n = va, ssrWidth: a = /* @__PURE__ */ G0() } = t, r = /* @__PURE__ */ rc(() => n && "matchMedia" in n && typeof n.matchMedia == "function"), o = ht(typeof a == "number"), s = ht(), i = ht(!1), u = (d) => {
    i.value = d.matches;
  };
  return Te(() => {
    if (o.value) {
      o.value = !r.value, i.value = pe(e).split(",").some((d) => {
        const c = d.includes("not all"), f = d.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/), p = d.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let v = !!(f || p);
        return f && v && (v = a >= ip(f[1])), p && v && (v = a <= ip(p[1])), c ? !v : v;
      });
      return;
    }
    r.value && (s.value = n.matchMedia(pe(e)), i.value = s.value.matches);
  }), ct(s, "change", u, { passive: !0 }), A(() => i.value);
}
function K0(e) {
  return JSON.parse(JSON.stringify(e));
}
function Y0(e) {
  const t = zt(), n = x0(() => null, () => e ? jt(e) : t.proxy.$el);
  return Z_(n.trigger), Ce(n.trigger), n;
}
function qn(e, t, n = {}) {
  const { window: a = va, ...r } = n;
  let o;
  const s = /* @__PURE__ */ rc(() => a && "ResizeObserver" in a), i = () => {
    o && (o.disconnect(), o = void 0);
  }, u = me(A(() => {
    const c = pe(e);
    return Array.isArray(c) ? c.map((f) => jt(f)) : [jt(c)];
  }), (c) => {
    if (i(), s.value && a) {
      o = new ResizeObserver(t);
      for (const f of c) f && o.observe(f, r);
    }
  }, {
    immediate: !0,
    flush: "post"
  }), d = () => {
    i(), u();
  };
  return Ta(d), {
    isSupported: s,
    stop: d
  };
}
const X0 = "focusin", J0 = "focusout", Z0 = ":focus-within";
function Q0(e, t = {}) {
  const { window: n = va } = t, a = A(() => jt(e)), r = ht(!1), o = A(() => r.value);
  if (!n || !(/* @__PURE__ */ j0(t)).value) return { focused: o };
  const i = { passive: !0 };
  return ct(a, X0, () => r.value = !0, i), ct(a, J0, () => {
    var u, d, c;
    return r.value = (u = (d = a.value) === null || d === void 0 || (c = d.matches) === null || c === void 0 ? void 0 : c.call(d, Z0)) !== null && u !== void 0 ? u : !1;
  }, i), { focused: o };
}
function ew(e, t = {}) {
  const { threshold: n = 50, onSwipe: a, onSwipeEnd: r, onSwipeStart: o, passive: s = !0 } = t, i = pn({
    x: 0,
    y: 0
  }), u = pn({
    x: 0,
    y: 0
  }), d = A(() => i.x - u.x), c = A(() => i.y - u.y), { max: f, abs: p } = Math, v = A(() => f(p(d.value), p(c.value)) >= n), m = ht(!1), y = A(() => v.value ? p(d.value) > p(c.value) ? d.value > 0 ? "left" : "right" : c.value > 0 ? "up" : "down" : "none"), x = (M) => [M.touches[0].clientX, M.touches[0].clientY], C = (M, q) => {
    i.x = M, i.y = q;
  }, S = (M, q) => {
    u.x = M, u.y = q;
  }, $ = {
    passive: s,
    capture: !s
  }, k = (M) => {
    m.value && r?.(M, y.value), m.value = !1;
  }, B = [
    ct(e, "touchstart", (M) => {
      if (M.touches.length !== 1) return;
      const [q, E] = x(M);
      C(q, E), S(q, E), o?.(M);
    }, $),
    ct(e, "touchmove", (M) => {
      if (M.touches.length !== 1) return;
      const [q, E] = x(M);
      S(q, E), $.capture && !$.passive && Math.abs(d.value) > Math.abs(c.value) && M.preventDefault(), !m.value && v.value && (m.value = !0), m.value && a?.(M);
    }, $),
    ct(e, ["touchend", "touchcancel"], k, $)
  ];
  return {
    isSwiping: m,
    direction: y,
    coordsStart: i,
    coordsEnd: u,
    lengthX: d,
    lengthY: c,
    stop: () => B.forEach((M) => M())
  };
}
// @__NO_SIDE_EFFECTS__
function Ie(e, t, n, a = {}) {
  var r, o;
  const { clone: s = !1, passive: i = !1, eventName: u, deep: d = !1, defaultValue: c, shouldEmit: f } = a, p = zt(), v = n || p?.emit || (p == null || (r = p.$emit) === null || r === void 0 ? void 0 : r.bind(p)) || (p == null || (o = p.proxy) === null || o === void 0 || (o = o.$emit) === null || o === void 0 ? void 0 : o.bind(p?.proxy));
  let m = u;
  t || (t = "modelValue"), m = m || `update:${t.toString()}`;
  const y = (S) => s ? typeof s == "function" ? s(S) : K0(S) : S, x = () => B0(e[t]) ? y(e[t]) : c, C = (S) => {
    f ? f(S) && v(m, S) : v(m, S);
  };
  if (i) {
    const S = I(x());
    let $ = !1;
    return me(() => e[t], (k) => {
      $ || ($ = !0, S.value = y(k), Pe(() => $ = !1));
    }), me(S, (k) => {
      !$ && (k !== e[t] || d) && C(k);
    }, { deep: d }), S;
  } else return A({
    get() {
      return x();
    },
    set(S) {
      C(S);
    }
  });
}
function vu(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function Qu(e, t, n = ".", a) {
  if (!vu(t))
    return Qu(e, {}, n, a);
  const r = Object.assign({}, t);
  for (const o in e) {
    if (o === "__proto__" || o === "constructor")
      continue;
    const s = e[o];
    s != null && (a && a(r, o, s, n) || (Array.isArray(s) && Array.isArray(r[o]) ? r[o] = [...s, ...r[o]] : vu(s) && vu(r[o]) ? r[o] = Qu(
      s,
      r[o],
      (n ? `${n}.` : "") + o.toString(),
      a
    ) : r[o] = s));
  }
  return r;
}
function tw(e) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((n, a) => Qu(n, a, "", e), {})
  );
}
const nw = tw(), aw = /* @__PURE__ */ nh(() => {
  const e = I(/* @__PURE__ */ new Map()), t = I(), n = A(() => {
    for (const s of e.value.values()) if (s) return !0;
    return !1;
  }), a = as({ scrollBody: I(!0) });
  let r = null;
  const o = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", lp && r?.(), t.value = void 0;
  };
  return me(n, (s, i) => {
    if (!Ut) return;
    if (!s) {
      i && o();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const u = window.innerWidth - document.documentElement.clientWidth, d = {
      padding: u,
      margin: 0
    }, c = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? nw({
      padding: a.scrollBody.value.padding === !0 ? u : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? u : a.scrollBody.value.margin
    }, d) : d : {
      padding: 0,
      margin: 0
    };
    u > 0 && (document.body.style.paddingRight = typeof c.padding == "number" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == "number" ? `${c.margin}px` : String(c.margin), document.documentElement.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), lp && (r = ct(document, "touchmove", (f) => rw(f), { passive: !1 })), Pe(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, {
    immediate: !0,
    flush: "sync"
  }), e;
});
function os(e) {
  const t = Math.random().toString(36).substring(2, 7), n = aw();
  n.value.set(t, e ?? !1);
  const a = A({
    get: () => n.value.get(t) ?? !1,
    set: (r) => n.value.set(t, r)
  });
  return V0(() => {
    n.value.delete(t);
  }), a;
}
function oh(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight) return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : oh(n);
  }
}
function rw(e) {
  const t = e || window.event, n = t.target;
  return n instanceof Element && oh(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);
}
function Br(e, t) {
  return e - t * Math.floor(e / t);
}
const sh = 1721426;
function Wa(e, t, n, a) {
  t = ss(e, t);
  let r = t - 1, o = -2;
  return n <= 2 ? o = 0 : ka(t) && (o = -1), sh - 1 + 365 * r + Math.floor(r / 4) - Math.floor(r / 100) + Math.floor(r / 400) + Math.floor((367 * n - 362) / 12 + o + a);
}
function ka(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function ss(e, t) {
  return e === "BC" ? 1 - t : t;
}
function pi(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const ow = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class An {
  fromJulianDay(t) {
    let n = t, a = n - sh, r = Math.floor(a / 146097), o = Br(a, 146097), s = Math.floor(o / 36524), i = Br(o, 36524), u = Math.floor(i / 1461), d = Br(i, 1461), c = Math.floor(d / 365), f = r * 400 + s * 100 + u * 4 + c + (s !== 4 && c !== 4 ? 1 : 0), [p, v] = pi(f), m = n - Wa(p, v, 1, 1), y = 2;
    n < Wa(p, v, 3, 1) ? y = 0 : ka(v) && (y = 1);
    let x = Math.floor(((m + y) * 12 + 373) / 367), C = n - Wa(p, v, x, 1) + 1;
    return new St(p, v, x, C);
  }
  toJulianDay(t) {
    return Wa(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return ow[ka(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return ka(t.year) ? 366 : 365;
  }
  getMaximumMonthsInYear() {
    return 12;
  }
  getMaximumDaysInMonth() {
    return 31;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
function wt(e, t) {
  return t = Zt(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function oc(e, t) {
  return t = Zt(t, e.calendar), e = ed(e), t = ed(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function Sa(e, t) {
  return sc(e.calendar, t.calendar) && wt(e, t);
}
function dp(e, t) {
  return sc(e.calendar, t.calendar) && oc(e, t);
}
function sc(e, t) {
  var n, a, r, o;
  return (o = (r = (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && r !== void 0 ? r : (a = t.isEqual) === null || a === void 0 ? void 0 : a.call(t, e)) !== null && o !== void 0 ? o : e.identifier === t.identifier;
}
function lh(e, t) {
  return wt(e, uh(t));
}
const sw = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
function ih(e, t, n) {
  let a = e.calendar.toJulianDay(e), r = sw[n], o = Math.ceil(a + 1 - r) % 7;
  return o < 0 && (o += 7), o;
}
function lw(e) {
  return aa(Date.now(), e);
}
function uh(e) {
  return cw(lw(e));
}
function dh(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function iw(e, t) {
  return cp(e) - cp(t);
}
function cp(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let mu = null;
function jr() {
  return mu == null && (mu = new Intl.DateTimeFormat().resolvedOptions().timeZone), mu;
}
function ed(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function fp(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
function Er(e) {
  e = Zt(e, new An());
  let t = ss(e.era, e.year);
  return ch(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function ch(e, t, n, a, r, o, s) {
  let i = /* @__PURE__ */ new Date();
  return i.setUTCHours(a, r, o, s), i.setUTCFullYear(e, t - 1, n), i.getTime();
}
function td(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === jr()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: n, month: a, day: r, hour: o, minute: s, second: i } = fh(e, t);
  return ch(n, a, r, o, s, i, 0) - Math.floor(e / 1e3) * 1e3;
}
const pp = /* @__PURE__ */ new Map();
function fh(e, t) {
  let n = pp.get(t);
  n || (n = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), pp.set(t, n));
  let a = n.formatToParts(new Date(e)), r = {};
  for (let o of a) o.type !== "literal" && (r[o.type] = o.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: r.era === "BC" || r.era === "B" ? -r.year + 1 : +r.year,
    month: +r.month,
    day: +r.day,
    hour: r.hour === "24" ? 0 : +r.hour,
    minute: +r.minute,
    second: +r.second
  };
}
const vp = 864e5;
function uw(e, t, n, a) {
  return (n === a ? [
    n
  ] : [
    n,
    a
  ]).filter((o) => dw(e, t, o));
}
function dw(e, t, n) {
  let a = fh(n, t);
  return e.year === a.year && e.month === a.month && e.day === a.day && e.hour === a.hour && e.minute === a.minute && e.second === a.second;
}
function na(e, t, n = "compatible") {
  let a = Tr(e);
  if (t === "UTC") return Er(a);
  if (t === jr() && n === "compatible") {
    a = Zt(a, new An());
    let u = /* @__PURE__ */ new Date(), d = ss(a.era, a.year);
    return u.setFullYear(d, a.month - 1, a.day), u.setHours(a.hour, a.minute, a.second, a.millisecond), u.getTime();
  }
  let r = Er(a), o = td(r - vp, t), s = td(r + vp, t), i = uw(a, t, r - o, r - s);
  if (i.length === 1) return i[0];
  if (i.length > 1) switch (n) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return i[0];
    case "later":
      return i[i.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (n) {
    case "earlier":
      return Math.min(r - o, r - s);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(r - o, r - s);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function ph(e, t, n = "compatible") {
  return new Date(na(e, t, n));
}
function aa(e, t) {
  let n = td(e, t), a = new Date(e + n), r = a.getUTCFullYear(), o = a.getUTCMonth() + 1, s = a.getUTCDate(), i = a.getUTCHours(), u = a.getUTCMinutes(), d = a.getUTCSeconds(), c = a.getUTCMilliseconds();
  return new Or(r < 1 ? "BC" : "AD", r < 1 ? -r + 1 : r, o, s, t, n, i, u, d, c);
}
function cw(e) {
  return new St(e.calendar, e.era, e.year, e.month, e.day);
}
function Tr(e, t) {
  let n = 0, a = 0, r = 0, o = 0;
  if ("timeZone" in e) ({ hour: n, minute: a, second: r, millisecond: o } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: n, minute: a, second: r, millisecond: o } = t), new Ir(e.calendar, e.era, e.year, e.month, e.day, n, a, r, o);
}
function Zt(e, t) {
  if (sc(e.calendar, t)) return e;
  let n = t.fromJulianDay(e.calendar.toJulianDay(e)), a = e.copy();
  return a.calendar = t, a.era = n.era, a.year = n.year, a.month = n.month, a.day = n.day, Za(a), a;
}
function fw(e, t, n) {
  if (e instanceof Or)
    return e.timeZone === t ? e : vw(e, t);
  let a = na(e, t, n);
  return aa(a, t);
}
function pw(e) {
  let t = Er(e) - e.offset;
  return new Date(t);
}
function vw(e, t) {
  let n = Er(e) - e.offset;
  return Zt(aa(n, t), e.calendar);
}
const lo = 36e5;
function vi(e, t) {
  let n = e.copy(), a = "hour" in n ? yw(n, t) : 0;
  nd(n, t.years || 0), n.calendar.balanceYearMonth && n.calendar.balanceYearMonth(n, e), n.month += t.months || 0, ad(n), vh(n), n.day += (t.weeks || 0) * 7, n.day += t.days || 0, n.day += a, mw(n), n.calendar.balanceDate && n.calendar.balanceDate(n), n.year < 1 && (n.year = 1, n.month = 1, n.day = 1);
  let r = n.calendar.getYearsInEra(n);
  if (n.year > r) {
    var o, s;
    let u = (o = (s = n.calendar).isInverseEra) === null || o === void 0 ? void 0 : o.call(s, n);
    n.year = r, n.month = u ? 1 : n.calendar.getMonthsInYear(n), n.day = u ? 1 : n.calendar.getDaysInMonth(n);
  }
  n.month < 1 && (n.month = 1, n.day = 1);
  let i = n.calendar.getMonthsInYear(n);
  return n.month > i && (n.month = i, n.day = n.calendar.getDaysInMonth(n)), n.day = Math.max(1, Math.min(n.calendar.getDaysInMonth(n), n.day)), n;
}
function nd(e, t) {
  var n, a;
  !((n = (a = e.calendar).isInverseEra) === null || n === void 0) && n.call(a, e) && (t = -t), e.year += t;
}
function ad(e) {
  for (; e.month < 1; )
    nd(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, nd(e, 1);
}
function mw(e) {
  for (; e.day < 1; )
    e.month--, ad(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, ad(e);
}
function vh(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function Za(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), vh(e);
}
function mh(e) {
  let t = {};
  for (let n in e) typeof e[n] == "number" && (t[n] = -e[n]);
  return t;
}
function hh(e, t) {
  return vi(e, mh(t));
}
function lc(e, t) {
  let n = e.copy();
  return t.era != null && (n.era = t.era), t.year != null && (n.year = t.year), t.month != null && (n.month = t.month), t.day != null && (n.day = t.day), Za(n), n;
}
function xl(e, t) {
  let n = e.copy();
  return t.hour != null && (n.hour = t.hour), t.minute != null && (n.minute = t.minute), t.second != null && (n.second = t.second), t.millisecond != null && (n.millisecond = t.millisecond), gw(n), n;
}
function hw(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = Es(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = Es(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = Es(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = Es(e.hour, 24), t;
}
function gw(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function Es(e, t) {
  let n = e % t;
  return n < 0 && (n += t), n;
}
function yw(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, hw(e);
}
function ic(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "era": {
      let i = e.calendar.getEras(), u = i.indexOf(e.era);
      if (u < 0) throw new Error("Invalid era: " + e.era);
      u = ra(u, n, 0, i.length - 1, a?.round), r.era = i[u], Za(r);
      break;
    }
    case "year":
      var o, s;
      !((o = (s = r.calendar).isInverseEra) === null || o === void 0) && o.call(s, r) && (n = -n), r.year = ra(e.year, n, -1 / 0, 9999, a?.round), r.year === -1 / 0 && (r.year = 1), r.calendar.balanceYearMonth && r.calendar.balanceYearMonth(r, e);
      break;
    case "month":
      r.month = ra(e.month, n, 1, e.calendar.getMonthsInYear(e), a?.round);
      break;
    case "day":
      r.day = ra(e.day, n, 1, e.calendar.getDaysInMonth(e), a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(r), Za(r), r;
}
function gh(e, t, n, a) {
  let r = e.copy();
  switch (t) {
    case "hour": {
      let o = e.hour, s = 0, i = 23;
      if (a?.hourCycle === 12) {
        let u = o >= 12;
        s = u ? 12 : 0, i = u ? 23 : 11;
      }
      r.hour = ra(o, n, s, i, a?.round);
      break;
    }
    case "minute":
      r.minute = ra(e.minute, n, 0, 59, a?.round);
      break;
    case "second":
      r.second = ra(e.second, n, 0, 59, a?.round);
      break;
    case "millisecond":
      r.millisecond = ra(e.millisecond, n, 0, 999, a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return r;
}
function ra(e, t, n, a, r = !1) {
  if (r) {
    e += Math.sign(t), e < n && (e = a);
    let o = Math.abs(t);
    t > 0 ? e = Math.ceil(e / o) * o : e = Math.floor(e / o) * o, e > a && (e = n);
  } else
    e += t, e < n ? e = a - (n - e - 1) : e > a && (e = n + (e - a - 1));
  return e;
}
function yh(e, t) {
  let n;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let r = vi(Tr(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    n = na(r, e.timeZone);
  } else
    n = Er(e) - e.offset;
  n += t.milliseconds || 0, n += (t.seconds || 0) * 1e3, n += (t.minutes || 0) * 6e4, n += (t.hours || 0) * 36e5;
  let a = aa(n, e.timeZone);
  return Zt(a, e.calendar);
}
function bw(e, t) {
  return yh(e, mh(t));
}
function _w(e, t, n, a) {
  switch (t) {
    case "hour": {
      let r = 0, o = 23;
      if (a?.hourCycle === 12) {
        let m = e.hour >= 12;
        r = m ? 12 : 0, o = m ? 23 : 11;
      }
      let s = Tr(e), i = Zt(xl(s, {
        hour: r
      }), new An()), u = [
        na(i, e.timeZone, "earlier"),
        na(i, e.timeZone, "later")
      ].filter((m) => aa(m, e.timeZone).day === i.day)[0], d = Zt(xl(s, {
        hour: o
      }), new An()), c = [
        na(d, e.timeZone, "earlier"),
        na(d, e.timeZone, "later")
      ].filter((m) => aa(m, e.timeZone).day === d.day).pop(), f = Er(e) - e.offset, p = Math.floor(f / lo), v = f % lo;
      return f = ra(p, n, Math.floor(u / lo), Math.floor(c / lo), a?.round) * lo + v, Zt(aa(f, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return gh(e, t, n, a);
    case "era":
    case "year":
    case "month":
    case "day": {
      let r = ic(Tr(e), t, n, a), o = na(r, e.timeZone);
      return Zt(aa(o, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function ww(e, t, n) {
  let a = Tr(e), r = xl(lc(a, t), t);
  if (r.compare(a) === 0) return e;
  let o = na(r, e.timeZone, n);
  return Zt(aa(o, e.timeZone), e.calendar);
}
function xw(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function bh(e) {
  let t = Zt(e, new An()), n;
  return t.era === "BC" ? n = t.year === 1 ? "0000" : "-" + String(Math.abs(1 - t.year)).padStart(6, "00") : n = String(t.year).padStart(4, "0"), `${n}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function _h(e) {
  return `${bh(e)}T${xw(e)}`;
}
function Cw(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let n = Math.floor(e / 36e5), a = Math.floor(e % 36e5 / 6e4), r = Math.floor(e % 36e5 % 6e4 / 1e3), o = `${t}${String(n).padStart(2, "0")}:${String(a).padStart(2, "0")}`;
  return r !== 0 && (o += `:${String(r).padStart(2, "0")}`), o;
}
function Sw(e) {
  return `${_h(e)}${Cw(e.offset)}[${e.timeZone}]`;
}
function $w(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function uc(e, t, n) {
  $w(e, t), t.set(e, n);
}
function dc(e) {
  let t = typeof e[0] == "object" ? e.shift() : new An(), n;
  if (typeof e[0] == "string") n = e.shift();
  else {
    let s = t.getEras();
    n = s[s.length - 1];
  }
  let a = e.shift(), r = e.shift(), o = e.shift();
  return [
    t,
    n,
    a,
    r,
    o
  ];
}
var Bw = /* @__PURE__ */ new WeakMap();
class St {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new St(this.calendar, this.era, this.year, this.month, this.day) : new St(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return vi(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return hh(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return lc(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return ic(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return ph(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return bh(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return dh(this, t);
  }
  constructor(...t) {
    uc(this, Bw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = dc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, Za(this);
  }
}
var kw = /* @__PURE__ */ new WeakMap();
class Ir {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Ir(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new Ir(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return vi(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return hh(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return lc(xl(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return ic(this, t, n, a);
      default:
        return gh(this, t, n, a);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, n) {
    return ph(this, t, n);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return _h(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let n = dh(this, t);
    return n === 0 ? iw(this, Tr(t)) : n;
  }
  constructor(...t) {
    uc(this, kw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = dc(t);
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, Za(this);
  }
}
var Pw = /* @__PURE__ */ new WeakMap();
class Or {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new Or(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new Or(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return yh(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return bw(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, n) {
    return ww(this, t, n);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return _w(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return pw(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return Sw(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - fw(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    uc(this, Pw, {
      writable: !0,
      value: void 0
    });
    let [n, a, r, o, s] = dc(t), i = t.shift(), u = t.shift();
    this.calendar = n, this.era = a, this.year = r, this.month = o, this.day = s, this.timeZone = i, this.offset = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, Za(this);
  }
}
const kr = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], Mw = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], rl = [
  1867,
  1911,
  1925,
  1988,
  2018
], Ca = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function mp(e) {
  const t = kr.findIndex(([n, a, r]) => e.year < n || e.year === n && e.month < a || e.year === n && e.month === a && e.day < r);
  return t === -1 ? kr.length - 1 : t === 0 ? 0 : t - 1;
}
function hu(e) {
  let t = rl[Ca.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new St(e.year + t, e.month, e.day);
}
class Dw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = mp(n);
    return new St(this, Ca[a], n.year - rl[a], n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(hu(t));
  }
  balanceDate(t) {
    let n = hu(t), a = mp(n);
    Ca[a] !== t.era && (t.era = Ca[a], t.year = n.year - rl[a]), this.constrainDate(t);
  }
  constrainDate(t) {
    let n = Ca.indexOf(t.era), a = Mw[n];
    if (a != null) {
      let [r, o, s] = a, i = r - rl[n];
      t.year = Math.max(1, Math.min(i, t.year)), t.year === i && (t.month = Math.min(o, t.month), t.month === o && (t.day = Math.min(s, t.day)));
    }
    if (t.year === 1 && n >= 0) {
      let [, r, o] = kr[n];
      t.month = Math.max(r, t.month), t.month === r && (t.day = Math.max(o, t.day));
    }
  }
  getEras() {
    return Ca;
  }
  getYearsInEra(t) {
    let n = Ca.indexOf(t.era), a = kr[n], r = kr[n + 1];
    if (r == null)
      return 9999 - a[0] + 1;
    let o = r[0] - a[0];
    return (t.month < r[1] || t.month === r[1] && t.day < r[2]) && o++, o;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(hu(t));
  }
  getMinimumMonthInYear(t) {
    let n = hp(t);
    return n ? n[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let n = hp(t);
    return n && t.month === n[1] ? n[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function hp(e) {
  if (e.year === 1) {
    let t = Ca.indexOf(e.era);
    return kr[t];
  }
}
const wh = -543;
class qw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ss(n.era, n.year);
    return new St(this, a - wh, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(gp(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(gp(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function gp(e) {
  let [t, n] = pi(e.year + wh);
  return new St(t, n, e.month, e.day);
}
const Cl = 1911;
function xh(e) {
  return e.era === "minguo" ? e.year + Cl : 1 - e.year + Cl;
}
function yp(e) {
  let t = e - Cl;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class Aw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = ss(n.era, n.year), [r, o] = yp(a);
    return new St(this, r, o, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay(bp(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [n, a] = yp(xh(t));
    t.era = n, t.year = a;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth(bp(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - Cl;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function bp(e) {
  let [t, n] = pi(xh(e));
  return new St(t, n, e.month, e.day);
}
const _p = 1948320, wp = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class Ew {
  fromJulianDay(t) {
    let n = t - _p, a = 1 + Math.floor((33 * n + 3) / 12053), r = 365 * (a - 1) + Math.floor((8 * a + 21) / 33), o = n - r, s = o < 216 ? Math.floor(o / 31) : Math.floor((o - 6) / 30), i = o - wp[s] + 1;
    return new St(this, a, s + 1, i);
  }
  toJulianDay(t) {
    let n = _p - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return n += wp[t.month - 1], n += t.day, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || Br(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getMaximumMonthsInYear() {
    return 12;
  }
  getMaximumDaysInMonth() {
    return 31;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const gu = 78, xp = 80;
class Tw extends An {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = n.year - gu, r = t - Wa(n.era, n.year, 1, 1), o;
    r < xp ? (a--, o = ka(n.year - 1) ? 31 : 30, r += o + 155 + 90 + 10) : (o = ka(n.year) ? 31 : 30, r -= xp);
    let s, i;
    if (r < o)
      s = 1, i = r + 1;
    else {
      let u = r - o;
      u < 155 ? (s = Math.floor(u / 31) + 2, i = u % 31 + 1) : (u -= 155, s = Math.floor(u / 30) + 7, i = u % 30 + 1);
    }
    return new St(this, a, s, i);
  }
  toJulianDay(t) {
    let n = t.year + gu, [a, r] = pi(n), o, s;
    return ka(r) ? (o = 31, s = Wa(a, r, 3, 21)) : (o = 30, s = Wa(a, r, 3, 22)), t.month === 1 ? s + t.day - 1 : (s += o + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (s += (t.month - 7) * 30), s += t.day - 1, s);
  }
  getDaysInMonth(t) {
    return t.month === 1 && ka(t.year + gu) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const Sl = 1948440, Cp = 1948439, _n = 1300, hr = 1600, Iw = 460322;
function $l(e, t, n, a) {
  return a + Math.ceil(29.5 * (n - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function Ch(e, t, n) {
  let a = Math.floor((30 * (n - t) + 10646) / 10631), r = Math.min(12, Math.ceil((n - (29 + $l(t, a, 1, 1))) / 29.5) + 1), o = n - $l(t, a, r, 1) + 1;
  return new St(e, a, r, o);
}
function Sp(e) {
  return (14 + 11 * e) % 30 < 11;
}
class cc {
  fromJulianDay(t) {
    return Ch(this, Sl, t);
  }
  toJulianDay(t) {
    return $l(Sl, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = 29 + t.month % 2;
    return t.month === 12 && Sp(t.year) && n++, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return Sp(t.year) ? 355 : 354;
  }
  getMaximumMonthsInYear() {
    return 12;
  }
  getMaximumDaysInMonth() {
    return 30;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class Ow extends cc {
  fromJulianDay(t) {
    return Ch(this, Cp, t);
  }
  toJulianDay(t) {
    return $l(Cp, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const Rw = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let rd, Pr;
function ol(e) {
  return Iw + Pr[e - _n];
}
function _o(e, t) {
  let n = e - _n, a = 1 << 11 - (t - 1);
  return (rd[n] & a) === 0 ? 29 : 30;
}
function $p(e, t) {
  let n = ol(e);
  for (let a = 1; a < t; a++) n += _o(e, a);
  return n;
}
function Bp(e) {
  return Pr[e + 1 - _n] - Pr[e - _n];
}
class Vw extends cc {
  fromJulianDay(t) {
    let n = t - Sl, a = ol(_n), r = ol(hr);
    if (n < a || n > r) return super.fromJulianDay(t);
    {
      let o = _n - 1, s = 1, i = 1;
      for (; i > 0; ) {
        o++, i = n - ol(o) + 1;
        let u = Bp(o);
        if (i === u) {
          s = 12;
          break;
        } else if (i < u) {
          let d = _o(o, s);
          for (s = 1; i > d; )
            i -= d, s++, d = _o(o, s);
          break;
        }
      }
      return new St(this, o, s, n - $p(o, s) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < _n || t.year > hr ? super.toJulianDay(t) : Sl + $p(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < _n || t.year > hr ? super.getDaysInMonth(t) : _o(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < _n || t.year > hr ? super.getDaysInYear(t) : Bp(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", rd || (rd = new Uint16Array(Uint8Array.from(atob(Rw), (t) => t.charCodeAt(0)).buffer)), !Pr) {
      Pr = new Uint32Array(hr - _n + 1);
      let t = 0;
      for (let n = _n; n <= hr; n++) {
        Pr[n - _n] = t;
        for (let a = 1; a <= 12; a++) t += _o(n, a);
      }
    }
  }
}
const kp = 347997, Sh = 1080, $h = 24 * Sh, Fw = 29, Nw = 12 * Sh + 793, Lw = Fw * $h + Nw;
function ja(e) {
  return Br(e * 7 + 1, 19) < 7;
}
function sl(e) {
  let t = Math.floor((235 * e - 234) / 19), n = 12084 + 13753 * t, a = t * 29 + Math.floor(n / 25920);
  return Br(3 * (a + 1), 7) < 3 && (a += 1), a;
}
function zw(e) {
  let t = sl(e - 1), n = sl(e);
  return sl(e + 1) - n === 356 ? 2 : n - t === 382 ? 1 : 0;
}
function Po(e) {
  return sl(e) + zw(e);
}
function Bh(e) {
  return Po(e + 1) - Po(e);
}
function Hw(e) {
  let t = Bh(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    // deficient
    case 354:
      return 1;
    // normal
    case 355:
      return 2;
  }
}
function Ts(e, t) {
  if (t >= 6 && !ja(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let n = Hw(e);
  return t === 2 ? n === 2 ? 30 : 29 : t === 3 ? n === 0 ? 29 : 30 : t === 6 ? ja(e) ? 30 : 0 : 30;
}
class Uw {
  fromJulianDay(t) {
    let n = t - kp, a = n * $h / Lw, r = Math.floor((19 * a + 234) / 235) + 1, o = Po(r), s = Math.floor(n - o);
    for (; s < 1; )
      r--, o = Po(r), s = Math.floor(n - o);
    let i = 1, u = 0;
    for (; u < s; )
      u += Ts(r, i), i++;
    i--, u -= Ts(r, i);
    let d = s - u;
    return new St(this, r, i, d);
  }
  toJulianDay(t) {
    let n = Po(t.year);
    for (let a = 1; a < t.month; a++) n += Ts(t.year, a);
    return n + t.day + kp;
  }
  getDaysInMonth(t) {
    return Ts(t.year, t.month);
  }
  getMonthsInYear(t) {
    return ja(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return Bh(t.year);
  }
  getMaximumMonthsInYear() {
    return 13;
  }
  getMaximumDaysInMonth() {
    return 30;
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, n) {
    n.year !== t.year && (ja(n.year) && !ja(t.year) && n.month > 6 ? t.month-- : !ja(n.year) && ja(t.year) && n.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const od = 1723856, Pp = 1824665, sd = 5500;
function Bl(e, t, n, a) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (n - 1) + a - 1;
}
function fc(e, t) {
  let n = Math.floor(4 * (t - e) / 1461), a = 1 + Math.floor((t - Bl(e, n, 1, 1)) / 30), r = t + 1 - Bl(e, n, a, 1);
  return [
    n,
    a,
    r
  ];
}
function kh(e) {
  return Math.floor(e % 4 / 3);
}
function Ph(e, t) {
  return t % 13 !== 0 ? 30 : kh(e) + 5;
}
class pc {
  fromJulianDay(t) {
    let [n, a, r] = fc(od, t), o = "AM";
    return n <= 0 && (o = "AA", n += sd), new St(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "AA" && (n -= sd), Bl(od, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    return Ph(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + kh(t.year);
  }
  getMaximumMonthsInYear() {
    return 13;
  }
  getMaximumDaysInMonth() {
    return 30;
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class jw extends pc {
  fromJulianDay(t) {
    let [n, a, r] = fc(od, t);
    return n += sd, new St(this, "AA", n, a, r);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class Ww extends pc {
  fromJulianDay(t) {
    let [n, a, r] = fc(Pp, t), o = "CE";
    return n <= 0 && (o = "BCE", n = 1 - n), new St(this, o, n, a, r);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Bl(Pp, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), Ph(n, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function Gw(e) {
  switch (e) {
    case "buddhist":
      return new qw();
    case "ethiopic":
      return new pc();
    case "ethioaa":
      return new jw();
    case "coptic":
      return new Ww();
    case "hebrew":
      return new Uw();
    case "indian":
      return new Tw();
    case "islamic-civil":
      return new cc();
    case "islamic-tbla":
      return new Ow();
    case "islamic-umalqura":
      return new Vw();
    case "japanese":
      return new Dw();
    case "persian":
      return new Ew();
    case "roc":
      return new Aw();
    default:
      return new An();
  }
}
let yu = /* @__PURE__ */ new Map();
class ta {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)}  ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.formatter.formatToParts(t), r = this.formatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return Xw() && (this.resolvedHourCycle || (this.resolvedHourCycle = Jw(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, n = {}) {
    this.formatter = Mh(t, n), this.options = n;
  }
}
const Kw = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function Mh(e, t = {}) {
  if (typeof t.hour12 == "boolean" && Yw()) {
    t = {
      ...t
    };
    let r = Kw[String(t.hour12)][e.split("-")[0]], o = t.hour12 ? "h12" : "h23";
    t.hourCycle = r ?? o, delete t.hour12;
  }
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : "");
  if (yu.has(n)) return yu.get(n);
  let a = new Intl.DateTimeFormat(e, t);
  return yu.set(n, a), a;
}
let bu = null;
function Yw() {
  return bu == null && (bu = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), bu;
}
let _u = null;
function Xw() {
  return _u == null && (_u = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), _u;
}
function Jw(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = Mh(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), a = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((o) => o.type === "hour").value, 10), r = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((o) => o.type === "hour").value, 10);
  if (a === 0 && r === 23) return "h23";
  if (a === 24 && r === 23) return "h24";
  if (a === 0 && r === 11) return "h11";
  if (a === 12 && r === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function $n(e, t = jr()) {
  return vc(e) ? e.toDate() : e.toDate(t);
}
function Zw(e) {
  return e instanceof Ir;
}
function vc(e) {
  return e instanceof Or;
}
function Qw(e) {
  return Zw(e) || vc(e);
}
function Io(e) {
  if (e instanceof Date) {
    const t = e.getFullYear(), n = e.getMonth() + 1;
    return new Date(t, n, 0).getDate();
  } else return e.set({ day: 100 }).day;
}
function Xa(e, t) {
  return e.compare(t) < 0;
}
function ll(e, t) {
  return e.compare(t) > 0;
}
function e1(e, t) {
  return e.compare(t) <= 0;
}
function t1(e, t) {
  return e.compare(t) >= 0;
}
function n1(e, t, n) {
  return t1(e, t) && e1(e, n);
}
function wu(e, t, n) {
  return ll(e, t) && Xa(e, n);
}
function a1(e, t, n) {
  const a = ih(e, n, "sun");
  return t > a ? e.subtract({ days: a + 7 - t }) : t === a ? e : e.subtract({ days: a - t });
}
function r1(e, t, n) {
  const a = ih(e, n, "sun"), r = t === 0 ? 6 : t - 1;
  return a === r ? e : a > r ? e.add({ days: 7 - a + r }) : e.add({ days: r - a });
}
function o1(e, t, n, a, r) {
  if (n === void 0 && a === void 0 && r === void 0) return !0;
  let o = e.add({ days: 1 });
  if ((a?.(o) || n?.(o)) && !r?.(o)) return !1;
  const s = t;
  for (; o.compare(s) < 0; )
    if (o = o.add({ days: 1 }), (a?.(o) || n?.(o)) && !r?.(o)) return !1;
  return !0;
}
function Dh(e) {
  const { defaultValue: t, defaultPlaceholder: n, granularity: a = "day", locale: r = "en" } = e;
  if (Array.isArray(t) && t.length) return t.at(-1).copy();
  if (t && !Array.isArray(t)) return t.copy();
  if (n) return n.copy();
  const o = /* @__PURE__ */ new Date(), s = o.getFullYear(), i = o.getMonth() + 1, u = o.getDate(), d = [
    "hour",
    "minute",
    "second"
  ], c = new ta(r), f = Gw(c.resolvedOptions().calendar);
  return d.includes(a ?? "day") ? Zt(new Ir(s, i, u, 0, 0, 0), f) : Zt(new St(s, i, u), f);
}
function s1(e, t) {
  const n = [];
  for (let a = 0; a < e.length; a += t) n.push(e.slice(a, a + t));
  return n;
}
function qh(e) {
  const t = e.querySelector("[data-selected]");
  if (t) return t.focus();
  const n = e.querySelector("[data-today]");
  if (n) return n.focus();
  const a = e.querySelector("[data-reka-calendar-day]");
  if (a) return a.focus();
}
function ld(e, t) {
  const n = [];
  let a = e.add({ days: 1 });
  const r = t;
  for (; a.compare(r) < 0; )
    n.push(a), a = a.add({ days: 1 });
  return n;
}
function xu(e) {
  const { dateObj: t, weekStartsOn: n, fixedWeeks: a, locale: r } = e, o = Io(t), s = Array.from({ length: o }, (x, C) => t.set({ day: C + 1 })), i = ed(t), u = fp(t), d = a1(i, n, r), c = r1(u, n, r), f = ld(d.subtract({ days: 1 }), i), p = ld(u, c.add({ days: 1 })), v = f.length + s.length + p.length;
  if (a && v < 42) {
    const x = 42 - v;
    let C = p[p.length - 1];
    C || (C = fp(t));
    const S = Array.from({ length: x }, ($, k) => {
      const B = k + 1;
      return C.add({ days: B });
    });
    p.push(...S);
  }
  const m = f.concat(s, p), y = s1(m, 7);
  return {
    value: t,
    cells: m,
    rows: y
  };
}
function Na(e) {
  const { numberOfMonths: t, dateObj: n, ...a } = e, r = [];
  if (!t || t === 1)
    return r.push(xu({
      ...a,
      dateObj: n
    })), r;
  r.push(xu({
    ...a,
    dateObj: n
  }));
  for (let o = 1; o < t; o++) {
    const s = n.add({ months: o });
    r.push(xu({
      ...a,
      dateObj: s
    }));
  }
  return r;
}
function l1(e, t = {}) {
  const n = I(e);
  function a() {
    return n.value;
  }
  function r(x) {
    n.value = x;
  }
  function o(x, C) {
    return new ta(n.value, {
      ...t,
      ...C
    }).format(x);
  }
  function s(x, C = !0) {
    return Qw(x) && C ? o($n(x), {
      dateStyle: "long",
      timeStyle: "long"
    }) : o($n(x), { dateStyle: "long" });
  }
  function i(x, C = {}) {
    return new ta(n.value, {
      ...t,
      month: "long",
      year: "numeric",
      ...C
    }).format(x);
  }
  function u(x, C = {}) {
    return new ta(n.value, {
      ...t,
      month: "long",
      ...C
    }).format(x);
  }
  function d() {
    const x = uh(jr());
    return [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12
    ].map((S) => ({
      label: u($n(x.set({ month: S }))),
      value: S
    }));
  }
  function c(x, C = {}) {
    return new ta(n.value, {
      ...t,
      year: "numeric",
      ...C
    }).format(x);
  }
  function f(x, C) {
    return vc(x) ? new ta(n.value, {
      ...t,
      ...C,
      timeZone: x.timeZone
    }).formatToParts($n(x)) : new ta(n.value, {
      ...t,
      ...C
    }).formatToParts($n(x));
  }
  function p(x, C = "narrow") {
    return new ta(n.value, {
      ...t,
      weekday: C
    }).format(x);
  }
  function v(x) {
    const S = new ta(n.value, {
      ...t,
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(x).find(($) => $.type === "dayPeriod")?.value;
    return S === "PM" || S === "pm" || S === "p.m." ? "PM" : "AM";
  }
  const m = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function y(x, C, S = {}) {
    const $ = {
      ...m,
      ...S
    }, B = f(x, $).find((P) => P.type === C);
    return B ? B.value : "";
  }
  return {
    setLocale: r,
    getLocale: a,
    fullMonth: u,
    fullYear: c,
    fullMonthAndYear: i,
    toParts: f,
    custom: o,
    part: y,
    dayPeriod: v,
    selectedDate: s,
    dayOfWeek: p,
    getMonths: d
  };
}
function gt(e) {
  const t = as({ dir: I("ltr") });
  return A(() => e?.value || t.dir?.value || "ltr");
}
function Gt(e) {
  const t = zt(), n = t?.type.emits, a = {};
  return n?.length || console.warn(`No emitted event found. Please check component: ${t?.type.__name}`), n?.forEach((r) => {
    a[Q_(yl(r))] = (...o) => e(r, ...o);
  }), a;
}
function Ah(e) {
  const t = A(() => l(e)), n = A(() => new Intl.Collator("en", {
    usage: "search",
    ...t.value
  }));
  return {
    startsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(0, i.length), i) === 0),
    endsWith: (s, i) => i.length === 0 ? !0 : (s = s.normalize("NFC"), i = i.normalize("NFC"), n.value.compare(s.slice(-i.length), i) === 0),
    contains: (s, i) => {
      if (i.length === 0) return !0;
      s = s.normalize("NFC"), i = i.normalize("NFC");
      let u = 0;
      const d = i.length;
      for (; u + d <= s.length; u++) {
        const c = s.slice(u, u + d);
        if (n.value.compare(i, c) === 0) return !0;
      }
      return !1;
    }
  };
}
let Cu = 0;
function mi() {
  Te((e) => {
    if (!Ut) return;
    const t = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", t[0] ?? Mp()), document.body.insertAdjacentElement("beforeend", t[1] ?? Mp()), Cu++, e(() => {
      Cu === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((n) => n.remove()), Cu--;
    });
  });
}
function Mp() {
  const e = document.createElement("span");
  return e.setAttribute("data-reka-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
function In(e) {
  return A(() => pe(e) ? !!jt(e)?.closest("form") : !0);
}
function j() {
  const e = zt(), t = I(), n = A(() => ["#text", "#comment"].includes(t.value?.$el.nodeName) ? t.value?.$el.nextElementSibling : jt(t)), a = Object.assign({}, e.exposed), r = {};
  for (const s in e.props) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => e.props[s]
  });
  if (Object.keys(a).length > 0) for (const s in a) Object.defineProperty(r, s, {
    enumerable: !0,
    configurable: !0,
    get: () => a[s]
  });
  Object.defineProperty(r, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = r;
  function o(s) {
    if (t.value = s, !!s && (Object.defineProperty(r, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => s instanceof Element ? s : s.$el
    }), !(s instanceof Element) && !Object.hasOwn(s, "$el"))) {
      const i = s.$.exposed, u = Object.assign({}, r);
      for (const d in i) Object.defineProperty(u, d, {
        enumerable: !0,
        configurable: !0,
        get: () => i[d]
      });
      e.exposed = u;
    }
  }
  return {
    forwardRef: o,
    currentRef: t,
    currentElement: n
  };
}
function he(e) {
  const t = zt(), n = Object.keys(t?.type.props ?? {}).reduce((r, o) => {
    const s = (t?.type.props[o]).default;
    return s !== void 0 && (r[o] = s), r;
  }, {}), a = Hn(e);
  return A(() => {
    const r = {}, o = t?.vnode.props ?? {};
    return Object.keys(o).forEach((s) => {
      r[yl(s)] = o[s];
    }), Object.keys({
      ...n,
      ...r
    }).reduce((s, i) => (a.value[i] !== void 0 && (s[i] = a.value[i]), s), {});
  });
}
function ve(e, t) {
  const n = he(e), a = t ? Gt(t) : {};
  return A(() => ({
    ...n.value,
    ...a
  }));
}
function Eh(e, t) {
  const n = rs(!1, 300);
  Ta(() => {
    n.value = !1;
  });
  const a = I(null), r = /* @__PURE__ */ Sr();
  function o() {
    a.value = null, n.value = !1;
  }
  function s(i, u) {
    const d = i.currentTarget, c = {
      x: i.clientX,
      y: i.clientY
    }, f = i1(c, d.getBoundingClientRect()), p = u1(c, f, 1), v = d1(u.getBoundingClientRect()), m = f1([...p, ...v]);
    a.value = m, n.value = !0;
  }
  return Te((i) => {
    if (e.value && t.value) {
      const u = (c) => s(c, t.value), d = (c) => s(c, e.value);
      e.value.addEventListener("pointerleave", u), t.value.addEventListener("pointerleave", d), i(() => {
        e.value?.removeEventListener("pointerleave", u), t.value?.removeEventListener("pointerleave", d);
      });
    }
  }), Te((i) => {
    if (a.value) {
      const u = (d) => {
        if (!a.value || !(d.target instanceof Element)) return;
        const c = d.target, f = {
          x: d.clientX,
          y: d.clientY
        }, p = e.value?.contains(c) || t.value?.contains(c), v = !c1(f, a.value), m = !!c.closest("[data-grace-area-trigger]");
        p ? o() : (v || m) && (o(), r.trigger());
      };
      e.value?.ownerDocument.addEventListener("pointermove", u), i(() => e.value?.ownerDocument.removeEventListener("pointermove", u));
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: r.on
  };
}
function i1(e, t) {
  const n = Math.abs(t.top - e.y), a = Math.abs(t.bottom - e.y), r = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x);
  switch (Math.min(n, a, r, o)) {
    case o:
      return "left";
    case r:
      return "right";
    case n:
      return "top";
    case a:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function u1(e, t, n = 5) {
  const a = [];
  switch (t) {
    case "top":
      a.push({
        x: e.x - n,
        y: e.y + n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "bottom":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y - n
      });
      break;
    case "left":
      a.push({
        x: e.x + n,
        y: e.y - n
      }, {
        x: e.x + n,
        y: e.y + n
      });
      break;
    case "right":
      a.push({
        x: e.x - n,
        y: e.y - n
      }, {
        x: e.x - n,
        y: e.y + n
      });
      break;
  }
  return a;
}
function d1(e) {
  const { top: t, right: n, bottom: a, left: r } = e;
  return [
    {
      x: r,
      y: t
    },
    {
      x: n,
      y: t
    },
    {
      x: n,
      y: a
    },
    {
      x: r,
      y: a
    }
  ];
}
function c1(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function f1(e) {
  const t = e.slice();
  return t.sort((n, a) => n.x < a.x ? -1 : n.x > a.x ? 1 : n.y < a.y ? -1 : n.y > a.y ? 1 : 0), p1(t);
}
function p1(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let a = 0; a < e.length; a++) {
    const r = e[a];
    for (; t.length >= 2; ) {
      const o = t[t.length - 1], s = t[t.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) t.pop();
      else break;
    }
    t.push(r);
  }
  t.pop();
  const n = [];
  for (let a = e.length - 1; a >= 0; a--) {
    const r = e[a];
    for (; n.length >= 2; ) {
      const o = n[n.length - 1], s = n[n.length - 2];
      if ((o.x - s.x) * (r.y - s.y) >= (o.y - s.y) * (r.x - s.x)) n.pop();
      else break;
    }
    n.push(r);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var v1 = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, gr = /* @__PURE__ */ new WeakMap(), Is = /* @__PURE__ */ new WeakMap(), Os = {}, Su = 0, Th = function(e) {
  return e && (e.host || Th(e.parentNode));
}, m1 = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var a = Th(n);
    return a && e.contains(a) ? a : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, h1 = function(e, t, n, a) {
  var r = m1(t, Array.isArray(e) ? e : [e]);
  Os[n] || (Os[n] = /* @__PURE__ */ new WeakMap());
  var o = Os[n], s = [], i = /* @__PURE__ */ new Set(), u = new Set(r), d = function(f) {
    !f || i.has(f) || (i.add(f), d(f.parentNode));
  };
  r.forEach(d);
  var c = function(f) {
    !f || u.has(f) || Array.prototype.forEach.call(f.children, function(p) {
      if (i.has(p))
        c(p);
      else
        try {
          var v = p.getAttribute(a), m = v !== null && v !== "false", y = (gr.get(p) || 0) + 1, x = (o.get(p) || 0) + 1;
          gr.set(p, y), o.set(p, x), s.push(p), y === 1 && m && Is.set(p, !0), x === 1 && p.setAttribute(n, "true"), m || p.setAttribute(a, "true");
        } catch (C) {
          console.error("aria-hidden: cannot operate on ", p, C);
        }
    });
  };
  return c(t), i.clear(), Su++, function() {
    s.forEach(function(f) {
      var p = gr.get(f) - 1, v = o.get(f) - 1;
      gr.set(f, p), o.set(f, v), p || (Is.has(f) || f.removeAttribute(a), Is.delete(f)), v || f.removeAttribute(n);
    }), Su--, Su || (gr = /* @__PURE__ */ new WeakMap(), gr = /* @__PURE__ */ new WeakMap(), Is = /* @__PURE__ */ new WeakMap(), Os = {});
  };
}, g1 = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), r = v1(e);
  return r ? (a.push.apply(a, Array.from(r.querySelectorAll("[aria-live], script"))), h1(a, r, n, "aria-hidden")) : function() {
    return null;
  };
};
function ls(e) {
  let t;
  me(() => jt(e), (n) => {
    n ? t = g1(n) : t && t();
  }), nt(() => {
    t && t();
  });
}
let y1 = 0;
function Ke(e, t = "reka") {
  if (e) return e;
  if ("useId" in ap) return `${t}-${ap.useId?.()}`;
  const n = as({ useId: void 0 });
  return n.useId ? `${t}-${n.useId()}` : `${t}-${++y1}`;
}
function is() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
function mc(e) {
  const t = as({ locale: I("en") });
  return A(() => e?.value || t.locale?.value || "en");
}
function Ih(e) {
  const t = I(), n = A(() => t.value?.width ?? 0), a = A(() => t.value?.height ?? 0);
  return Ce(() => {
    const r = jt(e);
    if (r) {
      t.value = {
        width: r.offsetWidth,
        height: r.offsetHeight
      };
      const o = new ResizeObserver((s) => {
        if (!Array.isArray(s) || !s.length) return;
        const i = s[0];
        let u, d;
        if ("borderBoxSize" in i) {
          const c = i.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          u = f.inlineSize, d = f.blockSize;
        } else
          u = r.offsetWidth, d = r.offsetHeight;
        t.value = {
          width: u,
          height: d
        };
      });
      return o.observe(r, { box: "border-box" }), () => o.unobserve(r);
    } else t.value = void 0;
  }), {
    width: n,
    height: a
  };
}
function hc(e, t) {
  const n = I(e);
  function a(o) {
    return t[n.value][o] ?? n.value;
  }
  return {
    state: n,
    dispatch: (o) => {
      n.value = a(o);
    }
  };
}
function hi(e) {
  const t = rs("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (r, o) => {
      t.value = t.value + r;
      {
        const s = rt(), i = o.map((p) => ({
          ...p,
          textValue: p.value?.textValue ?? p.ref.textContent?.trim() ?? ""
        })), u = i.find((p) => p.ref === s), d = i.map((p) => p.textValue), c = b1(d, t.value, u?.textValue), f = i.find((p) => p.textValue === c);
        return f && f.ref.focus(), f?.ref;
      }
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function gc(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
function b1(e, t, n) {
  const r = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, o = n ? e.indexOf(n) : -1;
  let s = gc(e, Math.max(o, 0));
  r.length === 1 && (s = s.filter((d) => d !== n));
  const u = s.find((d) => d.toLowerCase().startsWith(r.toLowerCase()));
  return u !== n ? u : void 0;
}
function _1(e, t) {
  const n = I({}), a = I("none"), r = I(e), o = e.value ? "mounted" : "unmounted";
  let s;
  const i = t.value?.ownerDocument.defaultView ?? va, { state: u, dispatch: d } = hc(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  }), c = (x) => {
    if (Ut) {
      const C = new CustomEvent(x, {
        bubbles: !1,
        cancelable: !1
      });
      t.value?.dispatchEvent(C);
    }
  };
  me(e, async (x, C) => {
    const S = C !== x;
    if (await Pe(), S) {
      const $ = a.value, k = Rs(t.value);
      x ? (d("MOUNT"), c("enter"), k === "none" && c("after-enter")) : k === "none" || k === "undefined" || n.value?.display === "none" ? (d("UNMOUNT"), c("leave"), c("after-leave")) : C && $ !== k ? (d("ANIMATION_OUT"), c("leave")) : (d("UNMOUNT"), c("after-leave"));
    }
  }, { immediate: !0 });
  const f = (x) => {
    const C = Rs(t.value), S = C.includes(CSS.escape(x.animationName)), $ = u.value === "mounted" ? "enter" : "leave";
    if (x.target === t.value && S && (c(`after-${$}`), d("ANIMATION_END"), !r.value)) {
      const k = t.value.style.animationFillMode;
      t.value.style.animationFillMode = "forwards", s = i?.setTimeout(() => {
        t.value?.style.animationFillMode === "forwards" && (t.value.style.animationFillMode = k);
      });
    }
    x.target === t.value && C === "none" && d("ANIMATION_END");
  }, p = (x) => {
    x.target === t.value && (a.value = Rs(t.value));
  }, v = me(t, (x, C) => {
    x ? (n.value = getComputedStyle(x), x.addEventListener("animationstart", p), x.addEventListener("animationcancel", f), x.addEventListener("animationend", f)) : (d("ANIMATION_END"), s !== void 0 && i?.clearTimeout(s), C?.removeEventListener("animationstart", p), C?.removeEventListener("animationcancel", f), C?.removeEventListener("animationend", f));
  }, { immediate: !0 }), m = me(u, () => {
    const x = Rs(t.value);
    a.value = u.value === "mounted" ? x : "none";
  });
  return nt(() => {
    v(), m();
  }), { isPresent: A(() => ["mounted", "unmountSuspended"].includes(u.value)) };
}
function Rs(e) {
  return e && getComputedStyle(e).animationName || "none";
}
var yt = b({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(e, { slots: t, expose: n }) {
    const { present: a, forceMount: r } = qe(e), o = I(), { isPresent: s } = _1(a, o);
    n({ present: s });
    let i = t.default({ present: s.value });
    i = tc(i || []);
    const u = zt();
    if (i && i?.length > 1) {
      const d = u?.parent?.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${d}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((c) => `  - ${c}`).join(`
`)
      ].join(`
`));
    }
    return () => r.value || a.value || s.value ? tn(t.default({ present: s.value })[0], { ref: (d) => {
      const c = jt(d);
      return typeof c?.hasAttribute > "u" || (c?.hasAttribute("data-reka-popper-content-wrapper") ? o.value = c.firstElementChild : o.value = c), c;
    } }) : null;
  }
});
const kl = b({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: t, slots: n }) {
    return () => {
      if (!n.default) return null;
      const a = tc(n.default()), r = a.findIndex((u) => u.type !== e0);
      if (r === -1) return a;
      const o = a[r];
      delete o.props?.ref;
      const s = o.props ? T(t, o.props) : t, i = t0({
        ...o,
        props: {}
      }, s);
      return a.length === 1 ? i : (a[r] = i, a);
    };
  }
}), w1 = [
  "area",
  "img",
  "input"
], X = b({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: t, slots: n }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && w1.includes(a) ? () => tn(a, t) : a !== "template" ? () => tn(e.as, t, { default: n.default }) : () => tn(kl, t, { default: n.default });
  }
});
function Lt() {
  const e = I(), t = A(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : jt(e));
  return {
    primitiveElement: e,
    currentElement: t
  };
}
const [Oh, x1] = Se("CollapsibleRoot");
var C1 = /* @__PURE__ */ b({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = /* @__PURE__ */ Ie(a, "open", n, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), { disabled: s, unmountOnHide: i } = qe(a);
    return x1({
      contentId: "",
      disabled: s,
      open: o,
      unmountOnHide: i,
      onOpenToggle: () => {
        s.value || (o.value = !o.value);
      }
    }), t({ open: o }), j(), (u, d) => (h(), w(l(X), {
      as: u.as,
      "as-child": a.asChild,
      "data-state": l(o) ? "open" : "closed",
      "data-disabled": l(s) ? "" : void 0
    }, {
      default: g(() => [_(u.$slots, "default", { open: l(o) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ]));
  }
}), Rh = C1, S1 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["contentFound"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Oh();
    r.contentId ||= Ke(void 0, "reka-collapsible-content");
    const o = I(), { forwardRef: s, currentElement: i } = j(), u = I(0), d = I(0), c = A(() => r.open.value), f = I(c.value), p = I();
    me(() => [c.value, o.value?.present], async () => {
      await Pe();
      const m = i.value;
      if (!m) return;
      p.value = p.value || {
        transitionDuration: m.style.transitionDuration,
        animationName: m.style.animationName
      }, m.style.transitionDuration = "0s", m.style.animationName = "none";
      const y = m.getBoundingClientRect();
      d.value = y.height, u.value = y.width, f.value || (m.style.transitionDuration = p.value.transitionDuration, m.style.animationName = p.value.animationName);
    }, { immediate: !0 });
    const v = A(() => f.value && r.open.value);
    return Ce(() => {
      requestAnimationFrame(() => {
        f.value = !1;
      });
    }), ct(i, "beforematch", (m) => {
      requestAnimationFrame(() => {
        r.onOpenToggle(), a("contentFound");
      });
    }), (m, y) => (h(), w(l(yt), {
      ref_key: "presentRef",
      ref: o,
      present: m.forceMount || l(r).open.value,
      "force-mount": !0
    }, {
      default: g(({ present: x }) => [N(l(X), T(m.$attrs, {
        id: l(r).contentId,
        ref: l(s),
        "as-child": n.asChild,
        as: m.as,
        hidden: x ? void 0 : l(r).unmountOnHide.value ? "" : "until-found",
        "data-state": v.value ? void 0 : l(r).open.value ? "open" : "closed",
        "data-disabled": l(r).disabled?.value ? "" : void 0,
        style: {
          "--reka-collapsible-content-height": `${d.value}px`,
          "--reka-collapsible-content-width": `${u.value}px`
        }
      }), {
        default: g(() => [!l(r).unmountOnHide.value || x ? _(m.$slots, "default", { key: 0 }) : De("v-if", !0)]),
        _: 2
      }, 1040, [
        "id",
        "as-child",
        "as",
        "hidden",
        "data-state",
        "data-disabled",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Vh = S1, $1 = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Oh();
    return (a, r) => (h(), w(l(X), {
      type: a.as === "button" ? "button" : void 0,
      as: a.as,
      "as-child": t.asChild,
      "aria-controls": l(n).contentId,
      "aria-expanded": l(n).open.value,
      "data-state": l(n).open.value ? "open" : "closed",
      "data-disabled": l(n).disabled?.value ? "" : void 0,
      disabled: l(n).disabled?.value,
      onClick: l(n).onOpenToggle
    }, {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "aria-controls",
      "aria-expanded",
      "data-state",
      "data-disabled",
      "disabled",
      "onClick"
    ]));
  }
}), Fh = $1;
function B1({ type: e, defaultValue: t, modelValue: n }) {
  const a = n || t;
  return n !== void 0 || t !== void 0 ? Array.isArray(a) ? "multiple" : "single" : e ?? "single";
}
function k1({ type: e, defaultValue: t, modelValue: n }) {
  return e || B1({
    type: e,
    defaultValue: t,
    modelValue: n
  });
}
function P1({ type: e, defaultValue: t }) {
  return t !== void 0 ? t : e === "single" ? void 0 : [];
}
function Nh(e, t) {
  const n = A(() => k1(e)), a = /* @__PURE__ */ Ie(e, "modelValue", t, {
    defaultValue: P1(e),
    passive: e.modelValue === void 0,
    deep: !0
  });
  function r(s) {
    if (n.value === "single") a.value = Dn(s, a.value) ? void 0 : s;
    else {
      const i = Array.isArray(a.value) ? [...a.value || []] : [a.value].filter(Boolean);
      if (bl(i, s)) {
        const u = i.findIndex((d) => Dn(d, s));
        i.splice(u, 1);
      } else i.push(s);
      a.value = i;
    }
  }
  const o = A(() => n.value === "single");
  return {
    modelValue: a,
    changeModelValue: r,
    isSingle: o
  };
}
const [gi, M1] = Se("AccordionRoot");
var D1 = /* @__PURE__ */ b({
  __name: "AccordionRoot",
  props: {
    collapsible: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, disabled: o, unmountOnHide: s } = qe(n), i = gt(r), { modelValue: u, changeModelValue: d, isSingle: c } = Nh(n, a), { forwardRef: f, currentElement: p } = j();
    return M1({
      disabled: o,
      direction: i,
      orientation: n.orientation,
      parentElement: p,
      isSingle: c,
      collapsible: n.collapsible,
      modelValue: u,
      changeModelValue: d,
      unmountOnHide: s
    }), (v, m) => (h(), w(l(X), {
      ref: l(f),
      "as-child": v.asChild,
      as: v.as
    }, {
      default: g(() => [_(v.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), q1 = D1, id = /* @__PURE__ */ (function(e) {
  return e.Open = "open", e.Closed = "closed", e;
})(id || {});
const [yc, A1] = Se("AccordionItem");
var E1 = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: String,
      required: !0
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = gi(), r = A(() => a.isSingle.value ? n.value === a.modelValue.value : Array.isArray(a.modelValue.value) && a.modelValue.value.includes(n.value)), o = A(() => a.disabled.value || n.disabled), s = A(() => o.value ? "" : void 0), i = A(() => r.value ? id.Open : id.Closed);
    t({
      open: r,
      dataDisabled: s
    });
    const { currentRef: u, currentElement: d } = j();
    A1({
      open: r,
      dataState: i,
      disabled: o,
      dataDisabled: s,
      triggerId: "",
      currentRef: u,
      currentElement: d,
      value: A(() => n.value)
    });
    function c(f) {
      const p = f.target;
      if (Array.from(a.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []).findIndex((y) => y === p) === -1) return null;
      rr(f, p, a.parentElement.value, {
        arrowKeyOptions: a.orientation,
        dir: a.direction.value,
        focus: !0
      });
    }
    return (f, p) => (h(), w(l(Rh), {
      "data-orientation": l(a).orientation,
      "data-disabled": s.value,
      "data-state": i.value,
      disabled: o.value,
      open: r.value,
      as: n.as,
      "as-child": n.asChild,
      "unmount-on-hide": n.unmountOnHide ?? l(a).unmountOnHide.value,
      onKeydown: Je(c, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end"
      ])
    }, {
      default: g(() => [_(f.$slots, "default", { open: r.value })]),
      _: 3
    }, 8, [
      "data-orientation",
      "data-disabled",
      "data-state",
      "disabled",
      "open",
      "as",
      "as-child",
      "unmount-on-hide"
    ]));
  }
}), T1 = E1, I1 = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = gi(), a = yc();
    return j(), (r, o) => (h(), w(l(Vh), {
      role: "region",
      "as-child": t.asChild,
      as: r.as,
      "force-mount": t.forceMount,
      "aria-labelledby": l(a).triggerId,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      style: {
        "--reka-accordion-content-width": "var(--reka-collapsible-content-width)",
        "--reka-accordion-content-height": "var(--reka-collapsible-content-height)"
      },
      onContentFound: o[0] || (o[0] = (s) => l(n).changeModelValue(l(a).value.value))
    }, {
      default: g(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "force-mount",
      "aria-labelledby",
      "data-state",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), O1 = I1, R1 = /* @__PURE__ */ b({
  __name: "AccordionHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h3"
    }
  },
  setup(e) {
    const t = e, n = gi(), a = yc();
    return j(), (r, o) => (h(), w(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      "data-disabled": l(a).dataDisabled.value
    }, {
      default: g(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-orientation",
      "data-state",
      "data-disabled"
    ]));
  }
}), V1 = R1, F1 = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = gi(), a = yc();
    a.triggerId ||= Ke(void 0, "reka-accordion-trigger");
    function r() {
      const o = n.isSingle.value && a.open.value && !n.collapsible;
      a.disabled.value || o || n.changeModelValue(a.value.value);
    }
    return (o, s) => (h(), w(l(Fh), {
      id: l(a).triggerId,
      ref: l(a).currentRef,
      "data-reka-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-disabled": l(a).disabled.value || void 0,
      "aria-expanded": l(a).open.value || !1,
      "data-disabled": l(a).dataDisabled.value,
      "data-orientation": l(n).orientation,
      "data-state": l(a).dataState.value,
      disabled: l(a).disabled.value,
      onClick: r
    }, {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "aria-disabled",
      "aria-expanded",
      "data-disabled",
      "data-orientation",
      "data-state",
      "disabled"
    ]));
  }
}), N1 = F1;
const [Xn, L1] = Se("DialogRoot");
var z1 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ie(n, "open", t, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = I(), s = I(), { modal: i } = qe(n);
    return L1({
      open: r,
      modal: i,
      openModal: () => {
        r.value = !0;
      },
      onOpenChange: (u) => {
        r.value = u;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: o,
      contentElement: s
    }), (u, d) => _(u.$slots, "default", {
      open: l(r),
      close: () => r.value = !1
    });
  }
}), yi = z1, H1 = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Xn();
    return (a, r) => (h(), w(l(X), T(t, {
      type: a.as === "button" ? "button" : void 0,
      onClick: r[0] || (r[0] = (o) => l(n).onOpenChange(!1))
    }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), Ia = H1;
const U1 = "dismissableLayer.pointerDownOutside", j1 = "dismissableLayer.focusOutside";
function Lh(e, t) {
  const n = t.closest("[data-dismissable-layer]"), a = e.dataset.dismissableLayer === "" ? e : e.querySelector("[data-dismissable-layer]"), r = Array.from(e.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  return !!(n && (a === n || r.indexOf(a) < r.indexOf(n)));
}
function W1(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = I(!1), o = I(() => {
  });
  return Te((s) => {
    if (!Ut || !pe(n)) return;
    const i = async (d) => {
      const c = d.target;
      if (!(!t?.value || !c)) {
        if (Lh(t.value, c)) {
          r.value = !1;
          return;
        }
        if (d.target && !r.value) {
          let p = function() {
            ns(U1, e, f);
          };
          const f = { originalEvent: d };
          d.pointerType === "touch" ? (a.removeEventListener("click", o.value), o.value = p, a.addEventListener("click", o.value, { once: !0 })) : p();
        } else a.removeEventListener("click", o.value);
        r.value = !1;
      }
    }, u = window.setTimeout(() => {
      a.addEventListener("pointerdown", i);
    }, 0);
    s(() => {
      window.clearTimeout(u), a.removeEventListener("pointerdown", i), a.removeEventListener("click", o.value);
    });
  }), { onPointerDownCapture: () => {
    pe(n) && (r.value = !0);
  } };
}
function G1(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, r = I(!1);
  return Te((o) => {
    if (!Ut || !pe(n)) return;
    const s = async (i) => {
      if (!t?.value) return;
      await Pe(), await Pe();
      const u = i.target;
      !t.value || !u || Lh(t.value, u) || i.target && !r.value && ns(j1, e, { originalEvent: i });
    };
    a.addEventListener("focusin", s), o(() => a.removeEventListener("focusin", s));
  }), {
    onFocusCapture: () => {
      pe(n) && (r.value = !0);
    },
    onBlurCapture: () => {
      pe(n) && (r.value = !1);
    }
  };
}
const gn = pn({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  originalBodyPointerEvents: void 0,
  branches: /* @__PURE__ */ new Set()
});
var K1 = /* @__PURE__ */ b({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = A(() => o.value?.ownerDocument ?? globalThis.document), i = A(() => gn.layersRoot), u = A(() => o.value ? Array.from(i.value).indexOf(o.value) : -1), d = A(() => gn.layersWithOutsidePointerEventsDisabled.size > 0), c = A(() => {
      const v = Array.from(i.value), [m] = [...gn.layersWithOutsidePointerEventsDisabled].slice(-1), y = v.indexOf(m);
      return u.value >= y;
    }), f = W1(async (v) => {
      const m = [...gn.branches].some((y) => y?.contains(v.target));
      !c.value || m || (a("pointerDownOutside", v), a("interactOutside", v), await Pe(), v.defaultPrevented || a("dismiss"));
    }, o), p = G1((v) => {
      [...gn.branches].some((y) => y?.contains(v.target)) || (a("focusOutside", v), a("interactOutside", v), v.defaultPrevented || a("dismiss"));
    }, o);
    return U0("Escape", (v) => {
      u.value === i.value.size - 1 && (a("escapeKeyDown", v), v.defaultPrevented || a("dismiss"));
    }), Te((v) => {
      o.value && (n.disableOutsidePointerEvents && (gn.layersWithOutsidePointerEventsDisabled.size === 0 && (gn.originalBodyPointerEvents = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), gn.layersWithOutsidePointerEventsDisabled.add(o.value)), i.value.add(o.value), v(() => {
        n.disableOutsidePointerEvents && gn.layersWithOutsidePointerEventsDisabled.size === 1 && !Pn(gn.originalBodyPointerEvents) && (s.value.body.style.pointerEvents = gn.originalBodyPointerEvents);
      }));
    }), Te((v) => {
      v(() => {
        o.value && (i.value.delete(o.value), gn.layersWithOutsidePointerEventsDisabled.delete(o.value));
      });
    }), (v, m) => (h(), w(l(X), {
      ref: l(r),
      "as-child": v.asChild,
      as: v.as,
      "data-dismissable-layer": "",
      style: dt({ pointerEvents: d.value ? c.value ? "auto" : "none" : void 0 }),
      onFocusCapture: l(p).onFocusCapture,
      onBlurCapture: l(p).onBlurCapture,
      onPointerdownCapture: l(f).onPointerDownCapture
    }, {
      default: g(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "style",
      "onFocusCapture",
      "onBlurCapture",
      "onPointerdownCapture"
    ]));
  }
}), Oa = K1;
const Y1 = /* @__PURE__ */ C0(() => I([]));
function X1() {
  const e = Y1();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && n?.pause(), e.value = Dp(e.value, t), e.value.unshift(t);
    },
    remove(t) {
      e.value = Dp(e.value, t), e.value[0]?.resume();
    }
  };
}
function Dp(e, t) {
  const n = [...e], a = n.indexOf(t);
  return a !== -1 && n.splice(a, 1), n;
}
const $u = "focusScope.autoFocusOnMount", Bu = "focusScope.autoFocusOnUnmount", qp = {
  bubbles: !1,
  cancelable: !0
};
function J1(e, { select: t = !1 } = {}) {
  const n = rt();
  for (const a of e)
    if (xa(a, { select: t }), rt() !== n) return !0;
}
function Z1(e) {
  const t = zh(e), n = Ap(t, e), a = Ap(t.reverse(), e);
  return [n, a];
}
function zh(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Ap(e, t) {
  for (const n of e) if (!Q1(n, { upTo: t })) return n;
}
function Q1(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function ex(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function xa(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = rt();
    e.focus({ preventScroll: !0 }), e !== n && ex(e) && t && e.select();
  }
}
var tx = /* @__PURE__ */ b({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    trapped: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, { currentRef: r, currentElement: o } = j(), s = I(null), i = X1(), u = pn({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Te((c) => {
      if (!Ut) return;
      const f = o.value;
      if (!n.trapped) return;
      function p(x) {
        if (u.paused || !f) return;
        const C = x.target;
        f.contains(C) ? s.value = C : xa(s.value, { select: !0 });
      }
      function v(x) {
        if (u.paused || !f) return;
        const C = x.relatedTarget;
        C !== null && (f.contains(C) || xa(s.value, { select: !0 }));
      }
      function m(x) {
        f.contains(s.value) || xa(f);
      }
      document.addEventListener("focusin", p), document.addEventListener("focusout", v);
      const y = new MutationObserver(m);
      f && y.observe(f, {
        childList: !0,
        subtree: !0
      }), c(() => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", v), y.disconnect();
      });
    }), Te(async (c) => {
      const f = o.value;
      if (await Pe(), !f) return;
      i.add(u);
      const p = rt();
      if (!f.contains(p)) {
        const m = new CustomEvent($u, qp);
        f.addEventListener($u, (y) => a("mountAutoFocus", y)), f.dispatchEvent(m), m.defaultPrevented || (J1(zh(f), { select: !0 }), rt() === p && xa(f));
      }
      c(() => {
        f.removeEventListener($u, (x) => a("mountAutoFocus", x));
        const m = new CustomEvent(Bu, qp), y = (x) => {
          a("unmountAutoFocus", x);
        };
        f.addEventListener(Bu, y), f.dispatchEvent(m), setTimeout(() => {
          m.defaultPrevented || xa(p ?? document.body, { select: !0 }), f.removeEventListener(Bu, y), i.remove(u);
        }, 0);
      });
    });
    function d(c) {
      if (!n.loop && !n.trapped || u.paused) return;
      const f = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, p = rt();
      if (f && p) {
        const v = c.currentTarget, [m, y] = Z1(v);
        m && y ? !c.shiftKey && p === y ? (c.preventDefault(), n.loop && xa(m, { select: !0 })) : c.shiftKey && p === m && (c.preventDefault(), n.loop && xa(y, { select: !0 })) : p === v && c.preventDefault();
      }
    }
    return (c, f) => (h(), w(l(X), {
      ref_key: "currentRef",
      ref: r,
      tabindex: "-1",
      "as-child": c.asChild,
      as: c.as,
      onKeydown: d
    }, {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), us = tx;
const nx = "menu.itemSelect", ud = ["Enter", " "], ax = [
  "ArrowDown",
  "PageUp",
  "Home"
], Hh = [
  "ArrowUp",
  "PageDown",
  "End"
], rx = [...ax, ...Hh], ox = {
  ltr: [...ud, "ArrowRight"],
  rtl: [...ud, "ArrowLeft"]
}, sx = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function bc(e) {
  return e ? "open" : "closed";
}
function Pl(e) {
  return e === "indeterminate";
}
function _c(e) {
  return Pl(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function dd(e) {
  const t = rt();
  for (const n of e)
    if (n === t || (n.focus(), rt() !== t)) return;
}
function lx(e, t) {
  const { x: n, y: a } = e;
  let r = !1;
  for (let o = 0, s = t.length - 1; o < t.length; s = o++) {
    const i = t[o].x, u = t[o].y, d = t[s].x, c = t[s].y;
    u > a != c > a && n < (d - i) * (a - u) / (c - u) + i && (r = !r);
  }
  return r;
}
function ix(e, t) {
  if (!t) return !1;
  const n = {
    x: e.clientX,
    y: e.clientY
  };
  return lx(n, t);
}
function Oo(e) {
  return e.pointerType === "mouse";
}
var ux = /* @__PURE__ */ b({
  __name: "DialogContentImpl",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xn(), { forwardRef: o, currentElement: s } = j();
    return r.titleId ||= Ke(void 0, "reka-dialog-title"), r.descriptionId ||= Ke(void 0, "reka-dialog-description"), Ce(() => {
      r.contentElement = s, rt() !== document.body && (r.triggerElement.value = rt());
    }), (i, u) => (h(), w(l(us), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: g(() => [N(l(Oa), T({
        id: l(r).contentId,
        ref: l(o),
        as: i.as,
        "as-child": i.asChild,
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        role: "dialog",
        "aria-describedby": l(r).descriptionId,
        "aria-labelledby": l(r).titleId,
        "data-state": l(bc)(l(r).open.value)
      }, i.$attrs, {
        onDismiss: u[0] || (u[0] = (d) => l(r).onOpenChange(!1)),
        onEscapeKeyDown: u[1] || (u[1] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[2] || (u[2] = (d) => a("focusOutside", d)),
        onInteractOutside: u[3] || (u[3] = (d) => a("interactOutside", d)),
        onPointerDownOutside: u[4] || (u[4] = (d) => a("pointerDownOutside", d))
      }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "as",
        "as-child",
        "disable-outside-pointer-events",
        "aria-describedby",
        "aria-labelledby",
        "data-state"
      ])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Uh = ux, dx = /* @__PURE__ */ b({
  __name: "DialogContentModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xn(), o = Gt(a), { forwardRef: s, currentElement: i } = j();
    return ls(i), (u, d) => (h(), w(Uh, T({
      ...n,
      ...l(o)
    }, {
      ref: l(s),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (c.preventDefault(), l(r).triggerElement.value?.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0;
        (f.button === 2 || p) && c.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (c) => {
        c.preventDefault();
      })
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), cx = dx, fx = /* @__PURE__ */ b({
  __name: "DialogContentNonModal",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    j();
    const o = Xn(), s = I(!1), i = I(!1);
    return (u, d) => (h(), w(Uh, T({
      ...n,
      ...l(r)
    }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        c.defaultPrevented || (s.value || l(o).triggerElement.value?.focus(), c.preventDefault()), s.value = !1, i.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = (c) => {
        c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const f = c.target;
        l(o).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && i.value && c.preventDefault();
      })
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), px = fx, vx = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xn(), o = Gt(a), { forwardRef: s } = j();
    return (i, u) => (h(), w(l(yt), { present: i.forceMount || l(r).open.value }, {
      default: g(() => [l(r).modal.value ? (h(), w(cx, T({
        key: 0,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), w(px, T({
        key: 1,
        ref: l(s)
      }, {
        ...n,
        ...l(o),
        ...i.$attrs
      }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), ds = vx, mx = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Xn();
    return (a, r) => (h(), w(l(X), T(t, { id: l(n).descriptionId }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), bi = mx, hx = /* @__PURE__ */ b({
  __name: "DialogOverlayImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Xn();
    return os(!0), j(), (n, a) => (h(), w(l(X), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": l(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-state"
    ]));
  }
}), gx = hx, yx = /* @__PURE__ */ b({
  __name: "DialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = Xn(), { forwardRef: n } = j();
    return (a, r) => l(t)?.modal.value ? (h(), w(l(yt), {
      key: 0,
      present: a.forceMount || l(t).open.value
    }, {
      default: g(() => [N(gx, T(a.$attrs, {
        ref: l(n),
        as: a.as,
        "as-child": a.asChild
      }), {
        default: g(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, ["as", "as-child"])]),
      _: 3
    }, 8, ["present"])) : De("v-if", !0);
  }
}), cs = yx, bx = /* @__PURE__ */ b({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: !1,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = /* @__PURE__ */ ac();
    return (n, a) => l(t) || n.forceMount ? (h(), w(ci, {
      key: 0,
      to: n.to,
      disabled: n.disabled,
      defer: n.defer
    }, [_(n.$slots, "default")], 8, [
      "to",
      "disabled",
      "defer"
    ])) : De("v-if", !0);
  }
}), Ra = bx, _x = /* @__PURE__ */ b({
  __name: "DialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _i = _x, wx = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e, n = Xn();
    return j(), (a, r) => (h(), w(l(X), T(t, { id: l(n).titleId }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), wi = wx, xx = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Xn(), { forwardRef: a, currentElement: r } = j();
    return n.contentId ||= Ke(void 0, "reka-dialog-content"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), w(l(X), T(t, {
      ref: l(a),
      type: o.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": l(n).open.value || !1,
      "aria-controls": l(n).open.value ? l(n).contentId : void 0,
      "data-state": l(n).open.value ? "open" : "closed",
      onClick: l(n).onOpenToggle
    }), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "onClick"
    ]));
  }
}), xi = xx, Cx = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Ia), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Sx = Cx;
const [$x, Bx] = Se("AlertDialogContent");
var kx = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    j();
    const o = I();
    return Bx({ onCancelElementChange: (s) => {
      o.value = s;
    } }), (s, i) => (h(), w(l(ds), T({
      ...n,
      ...l(r)
    }, {
      role: "alertdialog",
      onPointerDownOutside: i[0] || (i[0] = Ye(() => {
      }, ["prevent"])),
      onInteractOutside: i[1] || (i[1] = Ye(() => {
      }, ["prevent"])),
      onOpenAutoFocus: i[2] || (i[2] = () => {
        Pe(() => {
          o.value?.focus({ preventScroll: !0 });
        });
      })
    }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Px = kx, Mx = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = $x(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onCancelElementChange(r.value);
    }), (o, s) => (h(), w(l(Ia), T(t, { ref: l(a) }), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Dx = Mx, qx = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(bi), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ax = qx, Ex = /* @__PURE__ */ b({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(cs), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Tx = Ex, Ix = /* @__PURE__ */ b({
  __name: "AlertDialogPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ox = Ix, Rx = /* @__PURE__ */ b({
  __name: "AlertDialogRoot",
  props: {
    open: {
      type: Boolean,
      required: !1
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), w(l(yi), T(l(r), { modal: !0 }), {
      default: g((i) => [_(o.$slots, "default", oe(le(i)))]),
      _: 3
    }, 16));
  }
}), Vx = Rx, Fx = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h2"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(wi), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Nx = Fx, Lx = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(xi), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), zx = Lx, Hx = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "AspectRatio",
  props: {
    ratio: {
      type: Number,
      required: !1,
      default: 1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = A(() => 1 / t.ratio * 100);
    return (r, o) => (h(), G("div", {
      style: dt(`position: relative; width: 100%; padding-bottom: ${a.value}%`),
      "data-reka-aspect-ratio-wrapper": ""
    }, [N(l(X), T({
      ref: l(n),
      "as-child": r.asChild,
      as: r.as,
      style: {
        position: "absolute",
        inset: "0px"
      }
    }, r.$attrs), {
      default: g(() => [_(r.$slots, "default", { aspect: a.value })]),
      _: 3
    }, 16, ["as-child", "as"])], 4));
  }
}), Ux = Hx;
const [jh, jx] = Se("AvatarRoot");
var Wx = /* @__PURE__ */ b({
  __name: "AvatarRoot",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return j(), jx({ imageLoadingStatus: I("idle") }), (t, n) => (h(), w(l(X), {
      "as-child": t.asChild,
      as: t.as
    }, {
      default: g(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), Gx = Wx, Kx = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = jh();
    j();
    const a = I(t.delayMs === void 0);
    return Te((r) => {
      if (t.delayMs && Ut) {
        const o = window.setTimeout(() => {
          a.value = !0;
        }, t.delayMs);
        r(() => {
          window.clearTimeout(o);
        });
      }
    }), (r, o) => a.value && l(n).imageLoadingStatus.value !== "loaded" ? (h(), w(l(X), {
      key: 0,
      "as-child": r.asChild,
      as: r.as
    }, {
      default: g(() => [_(r.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"])) : De("v-if", !0);
  }
}), Yx = Kx;
function Ep(e, t) {
  return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle";
}
function Xx(e, { referrerPolicy: t, crossOrigin: n } = {}) {
  const a = I(!1), r = I(null), o = A(() => a.value ? (!r.value && Ut && (r.value = new window.Image()), r.value) : null), s = I(Ep(o.value, e.value)), i = (u) => () => {
    a.value && (s.value = u);
  };
  return Ce(() => {
    a.value = !0, Te((u) => {
      const d = o.value;
      if (!d) return;
      s.value = Ep(d, e.value);
      const c = i("loaded"), f = i("error");
      d.addEventListener("load", c), d.addEventListener("error", f), t?.value && (d.referrerPolicy = t.value), typeof n?.value == "string" && (d.crossOrigin = n.value), u(() => {
        d.removeEventListener("load", c), d.removeEventListener("error", f);
      });
    });
  }), nt(() => {
    a.value = !1;
  }), s;
}
var Jx = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {
      type: String,
      required: !0
    },
    referrerPolicy: {
      type: null,
      required: !1
    },
    crossOrigin: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "img"
    }
  },
  emits: ["loadingStatusChange"],
  setup(e, { emit: t }) {
    const n = e, a = t, { src: r, referrerPolicy: o, crossOrigin: s } = qe(n);
    j();
    const i = jh(), u = Xx(r, {
      referrerPolicy: o,
      crossOrigin: s
    });
    return me(u, (d) => {
      a("loadingStatusChange", d), d !== "idle" && (i.imageLoadingStatus.value = d);
    }, { immediate: !0 }), (d, c) => ec((h(), w(l(X), {
      role: "img",
      "as-child": d.asChild,
      as: d.as,
      src: l(r),
      referrerpolicy: l(o),
      crossorigin: l(s)
    }, {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "src",
      "referrerpolicy",
      "crossorigin"
    ])), [[n0, l(u) === "loaded"]]);
  }
}), Zx = Jx;
function Qx(e) {
  function t(a) {
    return Array.isArray(e.date.value) ? e.date.value.some((r) => wt(r, a)) : e.date.value ? wt(e.date.value, a) : !1;
  }
  const n = A(() => {
    if (Array.isArray(e.date.value)) {
      if (!e.date.value.length) return !1;
      for (const a of e.date.value)
        if (e.isDateDisabled?.(a) || e.isDateUnavailable?.(a)) return !0;
    } else {
      if (!e.date.value) return !1;
      if (e.isDateDisabled?.(e.date.value) || e.isDateUnavailable?.(e.date.value)) return !0;
    }
    return !1;
  });
  return {
    isDateSelected: t,
    isInvalid: n
  };
}
function eC(e, t) {
  const n = t(e), a = n.compare(e), r = {};
  return a >= 7 && (r.day = 1), a >= Io(e) && (r.month = 1), n.set({ ...r });
}
function tC(e, t) {
  const n = t(e), a = e.compare(n), r = {};
  return a >= 7 && (r.day = 35), a >= Io(e) && (r.month = 13), n.set({ ...r });
}
function nC(e, t) {
  return t(e);
}
function aC(e, t) {
  return t(e);
}
function Wh(e) {
  const t = l1(e.locale.value), n = A(() => {
    const y = { calendar: e.placeholder.value.calendar.identifier };
    return e.placeholder.value.calendar.identifier === "gregory" && e.placeholder.value.era === "BC" && (y.era = "short"), y;
  }), a = I(Na({
    dateObj: e.placeholder.value,
    weekStartsOn: e.weekStartsOn.value,
    locale: e.locale.value,
    fixedWeeks: e.fixedWeeks.value,
    numberOfMonths: e.numberOfMonths.value
  })), r = A(() => a.value.map((y) => y.value));
  function o(y) {
    return !r.value.some((x) => dp(y, x));
  }
  const s = (y) => {
    if (!e.maxValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const x = a.value[a.value.length - 1].value;
    if (!y && !e.nextPage.value) {
      const S = x.add({ months: 1 }).set({ day: 1 });
      return ll(S, e.maxValue.value);
    }
    const C = eC(x, y || e.nextPage.value);
    return ll(C, e.maxValue.value);
  }, i = (y) => {
    if (!e.minValue.value || !a.value.length) return !1;
    if (e.disabled.value) return !0;
    const x = a.value[0].value;
    if (!y && !e.prevPage.value) {
      const S = x.subtract({ months: 1 }).set({ day: 35 });
      return Xa(S, e.minValue.value);
    }
    const C = tC(x, y || e.prevPage.value);
    return Xa(C, e.minValue.value);
  };
  function u(y) {
    return !!(e.isDateDisabled?.(y) || e.disabled.value || e.maxValue.value && ll(y, e.maxValue.value) || e.minValue.value && Xa(y, e.minValue.value));
  }
  const d = (y) => !!e.isDateUnavailable?.(y), c = A(() => a.value.length ? a.value[0].rows[0].map((y) => t.dayOfWeek($n(y), e.weekdayFormat.value)) : []), f = (y) => {
    const x = a.value[0].value;
    if (!y && !e.nextPage.value) {
      const k = x.add({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), B = Na({
        dateObj: k,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = B, e.placeholder.value = B[0].value.set({ day: 1 });
      return;
    }
    const C = nC(x, y || e.nextPage.value), S = Na({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!y) {
      const k = S[0].value.compare(x);
      k >= Io(x) && ($.day = 1), k >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  }, p = (y) => {
    const x = a.value[0].value;
    if (!y && !e.prevPage.value) {
      const k = x.subtract({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), B = Na({
        dateObj: k,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = B, e.placeholder.value = B[0].value.set({ day: 1 });
      return;
    }
    const C = aC(x, y || e.prevPage.value), S = Na({
      dateObj: C,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = S;
    const $ = {};
    if (!y) {
      const k = x.compare(S[0].value);
      k >= Io(x) && ($.day = 1), k >= 365 && ($.month = 1);
    }
    e.placeholder.value = S[0].value.set({ ...$ });
  };
  me(e.placeholder, (y) => {
    r.value.some((x) => dp(x, y)) || (a.value = Na({
      dateObj: y,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    }));
  }), me([
    e.locale,
    e.weekStartsOn,
    e.fixedWeeks,
    e.numberOfMonths
  ], () => {
    a.value = Na({
      dateObj: e.placeholder.value,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
  });
  const v = A(() => {
    if (!a.value.length) return "";
    if (e.locale.value !== t.getLocale() && t.setLocale(e.locale.value), a.value.length === 1) {
      const P = a.value[0].value;
      return `${t.fullMonthAndYear($n(P), n.value)}`;
    }
    const y = $n(a.value[0].value), x = $n(a.value[a.value.length - 1].value), C = t.fullMonth(y, n.value), S = t.fullMonth(x, n.value), $ = t.fullYear(y, n.value), k = t.fullYear(x, n.value);
    return $ === k ? `${C} - ${S} ${k}` : `${C} ${$} - ${S} ${k}`;
  }), m = A(() => `${e.calendarLabel.value ?? "Event Date"}, ${v.value}`);
  return {
    isDateDisabled: u,
    isDateUnavailable: d,
    isNextButtonDisabled: s,
    isPrevButtonDisabled: i,
    grid: a,
    weekdays: c,
    visibleView: r,
    isOutsideVisibleView: o,
    formatter: t,
    nextPage: f,
    prevPage: p,
    headingValue: v,
    fullCalendarLabel: m
  };
}
const rC = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, oC = {
  role: "heading",
  "aria-level": "2"
}, [Wr, sC] = Se("CalendarRoot");
var lC = /* @__PURE__ */ b({
  __name: "CalendarRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, multiple: f, minValue: p, maxValue: v, numberOfMonths: m, preventDeselect: y, isDateDisabled: x, isDateUnavailable: C, calendarLabel: S, defaultValue: $, nextPage: k, prevPage: B, dir: P, locale: M, disableDaysOutsideCurrentView: q } = qe(n), { primitiveElement: E, currentElement: D } = Lt(), O = mc(M), F = gt(P), J = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: $.value,
      passive: n.modelValue === void 0
    }), ne = Dh({
      defaultPlaceholder: n.placeholder,
      defaultValue: J.value,
      locale: n.locale
    }), Q = /* @__PURE__ */ Ie(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ne.copy(),
      passive: n.placeholder === void 0
    });
    function W(L) {
      Q.value = L.copy();
    }
    const { fullCalendarLabel: H, headingValue: U, isDateDisabled: se, isDateUnavailable: ee, isNextButtonDisabled: de, isPrevButtonDisabled: fe, weekdays: _e, isOutsideVisibleView: ye, nextPage: Ee, prevPage: ce, formatter: V, grid: te } = Wh({
      locale: O,
      placeholder: Q,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: m,
      minValue: p,
      maxValue: v,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: x.value,
      isDateUnavailable: C.value,
      calendarLabel: S,
      nextPage: k,
      prevPage: B
    }), { isInvalid: z, isDateSelected: re } = Qx({
      date: J,
      isDateDisabled: se,
      isDateUnavailable: ee
    });
    me(J, (L) => {
      if (Array.isArray(L) && L.length) {
        const be = L[L.length - 1];
        be && !Sa(Q.value, be) && W(be);
      } else !Array.isArray(L) && L && !Sa(Q.value, L) && W(L);
    });
    function ie(L) {
      if (f.value) {
        if (!J.value) J.value = [L.copy()];
        else if (Array.isArray(J.value)) {
          if (J.value.findIndex((xe) => wt(xe, L)) === -1) J.value = [...J.value, L];
          else if (!y.value) {
            const xe = J.value.filter((Ne) => !wt(Ne, L));
            if (!xe.length) {
              Q.value = L.copy(), J.value = void 0;
              return;
            }
            J.value = xe.map((Ne) => Ne.copy());
          }
        }
      } else {
        if (!J.value) {
          J.value = L.copy();
          return;
        }
        !y.value && Sa(J.value, L) ? (Q.value = L.copy(), J.value = void 0) : J.value = L.copy();
      }
    }
    return Ce(() => {
      s.value && qh(D.value);
    }), sC({
      isDateUnavailable: ee,
      dir: F,
      isDateDisabled: se,
      locale: O,
      formatter: V,
      modelValue: J,
      placeholder: Q,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: te,
      weekDays: _e,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      multiple: f,
      numberOfMonths: m,
      readonly: o,
      preventDeselect: y,
      fullCalendarLabel: H,
      headingValue: U,
      isInvalid: z,
      isDateSelected: re,
      isNextButtonDisabled: de,
      isPrevButtonDisabled: fe,
      isOutsideVisibleView: ye,
      nextPage: Ee,
      prevPage: ce,
      parentElement: D,
      onPlaceholderChange: W,
      onDateChange: ie,
      disableDaysOutsideCurrentView: q,
      minValue: p,
      maxValue: v
    }), (L, be) => (h(), w(l(X), {
      ref_key: "primitiveElement",
      ref: E,
      as: L.as,
      "as-child": L.asChild,
      "aria-label": l(H),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(z) ? "" : void 0,
      dir: l(F)
    }, {
      default: g(() => [_(L.$slots, "default", {
        date: l(Q),
        grid: l(te),
        weekDays: l(_e),
        weekStartsOn: l(u),
        locale: l(O),
        fixedWeeks: l(c),
        modelValue: l(J)
      }), we("div", rC, [we("div", oC, Fe(l(H)), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), iC = lC, uC = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = Wr();
    return (n, a) => (h(), w(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isDateSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), dC = uC, cC = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = is(), a = Wr(), { primitiveElement: r } = Lt(), o = A(() => t.day.day.toLocaleString(a.locale.value)), s = A(() => a.formatter.custom($n(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), i = A(() => a.isDateUnavailable?.(t.day) ?? !1), u = A(() => lh(t.day, jr())), d = A(() => !oc(t.day, t.month)), c = A(() => a.isOutsideVisibleView(t.day)), f = A(() => a.isDateDisabled(t.day) || a.disableDaysOutsideCurrentView.value && d.value), p = A(() => !a.disabled.value && wt(t.day, a.placeholder.value)), v = A(() => a.isDateSelected(t.day));
    function m(C) {
      a.readonly.value || a.isDateDisabled(C) || a.isDateUnavailable?.(C) || a.onDateChange(C);
    }
    function y() {
      f.value || m(t.day);
    }
    function x(C) {
      if (f.value) return;
      C.preventDefault(), C.stopPropagation();
      const S = a.parentElement.value, $ = 7, k = a.dir.value === "rtl" ? -1 : 1;
      switch (C.code) {
        case n.ARROW_RIGHT:
          B(t.day, k);
          break;
        case n.ARROW_LEFT:
          B(t.day, -k);
          break;
        case n.ARROW_UP:
          B(t.day, -$);
          break;
        case n.ARROW_DOWN:
          B(t.day, $);
          break;
        case n.ENTER:
        case n.SPACE_CODE:
          m(t.day);
      }
      function B(P, M) {
        const q = P.add({ days: M });
        if (a.minValue.value && q.compare(a.minValue.value) < 0 || a.maxValue.value && q.compare(a.maxValue.value) > 0) return;
        const E = S.querySelector(`[data-value='${q.toString()}']:not([data-outside-view])`);
        if (!E) {
          if (M > 0) {
            if (a.isNextButtonDisabled()) return;
            a.nextPage();
          } else {
            if (a.isPrevButtonDisabled()) return;
            a.prevPage();
          }
          Pe(() => {
            B(P, M);
          });
          return;
        }
        if (E && E.hasAttribute("data-disabled")) return B(q, M);
        a.onPlaceholderChange(q), E?.focus();
      }
    }
    return (C, S) => (h(), w(l(X), T({
      ref_key: "primitiveElement",
      ref: r
    }, t, {
      role: "button",
      "aria-label": s.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-disabled": f.value || i.value ? !0 : void 0,
      "data-selected": v.value ? !0 : void 0,
      "data-value": C.day.toString(),
      "data-disabled": f.value ? "" : void 0,
      "data-unavailable": i.value ? "" : void 0,
      "data-today": u.value ? "" : void 0,
      "data-outside-view": d.value ? "" : void 0,
      "data-outside-visible-view": c.value ? "" : void 0,
      "data-focused": p.value ? "" : void 0,
      tabindex: p.value ? 0 : d.value || f.value ? void 0 : -1,
      onClick: y,
      onKeydown: [Je(x, [
        "up",
        "down",
        "left",
        "right",
        "space",
        "enter"
      ]), S[0] || (S[0] = Je(Ye(() => {
      }, ["prevent"]), ["enter"]))]
    }), {
      default: g(() => [_(C.$slots, "default", {
        dayValue: o.value,
        disabled: f.value,
        today: u.value,
        selected: v.value,
        outsideView: d.value,
        outsideVisibleView: c.value,
        unavailable: i.value
      }, () => [Re(Fe(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-disabled",
      "data-selected",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-outside-visible-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), fC = cC, pC = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = Wr(), a = A(() => n.disabled.value ? !0 : void 0), r = A(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), w(l(X), T(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), vC = pC, mC = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), hC = mC, gC = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), T(t, { "aria-hidden": "true" }), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), yC = gC, bC = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _C = bC, wC = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xC = wC, CC = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), SC = CC, $C = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Wr();
    return (a, r) => (h(), w(l(X), T(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: g(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Fe(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), BC = $C, kC = /* @__PURE__ */ b({
  __name: "CalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = A(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = Wr();
    return (r, o) => (h(), w(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: g(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), PC = kC, MC = /* @__PURE__ */ b({
  __name: "CalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = A(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = Wr();
    return (r, o) => (h(), w(l(X), {
      "aria-label": "Previous page",
      as: t.as,
      "as-child": t.asChild,
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: g(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), DC = MC;
const Tp = "data-reka-collection-item";
function st(e = {}) {
  const { key: t = "", isProvider: n = !1 } = e, a = `${t}CollectionProvider`;
  let r;
  if (n) {
    const c = I(/* @__PURE__ */ new Map());
    r = {
      collectionRef: I(),
      itemMap: c
    }, Kn(a, r);
  } else r = xn(a);
  const o = (c = !1) => {
    const f = r.collectionRef.value;
    if (!f) return [];
    const p = Array.from(f.querySelectorAll(`[${Tp}]`)), m = Array.from(r.itemMap.value.values()).sort((y, x) => p.indexOf(y.ref) - p.indexOf(x.ref));
    return c ? m : m.filter((y) => y.ref.dataset.disabled !== "");
  }, s = b({
    name: "CollectionSlot",
    inheritAttrs: !1,
    setup(c, { slots: f, attrs: p }) {
      const { primitiveElement: v, currentElement: m } = Lt();
      return me(m, () => {
        r.collectionRef.value = m.value;
      }), () => tn(kl, {
        ref: v,
        ...p
      }, f);
    }
  }), i = b({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: { value: { validator: () => !0 } },
    setup(c, { slots: f, attrs: p }) {
      const { primitiveElement: v, currentElement: m } = Lt();
      return Te((y) => {
        if (m.value) {
          const x = a0(m.value);
          r.itemMap.value.set(x, {
            ref: m.value,
            value: c.value
          }), y(() => r.itemMap.value.delete(x));
        }
      }), () => tn(kl, {
        ...p,
        [Tp]: "",
        ref: v
      }, f);
    }
  }), u = A(() => Array.from(r.itemMap.value.values())), d = A(() => r.itemMap.value.size);
  return {
    getItems: o,
    reactiveItems: u,
    itemMapSize: d,
    CollectionSlot: s,
    CollectionItem: i
  };
}
const qC = "rovingFocusGroup.onEntryFocus", AC = {
  bubbles: !1,
  cancelable: !0
}, EC = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function TC(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Gh(e, t, n) {
  const a = TC(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return EC[a];
}
function Kh(e, t = !1) {
  const n = rt();
  for (const a of e)
    if (a === n || (a.focus({ preventScroll: t }), rt() !== n)) return;
}
function IC(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
const [OC, RC] = Se("RovingFocusGroup");
var VC = /* @__PURE__ */ b({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    },
    currentTabStopId: {
      type: [String, null],
      required: !1
    },
    defaultCurrentTabStopId: {
      type: String,
      required: !1
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { loop: o, orientation: s, dir: i } = qe(a), u = gt(i), d = /* @__PURE__ */ Ie(a, "currentTabStopId", r, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), c = I(!1), f = I(!1), p = I(0), { getItems: v, CollectionSlot: m } = st({ isProvider: !0 });
    function y(C) {
      const S = !f.value;
      if (C.currentTarget && C.target === C.currentTarget && S && !c.value) {
        const $ = new CustomEvent(qC, AC);
        if (C.currentTarget.dispatchEvent($), r("entryFocus", $), !$.defaultPrevented) {
          const k = v().map((E) => E.ref).filter((E) => E.dataset.disabled !== ""), B = k.find((E) => E.getAttribute("data-active") === ""), P = k.find((E) => E.getAttribute("data-highlighted") === ""), M = k.find((E) => E.id === d.value), q = [
            B,
            P,
            M,
            ...k
          ].filter(Boolean);
          Kh(q, a.preventScrollOnEntryFocus);
        }
      }
      f.value = !1;
    }
    function x() {
      setTimeout(() => {
        f.value = !1;
      }, 1);
    }
    return t({ getItems: v }), RC({
      loop: o,
      dir: u,
      orientation: s,
      currentTabStopId: d,
      onItemFocus: (C) => {
        d.value = C;
      },
      onItemShiftTab: () => {
        c.value = !0;
      },
      onFocusableItemAdd: () => {
        p.value++;
      },
      onFocusableItemRemove: () => {
        p.value--;
      }
    }), (C, S) => (h(), w(l(m), null, {
      default: g(() => [N(l(X), {
        tabindex: c.value || p.value === 0 ? -1 : 0,
        "data-orientation": l(s),
        as: C.as,
        "as-child": C.asChild,
        dir: l(u),
        style: { outline: "none" },
        onMousedown: S[0] || (S[0] = ($) => f.value = !0),
        onMouseup: x,
        onFocus: y,
        onBlur: S[1] || (S[1] = ($) => c.value = !1)
      }, {
        default: g(() => [_(C.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "as",
        "as-child",
        "dir"
      ])]),
      _: 3
    }));
  }
}), fs = VC, FC = /* @__PURE__ */ b({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: !1
    },
    focusable: {
      type: Boolean,
      required: !1,
      default: !0
    },
    active: {
      type: Boolean,
      required: !1
    },
    allowShiftKey: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = OC(), a = Ke(), r = A(() => t.tabStopId || a), o = A(() => n.currentTabStopId.value === r.value), { getItems: s, CollectionItem: i } = st();
    Ce(() => {
      t.focusable && n.onFocusableItemAdd();
    }), nt(() => {
      t.focusable && n.onFocusableItemRemove();
    });
    function u(d) {
      if (d.key === "Tab" && d.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (d.target !== d.currentTarget) return;
      const c = Gh(d, n.orientation.value, n.dir.value);
      if (c !== void 0) {
        if (d.metaKey || d.ctrlKey || d.altKey || !t.allowShiftKey && d.shiftKey) return;
        d.preventDefault();
        let f = [...s().map((p) => p.ref).filter((p) => p.dataset.disabled !== "")];
        if (c === "last") f.reverse();
        else if (c === "prev" || c === "next") {
          c === "prev" && f.reverse();
          const p = f.indexOf(d.currentTarget);
          f = n.loop.value ? IC(f, p + 1) : f.slice(p + 1);
        }
        Pe(() => Kh(f));
      }
    }
    return (d, c) => (h(), w(l(i), null, {
      default: g(() => [N(l(X), {
        tabindex: o.value ? 0 : -1,
        "data-orientation": l(n).orientation.value,
        "data-active": d.active ? "" : void 0,
        "data-disabled": d.focusable ? void 0 : "",
        as: d.as,
        "as-child": d.asChild,
        onMousedown: c[0] || (c[0] = (f) => {
          d.focusable ? l(n).onItemFocus(r.value) : f.preventDefault();
        }),
        onFocus: c[1] || (c[1] = (f) => l(n).onItemFocus(r.value)),
        onKeydown: u
      }, {
        default: g(() => [_(d.$slots, "default")]),
        _: 3
      }, 8, [
        "tabindex",
        "data-orientation",
        "data-active",
        "data-disabled",
        "as",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), ps = FC, NC = /* @__PURE__ */ b({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: !1,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), w(l(X), {
      as: t.as,
      "as-child": t.asChild,
      "aria-hidden": t.feature === "focusable" ? "true" : void 0,
      "data-hidden": t.feature === "fully-hidden" ? "" : void 0,
      tabindex: t.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        top: "-1px",
        left: "-1px"
      }
    }, {
      default: g(() => [_(t.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-hidden",
      "data-hidden",
      "tabindex"
    ]));
  }
}), Ci = NC, LC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Lt(), r = A(() => t.checked ?? t.value);
    return me(r, (o, s) => {
      if (!a.value) return;
      const i = a.value, u = window.HTMLInputElement.prototype, c = Object.getOwnPropertyDescriptor(u, "value").set;
      if (c && o !== s) {
        const f = new Event("input", { bubbles: !0 }), p = new Event("change", { bubbles: !0 });
        c.call(i, o), i.dispatchEvent(f), i.dispatchEvent(p);
      }
    }), (o, s) => (h(), w(Ci, T({
      ref_key: "primitiveElement",
      ref: n
    }, {
      ...t,
      ...o.$attrs
    }, { as: "input" }), null, 16));
  }
}), Ip = LC, zC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: !0
    },
    value: {
      type: null,
      required: !0
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    required: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    feature: {
      type: String,
      required: !1,
      default: "fully-hidden"
    }
  },
  setup(e) {
    const t = e, n = A(() => typeof t.value == "object" && Array.isArray(t.value) && t.value.length === 0 && t.required), a = A(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" || t.value === null || t.value === void 0 ? [{
      name: t.name,
      value: t.value
    }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((r, o) => typeof r == "object" ? Object.entries(r).map(([s, i]) => ({
      name: `${t.name}[${o}][${s}]`,
      value: i
    })) : {
      name: `${t.name}[${o}]`,
      value: r
    }) : t.value !== null && typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([r, o]) => ({
      name: `${t.name}[${r}]`,
      value: o
    })) : []);
    return (r, o) => (h(), G(Ge, null, [De(" We render single input if it's required "), n.value ? (h(), w(Ip, T({ key: r.name }, {
      ...t,
      ...r.$attrs
    }, {
      name: r.name,
      value: r.value
    }), null, 16, ["name", "value"])) : (h(!0), G(Ge, { key: 1 }, Et(a.value, (s) => (h(), w(Ip, T({ key: s.name }, { ref_for: !0 }, {
      ...t,
      ...r.$attrs
    }, {
      name: s.name,
      value: s.value
    }), null, 16, ["name", "value"]))), 128))], 2112));
  }
}), On = zC;
const [HC] = Se("CheckboxGroupRoot");
function Ml(e) {
  return e === "indeterminate";
}
function Yh(e) {
  return Ml(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
const [UC, jC] = Se("CheckboxRoot");
var WC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultValue: {
      type: [Boolean, String],
      required: !1
    },
    modelValue: {
      type: [
        Boolean,
        String,
        null
      ],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    value: {
      type: null,
      required: !1,
      default: "on"
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = HC(null), i = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), u = A(() => s?.disabled.value || n.disabled), d = A(() => Pn(s?.modelValue.value) ? i.value === "indeterminate" ? "indeterminate" : i.value : bl(s.modelValue.value, n.value));
    function c() {
      if (Pn(s?.modelValue.value))
        i.value = Ml(i.value) ? !0 : !i.value;
      else {
        const v = [...s.modelValue.value || []];
        if (bl(v, n.value)) {
          const m = v.findIndex((y) => Dn(y, n.value));
          v.splice(m, 1);
        } else v.push(n.value);
        s.modelValue.value = v;
      }
    }
    const f = In(o), p = A(() => n.id && o.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return jC({
      disabled: u,
      state: d
    }), (v, m) => (h(), w(Pt(l(s)?.rovingFocus.value ? l(ps) : l(X)), T(v.$attrs, {
      id: v.id,
      ref: l(r),
      role: "checkbox",
      "as-child": v.asChild,
      as: v.as,
      type: v.as === "button" ? "button" : void 0,
      "aria-checked": l(Ml)(d.value) ? "mixed" : d.value,
      "aria-required": v.required,
      "aria-label": v.$attrs["aria-label"] || p.value,
      "data-state": l(Yh)(d.value),
      "data-disabled": u.value ? "" : void 0,
      disabled: u.value,
      focusable: l(s)?.rovingFocus.value ? !u.value : void 0,
      onKeydown: Je(Ye(() => {
      }, ["prevent"]), ["enter"]),
      onClick: c
    }), {
      default: g(() => [_(v.$slots, "default", {
        modelValue: l(i),
        state: d.value
      }), l(f) && v.name && !l(s) ? (h(), w(l(On), {
        key: 0,
        type: "checkbox",
        checked: !!d.value,
        name: v.name,
        value: v.value,
        disabled: u.value,
        required: v.required
      }, null, 8, [
        "checked",
        "name",
        "value",
        "disabled",
        "required"
      ])) : De("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "as-child",
      "as",
      "type",
      "aria-checked",
      "aria-required",
      "aria-label",
      "data-state",
      "data-disabled",
      "disabled",
      "focusable",
      "onKeydown"
    ]));
  }
}), GC = WC, KC = /* @__PURE__ */ b({
  __name: "CheckboxIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = UC();
    return (a, r) => (h(), w(l(yt), { present: a.forceMount || l(Ml)(l(n).state.value) || l(n).state.value === !0 }, {
      default: g(() => [N(l(X), T({
        ref: l(t),
        "data-state": l(Yh)(l(n).state.value),
        "data-disabled": l(n).disabled.value ? "" : void 0,
        style: { pointerEvents: "none" },
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: g(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), YC = KC;
const [Xh, XC] = Se("PopperRoot");
var JC = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = I();
    return XC({
      anchor: t,
      onAnchorChange: (n) => t.value = n
    }), (n, a) => _(n.$slots, "default");
  }
}), or = JC, ZC = /* @__PURE__ */ b({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = Xh();
    return Km(() => {
      r.onAnchorChange(t.reference ?? a.value);
    }), (o, s) => (h(), w(l(X), {
      ref: l(n),
      as: o.as,
      "as-child": o.asChild
    }, {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), sr = ZC;
const QC = {
  key: 0,
  d: "M0 0L6 6L12 0"
}, eS = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
var tS = /* @__PURE__ */ b({
  __name: "Arrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(X), T(t, {
      width: n.width,
      height: n.height,
      viewBox: n.asChild ? void 0 : "0 0 12 6",
      preserveAspectRatio: n.asChild ? void 0 : "none"
    }), {
      default: g(() => [_(n.$slots, "default", {}, () => [n.rounded ? (h(), G("path", eS)) : (h(), G("path", QC))])]),
      _: 3
    }, 16, [
      "width",
      "height",
      "viewBox",
      "preserveAspectRatio"
    ]));
  }
}), nS = tS;
function aS(e) {
  return e !== null;
}
function rS(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: a, middlewareData: r } = t, s = r.arrow?.centerOffset !== 0, i = s ? 0 : e.arrowWidth, u = s ? 0 : e.arrowHeight, [d, c] = cd(n), f = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[c], p = (r.arrow?.x ?? 0) + i / 2, v = (r.arrow?.y ?? 0) + u / 2;
      let m = "", y = "";
      return d === "bottom" ? (m = s ? f : `${p}px`, y = `${-u}px`) : d === "top" ? (m = s ? f : `${p}px`, y = `${a.floating.height + u}px`) : d === "right" ? (m = `${-u}px`, y = s ? f : `${v}px`) : d === "left" && (m = `${a.floating.width + u}px`, y = s ? f : `${v}px`), { data: {
        x: m,
        y
      } };
    }
  };
}
function cd(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
const oS = ["top", "right", "bottom", "left"], Da = Math.min, dn = Math.max, Dl = Math.round, Vs = Math.floor, jn = (e) => ({
  x: e,
  y: e
}), sS = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, lS = {
  start: "end",
  end: "start"
};
function fd(e, t, n) {
  return dn(e, Da(t, n));
}
function ia(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ua(e) {
  return e.split("-")[0];
}
function Gr(e) {
  return e.split("-")[1];
}
function wc(e) {
  return e === "x" ? "y" : "x";
}
function xc(e) {
  return e === "y" ? "height" : "width";
}
const iS = /* @__PURE__ */ new Set(["top", "bottom"]);
function Un(e) {
  return iS.has(ua(e)) ? "y" : "x";
}
function Cc(e) {
  return wc(Un(e));
}
function uS(e, t, n) {
  n === void 0 && (n = !1);
  const a = Gr(e), r = Cc(e), o = xc(r);
  let s = r === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[o] > t.floating[o] && (s = ql(s)), [s, ql(s)];
}
function dS(e) {
  const t = ql(e);
  return [pd(e), t, pd(t)];
}
function pd(e) {
  return e.replace(/start|end/g, (t) => lS[t]);
}
const Op = ["left", "right"], Rp = ["right", "left"], cS = ["top", "bottom"], fS = ["bottom", "top"];
function pS(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? Rp : Op : t ? Op : Rp;
    case "left":
    case "right":
      return t ? cS : fS;
    default:
      return [];
  }
}
function vS(e, t, n, a) {
  const r = Gr(e);
  let o = pS(ua(e), n === "start", a);
  return r && (o = o.map((s) => s + "-" + r), t && (o = o.concat(o.map(pd)))), o;
}
function ql(e) {
  return e.replace(/left|right|bottom|top/g, (t) => sS[t]);
}
function mS(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Jh(e) {
  return typeof e != "number" ? mS(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Al(e) {
  const {
    x: t,
    y: n,
    width: a,
    height: r
  } = e;
  return {
    width: a,
    height: r,
    top: n,
    left: t,
    right: t + a,
    bottom: n + r,
    x: t,
    y: n
  };
}
function Vp(e, t, n) {
  let {
    reference: a,
    floating: r
  } = e;
  const o = Un(t), s = Cc(t), i = xc(s), u = ua(t), d = o === "y", c = a.x + a.width / 2 - r.width / 2, f = a.y + a.height / 2 - r.height / 2, p = a[i] / 2 - r[i] / 2;
  let v;
  switch (u) {
    case "top":
      v = {
        x: c,
        y: a.y - r.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: a.y + a.height
      };
      break;
    case "right":
      v = {
        x: a.x + a.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: a.x - r.width,
        y: f
      };
      break;
    default:
      v = {
        x: a.x,
        y: a.y
      };
  }
  switch (Gr(t)) {
    case "start":
      v[s] -= p * (n && d ? -1 : 1);
      break;
    case "end":
      v[s] += p * (n && d ? -1 : 1);
      break;
  }
  return v;
}
async function hS(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: a,
    y: r,
    platform: o,
    rects: s,
    elements: i,
    strategy: u
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = !1,
    padding: v = 0
  } = ia(t, e), m = Jh(v), x = i[p ? f === "floating" ? "reference" : "floating" : f], C = Al(await o.getClippingRect({
    element: (n = await (o.isElement == null ? void 0 : o.isElement(x))) == null || n ? x : x.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(i.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: u
  })), S = f === "floating" ? {
    x: a,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, $ = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(i.floating)), k = await (o.isElement == null ? void 0 : o.isElement($)) ? await (o.getScale == null ? void 0 : o.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, B = Al(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: S,
    offsetParent: $,
    strategy: u
  }) : S);
  return {
    top: (C.top - B.top + m.top) / k.y,
    bottom: (B.bottom - C.bottom + m.bottom) / k.y,
    left: (C.left - B.left + m.left) / k.x,
    right: (B.right - C.right + m.right) / k.x
  };
}
const gS = async (e, t, n) => {
  const {
    placement: a = "bottom",
    strategy: r = "absolute",
    middleware: o = [],
    platform: s
  } = n, i = o.filter(Boolean), u = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: c,
    y: f
  } = Vp(d, a, u), p = a, v = {}, m = 0;
  for (let x = 0; x < i.length; x++) {
    var y;
    const {
      name: C,
      fn: S
    } = i[x], {
      x: $,
      y: k,
      data: B,
      reset: P
    } = await S({
      x: c,
      y: f,
      initialPlacement: a,
      placement: p,
      strategy: r,
      middlewareData: v,
      rects: d,
      platform: {
        ...s,
        detectOverflow: (y = s.detectOverflow) != null ? y : hS
      },
      elements: {
        reference: e,
        floating: t
      }
    });
    c = $ ?? c, f = k ?? f, v = {
      ...v,
      [C]: {
        ...v[C],
        ...B
      }
    }, P && m <= 50 && (m++, typeof P == "object" && (P.placement && (p = P.placement), P.rects && (d = P.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : P.rects), {
      x: c,
      y: f
    } = Vp(d, p, u)), x = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: r,
    middlewareData: v
  };
}, yS = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: a,
      placement: r,
      rects: o,
      platform: s,
      elements: i,
      middlewareData: u
    } = t, {
      element: d,
      padding: c = 0
    } = ia(e, t) || {};
    if (d == null)
      return {};
    const f = Jh(c), p = {
      x: n,
      y: a
    }, v = Cc(r), m = xc(v), y = await s.getDimensions(d), x = v === "y", C = x ? "top" : "left", S = x ? "bottom" : "right", $ = x ? "clientHeight" : "clientWidth", k = o.reference[m] + o.reference[v] - p[v] - o.floating[m], B = p[v] - o.reference[v], P = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d));
    let M = P ? P[$] : 0;
    (!M || !await (s.isElement == null ? void 0 : s.isElement(P))) && (M = i.floating[$] || o.floating[m]);
    const q = k / 2 - B / 2, E = M / 2 - y[m] / 2 - 1, D = Da(f[C], E), O = Da(f[S], E), F = D, J = M - y[m] - O, ne = M / 2 - y[m] / 2 + q, Q = fd(F, ne, J), W = !u.arrow && Gr(r) != null && ne !== Q && o.reference[m] / 2 - (ne < F ? D : O) - y[m] / 2 < 0, H = W ? ne < F ? ne - F : ne - J : 0;
    return {
      [v]: p[v] + H,
      data: {
        [v]: Q,
        centerOffset: ne - Q - H,
        ...W && {
          alignmentOffset: H
        }
      },
      reset: W
    };
  }
}), bS = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        middlewareData: o,
        rects: s,
        initialPlacement: i,
        platform: u,
        elements: d
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !0,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: y = !0,
        ...x
      } = ia(e, t);
      if ((n = o.arrow) != null && n.alignmentOffset)
        return {};
      const C = ua(r), S = Un(i), $ = ua(i) === i, k = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)), B = p || ($ || !y ? [ql(i)] : dS(i)), P = m !== "none";
      !p && P && B.push(...vS(i, y, m, k));
      const M = [i, ...B], q = await u.detectOverflow(t, x), E = [];
      let D = ((a = o.flip) == null ? void 0 : a.overflows) || [];
      if (c && E.push(q[C]), f) {
        const ne = uS(r, s, k);
        E.push(q[ne[0]], q[ne[1]]);
      }
      if (D = [...D, {
        placement: r,
        overflows: E
      }], !E.every((ne) => ne <= 0)) {
        var O, F;
        const ne = (((O = o.flip) == null ? void 0 : O.index) || 0) + 1, Q = M[ne];
        if (Q && (!(f === "alignment" ? S !== Un(Q) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        D.every((U) => Un(U.placement) === S ? U.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ne,
              overflows: D
            },
            reset: {
              placement: Q
            }
          };
        let W = (F = D.filter((H) => H.overflows[0] <= 0).sort((H, U) => H.overflows[1] - U.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!W)
          switch (v) {
            case "bestFit": {
              var J;
              const H = (J = D.filter((U) => {
                if (P) {
                  const se = Un(U.placement);
                  return se === S || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  se === "y";
                }
                return !0;
              }).map((U) => [U.placement, U.overflows.filter((se) => se > 0).reduce((se, ee) => se + ee, 0)]).sort((U, se) => U[1] - se[1])[0]) == null ? void 0 : J[0];
              H && (W = H);
              break;
            }
            case "initialPlacement":
              W = i;
              break;
          }
        if (r !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
};
function Fp(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Np(e) {
  return oS.some((t) => e[t] >= 0);
}
const _S = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n,
        platform: a
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = ia(e, t);
      switch (r) {
        case "referenceHidden": {
          const s = await a.detectOverflow(t, {
            ...o,
            elementContext: "reference"
          }), i = Fp(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: i,
              referenceHidden: Np(i)
            }
          };
        }
        case "escaped": {
          const s = await a.detectOverflow(t, {
            ...o,
            altBoundary: !0
          }), i = Fp(s, n.floating);
          return {
            data: {
              escapedOffsets: i,
              escaped: Np(i)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, Zh = /* @__PURE__ */ new Set(["left", "top"]);
async function wS(e, t) {
  const {
    placement: n,
    platform: a,
    elements: r
  } = e, o = await (a.isRTL == null ? void 0 : a.isRTL(r.floating)), s = ua(n), i = Gr(n), u = Un(n) === "y", d = Zh.has(s) ? -1 : 1, c = o && u ? -1 : 1, f = ia(t, e);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return i && typeof m == "number" && (v = i === "end" ? m * -1 : m), u ? {
    x: v * c,
    y: p * d
  } : {
    x: p * d,
    y: v * c
  };
}
const xS = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, a;
      const {
        x: r,
        y: o,
        placement: s,
        middlewareData: i
      } = t, u = await wS(t, e);
      return s === ((n = i.offset) == null ? void 0 : n.placement) && (a = i.arrow) != null && a.alignmentOffset ? {} : {
        x: r + u.x,
        y: o + u.y,
        data: {
          ...u,
          placement: s
        }
      };
    }
  };
}, CS = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: a,
        placement: r,
        platform: o
      } = t, {
        mainAxis: s = !0,
        crossAxis: i = !1,
        limiter: u = {
          fn: (C) => {
            let {
              x: S,
              y: $
            } = C;
            return {
              x: S,
              y: $
            };
          }
        },
        ...d
      } = ia(e, t), c = {
        x: n,
        y: a
      }, f = await o.detectOverflow(t, d), p = Un(ua(r)), v = wc(p);
      let m = c[v], y = c[p];
      if (s) {
        const C = v === "y" ? "top" : "left", S = v === "y" ? "bottom" : "right", $ = m + f[C], k = m - f[S];
        m = fd($, m, k);
      }
      if (i) {
        const C = p === "y" ? "top" : "left", S = p === "y" ? "bottom" : "right", $ = y + f[C], k = y - f[S];
        y = fd($, y, k);
      }
      const x = u.fn({
        ...t,
        [v]: m,
        [p]: y
      });
      return {
        ...x,
        data: {
          x: x.x - n,
          y: x.y - a,
          enabled: {
            [v]: s,
            [p]: i
          }
        }
      };
    }
  };
}, SS = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: a,
        placement: r,
        rects: o,
        middlewareData: s
      } = t, {
        offset: i = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = ia(e, t), c = {
        x: n,
        y: a
      }, f = Un(r), p = wc(f);
      let v = c[p], m = c[f];
      const y = ia(i, t), x = typeof y == "number" ? {
        mainAxis: y,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...y
      };
      if (u) {
        const $ = p === "y" ? "height" : "width", k = o.reference[p] - o.floating[$] + x.mainAxis, B = o.reference[p] + o.reference[$] - x.mainAxis;
        v < k ? v = k : v > B && (v = B);
      }
      if (d) {
        var C, S;
        const $ = p === "y" ? "width" : "height", k = Zh.has(ua(r)), B = o.reference[f] - o.floating[$] + (k && ((C = s.offset) == null ? void 0 : C[f]) || 0) + (k ? 0 : x.crossAxis), P = o.reference[f] + o.reference[$] + (k ? 0 : ((S = s.offset) == null ? void 0 : S[f]) || 0) - (k ? x.crossAxis : 0);
        m < B ? m = B : m > P && (m = P);
      }
      return {
        [p]: v,
        [f]: m
      };
    }
  };
}, $S = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: r,
        rects: o,
        platform: s,
        elements: i
      } = t, {
        apply: u = () => {
        },
        ...d
      } = ia(e, t), c = await s.detectOverflow(t, d), f = ua(r), p = Gr(r), v = Un(r) === "y", {
        width: m,
        height: y
      } = o.floating;
      let x, C;
      f === "top" || f === "bottom" ? (x = f, C = p === (await (s.isRTL == null ? void 0 : s.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (C = f, x = p === "end" ? "top" : "bottom");
      const S = y - c.top - c.bottom, $ = m - c.left - c.right, k = Da(y - c[x], S), B = Da(m - c[C], $), P = !t.middlewareData.shift;
      let M = k, q = B;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (q = $), (a = t.middlewareData.shift) != null && a.enabled.y && (M = S), P && !p) {
        const D = dn(c.left, 0), O = dn(c.right, 0), F = dn(c.top, 0), J = dn(c.bottom, 0);
        v ? q = m - 2 * (D !== 0 || O !== 0 ? D + O : dn(c.left, c.right)) : M = y - 2 * (F !== 0 || J !== 0 ? F + J : dn(c.top, c.bottom));
      }
      await u({
        ...t,
        availableWidth: q,
        availableHeight: M
      });
      const E = await s.getDimensions(i.floating);
      return m !== E.width || y !== E.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Si() {
  return typeof window < "u";
}
function lr(e) {
  return Sc(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function cn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Jn(e) {
  var t;
  return (t = (Sc(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Sc(e) {
  return Si() ? e instanceof Node || e instanceof cn(e).Node : !1;
}
function En(e) {
  return Si() ? e instanceof Element || e instanceof cn(e).Element : !1;
}
function Yn(e) {
  return Si() ? e instanceof HTMLElement || e instanceof cn(e).HTMLElement : !1;
}
function Lp(e) {
  return !Si() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof cn(e).ShadowRoot;
}
const BS = /* @__PURE__ */ new Set(["inline", "contents"]);
function vs(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: a,
    display: r
  } = Tn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !BS.has(r);
}
const kS = /* @__PURE__ */ new Set(["table", "td", "th"]);
function PS(e) {
  return kS.has(lr(e));
}
const MS = [":popover-open", ":modal"];
function $i(e) {
  return MS.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const DS = ["transform", "translate", "scale", "rotate", "perspective"], qS = ["transform", "translate", "scale", "rotate", "perspective", "filter"], AS = ["paint", "layout", "strict", "content"];
function $c(e) {
  const t = Bc(), n = En(e) ? Tn(e) : e;
  return DS.some((a) => n[a] ? n[a] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || qS.some((a) => (n.willChange || "").includes(a)) || AS.some((a) => (n.contain || "").includes(a));
}
function ES(e) {
  let t = qa(e);
  for (; Yn(t) && !Rr(t); ) {
    if ($c(t))
      return t;
    if ($i(t))
      return null;
    t = qa(t);
  }
  return null;
}
function Bc() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const TS = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Rr(e) {
  return TS.has(lr(e));
}
function Tn(e) {
  return cn(e).getComputedStyle(e);
}
function Bi(e) {
  return En(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function qa(e) {
  if (lr(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Lp(e) && e.host || // Fallback.
    Jn(e)
  );
  return Lp(t) ? t.host : t;
}
function Qh(e) {
  const t = qa(e);
  return Rr(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Yn(t) && vs(t) ? t : Qh(t);
}
function Ro(e, t, n) {
  var a;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const r = Qh(e), o = r === ((a = e.ownerDocument) == null ? void 0 : a.body), s = cn(r);
  if (o) {
    const i = vd(s);
    return t.concat(s, s.visualViewport || [], vs(r) ? r : [], i && n ? Ro(i) : []);
  }
  return t.concat(r, Ro(r, [], n));
}
function vd(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function eg(e) {
  const t = Tn(e);
  let n = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const r = Yn(e), o = r ? e.offsetWidth : n, s = r ? e.offsetHeight : a, i = Dl(n) !== o || Dl(a) !== s;
  return i && (n = o, a = s), {
    width: n,
    height: a,
    $: i
  };
}
function kc(e) {
  return En(e) ? e : e.contextElement;
}
function Mr(e) {
  const t = kc(e);
  if (!Yn(t))
    return jn(1);
  const n = t.getBoundingClientRect(), {
    width: a,
    height: r,
    $: o
  } = eg(t);
  let s = (o ? Dl(n.width) : n.width) / a, i = (o ? Dl(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: s,
    y: i
  };
}
const IS = /* @__PURE__ */ jn(0);
function tg(e) {
  const t = cn(e);
  return !Bc() || !t.visualViewport ? IS : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function OS(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== cn(e) ? !1 : t;
}
function Qa(e, t, n, a) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = kc(e);
  let s = jn(1);
  t && (a ? En(a) && (s = Mr(a)) : s = Mr(e));
  const i = OS(o, n, a) ? tg(o) : jn(0);
  let u = (r.left + i.x) / s.x, d = (r.top + i.y) / s.y, c = r.width / s.x, f = r.height / s.y;
  if (o) {
    const p = cn(o), v = a && En(a) ? cn(a) : a;
    let m = p, y = vd(m);
    for (; y && a && v !== m; ) {
      const x = Mr(y), C = y.getBoundingClientRect(), S = Tn(y), $ = C.left + (y.clientLeft + parseFloat(S.paddingLeft)) * x.x, k = C.top + (y.clientTop + parseFloat(S.paddingTop)) * x.y;
      u *= x.x, d *= x.y, c *= x.x, f *= x.y, u += $, d += k, m = cn(y), y = vd(m);
    }
  }
  return Al({
    width: c,
    height: f,
    x: u,
    y: d
  });
}
function ki(e, t) {
  const n = Bi(e).scrollLeft;
  return t ? t.left + n : Qa(Jn(e)).left + n;
}
function ng(e, t) {
  const n = e.getBoundingClientRect(), a = n.left + t.scrollLeft - ki(e, n), r = n.top + t.scrollTop;
  return {
    x: a,
    y: r
  };
}
function RS(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: a,
    strategy: r
  } = e;
  const o = r === "fixed", s = Jn(a), i = t ? $i(t.floating) : !1;
  if (a === s || i && o)
    return n;
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = jn(1);
  const c = jn(0), f = Yn(a);
  if ((f || !f && !o) && ((lr(a) !== "body" || vs(s)) && (u = Bi(a)), Yn(a))) {
    const v = Qa(a);
    d = Mr(a), c.x = v.x + a.clientLeft, c.y = v.y + a.clientTop;
  }
  const p = s && !f && !o ? ng(s, u) : jn(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - u.scrollLeft * d.x + c.x + p.x,
    y: n.y * d.y - u.scrollTop * d.y + c.y + p.y
  };
}
function VS(e) {
  return Array.from(e.getClientRects());
}
function FS(e) {
  const t = Jn(e), n = Bi(e), a = e.ownerDocument.body, r = dn(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), o = dn(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let s = -n.scrollLeft + ki(e);
  const i = -n.scrollTop;
  return Tn(a).direction === "rtl" && (s += dn(t.clientWidth, a.clientWidth) - r), {
    width: r,
    height: o,
    x: s,
    y: i
  };
}
const zp = 25;
function NS(e, t) {
  const n = cn(e), a = Jn(e), r = n.visualViewport;
  let o = a.clientWidth, s = a.clientHeight, i = 0, u = 0;
  if (r) {
    o = r.width, s = r.height;
    const c = Bc();
    (!c || c && t === "fixed") && (i = r.offsetLeft, u = r.offsetTop);
  }
  const d = ki(a);
  if (d <= 0) {
    const c = a.ownerDocument, f = c.body, p = getComputedStyle(f), v = c.compatMode === "CSS1Compat" && parseFloat(p.marginLeft) + parseFloat(p.marginRight) || 0, m = Math.abs(a.clientWidth - f.clientWidth - v);
    m <= zp && (o -= m);
  } else d <= zp && (o += d);
  return {
    width: o,
    height: s,
    x: i,
    y: u
  };
}
const LS = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function zS(e, t) {
  const n = Qa(e, !0, t === "fixed"), a = n.top + e.clientTop, r = n.left + e.clientLeft, o = Yn(e) ? Mr(e) : jn(1), s = e.clientWidth * o.x, i = e.clientHeight * o.y, u = r * o.x, d = a * o.y;
  return {
    width: s,
    height: i,
    x: u,
    y: d
  };
}
function Hp(e, t, n) {
  let a;
  if (t === "viewport")
    a = NS(e, n);
  else if (t === "document")
    a = FS(Jn(e));
  else if (En(t))
    a = zS(t, n);
  else {
    const r = tg(e);
    a = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return Al(a);
}
function ag(e, t) {
  const n = qa(e);
  return n === t || !En(n) || Rr(n) ? !1 : Tn(n).position === "fixed" || ag(n, t);
}
function HS(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let a = Ro(e, [], !1).filter((i) => En(i) && lr(i) !== "body"), r = null;
  const o = Tn(e).position === "fixed";
  let s = o ? qa(e) : e;
  for (; En(s) && !Rr(s); ) {
    const i = Tn(s), u = $c(s);
    !u && i.position === "fixed" && (r = null), (o ? !u && !r : !u && i.position === "static" && !!r && LS.has(r.position) || vs(s) && !u && ag(e, s)) ? a = a.filter((c) => c !== s) : r = i, s = qa(s);
  }
  return t.set(e, a), a;
}
function US(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: a,
    strategy: r
  } = e;
  const s = [...n === "clippingAncestors" ? $i(t) ? [] : HS(t, this._c) : [].concat(n), a], i = s[0], u = s.reduce((d, c) => {
    const f = Hp(t, c, r);
    return d.top = dn(f.top, d.top), d.right = Da(f.right, d.right), d.bottom = Da(f.bottom, d.bottom), d.left = dn(f.left, d.left), d;
  }, Hp(t, i, r));
  return {
    width: u.right - u.left,
    height: u.bottom - u.top,
    x: u.left,
    y: u.top
  };
}
function jS(e) {
  const {
    width: t,
    height: n
  } = eg(e);
  return {
    width: t,
    height: n
  };
}
function WS(e, t, n) {
  const a = Yn(t), r = Jn(t), o = n === "fixed", s = Qa(e, !0, o, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const u = jn(0);
  function d() {
    u.x = ki(r);
  }
  if (a || !a && !o)
    if ((lr(t) !== "body" || vs(r)) && (i = Bi(t)), a) {
      const v = Qa(t, !0, o, t);
      u.x = v.x + t.clientLeft, u.y = v.y + t.clientTop;
    } else r && d();
  o && !a && r && d();
  const c = r && !a && !o ? ng(r, i) : jn(0), f = s.left + i.scrollLeft - u.x - c.x, p = s.top + i.scrollTop - u.y - c.y;
  return {
    x: f,
    y: p,
    width: s.width,
    height: s.height
  };
}
function ku(e) {
  return Tn(e).position === "static";
}
function Up(e, t) {
  if (!Yn(e) || Tn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Jn(e) === n && (n = n.ownerDocument.body), n;
}
function rg(e, t) {
  const n = cn(e);
  if ($i(e))
    return n;
  if (!Yn(e)) {
    let r = qa(e);
    for (; r && !Rr(r); ) {
      if (En(r) && !ku(r))
        return r;
      r = qa(r);
    }
    return n;
  }
  let a = Up(e, t);
  for (; a && PS(a) && ku(a); )
    a = Up(a, t);
  return a && Rr(a) && ku(a) && !$c(a) ? n : a || ES(e) || n;
}
const GS = async function(e) {
  const t = this.getOffsetParent || rg, n = this.getDimensions, a = await n(e.floating);
  return {
    reference: WS(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function KS(e) {
  return Tn(e).direction === "rtl";
}
const YS = {
  convertOffsetParentRelativeRectToViewportRelativeRect: RS,
  getDocumentElement: Jn,
  getClippingRect: US,
  getOffsetParent: rg,
  getElementRects: GS,
  getClientRects: VS,
  getDimensions: jS,
  getScale: Mr,
  isElement: En,
  isRTL: KS
};
function og(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function XS(e, t) {
  let n = null, a;
  const r = Jn(e);
  function o() {
    var i;
    clearTimeout(a), (i = n) == null || i.disconnect(), n = null;
  }
  function s(i, u) {
    i === void 0 && (i = !1), u === void 0 && (u = 1), o();
    const d = e.getBoundingClientRect(), {
      left: c,
      top: f,
      width: p,
      height: v
    } = d;
    if (i || t(), !p || !v)
      return;
    const m = Vs(f), y = Vs(r.clientWidth - (c + p)), x = Vs(r.clientHeight - (f + v)), C = Vs(c), $ = {
      rootMargin: -m + "px " + -y + "px " + -x + "px " + -C + "px",
      threshold: dn(0, Da(1, u)) || 1
    };
    let k = !0;
    function B(P) {
      const M = P[0].intersectionRatio;
      if (M !== u) {
        if (!k)
          return s();
        M ? s(!1, M) : a = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      M === 1 && !og(d, e.getBoundingClientRect()) && s(), k = !1;
    }
    try {
      n = new IntersectionObserver(B, {
        ...$,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(B, $);
    }
    n.observe(e);
  }
  return s(!0), o;
}
function JS(e, t, n, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: o = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: u = !1
  } = a, d = kc(e), c = r || o ? [...d ? Ro(d) : [], ...Ro(t)] : [];
  c.forEach((C) => {
    r && C.addEventListener("scroll", n, {
      passive: !0
    }), o && C.addEventListener("resize", n);
  });
  const f = d && i ? XS(d, n) : null;
  let p = -1, v = null;
  s && (v = new ResizeObserver((C) => {
    let [S] = C;
    S && S.target === d && v && (v.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var $;
      ($ = v) == null || $.observe(t);
    })), n();
  }), d && !u && v.observe(d), v.observe(t));
  let m, y = u ? Qa(e) : null;
  u && x();
  function x() {
    const C = Qa(e);
    y && !og(y, C) && n(), y = C, m = requestAnimationFrame(x);
  }
  return n(), () => {
    var C;
    c.forEach((S) => {
      r && S.removeEventListener("scroll", n), o && S.removeEventListener("resize", n);
    }), f?.(), (C = v) == null || C.disconnect(), v = null, u && cancelAnimationFrame(m);
  };
}
const ZS = xS, QS = CS, jp = bS, e$ = $S, t$ = _S, n$ = yS, a$ = SS, r$ = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), r = {
    platform: YS,
    ...n
  }, o = {
    ...r.platform,
    _c: a
  };
  return gS(e, t, {
    ...r,
    platform: o
  });
};
function o$(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function md(e) {
  if (o$(e)) {
    const t = e.$el;
    return Sc(t) && lr(t) === "#comment" ? null : t;
  }
  return e;
}
function wr(e) {
  return typeof e == "function" ? e() : l(e);
}
function s$(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = md(wr(e.element));
      return n == null ? {} : n$({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
function sg(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Wp(e, t) {
  const n = sg(e);
  return Math.round(t * n) / n;
}
function l$(e, t, n) {
  n === void 0 && (n = {});
  const a = n.whileElementsMounted, r = A(() => {
    var M;
    return (M = wr(n.open)) != null ? M : !0;
  }), o = A(() => wr(n.middleware)), s = A(() => {
    var M;
    return (M = wr(n.placement)) != null ? M : "bottom";
  }), i = A(() => {
    var M;
    return (M = wr(n.strategy)) != null ? M : "absolute";
  }), u = A(() => {
    var M;
    return (M = wr(n.transform)) != null ? M : !0;
  }), d = A(() => md(e.value)), c = A(() => md(t.value)), f = I(0), p = I(0), v = I(i.value), m = I(s.value), y = ht({}), x = I(!1), C = A(() => {
    const M = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return M;
    const q = Wp(c.value, f.value), E = Wp(c.value, p.value);
    return u.value ? {
      ...M,
      transform: "translate(" + q + "px, " + E + "px)",
      ...sg(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: q + "px",
      top: E + "px"
    };
  });
  let S;
  function $() {
    if (d.value == null || c.value == null)
      return;
    const M = r.value;
    r$(d.value, c.value, {
      middleware: o.value,
      placement: s.value,
      strategy: i.value
    }).then((q) => {
      f.value = q.x, p.value = q.y, v.value = q.strategy, m.value = q.placement, y.value = q.middlewareData, x.value = M !== !1;
    });
  }
  function k() {
    typeof S == "function" && (S(), S = void 0);
  }
  function B() {
    if (k(), a === void 0) {
      $();
      return;
    }
    if (d.value != null && c.value != null) {
      S = a(d.value, c.value, $);
      return;
    }
  }
  function P() {
    r.value || (x.value = !1);
  }
  return me([o, s, i, r], $, {
    flush: "sync"
  }), me([d, c], B, {
    flush: "sync"
  }), me(r, P, {
    flush: "sync"
  }), es() && Qd(k), {
    x: Ha(f),
    y: Ha(p),
    strategy: Ha(v),
    placement: Ha(m),
    middlewareData: Ha(y),
    isPositioned: Ha(x),
    floatingStyles: C,
    update: $
  };
}
const lg = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: !0,
  align: "center",
  alignOffset: 0,
  alignFlip: !0,
  arrowPadding: 0,
  hideShiftedArrow: !0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [i$, u$] = Se("PopperContent");
var d$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ Ym({
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...lg }),
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Xh(), { forwardRef: o, currentElement: s } = j(), i = I(), u = I(), { width: d, height: c } = Ih(u), f = A(() => n.side + (n.align !== "center" ? `-${n.align}` : "")), p = A(() => typeof n.collisionPadding == "number" ? n.collisionPadding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...n.collisionPadding
    }), v = A(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), m = A(() => ({
      padding: p.value,
      boundary: v.value.filter(aS),
      altBoundary: v.value.length > 0
    })), y = A(() => ({
      mainAxis: n.sideFlip,
      crossAxis: n.alignFlip
    })), x = w0(() => [
      ZS({
        mainAxis: n.sideOffset + c.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && jp({
        ...m.value,
        ...y.value
      }),
      n.avoidCollisions && QS({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? a$() : void 0,
        ...m.value
      }),
      !n.prioritizePosition && n.avoidCollisions && jp({
        ...m.value,
        ...y.value
      }),
      e$({
        ...m.value,
        apply: ({ elements: F, rects: J, availableWidth: ne, availableHeight: Q }) => {
          const { width: W, height: H } = J.reference, U = F.floating.style;
          U.setProperty("--reka-popper-available-width", `${ne}px`), U.setProperty("--reka-popper-available-height", `${Q}px`), U.setProperty("--reka-popper-anchor-width", `${W}px`), U.setProperty("--reka-popper-anchor-height", `${H}px`);
        }
      }),
      u.value && s$({
        element: u.value,
        padding: n.arrowPadding
      }),
      rS({
        arrowWidth: d.value,
        arrowHeight: c.value
      }),
      n.hideWhenDetached && t$({
        strategy: "referenceHidden",
        ...m.value
      })
    ]), C = A(() => n.reference ?? r.anchor.value), { floatingStyles: S, placement: $, isPositioned: k, middlewareData: B } = l$(C, i, {
      strategy: n.positionStrategy,
      placement: f,
      whileElementsMounted: (...F) => JS(...F, {
        layoutShift: !n.disableUpdateOnLayoutShift,
        animationFrame: n.updatePositionStrategy === "always"
      }),
      middleware: x
    }), P = A(() => cd($.value)[0]), M = A(() => cd($.value)[1]);
    Km(() => {
      k.value && a("placed");
    });
    const q = A(() => {
      const F = B.value.arrow?.centerOffset !== 0;
      return n.hideShiftedArrow && F;
    }), E = I("");
    Te(() => {
      s.value && (E.value = window.getComputedStyle(s.value).zIndex);
    });
    const D = A(() => B.value.arrow?.x ?? 0), O = A(() => B.value.arrow?.y ?? 0);
    return u$({
      placedSide: P,
      onArrowChange: (F) => u.value = F,
      arrowX: D,
      arrowY: O,
      shouldHideArrow: q
    }), (F, J) => (h(), G("div", {
      ref_key: "floatingRef",
      ref: i,
      "data-reka-popper-content-wrapper": "",
      style: dt({
        ...l(S),
        transform: l(k) ? l(S).transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: E.value,
        "--reka-popper-transform-origin": [l(B).transformOrigin?.x, l(B).transformOrigin?.y].join(" "),
        ...l(B).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [N(l(X), T({ ref: l(o) }, F.$attrs, {
      "as-child": n.asChild,
      as: F.as,
      "data-side": P.value,
      "data-align": M.value,
      style: { animation: l(k) ? void 0 : "none" }
    }), {
      default: g(() => [_(F.$slots, "default")]),
      _: 3
    }, 16, [
      "as-child",
      "as",
      "data-side",
      "data-align",
      "style"
    ])], 4));
  }
}), Kr = d$;
const c$ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var f$ = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {
      type: Number,
      required: !1
    },
    height: {
      type: Number,
      required: !1
    },
    rounded: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = i$(), a = A(() => c$[n.placedSide.value]);
    return (r, o) => (h(), G("span", {
      ref: (s) => {
        l(n).onArrowChange(s);
      },
      style: dt({
        position: "absolute",
        left: l(n).arrowX?.value ? `${l(n).arrowX?.value}px` : void 0,
        top: l(n).arrowY?.value ? `${l(n).arrowY?.value}px` : void 0,
        [a.value]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[l(n).placedSide.value],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[l(n).placedSide.value],
        visibility: l(n).shouldHideArrow.value ? "hidden" : void 0
      })
    }, [N(nS, T(r.$attrs, {
      ref: l(t),
      style: { display: "block" },
      as: r.as,
      "as-child": r.asChild,
      rounded: r.rounded,
      width: r.width,
      height: r.height
    }), {
      default: g(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "rounded",
      "width",
      "height"
    ])], 4));
  }
}), p$ = f$, v$ = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { forwardRef: t } = j();
    return (n, a) => (h(), w(l(sr), {
      "as-child": "",
      reference: n.reference
    }, {
      default: g(() => [N(l(X), T({
        ref: l(t),
        "as-child": n.asChild,
        as: n.as
      }, n.$attrs), {
        default: g(() => [_(n.$slots, "default")]),
        _: 3
      }, 16, ["as-child", "as"])]),
      _: 3
    }, 8, ["reference"]));
  }
}), m$ = v$;
function h$(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => Mo(a, t, n)) : Mo(e, t, n);
}
function Mo(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : Dn(e, t);
}
const [Pi, g$] = Se("ListboxRoot");
var y$ = /* @__PURE__ */ b({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    selectionBehavior: {
      type: String,
      required: !1,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: !1
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { multiple: o, highlightOnHover: s, orientation: i, disabled: u, selectionBehavior: d, dir: c } = qe(a), { getItems: f } = st({ isProvider: !0 }), { handleTypeaheadSearch: p } = hi(), { primitiveElement: v, currentElement: m } = Lt(), y = is(), x = gt(c), C = In(m), S = I(), $ = I(!1), k = I(!0), B = /* @__PURE__ */ Ie(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (o.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function P(V) {
      if ($.value = !0, a.multiple) {
        const te = Array.isArray(B.value) ? [...B.value] : [], z = te.findIndex((re) => Mo(re, V, a.by));
        a.selectionBehavior === "toggle" ? (z === -1 ? te.push(V) : te.splice(z, 1), B.value = te) : (B.value = [V], S.value = V);
      } else a.selectionBehavior === "toggle" && Mo(B.value, V, a.by) ? B.value = void 0 : B.value = V;
      setTimeout(() => {
        $.value = !1;
      }, 1);
    }
    const M = I(null), q = I(null), E = I(!1), D = I(!1), O = /* @__PURE__ */ Sr(), F = /* @__PURE__ */ Sr(), J = /* @__PURE__ */ Sr();
    function ne() {
      return f().map((V) => V.ref).filter((V) => V.dataset.disabled !== "");
    }
    function Q(V, te = !0) {
      if (!V) return;
      M.value = V, k.value && M.value.focus(), te && M.value.scrollIntoView({ block: "nearest" });
      const z = f().find((re) => re.ref === V);
      r("highlight", z);
    }
    function W(V) {
      if (E.value) J.trigger(V);
      else {
        const te = f().find((z) => Mo(z.value, V, a.by));
        te && (M.value = te.ref, Q(te.ref));
      }
    }
    function H(V) {
      M.value && M.value.isConnected && (V.preventDefault(), V.stopPropagation(), D.value || M.value.click());
    }
    function U(V) {
      if (k.value) {
        if ($.value = !0, E.value) F.trigger(V);
        else {
          const te = V.altKey || V.ctrlKey || V.metaKey;
          if (te && V.key === "a" && o.value) {
            const z = f(), re = z.map((ie) => ie.value);
            B.value = [...re], V.preventDefault(), Q(z[z.length - 1].ref);
          } else if (!te) {
            const z = p(V.key, f());
            z && Q(z);
          }
        }
        setTimeout(() => {
          $.value = !1;
        }, 1);
      }
    }
    function se() {
      D.value = !0;
    }
    function ee() {
      Pe(() => {
        D.value = !1;
      });
    }
    function de() {
      Pe(() => {
        const V = new KeyboardEvent("keydown", { key: "PageUp" });
        ye(V);
      });
    }
    function fe(V) {
      const te = M.value;
      te?.isConnected && (q.value = te), M.value = null, r("leave", V);
    }
    function _e(V) {
      const te = new CustomEvent("listbox.entryFocus", {
        bubbles: !1,
        cancelable: !0
      });
      if (V.currentTarget?.dispatchEvent(te), r("entryFocus", te), !te.defaultPrevented)
        if (q.value) Q(q.value);
        else {
          const z = ne()?.[0];
          Q(z);
        }
    }
    function ye(V) {
      const te = Gh(V, i.value, x.value);
      if (!te) return;
      let z = ne();
      if (M.value) {
        if (te === "last") z.reverse();
        else if (te === "prev" || te === "next") {
          te === "prev" && z.reverse();
          const re = z.indexOf(M.value);
          z = z.slice(re + 1);
        }
        Ee(V, z[0]);
      }
      if (z.length) {
        const re = !M.value && te === "prev" ? z.length - 1 : 0;
        Q(z[re]);
      }
      if (E.value) return F.trigger(V);
    }
    function Ee(V, te) {
      if (!(E.value || a.selectionBehavior !== "replace" || !o.value || !Array.isArray(B.value) || (V.altKey || V.ctrlKey || V.metaKey) && !V.shiftKey) && V.shiftKey) {
        const re = f().filter((be) => be.ref.dataset.disabled !== "");
        let ie = re.find((be) => be.ref === te)?.value;
        if (V.key === y.END ? ie = re[re.length - 1].value : V.key === y.HOME && (ie = re[0].value), !ie || !S.value) return;
        const L = y0(re.map((be) => be.value), S.value, ie);
        B.value = L;
      }
    }
    async function ce(V) {
      if (await Pe(), E.value) O.trigger(V);
      else {
        const te = ne(), z = te.find((re) => re.dataset.state === "checked");
        z ? Q(z) : te.length && Q(te[0]);
      }
    }
    return me(B, () => {
      $.value || Pe(() => {
        ce();
      });
    }, {
      immediate: !0,
      deep: !0
    }), t({
      highlightedElement: M,
      highlightItem: W,
      highlightFirstItem: de,
      highlightSelected: ce,
      getItems: f
    }), g$({
      modelValue: B,
      onValueChange: P,
      multiple: o,
      orientation: i,
      dir: x,
      disabled: u,
      highlightOnHover: s,
      highlightedElement: M,
      isVirtual: E,
      virtualFocusHook: O,
      virtualKeydownHook: F,
      virtualHighlightHook: J,
      by: a.by,
      firstValue: S,
      selectionBehavior: d,
      focusable: k,
      onLeave: fe,
      onEnter: _e,
      changeHighlight: Q,
      onKeydownEnter: H,
      onKeydownNavigation: ye,
      onKeydownTypeAhead: U,
      onCompositionStart: se,
      onCompositionEnd: ee,
      highlightFirstItem: de
    }), (V, te) => (h(), w(l(X), {
      ref_key: "primitiveElement",
      ref: v,
      as: V.as,
      "as-child": V.asChild,
      dir: l(x),
      "data-disabled": l(u) ? "" : void 0,
      onPointerleave: fe,
      onFocusout: te[0] || (te[0] = async (z) => {
        const re = z.relatedTarget || z.target;
        await Pe(), M.value && l(m) && !l(m).contains(re) && fe(z);
      })
    }, {
      default: g(() => [_(V.$slots, "default", { modelValue: l(B) }), l(C) && V.name ? (h(), w(l(On), {
        key: 0,
        name: V.name,
        value: l(B),
        disabled: l(u),
        required: V.required
      }, null, 8, [
        "name",
        "value",
        "disabled",
        "required"
      ])) : De("v-if", !0)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "dir",
      "data-disabled"
    ]));
  }
}), ig = y$, b$ = /* @__PURE__ */ b({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const { CollectionSlot: t } = st(), n = Pi(), a = rs(!1, 10);
    return (r, o) => (h(), w(l(t), null, {
      default: g(() => [N(l(X), {
        role: "listbox",
        as: r.as,
        "as-child": r.asChild,
        tabindex: l(n).focusable.value ? l(n).highlightedElement.value ? "-1" : "0" : "-1",
        "aria-orientation": l(n).orientation.value,
        "aria-multiselectable": !!l(n).multiple.value,
        "data-orientation": l(n).orientation.value,
        onMousedown: o[0] || (o[0] = Ye((s) => a.value = !0, ["left"])),
        onFocus: o[1] || (o[1] = (s) => {
          l(a) || l(n).onEnter(s);
        }),
        onKeydown: [
          o[2] || (o[2] = Je((s) => {
            l(n).orientation.value === "vertical" && (s.key === "ArrowLeft" || s.key === "ArrowRight") || l(n).orientation.value === "horizontal" && (s.key === "ArrowUp" || s.key === "ArrowDown") || (s.preventDefault(), l(n).focusable.value && l(n).onKeydownNavigation(s));
          }, [
            "down",
            "up",
            "left",
            "right",
            "home",
            "end"
          ])),
          Je(l(n).onKeydownEnter, ["enter"]),
          l(n).onKeydownTypeAhead
        ]
      }, {
        default: g(() => [_(r.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "tabindex",
        "aria-orientation",
        "aria-multiselectable",
        "data-orientation",
        "onKeydown"
      ])]),
      _: 3
    }));
  }
}), ug = b$, _$ = /* @__PURE__ */ b({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ie(n, "modelValue", t, {
      defaultValue: "",
      passive: n.modelValue === void 0
    }), o = Pi(), { primitiveElement: s, currentElement: i } = Lt(), u = A(() => n.disabled || o.disabled.value || !1), d = I();
    return r0(() => d.value = o.highlightedElement.value?.id), Ce(() => {
      o.focusable.value = !1, setTimeout(() => {
        n.autoFocus && i.value?.focus();
      }, 1);
    }), nt(() => {
      o.focusable.value = !0;
    }), (c, f) => (h(), w(l(X), {
      ref_key: "primitiveElement",
      ref: s,
      as: c.as,
      "as-child": c.asChild,
      value: l(r),
      disabled: u.value ? "" : void 0,
      "data-disabled": u.value ? "" : void 0,
      "aria-disabled": u.value ?? void 0,
      "aria-activedescendant": d.value,
      type: "text",
      onKeydown: [Je(Ye(l(o).onKeydownNavigation, ["prevent"]), [
        "down",
        "up",
        "home",
        "end"
      ]), Je(l(o).onKeydownEnter, ["enter"])],
      onInput: f[0] || (f[0] = (p) => {
        r.value = p.target.value, l(o).highlightFirstItem();
      }),
      onCompositionstart: l(o).onCompositionStart,
      onCompositionend: l(o).onCompositionEnd
    }, {
      default: g(() => [_(c.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "value",
      "disabled",
      "data-disabled",
      "aria-disabled",
      "aria-activedescendant",
      "onKeydown",
      "onCompositionstart",
      "onCompositionend"
    ]));
  }
}), dg = _$;
const [w$, x$] = Se("ListboxGroup");
var C$ = /* @__PURE__ */ b({
  __name: "ListboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ke(void 0, "reka-listbox-group");
    return x$({ id: n }), (a, r) => (h(), w(l(X), T({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), cg = C$, S$ = /* @__PURE__ */ b({
  __name: "ListboxGroupLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = w$({ id: "" });
    return (a, r) => (h(), w(l(X), T(t, { id: l(n).id }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), $$ = S$;
const B$ = "listbox.select", [k$, P$] = Se("ListboxItem");
var M$ = /* @__PURE__ */ b({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ke(void 0, "reka-listbox-item"), { CollectionItem: o } = st(), { forwardRef: s, currentElement: i } = j(), u = Pi(), d = A(() => i.value === u.highlightedElement.value), c = A(() => h$(u.modelValue.value, n.value, u.by)), f = A(() => u.disabled.value || n.disabled);
    async function p(m) {
      a("select", m), !m?.defaultPrevented && !f.value && m && (u.onValueChange(n.value), u.changeHighlight(i.value));
    }
    function v(m) {
      const y = {
        originalEvent: m,
        value: n.value
      };
      ns(B$, p, y);
    }
    return P$({ isSelected: c }), (m, y) => (h(), w(l(o), { value: m.value }, {
      default: g(() => [o0([d.value, c.value], () => N(l(X), T({ id: l(r) }, m.$attrs, {
        ref: l(s),
        role: "option",
        tabindex: l(u).focusable.value ? d.value ? "0" : "-1" : -1,
        "aria-selected": c.value,
        as: m.as,
        "as-child": m.asChild,
        disabled: f.value ? "" : void 0,
        "data-disabled": f.value ? "" : void 0,
        "data-highlighted": d.value ? "" : void 0,
        "data-state": c.value ? "checked" : "unchecked",
        onClick: v,
        onKeydown: Je(Ye(v, ["prevent"]), ["space"]),
        onPointermove: y[0] || (y[0] = () => {
          l(u).highlightedElement.value !== l(i) && l(u).highlightOnHover.value && !l(u).focusable.value && l(u).changeHighlight(l(i), !1);
        })
      }), {
        default: g(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "tabindex",
        "aria-selected",
        "as",
        "as-child",
        "disabled",
        "data-disabled",
        "data-highlighted",
        "data-state",
        "onKeydown"
      ]), y, 1)]),
      _: 3
    }, 8, ["value"]));
  }
}), fg = M$, D$ = /* @__PURE__ */ b({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = k$();
    return (a, r) => l(n).isSelected.value ? (h(), w(l(X), T({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : De("v-if", !0);
  }
}), q$ = D$;
const [ma, A$] = Se("ComboboxRoot");
var E$ = /* @__PURE__ */ b({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: !1,
      default: !0
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: !1,
      default: !0
    },
    openOnFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    openOnClick: {
      type: Boolean,
      required: !1,
      default: !1
    },
    ignoreFilter: {
      type: Boolean,
      required: !1
    },
    resetModelValueOnClear: {
      type: Boolean,
      required: !1,
      default: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    highlightOnHover: {
      type: Boolean,
      required: !1,
      default: !0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { primitiveElement: o, currentElement: s } = Lt(), { multiple: i, disabled: u, ignoreFilter: d, resetSearchTermOnSelect: c, openOnFocus: f, openOnClick: p, dir: v, resetModelValueOnClear: m, highlightOnHover: y } = qe(a), x = gt(v), C = /* @__PURE__ */ Ie(a, "modelValue", r, {
      defaultValue: a.defaultValue ?? (i.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), S = /* @__PURE__ */ Ie(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function $(W) {
      S.value = W, J.value = "", W ? (await Pe(), o.value?.highlightSelected(), B.value = !0, M.value?.focus()) : (B.value = !1, setTimeout(() => {
        !W && a.resetSearchTermOnBlur && k.trigger();
      }, 1));
    }
    const k = /* @__PURE__ */ Sr(), B = I(!1), P = I(!1), M = I(), q = I(), E = A(() => o.value?.highlightedElement ?? void 0), D = I(/* @__PURE__ */ new Map()), O = I(/* @__PURE__ */ new Map()), { contains: F } = Ah({ sensitivity: "base" }), J = I(""), ne = A((W) => {
      if (!J.value || a.ignoreFilter || P.value) return {
        count: D.value.size,
        items: W?.items ?? /* @__PURE__ */ new Map(),
        groups: W?.groups ?? new Set(O.value.keys())
      };
      let H = 0;
      const U = /* @__PURE__ */ new Map(), se = /* @__PURE__ */ new Set();
      for (const [ee, de] of D.value) {
        const fe = F(de, J.value);
        U.set(ee, fe ? 1 : 0), fe && H++;
      }
      for (const [ee, de] of O.value) for (const fe of de) if (U.get(fe) > 0) {
        se.add(ee);
        break;
      }
      return {
        count: H,
        items: U,
        groups: se
      };
    }), Q = zt();
    return Ce(() => {
      Q?.exposed && (Q.exposed.highlightItem = o.value?.highlightItem, Q.exposed.highlightFirstItem = o.value?.highlightFirstItem, Q.exposed.highlightSelected = o.value?.highlightSelected);
    }), t({
      filtered: ne,
      highlightedElement: E,
      highlightItem: o.value?.highlightItem,
      highlightFirstItem: o.value?.highlightFirstItem,
      highlightSelected: o.value?.highlightSelected
    }), A$({
      modelValue: C,
      multiple: i,
      disabled: u,
      open: S,
      onOpenChange: $,
      contentId: "",
      isUserInputted: B,
      isVirtual: P,
      inputElement: M,
      highlightedElement: E,
      onInputElementChange: (W) => M.value = W,
      triggerElement: q,
      onTriggerElementChange: (W) => q.value = W,
      parentElement: s,
      resetSearchTermOnSelect: c,
      onResetSearchTerm: k.on,
      allItems: D,
      allGroups: O,
      filterSearch: J,
      filterState: ne,
      ignoreFilter: d,
      openOnFocus: f,
      openOnClick: p,
      resetModelValueOnClear: m
    }), (W, H) => (h(), w(l(or), null, {
      default: g(() => [N(l(ig), T({
        ref_key: "primitiveElement",
        ref: o
      }, W.$attrs, {
        modelValue: l(C),
        "onUpdate:modelValue": H[0] || (H[0] = (U) => Ct(C) ? C.value = U : null),
        style: { pointerEvents: l(S) ? "auto" : void 0 },
        as: W.as,
        "as-child": W.asChild,
        dir: l(x),
        multiple: l(i),
        name: W.name,
        required: W.required,
        disabled: l(u),
        "highlight-on-hover": l(y),
        by: a.by,
        onHighlight: H[1] || (H[1] = (U) => r("highlight", U))
      }), {
        default: g(() => [_(W.$slots, "default", {
          open: l(S),
          modelValue: l(C)
        })]),
        _: 3
      }, 16, [
        "modelValue",
        "style",
        "as",
        "as-child",
        "dir",
        "multiple",
        "name",
        "required",
        "disabled",
        "highlight-on-hover",
        "by"
      ])]),
      _: 3
    }));
  }
}), T$ = E$;
const [eH, I$] = Se("ComboboxContent");
var O$ = /* @__PURE__ */ b({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { position: r } = qe(n), o = ma(), { forwardRef: s, currentElement: i } = j();
    os(n.bodyLock), mi(), ls(o.parentElement);
    const u = A(() => n.position === "popper" ? n : {}), d = he(u.value), c = {
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    I$({ position: r });
    const f = I(!1);
    return Ce(() => {
      o.inputElement.value && (f.value = i.value.contains(o.inputElement.value), f.value && o.inputElement.value.focus());
    }), nt(() => {
      const p = rt();
      f.value && (!p || p === document.body) && o.triggerElement.value?.focus();
    }), (p, v) => (h(), w(l(ug), { "as-child": "" }, {
      default: g(() => [N(l(us), {
        "as-child": "",
        onMountAutoFocus: v[5] || (v[5] = Ye(() => {
        }, ["prevent"]))
      }, {
        default: g(() => [N(l(Oa), {
          "as-child": "",
          "disable-outside-pointer-events": p.disableOutsidePointerEvents,
          onDismiss: v[0] || (v[0] = (m) => l(o).onOpenChange(!1)),
          onFocusOutside: v[1] || (v[1] = (m) => {
            l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("focusOutside", m);
          }),
          onInteractOutside: v[2] || (v[2] = (m) => a("interactOutside", m)),
          onEscapeKeyDown: v[3] || (v[3] = (m) => a("escapeKeyDown", m)),
          onPointerDownOutside: v[4] || (v[4] = (m) => {
            l(o).parentElement.value?.contains(m.target) && m.preventDefault(), a("pointerDownOutside", m);
          })
        }, {
          default: g(() => [(h(), w(Pt(l(r) === "popper" ? l(Kr) : l(X)), T({
            ...p.$attrs,
            ...l(d)
          }, {
            id: l(o).contentId,
            ref: l(s),
            "data-state": l(o).open.value ? "open" : "closed",
            style: {
              display: "flex",
              flexDirection: "column",
              outline: "none",
              ...l(r) === "popper" ? c : {}
            }
          }), {
            default: g(() => [_(p.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "data-state",
            "style"
          ]))]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      })]),
      _: 3
    }));
  }
}), R$ = O$, V$ = /* @__PURE__ */ b({
  __name: "ComboboxCancel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = ma();
    function a() {
      n.filterSearch.value = "", n.inputElement.value && (n.inputElement.value.value = "", n.inputElement.value.focus()), n.resetModelValueOnClear?.value && (n.modelValue.value = n.multiple.value ? [] : null);
    }
    return (r, o) => (h(), w(l(X), T({ type: r.as === "button" ? "button" : void 0 }, t, {
      tabindex: "-1",
      onClick: a
    }), {
      default: g(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["type"]));
  }
}), tH = V$, F$ = /* @__PURE__ */ b({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), { forwardRef: o } = j(), s = ma();
    return s.contentId ||= Ke(void 0, "reka-combobox-content"), (i, u) => (h(), w(l(yt), { present: i.forceMount || l(s).open.value }, {
      default: g(() => [N(R$, T({
        ...l(r),
        ...i.$attrs
      }, { ref: l(o) }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), N$ = F$, L$ = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ma(), a = A(() => n.ignoreFilter.value ? n.allItems.value.size === 0 : n.filterState.value.count === 0);
    return (r, o) => a.value ? (h(), w(l(X), oe(T({ key: 0 }, t)), {
      default: g(() => [_(r.$slots, "default", {}, () => [o[0] || (o[0] = Re("No options"))])]),
      _: 3
    }, 16)) : De("v-if", !0);
  }
}), z$ = L$;
const [pg, H$] = Se("ComboboxGroup");
var U$ = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ke(void 0, "reka-combobox-group"), a = ma(), r = A(() => a.ignoreFilter.value ? !0 : a.filterSearch.value ? a.filterState.value.groups.has(n) : !0), o = H$({
      id: n,
      labelId: ""
    });
    return Ce(() => {
      a.allGroups.value.has(n) || a.allGroups.value.set(n, /* @__PURE__ */ new Set());
    }), nt(() => {
      a.allGroups.value.delete(n);
    }), (s, i) => (h(), w(l(cg), T({
      id: l(n),
      "aria-labelledby": l(o).labelId
    }, t, { hidden: r.value ? void 0 : !0 }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "hidden"
    ]));
  }
}), j$ = U$, W$ = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: !1
    },
    modelValue: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ma(), o = Pi(), { primitiveElement: s, currentElement: i } = Lt(), u = /* @__PURE__ */ Ie(n, "modelValue", a, { passive: n.modelValue === void 0 });
    Ce(() => {
      i.value && r.onInputElementChange(i.value);
    });
    function d(m) {
      r.open.value || r.onOpenChange(!0);
    }
    function c(m) {
      const y = m.target;
      r.open.value ? r.filterSearch.value = y.value : (r.onOpenChange(!0), Pe(() => {
        y.value && (r.filterSearch.value = y.value, o.highlightFirstItem());
      }));
    }
    function f() {
      r.openOnFocus.value && !r.open.value && r.onOpenChange(!0);
    }
    function p() {
      r.openOnClick.value && !r.open.value && r.onOpenChange(!0);
    }
    function v() {
      const m = r.modelValue.value;
      n.displayValue ? u.value = n.displayValue(m) : !r.multiple.value && m && !Array.isArray(m) && typeof m != "object" ? u.value = m.toString() : u.value = "", Pe(() => {
        u.value = u.value;
      });
    }
    return r.onResetSearchTerm(() => {
      v();
    }), me(r.modelValue, async () => {
      !r.isUserInputted.value && r.resetSearchTermOnSelect.value && v();
    }, {
      immediate: !0,
      deep: !0
    }), me(r.filterState, (m, y) => {
      !r.isVirtual.value && y.count === 0 && o.highlightFirstItem();
    }), (m, y) => (h(), w(l(dg), {
      ref_key: "primitiveElement",
      ref: s,
      modelValue: l(u),
      "onUpdate:modelValue": y[0] || (y[0] = (x) => Ct(u) ? u.value = x : null),
      as: m.as,
      "as-child": m.asChild,
      "auto-focus": m.autoFocus,
      disabled: m.disabled,
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "off",
      onClick: p,
      onInput: c,
      onKeydown: Je(Ye(d, ["prevent"]), ["down", "up"]),
      onFocus: f
    }, {
      default: g(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, [
      "modelValue",
      "as",
      "as-child",
      "auto-focus",
      "disabled",
      "aria-expanded",
      "aria-controls",
      "onKeydown"
    ]));
  }
}), G$ = W$, K$ = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ke(void 0, "reka-combobox-item"), o = ma(), s = pg(null), { primitiveElement: i, currentElement: u } = Lt();
    if (n.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const d = A(() => {
      if (o.isVirtual.value || o.ignoreFilter.value || !o.filterSearch.value) return !0;
      {
        const c = o.filterState.value.items.get(r);
        return c === void 0 ? !0 : c > 0;
      }
    });
    return Ce(() => {
      o.allItems.value.set(r, n.textValue || u.value.textContent || u.value.innerText);
      const c = s?.id;
      c && (o.allGroups.value.has(c) ? o.allGroups.value.get(c)?.add(r) : o.allGroups.value.set(c, /* @__PURE__ */ new Set([r])));
    }), nt(() => {
      o.allItems.value.delete(r);
    }), (c, f) => d.value ? (h(), w(l(fg), T({ key: 0 }, n, {
      id: l(r),
      ref_key: "primitiveElement",
      ref: i,
      disabled: l(o).disabled.value || c.disabled,
      onSelect: f[0] || (f[0] = (p) => {
        a("select", p), !p.defaultPrevented && !l(o).multiple.value && !c.disabled && !l(o).disabled.value && (p.preventDefault(), l(o).onOpenChange(!1), l(o).modelValue.value = n.value);
      })
    }), {
      default: g(() => [_(c.$slots, "default", {}, () => [Re(Fe(c.value), 1)])]),
      _: 3
    }, 16, ["id", "disabled"])) : De("v-if", !0);
  }
}), Y$ = K$, X$ = /* @__PURE__ */ b({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(q$), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nH = X$, J$ = /* @__PURE__ */ b({
  __name: "ComboboxLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = pg({
      id: "",
      labelId: ""
    });
    return n.labelId ||= Ke(void 0, "reka-combobox-group-label"), (a, r) => (h(), w(l(X), T(t, { id: l(n).labelId }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Z$ = J$, Q$ = /* @__PURE__ */ b({
  __name: "ComboboxPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), eB = Q$, tB = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(X), T(t, { "aria-hidden": "true" }), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nB = tB, aB = /* @__PURE__ */ b({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = ma(), o = A(() => t.disabled || r.disabled.value || !1);
    return Ce(() => {
      a.value && r.onTriggerElementChange(a.value);
    }), (s, i) => (h(), w(l(X), T(t, {
      ref: l(n),
      type: s.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": l(r).open.value,
      "aria-controls": l(r).contentId,
      "data-state": l(r).open.value ? "open" : "closed",
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "aria-disabled": o.value ?? void 0,
      onClick: i[0] || (i[0] = (u) => l(r).onOpenChange(!l(r).open.value))
    }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "aria-expanded",
      "aria-controls",
      "data-state",
      "disabled",
      "data-disabled",
      "aria-disabled"
    ]));
  }
}), aH = aB;
function Mi(e) {
  const t = as({ nonce: I() });
  return A(() => e?.value || t.nonce?.value);
}
var rB = /* @__PURE__ */ b({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), { nonce: a } = qe(t), r = Mi(a), o = ma();
    return (s, i) => (h(), G(Ge, null, [N(l(X), T({
      ...s.$attrs,
      ...t
    }, {
      ref: l(n),
      "data-reka-combobox-viewport": "",
      role: "presentation",
      style: {
        position: "relative",
        flex: l(o).isVirtual.value ? void 0 : 1,
        overflow: "auto"
      }
    }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["style"]), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: g(() => i[0] || (i[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), oB = rB, sB = /* @__PURE__ */ b({
  __name: "MenuAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(sr), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Di = sB;
function lB() {
  const e = I(!1);
  return Ce(() => {
    ct("keydown", () => {
      e.value = !0;
    }, {
      capture: !0,
      passive: !0
    }), ct(["pointerdown", "pointermove"], () => {
      e.value = !1;
    }, {
      capture: !0,
      passive: !0
    });
  }), e;
}
const iB = /* @__PURE__ */ nh(lB), [ir, vg] = Se(["MenuRoot", "MenuSub"], "MenuContext"), [ms, uB] = Se("MenuRoot");
var dB = /* @__PURE__ */ b({
  __name: "MenuRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: !1
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r, dir: o } = qe(n), s = gt(o), i = /* @__PURE__ */ Ie(n, "open", a), u = I(), d = iB();
    return vg({
      open: i,
      onOpenChange: (c) => {
        i.value = c;
      },
      content: u,
      onContentChange: (c) => {
        u.value = c;
      }
    }), uB({
      onClose: () => {
        i.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: s,
      modal: r
    }), (c, f) => (h(), w(l(or), null, {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }));
  }
}), Pc = dB;
const [Mc, cB] = Se("MenuContent");
var fB = /* @__PURE__ */ b({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ Ym({
    loop: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    disableOutsideScroll: {
      type: Boolean,
      required: !1
    },
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  }, { ...lg }),
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus",
    "dismiss"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ir(), o = ms(), { trapFocus: s, disableOutsidePointerEvents: i, loop: u } = qe(n);
    mi(), os(i.value);
    const d = I(""), c = I(0), f = I(0), p = I(null), v = I("right"), m = I(0), y = I(null), x = I(), { forwardRef: C, currentElement: S } = j(), { handleTypeaheadSearch: $ } = hi();
    me(S, (E) => {
      r.onContentChange(E);
    }), nt(() => {
      window.clearTimeout(c.value);
    });
    function k(E) {
      return v.value === p.value?.side && ix(E, p.value?.area);
    }
    async function B(E) {
      a("openAutoFocus", E), !E.defaultPrevented && (E.preventDefault(), S.value?.focus({ preventScroll: !0 }));
    }
    function P(E) {
      if (E.defaultPrevented) return;
      const O = E.target.closest("[data-reka-menu-content]") === E.currentTarget, F = E.ctrlKey || E.altKey || E.metaKey, J = E.key.length === 1, ne = rr(E, rt(), S.value, {
        loop: u.value,
        arrowKeyOptions: "vertical",
        dir: o?.dir.value,
        focus: !0,
        attributeName: "[data-reka-collection-item]:not([data-disabled])"
      });
      if (ne) return ne?.focus();
      if (E.code === "Space") return;
      const Q = x.value?.getItems() ?? [];
      if (O && (E.key === "Tab" && E.preventDefault(), !F && J && $(E.key, Q)), E.target !== S.value || !rx.includes(E.key)) return;
      E.preventDefault();
      const W = [...Q.map((H) => H.ref)];
      Hh.includes(E.key) && W.reverse(), dd(W);
    }
    function M(E) {
      E?.currentTarget?.contains?.(E.target) || (window.clearTimeout(c.value), d.value = "");
    }
    function q(E) {
      if (!Oo(E)) return;
      const D = E.target, O = m.value !== E.clientX;
      if (E?.currentTarget?.contains(D) && O) {
        const F = E.clientX > m.value ? "right" : "left";
        v.value = F, m.value = E.clientX;
      }
    }
    return cB({
      onItemEnter: (E) => !!k(E),
      onItemLeave: (E) => {
        k(E) || (S.value?.focus(), y.value = null);
      },
      onTriggerLeave: (E) => !!k(E),
      searchRef: d,
      pointerGraceTimerRef: f,
      onPointerGraceIntentChange: (E) => {
        p.value = E;
      }
    }), (E, D) => (h(), w(l(us), {
      "as-child": "",
      trapped: l(s),
      onMountAutoFocus: B,
      onUnmountAutoFocus: D[7] || (D[7] = (O) => a("closeAutoFocus", O))
    }, {
      default: g(() => [N(l(Oa), {
        "as-child": "",
        "disable-outside-pointer-events": l(i),
        onEscapeKeyDown: D[2] || (D[2] = (O) => a("escapeKeyDown", O)),
        onPointerDownOutside: D[3] || (D[3] = (O) => a("pointerDownOutside", O)),
        onFocusOutside: D[4] || (D[4] = (O) => a("focusOutside", O)),
        onInteractOutside: D[5] || (D[5] = (O) => a("interactOutside", O)),
        onDismiss: D[6] || (D[6] = (O) => a("dismiss"))
      }, {
        default: g(() => [N(l(fs), {
          ref_key: "rovingFocusGroupRef",
          ref: x,
          "current-tab-stop-id": y.value,
          "onUpdate:currentTabStopId": D[0] || (D[0] = (O) => y.value = O),
          "as-child": "",
          orientation: "vertical",
          dir: l(o).dir.value,
          loop: l(u),
          onEntryFocus: D[1] || (D[1] = (O) => {
            a("entryFocus", O), l(o).isUsingKeyboardRef.value || O.preventDefault();
          })
        }, {
          default: g(() => [N(l(Kr), {
            ref: l(C),
            role: "menu",
            as: E.as,
            "as-child": E.asChild,
            "aria-orientation": "vertical",
            "data-reka-menu-content": "",
            "data-state": l(bc)(l(r).open.value),
            dir: l(o).dir.value,
            side: E.side,
            "side-offset": E.sideOffset,
            align: E.align,
            "align-offset": E.alignOffset,
            "avoid-collisions": E.avoidCollisions,
            "collision-boundary": E.collisionBoundary,
            "collision-padding": E.collisionPadding,
            "arrow-padding": E.arrowPadding,
            "prioritize-position": E.prioritizePosition,
            "position-strategy": E.positionStrategy,
            "update-position-strategy": E.updatePositionStrategy,
            sticky: E.sticky,
            "hide-when-detached": E.hideWhenDetached,
            reference: E.reference,
            onKeydown: P,
            onBlur: M,
            onPointermove: q
          }, {
            default: g(() => [_(E.$slots, "default")]),
            _: 3
          }, 8, [
            "as",
            "as-child",
            "data-state",
            "dir",
            "side",
            "side-offset",
            "align",
            "align-offset",
            "avoid-collisions",
            "collision-boundary",
            "collision-padding",
            "arrow-padding",
            "prioritize-position",
            "position-strategy",
            "update-position-strategy",
            "sticky",
            "hide-when-detached",
            "reference"
          ])]),
          _: 3
        }, 8, [
          "current-tab-stop-id",
          "dir",
          "loop"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Dc = fB, pB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Mc(), { forwardRef: a } = j(), { CollectionItem: r } = st(), o = I(!1);
    async function s(u) {
      u.defaultPrevented || Oo(u) && (t.disabled ? n.onItemLeave(u) : n.onItemEnter(u) || u.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function i(u) {
      await Pe(), !u.defaultPrevented && Oo(u) && n.onItemLeave(u);
    }
    return (u, d) => (h(), w(l(r), { value: { textValue: u.textValue } }, {
      default: g(() => [N(l(X), T({
        ref: l(a),
        role: "menuitem",
        tabindex: "-1"
      }, u.$attrs, {
        as: u.as,
        "as-child": u.asChild,
        "aria-disabled": u.disabled || void 0,
        "data-disabled": u.disabled ? "" : void 0,
        "data-highlighted": o.value ? "" : void 0,
        onPointermove: s,
        onPointerleave: i,
        onFocus: d[0] || (d[0] = async (c) => {
          await Pe(), !(c.defaultPrevented || u.disabled) && (o.value = !0);
        }),
        onBlur: d[1] || (d[1] = async (c) => {
          await Pe(), !c.defaultPrevented && (o.value = !1);
        })
      }), {
        default: g(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "aria-disabled",
        "data-disabled",
        "data-highlighted"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), mg = pB, vB = /* @__PURE__ */ b({
  __name: "MenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = ms(), i = Mc(), u = I(!1);
    async function d() {
      const c = o.value;
      if (!n.disabled && c) {
        const f = new CustomEvent(nx, {
          bubbles: !0,
          cancelable: !0
        });
        a("select", f), await Pe(), f.defaultPrevented ? u.value = !1 : s.onClose();
      }
    }
    return (c, f) => (h(), w(mg, T(n, {
      ref: l(r),
      onClick: d,
      onPointerdown: f[0] || (f[0] = () => {
        u.value = !0;
      }),
      onPointerup: f[1] || (f[1] = async (p) => {
        await Pe(), !p.defaultPrevented && (u.value || p.currentTarget?.click());
      }),
      onKeydown: f[2] || (f[2] = async (p) => {
        const v = l(i).searchRef.value !== "";
        c.disabled || v && p.key === " " || l(ud).includes(p.key) && (p.currentTarget.click(), p.preventDefault());
      })
    }), {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), hs = vB;
const [mB, hg] = Se(["MenuCheckboxItem", "MenuRadioItem"], "MenuItemIndicatorContext");
var hB = /* @__PURE__ */ b({
  __name: "MenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = mB({ modelValue: I(!1) });
    return (n, a) => (h(), w(l(yt), { present: n.forceMount || l(Pl)(l(t).modelValue.value) || l(t).modelValue.value === !0 }, {
      default: g(() => [N(l(X), {
        as: n.as,
        "as-child": n.asChild,
        "data-state": l(_c)(l(t).modelValue.value)
      }, {
        default: g(() => [_(n.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), qc = hB, gB = /* @__PURE__ */ b({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1,
      default: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, ["modelValue"]), o = he(r), s = /* @__PURE__ */ Ie(n, "modelValue", a);
    return hg({ modelValue: s }), (i, u) => (h(), w(hs, T({ role: "menuitemcheckbox" }, l(o), {
      "aria-checked": l(Pl)(l(s)) ? "mixed" : l(s),
      "data-state": l(_c)(l(s)),
      onSelect: u[0] || (u[0] = async (d) => {
        a("select", d), l(Pl)(l(s)) ? s.value = !0 : s.value = !l(s);
      })
    }), {
      default: g(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Ac = gB, yB = /* @__PURE__ */ b({
  __name: "MenuRootContentModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ve(n, a), o = ir(), { forwardRef: s, currentElement: i } = j();
    return ls(i), (u, d) => (h(), w(Dc, T(l(r), {
      ref: l(s),
      "trap-focus": l(o).open.value,
      "disable-outside-pointer-events": l(o).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (c) => l(o).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = Ye((c) => a("focusOutside", c), ["prevent"]))
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), bB = yB, _B = /* @__PURE__ */ b({
  __name: "MenuRootContentNonModal",
  props: {
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), o = ir();
    return (s, i) => (h(), w(Dc, T(l(r), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (u) => l(o).onOpenChange(!1))
    }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16));
  }
}), wB = _B, xB = /* @__PURE__ */ b({
  __name: "MenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), o = ir(), s = ms();
    return (i, u) => (h(), w(l(yt), { present: i.forceMount || l(o).open.value }, {
      default: g(() => [l(s).modal.value ? (h(), w(bB, oe(T({ key: 0 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), w(wB, oe(T({ key: 1 }, {
        ...i.$attrs,
        ...l(r)
      })), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), Ec = xB, CB = /* @__PURE__ */ b({
  __name: "MenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), T({ role: "group" }, t), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), qi = CB, SB = /* @__PURE__ */ b({
  __name: "MenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Tc = SB, $B = /* @__PURE__ */ b({
  __name: "MenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ic = $B;
const [BB, kB] = Se("MenuRadioGroup");
var PB = /* @__PURE__ */ b({
  __name: "MenuRadioGroup",
  props: {
    modelValue: {
      type: null,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, ["modelValue"]), o = he(r), s = /* @__PURE__ */ Ie(n, "modelValue", a);
    return kB({
      modelValue: s,
      onValueChange: (i) => {
        s.value = i;
      }
    }), (i, u) => (h(), w(qi, oe(le(l(o))), {
      default: g(() => [_(i.$slots, "default", { modelValue: l(s) })]),
      _: 3
    }, 16));
  }
}), Oc = PB, MB = /* @__PURE__ */ b({
  __name: "MenuRadioItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, ["value"]), o = he(r), { value: s } = qe(n), i = BB(), u = A(() => i.modelValue.value === s?.value);
    return hg({ modelValue: u }), (d, c) => (h(), w(hs, T({ role: "menuitemradio" }, l(o), {
      "aria-checked": u.value,
      "data-state": l(_c)(u.value),
      onSelect: c[0] || (c[0] = async (f) => {
        a("select", f), l(i).onValueChange(l(s));
      })
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Rc = MB, DB = /* @__PURE__ */ b({
  __name: "MenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), T(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Vc = DB;
const [gg, qB] = Se("MenuSub");
var AB = /* @__PURE__ */ b({
  __name: "MenuSub",
  props: { open: {
    type: Boolean,
    required: !1,
    default: void 0
  } },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ie(n, "open", t, {
      defaultValue: !1,
      passive: n.open === void 0
    }), o = ir(), s = I(), i = I();
    return Te((u) => {
      o?.open.value === !1 && (r.value = !1), u(() => r.value = !1);
    }), vg({
      open: r,
      onOpenChange: (u) => {
        r.value = u;
      },
      content: i,
      onContentChange: (u) => {
        i.value = u;
      }
    }), qB({
      triggerId: "",
      contentId: "",
      trigger: s,
      onTriggerChange: (u) => {
        s.value = u;
      }
    }), (u, d) => (h(), w(l(or), null, {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }));
  }
}), Fc = AB, EB = /* @__PURE__ */ b({
  __name: "MenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1,
      default: !0
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), o = ir(), s = ms(), i = gg(), { forwardRef: u, currentElement: d } = j();
    return i.contentId ||= Ke(void 0, "reka-menu-sub-content"), (c, f) => (h(), w(l(yt), { present: c.forceMount || l(o).open.value }, {
      default: g(() => [N(Dc, T(l(r), {
        id: l(i).contentId,
        ref: l(u),
        "aria-labelledby": l(i).triggerId,
        align: "start",
        side: l(s).dir.value === "rtl" ? "left" : "right",
        "disable-outside-pointer-events": !1,
        "disable-outside-scroll": !1,
        "trap-focus": !1,
        onOpenAutoFocus: f[0] || (f[0] = Ye((p) => {
          l(s).isUsingKeyboardRef.value && l(d)?.focus();
        }, ["prevent"])),
        onCloseAutoFocus: f[1] || (f[1] = Ye(() => {
        }, ["prevent"])),
        onFocusOutside: f[2] || (f[2] = (p) => {
          p.defaultPrevented || p.target !== l(i).trigger.value && l(o).onOpenChange(!1);
        }),
        onEscapeKeyDown: f[3] || (f[3] = (p) => {
          l(s).onClose(), p.preventDefault();
        }),
        onKeydown: f[4] || (f[4] = (p) => {
          const v = p.currentTarget?.contains(p.target), m = l(sx)[l(s).dir.value].includes(p.key);
          v && m && (l(o).onOpenChange(!1), l(i).trigger.value?.focus(), p.preventDefault());
        })
      }), {
        default: g(() => [_(c.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "side"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), Nc = EB, TB = /* @__PURE__ */ b({
  __name: "MenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ir(), a = ms(), r = gg(), o = Mc(), s = I(null);
    r.triggerId ||= Ke(void 0, "reka-menu-sub-trigger");
    function i() {
      s.value && window.clearTimeout(s.value), s.value = null;
    }
    nt(() => {
      i();
    });
    function u(f) {
      !Oo(f) || o.onItemEnter(f) || !t.disabled && !n.open.value && !s.value && (o.onPointerGraceIntentChange(null), s.value = window.setTimeout(() => {
        n.onOpenChange(!0), i();
      }, 100));
    }
    async function d(f) {
      if (!Oo(f)) return;
      i();
      const p = n.content.value?.getBoundingClientRect();
      if (p?.width) {
        const v = n.content.value?.dataset.side, m = v === "right", y = m ? -5 : 5, x = p[m ? "left" : "right"], C = p[m ? "right" : "left"];
        o.onPointerGraceIntentChange({
          area: [
            {
              x: f.clientX + y,
              y: f.clientY
            },
            {
              x,
              y: p.top
            },
            {
              x: C,
              y: p.top
            },
            {
              x: C,
              y: p.bottom
            },
            {
              x,
              y: p.bottom
            }
          ],
          side: v
        }), window.clearTimeout(o.pointerGraceTimerRef.value), o.pointerGraceTimerRef.value = window.setTimeout(() => o.onPointerGraceIntentChange(null), 300);
      } else {
        if (o.onTriggerLeave(f)) return;
        o.onPointerGraceIntentChange(null);
      }
    }
    async function c(f) {
      const p = o.searchRef.value !== "";
      t.disabled || p && f.key === " " || ox[a.dir.value].includes(f.key) && (n.onOpenChange(!0), await Pe(), n.content.value?.focus(), f.preventDefault());
    }
    return (f, p) => (h(), w(Di, { "as-child": "" }, {
      default: g(() => [N(mg, T(t, {
        id: l(r).triggerId,
        ref: (v) => {
          l(r)?.onTriggerChange(v?.$el);
        },
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(r).contentId,
        "data-state": l(bc)(l(n).open.value),
        onClick: p[0] || (p[0] = async (v) => {
          t.disabled || v.defaultPrevented || (v.currentTarget.focus(), l(n).open.value || l(n).onOpenChange(!0));
        }),
        onPointermove: u,
        onPointerleave: d,
        onKeydown: c
      }), {
        default: g(() => [_(f.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-expanded",
        "aria-controls",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), Lc = TB, IB = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(Ac), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), OB = IB;
const [yg, RB] = Se("ContextMenuRoot");
var VB = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuRoot",
  props: {
    pressOpenDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: r, modal: o, pressOpenDelay: s } = qe(n);
    j();
    const i = gt(r), u = I(!1), d = I();
    return RB({
      open: u,
      onOpenChange: (c) => {
        u.value = c;
      },
      dir: i,
      modal: o,
      triggerElement: d,
      pressOpenDelay: s
    }), me(u, (c) => {
      a("update:open", c);
    }), (c, f) => (h(), w(l(Pc), {
      open: u.value,
      "onUpdate:open": f[0] || (f[0] = (p) => u.value = p),
      dir: l(i),
      modal: l(o)
    }, {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), FB = VB, NB = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const o = yg(), s = I(!1);
    return (i, u) => (h(), w(l(Ec), T(l(r), {
      side: "right",
      "side-offset": 2,
      align: "start",
      "update-position-strategy": "always",
      style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        !d.defaultPrevented && s.value && d.preventDefault(), s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        d.detail.originalEvent.button === 2 && d.target === l(o).triggerElement.value && d.preventDefault(), !d.defaultPrevented && !l(o).modal.value && (s.value = !0);
      })
    }), {
      default: g(() => [_(i.$slots, "default")]),
      _: 3
    }, 16));
  }
}), LB = NB, zB = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(qi), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), HB = zB, UB = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(hs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), jB = UB, WB = /* @__PURE__ */ b({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(qc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bg = WB, GB = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Tc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), KB = GB, YB = /* @__PURE__ */ b({
  __name: "ContextMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ic), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), XB = YB, JB = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(Oc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ZB = JB, QB = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(Rc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ek = QB, tk = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Vc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), nk = tk, ak = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    return (o, s) => (h(), w(l(Fc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => Ct(r) ? r.value = i : null)
    }, {
      default: g(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), rk = ak, ok = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), w(l(Nc), T(l(r), { style: {
      "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sk = ok, lk = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Lc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ik = lk;
function Gp(e) {
  return e.pointerType !== "mouse";
}
var uk = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { disabled: n } = qe(t), { forwardRef: a, currentElement: r } = j(), o = yg(), s = I({
      x: 0,
      y: 0
    }), i = A(() => ({ getBoundingClientRect: () => ({
      width: 0,
      height: 0,
      left: s.value.x,
      right: s.value.x,
      top: s.value.y,
      bottom: s.value.y,
      ...s.value
    }) })), u = I(0);
    function d() {
      window.clearTimeout(u.value);
    }
    function c(m) {
      s.value = {
        x: m.clientX,
        y: m.clientY
      }, o.onOpenChange(!0);
    }
    async function f(m) {
      n.value || (await Pe(), m.defaultPrevented || (d(), c(m), m.preventDefault()));
    }
    async function p(m) {
      n.value || (await Pe(), Gp(m) && !m.defaultPrevented && (d(), u.value = window.setTimeout(() => c(m), o.pressOpenDelay.value)));
    }
    async function v(m) {
      n.value || (await Pe(), Gp(m) && !m.defaultPrevented && d());
    }
    return Ce(() => {
      r.value && (o.triggerElement.value = r.value);
    }), (m, y) => (h(), G(Ge, null, [N(l(Di), {
      as: "template",
      reference: i.value
    }, null, 8, ["reference"]), N(l(X), T({
      ref: l(a),
      as: m.as,
      "as-child": m.asChild,
      "data-state": l(o).open.value ? "open" : "closed",
      "data-disabled": l(n) ? "" : void 0,
      style: {
        WebkitTouchCallout: "none",
        pointerEvents: "auto"
      }
    }, m.$attrs, {
      onContextmenu: f,
      onPointerdown: p,
      onPointermove: v,
      onPointercancel: v,
      onPointerup: v
    }), {
      default: g(() => [_(m.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-state",
      "data-disabled"
    ])], 64));
  }
}), dk = uk;
const [Yr, ck] = Se("PopoverRoot");
var fk = /* @__PURE__ */ b({
  __name: "PopoverRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: r } = qe(n), o = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = I(), i = I(!1);
    return ck({
      contentId: "",
      triggerId: "",
      modal: r,
      open: o,
      onOpenChange: (u) => {
        o.value = u;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      triggerElement: s,
      hasCustomAnchor: i
    }), (u, d) => (h(), w(l(or), null, {
      default: g(() => [_(u.$slots, "default", {
        open: l(o),
        close: () => o.value = !1
      })]),
      _: 3
    }));
  }
}), pk = fk, vk = /* @__PURE__ */ b({
  __name: "PopoverAnchor",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Yr();
    return s0(() => {
      n.hasCustomAnchor.value = !0;
    }), nt(() => {
      n.hasCustomAnchor.value = !1;
    }), (a, r) => (h(), w(l(sr), oe(le(t)), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), rH = vk, mk = /* @__PURE__ */ b({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(Z(n, "trapFocus", "disableOutsidePointerEvents")), { forwardRef: o } = j(), s = Yr();
    return mi(), (i, u) => (h(), w(l(us), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => a("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => a("closeAutoFocus", d))
    }, {
      default: g(() => [N(l(Oa), {
        "as-child": "",
        "disable-outside-pointer-events": i.disableOutsidePointerEvents,
        onPointerDownOutside: u[0] || (u[0] = (d) => a("pointerDownOutside", d)),
        onInteractOutside: u[1] || (u[1] = (d) => a("interactOutside", d)),
        onEscapeKeyDown: u[2] || (u[2] = (d) => a("escapeKeyDown", d)),
        onFocusOutside: u[3] || (u[3] = (d) => a("focusOutside", d)),
        onDismiss: u[4] || (u[4] = (d) => l(s).onOpenChange(!1))
      }, {
        default: g(() => [N(l(Kr), T(l(r), {
          id: l(s).contentId,
          ref: l(o),
          "data-state": l(s).open.value ? "open" : "closed",
          "aria-labelledby": l(s).triggerId,
          style: {
            "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
            "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
            "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
          },
          role: "dialog"
        }), {
          default: g(() => [_(i.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "data-state",
          "aria-labelledby"
        ])]),
        _: 3
      }, 8, ["disable-outside-pointer-events"])]),
      _: 3
    }, 8, ["trapped"]));
  }
}), _g = mk, hk = /* @__PURE__ */ b({
  __name: "PopoverContentModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Yr(), o = I(!1);
    os(!0);
    const s = ve(n, a), { forwardRef: i, currentElement: u } = j();
    return ls(u), (d, c) => (h(), w(_g, T(l(s), {
      ref: l(i),
      "trap-focus": l(r).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: c[0] || (c[0] = Ye((f) => {
        a("closeAutoFocus", f), o.value || l(r).triggerElement.value?.focus();
      }, ["prevent"])),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        a("pointerDownOutside", f);
        const p = f.detail.originalEvent, v = p.button === 0 && p.ctrlKey === !0, m = p.button === 2 || v;
        o.value = m;
      }),
      onFocusOutside: c[2] || (c[2] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), gk = hk, yk = /* @__PURE__ */ b({
  __name: "PopoverContentNonModal",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Yr(), o = I(!1), s = I(!1), i = ve(n, a);
    return (u, d) => (h(), w(_g, T(l(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        a("closeAutoFocus", c), c.defaultPrevented || (o.value || l(r).triggerElement.value?.focus(), c.preventDefault()), o.value = !1, s.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = async (c) => {
        a("interactOutside", c), c.defaultPrevented || (o.value = !0, c.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const f = c.target;
        l(r).triggerElement.value?.contains(f) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && s.value && c.preventDefault();
      })
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bk = yk, _k = /* @__PURE__ */ b({
  __name: "PopoverContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Yr(), o = ve(n, a), { forwardRef: s } = j();
    return r.contentId ||= Ke(void 0, "reka-popover-content"), (i, u) => (h(), w(l(yt), { present: i.forceMount || l(r).open.value }, {
      default: g(() => [l(r).modal.value ? (h(), w(gk, T({ key: 0 }, l(o), { ref: l(s) }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)) : (h(), w(bk, T({ key: 1 }, l(o), { ref: l(s) }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), wk = _k, xk = /* @__PURE__ */ b({
  __name: "PopoverPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Ck = xk, Sk = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Yr(), { forwardRef: a, currentElement: r } = j();
    return n.triggerId ||= Ke(void 0, "reka-popover-trigger"), Ce(() => {
      n.triggerElement.value = r.value;
    }), (o, s) => (h(), w(Pt(l(n).hasCustomAnchor.value ? l(X) : l(sr)), { "as-child": "" }, {
      default: g(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).contentId,
        "data-state": l(n).open.value ? "open" : "closed",
        as: o.as,
        "as-child": t.asChild,
        onClick: l(n).onOpenToggle
      }, {
        default: g(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "aria-expanded",
        "aria-controls",
        "data-state",
        "as",
        "as-child",
        "onClick"
      ])]),
      _: 3
    }));
  }
}), $k = Sk;
function Bk(e) {
  const t = A(() => e.start.value ? !!e.isDateDisabled(e.start.value) : !1), n = A(() => e.end.value ? !!e.isDateDisabled(e.end.value) : !1), a = A(() => t.value || n.value ? !1 : !!(e.start.value && e.end.value && Xa(e.end.value, e.start.value))), r = (p) => e.start.value ? wt(e.start.value, p) : !1, o = (p) => e.end.value ? wt(e.end.value, p) : !1, s = (p) => e.start.value && wt(e.start.value, p) || e.end.value && wt(e.end.value, p) ? !0 : e.end.value && e.start.value ? wu(p, e.start.value, e.end.value) : !1, i = (p) => {
    if (e.isDateDisabled(p)) return !0;
    if (e.maximumDays?.value) {
      if (e.start.value && e.end.value) {
        if (e.fixedDate.value) {
          const v = ld(e.start.value, e.end.value).length;
          if (v <= e.maximumDays.value) {
            const m = e.maximumDays.value - v - 1, y = e.start.value.subtract({ days: m }), x = e.end.value.add({ days: m });
            return !wu(p, y, x);
          }
        }
        return !1;
      }
      if (e.start.value) {
        const v = e.start.value.add({ days: e.maximumDays.value }), m = e.start.value.subtract({ days: e.maximumDays.value });
        return !wu(p, m, v);
      }
    }
    return !e.start.value || e.end.value || wt(e.start.value, p), !1;
  }, u = (p) => !!e.isDateHighlightable?.(p), d = A(() => {
    if (e.start.value && e.end.value && !e.fixedDate.value || !e.start.value || !e.focusedValue.value) return null;
    const p = Xa(e.start.value, e.focusedValue.value), v = p ? e.start.value : e.focusedValue.value, m = p ? e.focusedValue.value : e.start.value;
    if (wt(v, m)) return {
      start: v,
      end: m
    };
    if (e.maximumDays?.value && !e.end.value) {
      const x = p ? v.add({ days: e.maximumDays.value - 1 }) : v.subtract({ days: e.maximumDays.value });
      return {
        start: v,
        end: x
      };
    }
    return o1(v, m, e.allowNonContiguousRanges.value ? () => !1 : e.isDateUnavailable, i, e.isDateHighlightable) ? {
      start: v,
      end: m
    } : null;
  });
  return {
    isInvalid: a,
    isSelected: s,
    isDateHighlightable: u,
    highlightedRange: d,
    isSelectionStart: r,
    isSelectionEnd: o,
    isHighlightedStart: (p) => !d.value || !d.value.start ? !1 : wt(d.value.start, p),
    isHighlightedEnd: (p) => !d.value || !d.value.end ? !1 : wt(d.value.end, p),
    isDateDisabled: i
  };
}
const kk = { style: {
  border: "0px",
  clip: "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0px",
  position: "absolute",
  "white-space": "nowrap",
  width: "1px"
} }, Pk = {
  role: "heading",
  "aria-level": "2"
}, [Xr, Mk] = Se("RangeCalendarRoot");
var Dk = /* @__PURE__ */ b({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: Object,
      required: !1,
      default: () => ({
        start: void 0,
        end: void 0
      })
    },
    modelValue: {
      type: [Object, null],
      required: !1
    },
    placeholder: {
      type: null,
      required: !1,
      default: void 0
    },
    allowNonContiguousRanges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    pagedNavigation: {
      type: Boolean,
      required: !1,
      default: !1
    },
    preventDeselect: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maximumDays: {
      type: Number,
      required: !1,
      default: void 0
    },
    weekStartsOn: {
      type: Number,
      required: !1,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: !1,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: !1
    },
    fixedWeeks: {
      type: Boolean,
      required: !1,
      default: !1
    },
    maxValue: {
      type: null,
      required: !1
    },
    minValue: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    numberOfMonths: {
      type: Number,
      required: !1,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    readonly: {
      type: Boolean,
      required: !1,
      default: !1
    },
    initialFocus: {
      type: Boolean,
      required: !1,
      default: !1
    },
    isDateDisabled: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: !1,
      default: void 0
    },
    isDateHighlightable: {
      type: Function,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    nextPage: {
      type: Function,
      required: !1
    },
    prevPage: {
      type: Function,
      required: !1
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: !1,
      default: !1
    },
    fixedDate: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  emits: [
    "update:modelValue",
    "update:validModelValue",
    "update:placeholder",
    "update:startValue"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, initialFocus: s, pagedNavigation: i, weekStartsOn: u, weekdayFormat: d, fixedWeeks: c, numberOfMonths: f, preventDeselect: p, isDateUnavailable: v, isDateHighlightable: m, isDateDisabled: y, calendarLabel: x, maxValue: C, minValue: S, dir: $, locale: k, nextPage: B, prevPage: P, allowNonContiguousRanges: M, disableDaysOutsideCurrentView: q, fixedDate: E, maximumDays: D } = qe(n), { primitiveElement: O, currentElement: F } = Lt(), J = gt($), ne = mc(k), Q = I(), W = I(), H = I(!1), U = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: n.modelValue === void 0
    }), se = I(U.value);
    me(se, (Ve) => {
      a("update:validModelValue", Ve);
    });
    const ee = Dh({
      defaultPlaceholder: n.placeholder,
      defaultValue: U.value.start,
      locale: n.locale
    }), de = I(U.value.start), fe = I(U.value.end), _e = /* @__PURE__ */ Ie(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ee.copy(),
      passive: n.placeholder === void 0
    });
    function ye(Ve) {
      _e.value = Ve.copy();
    }
    const { fullCalendarLabel: Ee, headingValue: ce, isDateDisabled: V, isDateUnavailable: te, isNextButtonDisabled: z, isPrevButtonDisabled: re, grid: ie, weekdays: L, isOutsideVisibleView: be, nextPage: xe, prevPage: Ne, formatter: Xe } = Wh({
      locale: ne,
      placeholder: _e,
      weekStartsOn: u,
      fixedWeeks: c,
      numberOfMonths: f,
      minValue: S,
      maxValue: C,
      disabled: r,
      weekdayFormat: d,
      pagedNavigation: i,
      isDateDisabled: y.value,
      isDateUnavailable: v.value,
      calendarLabel: x,
      nextPage: B,
      prevPage: P
    }), { isInvalid: lt, isSelected: ke, isDateHighlightable: Le, highlightedRange: Ue, isSelectionStart: We, isSelectionEnd: it, isHighlightedStart: ut, isHighlightedEnd: $t, isDateDisabled: on } = Bk({
      start: de,
      end: fe,
      isDateDisabled: V,
      isDateUnavailable: te,
      isDateHighlightable: m.value,
      focusedValue: W,
      allowNonContiguousRanges: M,
      fixedDate: E,
      maximumDays: D
    });
    me(U, (Ve, Dt) => {
      (!Dt?.start && Ve?.start || !Ve || !Ve.start || de.value && !Sa(Ve.start, de.value)) && (de.value = Ve?.start?.copy?.()), (!Dt?.end && Ve.end || !Ve || !Ve.end || fe.value && !Sa(Ve.end, fe.value)) && (fe.value = Ve?.end?.copy?.());
    }), me(de, (Ve) => {
      Ve && !Sa(Ve, _e.value) && ye(Ve), a("update:startValue", Ve);
    }), me([de, fe], ([Ve, Dt]) => {
      const Wt = U.value;
      if (!(Wt && Wt.start && Wt.end && Ve && Dt && Sa(Wt.start, Ve) && Sa(Wt.end, Dt)))
        if (H.value = !0, Dt && Ve) {
          const Ot = Xa(Dt, Ve) ? {
            start: Dt.copy(),
            end: Ve.copy()
          } : {
            start: Ve.copy(),
            end: Dt.copy()
          };
          U.value = {
            start: Ot.start,
            end: Ot.end
          }, H.value = !1, se.value = {
            start: Ot.start.copy(),
            end: Ot.end.copy()
          };
        } else U.value = Ve ? {
          start: Ve.copy(),
          end: void 0
        } : {
          start: Dt?.copy(),
          end: void 0
        };
    });
    const hn = is();
    return ct("keydown", (Ve) => {
      Ve.key === hn.ESCAPE && H.value && (de.value = se.value.start?.copy(), fe.value = se.value.end?.copy());
    }), Mk({
      isDateUnavailable: te,
      isDateHighlightable: Le,
      startValue: de,
      endValue: fe,
      formatter: Xe,
      modelValue: U,
      placeholder: _e,
      disabled: r,
      initialFocus: s,
      pagedNavigation: i,
      grid: ie,
      weekDays: L,
      weekStartsOn: u,
      weekdayFormat: d,
      fixedWeeks: c,
      numberOfMonths: f,
      readonly: o,
      preventDeselect: p,
      fullCalendarLabel: Ee,
      headingValue: ce,
      isInvalid: lt,
      isDateDisabled: on,
      allowNonContiguousRanges: M,
      highlightedRange: Ue,
      focusedValue: W,
      lastPressedDateValue: Q,
      isSelected: ke,
      isSelectionEnd: it,
      isSelectionStart: We,
      isNextButtonDisabled: z,
      isPrevButtonDisabled: re,
      isOutsideVisibleView: be,
      nextPage: xe,
      prevPage: Ne,
      parentElement: F,
      onPlaceholderChange: ye,
      locale: ne,
      dir: J,
      isHighlightedStart: ut,
      isHighlightedEnd: $t,
      disableDaysOutsideCurrentView: q,
      fixedDate: E,
      maximumDays: D,
      minValue: S,
      maxValue: C
    }), Ce(() => {
      s.value && qh(F.value);
    }), (Ve, Dt) => (h(), w(l(X), {
      ref_key: "primitiveElement",
      ref: O,
      as: Ve.as,
      "as-child": Ve.asChild,
      "aria-label": l(Ee),
      "data-readonly": l(o) ? "" : void 0,
      "data-disabled": l(r) ? "" : void 0,
      "data-invalid": l(lt) ? "" : void 0,
      dir: l(J)
    }, {
      default: g(() => [we("div", kk, [we("div", Pk, Fe(l(Ee)), 1)]), _(Ve.$slots, "default", {
        date: l(_e),
        grid: l(ie),
        weekDays: l(L),
        weekStartsOn: l(u),
        locale: l(ne),
        fixedWeeks: l(c),
        modelValue: l(U)
      })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "data-readonly",
      "data-disabled",
      "data-invalid",
      "dir"
    ]));
  }
}), qk = Dk, Ak = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "td"
    }
  },
  setup(e) {
    const t = Xr();
    return (n, a) => (h(), w(l(X), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": l(t).isSelected(n.date) ? !0 : void 0,
      "aria-disabled": l(t).isDateDisabled(n.date) || l(t).isDateUnavailable?.(n.date) || l(t).disableDaysOutsideCurrentView.value,
      "data-disabled": l(t).isDateDisabled(n.date) || l(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-selected",
      "aria-disabled",
      "data-disabled"
    ]));
  }
}), Ek = Ak, Tk = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: !0
    },
    month: {
      type: null,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Xr(), a = is(), { primitiveElement: r } = Lt(), o = A(() => n.formatter.custom($n(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), s = A(() => n.isDateUnavailable?.(t.day) ?? !1), i = A(() => n.isSelected(t.day)), u = A(() => n.isSelectionStart(t.day)), d = A(() => n.isSelectionEnd(t.day)), c = A(() => n.isHighlightedStart(t.day)), f = A(() => n.isHighlightedEnd(t.day)), p = A(() => n.highlightedRange.value ? n1(t.day, n.highlightedRange.value.start, n.highlightedRange.value.end) : !1), v = A(() => n.allowNonContiguousRanges.value), m = A(() => lh(t.day, jr())), y = A(() => !oc(t.day, t.month)), x = A(() => n.isOutsideVisibleView(t.day)), C = A(() => n.isDateDisabled(t.day) || n.disableDaysOutsideCurrentView.value && y.value), S = A(() => t.day.day.toLocaleString(n.locale.value)), $ = A(() => !n.disabled.value && wt(t.day, n.placeholder.value));
    function k(q, E) {
      if (!n.readonly.value && !(n.isDateDisabled(E) || n.isDateUnavailable?.(E))) {
        if (n.lastPressedDateValue.value = E.copy(), n.startValue.value && n.highlightedRange.value === null) {
          if (wt(E, n.startValue.value) && !n.preventDeselect.value && !n.endValue.value) {
            n.startValue.value = void 0, n.onPlaceholderChange(E);
            return;
          } else if (!n.endValue.value) {
            q.preventDefault(), n.lastPressedDateValue.value && wt(n.lastPressedDateValue.value, E) && (n.startValue.value = E.copy());
            return;
          }
        }
        if (n.startValue.value && n.endValue.value && wt(n.startValue.value, n.endValue.value) && wt(n.startValue.value, E) && !n.preventDeselect.value) {
          n.startValue.value = void 0, n.endValue.value = void 0, n.onPlaceholderChange(E);
          return;
        }
        n.startValue.value ? n.endValue.value ? n.endValue.value && n.startValue.value && (n.fixedDate.value ? n.fixedDate.value === "start" ? E.compare(n.startValue.value) < 0 ? n.startValue.value = E.copy() : n.endValue.value = E.copy() : n.fixedDate.value === "end" && (E.compare(n.endValue.value) > 0 ? n.endValue.value = E.copy() : n.startValue.value = E.copy()) : (n.endValue.value = void 0, n.startValue.value = E.copy())) : n.endValue.value = E.copy() : n.startValue.value = E.copy();
      }
    }
    function B(q) {
      C.value || k(q, t.day);
    }
    function P() {
      C.value || n.isDateUnavailable?.(t.day) || (n.focusedValue.value = t.day.copy());
    }
    function M(q) {
      if (C.value) return;
      q.preventDefault(), q.stopPropagation();
      const E = n.parentElement.value, D = 7, O = n.dir.value === "rtl" ? -1 : 1;
      switch (q.code) {
        case a.ARROW_RIGHT:
          F(t.day, O);
          break;
        case a.ARROW_LEFT:
          F(t.day, -O);
          break;
        case a.ARROW_UP:
          F(t.day, -D);
          break;
        case a.ARROW_DOWN:
          F(t.day, D);
          break;
        case a.ENTER:
        case a.SPACE_CODE:
          k(q, t.day);
      }
      function F(J, ne) {
        const Q = J.add({ days: ne });
        if (n.minValue.value && Q.compare(n.minValue.value) < 0 || n.maxValue.value && Q.compare(n.maxValue.value) > 0) return;
        const W = E.querySelector(`[data-value='${Q.toString()}']:not([data-outside-view])`);
        if (!W) {
          if (ne > 0) {
            if (n.isNextButtonDisabled()) return;
            n.nextPage();
          } else {
            if (n.isPrevButtonDisabled()) return;
            n.prevPage();
          }
          Pe(() => {
            F(J, ne);
          });
          return;
        }
        if (W && W.hasAttribute("data-disabled")) return F(Q, ne);
        n.onPlaceholderChange(Q), W?.focus();
      }
    }
    return (q, E) => (h(), w(l(X), {
      ref_key: "primitiveElement",
      ref: r,
      as: q.as,
      "as-child": q.asChild,
      role: "button",
      "aria-label": o.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-pressed": i.value && (v.value || !s.value) ? !0 : void 0,
      "aria-disabled": C.value || s.value ? !0 : void 0,
      "data-highlighted": p.value && (v.value || !s.value) ? "" : void 0,
      "data-selection-start": u.value ? !0 : void 0,
      "data-selection-end": d.value ? !0 : void 0,
      "data-highlighted-start": c.value ? !0 : void 0,
      "data-highlighted-end": f.value ? !0 : void 0,
      "data-selected": i.value && (v.value || !s.value) ? !0 : void 0,
      "data-outside-visible-view": x.value ? "" : void 0,
      "data-value": q.day.toString(),
      "data-disabled": C.value ? "" : void 0,
      "data-unavailable": s.value ? "" : void 0,
      "data-today": m.value ? "" : void 0,
      "data-outside-view": y.value ? "" : void 0,
      "data-focused": $.value ? "" : void 0,
      tabindex: $.value ? 0 : y.value || C.value ? void 0 : -1,
      onClick: B,
      onFocusin: P,
      onMouseenter: P,
      onKeydown: Je(M, [
        "up",
        "down",
        "left",
        "right",
        "enter",
        "space"
      ])
    }, {
      default: g(() => [_(q.$slots, "default", {
        dayValue: S.value,
        disabled: C.value,
        today: m.value,
        selected: i.value,
        outsideView: y.value,
        outsideVisibleView: x.value,
        unavailable: s.value,
        highlighted: p.value && (v.value || !s.value),
        highlightedStart: c.value,
        highlightedEnd: f.value,
        selectionStart: u.value,
        selectionEnd: d.value
      }, () => [Re(Fe(S.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-label",
      "aria-pressed",
      "aria-disabled",
      "data-highlighted",
      "data-selection-start",
      "data-selection-end",
      "data-highlighted-start",
      "data-highlighted-end",
      "data-selected",
      "data-outside-visible-view",
      "data-value",
      "data-disabled",
      "data-unavailable",
      "data-today",
      "data-outside-view",
      "data-focused",
      "tabindex"
    ]));
  }
}), Ik = Tk, Ok = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "table"
    }
  },
  setup(e) {
    const t = e, n = Xr(), a = A(() => n.disabled.value ? !0 : void 0), r = A(() => n.readonly.value ? !0 : void 0);
    return (o, s) => (h(), w(l(X), T(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": r.value,
      "aria-disabled": a.value,
      "data-readonly": r.value && "",
      "data-disabled": a.value && ""
    }), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-readonly",
      "aria-disabled",
      "data-readonly",
      "data-disabled"
    ]));
  }
}), Rk = Ok, Vk = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tbody"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Fk = Vk, Nk = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "thead"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), T(t, { "aria-hidden": "true" }), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Lk = Nk, zk = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "tr"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Hk = zk, Uk = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "th"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), jk = Uk, Wk = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Gk = Wk, Kk = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Xr();
    return (a, r) => (h(), w(l(X), T(t, { "data-disabled": l(n).disabled.value ? "" : void 0 }), {
      default: g(() => [_(a.$slots, "default", { headingValue: l(n).headingValue.value }, () => [Re(Fe(l(n).headingValue.value), 1)])]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), Yk = Kk, Xk = /* @__PURE__ */ b({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = A(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = Xr();
    return (r, o) => (h(), w(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Next page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).nextPage(t.nextPage))
    }, {
      default: g(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Next page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), Jk = Xk, Zk = /* @__PURE__ */ b({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = A(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = Xr();
    return (r, o) => (h(), w(l(X), {
      as: r.as,
      "as-child": r.asChild,
      "aria-label": "Previous page",
      type: r.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: o[0] || (o[0] = (s) => l(a).prevPage(t.prevPage))
    }, {
      default: g(() => [_(r.$slots, "default", { disabled: n.value }, () => [o[1] || (o[1] = Re(" Prev page "))])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "type",
      "aria-disabled",
      "data-disabled",
      "disabled"
    ]));
  }
}), Qk = Zk, eP = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(Ac), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), tP = eP;
const [wg, nP] = Se("DropdownMenuRoot");
var aP = /* @__PURE__ */ b({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    modal: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), o = I(), { modal: s, dir: i } = qe(n), u = gt(i);
    return nP({
      open: r,
      onOpenChange: (d) => {
        r.value = d;
      },
      onOpenToggle: () => {
        r.value = !r.value;
      },
      triggerId: "",
      triggerElement: o,
      contentId: "",
      modal: s,
      dir: u
    }), (d, c) => (h(), w(l(Pc), {
      open: l(r),
      "onUpdate:open": c[0] || (c[0] = (f) => Ct(r) ? r.value = f : null),
      dir: l(u),
      modal: l(s)
    }, {
      default: g(() => [_(d.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, [
      "open",
      "dir",
      "modal"
    ]));
  }
}), rP = aP, oP = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const o = wg(), s = I(!1);
    function i(u) {
      u.defaultPrevented || (s.value || setTimeout(() => {
        o.triggerElement.value?.focus();
      }, 0), s.value = !1, u.preventDefault());
    }
    return o.contentId ||= Ke(void 0, "reka-dropdown-menu-content"), (u, d) => (h(), w(l(Ec), T(l(r), {
      id: l(o).contentId,
      "aria-labelledby": l(o)?.triggerId,
      style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: i,
      onInteractOutside: d[0] || (d[0] = (c) => {
        if (c.defaultPrevented) return;
        const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, v = f.button === 2 || p;
        (!l(o).modal.value || v) && (s.value = !0), l(o).triggerElement.value?.contains(c.target) && c.preventDefault();
      })
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), sP = oP, lP = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(qi), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), iP = lP, uP = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(hs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), dP = uP, cP = /* @__PURE__ */ b({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(qc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), xg = cP, fP = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Tc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), pP = fP, vP = /* @__PURE__ */ b({
  __name: "DropdownMenuPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ic), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), mP = vP, hP = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(Oc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gP = hP, yP = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), w(l(Rc), oe(le(l(r))), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bP = yP, _P = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Vc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), wP = _P, xP = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ie(n, "open", t, {
      passive: n.open === void 0,
      defaultValue: n.defaultOpen ?? !1
    });
    return j(), (o, s) => (h(), w(l(Fc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => Ct(r) ? r.value = i : null)
    }, {
      default: g(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), CP = xP, SP = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), w(l(Nc), T(l(r), { style: {
      "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
      "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
      "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $P = SP, BP = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Lc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), kP = BP, PP = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = wg(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.triggerElement = r;
    }), n.triggerId ||= Ke(void 0, "reka-dropdown-menu-trigger"), (o, s) => (h(), w(l(Di), { "as-child": "" }, {
      default: g(() => [N(l(X), {
        id: l(n).triggerId,
        ref: l(a),
        type: o.as === "button" ? "button" : void 0,
        "as-child": t.asChild,
        as: o.as,
        "aria-haspopup": "menu",
        "aria-expanded": l(n).open.value,
        "aria-controls": l(n).open.value ? l(n).contentId : void 0,
        "data-disabled": o.disabled ? "" : void 0,
        disabled: o.disabled,
        "data-state": l(n).open.value ? "open" : "closed",
        onClick: s[0] || (s[0] = async (i) => {
          !o.disabled && i.button === 0 && i.ctrlKey === !1 && (l(n)?.onOpenToggle(), await Pe(), l(n).open.value && i.preventDefault());
        }),
        onKeydown: s[1] || (s[1] = Je((i) => {
          o.disabled || (["Enter", " "].includes(i.key) && l(n).onOpenToggle(), i.key === "ArrowDown" && l(n).onOpenChange(!0), [
            "Enter",
            " ",
            "ArrowDown"
          ].includes(i.key) && i.preventDefault());
        }, [
          "enter",
          "space",
          "arrow-down"
        ]))
      }, {
        default: g(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as-child",
        "as",
        "aria-expanded",
        "aria-controls",
        "data-disabled",
        "disabled",
        "data-state"
      ])]),
      _: 3
    }));
  }
}), MP = PP;
const [zc, DP] = Se("HoverCardRoot");
var qP = /* @__PURE__ */ b({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    openDelay: {
      type: Number,
      required: !1,
      default: 700
    },
    closeDelay: {
      type: Number,
      required: !1,
      default: 300
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { openDelay: r, closeDelay: o } = qe(n);
    j();
    const s = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = I(0), u = I(0), d = I(!1), c = I(!1), f = I(!1), p = I();
    function v() {
      clearTimeout(u.value), i.value = window.setTimeout(() => s.value = !0, r.value);
    }
    function m() {
      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => s.value = !1, o.value));
    }
    function y() {
      s.value = !1;
    }
    return DP({
      open: s,
      onOpenChange(x) {
        s.value = x;
      },
      onOpen: v,
      onClose: m,
      onDismiss: y,
      hasSelectionRef: d,
      isPointerDownOnContentRef: c,
      isPointerInTransitRef: f,
      triggerElement: p
    }), (x, C) => (h(), w(l(or), null, {
      default: g(() => [_(x.$slots, "default", { open: l(s) })]),
      _: 3
    }));
  }
}), AP = qP;
function hd(e) {
  return (t) => t.pointerType === "touch" ? void 0 : e();
}
function EP(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
var TP = /* @__PURE__ */ b({
  __name: "HoverCardContentImpl",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = he(n), { forwardRef: o, currentElement: s } = j(), i = zc(), { isPointerInTransit: u, onPointerExit: d } = Eh(i.triggerElement, s);
    R0(i.isPointerInTransitRef, u, { direction: "rtl" }), d(() => {
      i.onClose();
    });
    const c = I(!1);
    let f;
    Te((v) => {
      if (c.value) {
        const m = document.body;
        f = m.style.userSelect || m.style.webkitUserSelect, m.style.userSelect = "none", m.style.webkitUserSelect = "none", v(() => {
          m.style.userSelect = f, m.style.webkitUserSelect = f;
        });
      }
    });
    function p() {
      c.value = !1, i.isPointerDownOnContentRef.value = !1, Pe(() => {
        document.getSelection()?.toString() !== "" && (i.hasSelectionRef.value = !0);
      });
    }
    return Ce(() => {
      s.value && (document.addEventListener("pointerup", p), EP(s.value).forEach((m) => m.setAttribute("tabindex", "-1")));
    }), nt(() => {
      document.removeEventListener("pointerup", p), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;
    }), (v, m) => (h(), w(l(Oa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: m[1] || (m[1] = (y) => a("escapeKeyDown", y)),
      onPointerDownOutside: m[2] || (m[2] = (y) => a("pointerDownOutside", y)),
      onFocusOutside: m[3] || (m[3] = Ye((y) => a("focusOutside", y), ["prevent"])),
      onDismiss: l(i).onDismiss
    }, {
      default: g(() => [N(l(Kr), T({
        ...l(r),
        ...v.$attrs
      }, {
        ref: l(o),
        "data-state": l(i).open.value ? "open" : "closed",
        style: {
          userSelect: c.value ? "text" : void 0,
          WebkitUserSelect: c.value ? "text" : void 0,
          "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
          "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
          "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onPointerdown: m[0] || (m[0] = (y) => {
          y.currentTarget.contains(y.target) && (c.value = !0), l(i).hasSelectionRef.value = !1, l(i).isPointerDownOnContentRef.value = !0;
        })
      }), {
        default: g(() => [_(v.$slots, "default")]),
        _: 3
      }, 16, ["data-state", "style"])]),
      _: 3
    }, 8, ["onDismiss"]));
  }
}), IP = TP, OP = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t), { forwardRef: o } = j(), s = zc();
    return (i, u) => (h(), w(l(yt), { present: i.forceMount || l(s).open.value }, {
      default: g(() => [N(IP, T(l(r), {
        ref: l(o),
        onPointerenter: u[0] || (u[0] = (d) => l(hd)(l(s).onOpen)(d))
      }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"]));
  }
}), RP = OP, VP = /* @__PURE__ */ b({
  __name: "HoverCardPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), FP = VP, NP = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  setup(e) {
    const { forwardRef: t, currentElement: n } = j(), a = zc();
    a.triggerElement = n;
    function r() {
      setTimeout(() => {
        !a.isPointerInTransitRef.value && !a.open.value && a.onClose();
      }, 0);
    }
    return (o, s) => (h(), w(l(sr), {
      "as-child": "",
      reference: o.reference
    }, {
      default: g(() => [N(l(X), {
        ref: l(t),
        "as-child": o.asChild,
        as: o.as,
        "data-state": l(a).open.value ? "open" : "closed",
        "data-grace-area-trigger": "",
        onPointerenter: s[0] || (s[0] = (i) => l(hd)(l(a).onOpen)(i)),
        onPointerleave: s[1] || (s[1] = (i) => l(hd)(r)(i)),
        onFocus: s[2] || (s[2] = (i) => l(a).onOpen()),
        onBlur: s[3] || (s[3] = (i) => l(a).onClose())
      }, {
        default: g(() => [_(o.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "data-state"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), LP = NP, zP = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "label"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(X), T(t, { onMousedown: a[0] || (a[0] = (r) => {
      !r.defaultPrevented && r.detail > 1 && r.preventDefault();
    }) }), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), HP = zP, UP = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(Ac), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), jP = UP;
const [Ai, WP] = Se("MenubarRoot");
var GP = /* @__PURE__ */ b({
  __name: "MenubarRoot",
  props: {
    modelValue: {
      type: String,
      required: !1
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r } = j(), { CollectionSlot: o } = st({
      key: "Menubar",
      isProvider: !0
    }), s = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), i = I(null), { dir: u, loop: d } = qe(n), c = gt(u);
    return WP({
      modelValue: s,
      dir: c,
      loop: d,
      onMenuOpen: (f) => {
        s.value = f, i.value = f;
      },
      onMenuClose: () => {
        s.value = "";
      },
      onMenuToggle: (f) => {
        s.value = s.value ? "" : f, i.value = f;
      }
    }), (f, p) => (h(), w(l(o), null, {
      default: g(() => [N(l(fs), {
        "current-tab-stop-id": i.value,
        "onUpdate:currentTabStopId": p[0] || (p[0] = (v) => i.value = v),
        orientation: "horizontal",
        loop: l(d),
        dir: l(c),
        "as-child": ""
      }, {
        default: g(() => [N(l(X), {
          ref: l(r),
          role: "menubar"
        }, {
          default: g(() => [_(f.$slots, "default", { modelValue: l(s) })]),
          _: 3
        }, 512)]),
        _: 3
      }, 8, [
        "current-tab-stop-id",
        "loop",
        "dir"
      ])]),
      _: 3
    }));
  }
}), KP = GP;
const [Hc, YP] = Se("MenubarMenu");
var XP = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: { value: {
    type: String,
    required: !1
  } },
  setup(e) {
    const n = Ke(e.value), a = Ai();
    j();
    const r = I(), o = I(!1), s = A(() => a.modelValue.value === n);
    return me(s, () => {
      s.value || (o.value = !1);
    }), YP({
      value: n,
      triggerElement: r,
      triggerId: n,
      contentId: "",
      wasKeyboardTriggerOpenRef: o
    }), (i, u) => (h(), w(l(Pc), {
      open: s.value,
      modal: !1,
      dir: l(a).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || l(a).onMenuClose();
      })
    }, {
      default: g(() => [_(i.$slots, "default")]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), JP = XP, ZP = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const o = Ai(), s = Hc();
    s.contentId ||= Ke(void 0, "reka-menubar-content");
    const { getItems: i } = st({ key: "Menubar" }), u = I(!1);
    function d(c) {
      const p = c.target.hasAttribute("data-reka-menubar-subtrigger"), m = (o.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!m && p) return;
      let x = i().filter(($) => $.ref.dataset.disabled !== "").map(($) => $.ref.dataset.value);
      m && x.reverse();
      const C = x.indexOf(s.value);
      x = o.loop.value ? gc(x, C + 1) : x.slice(C + 1);
      const [S] = x;
      S && o.onMenuOpen(S);
    }
    return (c, f) => (h(), w(l(Ec), T(l(r), {
      id: l(s).contentId,
      "data-reka-menubar-content": "",
      "aria-labelledby": l(s).triggerId,
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (p) => {
        !l(o).modelValue.value && !u.value && l(s).triggerElement.value?.focus(), u.value = !1, p.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (p) => {
        const v = p.target;
        l(i)().filter((y) => y.ref.dataset.disabled !== "").some((y) => y.ref.contains(v)) && p.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (p) => {
        u.value = !0;
      }),
      onEntryFocus: f[3] || (f[3] = (p) => {
        l(s).wasKeyboardTriggerOpenRef.value || p.preventDefault();
      }),
      onKeydown: Je(d, ["arrow-right", "arrow-left"])
    }), {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), QP = ZP, eM = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(qi), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), tM = eM, nM = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(hs), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), aM = nM, rM = /* @__PURE__ */ b({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(qc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Cg = rM, oM = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Tc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), sM = oM, lM = /* @__PURE__ */ b({
  __name: "MenubarPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ic), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Sg = lM, iM = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = Gt(t);
    return j(), (o, s) => (h(), w(l(Oc), oe(le({
      ...n,
      ...l(r)
    })), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), uM = iM, dM = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return j(), (o, s) => (h(), w(l(Rc), oe(le(l(r))), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), cM = dM, fM = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Vc), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), pM = fM, vM = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    return (o, s) => (h(), w(l(Fc), {
      open: l(r),
      "onUpdate:open": s[0] || (s[0] = (i) => Ct(r) ? r.value = i : null)
    }, {
      default: g(() => [_(o.$slots, "default", { open: l(r) })]),
      _: 3
    }, 8, ["open"]));
  }
}), mM = vM, hM = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    j();
    const { getItems: o } = st({ key: "Menubar" }), s = Ai(), i = Hc();
    function u(d) {
      if (d.target.hasAttribute("data-reka-menubar-subtrigger")) return;
      let p = o().filter((y) => y.ref.dataset.disabled !== "").map((y) => y.ref.dataset.value);
      const v = p.indexOf(i.value);
      p = s.loop.value ? gc(p, v + 1) : p.slice(v + 1);
      const [m] = p;
      m && s.onMenuOpen(m);
    }
    return (d, c) => (h(), w(l(Nc), T(l(r), {
      "data-reka-menubar-content": "",
      style: {
        "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
        "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
        "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onKeydown: Je(u, ["arrow-right"])
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), gM = hM, yM = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(Lc), T(t, { "data-reka-menubar-subtrigger": "" }), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), bM = yM, _M = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = Ai(), n = Hc(), { forwardRef: a, currentElement: r } = j(), { CollectionItem: o } = st({ key: "Menubar" }), s = I(!1), i = A(() => t.modelValue.value === n.value);
    return Ce(() => {
      n.triggerElement = r;
    }), (u, d) => (h(), w(l(ps), {
      "as-child": "",
      focusable: !u.disabled,
      "tab-stop-id": l(n).value
    }, {
      default: g(() => [N(l(o), null, {
        default: g(() => [N(l(Di), { "as-child": "" }, {
          default: g(() => [N(l(X), {
            id: l(n).triggerId,
            ref: l(a),
            as: u.as,
            "as-child": u.asChild,
            type: u.as === "button" ? "button" : void 0,
            role: "menuitem",
            "aria-haspopup": "menu",
            "aria-expanded": i.value,
            "aria-controls": i.value ? l(n).contentId : void 0,
            "data-highlighted": s.value ? "" : void 0,
            "data-state": i.value ? "open" : "closed",
            "data-disabled": u.disabled ? "" : void 0,
            disabled: u.disabled,
            "data-value": l(n).value,
            onPointerdown: d[0] || (d[0] = (c) => {
              !u.disabled && c.button === 0 && c.ctrlKey === !1 && (l(t).onMenuOpen(l(n).value), i.value || c.preventDefault());
            }),
            onPointerenter: d[1] || (d[1] = () => {
              l(t).modelValue.value && !i.value && (l(t).onMenuOpen(l(n).value), l(r)?.focus());
            }),
            onKeydown: d[2] || (d[2] = Je((c) => {
              u.disabled || (["Enter", " "].includes(c.key) && l(t).onMenuToggle(l(n).value), c.key === "ArrowDown" && l(t).onMenuOpen(l(n).value), [
                "Enter",
                " ",
                "ArrowDown"
              ].includes(c.key) && (l(n).wasKeyboardTriggerOpenRef.value = !0, c.preventDefault()));
            }, [
              "enter",
              "space",
              "arrow-down"
            ])),
            onFocus: d[3] || (d[3] = (c) => s.value = !0),
            onBlur: d[4] || (d[4] = (c) => s.value = !1)
          }, {
            default: g(() => [_(u.$slots, "default")]),
            _: 3
          }, 8, [
            "id",
            "as",
            "as-child",
            "type",
            "aria-expanded",
            "aria-controls",
            "data-highlighted",
            "data-state",
            "data-disabled",
            "disabled",
            "data-value"
          ])]),
          _: 3
        })]),
        _: 3
      })]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), wM = _M;
function Ei(e) {
  return e ? "open" : "closed";
}
function $g(e, t) {
  return `${e}-trigger-${t}`;
}
function Uc(e, t) {
  return `${e}-content-${t}`;
}
const xM = "navigationMenu.linkSelect", Do = "navigationMenu.rootContentDismiss";
function gd(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (a) => {
    const r = a.tagName === "INPUT" && a.type === "hidden";
    return a.disabled || a.hidden || r ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Bg(e) {
  const t = rt();
  return e.some((n) => n === t ? !0 : (n.focus(), rt() !== t));
}
function CM(e) {
  return e.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    e.forEach((t) => {
      const n = t.dataset.tabindex;
      t.setAttribute("tabindex", n);
    });
  };
}
function kg(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
const [ur, SM] = Se(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var $M = /* @__PURE__ */ b({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: {
      type: String,
      required: !1,
      default: void 0
    },
    defaultValue: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: 200
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableClickTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableHoverTrigger: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disablePointerLeaveClose: {
      type: Boolean,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ie(n, "modelValue", t, {
      defaultValue: n.defaultValue ?? "",
      passive: n.modelValue === void 0
    }), o = I(""), { forwardRef: s, currentElement: i } = j(), u = I(), d = I(), c = I(), { getItems: f, CollectionSlot: p } = st({
      key: "NavigationMenu",
      isProvider: !0
    }), { delayDuration: v, skipDelayDuration: m, dir: y, disableClickTrigger: x, disableHoverTrigger: C, unmountOnHide: S } = qe(n), $ = gt(y), k = rs(!1, m), B = A(() => r.value !== "" || k.value ? 150 : v.value), P = /* @__PURE__ */ fi((q) => {
      typeof q == "string" && (o.value = r.value, r.value = q);
    }, B);
    Te(() => {
      if (!r.value) return;
      const q = f().map((E) => E.ref);
      c.value = q.find((E) => E.id.includes(r.value));
    }), ct(i, Do, M), SM({
      isRootMenu: !0,
      modelValue: r,
      previousValue: o,
      baseId: Ke(void 0, "reka-navigation-menu"),
      disableClickTrigger: x,
      disableHoverTrigger: C,
      dir: $,
      unmountOnHide: S,
      orientation: n.orientation,
      rootNavigationMenu: i,
      indicatorTrack: u,
      activeTrigger: c,
      onIndicatorTrackChange: (q) => {
        u.value = q;
      },
      viewport: d,
      onViewportChange: (q) => {
        d.value = q;
      },
      onTriggerEnter: (q) => {
        P(q);
      },
      onTriggerLeave: () => {
        k.value = !0, P("");
      },
      onContentEnter: () => {
        P();
      },
      onContentLeave: () => {
        n.disablePointerLeaveClose || P("");
      },
      onItemSelect: (q) => {
        o.value = r.value, r.value = q;
      },
      onItemDismiss: M
    });
    function M() {
      o.value = r.value, r.value = "";
    }
    return (q, E) => (h(), w(l(p), null, {
      default: g(() => [N(l(X), {
        ref: l(s),
        as: q.as,
        "as-child": q.asChild,
        "data-orientation": q.orientation,
        dir: l($),
        "data-reka-navigation-menu": ""
      }, {
        default: g(() => [_(q.$slots, "default", { modelValue: l(r) })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-orientation",
        "dir"
      ])]),
      _: 3
    }));
  }
}), BM = $M;
const [jc, kM] = Se("NavigationMenuItem");
var PM = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "li"
    }
  },
  setup(e) {
    const t = e;
    j();
    const { getItems: n } = st({ key: "NavigationMenu" }), a = ur(), r = Ke(t.value), o = I(), s = I(), i = Uc(a.baseId, r);
    let u = () => ({});
    const d = I(!1);
    async function c(m = "start") {
      const y = document.getElementById(i);
      if (y) {
        u();
        const x = gd(y);
        x.length && Bg(m === "start" ? x : x.reverse());
      }
    }
    function f() {
      const m = document.getElementById(i);
      if (m) {
        const y = gd(m);
        y.length && (u = CM(y));
      }
    }
    kM({
      value: r,
      contentId: i,
      triggerRef: o,
      focusProxyRef: s,
      wasEscapeCloseRef: d,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function p() {
      a.onItemDismiss(), o.value?.focus();
    }
    function v(m) {
      const y = rt();
      if (m.keyCode === 32 || m.key === "Enter") if (a.modelValue.value === r) {
        p(), m.preventDefault();
        return;
      } else {
        m.target.click(), m.preventDefault();
        return;
      }
      const x = n().filter((S) => S.ref.parentElement?.hasAttribute("data-menu-item")).map((S) => S.ref);
      if (!x.includes(y)) return;
      const C = rr(m, y, void 0, {
        itemsArray: x,
        loop: !1
      });
      C && C?.focus(), m.preventDefault(), m.stopPropagation();
    }
    return (m, y) => (h(), w(l(X), {
      "as-child": m.asChild,
      as: m.as,
      "data-menu-item": "",
      onKeydown: Je(v, [
        "up",
        "down",
        "left",
        "right",
        "home",
        "end",
        "space"
      ])
    }, {
      default: g(() => [_(m.$slots, "default")]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), MM = PM, DM = /* @__PURE__ */ b({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = ur(), u = jc(), d = $g(i.baseId, u.value), c = Uc(i.baseId, u.value), f = I(null), p = A(() => {
      const S = r().map((q) => q.ref.id.split("trigger-")[1]);
      i.dir.value === "rtl" && S.reverse();
      const $ = S.indexOf(i.modelValue.value), k = S.indexOf(i.previousValue.value), B = u.value === i.modelValue.value, P = k === S.indexOf(u.value);
      if (!B && !P) return f.value;
      const M = (() => {
        if ($ !== k) {
          if (B && k !== -1) return $ > k ? "from-end" : "from-start";
          if (P && $ !== -1) return $ > k ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = M, M;
    });
    function v(S) {
      if (a("focusOutside", S), a("interactOutside", S), S.detail.originalEvent.target.hasAttribute("data-navigation-menu-trigger") && S.preventDefault(), !S.defaultPrevented) {
        u.onContentFocusOutside();
        const k = S.target;
        i.rootNavigationMenu?.value?.contains(k) && S.preventDefault();
      }
    }
    function m(S) {
      if (a("pointerDownOutside", S), !S.defaultPrevented) {
        const $ = S.target, k = r().some((P) => P.ref.contains($)), B = i.isRootMenu && i.viewport.value?.contains($);
        (k || B || !i.isRootMenu) && S.preventDefault();
      }
    }
    Te((S) => {
      const $ = s.value;
      if (i.isRootMenu && $) {
        const k = () => {
          i.onItemDismiss(), u.onRootContentClose(), $.contains(rt()) && u.triggerRef.value?.focus();
        };
        $.addEventListener(Do, k), S(() => $.removeEventListener(Do, k));
      }
    });
    function y(S) {
      a("escapeKeyDown", S), S.defaultPrevented || (i.onItemDismiss(), u.triggerRef?.value?.focus(), u.wasEscapeCloseRef.value = !0);
    }
    function x(S) {
      if (S.target.closest("[data-reka-navigation-menu]") !== i.rootNavigationMenu.value) return;
      const $ = S.altKey || S.ctrlKey || S.metaKey, k = S.key === "Tab" && !$, B = gd(S.currentTarget);
      if (k) {
        const M = rt(), q = B.findIndex((O) => O === M), D = S.shiftKey ? B.slice(0, q).reverse() : B.slice(q + 1, B.length);
        if (Bg(D)) S.preventDefault();
        else {
          u.focusProxyRef.value?.focus();
          return;
        }
      }
      rr(S, rt(), void 0, {
        itemsArray: B,
        loop: !1,
        enableIgnoredElement: !0
      })?.focus();
    }
    function C() {
      const S = new Event(Do, {
        bubbles: !0,
        cancelable: !0
      });
      s.value?.dispatchEvent(S);
    }
    return (S, $) => (h(), w(l(Oa), T({
      id: l(c),
      ref: l(o),
      "aria-labelledby": l(d),
      "data-motion": p.value,
      "data-state": l(Ei)(l(i).modelValue.value === l(u).value),
      "data-orientation": l(i).orientation
    }, n, {
      onKeydown: x,
      onEscapeKeyDown: y,
      onPointerDownOutside: m,
      onFocusOutside: v,
      onDismiss: C
    }), {
      default: g(() => [_(S.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "aria-labelledby",
      "data-motion",
      "data-state",
      "data-orientation"
    ]));
  }
}), qM = DM, AM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = ve(Z(n, "forceMount"), a), { forwardRef: o } = j(), s = ur(), i = jc(), u = A(() => i.value === s.modelValue.value), d = A(() => s.viewport.value && !s.modelValue.value && s.previousValue.value ? s.previousValue.value === i.value : !1);
    return (c, f) => (h(), w(ci, {
      to: l(Ut) && l(s).viewport.value ? l(s).viewport.value : "body",
      disabled: l(Ut) && l(s).viewport.value ? !l(s).viewport.value : !0
    }, [N(l(yt), {
      present: c.forceMount || u.value || d.value,
      "force-mount": !l(s).unmountOnHide.value
    }, {
      default: g(({ present: p }) => [N(qM, T({
        ref: l(o),
        "data-state": l(Ei)(u.value),
        style: { pointerEvents: !u.value && l(s).isRootMenu ? "none" : void 0 }
      }, {
        ...c.$attrs,
        ...l(r)
      }, {
        hidden: !p,
        onPointerenter: f[0] || (f[0] = (v) => l(s).onContentEnter(l(i).value)),
        onPointerleave: f[1] || (f[1] = (v) => l(kg)(() => l(s).onContentLeave())(v)),
        onPointerDownOutside: f[2] || (f[2] = (v) => a("pointerDownOutside", v)),
        onFocusOutside: f[3] || (f[3] = (v) => a("focusOutside", v)),
        onInteractOutside: f[4] || (f[4] = (v) => a("interactOutside", v))
      }), {
        default: g(() => [_(c.$slots, "default")]),
        _: 2
      }, 1040, [
        "data-state",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"])], 8, ["to", "disabled"]));
  }
}), EM = AM, TM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = ur(), r = I(), o = A(() => a.orientation === "horizontal"), s = A(() => !!a.modelValue.value), { activeTrigger: i } = a;
    function u() {
      i.value && (r.value = {
        size: o.value ? i.value.offsetWidth : i.value.offsetHeight,
        position: o.value ? i.value.offsetLeft : i.value.offsetTop
      });
    }
    return Te(() => {
      a.modelValue.value && u();
    }), qn(i, u), qn(a.indicatorTrack, u), (d, c) => l(a).indicatorTrack.value ? (h(), w(ci, {
      key: 0,
      to: l(a).indicatorTrack.value
    }, [N(l(yt), { present: d.forceMount || s.value }, {
      default: g(() => [N(l(X), T({
        ref: l(n),
        "aria-hidden": "true",
        "data-state": s.value ? "visible" : "hidden",
        "data-orientation": l(a).orientation,
        "as-child": t.asChild,
        as: d.as,
        style: { ...r.value ? {
          "--reka-navigation-menu-indicator-size": `${r.value.size}px`,
          "--reka-navigation-menu-indicator-position": `${r.value.position}px`
        } : {} }
      }, d.$attrs), {
        default: g(() => [_(d.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }, 8, ["present"])], 8, ["to"])) : De("v-if", !0);
  }
}), IM = TM, OM = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "a"
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { CollectionItem: r } = st({ key: "NavigationMenu" });
    j();
    async function o(s) {
      const i = new CustomEvent(xM, {
        bubbles: !0,
        cancelable: !0,
        detail: { originalEvent: s }
      });
      if (a("select", i), !i.defaultPrevented && !s.metaKey) {
        const u = new CustomEvent(Do, {
          bubbles: !0,
          cancelable: !0
        });
        s.target?.dispatchEvent(u);
      }
    }
    return (s, i) => (h(), w(l(r), null, {
      default: g(() => [N(l(X), {
        as: s.as,
        "data-active": s.active ? "" : void 0,
        "aria-current": s.active ? "page" : void 0,
        "as-child": n.asChild,
        onClick: o
      }, {
        default: g(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "data-active",
        "aria-current",
        "as-child"
      ])]),
      _: 3
    }));
  }
}), RM = OM, VM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "ul"
    }
  },
  setup(e) {
    const t = e, n = ur(), { forwardRef: a, currentElement: r } = j();
    return Ce(() => {
      n.onIndicatorTrackChange(r.value);
    }), (o, s) => (h(), w(l(X), {
      ref: l(a),
      style: { position: "relative" }
    }, {
      default: g(() => [N(l(X), T(o.$attrs, {
        "as-child": t.asChild,
        as: o.as,
        "data-orientation": l(n).orientation
      }), {
        default: g(() => [_(o.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-orientation"
      ])]),
      _: 3
    }, 512));
  }
}), FM = VM;
const NM = ["aria-owns"];
var LM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = ur(), a = jc(), { CollectionItem: r } = st({ key: "NavigationMenu" }), { forwardRef: o, currentElement: s } = j(), i = I(""), u = I(""), d = rs(!1, 300), c = I(!1), f = A(() => a.value === n.modelValue.value);
    Ce(() => {
      a.triggerRef = s, i.value = $g(n.baseId, a.value), u.value = Uc(n.baseId, a.value);
    });
    function p() {
      n.disableHoverTrigger.value || (c.value = !1, a.wasEscapeCloseRef.value = !1);
    }
    function v($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled || c.value || a.wasEscapeCloseRef.value || d.value) return;
        n.onTriggerEnter(a.value), d.value = !0;
      }
    }
    function m($) {
      if (!n.disableHoverTrigger.value && $.pointerType === "mouse") {
        if (t.disabled) return;
        n.onTriggerLeave(), d.value = !1;
      }
    }
    function y($) {
      (!("pointerType" in $) || $.pointerType === "mouse") && n.disableClickTrigger.value || d.value || (f.value ? n.onItemSelect("") : n.onItemSelect(a.value), c.value = f.value);
    }
    function x($) {
      const B = {
        horizontal: "ArrowDown",
        vertical: n.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight"
      }[n.orientation];
      f.value && $.key === B && (a.onEntryKeyDown(), $.preventDefault(), $.stopPropagation());
    }
    function C($) {
      a.focusProxyRef.value = jt($);
    }
    function S($) {
      const k = document.getElementById(a.contentId), B = $.relatedTarget, P = B === s.value, M = k?.contains(B);
      (P || !M) && a.onFocusProxyEnter(P ? "start" : "end");
    }
    return ($, k) => (h(), G(Ge, null, [N(l(r), null, {
      default: g(() => [N(l(X), T({
        id: i.value,
        ref: l(o),
        disabled: $.disabled,
        "data-disabled": $.disabled ? "" : void 0,
        "data-state": l(Ei)(f.value),
        "data-navigation-menu-trigger": "",
        "aria-expanded": f.value,
        "aria-controls": u.value,
        "as-child": t.asChild,
        as: $.as
      }, $.$attrs, {
        onPointerenter: p,
        onPointermove: v,
        onPointerleave: m,
        onClick: y,
        onKeydown: x
      }), {
        default: g(() => [_($.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "disabled",
        "data-disabled",
        "data-state",
        "aria-expanded",
        "aria-controls",
        "as-child",
        "as"
      ])]),
      _: 3
    }), f.value ? (h(), G(Ge, { key: 0 }, [N(l(Ci), {
      ref: C,
      "aria-hidden": "true",
      tabindex: 0,
      onFocus: S
    }), l(n).viewport ? (h(), G("span", {
      key: 0,
      "aria-owns": u.value
    }, null, 8, NM)) : De("v-if", !0)], 64)) : De("v-if", !0)], 64));
  }
}), zM = LM, HM = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    align: {
      type: String,
      required: !1,
      default: "center"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = ur(), { activeTrigger: o, rootNavigationMenu: s, modelValue: i } = r, u = I(), d = I(), c = A(() => !!r.modelValue.value);
    me(a, () => {
      r.onViewportChange(a.value);
    });
    const f = I();
    me([i, c], () => {
      Pe(() => {
        a.value && requestAnimationFrame(() => {
          const v = a.value?.querySelector("[data-state=open]");
          f.value = v;
        });
      });
    }, { immediate: !0 });
    function p() {
      if (f.value && o.value && s.value) {
        const v = document.documentElement.offsetWidth, m = document.documentElement.offsetHeight, y = s.value.getBoundingClientRect(), x = o.value.getBoundingClientRect(), { offsetWidth: C, offsetHeight: S } = f.value, $ = x.left - y.left, k = x.top - y.top;
        let B = null, P = null;
        switch (t.align) {
          case "start":
            B = $, P = k;
            break;
          case "end":
            B = $ - C + x.width, P = k - S + x.height;
            break;
          default:
            B = $ - C / 2 + x.width / 2, P = k - S / 2 + x.height / 2;
        }
        const M = 10;
        B + y.left < M && (B = M - y.left);
        const q = B + y.left + C;
        q > v - M && (B -= q - v + M, B < M - y.left && (B = M - y.left)), P + y.top < M && (P = M - y.top);
        const E = P + y.top + S;
        E > m - M && (P -= E - m + M, P < M - y.top && (P = M - y.top)), B = Math.round(B), P = Math.round(P), d.value = {
          left: B,
          top: P
        };
      }
    }
    return qn(f, () => {
      f.value && (u.value = {
        width: f.value.offsetWidth,
        height: f.value.offsetHeight
      }, p());
    }), qn([globalThis.document?.body, s], () => {
      p();
    }), (v, m) => (h(), w(l(yt), {
      present: v.forceMount || c.value,
      "force-mount": !l(r).unmountOnHide.value,
      onAfterLeave: m[2] || (m[2] = () => {
        u.value = void 0, d.value = void 0;
      })
    }, {
      default: g(({ present: y }) => [N(l(X), T(v.$attrs, {
        ref: l(n),
        as: v.as,
        "as-child": v.asChild,
        "data-state": l(Ei)(c.value),
        "data-orientation": l(r).orientation,
        style: {
          pointerEvents: !c.value && l(r).isRootMenu ? "none" : void 0,
          "--reka-navigation-menu-viewport-width": u.value ? `${u.value?.width}px` : void 0,
          "--reka-navigation-menu-viewport-height": u.value ? `${u.value?.height}px` : void 0,
          "--reka-navigation-menu-viewport-left": d.value ? `${d.value?.left}px` : void 0,
          "--reka-navigation-menu-viewport-top": d.value ? `${d.value?.top}px` : void 0
        },
        hidden: !y,
        onPointerenter: m[0] || (m[0] = (x) => l(r).onContentEnter(l(r).modelValue.value)),
        onPointerleave: m[1] || (m[1] = (x) => l(kg)(() => l(r).onContentLeave())(x))
      }), {
        default: g(() => [_(v.$slots, "default")]),
        _: 2
      }, 1040, [
        "as",
        "as-child",
        "data-state",
        "data-orientation",
        "style",
        "hidden"
      ])]),
      _: 3
    }, 8, ["present", "force-mount"]));
  }
}), UM = HM;
let Pu = /* @__PURE__ */ new Map(), yd = !1;
try {
  yd = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let El = !1;
try {
  El = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const Pg = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
class Mg {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(t) {
    let n = "";
    if (!yd && this.options.signDisplay != null ? n = WM(this.numberFormatter, this.options.signDisplay, t) : n = this.numberFormatter.format(t), this.options.style === "unit" && !El) {
      var a;
      let { unit: r, unitDisplay: o = "short", locale: s } = this.resolvedOptions();
      if (!r) return n;
      let i = (a = Pg[r]) === null || a === void 0 ? void 0 : a[o];
      n += i[s] || i.default;
    }
    return n;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(t) {
    return this.numberFormatter.formatToParts(t);
  }
  /** Formats a number range as a string. */
  formatRange(t, n) {
    if (typeof this.numberFormatter.formatRange == "function") return this.numberFormatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.format(t)}  ${this.format(n)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.numberFormatter.formatRangeToParts == "function") return this.numberFormatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.numberFormatter.formatToParts(t), r = this.numberFormatter.formatToParts(n);
    return [
      ...a.map((o) => ({
        ...o,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...r.map((o) => ({
        ...o,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.numberFormatter.resolvedOptions();
    return !yd && this.options.signDisplay != null && (t = {
      ...t,
      signDisplay: this.options.signDisplay
    }), !El && this.options.style === "unit" && (t = {
      ...t,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), t;
  }
  constructor(t, n = {}) {
    this.numberFormatter = jM(t, n), this.options = n;
  }
}
function jM(e, t = {}) {
  let { numberingSystem: n } = t;
  if (n && e.includes("-nu-") && (e.includes("-u-") || (e += "-u-"), e += `-nu-${n}`), t.style === "unit" && !El) {
    var a;
    let { unit: s, unitDisplay: i = "short" } = t;
    if (!s) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((a = Pg[s]) === null || a === void 0) && a[i])) throw new Error(`Unsupported unit ${s} with unitDisplay = ${i}`);
    t = {
      ...t,
      style: "decimal"
    };
  }
  let r = e + (t ? Object.entries(t).sort((s, i) => s[0] < i[0] ? -1 : 1).join() : "");
  if (Pu.has(r)) return Pu.get(r);
  let o = new Intl.NumberFormat(e, t);
  return Pu.set(r, o), o;
}
function WM(e, t, n) {
  if (t === "auto") return e.format(n);
  if (t === "never") return e.format(Math.abs(n));
  {
    let a = !1;
    if (t === "always" ? a = n > 0 || Object.is(n, 0) : t === "exceptZero" && (Object.is(n, -0) || Object.is(n, 0) ? n = Math.abs(n) : a = n > 0), a) {
      let r = e.format(-n), o = e.format(n), s = r.replace(o, "").replace(/\u200e|\u061C/, "");
      return [
        ...s
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), r.replace(o, "!!!").replace(s, "+").replace("!!!", o);
    } else return e.format(n);
  }
}
const GM = new RegExp("^.*\\(.*\\).*$"), KM = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
class Dg {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(t) {
    return Mu(this.locale, this.options, t).parse(t);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(t, n, a) {
    return Mu(this.locale, this.options, t).isValidPartialNumber(t, n, a);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(t) {
    return Mu(this.locale, this.options, t).options.numberingSystem;
  }
  constructor(t, n = {}) {
    this.locale = t, this.options = n;
  }
}
const Kp = /* @__PURE__ */ new Map();
function Mu(e, t, n) {
  let a = Yp(e, t);
  if (!e.includes("-nu-") && !a.isValidPartialNumber(n)) {
    for (let r of KM) if (r !== a.options.numberingSystem) {
      let o = Yp(e + (e.includes("-u-") ? "-nu-" : "-u-nu-") + r, t);
      if (o.isValidPartialNumber(n)) return o;
    }
  }
  return a;
}
function Yp(e, t) {
  let n = e + (t ? Object.entries(t).sort((r, o) => r[0] < o[0] ? -1 : 1).join() : ""), a = Kp.get(n);
  return a || (a = new YM(e, t), Kp.set(n, a)), a;
}
class YM {
  parse(t) {
    let n = this.sanitize(t);
    if (this.symbols.group && (n = yr(n, this.symbols.group, "")), this.symbols.decimal && (n = n.replace(this.symbols.decimal, ".")), this.symbols.minusSign && (n = n.replace(this.symbols.minusSign, "-")), n = n.replace(this.symbols.numeral, this.symbols.index), this.options.style === "percent") {
      let s = n.indexOf("-");
      n = n.replace("-", ""), n = n.replace("+", "");
      let i = n.indexOf(".");
      i === -1 && (i = n.length), n = n.replace(".", ""), i - 2 === 0 ? n = `0.${n}` : i - 2 === -1 ? n = `0.0${n}` : i - 2 === -2 ? n = "0.00" : n = `${n.slice(0, i - 2)}.${n.slice(i - 2)}`, s > -1 && (n = `-${n}`);
    }
    let a = n ? +n : NaN;
    if (isNaN(a)) return NaN;
    if (this.options.style === "percent") {
      var r, o;
      let s = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((r = this.options.minimumFractionDigits) !== null && r !== void 0 ? r : 0) + 2, 20),
        maximumFractionDigits: Math.min(((o = this.options.maximumFractionDigits) !== null && o !== void 0 ? o : 0) + 2, 20)
      };
      return new Dg(this.locale, s).parse(new Mg(this.locale, s).format(a));
    }
    return this.options.currencySign === "accounting" && GM.test(t) && (a = -1 * a), a;
  }
  sanitize(t) {
    return t = t.replace(this.symbols.literals, ""), this.symbols.minusSign && (t = t.replace("-", this.symbols.minusSign)), this.options.numberingSystem === "arab" && (this.symbols.decimal && (t = t.replace(",", this.symbols.decimal), t = t.replace("", this.symbols.decimal)), this.symbols.group && (t = yr(t, ".", this.symbols.group))), this.symbols.group === "" && t.includes("'") && (t = yr(t, "'", this.symbols.group)), this.options.locale === "fr-FR" && this.symbols.group && (t = yr(t, " ", this.symbols.group), t = yr(t, /\u00A0/g, this.symbols.group)), t;
  }
  isValidPartialNumber(t, n = -1 / 0, a = 1 / 0) {
    return t = this.sanitize(t), this.symbols.minusSign && t.startsWith(this.symbols.minusSign) && n < 0 ? t = t.slice(this.symbols.minusSign.length) : this.symbols.plusSign && t.startsWith(this.symbols.plusSign) && a > 0 && (t = t.slice(this.symbols.plusSign.length)), this.symbols.group && t.startsWith(this.symbols.group) || this.symbols.decimal && t.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0 ? !1 : (this.symbols.group && (t = yr(t, this.symbols.group, "")), t = t.replace(this.symbols.numeral, ""), this.symbols.decimal && (t = t.replace(this.symbols.decimal, "")), t.length === 0);
  }
  constructor(t, n = {}) {
    this.locale = t, n.roundingIncrement !== 1 && n.roundingIncrement != null && (n.maximumFractionDigits == null && n.minimumFractionDigits == null ? (n.maximumFractionDigits = 0, n.minimumFractionDigits = 0) : n.maximumFractionDigits == null ? n.maximumFractionDigits = n.minimumFractionDigits : n.minimumFractionDigits == null && (n.minimumFractionDigits = n.maximumFractionDigits)), this.formatter = new Intl.NumberFormat(t, n), this.options = this.formatter.resolvedOptions(), this.symbols = JM(t, this.formatter, this.options, n);
    var a, r;
    this.options.style === "percent" && (((a = this.options.minimumFractionDigits) !== null && a !== void 0 ? a : 0) > 18 || ((r = this.options.maximumFractionDigits) !== null && r !== void 0 ? r : 0) > 18) && console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
}
const Xp = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]), XM = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function JM(e, t, n, a) {
  var r, o, s, i;
  let u = new Intl.NumberFormat(e, {
    ...n,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  }), d = u.formatToParts(-10000.111), c = u.formatToParts(10000.111), f = XM.map((D) => u.formatToParts(D));
  var p;
  let v = (p = (r = d.find((D) => D.type === "minusSign")) === null || r === void 0 ? void 0 : r.value) !== null && p !== void 0 ? p : "-", m = (o = c.find((D) => D.type === "plusSign")) === null || o === void 0 ? void 0 : o.value;
  !m && (a?.signDisplay === "exceptZero" || a?.signDisplay === "always") && (m = "+");
  let x = (s = new Intl.NumberFormat(e, {
    ...n,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3).find((D) => D.type === "decimal")) === null || s === void 0 ? void 0 : s.value, C = (i = d.find((D) => D.type === "group")) === null || i === void 0 ? void 0 : i.value, S = d.filter((D) => !Xp.has(D.type)).map((D) => Jp(D.value)), $ = f.flatMap((D) => D.filter((O) => !Xp.has(O.type)).map((O) => Jp(O.value))), k = [
    .../* @__PURE__ */ new Set([
      ...S,
      ...$
    ])
  ].sort((D, O) => O.length - D.length), B = k.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${k.join("|")}|[\\p{White_Space}]`, "gu"), P = [
    ...new Intl.NumberFormat(n.locale, {
      useGrouping: !1
    }).format(9876543210)
  ].reverse(), M = new Map(P.map((D, O) => [
    D,
    O
  ])), q = new RegExp(`[${P.join("")}]`, "g");
  return {
    minusSign: v,
    plusSign: m,
    decimal: x,
    group: C,
    literals: B,
    numeral: q,
    index: (D) => String(M.get(D))
  };
}
function yr(e, t, n) {
  return e.replaceAll ? e.replaceAll(t, n) : e.split(t).join(n);
}
function Jp(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function qg(e) {
  const { disabled: t } = e, n = I(), a = /* @__PURE__ */ Sr(), r = () => window.clearTimeout(n.value), o = (p) => {
    r(), !t.value && (a.trigger(), n.value = window.setTimeout(() => {
      o(60);
    }, p));
  }, s = () => {
    o(400);
  }, i = () => {
    r();
  }, u = I(!1), d = A(() => jt(e.target)), c = (p) => {
    p.button !== 0 || u.value || (p.preventDefault(), u.value = !0, s());
  }, f = () => {
    u.value = !1, i();
  };
  return Ut && (ct(d || window, "pointerdown", c), ct(window, "pointerup", f), ct(window, "pointercancel", f)), {
    isPressed: u,
    onTrigger: a.on
  };
}
function Zp(e, t = I({})) {
  return nc(() => new Mg(e.value, t.value));
}
function ZM(e, t = I({})) {
  return nc(() => new Dg(e.value, t.value));
}
function Qp(e, t, n) {
  let a = e === "+" ? t + n : t - n;
  if (t % 1 !== 0 || n % 1 !== 0) {
    const r = t.toString().split("."), o = n.toString().split("."), s = r[1] && r[1].length || 0, i = o[1] && o[1].length || 0, u = 10 ** Math.max(s, i);
    t = Math.round(t * u), n = Math.round(n * u), a = e === "+" ? t + n : t - n, a /= u;
  }
  return a;
}
const [Wc, QM] = Se("NumberFieldRoot");
var eD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "NumberFieldRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: void 0
    },
    modelValue: {
      type: [Number, null],
      required: !1
    },
    min: {
      type: Number,
      required: !1
    },
    max: {
      type: Number,
      required: !1
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    stepSnapping: {
      type: Boolean,
      required: !1,
      default: !0
    },
    focusOnChange: {
      type: Boolean,
      required: !1,
      default: !0
    },
    formatOptions: {
      type: null,
      required: !1
    },
    locale: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    readonly: {
      type: Boolean,
      required: !1
    },
    disableWheelChange: {
      type: Boolean,
      required: !1
    },
    invertWheelChange: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r, readonly: o, disableWheelChange: s, invertWheelChange: i, min: u, max: d, step: c, stepSnapping: f, formatOptions: p, id: v, locale: m } = qe(n), y = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { primitiveElement: x, currentElement: C } = Lt(), S = mc(m), $ = In(C), k = I(), B = A(() => !Pn(y.value) && (U(y.value) === u.value || u.value && !isNaN(y.value) ? Qp("-", y.value, c.value) < u.value : !1)), P = A(() => !Pn(y.value) && (U(y.value) === d.value || d.value && !isNaN(y.value) ? Qp("+", y.value, c.value) > d.value : !1));
    function M(ee, de = 1) {
      if (n.focusOnChange && k.value?.focus(), n.disabled || n.readonly) return;
      const fe = F.parse(k.value?.value ?? "");
      isNaN(fe) ? y.value = u.value ?? 0 : ee === "increase" ? y.value = U(fe + (c.value ?? 1) * de) : y.value = U(fe - (c.value ?? 1) * de);
    }
    function q(ee = 1) {
      M("increase", ee);
    }
    function E(ee = 1) {
      M("decrease", ee);
    }
    function D(ee) {
      ee === "min" && u.value !== void 0 ? y.value = U(u.value) : ee === "max" && d.value !== void 0 && (y.value = U(d.value));
    }
    const O = Zp(S, p), F = ZM(S, p), J = A(() => O.resolvedOptions().maximumFractionDigits > 0 ? "decimal" : "numeric"), ne = Zp(S, p), Q = A(() => Pn(y.value) || isNaN(y.value) ? "" : ne.format(y.value));
    function W(ee) {
      return F.isValidPartialNumber(ee, u.value, d.value);
    }
    function H(ee) {
      k.value && (k.value.value = ee);
    }
    function U(ee) {
      let de;
      return c.value === void 0 || isNaN(c.value) || !f.value ? de = Ar(ee, u.value, d.value) : de = b0(ee, u.value, d.value, c.value), de = F.parse(O.format(de)), de;
    }
    function se(ee) {
      const de = F.parse(ee);
      return y.value = isNaN(de) ? void 0 : U(de), ee.length ? (isNaN(de), H(Q.value)) : H(ee);
    }
    return QM({
      modelValue: y,
      handleDecrease: E,
      handleIncrease: q,
      handleMinMaxValue: D,
      inputMode: J,
      inputEl: k,
      onInputElement: (ee) => k.value = ee,
      textValue: Q,
      validate: W,
      applyInputValue: se,
      disabled: r,
      readonly: o,
      disableWheelChange: s,
      invertWheelChange: i,
      max: d,
      min: u,
      isDecreaseDisabled: B,
      isIncreaseDisabled: P,
      id: v
    }), (ee, de) => (h(), w(l(X), T(ee.$attrs, {
      ref_key: "primitiveElement",
      ref: x,
      role: "group",
      as: ee.as,
      "as-child": ee.asChild,
      "data-disabled": l(r) ? "" : void 0,
      "data-readonly": l(o) ? "" : void 0
    }), {
      default: g(() => [_(ee.$slots, "default", {
        modelValue: l(y),
        textValue: Q.value
      }), l($) && ee.name ? (h(), w(l(On), {
        key: 0,
        type: "text",
        value: l(y),
        name: ee.name,
        disabled: l(r),
        readonly: l(o),
        required: ee.required
      }, null, 8, [
        "value",
        "name",
        "disabled",
        "readonly",
        "required"
      ])) : De("v-if", !0)]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-disabled",
      "data-readonly"
    ]));
  }
}), tD = eD, nD = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Wc(), a = A(() => n.disabled?.value || n.readonly.value || t.disabled || n.isDecreaseDisabled.value), { primitiveElement: r, currentElement: o } = Lt(), { isPressed: s, onTrigger: i } = qg({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleDecrease();
    }), (u, d) => (h(), w(l(X), T(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Decrease",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), aD = nD, rD = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Wc(), a = A(() => n.disabled?.value || n.readonly.value || t.disabled || n.isIncreaseDisabled.value), { primitiveElement: r, currentElement: o } = Lt(), { isPressed: s, onTrigger: i } = qg({
      target: o,
      disabled: a
    });
    return i(() => {
      n.handleIncrease();
    }), (u, d) => (h(), w(l(X), T(t, {
      ref_key: "primitiveElement",
      ref: r,
      tabindex: "-1",
      "aria-label": "Increase",
      type: u.as === "button" ? "button" : void 0,
      style: { userSelect: l(s) ? "none" : void 0 },
      disabled: a.value ? "" : void 0,
      "data-disabled": a.value ? "" : void 0,
      "data-pressed": l(s) ? "true" : void 0,
      onContextmenu: d[0] || (d[0] = Ye(() => {
      }, ["prevent"]))
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "type",
      "style",
      "disabled",
      "data-disabled",
      "data-pressed"
    ]));
  }
}), oD = rD, sD = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = Lt(), r = Wc();
    function o(u) {
      r.disableWheelChange.value || u.target === rt() && (Math.abs(u.deltaY) <= Math.abs(u.deltaX) || (u.preventDefault(), u.deltaY > 0 ? r.invertWheelChange.value ? r.handleDecrease() : r.handleIncrease() : u.deltaY < 0 && (r.invertWheelChange.value ? r.handleIncrease() : r.handleDecrease())));
    }
    Ce(() => {
      r.onInputElement(a.value);
    });
    const s = I(r.textValue.value);
    me(() => r.textValue.value, () => {
      s.value = r.textValue.value;
    }, {
      immediate: !0,
      deep: !0
    });
    function i() {
      requestAnimationFrame(() => {
        s.value = r.textValue.value;
      });
    }
    return (u, d) => (h(), w(l(X), T(t, {
      id: l(r).id.value,
      ref_key: "primitiveElement",
      ref: n,
      value: s.value,
      role: "spinbutton",
      type: "text",
      tabindex: "0",
      inputmode: l(r).inputMode.value,
      disabled: l(r).disabled.value ? "" : void 0,
      "data-disabled": l(r).disabled.value ? "" : void 0,
      readonly: l(r).readonly.value ? "" : void 0,
      "data-readonly": l(r).readonly.value ? "" : void 0,
      autocomplete: "off",
      autocorrect: "off",
      spellcheck: "false",
      "aria-roledescription": "Number field",
      "aria-valuenow": l(r).modelValue.value,
      "aria-valuemin": l(r).min.value,
      "aria-valuemax": l(r).max.value,
      onKeydown: [
        d[0] || (d[0] = Je(Ye((c) => l(r).handleIncrease(), ["prevent"]), ["up"])),
        d[1] || (d[1] = Je(Ye((c) => l(r).handleDecrease(), ["prevent"]), ["down"])),
        d[2] || (d[2] = Je(Ye((c) => l(r).handleIncrease(10), ["prevent"]), ["page-up"])),
        d[3] || (d[3] = Je(Ye((c) => l(r).handleDecrease(10), ["prevent"]), ["page-down"])),
        d[4] || (d[4] = Je(Ye((c) => l(r).handleMinMaxValue("min"), ["prevent"]), ["home"])),
        d[5] || (d[5] = Je(Ye((c) => l(r).handleMinMaxValue("max"), ["prevent"]), ["end"])),
        d[8] || (d[8] = Je((c) => l(r).applyInputValue(c.target?.value), ["enter"]))
      ],
      onWheel: o,
      onBeforeinput: d[6] || (d[6] = (c) => {
        const f = c.target;
        let p = f.value.slice(0, f.selectionStart ?? void 0) + (c.data ?? "") + f.value.slice(f.selectionEnd ?? void 0);
        l(r).validate(p) || c.preventDefault();
      }),
      onInput: d[7] || (d[7] = (c) => {
        const f = c.target;
        s.value = f.value;
      }),
      onChange: i,
      onBlur: d[9] || (d[9] = (c) => l(r).applyInputValue(c.target?.value))
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, [
      "id",
      "value",
      "inputmode",
      "disabled",
      "data-disabled",
      "readonly",
      "data-readonly",
      "aria-valuenow",
      "aria-valuemin",
      "aria-valuemax"
    ]));
  }
}), lD = sD, iD = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(X), T(t, { "data-type": "ellipsis" }), {
      default: g(() => [_(n.$slots, "default", {}, () => [a[0] || (a[0] = Re(""))])]),
      _: 3
    }, 16));
  }
}), uD = iD;
const [Jr, dD] = Se("PaginationRoot");
var cD = /* @__PURE__ */ b({
  __name: "PaginationRoot",
  props: {
    page: {
      type: Number,
      required: !1
    },
    defaultPage: {
      type: Number,
      required: !1,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      required: !0
    },
    total: {
      type: Number,
      required: !1,
      default: 0
    },
    siblingCount: {
      type: Number,
      required: !1,
      default: 2
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    showEdges: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "nav"
    }
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, { siblingCount: r, disabled: o, showEdges: s } = qe(n);
    j();
    const i = /* @__PURE__ */ Ie(n, "page", a, {
      defaultValue: n.defaultPage,
      passive: n.page === void 0
    }), u = A(() => Math.max(1, Math.ceil(n.total / (n.itemsPerPage || 1))));
    return dD({
      page: i,
      onPageChange(d) {
        i.value = d;
      },
      pageCount: u,
      siblingCount: r,
      disabled: o,
      showEdges: s
    }), (d, c) => (h(), w(l(X), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: g(() => [_(d.$slots, "default", {
        page: l(i),
        pageCount: u.value
      })]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), fD = cD, pD = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Jr();
    j();
    const a = A(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), w(l(X), T(t, {
      "aria-label": "First Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(1))
    }), {
      default: g(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("First page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), vD = pD, mD = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Jr();
    j();
    const a = A(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), w(l(X), T(t, {
      "aria-label": "Last Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).pageCount.value))
    }), {
      default: g(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Last page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), hD = mD;
function ga(e, t) {
  const n = t - e + 1;
  return Array.from({ length: n }, (a, r) => r + e);
}
function gD(e) {
  return e.map((t) => typeof t == "number" ? {
    type: "page",
    value: t
  } : { type: "ellipsis" });
}
const Fs = "ellipsis";
function yD(e, t, n, a) {
  const o = t, s = Math.max(e - n, 1), i = Math.min(e + n, o);
  if (a) {
    const d = Math.min(2 * n + 5, t) - 2, c = s > 3 && Math.abs(o - d - 1 + 1) > 2 && Math.abs(s - 1) > 2, f = i < o - 2 && Math.abs(o - d) > 2 && Math.abs(o - i) > 2;
    if (!c && f)
      return [
        ...ga(1, d),
        Fs,
        o
      ];
    if (c && !f) {
      const v = ga(o - d + 1, o);
      return [
        1,
        Fs,
        ...v
      ];
    }
    if (c && f) {
      const v = ga(s, i);
      return [
        1,
        Fs,
        ...v,
        Fs,
        o
      ];
    }
    return ga(1, o);
  } else {
    const u = n * 2 + 1;
    return t < u ? ga(1, o) : e <= n + 1 ? ga(1, u) : t - e <= n ? ga(t - u + 1, o) : ga(s, i);
  }
}
var bD = /* @__PURE__ */ b({
  __name: "PaginationList",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Jr(), a = A(() => gD(yD(n.page.value, n.pageCount.value, n.siblingCount.value, n.showEdges.value)));
    return (r, o) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(r.$slots, "default", { items: a.value })]),
      _: 3
    }, 16));
  }
}), _D = bD, wD = /* @__PURE__ */ b({
  __name: "PaginationListItem",
  props: {
    value: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Jr(), a = A(() => n.page.value === t.value), r = A(() => n.disabled.value);
    return (o, s) => (h(), w(l(X), T(t, {
      "data-type": "page",
      "aria-label": `Page ${o.value}`,
      "aria-current": a.value ? "page" : void 0,
      "data-selected": a.value ? "true" : void 0,
      disabled: r.value,
      type: o.as === "button" ? "button" : void 0,
      onClick: s[0] || (s[0] = (i) => !r.value && l(n).onPageChange(o.value))
    }), {
      default: g(() => [_(o.$slots, "default", {}, () => [Re(Fe(o.value), 1)])]),
      _: 3
    }, 16, [
      "aria-label",
      "aria-current",
      "data-selected",
      "disabled",
      "type"
    ]));
  }
}), xD = wD, CD = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Jr(), a = A(() => n.page.value === n.pageCount.value || n.disabled.value);
    return (r, o) => (h(), w(l(X), T(t, {
      "aria-label": "Next Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value + 1))
    }), {
      default: g(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Next page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), SD = CD, $D = /* @__PURE__ */ b({
  __name: "PaginationPrev",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = Jr(), a = A(() => n.page.value === 1 || n.disabled.value);
    return (r, o) => (h(), w(l(X), T(t, {
      "aria-label": "Previous Page",
      type: r.as === "button" ? "button" : void 0,
      disabled: a.value,
      onClick: o[0] || (o[0] = (s) => !a.value && l(n).onPageChange(l(n).page.value - 1))
    }), {
      default: g(() => [_(r.$slots, "default", {}, () => [o[1] || (o[1] = Re("Prev page"))])]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), BD = $D;
const [kD, PD] = Se("PinInputRoot");
var MD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PinInputRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    mask: {
      type: Boolean,
      required: !1
    },
    otp: {
      type: Boolean,
      required: !1
    },
    type: {
      type: null,
      required: !1,
      default: "text"
    },
    dir: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, { mask: r, otp: o, placeholder: s, type: i, disabled: u, dir: d } = qe(n), { forwardRef: c } = j(), f = gt(d), p = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? [],
      passive: !0,
      deep: !0
    }), v = A(() => Array.isArray(p.value) ? [...p.value] : []), m = I(/* @__PURE__ */ new Set());
    function y(S) {
      m.value.add(S);
    }
    const x = A(() => n.type === "number"), C = A(() => v.value.filter(($) => !!$ || x.value && $ === 0).length === m.value.size);
    return me(p, () => {
      C.value && a("complete", p.value);
    }, { deep: !0 }), PD({
      modelValue: p,
      currentModelValue: v,
      mask: r,
      otp: o,
      placeholder: s,
      type: i,
      dir: f,
      disabled: u,
      isCompleted: C,
      inputElements: m,
      onInputElementChange: y,
      isNumericMode: x
    }), (S, $) => (h(), w(l(X), T(S.$attrs, {
      ref: l(c),
      dir: l(f),
      "data-complete": C.value ? "" : void 0,
      "data-disabled": l(u) ? "" : void 0
    }), {
      default: g(() => [_(S.$slots, "default", { modelValue: l(p) }), N(On, {
        id: S.id,
        as: "input",
        feature: "focusable",
        tabindex: "-1",
        value: v.value.join(""),
        name: S.name ?? "",
        disabled: l(u),
        required: S.required,
        onFocus: $[0] || ($[0] = (k) => Array.from(m.value)?.[0]?.focus())
      }, null, 8, [
        "id",
        "value",
        "name",
        "disabled",
        "required"
      ])]),
      _: 3
    }, 16, [
      "dir",
      "data-complete",
      "data-disabled"
    ]));
  }
}), DD = MD, qD = /* @__PURE__ */ b({
  __name: "PinInputInput",
  props: {
    index: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = kD(), a = A(() => Array.from(n.inputElements.value)), r = A(() => n.currentModelValue.value[t.index]), o = A(() => t.disabled || n.disabled.value), s = A(() => n.otp.value), i = A(() => n.mask.value), { primitiveElement: u, currentElement: d } = Lt();
    function c(B) {
      const P = B.target;
      if ((B.data?.length ?? 0) > 1) {
        S(P.value);
        return;
      }
      if (n.isNumericMode.value && !/^\d*$/.test(P.value)) {
        P.value = P.value.replace(/\D/g, "");
        return;
      }
      P.value = B.data || P.value.slice(-1), k(t.index, P.value);
      const M = a.value[t.index + 1];
      M && M.focus();
    }
    function f() {
      Pe(() => {
        const B = d.value;
        B && (!B.value && B === rt() ? B.placeholder = "" : B.placeholder = n.placeholder.value);
      });
    }
    function p(B) {
      rr(B, rt(), void 0, {
        itemsArray: a.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: "horizontal",
        dir: n.dir.value
      });
    }
    function v(B) {
      if (B.preventDefault(), B.target.value) k(t.index, "");
      else {
        const q = a.value[t.index - 1];
        q && (q.focus(), k(t.index - 1, ""));
      }
    }
    function m(B) {
      B.key === "Delete" && (B.preventDefault(), k(t.index, ""));
    }
    function y(B) {
      if (n.otp.value) {
        const M = a.value.findIndex((q, E) => n.currentModelValue.value[E] === "" || n.currentModelValue.value[E] === void 0);
        if (M !== -1 && M < t.index) {
          a.value[M].focus();
          return;
        }
      }
      B.target.setSelectionRange(1, 1), f();
    }
    function x(B) {
      f();
    }
    function C(B) {
      B.preventDefault();
      const P = B.clipboardData;
      if (!P) return;
      const M = P.getData("text");
      S(M);
    }
    function S(B) {
      const P = [...n.currentModelValue.value], M = B.length >= a.value.length ? 0 : t.index, q = Math.min(M + B.length, a.value.length);
      for (let E = M; E < q; E++) {
        const D = a.value[E], O = B[E - M];
        n.isNumericMode.value && !/^\d*$/.test(O) || (P[E] = O, D.focus());
      }
      n.modelValue.value = P, a.value[q]?.focus();
    }
    function $(B) {
      let P = B.length - 1;
      for (; P >= 0 && B[P] === ""; )
        B.pop(), P--;
      return B;
    }
    function k(B, P) {
      const M = [...n.currentModelValue.value];
      if (n.isNumericMode.value) {
        const q = +P;
        P === "" || isNaN(q) ? delete M[B] : M[B] = q;
      } else M[B] = P;
      n.modelValue.value = $(M);
    }
    return me(r, f), Ce(() => {
      n.onInputElementChange(d.value);
    }), nt(() => {
      n.inputElements?.value.delete(d.value);
    }), (B, P) => (h(), w(l(X), {
      ref_key: "primitiveElement",
      ref: u,
      autocapitalize: "none",
      as: B.as,
      "as-child": B.asChild,
      autocomplete: s.value ? "one-time-code" : "false",
      type: i.value ? "password" : "text",
      inputmode: l(n).isNumericMode.value ? "numeric" : "text",
      pattern: l(n).isNumericMode.value ? "[0-9]*" : void 0,
      placeholder: l(n).placeholder.value,
      value: r.value,
      disabled: o.value,
      "data-disabled": o.value ? "" : void 0,
      "data-complete": l(n).isCompleted.value ? "" : void 0,
      "aria-label": `pin input ${B.index + 1} of ${a.value.length}`,
      onInput: P[0] || (P[0] = (M) => c(M)),
      onKeydown: [
        Je(p, [
          "left",
          "right",
          "up",
          "down",
          "home",
          "end"
        ]),
        Je(v, ["backspace"]),
        Je(m, ["delete"])
      ],
      onFocus: y,
      onBlur: x,
      onPaste: C
    }, {
      default: g(() => [_(B.$slots, "default")]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "autocomplete",
      "type",
      "inputmode",
      "pattern",
      "placeholder",
      "value",
      "disabled",
      "data-disabled",
      "data-complete",
      "aria-label"
    ]));
  }
}), AD = qD;
const Vo = 100, [ED, TD] = Se("ProgressRoot"), Tl = (e) => typeof e == "number";
function ID(e, t) {
  return Pn(e) || Tl(e) && !Number.isNaN(e) && e <= t && e >= 0 ? e : (console.error(`Invalid prop \`value\` of value \`${e}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Vo} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function OD(e) {
  return Tl(e) && !Number.isNaN(e) && e > 0 ? e : (console.error(`Invalid prop \`max\` of value \`${e}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Vo}\`.`), Vo);
}
var RD = /* @__PURE__ */ b({
  __name: "ProgressRoot",
  props: {
    modelValue: {
      type: [Number, null],
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: Vo
    },
    getValueLabel: {
      type: Function,
      required: !1,
      default: (e, t) => Tl(e) ? `${Math.round(e / t * Vo)}%` : void 0
    },
    getValueText: {
      type: Function,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:max"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = /* @__PURE__ */ Ie(n, "modelValue", a, { passive: n.modelValue === void 0 }), o = /* @__PURE__ */ Ie(n, "max", a, { passive: n.max === void 0 });
    me(() => r.value, async (i) => {
      const u = ID(i, n.max);
      u !== i && (await Pe(), r.value = u);
    }, { immediate: !0 }), me(() => n.max, (i) => {
      const u = OD(n.max);
      u !== i && (o.value = u);
    }, { immediate: !0 });
    const s = A(() => Pn(r.value) ? "indeterminate" : r.value === o.value ? "complete" : "loading");
    return TD({
      modelValue: r,
      max: o,
      progressState: s
    }), (i, u) => (h(), w(l(X), {
      "as-child": i.asChild,
      as: i.as,
      "aria-valuemax": l(o),
      "aria-valuemin": 0,
      "aria-valuenow": Tl(l(r)) ? l(r) : void 0,
      "aria-valuetext": i.getValueText?.(l(r), l(o)),
      "aria-label": i.getValueLabel(l(r), l(o)),
      role: "progressbar",
      "data-state": s.value,
      "data-value": l(r) ?? void 0,
      "data-max": l(o)
    }, {
      default: g(() => [_(i.$slots, "default", { modelValue: l(r) })]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "aria-valuemax",
      "aria-valuenow",
      "aria-valuetext",
      "aria-label",
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), VD = RD, FD = /* @__PURE__ */ b({
  __name: "ProgressIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ED();
    return j(), (a, r) => (h(), w(l(X), T(t, {
      "data-state": l(n).progressState.value,
      "data-value": l(n).modelValue?.value ?? void 0,
      "data-max": l(n).max.value
    }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, [
      "data-state",
      "data-value",
      "data-max"
    ]));
  }
}), ND = FD;
const LD = "radio.select";
function zD(e, t, n) {
  ns(LD, n, {
    originalEvent: e,
    value: t
  });
}
var HD = /* @__PURE__ */ b({
  __name: "Radio",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    checked: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:checked", "select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = /* @__PURE__ */ Ie(n, "checked", a, { passive: n.checked === void 0 }), { value: o } = qe(n), { forwardRef: s, currentElement: i } = j(), u = In(i), d = A(() => n.id && i.value ? document.querySelector(`[for="${n.id}"]`)?.innerText ?? n.value : void 0);
    function c(f) {
      n.disabled || zD(f, n.value, (p) => {
        a("select", p), !p?.defaultPrevented && (r.value = !0, u.value && p.stopPropagation());
      });
    }
    return (f, p) => (h(), w(l(X), T(f.$attrs, {
      id: f.id,
      ref: l(s),
      role: "radio",
      type: f.as === "button" ? "button" : void 0,
      as: f.as,
      "aria-checked": l(r),
      "aria-label": d.value,
      "as-child": f.asChild,
      disabled: f.disabled ? "" : void 0,
      "data-state": l(r) ? "checked" : "unchecked",
      "data-disabled": f.disabled ? "" : void 0,
      value: l(o),
      required: f.required,
      name: f.name,
      onClick: Ye(c, ["stop"])
    }), {
      default: g(() => [_(f.$slots, "default", { checked: l(r) }), l(u) && f.name ? (h(), w(l(On), {
        key: 0,
        type: "radio",
        tabindex: "-1",
        value: l(o),
        checked: !!l(r),
        name: f.name,
        disabled: f.disabled,
        required: f.required
      }, null, 8, [
        "value",
        "checked",
        "name",
        "disabled",
        "required"
      ])) : De("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "as",
      "aria-checked",
      "aria-label",
      "as-child",
      "disabled",
      "data-state",
      "data-disabled",
      "value",
      "required",
      "name"
    ]));
  }
}), UD = HD;
const [jD, WD] = Se("RadioGroupRoot");
var GD = /* @__PURE__ */ b({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: void 0
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { disabled: i, loop: u, orientation: d, name: c, required: f, dir: p } = qe(n), v = gt(p), m = In(o);
    return WD({
      modelValue: s,
      changeModelValue: (y) => {
        s.value = y;
      },
      disabled: i,
      loop: u,
      orientation: d,
      name: c?.value,
      required: f
    }), (y, x) => (h(), w(l(fs), {
      "as-child": "",
      orientation: l(d),
      dir: l(v),
      loop: l(u)
    }, {
      default: g(() => [N(l(X), {
        ref: l(r),
        role: "radiogroup",
        "data-disabled": l(i) ? "" : void 0,
        "as-child": y.asChild,
        as: y.as,
        "aria-orientation": l(d),
        "aria-required": l(f),
        dir: l(v)
      }, {
        default: g(() => [_(y.$slots, "default", { modelValue: l(s) }), l(m) && l(c) ? (h(), w(l(On), {
          key: 0,
          required: l(f),
          disabled: l(i),
          value: l(s),
          name: l(c)
        }, null, 8, [
          "required",
          "disabled",
          "value",
          "name"
        ])) : De("v-if", !0)]),
        _: 3
      }, 8, [
        "data-disabled",
        "as-child",
        "as",
        "aria-orientation",
        "aria-required",
        "dir"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), KD = GD;
const [YD, XD] = Se("RadioGroupItem");
var JD = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {
      type: String,
      required: !1
    },
    value: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = jD(), i = A(() => s.disabled.value || n.disabled), u = A(() => s.required.value || n.required), d = A(() => Dn(s.modelValue?.value, n.value));
    XD({
      disabled: i,
      checked: d
    });
    const c = I(!1), f = [
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ];
    ct("keydown", (v) => {
      f.includes(v.key) && (c.value = !0);
    }), ct("keyup", () => {
      c.value = !1;
    });
    function p() {
      setTimeout(() => {
        c.value && o.value?.click();
      }, 0);
    }
    return (v, m) => (h(), w(l(ps), {
      checked: d.value,
      disabled: i.value,
      "as-child": "",
      focusable: !i.value,
      active: d.value
    }, {
      default: g(() => [N(UD, T({
        ...v.$attrs,
        ...n
      }, {
        ref: l(r),
        checked: d.value,
        required: u.value,
        disabled: i.value,
        "onUpdate:checked": m[0] || (m[0] = (y) => l(s).changeModelValue(v.value)),
        onSelect: m[1] || (m[1] = (y) => a("select", y)),
        onKeydown: m[2] || (m[2] = Je(Ye(() => {
        }, ["prevent"]), ["enter"])),
        onFocus: p
      }), {
        default: g(() => [_(v.$slots, "default", {
          checked: d.value,
          required: u.value,
          disabled: i.value
        })]),
        _: 3
      }, 16, [
        "checked",
        "required",
        "disabled"
      ])]),
      _: 3
    }, 8, [
      "checked",
      "disabled",
      "focusable",
      "active"
    ]));
  }
}), ZD = JD, QD = /* @__PURE__ */ b({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const { forwardRef: t } = j(), n = YD();
    return (a, r) => (h(), w(l(yt), { present: a.forceMount || l(n).checked.value }, {
      default: g(() => [N(l(X), T({
        ref: l(t),
        "data-state": l(n).checked.value ? "checked" : "unchecked",
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "as-child": a.asChild,
        as: a.as
      }, a.$attrs), {
        default: g(() => [_(a.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), eq = QD;
const [mn, tq] = Se("ScrollAreaRoot");
var nq = /* @__PURE__ */ b({
  __name: "ScrollAreaRoot",
  props: {
    type: {
      type: String,
      required: !1,
      default: "hover"
    },
    dir: {
      type: String,
      required: !1
    },
    scrollHideDelay: {
      type: Number,
      required: !1,
      default: 600
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, a = I(0), r = I(0), o = I(), s = I(), i = I(), u = I(), d = I(!1), c = I(!1), { type: f, dir: p, scrollHideDelay: v } = qe(n), m = gt(p);
    function y() {
      o.value?.scrollTo({ top: 0 });
    }
    function x() {
      o.value?.scrollTo({
        top: 0,
        left: 0
      });
    }
    t({
      viewport: o,
      scrollTop: y,
      scrollTopLeft: x
    });
    const { forwardRef: C, currentElement: S } = j();
    return tq({
      type: f,
      dir: m,
      scrollHideDelay: v,
      scrollArea: S,
      viewport: o,
      onViewportChange: ($) => {
        o.value = $ || void 0;
      },
      content: s,
      onContentChange: ($) => {
        s.value = $;
      },
      scrollbarX: i,
      scrollbarXEnabled: d,
      scrollbarY: u,
      scrollbarYEnabled: c,
      onScrollbarXChange: ($) => {
        i.value = $ || void 0;
      },
      onScrollbarYChange: ($) => {
        u.value = $ || void 0;
      },
      onScrollbarXEnabledChange: ($) => {
        d.value = $;
      },
      onScrollbarYEnabledChange: ($) => {
        c.value = $;
      },
      onCornerWidthChange: ($) => {
        a.value = $;
      },
      onCornerHeightChange: ($) => {
        r.value = $;
      }
    }), ($, k) => (h(), w(l(X), {
      ref: l(C),
      "as-child": n.asChild,
      as: $.as,
      dir: l(m),
      style: dt({
        position: "relative",
        "--reka-scroll-area-corner-width": `${a.value}px`,
        "--reka-scroll-area-corner-height": `${r.value}px`
      })
    }, {
      default: g(() => [_($.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "dir",
      "style"
    ]));
  }
}), aq = nq, rq = /* @__PURE__ */ b({
  __name: "ScrollAreaCornerImpl",
  setup(e) {
    const t = mn(), n = I(0), a = I(0), r = A(() => !!n.value && !!a.value);
    function o() {
      const i = t.scrollbarX.value?.offsetHeight || 0;
      t.onCornerHeightChange(i), a.value = i;
    }
    function s() {
      const i = t.scrollbarY.value?.offsetWidth || 0;
      t.onCornerWidthChange(i), n.value = i;
    }
    return qn(t.scrollbarX.value, o), qn(t.scrollbarY.value, s), me(() => t.scrollbarX.value, o), me(() => t.scrollbarY.value, s), (i, u) => r.value ? (h(), w(l(X), T({
      key: 0,
      style: {
        width: `${n.value}px`,
        height: `${a.value}px`,
        position: "absolute",
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: 0
      }
    }, i.$parent?.$props), {
      default: g(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, ["style"])) : De("v-if", !0);
  }
}), oq = rq, sq = /* @__PURE__ */ b({
  __name: "ScrollAreaCorner",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = mn(), r = A(() => !!a.scrollbarX.value && !!a.scrollbarY.value), o = A(() => a.type.value !== "scroll" && r.value);
    return (s, i) => o.value ? (h(), w(oq, T({ key: 0 }, t, { ref: l(n) }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16)) : De("v-if", !0);
  }
}), lq = sq;
function Ag(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function Ti(e) {
  const t = Eg(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, a = (e.scrollbar.size - n) * t;
  return Math.max(a, 18);
}
function Eg(e, t) {
  const n = e / t;
  return Number.isNaN(n) ? 0 : n;
}
function iq(e, t = () => {
}) {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, a = 0;
  return (function r() {
    const o = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, s = n.left !== o.left, i = n.top !== o.top;
    (s || i) && t(), n = o, a = window.requestAnimationFrame(r);
  })(), () => window.cancelAnimationFrame(a);
}
function ev(e, t, n = "ltr") {
  const a = Ti(t), r = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, o = t.scrollbar.size - r, s = t.content - t.viewport, i = o - a, u = n === "ltr" ? [0, s] : [s * -1, 0], d = Ar(e, u[0], u[1]);
  return Ag([0, s], [0, i])(d);
}
function Ns(e) {
  return e ? Number.parseInt(e, 10) : 0;
}
function uq(e, t, n, a = "ltr") {
  const r = Ti(n), o = r / 2, s = t || o, i = r - s, u = n.scrollbar.paddingStart + s, d = n.scrollbar.size - n.scrollbar.paddingEnd - i, c = n.content - n.viewport, f = a === "ltr" ? [0, c] : [c * -1, 0];
  return Ag([u, d], f)(e);
}
function tv(e, t) {
  return e > 0 && e < t;
}
var dq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarX",
  setup(e) {
    const t = mn(), n = Ii(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarXChange(r.value);
    });
    const o = A(() => n.sizes.value);
    return (s, i) => (h(), w(Tg, {
      ref: l(a),
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: dt({
        bottom: 0,
        left: l(t).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
        right: l(t).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
        "--reka-scroll-area-thumb-width": o.value ? `${l(Ti)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.x))
    }, {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), cq = dq, fq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarY",
  setup(e) {
    const t = mn(), n = Ii(), { forwardRef: a, currentElement: r } = j();
    Ce(() => {
      r.value && t.onScrollbarYChange(r.value);
    });
    const o = A(() => n.sizes.value);
    return (s, i) => (h(), w(Tg, {
      ref: l(a),
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: dt({
        top: 0,
        right: l(t).dir.value === "ltr" ? 0 : void 0,
        left: l(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--reka-scroll-area-corner-height)",
        "--reka-scroll-area-thumb-height": o.value ? `${l(Ti)(o.value)}px` : void 0
      }),
      onOnDragScroll: i[0] || (i[0] = (u) => l(n).onDragScroll(u.y))
    }, {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), pq = fq, vq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarAuto",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = mn(), n = gs(), { forwardRef: a } = j(), r = I(!1), o = /* @__PURE__ */ fi(() => {
      if (t.viewport.value) {
        const s = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        r.value = n.isHorizontal.value ? s : i;
      }
    }, 10);
    return Ce(() => o()), qn(t.viewport, o), qn(t.content, o), (s, i) => (h(), w(l(yt), { present: s.forceMount || r.value }, {
      default: g(() => [N(Kc, T(s.$attrs, {
        ref: l(a),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: g(() => [_(s.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), Gc = vq, mq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarGlimpse",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = mn(), n = gs(), { forwardRef: a } = j(), { state: r, dispatch: o } = hc("hidden", {
      hidden: {
        POINTER_ENTER: "glimpse",
        SCROLL: "scrolling"
      },
      glimpse: {
        HIDE: "hidden",
        POINTER_LEAVE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "glimpse"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }), s = A(() => r.value !== "hidden");
    function i() {
      o("POINTER_ENTER");
    }
    function u() {
      o("POINTER_LEAVE");
    }
    const d = /* @__PURE__ */ fi(() => o("SCROLL_END"), 100);
    return Te((c) => {
      if (r.value === "glimpse") {
        const f = window.setTimeout(() => o("HIDE"), t.scrollHideDelay.value);
        c(() => {
          window.clearTimeout(f);
        });
      }
    }), Te((c) => {
      if (r.value === "idle") {
        const f = window.setTimeout(() => o("HIDE"), t.scrollHideDelay.value);
        c(() => {
          window.clearTimeout(f);
        });
      }
    }), Te((c) => {
      const f = t.viewport.value, p = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (f) {
        let v = f[p];
        const m = () => {
          const y = f[p];
          v !== y && (o("SCROLL"), d()), v = y;
        };
        f.addEventListener("scroll", m), c(() => {
          f.removeEventListener("scroll", m);
        });
      }
    }), Ce(() => {
      const c = t.scrollArea.value;
      c && (c.addEventListener("pointerenter", i), c.addEventListener("pointerleave", u));
    }), nt(() => {
      const c = t.scrollArea.value;
      c && (c.removeEventListener("pointerenter", i), c.removeEventListener("pointerleave", u));
    }), (c, f) => (h(), w(l(yt), { present: c.forceMount || s.value }, {
      default: g(() => [N(Gc, T(c.$attrs, {
        ref: l(a),
        "data-state": s.value ? "visible" : "hidden"
      }), {
        default: g(() => [_(c.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), hq = mq, gq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = mn(), { forwardRef: n } = j();
    let a;
    const r = I(!1);
    function o() {
      window.clearTimeout(a), r.value = !0;
    }
    function s() {
      a = window.setTimeout(() => {
        r.value = !1;
      }, t.scrollHideDelay.value);
    }
    return Ce(() => {
      const i = t.scrollArea.value;
      i && (i.addEventListener("pointerenter", o), i.addEventListener("pointerleave", s));
    }), nt(() => {
      const i = t.scrollArea.value;
      i && (window.clearTimeout(a), i.removeEventListener("pointerenter", o), i.removeEventListener("pointerleave", s));
    }), (i, u) => (h(), w(l(yt), { present: i.forceMount || r.value }, {
      default: g(() => [N(Gc, T(i.$attrs, {
        ref: l(n),
        "data-state": r.value ? "visible" : "hidden"
      }), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), yq = gq, bq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarScroll",
  props: { forceMount: {
    type: Boolean,
    required: !1
  } },
  setup(e) {
    const t = mn(), n = gs(), { forwardRef: a } = j(), { state: r, dispatch: o } = hc("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    }), s = A(() => r.value !== "hidden");
    Te((u) => {
      if (r.value === "idle") {
        const d = window.setTimeout(() => o("HIDE"), t.scrollHideDelay.value);
        u(() => {
          window.clearTimeout(d);
        });
      }
    });
    const i = /* @__PURE__ */ fi(() => o("SCROLL_END"), 100);
    return Te((u) => {
      const d = t.viewport.value, c = n.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (d) {
        let f = d[c];
        const p = () => {
          const v = d[c];
          f !== v && (o("SCROLL"), i()), f = v;
        };
        d.addEventListener("scroll", p), u(() => {
          d.removeEventListener("scroll", p);
        });
      }
    }), (u, d) => (h(), w(l(yt), { present: u.forceMount || s.value }, {
      default: g(() => [N(Kc, T(u.$attrs, {
        ref: l(a),
        "data-state": s.value ? "visible" : "hidden"
      }), {
        default: g(() => [_(u.$slots, "default")]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }, 8, ["present"]));
  }
}), _q = bq;
const [gs, wq] = Se("ScrollAreaScrollbar");
var xq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "vertical"
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = mn(), r = A(() => t.orientation === "horizontal");
    me(r, () => {
      r.value ? a.onScrollbarXEnabledChange(!0) : a.onScrollbarYEnabledChange(!0);
    }, { immediate: !0 }), nt(() => {
      a.onScrollbarXEnabledChange(!1), a.onScrollbarYEnabledChange(!1);
    });
    const { orientation: o, forceMount: s, asChild: i, as: u } = qe(t);
    return wq({
      orientation: o,
      forceMount: s,
      isHorizontal: r,
      as: u,
      asChild: i
    }), (d, c) => l(a).type.value === "hover" ? (h(), w(yq, T({ key: 0 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "scroll" ? (h(), w(_q, T({ key: 1 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "glimpse" ? (h(), w(hq, T({ key: 2 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "auto" ? (h(), w(Gc, T({ key: 3 }, d.$attrs, {
      ref: l(n),
      "force-mount": l(s)
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16, ["force-mount"])) : l(a).type.value === "always" ? (h(), w(Kc, T({ key: 4 }, d.$attrs, {
      ref: l(n),
      "data-state": "visible"
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16)) : De("v-if", !0);
  }
}), Cq = xq;
const [Ii, Sq] = Se("ScrollAreaScrollbarVisible");
var $q = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarVisible",
  setup(e) {
    const t = mn(), n = gs(), { forwardRef: a } = j(), r = I({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    }), o = A(() => {
      const C = Eg(r.value.viewport, r.value.content);
      return C > 0 && C < 1;
    }), s = I(), i = I(0);
    function u(C, S) {
      if (v.value) {
        const $ = t.viewport.value.scrollLeft + C.deltaY;
        t.viewport.value.scrollLeft = $, tv($, S) && C.preventDefault();
      } else {
        const $ = t.viewport.value.scrollTop + C.deltaY;
        t.viewport.value.scrollTop = $, tv($, S) && C.preventDefault();
      }
    }
    function d(C, S) {
      v.value ? i.value = S.x : i.value = S.y;
    }
    function c(C) {
      i.value = 0;
    }
    function f(C) {
      r.value = C;
    }
    function p(C, S) {
      return uq(C, i.value, r.value, S);
    }
    const v = A(() => n.isHorizontal.value);
    function m(C) {
      v.value ? t.viewport.value.scrollLeft = p(C, t.dir.value) : t.viewport.value.scrollTop = p(C);
    }
    function y() {
      if (v.value) {
        if (t.viewport.value && s.value) {
          const C = t.viewport.value.scrollLeft, S = ev(C, r.value, t.dir.value);
          s.value.style.transform = `translate3d(${S}px, 0, 0)`;
        }
      } else if (t.viewport.value && s.value) {
        const C = t.viewport.value.scrollTop, S = ev(C, r.value);
        s.value.style.transform = `translate3d(0, ${S}px, 0)`;
      }
    }
    function x(C) {
      s.value = C;
    }
    return Sq({
      sizes: r,
      hasThumb: o,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: c,
      handleSizeChange: f,
      onThumbPositionChange: y,
      onThumbChange: x,
      onDragScroll: m
    }), (C, S) => v.value ? (h(), w(cq, T({ key: 0 }, C.$attrs, { ref: l(a) }), {
      default: g(() => [_(C.$slots, "default")]),
      _: 3
    }, 16)) : (h(), w(pq, T({ key: 1 }, C.$attrs, { ref: l(a) }), {
      default: g(() => [_(C.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Kc = $q, Bq = /* @__PURE__ */ b({
  __name: "ScrollAreaScrollbarImpl",
  props: { isHorizontal: {
    type: Boolean,
    required: !0
  } },
  emits: [
    "onDragScroll",
    "onWheelScroll",
    "onThumbPointerDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = mn(), o = Ii(), s = gs(), { forwardRef: i, currentElement: u } = j(), d = I(""), c = I();
    function f(C) {
      if (c.value) {
        const S = C.clientX - c.value?.left, $ = C.clientY - c.value?.top;
        a("onDragScroll", {
          x: S,
          y: $
        });
      }
    }
    function p(C) {
      C.button === 0 && (C.target.setPointerCapture(C.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", r.viewport && (r.viewport.value.style.scrollBehavior = "auto"), f(C));
    }
    function v(C) {
      f(C);
    }
    function m(C) {
      const S = C.target;
      S.hasPointerCapture(C.pointerId) && S.releasePointerCapture(C.pointerId), document.body.style.webkitUserSelect = d.value, r.viewport && (r.viewport.value.style.scrollBehavior = ""), c.value = void 0;
    }
    function y(C) {
      const S = C.target, $ = u.value?.contains(S), k = o.sizes.value.content - o.sizes.value.viewport;
      $ && o.handleWheelScroll(C, k);
    }
    Ce(() => {
      document.addEventListener("wheel", y, { passive: !1 });
    }), nt(() => {
      document.removeEventListener("wheel", y);
    });
    function x() {
      u.value && (n.isHorizontal ? o.handleSizeChange({
        content: r.viewport.value?.scrollWidth ?? 0,
        viewport: r.viewport.value?.offsetWidth ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: Ns(getComputedStyle(u.value).paddingLeft),
          paddingEnd: Ns(getComputedStyle(u.value).paddingRight)
        }
      }) : o.handleSizeChange({
        content: r.viewport.value?.scrollHeight ?? 0,
        viewport: r.viewport.value?.offsetHeight ?? 0,
        scrollbar: {
          size: u.value?.clientHeight ?? 0,
          paddingStart: Ns(getComputedStyle(u.value).paddingTop),
          paddingEnd: Ns(getComputedStyle(u.value).paddingBottom)
        }
      }), o.onThumbPositionChange());
    }
    return qn(u, x), qn(r.content, x), (C, S) => (h(), w(l(X), {
      ref: l(i),
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: l(s).as.value,
      "as-child": l(s).asChild.value,
      onPointerdown: p,
      onPointermove: v,
      onPointerup: m
    }, {
      default: g(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Tg = Bq, kq = /* @__PURE__ */ b({
  __name: "ScrollAreaThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = mn(), a = Ii();
    function r(p) {
      const m = p.target.getBoundingClientRect(), y = p.clientX - m.left, x = p.clientY - m.top;
      a.handleThumbDown(p, {
        x: y,
        y: x
      });
    }
    function o(p) {
      a.handleThumbUp(p);
    }
    const { forwardRef: s, currentElement: i } = j(), u = I(), d = A(() => n.viewport.value);
    function c() {
      if (!u.value) {
        const p = iq(d.value, a.onThumbPositionChange);
        u.value = p, a.onThumbPositionChange();
      }
    }
    const f = A(() => a.sizes.value);
    return N0(f, () => {
      a.onThumbChange(i.value), d.value && (a.onThumbPositionChange(), d.value.addEventListener("scroll", c));
    }), nt(() => {
      d.value.removeEventListener("scroll", c), n.viewport.value?.removeEventListener("scroll", c);
    }), (p, v) => (h(), w(l(X), {
      ref: l(s),
      "data-state": l(a).hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--reka-scroll-area-thumb-width)",
        height: "var(--reka-scroll-area-thumb-height)"
      },
      "as-child": t.asChild,
      as: p.as,
      onPointerdown: r,
      onPointerup: o
    }, {
      default: g(() => [_(p.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "as-child",
      "as"
    ]));
  }
}), Pq = kq, Mq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e, { expose: t }) {
    const n = e, { nonce: a } = qe(n), r = Mi(a), o = mn(), s = I();
    Ce(() => {
      o.onViewportChange(s.value), o.onContentChange(u.value);
    }), t({ viewportElement: s });
    const { forwardRef: i, currentElement: u } = j();
    return (d, c) => (h(), G(Ge, null, [we("div", T({
      ref_key: "viewportElement",
      ref: s,
      "data-reka-scroll-area-viewport": "",
      style: {
        overflowX: l(o).scrollbarXEnabled.value ? "scroll" : "hidden",
        overflowY: l(o).scrollbarYEnabled.value ? "scroll" : "hidden"
      }
    }, d.$attrs, { tabindex: 0 }), [N(l(X), {
      ref: l(i),
      style: dt({ minWidth: l(o).scrollbarXEnabled.value ? "fit-content" : void 0 }),
      "as-child": n.asChild,
      as: d.as
    }, {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "style",
      "as-child",
      "as"
    ])], 16), N(l(X), {
      as: "style",
      nonce: l(r)
    }, {
      default: g(() => c[0] || (c[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), Dq = Mq;
const qq = [
  " ",
  "Enter",
  "ArrowUp",
  "ArrowDown"
], Aq = [" ", "Enter"], Cn = 10;
function Fo(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => bd(a, t, n)) : bd(e, t, n);
}
function bd(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : Dn(e, t);
}
function Eq(e) {
  return e == null || e === "" || Array.isArray(e) && e.length === 0;
}
const Tq = {
  key: 0,
  value: ""
}, [Va, Ig] = Se("SelectRoot");
var Iq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectRoot",
  props: {
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1,
      default: void 0
    },
    by: {
      type: [String, Function],
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    autocomplete: {
      type: String,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { required: r, disabled: o, multiple: s, dir: i } = qe(n), u = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? (s.value ? [] : void 0),
      passive: n.modelValue === void 0,
      deep: !0
    }), d = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), c = I(), f = I(), p = I({
      x: 0,
      y: 0
    }), v = A(() => s.value && Array.isArray(u.value) ? u.value?.length === 0 : Pn(u.value));
    st({ isProvider: !0 });
    const m = gt(i), y = In(c), x = I(/* @__PURE__ */ new Set()), C = A(() => Array.from(x.value).map((k) => k.value).join(";"));
    function S(k) {
      if (s.value) {
        const B = Array.isArray(u.value) ? [...u.value] : [], P = B.findIndex((M) => bd(M, k, n.by));
        P === -1 ? B.push(k) : B.splice(P, 1), u.value = [...B];
      } else u.value = k;
    }
    function $(k) {
      return Array.from(x.value).find((B) => Fo(k, B.value, n.by));
    }
    return Ig({
      triggerElement: c,
      onTriggerChange: (k) => {
        c.value = k;
      },
      valueElement: f,
      onValueElementChange: (k) => {
        f.value = k;
      },
      contentId: "",
      modelValue: u,
      onValueChange: S,
      by: n.by,
      open: d,
      multiple: s,
      required: r,
      onOpenChange: (k) => {
        d.value = k;
      },
      dir: m,
      triggerPointerDownPosRef: p,
      disabled: o,
      isEmptyModelValue: v,
      optionsSet: x,
      onOptionAdd: (k) => {
        const B = $(k.value);
        B && x.value.delete(B), x.value.add(k);
      },
      onOptionRemove: (k) => {
        const B = $(k.value);
        B && x.value.delete(B);
      }
    }), (k, B) => (h(), w(l(or), null, {
      default: g(() => [_(k.$slots, "default", {
        modelValue: l(u),
        open: l(d)
      }), l(y) ? (h(), w(Vq, {
        key: C.value,
        "aria-hidden": "true",
        tabindex: "-1",
        multiple: l(s),
        required: l(r),
        name: k.name,
        autocomplete: k.autocomplete,
        disabled: l(o),
        value: l(u)
      }, {
        default: g(() => [l(Pn)(l(u)) ? (h(), G("option", Tq)) : De("v-if", !0), (h(!0), G(Ge, null, Et(Array.from(x.value), (P) => (h(), G("option", T({ key: P.value ?? "" }, { ref_for: !0 }, P), null, 16))), 128))]),
        _: 1
      }, 8, [
        "multiple",
        "required",
        "name",
        "autocomplete",
        "disabled",
        "value"
      ])) : De("v-if", !0)]),
      _: 3
    }));
  }
}), Oq = Iq, Rq = /* @__PURE__ */ b({
  __name: "BubbleSelect",
  props: {
    autocomplete: {
      type: String,
      required: !1
    },
    autofocus: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    form: {
      type: String,
      required: !1
    },
    multiple: {
      type: Boolean,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    size: {
      type: Number,
      required: !1
    },
    value: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = I(), a = Va();
    me(() => t.value, (o, s) => {
      const i = window.HTMLSelectElement.prototype, d = Object.getOwnPropertyDescriptor(i, "value").set;
      if (o !== s && d && n.value) {
        const c = new Event("change", { bubbles: !0 });
        d.call(n.value, o), n.value.dispatchEvent(c);
      }
    });
    function r(o) {
      a.onValueChange(o.target.value);
    }
    return (o, s) => (h(), w(l(Ci), { "as-child": "" }, {
      default: g(() => [we("select", T({
        ref_key: "selectElement",
        ref: n
      }, t, { onInput: r }), [_(o.$slots, "default")], 16)]),
      _: 3
    }));
  }
}), Vq = Rq, Fq = /* @__PURE__ */ b({
  __name: "SelectPopperPosition",
  props: {
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: Cn
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), w(l(Kr), T(l(n), { style: {
      boxSizing: "border-box",
      "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-select-content-available-width": "var(--reka-popper-available-width)",
      "--reka-select-content-available-height": "var(--reka-popper-available-height)",
      "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
    } }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Nq = Fq;
const Lq = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [dr, Og] = Se("SelectContent");
var zq = /* @__PURE__ */ b({
  __name: "SelectContentImpl",
  props: {
    position: {
      type: String,
      required: !1,
      default: "item-aligned"
    },
    bodyLock: {
      type: Boolean,
      required: !1,
      default: !0
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Va();
    mi(), os(n.bodyLock);
    const { CollectionSlot: o, getItems: s } = st(), i = I();
    ls(i);
    const { search: u, handleTypeaheadSearch: d } = hi(), c = I(), f = I(), p = I(), v = I(!1), m = I(!1), y = I(!1);
    function x() {
      f.value && i.value && dd([f.value, i.value]);
    }
    me(v, () => {
      x();
    });
    const { onOpenChange: C, triggerPointerDownPosRef: S } = r;
    Te((P) => {
      if (!i.value) return;
      let M = {
        x: 0,
        y: 0
      };
      const q = (D) => {
        M = {
          x: Math.abs(Math.round(D.pageX) - (S.value?.x ?? 0)),
          y: Math.abs(Math.round(D.pageY) - (S.value?.y ?? 0))
        };
      }, E = (D) => {
        D.pointerType !== "touch" && (M.x <= 10 && M.y <= 10 ? D.preventDefault() : i.value?.contains(D.target) || C(!1), document.removeEventListener("pointermove", q), S.value = null);
      };
      S.value !== null && (document.addEventListener("pointermove", q), document.addEventListener("pointerup", E, {
        capture: !0,
        once: !0
      })), P(() => {
        document.removeEventListener("pointermove", q), document.removeEventListener("pointerup", E, { capture: !0 });
      });
    });
    function $(P) {
      const M = P.ctrlKey || P.altKey || P.metaKey;
      if (P.key === "Tab" && P.preventDefault(), !M && P.key.length === 1 && d(P.key, s()), [
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End"
      ].includes(P.key)) {
        let E = [...s().map((D) => D.ref)];
        if (["ArrowUp", "End"].includes(P.key) && (E = E.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(P.key)) {
          const D = P.target, O = E.indexOf(D);
          E = E.slice(O + 1);
        }
        setTimeout(() => dd(E)), P.preventDefault();
      }
    }
    const k = A(() => n.position === "popper" ? n : {}), B = he(k.value);
    return Og({
      content: i,
      viewport: c,
      onViewportChange: (P) => {
        c.value = P;
      },
      itemRefCallback: (P, M, q) => {
        const E = !m.value && !q, D = Fo(r.modelValue.value, M, r.by);
        if (r.multiple.value) {
          if (y.value) return;
          (D || E) && (f.value = P, D && (y.value = !0));
        } else (D || E) && (f.value = P);
        E && (m.value = !0);
      },
      selectedItem: f,
      selectedItemText: p,
      onItemLeave: () => {
        i.value?.focus();
      },
      itemTextRefCallback: (P, M, q) => {
        const E = !m.value && !q;
        (Fo(r.modelValue.value, M, r.by) || E) && (p.value = P);
      },
      focusSelectedItem: x,
      position: n.position,
      isPositioned: v,
      searchRef: u
    }), (P, M) => (h(), w(l(o), null, {
      default: g(() => [N(l(us), {
        "as-child": "",
        onMountAutoFocus: M[6] || (M[6] = Ye(() => {
        }, ["prevent"])),
        onUnmountAutoFocus: M[7] || (M[7] = (q) => {
          a("closeAutoFocus", q), !q.defaultPrevented && (l(r).triggerElement.value?.focus({ preventScroll: !0 }), q.preventDefault());
        })
      }, {
        default: g(() => [N(l(Oa), {
          "as-child": "",
          "disable-outside-pointer-events": P.disableOutsidePointerEvents,
          onFocusOutside: M[2] || (M[2] = Ye(() => {
          }, ["prevent"])),
          onDismiss: M[3] || (M[3] = (q) => l(r).onOpenChange(!1)),
          onEscapeKeyDown: M[4] || (M[4] = (q) => a("escapeKeyDown", q)),
          onPointerDownOutside: M[5] || (M[5] = (q) => a("pointerDownOutside", q))
        }, {
          default: g(() => [(h(), w(Pt(P.position === "popper" ? Nq : Wq), T({
            ...P.$attrs,
            ...l(B)
          }, {
            id: l(r).contentId,
            ref: (q) => {
              const E = l(jt)(q);
              E?.hasAttribute("data-reka-popper-content-wrapper") ? i.value = E.firstElementChild : i.value = E;
            },
            role: "listbox",
            "data-state": l(r).open.value ? "open" : "closed",
            dir: l(r).dir.value,
            style: {
              display: "flex",
              flexDirection: "column",
              outline: "none"
            },
            onContextmenu: M[0] || (M[0] = Ye(() => {
            }, ["prevent"])),
            onPlaced: M[1] || (M[1] = (q) => v.value = !0),
            onKeydown: $
          }), {
            default: g(() => [_(P.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "data-state",
            "dir",
            "onKeydown"
          ]))]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      })]),
      _: 3
    }));
  }
}), Hq = zq;
const [Yc, Uq] = Se("SelectItemAlignedPosition");
var jq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, { getItems: r } = st(), o = Va(), s = dr(), i = I(!1), u = I(!0), d = I(), { forwardRef: c, currentElement: f } = j(), { viewport: p, selectedItem: v, selectedItemText: m, focusSelectedItem: y } = s;
    function x() {
      if (o.triggerElement.value && o.valueElement.value && d.value && f.value && p?.value && v?.value && m?.value) {
        const $ = o.triggerElement.value.getBoundingClientRect(), k = f.value.getBoundingClientRect(), B = o.valueElement.value.getBoundingClientRect(), P = m.value.getBoundingClientRect();
        if (o.dir.value !== "rtl") {
          const V = P.left - k.left, te = B.left - V, z = $.left - te, re = $.width + z, ie = Math.max(re, k.width), L = window.innerWidth - Cn, be = Ar(te, Cn, Math.max(Cn, L - ie));
          d.value.style.minWidth = `${re}px`, d.value.style.left = `${be}px`;
        } else {
          const V = k.right - P.right, te = window.innerWidth - B.right - V, z = window.innerWidth - $.right - te, re = $.width + z, ie = Math.max(re, k.width), L = window.innerWidth - Cn, be = Ar(te, Cn, Math.max(Cn, L - ie));
          d.value.style.minWidth = `${re}px`, d.value.style.right = `${be}px`;
        }
        const M = r().map((V) => V.ref), q = window.innerHeight - Cn * 2, E = p.value.scrollHeight, D = window.getComputedStyle(f.value), O = Number.parseInt(D.borderTopWidth, 10), F = Number.parseInt(D.paddingTop, 10), J = Number.parseInt(D.borderBottomWidth, 10), ne = Number.parseInt(D.paddingBottom, 10), Q = O + F + E + ne + J, W = Math.min(v.value.offsetHeight * 5, Q), H = window.getComputedStyle(p.value), U = Number.parseInt(H.paddingTop, 10), se = Number.parseInt(H.paddingBottom, 10), ee = $.top + $.height / 2 - Cn, de = q - ee, fe = v.value.offsetHeight / 2, _e = v.value.offsetTop + fe, ye = O + F + _e, Ee = Q - ye;
        if (ye <= ee) {
          const V = v.value === M[M.length - 1];
          d.value.style.bottom = "0px";
          const te = f.value.clientHeight - p.value.offsetTop - p.value.offsetHeight, z = Math.max(de, fe + (V ? se : 0) + te + J), re = ye + z;
          d.value.style.height = `${re}px`;
        } else {
          const V = v.value === M[0];
          d.value.style.top = "0px";
          const z = Math.max(ee, O + p.value.offsetTop + (V ? U : 0) + fe) + Ee;
          d.value.style.height = `${z}px`, p.value.scrollTop = ye - ee + p.value.offsetTop;
        }
        d.value.style.margin = `${Cn}px 0`, d.value.style.minHeight = `${W}px`, d.value.style.maxHeight = `${q}px`, a("placed"), requestAnimationFrame(() => i.value = !0);
      }
    }
    const C = I("");
    Ce(async () => {
      await Pe(), x(), f.value && (C.value = window.getComputedStyle(f.value).zIndex);
    });
    function S($) {
      $ && u.value === !0 && (x(), y?.(), u.value = !1);
    }
    return qn(o.triggerElement, () => {
      x();
    }), Uq({
      contentWrapper: d,
      shouldExpandOnScrollRef: i,
      onScrollButtonChange: S
    }), ($, k) => (h(), G("div", {
      ref_key: "contentWrapperElement",
      ref: d,
      style: dt({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: C.value
      })
    }, [N(l(X), T({
      ref: l(c),
      style: {
        boxSizing: "border-box",
        maxHeight: "100%"
      }
    }, {
      ...$.$attrs,
      ...n
    }), {
      default: g(() => [_($.$slots, "default")]),
      _: 3
    }, 16)], 4));
  }
}), Wq = jq, Gq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectProvider",
  props: { context: {
    type: Object,
    required: !0
  } },
  setup(e) {
    return Ig(e.context), Og(Lq), (n, a) => _(n.$slots, "default");
  }
}), Kq = Gq;
const Yq = { key: 1 };
var Xq = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    position: {
      type: String,
      required: !1
    },
    bodyLock: {
      type: Boolean,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    sideFlip: {
      type: Boolean,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    alignFlip: {
      type: Boolean,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    hideShiftedArrow: {
      type: Boolean,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: !1
    },
    prioritizePosition: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(e, { emit: t }) {
    const n = e, r = ve(n, t), o = Va(), s = I();
    Ce(() => {
      s.value = new DocumentFragment();
    });
    const i = I(), u = A(() => n.forceMount || o.open.value), d = I(u.value);
    return me(u, () => {
      setTimeout(() => d.value = u.value);
    }), (c, f) => u.value || d.value || i.value?.present ? (h(), w(l(yt), {
      key: 0,
      ref_key: "presenceRef",
      ref: i,
      present: u.value
    }, {
      default: g(() => [N(Hq, oe(le({
        ...l(r),
        ...c.$attrs
      })), {
        default: g(() => [_(c.$slots, "default")]),
        _: 3
      }, 16)]),
      _: 3
    }, 8, ["present"])) : s.value ? (h(), G("div", Yq, [(h(), w(ci, { to: s.value }, [N(Kq, { context: l(o) }, {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }, 8, ["context"])], 8, ["to"]))])) : De("v-if", !0);
  }
}), Jq = Xq;
const [Zq, Qq] = Se("SelectGroup");
var eA = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Ke(void 0, "reka-select-group");
    return Qq({ id: n }), (a, r) => (h(), w(l(X), T({ role: "group" }, t, { "aria-labelledby": l(n) }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), tA = eA, nA = /* @__PURE__ */ b({
  __name: "SelectIcon",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    return (t, n) => (h(), w(l(X), {
      "aria-hidden": "true",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: g(() => [_(t.$slots, "default", {}, () => [n[0] || (n[0] = Re(""))])]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), aA = nA;
const [Rg, rA] = Se("SelectItem");
var oA = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    textValue: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = qe(n), o = Va(), s = dr(), { forwardRef: i, currentElement: u } = j(), { CollectionItem: d } = st(), c = A(() => Fo(o.modelValue?.value, n.value, o.by)), f = I(!1), p = I(n.textValue ?? ""), v = Ke(void 0, "reka-select-item-text"), m = "select.select";
    async function y(k) {
      if (k.defaultPrevented) return;
      const B = {
        originalEvent: k,
        value: n.value
      };
      ns(m, x, B);
    }
    async function x(k) {
      await Pe(), a("select", k), !k.defaultPrevented && (r.value || (o.onValueChange(n.value), o.multiple.value || o.onOpenChange(!1)));
    }
    async function C(k) {
      await Pe(), !k.defaultPrevented && (r.value ? s.onItemLeave?.() : k.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function S(k) {
      await Pe(), !k.defaultPrevented && k.currentTarget === rt() && s.onItemLeave?.();
    }
    async function $(k) {
      await Pe(), !(k.defaultPrevented || s.searchRef?.value !== "" && k.key === " ") && (Aq.includes(k.key) && y(k), k.key === " " && k.preventDefault());
    }
    if (n.value === "") throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    return Ce(() => {
      u.value && s.itemRefCallback(u.value, n.value, n.disabled);
    }), rA({
      value: n.value,
      disabled: r,
      textId: v,
      isSelected: c,
      onItemTextChange: (k) => {
        p.value = ((p.value || k?.textContent) ?? "").trim();
      }
    }), (k, B) => (h(), w(l(d), { value: { textValue: p.value } }, {
      default: g(() => [N(l(X), {
        ref: l(i),
        role: "option",
        "aria-labelledby": l(v),
        "data-highlighted": f.value ? "" : void 0,
        "aria-selected": c.value,
        "data-state": c.value ? "checked" : "unchecked",
        "aria-disabled": l(r) || void 0,
        "data-disabled": l(r) ? "" : void 0,
        tabindex: l(r) ? void 0 : -1,
        as: k.as,
        "as-child": k.asChild,
        onFocus: B[0] || (B[0] = (P) => f.value = !0),
        onBlur: B[1] || (B[1] = (P) => f.value = !1),
        onPointerup: y,
        onPointerdown: B[2] || (B[2] = (P) => {
          P.currentTarget.focus({ preventScroll: !0 });
        }),
        onTouchend: B[3] || (B[3] = Ye(() => {
        }, ["prevent", "stop"])),
        onPointermove: C,
        onPointerleave: S,
        onKeydown: $
      }, {
        default: g(() => [_(k.$slots, "default")]),
        _: 3
      }, 8, [
        "aria-labelledby",
        "data-highlighted",
        "aria-selected",
        "data-state",
        "aria-disabled",
        "data-disabled",
        "tabindex",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), sA = oA, lA = /* @__PURE__ */ b({
  __name: "SelectItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Rg();
    return (a, r) => l(n).isSelected.value ? (h(), w(l(X), T({
      key: 0,
      "aria-hidden": "true"
    }, t), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16)) : De("v-if", !0);
  }
}), iA = lA, uA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = Va(), a = dr(), r = Rg(), { forwardRef: o, currentElement: s } = j(), i = A(() => ({
      value: r.value,
      disabled: r.disabled.value,
      textContent: s.value?.textContent ?? r.value?.toString() ?? ""
    }));
    return Ce(() => {
      s.value && (r.onItemTextChange(s.value), a.itemTextRefCallback(s.value, r.value, r.disabled.value), n.onOptionAdd(i.value));
    }), nt(() => {
      n.onOptionRemove(i.value);
    }), (u, d) => (h(), w(l(X), T({
      id: l(r).textId,
      ref: l(o)
    }, {
      ...t,
      ...u.$attrs
    }), {
      default: g(() => [_(u.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), Vg = uA, dA = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "div"
    }
  },
  setup(e) {
    const t = e, n = Zq({ id: "" });
    return (a, r) => (h(), w(l(X), T(t, { id: l(n).id }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), cA = dA, fA = /* @__PURE__ */ b({
  __name: "SelectPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), pA = fA, vA = /* @__PURE__ */ b({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(e, { emit: t }) {
    const n = t, { getItems: a } = st(), r = dr(), o = I(null);
    function s() {
      o.value !== null && (window.clearInterval(o.value), o.value = null);
    }
    Te(() => {
      a().map((c) => c.ref).find((c) => c === rt())?.scrollIntoView({ block: "nearest" });
    });
    function i() {
      o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    function u() {
      r.onItemLeave?.(), o.value === null && (o.value = window.setInterval(() => {
        n("autoScroll");
      }, 50));
    }
    return Ea(() => s()), (d, c) => (h(), w(l(X), T({
      "aria-hidden": "true",
      style: { flexShrink: 0 }
    }, d.$parent?.$props, {
      onPointerdown: i,
      onPointermove: u,
      onPointerleave: c[0] || (c[0] = () => {
        s();
      })
    }), {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Fg = vA, mA = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = dr(), n = t.position === "item-aligned" ? Yc() : void 0, { forwardRef: a, currentElement: r } = j(), o = I(!1);
    return Te((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          const d = i.scrollHeight - i.clientHeight;
          o.value = Math.ceil(i.scrollTop) < d;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), me(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), w(Fg, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : De("v-if", !0);
  }
}), hA = mA, gA = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = dr(), n = t.position === "item-aligned" ? Yc() : void 0, { forwardRef: a, currentElement: r } = j(), o = I(!1);
    return Te((s) => {
      if (t.viewport?.value && t.isPositioned?.value) {
        let u = function() {
          o.value = i.scrollTop > 0;
        };
        const i = t.viewport.value;
        u(), i.addEventListener("scroll", u), s(() => i.removeEventListener("scroll", u));
      }
    }), me(r, () => {
      r.value && n?.onScrollButtonChange(r.value);
    }), (s, i) => o.value ? (h(), w(Fg, {
      key: 0,
      ref: l(a),
      onAutoScroll: i[0] || (i[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u?.value && d?.value && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 512)) : De("v-if", !0);
  }
}), yA = gA, bA = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), T({ "aria-hidden": "true" }, t), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), _A = bA, wA = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: !1
    },
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Va(), { forwardRef: a, currentElement: r } = j(), o = A(() => n.disabled?.value || t.disabled);
    n.contentId ||= Ke(void 0, "reka-select-content"), Ce(() => {
      n.onTriggerChange(r.value);
    });
    const { getItems: s } = st(), { search: i, handleTypeaheadSearch: u, resetTypeahead: d } = hi();
    function c() {
      o.value || (n.onOpenChange(!0), d());
    }
    function f(p) {
      c(), n.triggerPointerDownPosRef.value = {
        x: Math.round(p.pageX),
        y: Math.round(p.pageY)
      };
    }
    return (p, v) => (h(), w(l(sr), {
      "as-child": "",
      reference: p.reference
    }, {
      default: g(() => [N(l(X), {
        ref: l(a),
        role: "combobox",
        type: p.as === "button" ? "button" : void 0,
        "aria-controls": l(n).contentId,
        "aria-expanded": l(n).open.value || !1,
        "aria-required": l(n).required?.value,
        "aria-autocomplete": "none",
        disabled: o.value,
        dir: l(n)?.dir.value,
        "data-state": l(n)?.open.value ? "open" : "closed",
        "data-disabled": o.value ? "" : void 0,
        "data-placeholder": l(Eq)(l(n).modelValue?.value) ? "" : void 0,
        "as-child": p.asChild,
        as: p.as,
        onClick: v[0] || (v[0] = (m) => {
          m?.currentTarget?.focus();
        }),
        onPointerdown: v[1] || (v[1] = (m) => {
          if (m.pointerType === "touch") return m.preventDefault();
          const y = m.target;
          y.hasPointerCapture(m.pointerId) && y.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && (f(m), m.preventDefault());
        }),
        onPointerup: v[2] || (v[2] = Ye((m) => {
          m.pointerType === "touch" && f(m);
        }, ["prevent"])),
        onKeydown: v[3] || (v[3] = (m) => {
          const y = l(i) !== "";
          !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && y && m.key === " " || (l(u)(m.key, l(s)()), l(qq).includes(m.key) && (c(), m.preventDefault()));
        })
      }, {
        default: g(() => [_(p.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "aria-controls",
        "aria-expanded",
        "aria-required",
        "disabled",
        "dir",
        "data-state",
        "data-disabled",
        "data-placeholder",
        "as-child",
        "as"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), xA = wA, CA = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {
      type: String,
      required: !1,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = j(), r = Va();
    Ce(() => {
      r.valueElement = a;
    });
    const o = A(() => {
      let i = [];
      const u = Array.from(r.optionsSet.value), d = (c) => u.find((f) => Fo(c, f.value, r.by));
      return Array.isArray(r.modelValue.value) ? i = r.modelValue.value.map((c) => d(c)?.textContent ?? "") : i = [d(r.modelValue.value)?.textContent ?? ""], i.filter(Boolean);
    }), s = A(() => o.value.length ? o.value.join(", ") : t.placeholder);
    return (i, u) => (h(), w(l(X), {
      ref: l(n),
      as: i.as,
      "as-child": i.asChild,
      style: { pointerEvents: "none" },
      "data-placeholder": o.value.length ? void 0 : t.placeholder
    }, {
      default: g(() => [_(i.$slots, "default", {
        selectedLabel: o.value,
        modelValue: l(r).modelValue.value
      }, () => [Re(Fe(s.value), 1)])]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-placeholder"
    ]));
  }
}), SA = CA, $A = /* @__PURE__ */ b({
  __name: "SelectViewport",
  props: {
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { nonce: n } = qe(t), a = Mi(n), r = dr(), o = r.position === "item-aligned" ? Yc() : void 0, { forwardRef: s, currentElement: i } = j();
    Ce(() => {
      r?.onViewportChange(i.value);
    });
    const u = I(0);
    function d(c) {
      const f = c.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: v } = o ?? {};
      if (p?.value && v?.value) {
        const m = Math.abs(u.value - f.scrollTop);
        if (m > 0) {
          const y = window.innerHeight - Cn * 2, x = Number.parseFloat(v.value.style.minHeight), C = Number.parseFloat(v.value.style.height), S = Math.max(x, C);
          if (S < y) {
            const $ = S + m, k = Math.min(y, $), B = $ - k;
            v.value.style.height = `${k}px`, v.value.style.bottom === "0px" && (f.scrollTop = B > 0 ? B : 0, v.value.style.justifyContent = "flex-end");
          }
        }
      }
      u.value = f.scrollTop;
    }
    return (c, f) => (h(), G(Ge, null, [N(l(X), T({
      ref: l(s),
      "data-reka-select-viewport": "",
      role: "presentation"
    }, {
      ...c.$attrs,
      ...t
    }, {
      style: {
        position: "relative",
        flex: 1,
        overflow: "hidden auto"
      },
      onScroll: d
    }), {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }, 16), N(l(X), {
      as: "style",
      nonce: l(a)
    }, {
      default: g(() => f[0] || (f[0] = [Re(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")])),
      _: 1,
      __: [0]
    }, 8, ["nonce"])], 64));
  }
}), BA = $A, kA = /* @__PURE__ */ b({
  __name: "BaseSeparator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ["horizontal", "vertical"];
    function a(i) {
      return n.includes(i);
    }
    const r = A(() => a(t.orientation) ? t.orientation : "horizontal"), o = A(() => r.value === "vertical" ? t.orientation : void 0), s = A(() => t.decorative ? { role: "none" } : {
      "aria-orientation": o.value,
      role: "separator"
    });
    return (i, u) => (h(), w(l(X), T({
      as: i.as,
      "as-child": i.asChild,
      "data-orientation": r.value
    }, s.value), {
      default: g(() => [_(i.$slots, "default")]),
      _: 3
    }, 16, [
      "as",
      "as-child",
      "data-orientation"
    ]));
  }
}), PA = kA, MA = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(PA, oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Xc = MA;
function DA(e = [], t, n) {
  const a = [...e];
  return a[n] = t, a.sort((r, o) => r - o);
}
function Ng(e, t, n) {
  const o = 100 / (n - t) * (e - t);
  return Ar(o, 0, 100);
}
function qA(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function AA(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((r) => Math.abs(r - t)), a = Math.min(...n);
  return n.indexOf(a);
}
function EA(e, t, n) {
  const a = e / 2, o = Jc([0, 50], [0, a]);
  return (a - o(t) * n) * n;
}
function TA(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function IA(e, t) {
  if (t > 0) {
    const n = TA(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Jc(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function OA(e) {
  return (String(e).split(".")[1] || "").length;
}
function RA(e, t) {
  const n = 10 ** t;
  return Math.round(e * n) / n;
}
const Lg = ["PageUp", "PageDown"], zg = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
], Hg = {
  "from-left": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-right": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowRight"
  ],
  "from-bottom": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-top": [
    "Home",
    "PageUp",
    "ArrowUp",
    "ArrowLeft"
  ]
}, [Ug, jg] = Se(["SliderVertical", "SliderHorizontal"]);
var VA = /* @__PURE__ */ b({
  __name: "SliderHorizontal",
  props: {
    dir: {
      type: String,
      required: !1
    },
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, dir: s, inverted: i } = qe(n), { forwardRef: u, currentElement: d } = j(), c = Zr(), f = I(), p = I(), v = A(() => s?.value !== "rtl" && !i.value || s?.value !== "ltr" && i.value);
    function m(S, $) {
      const k = p.value || d.value.getBoundingClientRect(), B = [...c.thumbElements.value][c.valueIndexToChangeRef.value], P = c.thumbAlignment.value === "contain" ? B.clientWidth : 0;
      !f.value && !$ && c.thumbAlignment.value === "contain" && (f.value = S.clientX - B.getBoundingClientRect().left);
      const M = [0, k.width - P], q = v.value ? [o.value, r.value] : [r.value, o.value], E = Jc(M, q);
      p.value = k;
      const D = $ ? S.clientX - k.left - P / 2 : S.clientX - k.left - (f.value ?? 0);
      return E(D);
    }
    const y = A(() => v.value ? "left" : "right"), x = A(() => v.value ? "right" : "left"), C = A(() => v.value ? 1 : -1);
    return jg({
      startEdge: y,
      endEdge: x,
      direction: C,
      size: "width"
    }), (S, $) => (h(), w(Wg, {
      ref: l(u),
      dir: l(s),
      "data-orientation": "horizontal",
      style: dt({ "--reka-slider-thumb-transform": !v.value && l(c).thumbAlignment.value === "overflow" ? "translateX(50%)" : "translateX(-50%)" }),
      onSlideStart: $[0] || ($[0] = (k) => {
        const B = m(k, !0);
        a("slideStart", B);
      }),
      onSlideMove: $[1] || ($[1] = (k) => {
        const B = m(k);
        a("slideMove", B);
      }),
      onSlideEnd: $[2] || ($[2] = () => {
        p.value = void 0, f.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: $[3] || ($[3] = (k) => {
        const B = v.value ? "from-left" : "from-right", P = l(Hg)[B].includes(k.key);
        a("stepKeyDown", k, P ? -1 : 1);
      }),
      onEndKeyDown: $[4] || ($[4] = (k) => a("endKeyDown", k)),
      onHomeKeyDown: $[5] || ($[5] = (k) => a("homeKeyDown", k))
    }, {
      default: g(() => [_(S.$slots, "default")]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), FA = VA, NA = /* @__PURE__ */ b({
  __name: "SliderVertical",
  props: {
    min: {
      type: Number,
      required: !0
    },
    max: {
      type: Number,
      required: !0
    },
    inverted: {
      type: Boolean,
      required: !0
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: r, min: o, inverted: s } = qe(n), i = Zr(), { forwardRef: u, currentElement: d } = j(), c = I(), f = I(), p = A(() => !s.value);
    function v(C, S) {
      const $ = f.value || d.value.getBoundingClientRect(), k = [...i.thumbElements.value][i.valueIndexToChangeRef.value], B = i.thumbAlignment.value === "contain" ? k.clientHeight : 0;
      !c.value && !S && i.thumbAlignment.value === "contain" && (c.value = C.clientY - k.getBoundingClientRect().top);
      const P = [0, $.height - B], M = p.value ? [r.value, o.value] : [o.value, r.value], q = Jc(P, M), E = S ? C.clientY - $.top - B / 2 : C.clientY - $.top - (c.value ?? 0);
      return f.value = $, q(E);
    }
    const m = A(() => p.value ? "bottom" : "top"), y = A(() => p.value ? "top" : "bottom"), x = A(() => p.value ? 1 : -1);
    return jg({
      startEdge: m,
      endEdge: y,
      direction: x,
      size: "height"
    }), (C, S) => (h(), w(Wg, {
      ref: l(u),
      "data-orientation": "vertical",
      style: dt({ "--reka-slider-thumb-transform": !p.value && l(i).thumbAlignment.value === "overflow" ? "translateY(-50%)" : "translateY(50%)" }),
      onSlideStart: S[0] || (S[0] = ($) => {
        const k = v($, !0);
        a("slideStart", k);
      }),
      onSlideMove: S[1] || (S[1] = ($) => {
        const k = v($);
        a("slideMove", k);
      }),
      onSlideEnd: S[2] || (S[2] = () => {
        f.value = void 0, c.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: S[3] || (S[3] = ($) => {
        const k = p.value ? "from-bottom" : "from-top", B = l(Hg)[k].includes($.key);
        a("stepKeyDown", $, B ? -1 : 1);
      }),
      onEndKeyDown: S[4] || (S[4] = ($) => a("endKeyDown", $)),
      onHomeKeyDown: S[5] || (S[5] = ($) => a("homeKeyDown", $))
    }, {
      default: g(() => [_(C.$slots, "default")]),
      _: 3
    }, 8, ["style"]));
  }
}), LA = NA;
const [Zr, zA] = Se("SliderRoot");
var HA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    defaultValue: {
      type: Array,
      required: !1,
      default: () => [0]
    },
    modelValue: {
      type: [Array, null],
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    inverted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    min: {
      type: Number,
      required: !1,
      default: 0
    },
    max: {
      type: Number,
      required: !1,
      default: 100
    },
    step: {
      type: Number,
      required: !1,
      default: 1
    },
    minStepsBetweenThumbs: {
      type: Number,
      required: !1,
      default: 0
    },
    thumbAlignment: {
      type: String,
      required: !1,
      default: "contain"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, { min: r, max: o, step: s, minStepsBetweenThumbs: i, orientation: u, disabled: d, thumbAlignment: c, dir: f } = qe(n), p = gt(f), { forwardRef: v, currentElement: m } = j(), y = In(m), { CollectionSlot: x } = st({ isProvider: !0 }), C = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), S = A(() => Array.isArray(C.value) ? [...C.value] : []), $ = I(0), k = I(S.value);
    function B(D) {
      const O = AA(S.value, D);
      q(D, O);
    }
    function P(D) {
      q(D, $.value);
    }
    function M() {
      const D = k.value[$.value];
      S.value[$.value] !== D && a("valueCommit", l0(S.value));
    }
    function q(D, O, { commit: F } = { commit: !1 }) {
      const J = OA(s.value), ne = RA(Math.round((D - r.value) / s.value) * s.value + r.value, J), Q = Ar(ne, r.value, o.value), W = DA(S.value, Q, O);
      if (IA(W, i.value * s.value)) {
        $.value = W.indexOf(Q);
        const H = String(W) !== String(C.value);
        H && F && a("valueCommit", W), H && (E.value[$.value]?.focus(), C.value = W);
      }
    }
    const E = I([]);
    return zA({
      modelValue: C,
      currentModelValue: S,
      valueIndexToChangeRef: $,
      thumbElements: E,
      orientation: u,
      min: r,
      max: o,
      disabled: d,
      thumbAlignment: c
    }), (D, O) => (h(), w(l(x), null, {
      default: g(() => [(h(), w(Pt(l(u) === "horizontal" ? FA : LA), T(D.$attrs, {
        ref: l(v),
        "as-child": D.asChild,
        as: D.as,
        min: l(r),
        max: l(o),
        dir: l(p),
        inverted: D.inverted,
        "aria-disabled": l(d),
        "data-disabled": l(d) ? "" : void 0,
        onPointerdown: O[0] || (O[0] = () => {
          l(d) || (k.value = S.value);
        }),
        onSlideStart: O[1] || (O[1] = (F) => !l(d) && B(F)),
        onSlideMove: O[2] || (O[2] = (F) => !l(d) && P(F)),
        onSlideEnd: O[3] || (O[3] = (F) => !l(d) && M()),
        onHomeKeyDown: O[4] || (O[4] = (F) => !l(d) && q(l(r), 0, { commit: !0 })),
        onEndKeyDown: O[5] || (O[5] = (F) => !l(d) && q(l(o), S.value.length - 1, { commit: !0 })),
        onStepKeyDown: O[6] || (O[6] = (F, J) => {
          if (!l(d)) {
            const W = l(Lg).includes(F.key) || F.shiftKey && l(zg).includes(F.key) ? 10 : 1, H = $.value, U = S.value[H], se = l(s) * W * J;
            q(U + se, H, { commit: !0 });
          }
        })
      }), {
        default: g(() => [_(D.$slots, "default", { modelValue: l(C) }), l(y) && D.name ? (h(), w(l(On), {
          key: 0,
          type: "number",
          value: l(C),
          name: D.name,
          required: D.required,
          disabled: l(d),
          step: l(s)
        }, null, 8, [
          "value",
          "name",
          "required",
          "disabled",
          "step"
        ])) : De("v-if", !0)]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "min",
        "max",
        "dir",
        "inverted",
        "aria-disabled",
        "data-disabled"
      ]))]),
      _: 3
    }));
  }
}), UA = HA, jA = /* @__PURE__ */ b({
  __name: "SliderImpl",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  emits: [
    "slideStart",
    "slideMove",
    "slideEnd",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Zr();
    return (o, s) => (h(), w(l(X), T({ "data-slider-impl": "" }, n, {
      onKeydown: s[0] || (s[0] = (i) => {
        i.key === "Home" ? (a("homeKeyDown", i), i.preventDefault()) : i.key === "End" ? (a("endKeyDown", i), i.preventDefault()) : l(Lg).concat(l(zg)).includes(i.key) && (a("stepKeyDown", i), i.preventDefault());
      }),
      onPointerdown: s[1] || (s[1] = (i) => {
        const u = i.target;
        u.setPointerCapture(i.pointerId), i.preventDefault(), l(r).thumbElements.value.includes(u) ? u.focus() : a("slideStart", i);
      }),
      onPointermove: s[2] || (s[2] = (i) => {
        i.target.hasPointerCapture(i.pointerId) && a("slideMove", i);
      }),
      onPointerup: s[3] || (s[3] = (i) => {
        const u = i.target;
        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), a("slideEnd", i));
      })
    }), {
      default: g(() => [_(o.$slots, "default")]),
      _: 3
    }, 16));
  }
}), Wg = jA, WA = /* @__PURE__ */ b({
  __name: "SliderRange",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = Zr(), n = Ug();
    j();
    const a = A(() => t.currentModelValue.value.map((s) => Ng(s, t.min.value, t.max.value))), r = A(() => t.currentModelValue.value.length > 1 ? Math.min(...a.value) : 0), o = A(() => 100 - Math.max(...a.value, 0));
    return (s, i) => (h(), w(l(X), {
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      "as-child": s.asChild,
      as: s.as,
      style: dt({
        [l(n).startEdge.value]: `${r.value}%`,
        [l(n).endEdge.value]: `${o.value}%`
      })
    }, {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 8, [
      "data-disabled",
      "data-orientation",
      "as-child",
      "as",
      "style"
    ]));
  }
}), GA = WA, KA = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {
      type: Number,
      required: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = Zr(), a = Ug(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = A(() => n.modelValue?.value?.[t.index]), u = A(() => i.value === void 0 ? 0 : Ng(i.value, n.min.value ?? 0, n.max.value ?? 100)), d = A(() => qA(t.index, n.modelValue?.value?.length ?? 0)), c = Ih(o), f = A(() => c[a.size].value), p = A(() => n.thumbAlignment.value === "overflow" || !f.value ? 0 : EA(f.value, u.value, a.direction.value)), v = /* @__PURE__ */ ac();
    return Ce(() => {
      n.thumbElements.value.push(o.value);
    }), nt(() => {
      const m = n.thumbElements.value.findIndex((y) => y === o.value) ?? -1;
      n.thumbElements.value.splice(m, 1);
    }), (m, y) => (h(), w(l(s), null, {
      default: g(() => [N(l(X), T(m.$attrs, {
        ref: l(r),
        role: "slider",
        tabindex: l(n).disabled.value ? void 0 : 0,
        "aria-label": m.$attrs["aria-label"] || d.value,
        "data-disabled": l(n).disabled.value ? "" : void 0,
        "data-orientation": l(n).orientation.value,
        "aria-valuenow": i.value,
        "aria-valuemin": l(n).min.value,
        "aria-valuemax": l(n).max.value,
        "aria-orientation": l(n).orientation.value,
        "as-child": m.asChild,
        as: m.as,
        style: {
          transform: "var(--reka-slider-thumb-transform)",
          position: "absolute",
          [l(a).startEdge.value]: `calc(${u.value}% + ${p.value}px)`,
          display: !l(v) && i.value === void 0 ? "none" : void 0
        },
        onFocus: y[0] || (y[0] = () => {
          l(n).valueIndexToChangeRef.value = m.index;
        })
      }), {
        default: g(() => [_(m.$slots, "default")]),
        _: 3
      }, 16, [
        "tabindex",
        "aria-label",
        "data-disabled",
        "data-orientation",
        "aria-valuenow",
        "aria-valuemin",
        "aria-valuemax",
        "aria-orientation",
        "as-child",
        "as",
        "style"
      ])]),
      _: 3
    }));
  }
}), YA = KA, XA = /* @__PURE__ */ b({
  __name: "SliderThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, { getItems: n } = st(), { forwardRef: a, currentElement: r } = j(), o = A(() => r.value ? n(!0).findIndex((s) => s.ref === r.value) : -1);
    return (s, i) => (h(), w(YA, T({ ref: l(a) }, t, { index: o.value }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, ["index"]));
  }
}), JA = XA, ZA = /* @__PURE__ */ b({
  __name: "SliderTrack",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = Zr();
    return j(), (n, a) => (h(), w(l(X), {
      "as-child": n.asChild,
      as: n.as,
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "data-orientation": l(t).orientation.value
    }, {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "as-child",
      "as",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), QA = ZA;
function He(e, t = "Assertion failed!") {
  if (!e)
    throw console.error(t), new Error(t);
}
function Gg(e, t = document) {
  if (!ts) return null;
  if (t instanceof HTMLElement && t?.dataset?.panelGroupId === e) return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function Oi(e, t = document) {
  if (!ts) return null;
  const n = t.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return n || null;
}
function Kg(e, t, n = document) {
  return ts ? No(e, n).findIndex((o) => o.getAttribute("data-panel-resize-handle-id") === t) ?? null : null;
}
function No(e, t = document) {
  return ts ? Array.from(t.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`)) : [];
}
function eE(e, t, n, a = document) {
  const r = Oi(t, a), o = No(e, a), s = r ? o.indexOf(r) : -1, i = n[s]?.id ?? null, u = n[s + 1]?.id ?? null;
  return [i, u];
}
function Yg(e) {
  return e.type === "keydown";
}
function Xg(e) {
  return e.type.startsWith("mouse");
}
function Jg(e) {
  return e.type.startsWith("touch");
}
function Ri(e) {
  if (Xg(e)) return {
    x: e.clientX,
    y: e.clientY
  };
  if (Jg(e)) {
    const t = e.touches[0];
    if (t && t.clientX && t.clientY) return {
      x: t.clientX,
      y: t.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function Zg(e, t) {
  const n = e === "horizontal", { x: a, y: r } = Ri(t);
  return n ? a : r;
}
function tE(e, t, n, a, r) {
  const o = n === "horizontal", s = Oi(t, r);
  He(s);
  const i = s.getAttribute("data-panel-group-id");
  He(i);
  const { initialCursorPosition: u } = a, d = Zg(n, e), c = Gg(i, r);
  He(c);
  const f = c.getBoundingClientRect(), p = o ? f.width : f.height;
  return (d - u) / p * 100;
}
function nE(e, t, n, a, r, o) {
  if (Yg(e)) {
    const s = n === "horizontal";
    let i = 0;
    e.shiftKey ? i = 100 : i = r ?? 10;
    let u = 0;
    switch (e.key) {
      case "ArrowDown":
        u = s ? 0 : i;
        break;
      case "ArrowLeft":
        u = s ? -i : 0;
        break;
      case "ArrowRight":
        u = s ? i : 0;
        break;
      case "ArrowUp":
        u = s ? 0 : -i;
        break;
      case "End":
        u = 100;
        break;
      case "Home":
        u = -100;
        break;
    }
    return u;
  } else
    return a == null ? 0 : tE(e, t, n, a, o);
}
function aE({ layout: e, panelsArray: t, pivotIndices: n }) {
  let a = 0, r = 100, o = 0, s = 0;
  const i = n[0];
  He(i != null), t.forEach((f, p) => {
    const { constraints: v } = f, { maxSize: m = 100, minSize: y = 0 } = v;
    p === i ? (a = y, r = m) : (o += y, s += m);
  });
  const u = Math.min(r, 100 - o), d = Math.max(a, 100 - s), c = e[i];
  return {
    valueMax: u,
    valueMin: d,
    valueNow: c
  };
}
function rE({ panelDataArray: e }) {
  const t = Array.from({ length: e.length }), n = e.map((o) => o.constraints);
  let a = 0, r = 100;
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    He(s);
    const { defaultSize: i } = s;
    i != null && (a++, t[o] = i, r -= i);
  }
  for (let o = 0; o < e.length; o++) {
    const s = n[o];
    He(s);
    const { defaultSize: i } = s;
    if (i != null) continue;
    const u = e.length - a, d = r / u;
    a++, t[o] = d, r -= d;
  }
  return t;
}
function io(e, t, n) {
  t.forEach((a, r) => {
    const o = e[r];
    He(o);
    const { callbacks: s, constraints: i, id: u } = o, { collapsedSize: d = 0, collapsible: c } = i, f = n[u];
    if (f == null || a !== f) {
      n[u] = a;
      const { onCollapse: p, onExpand: v, onResize: m } = s;
      m && m(a, f), c && (p || v) && (v && (f == null || f === d) && a !== d && v(), p && (f == null || f !== d) && a === d && p());
    }
  });
}
function oE(e, t = 10) {
  let n = null;
  return (...r) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...r);
    }, t);
  };
}
const Zc = 10;
function Lo(e, t, n = Zc) {
  e = Number.parseFloat(e.toFixed(n)), t = Number.parseFloat(t.toFixed(n));
  const a = e - t;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function sn(e, t, n) {
  return Lo(e, t, n) === 0;
}
function xr({ panelConstraints: e, panelIndex: t, size: n }) {
  const a = e[t];
  He(a != null);
  const { collapsedSize: r = 0, collapsible: o, maxSize: s = 100, minSize: i = 0 } = a;
  if (Lo(n, i) < 0) if (o) {
    const u = (r + i) / 2;
    Lo(n, u) < 0 ? n = r : n = i;
  } else n = i;
  return n = Math.min(s, n), n = Number.parseFloat(n.toFixed(Zc)), n;
}
function Ls(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function wo({ delta: e, layout: t, panelConstraints: n, pivotIndices: a, trigger: r }) {
  if (sn(e, 0)) return t;
  const o = [...t], [s, i] = a;
  He(s != null), He(i != null);
  let u = 0;
  if (r === "keyboard") {
    {
      const c = e < 0 ? i : s, f = n[c];
      if (He(f), f.collapsible) {
        const p = t[c];
        He(p != null);
        const v = n[c];
        He(v);
        const { collapsedSize: m = 0, minSize: y = 0 } = v;
        if (sn(p, m)) {
          const x = y - p;
          Lo(x, Math.abs(e)) > 0 && (e = e < 0 ? 0 - x : x);
        }
      }
    }
    {
      const c = e < 0 ? s : i, f = n[c];
      He(f);
      const { collapsible: p } = f;
      if (p) {
        const v = t[c];
        He(v != null);
        const m = n[c];
        He(m);
        const { collapsedSize: y = 0, minSize: x = 0 } = m;
        if (sn(v, x)) {
          const C = v - y;
          Lo(C, Math.abs(e)) > 0 && (e = e < 0 ? 0 - C : C);
        }
      }
    }
  }
  {
    const c = e < 0 ? 1 : -1;
    let f = e < 0 ? i : s, p = 0;
    for (; ; ) {
      const m = t[f];
      He(m != null);
      const x = xr({
        panelConstraints: n,
        panelIndex: f,
        size: 100
      }) - m;
      if (p += x, f += c, f < 0 || f >= n.length) break;
    }
    const v = Math.min(Math.abs(e), Math.abs(p));
    e = e < 0 ? 0 - v : v;
  }
  {
    let f = e < 0 ? s : i;
    for (; f >= 0 && f < n.length; ) {
      const p = Math.abs(e) - Math.abs(u), v = t[f];
      He(v != null);
      const m = v - p, y = xr({
        panelConstraints: n,
        panelIndex: f,
        size: m
      });
      if (!sn(v, y) && (u += v - y, o[f] = y, u.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, { numeric: !0 }) >= 0))
        break;
      e < 0 ? f-- : f++;
    }
  }
  if (sn(u, 0)) return t;
  {
    const c = e < 0 ? i : s, f = t[c];
    He(f != null);
    const p = f + u, v = xr({
      panelConstraints: n,
      panelIndex: c,
      size: p
    });
    if (o[c] = v, !sn(v, p)) {
      let m = p - v, x = e < 0 ? i : s;
      for (; x >= 0 && x < n.length; ) {
        const C = o[x];
        He(C != null);
        const S = C + m, $ = xr({
          panelConstraints: n,
          panelIndex: x,
          size: S
        });
        if (sn(C, $) || (m -= $ - C, o[x] = $), sn(m, 0)) break;
        e > 0 ? x-- : x++;
      }
    }
  }
  const d = o.reduce((c, f) => f + c, 0);
  return sn(d, 100) ? o : t;
}
function Qg(e, t, n) {
  const a = Kg(e, t, n);
  return a != null ? [a, a + 1] : [-1, -1];
}
function sE(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function lE(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: rv(e),
    b: rv(t)
  };
  let a;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), a = e;
  He(a);
  const r = {
    a: av(nv(n.a)),
    b: av(nv(n.b))
  };
  if (r.a === r.b) {
    const o = a.childNodes, s = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let i = o.length;
    for (; i--; ) {
      const u = o[i];
      if (u === s.a) return 1;
      if (u === s.b) return -1;
    }
  }
  return Math.sign(r.a - r.b);
}
const iE = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function uE(e) {
  const t = getComputedStyle(ey(e)).display;
  return t === "flex" || t === "inline-flex";
}
function dE(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || uE(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || iE.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function nv(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (He(n), dE(n)) return n;
  }
  return null;
}
function av(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function rv(e) {
  const t = [];
  for (; e; )
    t.push(e), e = ey(e);
  return t;
}
function ey(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
const ty = 1, ny = 2, ay = 4, ry = 8;
function cE() {
  if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const fE = cE() === "coarse", Aa = [];
let Vi = !1;
const $a = /* @__PURE__ */ new Map(), Fi = /* @__PURE__ */ new Map(), zo = /* @__PURE__ */ new Set();
function pE(e, t, n, a, r, o) {
  const { ownerDocument: s } = t, i = {
    direction: n,
    element: t,
    hitAreaMargins: a,
    nonce: r,
    setResizeHandlerState: o
  }, u = $a.get(s) ?? 0;
  return $a.set(s, u + 1), zo.add(i), Il(), function() {
    Fi.delete(e), zo.delete(i);
    const c = $a.get(s) ?? 1;
    $a.set(s, c - 1), Il(), sy(), c === 1 && $a.delete(s);
  };
}
function zs(e) {
  const { target: t } = e, { x: n, y: a } = Ri(e);
  Vi = !0, Qc({
    target: t,
    x: n,
    y: a
  }), Il(), Aa.length > 0 && (ef("down", e), e.preventDefault());
}
function ya(e) {
  const { x: t, y: n } = Ri(e);
  if (!Vi) {
    const { target: a } = e;
    Qc({
      target: a,
      x: t,
      y: n
    });
  }
  ef("move", e), oy(), Aa.length > 0 && e.preventDefault();
}
function ba(e) {
  const { target: t } = e, { x: n, y: a } = Ri(e);
  Fi.clear(), Vi = !1, Aa.length > 0 && e.preventDefault(), ef("up", e), Qc({
    target: t,
    x: n,
    y: a
  }), oy(), Il();
}
function Qc({ target: e, x: t, y: n }) {
  Aa.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), zo.forEach((r) => {
    const { element: o, hitAreaMargins: s } = r, i = o.getBoundingClientRect(), { bottom: u, left: d, right: c, top: f } = i, p = fE ? s.coarse : s.fine;
    if (t >= d - p && t <= c + p && n >= f - p && n <= u + p) {
      if (a !== null && o !== a && !o.contains(a) && !a.contains(o) && lE(a, o) > 0) {
        let m = a, y = !1;
        for (; m && !m.contains(o); ) {
          if (sE(m.getBoundingClientRect(), i)) {
            y = !0;
            break;
          }
          m = m.parentElement;
        }
        if (y) return;
      }
      Aa.push(r);
    }
  });
}
function Du(e, t) {
  Fi.set(e, t);
}
function oy() {
  let e = !1, t = !1, n;
  Aa.forEach((r) => {
    const { direction: o, nonce: s } = r;
    o.value === "horizontal" ? e = !0 : t = !0, n = s.value;
  });
  let a = 0;
  Fi.forEach((r) => {
    a |= r;
  }), e && t ? qu("intersection", a, n) : e ? qu("horizontal", a, n) : t ? qu("vertical", a, n) : sy();
}
function Il() {
  $a.forEach((e, t) => {
    const { body: n } = t;
    n.removeEventListener("contextmenu", ba), n.removeEventListener("mousedown", zs), n.removeEventListener("mouseleave", ya), n.removeEventListener("mousemove", ya), n.removeEventListener("touchmove", ya), n.removeEventListener("touchstart", zs);
  }), window.removeEventListener("mouseup", ba), window.removeEventListener("touchcancel", ba), window.removeEventListener("touchend", ba), zo.size > 0 && (Vi ? (Aa.length > 0 && $a.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("contextmenu", ba), n.addEventListener("mouseleave", ya), n.addEventListener("mousemove", ya), n.addEventListener("touchmove", ya, { passive: !1 }));
  }), window.addEventListener("mouseup", ba), window.addEventListener("touchcancel", ba), window.addEventListener("touchend", ba)) : $a.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("mousedown", zs), n.addEventListener("mousemove", ya), n.addEventListener("touchmove", ya, { passive: !1 }), n.addEventListener("touchstart", zs));
  }));
}
function ef(e, t) {
  zo.forEach((n) => {
    const { setResizeHandlerState: a } = n, r = Aa.includes(n);
    a(e, r, t);
  });
}
let _d = null, Ba = null;
function vE(e, t) {
  if (t) {
    const n = (t & ty) !== 0, a = (t & ny) !== 0, r = (t & ay) !== 0, o = (t & ry) !== 0;
    if (n) return r ? "se-resize" : o ? "ne-resize" : "e-resize";
    if (a) return r ? "sw-resize" : o ? "nw-resize" : "w-resize";
    if (r) return "s-resize";
    if (o) return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function sy() {
  Ba !== null && (document.head.removeChild(Ba), _d = null, Ba = null);
}
function qu(e, t, n) {
  const a = vE(e, t);
  _d !== a && (_d = a, Ba === null && (Ba = document.createElement("style"), n && (Ba.nonce = n), document.head.appendChild(Ba)), Ba.innerHTML = `*{cursor: ${a}!important;}`);
}
function mE({ defaultSize: e, dragState: t, layout: n, panelData: a, panelIndex: r, precision: o = 3 }) {
  const s = n[r];
  let i;
  return s == null ? i = e !== void 0 ? e.toPrecision(o) : "1" : a.length === 1 ? i = "1" : i = s.toPrecision(o), {
    flexBasis: 0,
    flexGrow: i,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: t !== null ? "none" : void 0
  };
}
function hE({ layout: e, panelConstraints: t }) {
  const n = [...e], a = n.reduce((o, s) => o + s, 0);
  if (n.length !== t.length) throw new Error(`Invalid ${t.length} panel layout: ${n.map((o) => `${o}%`).join(", ")}`);
  if (!sn(a, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${n.map((o) => `${o}%`).join(", ")}. Layout normalization will be applied.`);
    for (let o = 0; o < t.length; o++) {
      const s = n[o];
      He(s != null);
      const i = 100 / a * s;
      n[o] = i;
    }
  }
  let r = 0;
  for (let o = 0; o < t.length; o++) {
    const s = n[o];
    He(s != null);
    const i = xr({
      panelConstraints: t,
      panelIndex: o,
      size: s
    });
    s !== i && (r += s - i, n[o] = i);
  }
  if (!sn(r, 0)) for (let o = 0; o < t.length; o++) {
    const s = n[o];
    He(s != null);
    const i = s + r, u = xr({
      panelConstraints: t,
      panelIndex: o,
      size: i
    });
    if (s !== u && (r -= u - s, n[o] = u, sn(r, 0)))
      break;
  }
  return n;
}
function gE({ eagerValuesRef: e, groupId: t, layout: n, panelDataArray: a, panelGroupElement: r, setLayout: o }) {
  Te((s) => {
    const i = r.value;
    if (!i) return;
    const u = No(t, i);
    for (let d = 0; d < a.length - 1; d++) {
      const { valueMax: c, valueMin: f, valueNow: p } = aE({
        layout: n.value,
        panelsArray: a,
        pivotIndices: [d, d + 1]
      }), v = u[d];
      if (v != null) {
        const m = a[d];
        He(m), v.setAttribute("aria-controls", m.id), v.setAttribute("aria-valuemax", `${Math.round(c)}`), v.setAttribute("aria-valuemin", `${Math.round(f)}`), v.setAttribute("aria-valuenow", p != null ? `${Math.round(p)}` : "");
      }
    }
    s(() => {
      u.forEach((d) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    });
  }), Te((s) => {
    const i = r.value;
    if (!i) return;
    const u = e.value;
    He(u);
    const { panelDataArray: d } = u, c = Gg(t, i);
    He(c != null, `No group found for id "${t}"`);
    const f = No(t, i);
    He(f);
    const p = f.map((v) => {
      const m = v.getAttribute("data-panel-resize-handle-id");
      He(m);
      const [y, x] = eE(t, m, d, i);
      if (y == null || x == null) return () => {
      };
      const C = (S) => {
        if (!S.defaultPrevented)
          switch (S.key) {
            case "Enter": {
              S.preventDefault();
              const $ = d.findIndex((k) => k.id === y);
              if ($ >= 0) {
                const k = d[$];
                He(k);
                const B = n.value[$], { collapsedSize: P = 0, collapsible: M, minSize: q = 0 } = k.constraints;
                if (B != null && M) {
                  const E = wo({
                    delta: sn(B, P) ? q - P : P - B,
                    layout: n.value,
                    panelConstraints: d.map((D) => D.constraints),
                    pivotIndices: Qg(t, m, i),
                    trigger: "keyboard"
                  });
                  n.value !== E && o(E);
                }
              }
              break;
            }
          }
      };
      return v.addEventListener("keydown", C), () => {
        v.removeEventListener("keydown", C);
      };
    });
    s(() => {
      p.forEach((v) => v());
    });
  });
}
function ov(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else throw new TypeError("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function ly(e) {
  return `reka:${e}`;
}
function iy(e) {
  return e.map((t) => {
    const { constraints: n, id: a, idIsFromProps: r, order: o } = t;
    return r ? a : o ? `${o}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function uy(e, t) {
  try {
    const n = ly(e), a = t.getItem(n);
    if (a) {
      const r = JSON.parse(a);
      if (typeof r == "object" && r != null) return r;
    }
  } catch {
  }
  return null;
}
function yE(e, t, n) {
  const a = uy(e, n) ?? {}, r = iy(t);
  return a[r] ?? null;
}
function bE(e, t, n, a, r) {
  const o = ly(e), s = iy(t), i = uy(e, r) ?? {};
  i[s] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: a
  };
  try {
    r.setItem(o, JSON.stringify(i));
  } catch (u) {
    console.error(u);
  }
}
const _E = 100, xo = {
  getItem: (e) => (ov(xo), xo.getItem(e)),
  setItem: (e, t) => {
    ov(xo), xo.setItem(e, t);
  }
}, [dy, wE] = Se("PanelGroup");
var xE = /* @__PURE__ */ b({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: !1
    },
    autoSaveId: {
      type: [String, null],
      required: !1,
      default: null
    },
    direction: {
      type: String,
      required: !0
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: !1,
      default: 10
    },
    storage: {
      type: Object,
      required: !1,
      default: () => xo
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = {}, { direction: o } = qe(n), s = Ke(n.id, "reka-splitter-group"), i = gt(), { forwardRef: u, currentElement: d } = j(), c = I(null), f = I([]), p = I({}), v = I(/* @__PURE__ */ new Map()), m = I(0), y = A(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: c.value,
      id: s,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), x = I({
      layout: f.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), C = (H) => f.value = H;
    gE({
      eagerValuesRef: x,
      groupId: s,
      layout: f,
      panelDataArray: x.value.panelDataArray,
      setLayout: C,
      panelGroupElement: d
    }), Te(() => {
      const { panelDataArray: H } = x.value, { autoSaveId: U } = n;
      if (U) {
        if (f.value.length === 0 || f.value.length !== H.length) return;
        let se = r[U];
        se || (se = oE(bE, _E), r[U] = se);
        const ee = [...H], de = new Map(v.value);
        se(U, ee, de, f.value, n.storage);
      }
    });
    function S(H, U) {
      const { panelDataArray: se } = x.value, ee = Q(se, H);
      return mE({
        defaultSize: U,
        dragState: c.value,
        layout: f.value,
        panelData: se,
        panelIndex: ee
      });
    }
    function $(H) {
      const { panelDataArray: U } = x.value;
      U.push(H), U.sort((se, ee) => {
        const de = se.order, fe = ee.order;
        return de == null && fe == null ? 0 : de == null ? -1 : fe == null ? 1 : de - fe;
      }), x.value.panelDataArrayChanged = !0;
    }
    me(() => x.value.panelDataArrayChanged, () => {
      if (x.value.panelDataArrayChanged) {
        x.value.panelDataArrayChanged = !1;
        const { autoSaveId: H, storage: U } = y.value, { layout: se, panelDataArray: ee } = x.value;
        let de = null;
        if (H) {
          const _e = yE(H, ee, U);
          _e && (v.value = new Map(Object.entries(_e.expandToSizes)), de = _e.layout);
        }
        de === null && (de = rE({ panelDataArray: ee }));
        const fe = hE({
          layout: de,
          panelConstraints: ee.map((_e) => _e.constraints)
        });
        g0(se, fe) || (C(fe), x.value.layout = fe, a("layout", fe), io(ee, fe, p.value));
      }
    });
    function k(H) {
      return function(se) {
        se.preventDefault();
        const ee = d.value;
        if (!ee) return () => null;
        const { direction: de, dragState: fe, id: _e, keyboardResizeBy: ye } = y.value, { layout: Ee, panelDataArray: ce } = x.value, { initialLayout: V } = fe ?? {}, te = Qg(_e, H, ee);
        let z = nE(se, H, de, fe, ye, ee);
        if (z === 0) return;
        const re = de === "horizontal";
        i.value === "rtl" && re && (z = -z);
        const ie = ce.map((xe) => xe.constraints), L = wo({
          delta: z,
          layout: V ?? Ee,
          panelConstraints: ie,
          pivotIndices: te,
          trigger: Yg(se) ? "keyboard" : "mouse-or-touch"
        }), be = !Ls(Ee, L);
        (Xg(se) || Jg(se)) && m.value !== z && (m.value = z, be ? Du(H, 0) : re ? Du(H, z < 0 ? ty : ny) : Du(H, z < 0 ? ay : ry)), be && (C(L), x.value.layout = L, a("layout", L), io(ce, L, p.value));
      };
    }
    function B(H, U) {
      const { layout: se, panelDataArray: ee } = x.value, de = ee.map((V) => V.constraints), { panelSize: fe, pivotIndices: _e } = W(ee, H, se);
      He(fe != null);
      const Ee = Q(ee, H) === ee.length - 1 ? fe - U : U - fe, ce = wo({
        delta: Ee,
        layout: se,
        panelConstraints: de,
        pivotIndices: _e,
        trigger: "imperative-api"
      });
      Ls(se, ce) || (C(ce), x.value.layout = ce, a("layout", ce), io(ee, ce, p.value));
    }
    function P(H, U) {
      const { layout: se, panelDataArray: ee } = x.value, de = Q(ee, H);
      ee[de] = H, x.value.panelDataArrayChanged = !0;
      const { collapsedSize: fe = 0, collapsible: _e } = U, { collapsedSize: ye = 0, collapsible: Ee, maxSize: ce = 100, minSize: V = 0 } = H.constraints, { panelSize: te } = W(ee, H, se);
      te !== null && (_e && Ee && te === fe ? fe !== ye && B(H, ye) : te < V ? B(H, V) : te > ce && B(H, ce));
    }
    function M(H, U) {
      const { direction: se } = y.value, { layout: ee } = x.value;
      if (!d.value) return;
      const de = Oi(H, d.value);
      He(de);
      const fe = Zg(se, U);
      c.value = {
        dragHandleId: H,
        dragHandleRect: de.getBoundingClientRect(),
        initialCursorPosition: fe,
        initialLayout: ee
      };
    }
    function q() {
      c.value = null;
    }
    function E(H) {
      const { panelDataArray: U } = x.value, se = Q(U, H);
      se >= 0 && (U.splice(se, 1), delete p.value[H.id], x.value.panelDataArrayChanged = !0);
    }
    function D(H) {
      const { layout: U, panelDataArray: se } = x.value;
      if (H.constraints.collapsible) {
        const ee = se.map((ye) => ye.constraints), { collapsedSize: de = 0, panelSize: fe, pivotIndices: _e } = W(se, H, U);
        if (He(fe != null, `Panel size not found for panel "${H.id}"`), fe !== de) {
          v.value.set(H.id, fe);
          const Ee = Q(se, H) === se.length - 1 ? fe - de : de - fe, ce = wo({
            delta: Ee,
            layout: U,
            panelConstraints: ee,
            pivotIndices: _e,
            trigger: "imperative-api"
          });
          Ls(U, ce) || (C(ce), x.value.layout = ce, a("layout", ce), io(se, ce, p.value));
        }
      }
    }
    function O(H) {
      const { layout: U, panelDataArray: se } = x.value;
      if (H.constraints.collapsible) {
        const ee = se.map((Ee) => Ee.constraints), { collapsedSize: de = 0, panelSize: fe, minSize: _e = 0, pivotIndices: ye } = W(se, H, U);
        if (fe === de) {
          const Ee = v.value.get(H.id), ce = Ee != null && Ee >= _e ? Ee : _e, te = Q(se, H) === se.length - 1 ? fe - ce : ce - fe, z = wo({
            delta: te,
            layout: U,
            panelConstraints: ee,
            pivotIndices: ye,
            trigger: "imperative-api"
          });
          Ls(U, z) || (C(z), x.value.layout = z, a("layout", z), io(se, z, p.value));
        }
      }
    }
    function F(H) {
      const { layout: U, panelDataArray: se } = x.value, { panelSize: ee } = W(se, H, U);
      return He(ee != null, `Panel size not found for panel "${H.id}"`), ee;
    }
    function J(H) {
      const { layout: U, panelDataArray: se } = x.value, { collapsedSize: ee = 0, collapsible: de, panelSize: fe } = W(se, H, U);
      return de ? fe === void 0 ? H.constraints.defaultSize === H.constraints.collapsedSize : fe === ee : !1;
    }
    function ne(H) {
      const { layout: U, panelDataArray: se } = x.value, { collapsedSize: ee = 0, collapsible: de, panelSize: fe } = W(se, H, U);
      return He(fe != null, `Panel size not found for panel "${H.id}"`), !de || fe > ee;
    }
    wE({
      direction: o,
      dragState: c.value,
      groupId: s,
      reevaluatePanelConstraints: P,
      registerPanel: $,
      registerResizeHandle: k,
      resizePanel: B,
      startDragging: M,
      stopDragging: q,
      unregisterPanel: E,
      panelGroupElement: d,
      collapsePanel: D,
      expandPanel: O,
      isPanelCollapsed: J,
      isPanelExpanded: ne,
      getPanelSize: F,
      getPanelStyle: S
    });
    function Q(H, U) {
      return H.findIndex((se) => se === U || se.id === U.id);
    }
    function W(H, U, se) {
      const ee = Q(H, U), fe = ee === H.length - 1 ? [ee - 1, ee] : [ee, ee + 1], _e = se[ee];
      return {
        ...U.constraints,
        panelSize: _e,
        pivotIndices: fe
      };
    }
    return (H, U) => (h(), w(l(X), {
      ref: l(u),
      as: H.as,
      "as-child": H.asChild,
      style: dt({
        display: "flex",
        flexDirection: l(o) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": l(o),
      "data-panel-group-id": l(s)
    }, {
      default: g(() => [_(H.$slots, "default", { layout: f.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "style",
      "data-orientation",
      "data-panel-group-id"
    ]));
  }
}), CE = xE, SE = /* @__PURE__ */ b({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: !1
    },
    collapsible: {
      type: Boolean,
      required: !1
    },
    defaultSize: {
      type: Number,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    maxSize: {
      type: Number,
      required: !1
    },
    minSize: {
      type: Number,
      required: !1
    },
    order: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, o = dy();
    if (o === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel: s, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: f, groupId: p, reevaluatePanelConstraints: v, registerPanel: m, unregisterPanel: y } = o, x = Ke(a.id, "reka-splitter-panel"), C = A(() => ({
      callbacks: {
        onCollapse: () => r("collapse"),
        onExpand: () => r("expand"),
        onResize: (...q) => r("resize", ...q)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(Zc)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: x,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    me(() => C.value.constraints, (q, E) => {
      (E.collapsedSize !== q.collapsedSize || E.collapsible !== q.collapsible || E.maxSize !== q.maxSize || E.minSize !== q.minSize) && v(C.value, E);
    }, { deep: !0 }), Ce(() => {
      m(C.value);
    }), nt(() => {
      y(C.value);
    });
    const S = A(() => d(C.value, a.defaultSize)), $ = A(() => c(C.value)), k = A(() => !$.value);
    function B() {
      s(C.value);
    }
    function P() {
      i(C.value);
    }
    function M(q) {
      f(C.value, q);
    }
    return t({
      collapse: B,
      expand: P,
      getSize() {
        return u(C.value);
      },
      resize: M,
      isCollapsed: $,
      isExpanded: k
    }), (q, E) => (h(), w(l(X), {
      id: l(x),
      style: dt(S.value),
      as: q.as,
      "as-child": q.asChild,
      "data-panel": "",
      "data-panel-collapsible": q.collapsible || void 0,
      "data-panel-group-id": l(p),
      "data-panel-id": l(x),
      "data-panel-size": Number.parseFloat(`${S.value.flexGrow}`).toFixed(1),
      "data-state": q.collapsible ? $.value ? "collapsed" : "expanded" : void 0
    }, {
      default: g(() => [_(q.$slots, "default", {
        isCollapsed: $.value,
        isExpanded: k.value,
        expand: P,
        collapse: B,
        resize: M
      })]),
      _: 3
    }, 8, [
      "id",
      "style",
      "as",
      "as-child",
      "data-panel-collapsible",
      "data-panel-group-id",
      "data-panel-id",
      "data-panel-size",
      "data-state"
    ]));
  }
}), oH = SE;
function $E({ disabled: e, handleId: t, resizeHandler: n, panelGroupElement: a }) {
  Te((r) => {
    const o = a.value;
    if (e.value || n.value === null || o === null) return;
    const s = Oi(t, o);
    if (s == null) return;
    const i = (u) => {
      if (!u.defaultPrevented)
        switch (u.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            u.preventDefault(), n.value?.(u);
            break;
          }
          case "F6": {
            u.preventDefault();
            const d = s.getAttribute("data-panel-group-id");
            He(d);
            const c = No(d, o), f = Kg(d, t, o);
            He(f !== null);
            const p = u.shiftKey ? f > 0 ? f - 1 : c.length - 1 : f + 1 < c.length ? f + 1 : 0;
            c[p].focus();
            break;
          }
        }
    };
    s.addEventListener("keydown", i), r(() => {
      s.removeEventListener("keydown", i);
    });
  });
}
var BE = /* @__PURE__ */ b({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: !1
    },
    hitAreaMargins: {
      type: Object,
      required: !1
    },
    tabindex: {
      type: Number,
      required: !1,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    nonce: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), { disabled: s } = qe(n), i = dy();
    if (i === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction: u, groupId: d, registerResizeHandle: c, startDragging: f, stopDragging: p, panelGroupElement: v } = i, m = Ke(n.id, "reka-splitter-resize-handle"), y = I("inactive"), x = I(!1), C = I(null), { nonce: S } = qe(n), $ = Mi(S);
    return me(s, () => {
      ts && (s.value ? C.value = null : C.value = c(m));
    }, { immediate: !0 }), Te((k) => {
      if (s.value || C.value === null) return;
      const B = o.value;
      if (!B) return;
      He(B);
      const P = (M, q, E) => {
        if (q) switch (M) {
          case "down": {
            y.value = "drag", f(m, E), a("dragging", !0);
            break;
          }
          case "move": {
            y.value !== "drag" && (y.value = "hover"), C.value?.(E);
            break;
          }
          case "up": {
            y.value = "hover", p(), a("dragging", !1);
            break;
          }
        }
        else y.value = "inactive";
      };
      k(pE(m, B, u, {
        coarse: n.hitAreaMargins?.coarse ?? 15,
        fine: n.hitAreaMargins?.fine ?? 5
      }, $, P));
    }), $E({
      disabled: s,
      resizeHandler: C,
      handleId: m,
      panelGroupElement: v
    }), (k, B) => (h(), w(l(X), {
      id: l(m),
      ref: l(r),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: k.as,
      "as-child": k.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: k.tabindex,
      "data-state": y.value,
      "data-disabled": l(s) ? "" : void 0,
      "data-orientation": l(u),
      "data-panel-group-id": l(d),
      "data-resize-handle-active": y.value === "drag" ? "pointer" : x.value ? "keyboard" : void 0,
      "data-resize-handle-state": y.value,
      "data-panel-resize-handle-enabled": !l(s),
      "data-panel-resize-handle-id": l(m),
      onBlur: B[0] || (B[0] = (P) => x.value = !1),
      onFocus: B[1] || (B[1] = (P) => x.value = !1)
    }, {
      default: g(() => [_(k.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "tabindex",
      "data-state",
      "data-disabled",
      "data-orientation",
      "data-panel-group-id",
      "data-resize-handle-active",
      "data-resize-handle-state",
      "data-panel-resize-handle-enabled",
      "data-panel-resize-handle-id"
    ]));
  }
}), kE = BE;
const PE = {
  "aria-live": "polite",
  "aria-atomic": "true",
  role: "status",
  style: {
    transform: "translateX(-100%)",
    position: "absolute",
    pointerEvents: "none",
    opacity: 0,
    margin: 0
  }
}, [tf, ME] = Se("StepperRoot");
var DE = /* @__PURE__ */ b({
  __name: "StepperRoot",
  props: {
    defaultValue: {
      type: Number,
      required: !1,
      default: 1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    modelValue: {
      type: Number,
      required: !1
    },
    linear: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, { dir: o, orientation: s, linear: i } = qe(a), u = gt(o), d = I(/* @__PURE__ */ new Set()), c = /* @__PURE__ */ Ie(a, "modelValue", r, {
      defaultValue: a.defaultValue,
      passive: a.modelValue === void 0
    }), f = A(() => Array.from(d.value)), p = A(() => c.value === 1), v = A(() => c.value === f.value.length), m = A(() => d.value.size);
    function y(q) {
      q > m.value || q < 1 || d.value.size && f.value[q] && f.value[q].getAttribute("disabled") || i.value && q > (c.value ?? 1) + 1 || (c.value = q);
    }
    function x() {
      y((c.value ?? 1) + 1);
    }
    function C() {
      y((c.value ?? 1) - 1);
    }
    function S() {
      return (c.value ?? 1) < m.value;
    }
    function $() {
      return (c.value ?? 1) > 1;
    }
    const k = I(null), B = I(null), P = A(() => k.value ? k.value.getAttribute("disabled") === "" : !0), M = A(() => B.value ? B.value.getAttribute("disabled") === "" : !0);
    return me(c, async () => {
      await Pe(() => {
        k.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, B.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), me(f, async () => {
      await Pe(() => {
        k.value = f.value.length && c.value < f.value.length ? f.value[c.value] : null, B.value = f.value.length && c.value > 1 ? f.value[c.value - 2] : null;
      });
    }), ME({
      modelValue: c,
      changeModelValue: (q) => {
        c.value = q;
      },
      orientation: s,
      dir: u,
      linear: i,
      totalStepperItems: d
    }), t({
      goToStep: y,
      nextStep: x,
      prevStep: C,
      modelValue: c,
      totalSteps: m,
      isNextDisabled: P,
      isPrevDisabled: M,
      isFirstStep: p,
      isLastStep: v,
      hasNext: S,
      hasPrev: $
    }), j(), (q, E) => (h(), w(l(X), {
      role: "group",
      "aria-label": "progress",
      as: q.as,
      "as-child": q.asChild,
      "data-linear": l(i) ? "" : void 0,
      "data-orientation": q.orientation
    }, {
      default: g(() => [_(q.$slots, "default", {
        modelValue: l(c),
        totalSteps: d.value.size,
        isNextDisabled: P.value,
        isPrevDisabled: M.value,
        isFirstStep: p.value,
        isLastStep: v.value,
        goToStep: y,
        nextStep: x,
        prevStep: C,
        hasNext: S,
        hasPrev: $
      }), we("div", PE, " Step " + Fe(l(c)) + " of " + Fe(d.value.size), 1)]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "data-linear",
      "data-orientation"
    ]));
  }
}), qE = DE;
const [ys, AE] = Se("StepperItem");
var EE = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {
      type: Number,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    completed: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { disabled: n, step: a, completed: r } = qe(t), { forwardRef: o } = j(), s = tf(), i = Ke(void 0, "reka-stepper-item-title"), u = Ke(void 0, "reka-stepper-item-description"), d = A(() => r.value ? "completed" : s.modelValue.value === a.value ? "active" : s.modelValue.value > a.value ? "completed" : "inactive"), c = A(() => n.value ? !1 : s.linear.value ? a.value <= s.modelValue.value || a.value === s.modelValue.value + 1 : !0);
    return AE({
      titleId: i,
      descriptionId: u,
      state: d,
      disabled: n,
      step: a,
      isFocusable: c
    }), (f, p) => (h(), w(l(X), {
      ref: l(o),
      as: f.as,
      "as-child": f.asChild,
      "aria-current": d.value === "active" ? "true" : void 0,
      "data-state": d.value,
      disabled: l(n) || !c.value ? "" : void 0,
      "data-disabled": l(n) || !c.value ? "" : void 0,
      "data-orientation": l(s).orientation.value
    }, {
      default: g(() => [_(f.$slots, "default", { state: d.value })]),
      _: 3
    }, 8, [
      "as",
      "as-child",
      "aria-current",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation"
    ]));
  }
}), TE = EE, IE = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "p"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = ys();
    return (a, r) => (h(), w(l(X), T(t, { id: l(n).descriptionId }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), OE = IE, RE = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = ys();
    return j(), (a, r) => (h(), w(l(X), oe(le(t)), {
      default: g(() => [_(a.$slots, "default", { step: l(n).step.value }, () => [Re(" Step " + Fe(l(n).step.value), 1)])]),
      _: 3
    }, 16));
  }
}), VE = RE, FE = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {
      type: String,
      required: !1
    },
    decorative: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, n = tf(), a = ys();
    return j(), (r, o) => (h(), w(l(Xc), T(t, {
      decorative: "",
      orientation: l(n).orientation.value,
      "data-state": l(a).state.value
    }), {
      default: g(() => [_(r.$slots, "default")]),
      _: 3
    }, 16, ["orientation", "data-state"]));
  }
}), NE = FE, LE = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "h4"
    }
  },
  setup(e) {
    const t = e, n = ys();
    return j(), (a, r) => (h(), w(l(X), T(t, { id: l(n).titleId }), {
      default: g(() => [_(a.$slots, "default")]),
      _: 3
    }, 16, ["id"]));
  }
}), zE = LE, HE = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = tf(), n = ys(), a = is(), r = A(() => Array.from(t.totalStepperItems.value));
    function o(d) {
      if (!n.disabled.value) {
        if (t.linear.value) {
          if ((n.step.value <= t.modelValue.value || n.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {
            t.changeModelValue(n.step.value);
            return;
          }
        } else if (d.ctrlKey === !1) {
          t.changeModelValue(n.step.value);
          return;
        }
        d.preventDefault();
      }
    }
    function s(d) {
      d.preventDefault(), !n.disabled.value && ((d.key === a.ENTER || d.key === a.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(n.step.value), [
        a.ARROW_LEFT,
        a.ARROW_RIGHT,
        a.ARROW_UP,
        a.ARROW_DOWN
      ].includes(d.key) && rr(d, rt(), void 0, {
        itemsArray: r.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: t.orientation.value,
        dir: t.dir.value
      }));
    }
    const { forwardRef: i, currentElement: u } = j();
    return Ce(() => {
      t.totalStepperItems.value.add(u.value);
    }), nt(() => {
      t.totalStepperItems.value.delete(u.value);
    }), (d, c) => (h(), w(l(X), {
      ref: l(i),
      type: d.as === "button" ? "button" : void 0,
      as: d.as,
      "as-child": d.asChild,
      "data-state": l(n).state.value,
      disabled: l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-disabled": l(n).disabled.value || !l(n).isFocusable.value ? "" : void 0,
      "data-orientation": l(t).orientation.value,
      tabindex: l(n).isFocusable.value ? 0 : -1,
      "aria-describedby": l(n).descriptionId,
      "aria-labelledby": l(n).titleId,
      onMousedown: Ye(o, ["left"]),
      onKeydown: Je(s, [
        "enter",
        "space",
        "left",
        "right",
        "up",
        "down"
      ])
    }, {
      default: g(() => [_(d.$slots, "default")]),
      _: 3
    }, 8, [
      "type",
      "as",
      "as-child",
      "data-state",
      "disabled",
      "data-disabled",
      "data-orientation",
      "tabindex",
      "aria-describedby",
      "aria-labelledby"
    ]));
  }
}), UE = HE;
const [jE, WE] = Se("SwitchRoot");
var GE = /* @__PURE__ */ b({
  __name: "SwitchRoot",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    id: {
      type: String,
      required: !1
    },
    value: {
      type: String,
      required: !1,
      default: "on"
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: r } = qe(n), o = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function s() {
      r.value || (o.value = !o.value);
    }
    const { forwardRef: i, currentElement: u } = j(), d = In(u), c = A(() => n.id && u.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return WE({
      modelValue: o,
      toggleCheck: s,
      disabled: r
    }), (f, p) => (h(), w(l(X), T(f.$attrs, {
      id: f.id,
      ref: l(i),
      role: "switch",
      type: f.as === "button" ? "button" : void 0,
      value: f.value,
      "aria-label": f.$attrs["aria-label"] || c.value,
      "aria-checked": l(o),
      "aria-required": f.required,
      "data-state": l(o) ? "checked" : "unchecked",
      "data-disabled": l(r) ? "" : void 0,
      "as-child": f.asChild,
      as: f.as,
      disabled: l(r),
      onClick: s,
      onKeydown: Je(Ye(s, ["prevent"]), ["enter"])
    }), {
      default: g(() => [_(f.$slots, "default", { modelValue: l(o) }), l(d) && f.name ? (h(), w(l(On), {
        key: 0,
        type: "checkbox",
        name: f.name,
        disabled: l(r),
        required: f.required,
        value: f.value,
        checked: !!l(o)
      }, null, 8, [
        "name",
        "disabled",
        "required",
        "value",
        "checked"
      ])) : De("v-if", !0)]),
      _: 3
    }, 16, [
      "id",
      "type",
      "value",
      "aria-label",
      "aria-checked",
      "aria-required",
      "data-state",
      "data-disabled",
      "as-child",
      "as",
      "disabled",
      "onKeydown"
    ]));
  }
}), KE = GE, YE = /* @__PURE__ */ b({
  __name: "SwitchThumb",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = jE();
    return j(), (n, a) => (h(), w(l(X), {
      "data-state": l(t).modelValue?.value ? "checked" : "unchecked",
      "data-disabled": l(t).disabled.value ? "" : void 0,
      "as-child": n.asChild,
      as: n.as
    }, {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 8, [
      "data-state",
      "data-disabled",
      "as-child",
      "as"
    ]));
  }
}), XE = YE;
const [nf, JE] = Se("TabsRoot");
var ZE = /* @__PURE__ */ b({
  __name: "TabsRoot",
  props: {
    defaultValue: {
      type: null,
      required: !1
    },
    orientation: {
      type: String,
      required: !1,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: !1
    },
    activationMode: {
      type: String,
      required: !1,
      default: "automatic"
    },
    modelValue: {
      type: null,
      required: !1
    },
    unmountOnHide: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { orientation: r, unmountOnHide: o, dir: s } = qe(n), i = gt(s);
    j();
    const u = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), d = I(), c = ht(/* @__PURE__ */ new Set());
    return JE({
      modelValue: u,
      changeModelValue: (f) => {
        u.value = f;
      },
      orientation: r,
      dir: i,
      unmountOnHide: o,
      activationMode: n.activationMode,
      baseId: Ke(void 0, "reka-tabs"),
      tabsList: d,
      contentIds: c,
      registerContent: (f) => {
        c.value = /* @__PURE__ */ new Set([...c.value, f]);
      },
      unregisterContent: (f) => {
        const p = new Set(c.value);
        p.delete(f), c.value = p;
      }
    }), (f, p) => (h(), w(l(X), {
      dir: l(i),
      "data-orientation": l(r),
      "as-child": f.asChild,
      as: f.as
    }, {
      default: g(() => [_(f.$slots, "default", { modelValue: l(u) })]),
      _: 3
    }, 8, [
      "dir",
      "data-orientation",
      "as-child",
      "as"
    ]));
  }
}), QE = ZE;
function cy(e, t) {
  return `${e}-trigger-${t}`;
}
function fy(e, t) {
  return `${e}-content-${t}`;
}
var eT = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    forceMount: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = nf(), r = A(() => cy(a.baseId, t.value)), o = A(() => fy(a.baseId, t.value)), s = A(() => t.value === a.modelValue.value), i = I(s.value);
    return Ce(() => {
      a.registerContent(t.value), requestAnimationFrame(() => {
        i.value = !1;
      });
    }), Ea(() => {
      a.unregisterContent(t.value);
    }), (u, d) => (h(), w(l(yt), {
      present: u.forceMount || s.value,
      "force-mount": ""
    }, {
      default: g(({ present: c }) => [N(l(X), {
        id: o.value,
        ref: l(n),
        "as-child": u.asChild,
        as: u.as,
        role: "tabpanel",
        "data-state": s.value ? "active" : "inactive",
        "data-orientation": l(a).orientation.value,
        "aria-labelledby": r.value,
        hidden: !c,
        tabindex: "0",
        style: dt({ animationDuration: i.value ? "0s" : void 0 })
      }, {
        default: g(() => [!l(a).unmountOnHide.value || c ? _(u.$slots, "default", { key: 0 }) : De("v-if", !0)]),
        _: 2
      }, 1032, [
        "id",
        "as-child",
        "as",
        "data-state",
        "data-orientation",
        "aria-labelledby",
        "hidden",
        "style"
      ])]),
      _: 3
    }, 8, ["present"]));
  }
}), tT = eT, nT = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { loop: n } = qe(t), { forwardRef: a, currentElement: r } = j(), o = nf();
    return o.tabsList = r, (s, i) => (h(), w(l(fs), {
      "as-child": "",
      orientation: l(o).orientation.value,
      dir: l(o).dir.value,
      loop: l(n)
    }, {
      default: g(() => [N(l(X), {
        ref: l(a),
        role: "tablist",
        "as-child": s.asChild,
        as: s.as,
        "aria-orientation": l(o).orientation.value
      }, {
        default: g(() => [_(s.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "aria-orientation"
      ])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), aT = nT, rT = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {
      type: [String, Number],
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, { forwardRef: n } = j(), a = nf(), r = A(() => cy(a.baseId, t.value)), o = A(() => a.contentIds.value.has(t.value) ? fy(a.baseId, t.value) : void 0), s = A(() => t.value === a.modelValue.value);
    return (i, u) => (h(), w(l(ps), {
      "as-child": "",
      focusable: !i.disabled,
      active: s.value
    }, {
      default: g(() => [N(l(X), {
        id: r.value,
        ref: l(n),
        role: "tab",
        type: i.as === "button" ? "button" : void 0,
        as: i.as,
        "as-child": i.asChild,
        "aria-selected": s.value ? "true" : "false",
        "aria-controls": o.value,
        "data-state": s.value ? "active" : "inactive",
        disabled: i.disabled,
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": l(a).orientation.value,
        onMousedown: u[0] || (u[0] = Ye((d) => {
          !i.disabled && d.ctrlKey === !1 ? l(a).changeModelValue(i.value) : d.preventDefault();
        }, ["left"])),
        onKeydown: u[1] || (u[1] = Je((d) => l(a).changeModelValue(i.value), ["enter", "space"])),
        onFocus: u[2] || (u[2] = () => {
          const d = l(a).activationMode !== "manual";
          !s.value && !i.disabled && d && l(a).changeModelValue(i.value);
        })
      }, {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "type",
        "as",
        "as-child",
        "aria-selected",
        "aria-controls",
        "data-state",
        "disabled",
        "data-disabled",
        "data-orientation"
      ])]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), oT = rT;
const [af, sT] = Se("TagsInputRoot");
var lT = /* @__PURE__ */ b({
  __name: "TagsInputRoot",
  props: {
    modelValue: {
      type: [Array, null],
      required: !1
    },
    defaultValue: {
      type: Array,
      required: !1,
      default: () => []
    },
    addOnPaste: {
      type: Boolean,
      required: !1
    },
    addOnTab: {
      type: Boolean,
      required: !1
    },
    addOnBlur: {
      type: Boolean,
      required: !1
    },
    duplicate: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    delimiter: {
      type: null,
      required: !1,
      default: ","
    },
    dir: {
      type: String,
      required: !1
    },
    max: {
      type: Number,
      required: !1,
      default: 0
    },
    id: {
      type: String,
      required: !1
    },
    convertValue: {
      type: Function,
      required: !1
    },
    displayValue: {
      type: Function,
      required: !1,
      default: (e) => e.toString()
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: [
    "update:modelValue",
    "invalid",
    "addTag",
    "removeTag"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, { addOnPaste: r, disabled: o, delimiter: s, max: i, id: u, dir: d, addOnBlur: c, addOnTab: f } = qe(n), p = gt(d), v = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: !0,
      deep: !0
    }), { forwardRef: m, currentElement: y } = j(), { focused: x } = Q0(y), C = In(y), { getItems: S, CollectionSlot: $ } = st({ isProvider: !0 }), k = I(), B = I(!1), P = A(() => Array.isArray(v.value) ? [...v.value] : []);
    function M(q) {
      if (q !== -1) {
        const E = S().filter((D) => D.ref.dataset.disabled !== "");
        v.value = v.value.filter((D, O) => O !== q), a("removeTag", E[q].value);
      }
    }
    return sT({
      modelValue: v,
      onAddValue: (q) => {
        const E = [...P.value], D = E.length > 0 && typeof E[0] == "object", O = E.length > 0 && typeof n.defaultValue[0] == "object";
        if ((D || O) && typeof n.convertValue != "function") throw new Error("You must provide a `convertValue` function when using objects as values.");
        const F = n.convertValue ? n.convertValue(q) : q;
        if (E.length >= i.value && i.value)
          return a("invalid", F), !1;
        if (n.duplicate)
          return v.value = [...E, F], a("addTag", F), !0;
        if (E.includes(F))
          B.value = !0;
        else return v.value = [...E, F], a("addTag", F), !0;
        return a("invalid", F), !1;
      },
      onRemoveValue: M,
      onInputKeydown: (q) => {
        const E = q.target, D = S().map((F) => F.ref).filter((F) => F.dataset.disabled !== "");
        if (!D.length) return;
        const O = D.at(-1);
        switch (q.key) {
          case "Delete":
          case "Backspace": {
            if (E.selectionStart !== 0 || E.selectionEnd !== 0) break;
            if (k.value) {
              const F = D.findIndex((J) => J === k.value);
              M(F), k.value = k.value === O ? D.at(F - 1) : D.at(F + 1), q.preventDefault();
            } else q.key === "Backspace" && (k.value = O, q.preventDefault());
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const F = q.key === "ArrowRight" && p.value === "ltr" || q.key === "ArrowLeft" && p.value === "rtl", J = !F;
            if (E.selectionStart !== 0 || E.selectionEnd !== 0) break;
            if (J && !k.value)
              k.value = O, q.preventDefault();
            else if (F && O && k.value === O)
              k.value = void 0, q.preventDefault();
            else if (k.value) {
              const ne = rr(q, k.value, void 0, {
                itemsArray: D,
                loop: !1,
                dir: p.value
              });
              ne && (k.value = ne), q.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            k.value && q.preventDefault();
            break;
          }
          default:
            k.value = void 0;
        }
      },
      selectedElement: k,
      isInvalidInput: B,
      addOnPaste: r,
      addOnBlur: c,
      addOnTab: f,
      dir: p,
      disabled: o,
      delimiter: s,
      max: i,
      id: u,
      displayValue: n.displayValue
    }), (q, E) => (h(), w(l($), null, {
      default: g(() => [N(l(X), {
        ref: l(m),
        dir: l(p),
        as: q.as,
        "as-child": q.asChild,
        "data-invalid": B.value ? "" : void 0,
        "data-disabled": l(o) ? "" : void 0,
        "data-focused": l(x) ? "" : void 0
      }, {
        default: g(() => [_(q.$slots, "default", { modelValue: l(v) }), l(C) && q.name ? (h(), w(l(On), {
          key: 0,
          name: q.name,
          value: l(v),
          required: q.required,
          disabled: l(o)
        }, null, 8, [
          "name",
          "value",
          "required",
          "disabled"
        ])) : De("v-if", !0)]),
        _: 3
      }, 8, [
        "dir",
        "as",
        "as-child",
        "data-invalid",
        "data-disabled",
        "data-focused"
      ])]),
      _: 3
    }));
  }
}), iT = lT, uT = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {
      type: String,
      required: !1
    },
    autoFocus: {
      type: Boolean,
      required: !1
    },
    maxLength: {
      type: Number,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "input"
    }
  },
  setup(e) {
    const t = e, n = af(), { forwardRef: a, currentElement: r } = j();
    function o(v) {
      if (n.selectedElement.value = void 0, !n.addOnBlur.value) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = "");
    }
    function s(v) {
      n.addOnTab.value && c(v);
    }
    const i = I(!1);
    function u() {
      i.value = !0;
    }
    function d() {
      Pe(() => {
        i.value = !1;
      });
    }
    async function c(v) {
      if (i.value || (await Pe(), v.defaultPrevented)) return;
      const m = v.target;
      if (!m.value) return;
      n.onAddValue(m.value) && (m.value = ""), v.preventDefault();
    }
    function f(v) {
      if (n.isInvalidInput.value = !1, v.data === null) return;
      const m = n.delimiter.value;
      if (m === v.data || m instanceof RegExp && m.test(v.data)) {
        const x = v.target;
        if (x.value = x.value.replace(m, ""), x.value.trim() === "") {
          x.value = "";
          return;
        }
        n.onAddValue(x.value) && (x.value = "");
      }
    }
    function p(v) {
      if (n.addOnPaste.value) {
        v.preventDefault();
        const m = v.clipboardData;
        if (!m) return;
        const y = m.getData("text");
        n.delimiter.value ? y.split(n.delimiter.value).forEach((C) => {
          n.onAddValue(C);
        }) : n.onAddValue(y);
      }
    }
    return Ce(() => {
      const v = r.value.nodeName === "INPUT" ? r.value : r.value.querySelector("input");
      v && setTimeout(() => {
        t.autoFocus && v?.focus();
      }, 1);
    }), (v, m) => (h(), w(l(X), {
      id: l(n).id?.value,
      ref: l(a),
      type: "text",
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      as: v.as,
      "as-child": v.asChild,
      maxlength: v.maxLength,
      placeholder: v.placeholder,
      disabled: l(n).disabled.value,
      "data-invalid": l(n).isInvalidInput.value ? "" : void 0,
      onInput: f,
      onKeydown: [
        Je(c, ["enter"]),
        Je(s, ["tab"]),
        l(n).onInputKeydown
      ],
      onBlur: o,
      onCompositionstart: u,
      onCompositionend: d,
      onPaste: p
    }, {
      default: g(() => [_(v.$slots, "default")]),
      _: 3
    }, 8, [
      "id",
      "as",
      "as-child",
      "maxlength",
      "placeholder",
      "disabled",
      "data-invalid",
      "onKeydown"
    ]));
  }
}), dT = uT;
const [py, cT] = Se("TagsInputItem");
var fT = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    }
  },
  setup(e) {
    const t = e, { value: n } = qe(t), a = af(), { forwardRef: r, currentElement: o } = j(), { CollectionItem: s } = st(), i = A(() => a.selectedElement.value === o.value), u = A(() => t.disabled || a.disabled.value), d = cT({
      value: n,
      isSelected: i,
      disabled: u,
      textId: "",
      displayValue: A(() => a.displayValue(n.value))
    });
    return (c, f) => (h(), w(l(s), { value: l(n) }, {
      default: g(() => [N(l(X), {
        ref: l(r),
        as: c.as,
        "as-child": c.asChild,
        "aria-labelledby": l(d).textId,
        "aria-current": i.value,
        "data-disabled": u.value ? "" : void 0,
        "data-state": i.value ? "active" : "inactive"
      }, {
        default: g(() => [_(c.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-labelledby",
        "aria-current",
        "data-disabled",
        "data-state"
      ])]),
      _: 3
    }, 8, ["value"]));
  }
}), pT = fT, vT = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e;
    j();
    const n = af(), a = py(), r = A(() => a.disabled?.value || n.disabled.value);
    function o() {
      if (r.value) return;
      const s = n.modelValue.value.findIndex((i) => Dn(i, a.value.value));
      n.onRemoveValue(s);
    }
    return (s, i) => (h(), w(l(X), T({ tabindex: "-1" }, t, {
      "aria-labelledby": l(a).textId,
      "aria-current": l(a).isSelected.value,
      "data-state": l(a).isSelected.value ? "active" : "inactive",
      "data-disabled": r.value ? "" : void 0,
      type: s.as === "button" ? "button" : void 0,
      onClick: o
    }), {
      default: g(() => [_(s.$slots, "default")]),
      _: 3
    }, 16, [
      "aria-labelledby",
      "aria-current",
      "data-state",
      "data-disabled",
      "type"
    ]));
  }
}), mT = vT, hT = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "span"
    }
  },
  setup(e) {
    const t = e, n = py();
    return j(), n.textId ||= Ke(void 0, "reka-tags-input-item-text"), (a, r) => (h(), w(l(X), T(t, { id: l(n).textId }), {
      default: g(() => [_(a.$slots, "default", {}, () => [Re(Fe(l(n).displayValue.value), 1)])]),
      _: 3
    }, 16, ["id"]));
  }
}), gT = hT;
const [vy, yT] = Se("ToggleGroupRoot");
var bT = /* @__PURE__ */ b({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: {
      type: Boolean,
      required: !1,
      default: !0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    orientation: {
      type: String,
      required: !1
    },
    dir: {
      type: String,
      required: !1
    },
    loop: {
      type: Boolean,
      required: !1,
      default: !0
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    },
    type: {
      type: String,
      required: !1
    },
    modelValue: {
      type: null,
      required: !1
    },
    defaultValue: {
      type: null,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { loop: r, rovingFocus: o, disabled: s, dir: i } = qe(n), u = gt(i), { forwardRef: d, currentElement: c } = j(), { modelValue: f, changeModelValue: p, isSingle: v } = Nh(n, a), m = In(c);
    return yT({
      isSingle: v,
      modelValue: f,
      changeModelValue: p,
      dir: u,
      orientation: n.orientation,
      loop: r,
      rovingFocus: o,
      disabled: s
    }), (y, x) => (h(), w(Pt(l(o) ? l(fs) : l(X)), {
      "as-child": "",
      orientation: l(o) ? y.orientation : void 0,
      dir: l(u),
      loop: l(o) ? l(r) : void 0
    }, {
      default: g(() => [N(l(X), {
        ref: l(d),
        role: "group",
        "as-child": y.asChild,
        as: y.as
      }, {
        default: g(() => [_(y.$slots, "default", { modelValue: l(f) }), l(m) && y.name ? (h(), w(On, {
          key: 0,
          name: y.name,
          required: y.required,
          value: l(f)
        }, null, 8, [
          "name",
          "required",
          "value"
        ])) : De("v-if", !0)]),
        _: 3
      }, 8, ["as-child", "as"])]),
      _: 3
    }, 8, [
      "orientation",
      "dir",
      "loop"
    ]));
  }
}), _T = bT, wT = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: {
      type: Boolean,
      required: !1
    },
    modelValue: {
      type: [Boolean, null],
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    },
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      required: !1
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: r, currentElement: o } = j(), s = vy(null), i = /* @__PURE__ */ Ie(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function u() {
      i.value = !i.value;
    }
    const d = A(() => i.value ? "on" : "off"), c = In(o);
    return (f, p) => (h(), w(l(X), {
      ref: l(r),
      type: f.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: f.as,
      "aria-pressed": l(i),
      "data-state": d.value,
      "data-disabled": f.disabled ? "" : void 0,
      disabled: f.disabled,
      onClick: u
    }, {
      default: g(() => [_(f.$slots, "default", {
        modelValue: l(i),
        disabled: f.disabled,
        pressed: l(i),
        state: d.value
      }), l(c) && f.name && !l(s) ? (h(), w(On, {
        key: 0,
        type: "checkbox",
        name: f.name,
        value: l(i),
        required: f.required
      }, null, 8, [
        "name",
        "value",
        "required"
      ])) : De("v-if", !0)]),
      _: 3
    }, 8, [
      "type",
      "as-child",
      "as",
      "aria-pressed",
      "data-state",
      "data-disabled",
      "disabled"
    ]));
  }
}), my = wT, xT = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {
      type: null,
      required: !0
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = vy(), a = A(() => n.disabled?.value || t.disabled), r = A(() => bl(n.modelValue.value, t.value)), { forwardRef: o } = j();
    return (s, i) => (h(), w(Pt(l(n).rovingFocus.value ? l(ps) : l(X)), T({ "as-child": "" }, l(n).rovingFocus.value ? {
      focusable: !a.value,
      active: r.value
    } : {}), {
      default: g(() => [N(l(my), T(t, {
        ref: l(o),
        disabled: a.value,
        "model-value": r.value,
        "onUpdate:modelValue": i[0] || (i[0] = (u) => l(n).changeModelValue(s.value))
      }), {
        default: g((u) => [_(s.$slots, "default", oe(le(u)))]),
        _: 3
      }, 16, ["disabled", "model-value"])]),
      _: 3
    }, 16));
  }
}), CT = xT, ST = /* @__PURE__ */ b({
  __name: "TooltipArrow",
  props: {
    width: {
      type: Number,
      required: !1,
      default: 10
    },
    height: {
      type: Number,
      required: !1,
      default: 5
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "svg"
    }
  },
  setup(e) {
    const t = e;
    return j(), (n, a) => (h(), w(l(p$), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), $T = ST;
const [rf, BT] = Se("TooltipProvider");
var kT = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: {
      type: Number,
      required: !1,
      default: 700
    },
    skipDelayDuration: {
      type: Number,
      required: !1,
      default: 300
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: !1
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: !1
    }
  },
  setup(e) {
    const t = e, { delayDuration: n, skipDelayDuration: a, disableHoverableContent: r, disableClosingTrigger: o, ignoreNonKeyboardFocus: s, disabled: i } = qe(t);
    j();
    const u = I(!0), d = I(!1), { start: c, stop: f } = ah(() => {
      u.value = !0;
    }, a, { immediate: !1 });
    return BT({
      isOpenDelayed: u,
      delayDuration: n,
      onOpen() {
        f(), u.value = !1;
      },
      onClose() {
        c();
      },
      isPointerInTransitRef: d,
      disableHoverableContent: r,
      disableClosingTrigger: o,
      disabled: i,
      ignoreNonKeyboardFocus: s
    }), (p, v) => _(p.$slots, "default");
  }
}), of = kT;
const hy = "tooltip.open", [Ni, PT] = Se("TooltipRoot");
var MT = /* @__PURE__ */ b({
  __name: "TooltipRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: !1,
      default: !1
    },
    open: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    delayDuration: {
      type: Number,
      required: !1,
      default: void 0
    },
    disableHoverableContent: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disableClosingTrigger: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: !1,
      default: void 0
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: !1,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    j();
    const r = rf(), o = A(() => n.disableHoverableContent ?? r.disableHoverableContent.value), s = A(() => n.disableClosingTrigger ?? r.disableClosingTrigger.value), i = A(() => n.disabled ?? r.disabled.value), u = A(() => n.delayDuration ?? r.delayDuration.value), d = A(() => n.ignoreNonKeyboardFocus ?? r.ignoreNonKeyboardFocus.value), c = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    me(c, ($) => {
      r.onClose && ($ ? (r.onOpen(), document.dispatchEvent(new CustomEvent(hy))) : r.onClose());
    });
    const f = I(!1), p = I(), v = A(() => c.value ? f.value ? "delayed-open" : "instant-open" : "closed"), { start: m, stop: y } = ah(() => {
      f.value = !0, c.value = !0;
    }, u, { immediate: !1 });
    function x() {
      y(), f.value = !1, c.value = !0;
    }
    function C() {
      y(), c.value = !1;
    }
    function S() {
      m();
    }
    return PT({
      contentId: "",
      open: c,
      stateAttribute: v,
      trigger: p,
      onTriggerChange($) {
        p.value = $;
      },
      onTriggerEnter() {
        r.isOpenDelayed.value ? S() : x();
      },
      onTriggerLeave() {
        o.value ? C() : y();
      },
      onOpen: x,
      onClose: C,
      disableHoverableContent: o,
      disableClosingTrigger: s,
      disabled: i,
      ignoreNonKeyboardFocus: d
    }), ($, k) => (h(), w(l(or), null, {
      default: g(() => [_($.$slots, "default", { open: l(c) })]),
      _: 3
    }));
  }
}), DT = MT, qT = /* @__PURE__ */ b({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1,
      default: 0
    },
    align: {
      type: null,
      required: !1,
      default: "center"
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1,
      default: !0
    },
    collisionBoundary: {
      type: null,
      required: !1,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1,
      default: 0
    },
    arrowPadding: {
      type: Number,
      required: !1,
      default: 0
    },
    sticky: {
      type: String,
      required: !1,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1,
      default: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ni(), { forwardRef: o, currentElement: s } = j(), i = A(() => n.ariaLabel || s.value?.textContent), u = A(() => {
      const { ariaLabel: d, ...c } = n;
      return c;
    });
    return Ce(() => {
      ct(window, "scroll", (d) => {
        d.target?.contains(r.trigger.value) && r.onClose();
      }), ct(window, hy, r.onClose);
    }), (d, c) => (h(), w(l(Oa), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: c[0] || (c[0] = (f) => a("escapeKeyDown", f)),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        l(r).disableClosingTrigger.value && l(r).trigger.value?.contains(f.target) && f.preventDefault(), a("pointerDownOutside", f);
      }),
      onFocusOutside: c[2] || (c[2] = Ye(() => {
      }, ["prevent"])),
      onDismiss: c[3] || (c[3] = (f) => l(r).onClose())
    }, {
      default: g(() => [N(l(Kr), T({
        ref: l(o),
        "data-state": l(r).stateAttribute.value
      }, {
        ...d.$attrs,
        ...u.value
      }, { style: {
        "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
        "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
        "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: g(() => [_(d.$slots, "default"), N(l(Ci), {
          id: l(r).contentId,
          role: "tooltip"
        }, {
          default: g(() => [Re(Fe(i.value), 1)]),
          _: 1
        }, 8, ["id"])]),
        _: 3
      }, 16, ["data-state"])]),
      _: 3
    }));
  }
}), gy = qT, AT = /* @__PURE__ */ b({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  setup(e) {
    const n = he(e), { forwardRef: a, currentElement: r } = j(), { trigger: o, onClose: s } = Ni(), i = rf(), { isPointerInTransit: u, onPointerExit: d } = Eh(o, r);
    return i.isPointerInTransitRef = u, d(() => {
      s();
    }), (c, f) => (h(), w(gy, T({ ref: l(a) }, l(n)), {
      default: g(() => [_(c.$slots, "default")]),
      _: 3
    }, 16));
  }
}), ET = AT, TT = /* @__PURE__ */ b({
  __name: "TooltipContent",
  props: {
    forceMount: {
      type: Boolean,
      required: !1
    },
    ariaLabel: {
      type: String,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1
    },
    side: {
      type: null,
      required: !1,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: !1
    },
    align: {
      type: null,
      required: !1
    },
    alignOffset: {
      type: Number,
      required: !1
    },
    avoidCollisions: {
      type: Boolean,
      required: !1
    },
    collisionBoundary: {
      type: null,
      required: !1
    },
    collisionPadding: {
      type: [Number, Object],
      required: !1
    },
    arrowPadding: {
      type: Number,
      required: !1
    },
    sticky: {
      type: String,
      required: !1
    },
    hideWhenDetached: {
      type: Boolean,
      required: !1
    },
    positionStrategy: {
      type: String,
      required: !1
    },
    updatePositionStrategy: {
      type: String,
      required: !1
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Ni(), o = ve(n, a), { forwardRef: s } = j();
    return (i, u) => (h(), w(l(yt), { present: i.forceMount || l(r).open.value }, {
      default: g(() => [(h(), w(Pt(l(r).disableHoverableContent.value ? gy : ET), T({ ref: l(s) }, l(o)), {
        default: g(() => [_(i.$slots, "default")]),
        _: 3
      }, 16))]),
      _: 3
    }, 8, ["present"]));
  }
}), IT = TT, OT = /* @__PURE__ */ b({
  __name: "TooltipPortal",
  props: {
    to: {
      type: null,
      required: !1
    },
    disabled: {
      type: Boolean,
      required: !1
    },
    defer: {
      type: Boolean,
      required: !1
    },
    forceMount: {
      type: Boolean,
      required: !1
    }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ra), oe(le(t)), {
      default: g(() => [_(n.$slots, "default")]),
      _: 3
    }, 16));
  }
}), RT = OT, VT = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {
      type: null,
      required: !1
    },
    asChild: {
      type: Boolean,
      required: !1
    },
    as: {
      type: null,
      required: !1,
      default: "button"
    }
  },
  setup(e) {
    const t = e, n = Ni(), a = rf();
    n.contentId ||= Ke(void 0, "reka-tooltip-content");
    const { forwardRef: r, currentElement: o } = j(), s = I(!1), i = I(!1), u = A(() => n.disabled.value ? {} : {
      click: y,
      focus: v,
      pointermove: f,
      pointerleave: p,
      pointerdown: c,
      blur: m
    });
    Ce(() => {
      n.onTriggerChange(o.value);
    });
    function d() {
      setTimeout(() => {
        s.value = !1;
      }, 1);
    }
    function c() {
      n.open && !n.disableClosingTrigger.value && n.onClose(), s.value = !0, document.addEventListener("pointerup", d, { once: !0 });
    }
    function f(x) {
      x.pointerType !== "touch" && !i.value && !a.isPointerInTransitRef.value && (n.onTriggerEnter(), i.value = !0);
    }
    function p() {
      n.onTriggerLeave(), i.value = !1;
    }
    function v(x) {
      s.value || n.ignoreNonKeyboardFocus.value && !x.target.matches?.(":focus-visible") || n.onOpen();
    }
    function m() {
      n.onClose();
    }
    function y() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (x, C) => (h(), w(l(sr), {
      "as-child": "",
      reference: x.reference
    }, {
      default: g(() => [N(l(X), T({
        ref: l(r),
        "aria-describedby": l(n).open.value ? l(n).contentId : void 0,
        "data-state": l(n).stateAttribute.value,
        as: x.as,
        "as-child": t.asChild,
        "data-grace-area-trigger": ""
      }, i0(u.value)), {
        default: g(() => [_(x.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-describedby",
        "data-state",
        "as",
        "as-child"
      ])]),
      _: 3
    }, 8, ["reference"]));
  }
}), FT = VT;
function yy(e) {
  var t, n, a = "";
  if (typeof e == "string" || typeof e == "number") a += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = yy(e[t])) && (a && (a += " "), a += n);
  } else for (n in e) e[n] && (a && (a += " "), a += n);
  return a;
}
function by() {
  for (var e, t, n = 0, a = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = yy(e)) && (a && (a += " "), a += t);
  return a;
}
const NT = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let a = 0; a < e.length; a++)
    n[a] = e[a];
  for (let a = 0; a < t.length; a++)
    n[e.length + a] = t[a];
  return n;
}, LT = (e, t) => ({
  classGroupId: e,
  validator: t
}), _y = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), Ol = "-", sv = [], zT = "arbitrary..", HT = (e) => {
  const t = jT(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: a
  } = e;
  return {
    getClassGroupId: (s) => {
      if (s.startsWith("[") && s.endsWith("]"))
        return UT(s);
      const i = s.split(Ol), u = i[0] === "" && i.length > 1 ? 1 : 0;
      return wy(i, u, t);
    },
    getConflictingClassGroupIds: (s, i) => {
      if (i) {
        const u = a[s], d = n[s];
        return u ? d ? NT(d, u) : u : d || sv;
      }
      return n[s] || sv;
    }
  };
}, wy = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const r = e[t], o = n.nextPart.get(r);
  if (o) {
    const d = wy(e, t + 1, o);
    if (d) return d;
  }
  const s = n.validators;
  if (s === null)
    return;
  const i = t === 0 ? e.join(Ol) : e.slice(t).join(Ol), u = s.length;
  for (let d = 0; d < u; d++) {
    const c = s[d];
    if (c.validator(i))
      return c.classGroupId;
  }
}, UT = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), a = t.slice(0, n);
  return a ? zT + a : void 0;
})(), jT = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return WT(n, t);
}, WT = (e, t) => {
  const n = _y();
  for (const a in e) {
    const r = e[a];
    sf(r, n, a, t);
  }
  return n;
}, sf = (e, t, n, a) => {
  const r = e.length;
  for (let o = 0; o < r; o++) {
    const s = e[o];
    GT(s, t, n, a);
  }
}, GT = (e, t, n, a) => {
  if (typeof e == "string") {
    KT(e, t, n);
    return;
  }
  if (typeof e == "function") {
    YT(e, t, n, a);
    return;
  }
  XT(e, t, n, a);
}, KT = (e, t, n) => {
  const a = e === "" ? t : xy(t, e);
  a.classGroupId = n;
}, YT = (e, t, n, a) => {
  if (JT(e)) {
    sf(e(a), t, n, a);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(LT(n, e));
}, XT = (e, t, n, a) => {
  const r = Object.entries(e), o = r.length;
  for (let s = 0; s < o; s++) {
    const [i, u] = r[s];
    sf(u, xy(t, i), n, a);
  }
}, xy = (e, t) => {
  let n = e;
  const a = t.split(Ol), r = a.length;
  for (let o = 0; o < r; o++) {
    const s = a[o];
    let i = n.nextPart.get(s);
    i || (i = _y(), n.nextPart.set(s, i)), n = i;
  }
  return n;
}, JT = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, ZT = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
  const r = (o, s) => {
    n[o] = s, t++, t > e && (t = 0, a = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(o) {
      let s = n[o];
      if (s !== void 0)
        return s;
      if ((s = a[o]) !== void 0)
        return r(o, s), s;
    },
    set(o, s) {
      o in n ? n[o] = s : r(o, s);
    }
  };
}, wd = "!", lv = ":", QT = [], iv = (e, t, n, a, r) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: a,
  isExternal: r
}), e2 = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let a = (r) => {
    const o = [];
    let s = 0, i = 0, u = 0, d;
    const c = r.length;
    for (let y = 0; y < c; y++) {
      const x = r[y];
      if (s === 0 && i === 0) {
        if (x === lv) {
          o.push(r.slice(u, y)), u = y + 1;
          continue;
        }
        if (x === "/") {
          d = y;
          continue;
        }
      }
      x === "[" ? s++ : x === "]" ? s-- : x === "(" ? i++ : x === ")" && i--;
    }
    const f = o.length === 0 ? r : r.slice(u);
    let p = f, v = !1;
    f.endsWith(wd) ? (p = f.slice(0, -1), v = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      f.startsWith(wd) && (p = f.slice(1), v = !0)
    );
    const m = d && d > u ? d - u : void 0;
    return iv(o, v, p, m);
  };
  if (t) {
    const r = t + lv, o = a;
    a = (s) => s.startsWith(r) ? o(s.slice(r.length)) : iv(QT, !1, s, void 0, !0);
  }
  if (n) {
    const r = a;
    a = (o) => n({
      className: o,
      parseClassName: r
    });
  }
  return a;
}, t2 = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, a) => {
    t.set(n, 1e6 + a);
  }), (n) => {
    const a = [];
    let r = [];
    for (let o = 0; o < n.length; o++) {
      const s = n[o], i = s[0] === "[", u = t.has(s);
      i || u ? (r.length > 0 && (r.sort(), a.push(...r), r = []), a.push(s)) : r.push(s);
    }
    return r.length > 0 && (r.sort(), a.push(...r)), a;
  };
}, n2 = (e) => ({
  cache: ZT(e.cacheSize),
  parseClassName: e2(e),
  sortModifiers: t2(e),
  ...HT(e)
}), a2 = /\s+/, r2 = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: a,
    getConflictingClassGroupIds: r,
    sortModifiers: o
  } = t, s = [], i = e.trim().split(a2);
  let u = "";
  for (let d = i.length - 1; d >= 0; d -= 1) {
    const c = i[d], {
      isExternal: f,
      modifiers: p,
      hasImportantModifier: v,
      baseClassName: m,
      maybePostfixModifierPosition: y
    } = n(c);
    if (f) {
      u = c + (u.length > 0 ? " " + u : u);
      continue;
    }
    let x = !!y, C = a(x ? m.substring(0, y) : m);
    if (!C) {
      if (!x) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      if (C = a(m), !C) {
        u = c + (u.length > 0 ? " " + u : u);
        continue;
      }
      x = !1;
    }
    const S = p.length === 0 ? "" : p.length === 1 ? p[0] : o(p).join(":"), $ = v ? S + wd : S, k = $ + C;
    if (s.indexOf(k) > -1)
      continue;
    s.push(k);
    const B = r(C, x);
    for (let P = 0; P < B.length; ++P) {
      const M = B[P];
      s.push($ + M);
    }
    u = c + (u.length > 0 ? " " + u : u);
  }
  return u;
}, o2 = (...e) => {
  let t = 0, n, a, r = "";
  for (; t < e.length; )
    (n = e[t++]) && (a = Cy(n)) && (r && (r += " "), r += a);
  return r;
}, Cy = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let a = 0; a < e.length; a++)
    e[a] && (t = Cy(e[a])) && (n && (n += " "), n += t);
  return n;
}, s2 = (e, ...t) => {
  let n, a, r, o;
  const s = (u) => {
    const d = t.reduce((c, f) => f(c), e());
    return n = n2(d), a = n.cache.get, r = n.cache.set, o = i, i(u);
  }, i = (u) => {
    const d = a(u);
    if (d)
      return d;
    const c = r2(u, n);
    return r(u, c), c;
  };
  return o = s, (...u) => o(o2(...u));
}, l2 = [], kt = (e) => {
  const t = (n) => n[e] || l2;
  return t.isThemeGetter = !0, t;
}, Sy = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, $y = /^\((?:(\w[\w-]*):)?(.+)\)$/i, i2 = /^\d+\/\d+$/, u2 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, d2 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, c2 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, f2 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, p2 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, br = (e) => i2.test(e), ze = (e) => !!e && !Number.isNaN(Number(e)), _a = (e) => !!e && Number.isInteger(Number(e)), Au = (e) => e.endsWith("%") && ze(e.slice(0, -1)), Qn = (e) => u2.test(e), v2 = () => !0, m2 = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  d2.test(e) && !c2.test(e)
), By = () => !1, h2 = (e) => f2.test(e), g2 = (e) => p2.test(e), y2 = (e) => !$e(e) && !Be(e), b2 = (e) => Qr(e, My, By), $e = (e) => Sy.test(e), La = (e) => Qr(e, Dy, m2), Eu = (e) => Qr(e, S2, ze), uv = (e) => Qr(e, ky, By), _2 = (e) => Qr(e, Py, g2), Hs = (e) => Qr(e, qy, h2), Be = (e) => $y.test(e), uo = (e) => eo(e, Dy), w2 = (e) => eo(e, $2), dv = (e) => eo(e, ky), x2 = (e) => eo(e, My), C2 = (e) => eo(e, Py), Us = (e) => eo(e, qy, !0), Qr = (e, t, n) => {
  const a = Sy.exec(e);
  return a ? a[1] ? t(a[1]) : n(a[2]) : !1;
}, eo = (e, t, n = !1) => {
  const a = $y.exec(e);
  return a ? a[1] ? t(a[1]) : n : !1;
}, ky = (e) => e === "position" || e === "percentage", Py = (e) => e === "image" || e === "url", My = (e) => e === "length" || e === "size" || e === "bg-size", Dy = (e) => e === "length", S2 = (e) => e === "number", $2 = (e) => e === "family-name", qy = (e) => e === "shadow", B2 = () => {
  const e = kt("color"), t = kt("font"), n = kt("text"), a = kt("font-weight"), r = kt("tracking"), o = kt("leading"), s = kt("breakpoint"), i = kt("container"), u = kt("spacing"), d = kt("radius"), c = kt("shadow"), f = kt("inset-shadow"), p = kt("text-shadow"), v = kt("drop-shadow"), m = kt("blur"), y = kt("perspective"), x = kt("aspect"), C = kt("ease"), S = kt("animate"), $ = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], k = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], B = () => [...k(), Be, $e], P = () => ["auto", "hidden", "clip", "visible", "scroll"], M = () => ["auto", "contain", "none"], q = () => [Be, $e, u], E = () => [br, "full", "auto", ...q()], D = () => [_a, "none", "subgrid", Be, $e], O = () => ["auto", {
    span: ["full", _a, Be, $e]
  }, _a, Be, $e], F = () => [_a, "auto", Be, $e], J = () => ["auto", "min", "max", "fr", Be, $e], ne = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], Q = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], W = () => ["auto", ...q()], H = () => [br, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...q()], U = () => [e, Be, $e], se = () => [...k(), dv, uv, {
    position: [Be, $e]
  }], ee = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], de = () => ["auto", "cover", "contain", x2, b2, {
    size: [Be, $e]
  }], fe = () => [Au, uo, La], _e = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    d,
    Be,
    $e
  ], ye = () => ["", ze, uo, La], Ee = () => ["solid", "dashed", "dotted", "double"], ce = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], V = () => [ze, Au, dv, uv], te = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    m,
    Be,
    $e
  ], z = () => ["none", ze, Be, $e], re = () => ["none", ze, Be, $e], ie = () => [ze, Be, $e], L = () => [br, "full", ...q()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Qn],
      breakpoint: [Qn],
      color: [v2],
      container: [Qn],
      "drop-shadow": [Qn],
      ease: ["in", "out", "in-out"],
      font: [y2],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Qn],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Qn],
      shadow: [Qn],
      spacing: ["px", ze],
      text: [Qn],
      "text-shadow": [Qn],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", br, $e, Be, x]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [ze, $e, Be, i]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": $()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": $()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: B()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: P()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": P()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": P()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: M()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": M()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": M()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: E()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": E()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": E()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: E()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: E()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: E()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: E()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: E()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: E()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [_a, "auto", Be, $e]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [br, "full", "auto", i, ...q()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [ze, br, "auto", "initial", "none", $e]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", ze, Be, $e]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", ze, Be, $e]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [_a, "first", "last", "none", Be, $e]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": D()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: O()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": F()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": F()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": D()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: O()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": F()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": F()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": J()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": J()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: q()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": q()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": q()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ne(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...Q(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...Q()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ne()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...Q(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ne()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...Q(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...Q()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: q()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: q()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: q()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: q()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: q()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: q()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: q()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: q()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: q()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: W()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: W()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: W()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: W()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: W()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: W()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: W()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: W()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: W()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": q()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": q()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: H()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [i, "screen", ...H()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          i,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...H()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          i,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...H()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...H()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...H()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...H()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, uo, La]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [a, Be, Eu]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Au, $e]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [w2, $e, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [r, Be, $e]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [ze, "none", Be, Eu]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          o,
          ...q()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Be, $e]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", Be, $e]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: U()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: U()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Ee(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [ze, "from-font", "auto", Be, La]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: U()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [ze, "auto", Be, $e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: q()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Be, $e]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Be, $e]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: se()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ee()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: de()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, _a, Be, $e],
          radial: ["", Be, $e],
          conic: [_a, Be, $e]
        }, C2, _2]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: U()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: fe()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: fe()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: fe()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: U()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: U()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: U()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: _e()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": _e()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": _e()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": _e()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": _e()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": _e()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": _e()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": _e()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": _e()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": _e()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": _e()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": _e()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": _e()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": _e()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": _e()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ye()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ye()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ye()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ye()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ye()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ye()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ye()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ye()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ye()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ye()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ye()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Ee(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...Ee(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: U()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": U()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": U()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": U()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": U()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": U()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": U()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": U()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": U()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: U()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...Ee(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [ze, Be, $e]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", ze, uo, La]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: U()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          c,
          Us,
          Hs
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: U()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", f, Us, Hs]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": U()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ye()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: U()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [ze, La]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": U()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ye()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": U()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", p, Us, Hs]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": U()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [ze, Be, $e]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...ce(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": ce()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [ze]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": V()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": V()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": U()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": U()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": V()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": V()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": U()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": U()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": V()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": V()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": U()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": U()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": V()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": V()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": U()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": U()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": V()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": V()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": U()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": U()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": V()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": V()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": U()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": U()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": V()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": V()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": U()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": U()
      }],
      "mask-image-radial": [{
        "mask-radial": [Be, $e]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": V()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": V()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": U()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": U()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": k()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [ze]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": V()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": V()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": U()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": U()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: se()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: ee()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: de()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", Be, $e]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Be,
          $e
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: te()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [ze, Be, $e]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [ze, Be, $e]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          v,
          Us,
          Hs
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": U()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", ze, Be, $e]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [ze, Be, $e]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", ze, Be, $e]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [ze, Be, $e]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", ze, Be, $e]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          Be,
          $e
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": te()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [ze, Be, $e]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [ze, Be, $e]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", ze, Be, $e]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [ze, Be, $e]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", ze, Be, $e]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [ze, Be, $e]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [ze, Be, $e]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", ze, Be, $e]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": q()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": q()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": q()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", Be, $e]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [ze, "initial", Be, $e]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", C, Be, $e]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [ze, Be, $e]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", S, Be, $e]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [y, Be, $e]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": B()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: z()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": z()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": z()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": z()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: re()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": re()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": re()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": re()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: ie()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": ie()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": ie()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [Be, $e, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: B()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: L()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": L()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": L()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": L()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: U()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: U()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Be, $e]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": q()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": q()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": q()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": q()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": q()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": q()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": q()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": q()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": q()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": q()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": q()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": q()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": q()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": q()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": q()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": q()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": q()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": q()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Be, $e]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...U()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [ze, uo, La, Eu]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...U()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, k2 = /* @__PURE__ */ s2(B2);
function R(...e) {
  return k2(by(e));
}
function sH(e, t) {
  t.value = typeof e == "function" ? e(t.value) : e;
}
function lH(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(s) => {
    const i = xn(a, s);
    if (i || i === null) return i;
    throw new Error(
      `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(", ")}` : `\`${e}\``}`
    );
  }, (s) => (Kn(a, s), s)];
}
function iH() {
  const e = wl("(max-width: 768px)"), t = wl("(min-width: 769px) and (max-width: 1024px)"), n = I(!1);
  Ce(() => {
    n.value = "ontouchstart" in window || navigator.maxTouchPoints > 0;
  });
  const a = A(() => e.value || t.value);
  return {
    isMobile: e,
    isTablet: t,
    isTouchDevice: n,
    isSmallScreen: a
  };
}
function uH(e, t = {}) {
  const { threshold: n = 50, enabled: a = !0, onSwipeLeft: r, onSwipeRight: o } = t, { direction: s, lengthX: i } = ew(e, {
    passive: !0,
    onSwipeEnd() {
      a && Math.abs(i.value) >= n && (s.value === "left" && r ? r() : s.value === "right" && o && o());
    }
  });
  return {
    direction: s,
    lengthX: i
  };
}
function dH() {
  const e = I(!0);
  let t = 0, n = !1;
  const a = () => {
    n || (window.requestAnimationFrame(() => {
      const r = window.scrollY, o = r - t;
      o > 10 && r > 100 ? e.value = !1 : o < -10 && (e.value = !0), t = r, n = !1;
    }), n = !0);
  };
  return Ce(() => {
    window.addEventListener("scroll", a, { passive: !0 });
  }), nt(() => {
    window.removeEventListener("scroll", a);
  }), {
    isVisible: e
  };
}
const P2 = /* @__PURE__ */ b({
  __name: "AlertDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(Vx), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cv = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, fv = by, an = (e, t) => (n) => {
  var a;
  if (t?.variants == null) return fv(e, n?.class, n?.className);
  const { variants: r, defaultVariants: o } = t, s = Object.keys(r).map((d) => {
    const c = n?.[d], f = o?.[d];
    if (c === null) return null;
    const p = cv(c) || cv(f);
    return r[d][p];
  }), i = n && Object.entries(n).reduce((d, c) => {
    let [f, p] = c;
    return p === void 0 || (d[f] = p), d;
  }, {}), u = t == null || (a = t.compoundVariants) === null || a === void 0 ? void 0 : a.reduce((d, c) => {
    let { class: f, className: p, ...v } = c;
    return Object.entries(v).every((m) => {
      let [y, x] = m;
      return Array.isArray(x) ? x.includes({
        ...o,
        ...i
      }[y]) : {
        ...o,
        ...i
      }[y] === x;
    }) ? [
      ...d,
      f,
      p
    ] : d;
  }, []);
  return fv(e, s, u, n?.class, n?.className);
}, bs = /* @__PURE__ */ b({
  __name: "Button",
  props: {
    variant: {},
    size: {},
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      "data-slot": "button",
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(R)(l(Kt)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Kt = an(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        xs: "h-7 rounded px-2",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), M2 = /* @__PURE__ */ b({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Sx), T(l(n), {
      class: l(R)(l(Kt)(), t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), D2 = /* @__PURE__ */ b({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Dx), T(l(n), {
      class: l(R)(l(Kt)({ variant: "outline" }), "mt-2 sm:mt-0", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), q2 = /* @__PURE__ */ b({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(Ox), null, {
      default: g(() => [
        N(l(Tx), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(Px), T(l(o), {
          class: l(R)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: g(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), A2 = /* @__PURE__ */ b({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Ax), T(l(n), {
      class: l(R)("text-sm text-muted-foreground", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), E2 = /* @__PURE__ */ b({
  __name: "AlertDialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), T2 = /* @__PURE__ */ b({
  __name: "AlertDialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("flex flex-col gap-y-2 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), I2 = /* @__PURE__ */ b({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Nx), T(l(n), {
      class: l(R)("text-lg font-semibold", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cH = /* @__PURE__ */ b({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(zx), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fH = /* @__PURE__ */ b({
  __name: "ConfirmDialog",
  setup(e) {
    const { isOpen: t, close: n, cancelButton: a, actionButton: r, title: o, description: s, variant: i } = V2();
    return (u, d) => (h(), w(l(P2), { open: l(t) }, {
      default: g(() => [
        N(l(q2), {
          onEscapeKeyDown: l(n),
          onPointerDownOutside: l(n)
        }, {
          default: g(() => [
            N(l(T2), null, {
              default: g(() => [
                N(l(I2), null, {
                  default: g(() => [
                    Re(Fe(l(o)), 1)
                  ]),
                  _: 1
                }),
                N(l(A2), null, {
                  default: g(() => [
                    Re(Fe(l(s)), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            N(l(E2), null, {
              default: g(() => [
                N(l(D2), {
                  onClick: l(a).handler
                }, {
                  default: g(() => [
                    Re(Fe(l(a).label ?? "Cancel"), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                N(l(M2), {
                  variant: l(i),
                  onClick: l(r).handler
                }, {
                  default: g(() => [
                    Re(Fe(l(r).label ?? "Confirm"), 1)
                  ]),
                  _: 1
                }, 8, ["variant", "onClick"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["onEscapeKeyDown", "onPointerDownOutside"])
      ]),
      _: 1
    }, 8, ["open"]));
  }
}), lf = I(!1), Ay = I(""), Ey = I(""), Ty = I(null), Iy = I({
  label: void 0,
  handler: () => {
  }
}), Oy = I({
  label: void 0,
  handler: () => {
  }
}), O2 = (e) => {
  Ay.value = e.title, Ey.value = e.description, Ty.value = e.variant, Iy.value = pv(e.cancelAction), Oy.value = pv(e.action), R2();
}, pv = (e) => typeof e == "string" ? {
  label: e,
  handler: il
} : typeof e == "function" ? {
  label: void 0,
  handler: e
} : typeof e == "object" && e !== void 0 ? {
  label: e.label ?? void 0,
  handler: e.handler ?? il
} : {
  label: void 0,
  handler: il
}, il = () => {
  lf.value = !1;
}, R2 = () => {
  lf.value = !0;
};
function V2() {
  return {
    confirmDialog: (e) => O2(e),
    title: Ay,
    description: Ey,
    variant: Ty,
    isOpen: lf,
    close: il,
    cancelButton: Iy,
    actionButton: Oy
  };
}
const cr = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t)
    n[a] = r;
  return n;
}, F2 = {}, N2 = { class: "h-full bg-background dark:text-white" };
function L2(e, t) {
  return h(), G("div", N2, [
    _(e.$slots, "default")
  ]);
}
const pH = /* @__PURE__ */ cr(F2, [["render", L2]]), z2 = {}, H2 = { class: "sticky top-0 z-50 flex h-16 shrink-0 items-center gap-x-4 bg-background/60 px-4 backdrop-blur sm:gap-x-6 sm:px-6 lg:px-8" };
function U2(e, t) {
  return h(), G("header", H2, [
    _(e.$slots, "default")
  ]);
}
const vH = /* @__PURE__ */ cr(z2, [["render", U2]]), j2 = {}, W2 = { class: "px-4 py-6 sm:px-6 lg:px-8 lg:pl-72" };
function G2(e, t) {
  return h(), G("main", W2, [
    _(e.$slots, "default")
  ]);
}
const mH = /* @__PURE__ */ cr(j2, [["render", G2]]), K2 = {};
function Y2(e, t) {
  return _(e.$slots, "default");
}
const hH = /* @__PURE__ */ cr(K2, [["render", Y2]]), X2 = {}, J2 = { class: "hidden px-6 py-6 lg:fixed lg:inset-y-0 lg:top-16 lg:z-50 lg:flex lg:w-72 lg:flex-col" }, Z2 = { class: "gap-y-5 overflow-y-auto" };
function Q2(e, t) {
  return h(), G("div", J2, [
    we("div", Z2, [
      _(e.$slots, "default")
    ])
  ]);
}
const gH = /* @__PURE__ */ cr(X2, [["render", Q2]]), eI = {};
function tI(e, t) {
  return _(e.$slots, "default");
}
const yH = /* @__PURE__ */ cr(eI, [["render", tI]]);
const vv = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), nI = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, a) => a ? a.toUpperCase() : n.toLowerCase()
), aI = (e) => {
  const t = nI(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
}, rI = (...e) => e.filter((t, n, a) => !!t && t.trim() !== "" && a.indexOf(t) === n).join(" ").trim(), mv = (e) => e === "";
var co = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
const oI = ({
  name: e,
  iconNode: t,
  absoluteStrokeWidth: n,
  "absolute-stroke-width": a,
  strokeWidth: r,
  "stroke-width": o,
  size: s = co.width,
  color: i = co.stroke,
  ...u
}, { slots: d }) => tn(
  "svg",
  {
    ...co,
    ...u,
    width: s,
    height: s,
    stroke: i,
    "stroke-width": mv(n) || mv(a) || n === !0 || a === !0 ? Number(r || o || co["stroke-width"]) * 24 / Number(s) : r || o || co["stroke-width"],
    class: rI(
      "lucide",
      u.class,
      ...e ? [`lucide-${vv(aI(e))}-icon`, `lucide-${vv(e)}`] : ["lucide-icon"]
    )
  },
  [...t.map((c) => tn(...c)), ...d.default ? [d.default()] : []]
);
const bt = (e, t) => (n, { slots: a, attrs: r }) => tn(
  oI,
  {
    ...r,
    ...n,
    iconNode: t,
    name: e
  },
  a
);
const sI = bt("arrow-left", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
const lI = bt("arrow-right", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
const to = bt("check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
const Li = bt("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
const zi = bt("chevron-left", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
const Fa = bt("chevron-right", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
const iI = bt("chevron-up", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }]
]);
const Ry = bt("circle-check", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]
]);
const uf = bt("circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
const Vy = bt("ellipsis", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
]);
const uI = bt("grip-vertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
const Fy = bt("info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
const df = bt("loader-circle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
const dI = bt("menu", [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
]);
const cf = bt("minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
const Ny = bt("octagon-x", [
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  [
    "path",
    {
      d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z",
      key: "2d38gg"
    }
  ],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
const Ly = bt("panel-left", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
const cI = bt("plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
const fI = bt("search", [
  ["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }],
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]
]);
const zy = bt("triangle-alert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
const no = bt("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), pI = {
  type: "button",
  class: "-m-2.5 p-2.5 lg:hidden"
}, bH = /* @__PURE__ */ b({
  __name: "TwoColumnLayoutSidebarTrigger",
  setup(e) {
    return (t, n) => (h(), G("button", pI, [
      n[0] || (n[0] = we("span", { class: "sr-only" }, "Open sidebar", -1)),
      N(l(dI), {
        class: "h-6 w-6",
        "aria-hidden": "true"
      })
    ]));
  }
}), hv = "sidebar_state", vI = 3600 * 24 * 7, mI = "18rem", hI = "3rem", _H = "18rem", gI = "b", [_s, yI] = Se("CollapsibleTwoColumnLayout"), bI = ["data-state", "data-collapsible"], wH = /* @__PURE__ */ b({
  __name: "CollapsibleTwoColumnLayout",
  props: {
    defaultOpen: { type: Boolean, default: !rh?.cookie.includes(`${hv}=false`) },
    open: { type: Boolean, default: void 0 },
    collapsible: { default: "icon" },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = wl("(max-width: 1023px)"), o = I(!1), s = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen ?? !0,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, n.collapsible !== "none" && (document.cookie = `${hv}=${s.value}; path=/; max-age=${vI}`);
    }
    function u(f) {
      o.value = f;
    }
    function d() {
      return r.value ? u(!o.value) : i(!s.value);
    }
    n.collapsible !== "none" && ct("keydown", (f) => {
      f.key === gI && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = A(() => s.value ? "expanded" : "collapsed");
    return yI({
      state: c,
      open: s,
      setOpen: i,
      isMobile: r,
      openMobile: o,
      setOpenMobile: u,
      toggleSidebar: d,
      collapsible: n.collapsible
    }), (f, p) => (h(), w(l(of), { "delay-duration": 0 }, {
      default: g(() => [
        we("div", T({
          style: {
            "--collapsible-sidebar-width": l(mI),
            "--collapsible-sidebar-width-icon": l(hI)
          },
          class: l(R)("group/collapsible-layout h-full bg-background dark:text-white", n.class),
          "data-state": c.value,
          "data-collapsible": e.collapsible
        }, f.$attrs), [
          _(f.$slots, "default")
        ], 16, bI)
      ]),
      _: 3
    }));
  }
}), _I = ["data-state", "data-collapsible"], wI = { class: "flex-1 overflow-y-auto" }, xH = /* @__PURE__ */ b({
  __name: "CollapsibleSidebarDesktop",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = _s(), o = A(() => r === "icon" && n.value === "collapsed");
    return (s, i) => l(a) ? De("", !0) : (h(), G("div", {
      key: 0,
      class: ae(
        l(R)(
          "fixed inset-y-0 top-16 z-50 flex flex-col px-6 py-6 transition-[width] duration-200 ease-linear",
          o.value ? "w-[var(--collapsible-sidebar-width-icon)] px-2" : "w-[var(--collapsible-sidebar-width)]",
          t.class
        )
      ),
      "data-state": l(n),
      "data-collapsible": l(r)
    }, [
      we("div", wI, [
        _(s.$slots, "default")
      ])
    ], 10, _I));
  }
}), xI = ["data-state"], CH = /* @__PURE__ */ b({
  __name: "CollapsibleMain",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = _s(), o = A(() => r === "icon" && n.value === "collapsed");
    return (s, i) => (h(), G("main", {
      class: ae(
        l(R)(
          "px-4 py-6 transition-[padding-left] duration-200 ease-linear sm:px-6 lg:px-8",
          !l(a) && (o.value ? "lg:pl-[var(--collapsible-sidebar-width-icon)]" : "lg:pl-[var(--collapsible-sidebar-width)]"),
          t.class
        )
      ),
      "data-state": l(n)
    }, [
      _(s.$slots, "default")
    ], 10, xI));
  }
}), SH = /* @__PURE__ */ b({
  __name: "CollapsibleSidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n, collapsible: a } = _s();
    return (r, o) => l(a) !== "none" ? (h(), w(l(bs), {
      key: 0,
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: ae(l(R)("h-7 w-7", t.class)),
      onClick: l(n)
    }, {
      default: g(() => [
        N(l(Ly), { class: "h-5 w-5" }),
        o[0] || (o[0] = we("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"])) : De("", !0);
  }
}), $H = /* @__PURE__ */ b({
  __name: "Tip",
  props: {
    tooltip: {},
    indicator: { type: Boolean },
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(CI), null, {
      default: g(() => [
        N(l(ff), oe(le(l(r))), {
          default: g(() => [
            N(l(vf), {
              class: ae(e.indicator ? "underline decoration-dotted underline-offset-4" : "")
            }, {
              default: g(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(pf), oe(le(o.$attrs)), {
              default: g(() => [
                _(o.$slots, "tooltip", {}, () => [
                  Re(Fe(e.tooltip), 1)
                ])
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), ff = /* @__PURE__ */ b({
  __name: "Tooltip",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    delayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(DT), T({ "data-slot": "tooltip" }, l(r)), {
      default: g((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), pf = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: { default: 4 },
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(RT), null, {
      default: g(() => [
        N(l(IT), T({ "data-slot": "tooltip-content" }, { ...l(o), ...s.$attrs }, {
          class: l(R)(
            "z-50 w-fit animate-in rounded-md bg-foreground px-3 py-1.5 text-xs text-balance text-background fade-in-0 zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
            n.class
          )
        }), {
          default: g(() => [
            _(s.$slots, "default"),
            N(l($T), { class: "z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] bg-foreground fill-foreground" })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), CI = /* @__PURE__ */ b({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 0 },
    skipDelayDuration: {},
    disableHoverableContent: { type: Boolean },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(of), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vf = /* @__PURE__ */ b({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(FT), T({ "data-slot": "tooltip-trigger" }, t), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), SI = ["data-active", "data-collapsed"], $I = ["data-active", "data-collapsed"], BH = /* @__PURE__ */ b({
  __name: "CollapsibleMenuButton",
  props: {
    tooltip: {},
    active: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = _s(), o = A(() => r === "icon" && n.value === "collapsed"), s = A(() => t.tooltip && o.value && !a.value);
    return (i, u) => s.value ? (h(), w(l(ff), { key: 0 }, {
      default: g(() => [
        N(l(vf), { "as-child": "" }, {
          default: g(() => [
            we("button", {
              type: "button",
              class: ae(
                l(R)(
                  "flex w-full items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors",
                  "hover:bg-accent hover:text-accent-foreground",
                  e.active && "bg-accent text-accent-foreground",
                  o.value && "justify-center px-2",
                  t.class
                )
              ),
              "data-active": e.active,
              "data-collapsed": o.value
            }, [
              _(i.$slots, "default")
            ], 10, SI)
          ]),
          _: 3
        }),
        N(l(pf), {
          side: "right",
          align: "center"
        }, {
          default: g(() => [
            typeof e.tooltip == "string" ? (h(), G(Ge, { key: 0 }, [
              Re(Fe(e.tooltip), 1)
            ], 64)) : (h(), w(Pt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        })
      ]),
      _: 3
    })) : (h(), G("button", {
      key: 1,
      type: "button",
      class: ae(
        l(R)(
          "flex w-full items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors",
          "hover:bg-accent hover:text-accent-foreground",
          e.active && "bg-accent text-accent-foreground",
          o.value && "justify-center px-2",
          t.class
        )
      ),
      "data-active": e.active,
      "data-collapsed": o.value
    }, [
      _(i.$slots, "default")
    ], 10, $I));
  }
}), BI = {
  key: 0,
  class: "mb-2 block px-3 text-xs font-semibold tracking-wider text-muted-foreground uppercase"
}, kH = /* @__PURE__ */ b({
  __name: "CollapsibleMenuGroup",
  props: {
    label: {},
    class: {}
  },
  setup(e) {
    const t = e, { state: n, isMobile: a, collapsible: r } = _s(), o = A(
      () => r === "icon" && n.value === "collapsed" && !a.value
    );
    return (s, i) => (h(), G("div", {
      class: ae(l(R)("space-y-1", t.class))
    }, [
      e.label && !o.value ? (h(), G("span", BI, Fe(e.label), 1)) : De("", !0),
      _(s.$slots, "default")
    ], 2));
  }
});
let xd = 1;
var kI = class {
  subscribers;
  toasts;
  dismissedToasts;
  constructor() {
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
  subscribe = (e) => (this.subscribers.push(e), () => {
    const t = this.subscribers.indexOf(e);
    this.subscribers.splice(t, 1);
  });
  publish = (e) => {
    this.subscribers.forEach((t) => t(e));
  };
  addToast = (e) => {
    this.publish(e), this.toasts = [...this.toasts, e];
  };
  create = (e) => {
    const { message: t, ...n } = e, a = typeof e.id == "number" || e.id && e.id?.length > 0 ? e.id : xd++, r = this.toasts.find((s) => s.id === a), o = e.dismissible === void 0 ? !0 : e.dismissible;
    return this.dismissedToasts.has(a) && this.dismissedToasts.delete(a), r ? this.toasts = this.toasts.map((s) => s.id === a ? (this.publish({
      ...s,
      ...e,
      id: a,
      title: t
    }), {
      ...s,
      ...e,
      id: a,
      dismissible: o,
      title: t
    }) : s) : this.addToast({
      title: t,
      ...n,
      dismissible: o,
      id: a
    }), a;
  };
  dismiss = (e) => (e ? (this.dismissedToasts.add(e), requestAnimationFrame(() => this.subscribers.forEach((t) => t({
    id: e,
    dismiss: !0
  })))) : this.toasts.forEach((t) => {
    this.subscribers.forEach((n) => n({
      id: t.id,
      dismiss: !0
    }));
  }), e);
  message = (e, t) => this.create({
    ...t,
    message: e,
    type: "default"
  });
  error = (e, t) => this.create({
    ...t,
    type: "error",
    message: e
  });
  success = (e, t) => this.create({
    ...t,
    type: "success",
    message: e
  });
  info = (e, t) => this.create({
    ...t,
    type: "info",
    message: e
  });
  warning = (e, t) => this.create({
    ...t,
    type: "warning",
    message: e
  });
  loading = (e, t) => this.create({
    ...t,
    type: "loading",
    message: e
  });
  promise = (e, t) => {
    if (!t) return;
    let n;
    t.loading !== void 0 && (n = this.create({
      ...t,
      promise: e,
      type: "loading",
      message: t.loading,
      description: typeof t.description != "function" ? t.description : void 0
    }));
    const a = Promise.resolve(e instanceof Function ? e() : e);
    let r = n !== void 0, o;
    const s = a.then(async (u) => {
      if (o = ["resolve", u], so(u))
        r = !1, this.create({
          id: n,
          type: "default",
          message: u
        });
      else if (MI(u) && !u.ok) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(`HTTP error! status: ${u.status}`) : t.error, f = typeof t.description == "function" ? await t.description(`HTTP error! status: ${u.status}`) : t.description, v = typeof c == "object" && !so(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (u instanceof Error) {
        r = !1;
        const c = typeof t.error == "function" ? await t.error(u) : t.error, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !so(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: f,
          ...v
        });
      } else if (t.success !== void 0) {
        r = !1;
        const c = typeof t.success == "function" ? await t.success(u) : t.success, f = typeof t.description == "function" ? await t.description(u) : t.description, v = typeof c == "object" && !so(c) ? c : {
          message: c || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "success",
          description: f,
          ...v
        });
      }
    }).catch(async (u) => {
      if (o = ["reject", u], t.error !== void 0) {
        r = !1;
        const d = typeof t.error == "function" ? await t.error(u) : t.error, c = typeof t.description == "function" ? await t.description(u) : t.description, p = typeof d == "object" && !so(d) ? d : {
          message: d || "",
          id: n || ""
        };
        this.create({
          id: n,
          type: "error",
          description: c,
          ...p
        });
      }
    }).finally(() => {
      r && (this.dismiss(n), n = void 0), t.finally?.();
    }), i = () => new Promise((u, d) => s.then(() => o[0] === "reject" ? d(o[1]) : u(o[1])).catch(d));
    return typeof n != "string" && typeof n != "number" ? { unwrap: i } : Object.assign(n, { unwrap: i });
  };
  custom = (e, t) => {
    const n = t?.id || xd++, a = this.toasts.find((o) => o.id === n), r = t?.dismissible === void 0 ? !0 : t.dismissible;
    return this.dismissedToasts.has(n) && this.dismissedToasts.delete(n), a ? this.toasts = this.toasts.map((o) => o.id === n ? (this.publish({
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), {
      ...o,
      component: e,
      dismissible: r,
      id: n,
      ...t
    }) : o) : this.addToast({
      component: e,
      dismissible: r,
      id: n,
      ...t
    }), n;
  };
  getActiveToasts = () => this.toasts.filter((e) => !this.dismissedToasts.has(e.id));
};
const Xt = new kI();
function PI(e, t) {
  const n = t?.id || xd++;
  return Xt.create({
    message: e,
    id: n,
    type: "default",
    ...t
  }), n;
}
const MI = (e) => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", DI = PI, qI = () => Xt.toasts, AI = () => Xt.getActiveToasts(), fo = Object.assign(DI, {
  success: Xt.success,
  info: Xt.info,
  warning: Xt.warning,
  error: Xt.error,
  custom: Xt.custom,
  message: Xt.message,
  promise: Xt.promise,
  dismiss: Xt.dismiss,
  loading: Xt.loading
}, {
  getHistory: qI,
  getToasts: AI
});
function js(e) {
  return e.label !== void 0;
}
const EI = 3, Hy = "24px", Uy = "16px", gv = 4e3, TI = 356, II = 14, OI = 45, jy = 200;
function RI() {
  const e = I(!1);
  return Te(() => {
    const t = () => {
      e.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
  }), { isDocumentHidden: e };
}
function wa(...e) {
  return e.filter(Boolean).join(" ");
}
function VI(e) {
  const [t, n] = e.split("-"), a = [];
  return t && a.push(t), n && a.push(n), a;
}
function FI(e, t) {
  const n = {};
  return [e, t].forEach((a, r) => {
    const o = r === 1, s = o ? "--mobile-offset" : "--offset", i = o ? Uy : Hy;
    function u(d) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((c) => {
        n[`${s}-${c}`] = typeof d == "number" ? `${d}px` : d;
      });
    }
    typeof a == "number" || typeof a == "string" ? u(a) : typeof a == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((d) => {
      a[d] === void 0 ? n[`${s}-${d}`] = i : n[`${s}-${d}`] = typeof a[d] == "number" ? `${a[d]}px` : a[d];
    }) : u(i);
  }), n;
}
const NI = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded",
  "data-testid"
], LI = [
  "aria-label",
  "data-disabled",
  "data-close-button-position"
];
var zI = /* @__PURE__ */ b({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    closeButtonPosition: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, r = I(null), o = I(null), s = I(!1), i = I(!1), u = I(!1), d = I(!1), c = I(!1), f = I(0), p = I(0), v = I(n.toast.duration || n.duration || gv), m = I(null), y = I(null), x = A(() => n.index === 0), C = A(() => n.index + 1 <= n.visibleToasts), S = A(() => n.toast.type), $ = A(() => n.toast.dismissible !== !1), k = A(() => n.toast.class || ""), B = A(() => n.descriptionClass || ""), P = A(() => {
      const V = n.toast.position || n.position, z = n.heights.filter((re) => re.position === V).findIndex((re) => re.toastId === n.toast.id);
      return z >= 0 ? z : 0;
    }), M = A(() => {
      const V = n.toast.position || n.position;
      return n.heights.filter((z) => z.position === V).reduce((z, re, ie) => ie >= P.value ? z : z + re.height, 0);
    }), q = A(() => P.value * n.gap + M.value || 0), E = A(() => n.toast.closeButton ?? n.closeButton), D = A(() => n.toast.duration || n.duration || gv), O = I(0), F = I(0), J = I(null), ne = A(() => n.position.split("-")), Q = A(() => ne.value[0]), W = A(() => ne.value[1]), H = A(() => typeof n.toast.title != "string"), U = A(() => typeof n.toast.description != "string"), { isDocumentHidden: se } = RI(), ee = A(() => S.value && S.value === "loading");
    Ce(() => {
      s.value = !0, v.value = D.value;
    }), Te(async () => {
      if (!s.value || !y.value) return;
      await Pe();
      const V = y.value, te = V.style.height;
      V.style.height = "auto";
      const z = V.getBoundingClientRect().height;
      V.style.height = te, p.value = z, a("update:height", {
        toastId: n.toast.id,
        height: z,
        position: n.toast.position || n.position
      });
    });
    function de() {
      i.value = !0, f.value = q.value, setTimeout(() => {
        a("removeToast", n.toast);
      }, jy);
    }
    function fe() {
      if (ee.value || !$.value) return {};
      de(), n.toast.onDismiss?.(n.toast);
    }
    function _e(V) {
      V.button !== 2 && (ee.value || !$.value || (m.value = /* @__PURE__ */ new Date(), f.value = q.value, V.target.setPointerCapture(V.pointerId), V.target.tagName !== "BUTTON" && (u.value = !0, J.value = {
        x: V.clientX,
        y: V.clientY
      })));
    }
    function ye() {
      if (d.value || !$.value) return;
      J.value = null;
      const V = Number(y.value?.style.getPropertyValue("--swipe-amount-x").replace("px", "") || 0), te = Number(y.value?.style.getPropertyValue("--swipe-amount-y").replace("px", "") || 0), z = (/* @__PURE__ */ new Date()).getTime() - (m.value?.getTime() || 0), re = r.value === "x" ? V : te, ie = Math.abs(re) / z;
      if (Math.abs(re) >= OI || ie > 0.11) {
        f.value = q.value, n.toast.onDismiss?.(n.toast), r.value === "x" ? o.value = V > 0 ? "right" : "left" : o.value = te > 0 ? "down" : "up", de(), d.value = !0;
        return;
      } else
        y.value?.style.setProperty("--swipe-amount-x", "0px"), y.value?.style.setProperty("--swipe-amount-y", "0px");
      c.value = !1, u.value = !1, r.value = null;
    }
    function Ee(V) {
      if (!J.value || !$.value || (window?.getSelection()?.toString()?.length ?? !1)) return;
      const z = V.clientY - J.value.y, re = V.clientX - J.value.x, ie = n.swipeDirections ?? VI(n.position);
      !r.value && (Math.abs(re) > 1 || Math.abs(z) > 1) && (r.value = Math.abs(re) > Math.abs(z) ? "x" : "y");
      let L = {
        x: 0,
        y: 0
      };
      const be = (xe) => 1 / (1.5 + Math.abs(xe) / 20);
      if (r.value === "y") {
        if (ie.includes("top") || ie.includes("bottom")) if (ie.includes("top") && z < 0 || ie.includes("bottom") && z > 0) L.y = z;
        else {
          const xe = z * be(z);
          L.y = Math.abs(xe) < Math.abs(z) ? xe : z;
        }
      } else if (r.value === "x" && (ie.includes("left") || ie.includes("right")))
        if (ie.includes("left") && re < 0 || ie.includes("right") && re > 0) L.x = re;
        else {
          const xe = re * be(re);
          L.x = Math.abs(xe) < Math.abs(re) ? xe : re;
        }
      (Math.abs(L.x) > 0 || Math.abs(L.y) > 0) && (c.value = !0), y.value?.style.setProperty("--swipe-amount-x", `${L.x}px`), y.value?.style.setProperty("--swipe-amount-y", `${L.y}px`);
    }
    Ce(() => {
      if (s.value = !0, !y.value) return;
      const V = y.value.getBoundingClientRect().height;
      p.value = V;
      const te = [{
        toastId: n.toast.id,
        height: V,
        position: n.toast.position
      }, ...n.heights];
      a("update:heights", te);
    }), Ea(() => {
      y.value && a("removeToast", n.toast);
    }), Te((V) => {
      if (n.toast.promise && S.value === "loading" || n.toast.duration === 1 / 0 || n.toast.type === "loading") return;
      let te;
      const z = () => {
        if (F.value < O.value) {
          const ie = (/* @__PURE__ */ new Date()).getTime() - O.value;
          v.value = v.value - ie;
        }
        F.value = (/* @__PURE__ */ new Date()).getTime();
      }, re = () => {
        v.value !== 1 / 0 && (O.value = (/* @__PURE__ */ new Date()).getTime(), te = setTimeout(() => {
          n.toast.onAutoClose?.(n.toast), de();
        }, v.value));
      };
      n.expanded || n.interacting || se.value ? z() : re(), V(() => {
        clearTimeout(te);
      });
    }), me(() => n.toast.delete, (V) => {
      V !== void 0 && V && (de(), n.toast.onDismiss?.(n.toast));
    }, { deep: !0 });
    function ce() {
      u.value = !1, r.value = null, J.value = null;
    }
    return (V, te) => (h(), G("li", {
      tabindex: "0",
      ref_key: "toastRef",
      ref: y,
      class: ae(l(wa)(n.class, k.value, V.classes?.toast, V.toast.classes?.toast, V.classes?.[S.value], V.toast?.classes?.[S.value])),
      "data-sonner-toast": "",
      "data-rich-colors": V.toast.richColors ?? V.defaultRichColors,
      "data-styled": !(V.toast.component || V.toast?.unstyled || V.unstyled),
      "data-mounted": s.value,
      "data-promise": !!V.toast.promise,
      "data-swiped": c.value,
      "data-removed": i.value,
      "data-visible": C.value,
      "data-y-position": Q.value,
      "data-x-position": W.value,
      "data-index": V.index,
      "data-front": x.value,
      "data-swiping": u.value,
      "data-dismissible": $.value,
      "data-type": S.value,
      "data-invert": V.toast.invert || V.invert,
      "data-swipe-out": d.value,
      "data-swipe-direction": o.value,
      "data-expanded": !!(V.expanded || V.expandByDefault && s.value),
      "data-testid": V.toast.testId,
      style: dt({
        "--index": V.index,
        "--toasts-before": V.index,
        "--z-index": V.toasts.length - V.index,
        "--offset": `${i.value ? f.value : q.value}px`,
        "--initial-height": V.expandByDefault ? "auto" : `${p.value}px`,
        ...V.style,
        ...n.toast.style
      }),
      onDragend: ce,
      onPointerdown: _e,
      onPointerup: ye,
      onPointermove: Ee
    }, [E.value && !V.toast.component && S.value !== "loading" ? (h(), G("button", {
      key: 0,
      "aria-label": V.closeButtonAriaLabel || "Close toast",
      "data-disabled": ee.value,
      "data-close-button": "true",
      "data-close-button-position": V.closeButtonPosition,
      class: ae(l(wa)(V.classes?.closeButton, V.toast?.classes?.closeButton)),
      onClick: fe
    }, [V.icons?.close ? (h(), w(Pt(V.icons?.close), { key: 0 })) : _(V.$slots, "close-icon", { key: 1 })], 10, LI)) : De("v-if", !0), V.toast.component ? (h(), w(Pt(V.toast.component), T({ key: 1 }, V.toast.componentProps, {
      onCloseToast: fe,
      isPaused: V.$props.expanded || V.$props.interacting || l(se)
    }), null, 16, ["isPaused"])) : (h(), G(Ge, { key: 2 }, [
      S.value !== "default" || V.toast.icon || V.toast.promise ? (h(), G("div", {
        key: 0,
        "data-icon": "",
        class: ae(l(wa)(V.classes?.icon, V.toast?.classes?.icon))
      }, [V.toast.icon ? (h(), w(Pt(V.toast.icon), { key: 0 })) : (h(), G(Ge, { key: 1 }, [S.value === "loading" ? _(V.$slots, "loading-icon", { key: 0 }) : S.value === "success" ? _(V.$slots, "success-icon", { key: 1 }) : S.value === "error" ? _(V.$slots, "error-icon", { key: 2 }) : S.value === "warning" ? _(V.$slots, "warning-icon", { key: 3 }) : S.value === "info" ? _(V.$slots, "info-icon", { key: 4 }) : De("v-if", !0)], 64))], 2)) : De("v-if", !0),
      we("div", {
        "data-content": "",
        class: ae(l(wa)(V.classes?.content, V.toast?.classes?.content))
      }, [we("div", {
        "data-title": "",
        class: ae(l(wa)(V.classes?.title, V.toast.classes?.title))
      }, [H.value ? (h(), w(Pt(V.toast.title), oe(T({ key: 0 }, V.toast.componentProps)), null, 16)) : (h(), G(Ge, { key: 1 }, [Re(Fe(V.toast.title), 1)], 64))], 2), V.toast.description ? (h(), G("div", {
        key: 0,
        "data-description": "",
        class: ae(l(wa)(V.descriptionClass, B.value, V.classes?.description, V.toast.classes?.description))
      }, [U.value ? (h(), w(Pt(V.toast.description), oe(T({ key: 0 }, V.toast.componentProps)), null, 16)) : (h(), G(Ge, { key: 1 }, [Re(Fe(V.toast.description), 1)], 64))], 2)) : De("v-if", !0)], 2),
      V.toast.cancel ? (h(), G("button", {
        key: 1,
        style: dt(V.toast.cancelButtonStyle || V.cancelButtonStyle),
        class: ae(l(wa)(V.classes?.cancelButton, V.toast.classes?.cancelButton)),
        "data-button": "",
        "data-cancel": "",
        onClick: te[0] || (te[0] = (z) => {
          l(js)(V.toast.cancel) && $.value && (V.toast.cancel.onClick?.(z), de());
        })
      }, Fe(l(js)(V.toast.cancel) ? V.toast.cancel?.label : V.toast.cancel), 7)) : De("v-if", !0),
      V.toast.action ? (h(), G("button", {
        key: 2,
        style: dt(V.toast.actionButtonStyle || V.actionButtonStyle),
        class: ae(l(wa)(V.classes?.actionButton, V.toast.classes?.actionButton)),
        "data-button": "",
        "data-action": "",
        onClick: te[1] || (te[1] = (z) => {
          l(js)(V.toast.action) && (V.toast.action.onClick?.(z), !z.defaultPrevented && de());
        })
      }, Fe(l(js)(V.toast.action) ? V.toast.action?.label : V.toast.action), 7)) : De("v-if", !0)
    ], 64))], 46, NI));
  }
}), HI = zI, ws = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, r] of t) n[a] = r;
  return n;
};
const UI = {}, jI = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function WI(e, t) {
  return h(), G("svg", jI, t[0] || (t[0] = [we("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), we("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var GI = /* @__PURE__ */ ws(UI, [["render", WI]]);
const KI = ["data-visible"], YI = { class: "sonner-spinner" };
var XI = /* @__PURE__ */ b({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(e) {
    const t = Array(12).fill(0);
    return (n, a) => (h(), G("div", {
      class: "sonner-loading-wrapper",
      "data-visible": n.visible
    }, [we("div", YI, [(h(!0), G(Ge, null, Et(l(t), (r) => (h(), G("div", {
      key: `spinner-bar-${r}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, KI));
  }
}), JI = XI;
const ZI = {}, QI = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function eO(e, t) {
  return h(), G("svg", QI, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var tO = /* @__PURE__ */ ws(ZI, [["render", eO]]);
const nO = {}, aO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function rO(e, t) {
  return h(), G("svg", aO, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var oO = /* @__PURE__ */ ws(nO, [["render", rO]]);
const sO = {}, lO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function iO(e, t) {
  return h(), G("svg", lO, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var uO = /* @__PURE__ */ ws(sO, [["render", iO]]);
const dO = {}, cO = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function fO(e, t) {
  return h(), G("svg", cO, t[0] || (t[0] = [we("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var pO = /* @__PURE__ */ ws(dO, [["render", fO]]);
const vO = ["aria-label"], mO = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position"
], hO = typeof window < "u" && typeof document < "u";
function gO() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const e = document.documentElement.getAttribute("dir");
  return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e;
}
var yO = /* @__PURE__ */ b({
  name: "Toaster",
  inheritAttrs: !1,
  __name: "Toaster",
  props: {
    id: {},
    invert: {
      type: Boolean,
      default: !1
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    closeButtonPosition: { default: "top-left" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: !1
    },
    expand: {
      type: Boolean,
      default: !1
    },
    duration: {},
    gap: { default: II },
    visibleToasts: { default: EI },
    closeButton: {
      type: Boolean,
      default: !1
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: Hy },
    mobileOffset: { default: Uy },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(e) {
    const t = e, n = u0(), a = I([]), r = A(() => t.id ? a.value.filter((D) => D.toasterId === t.id) : a.value.filter((D) => !D.toasterId));
    function o(D, O) {
      return r.value.filter((F) => !F.position && O === 0 || F.position === D);
    }
    const s = A(() => {
      const D = r.value.filter((O) => O.position).map((O) => O.position);
      return D.length > 0 ? Array.from(new Set([t.position].concat(D))) : [t.position];
    }), i = A(() => {
      const D = {};
      return s.value.forEach((O) => {
        D[O] = a.value.filter((F) => F.position === O);
      }), D;
    }), u = I([]), d = I({}), c = I(!1);
    Te(() => {
      s.value.forEach((D) => {
        D in d.value || (d.value[D] = !1);
      });
    });
    const f = I(t.theme !== "system" ? t.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), p = I(null), v = I(null), m = I(!1), y = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function x(D) {
      a.value.find((O) => O.id === D.id)?.delete || Xt.dismiss(D.id), a.value = a.value.filter(({ id: O }) => O !== D.id), setTimeout(() => {
        a.value.find((O) => O.id === D.id) || (u.value = u.value.filter((O) => O.toastId !== D.id));
      }, jy + 50);
    }
    function C(D) {
      m.value && !D.currentTarget?.contains?.(D.relatedTarget) && (m.value = !1, v.value && (v.value.focus({ preventScroll: !0 }), v.value = null));
    }
    function S(D) {
      D.target instanceof HTMLElement && D.target.dataset.dismissible === "false" || m.value || (m.value = !0, v.value = D.relatedTarget);
    }
    function $(D) {
      D.target && D.target instanceof HTMLElement && D.target.dataset.dismissible === "false" || (c.value = !0);
    }
    Te((D) => {
      const O = Xt.subscribe((F) => {
        if (F.dismiss) {
          requestAnimationFrame(() => {
            a.value = a.value.map((J) => J.id === F.id ? {
              ...J,
              delete: !0
            } : J);
          });
          return;
        }
        Pe(() => {
          const J = a.value.findIndex((ne) => ne.id === F.id);
          J !== -1 ? a.value = [
            ...a.value.slice(0, J),
            {
              ...a.value[J],
              ...F
            },
            ...a.value.slice(J + 1)
          ] : a.value = [F, ...a.value];
        });
      });
      D(O);
    }), Te((D) => {
      if (typeof window > "u") return;
      if (t.theme !== "system") {
        f.value = t.theme;
        return;
      }
      const O = window.matchMedia("(prefers-color-scheme: dark)"), F = (ne) => {
        f.value = ne ? "dark" : "light";
      };
      F(O.matches);
      const J = (ne) => {
        F(ne.matches);
      };
      try {
        O.addEventListener("change", J);
      } catch {
        O.addListener(J);
      }
      D(() => {
        try {
          O.removeEventListener("change", J);
        } catch {
          O.removeListener(J);
        }
      });
    }), Te(() => {
      p.value && v.value && (v.value.focus({ preventScroll: !0 }), v.value = null, m.value = !1);
    }), Te(() => {
      a.value.length <= 1 && Object.keys(d.value).forEach((D) => {
        d.value[D] = !1;
      });
    }), Te((D) => {
      function O(F) {
        const J = t.hotkey.every((W) => F[W] || F.code === W), ne = Array.isArray(p.value) ? p.value[0] : p.value;
        J && (s.value.forEach((W) => {
          d.value[W] = !0;
        }), ne?.focus());
        const Q = document.activeElement === p.value || ne?.contains(document.activeElement);
        F.code === "Escape" && Q && s.value.forEach((W) => {
          d.value[W] = !1;
        });
      }
      hO && (document.addEventListener("keydown", O), D(() => {
        document.removeEventListener("keydown", O);
      }));
    });
    function k(D) {
      const O = D.currentTarget, F = O.getAttribute("data-y-position") + "-" + O.getAttribute("data-x-position");
      d.value[F] = !0;
    }
    function B(D) {
      if (!c.value) {
        const O = D.currentTarget, F = O.getAttribute("data-y-position") + "-" + O.getAttribute("data-x-position");
        d.value[F] = !1;
      }
    }
    function P() {
      Object.keys(d.value).forEach((D) => {
        d.value[D] = !1;
      });
    }
    function M() {
      c.value = !1;
    }
    function q(D) {
      u.value = D;
    }
    function E(D) {
      const O = u.value.findIndex((F) => F.toastId === D.toastId);
      if (O !== -1) u.value[O] = D;
      else {
        const F = u.value.findIndex((J) => J.position === D.position);
        F !== -1 ? u.value.splice(F, 0, D) : u.value.unshift(D);
      }
    }
    return (D, O) => (h(), G(Ge, null, [De(" Remove item from normal navigation flow, only available via hotkey "), we("section", {
      "aria-label": `${D.containerAriaLabel} ${l(y)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(h(!0), G(Ge, null, Et(s.value, (F, J) => (h(), G("ol", T({
      key: F,
      ref_for: !0,
      ref_key: "listRef",
      ref: p,
      "data-sonner-toaster": "",
      "data-sonner-theme": f.value,
      class: t.class,
      dir: D.dir === "auto" ? gO() : D.dir,
      tabIndex: -1,
      "data-theme": D.theme,
      "data-rich-colors": D.richColors,
      "data-y-position": F.split("-")[0],
      "data-x-position": F.split("-")[1],
      style: {
        "--front-toast-height": `${u.value[0]?.height || 0}px`,
        "--width": `${l(TI)}px`,
        "--gap": `${D.gap}px`,
        ...D.style,
        ...l(n).style,
        ...l(FI)(D.offset, D.mobileOffset)
      }
    }, { ref_for: !0 }, D.$attrs, {
      onBlur: C,
      onFocus: S,
      onMouseenter: k,
      onMousemove: k,
      onMouseleave: B,
      onDragend: P,
      onPointerdown: $,
      onPointerup: M
    }), [(h(!0), G(Ge, null, Et(o(F, J), (ne, Q) => (h(), w(HI, {
      key: ne.id,
      heights: u.value,
      icons: D.icons,
      index: Q,
      toast: ne,
      defaultRichColors: D.richColors,
      duration: D.toastOptions?.duration ?? D.duration,
      class: ae(D.toastOptions?.class ?? ""),
      descriptionClass: D.toastOptions?.descriptionClass,
      invert: D.invert,
      visibleToasts: D.visibleToasts,
      closeButton: D.toastOptions?.closeButton ?? D.closeButton,
      interacting: c.value,
      position: F,
      closeButtonPosition: D.toastOptions?.closeButtonPosition ?? D.closeButtonPosition,
      style: dt(D.toastOptions?.style),
      unstyled: D.toastOptions?.unstyled,
      classes: D.toastOptions?.classes,
      cancelButtonStyle: D.toastOptions?.cancelButtonStyle,
      actionButtonStyle: D.toastOptions?.actionButtonStyle,
      "close-button-aria-label": D.toastOptions?.closeButtonAriaLabel,
      toasts: i.value[F],
      expandByDefault: D.expand,
      gap: D.gap,
      expanded: d.value[F] || !1,
      swipeDirections: t.swipeDirections,
      "onUpdate:heights": q,
      "onUpdate:height": E,
      onRemoveToast: x
    }, {
      "close-icon": g(() => [_(D.$slots, "close-icon", {}, () => [N(GI)])]),
      "loading-icon": g(() => [_(D.$slots, "loading-icon", {}, () => [N(JI, { visible: ne.type === "loading" }, null, 8, ["visible"])])]),
      "success-icon": g(() => [_(D.$slots, "success-icon", {}, () => [N(tO)])]),
      "error-icon": g(() => [_(D.$slots, "error-icon", {}, () => [N(pO)])]),
      "warning-icon": g(() => [_(D.$slots, "warning-icon", {}, () => [N(uO)])]),
      "info-icon": g(() => [_(D.$slots, "info-icon", {}, () => [N(oO)])]),
      _: 2
    }, 1032, [
      "heights",
      "icons",
      "index",
      "toast",
      "defaultRichColors",
      "duration",
      "class",
      "descriptionClass",
      "invert",
      "visibleToasts",
      "closeButton",
      "interacting",
      "position",
      "closeButtonPosition",
      "style",
      "unstyled",
      "classes",
      "cancelButtonStyle",
      "actionButtonStyle",
      "close-button-aria-label",
      "toasts",
      "expandByDefault",
      "gap",
      "expanded",
      "swipeDirections"
    ]))), 128))], 16, mO))), 128))], 8, vO)], 2112));
  }
}), Wy = yO;
function bO(e, t) {
  return Object.entries(e).map(([n, a]) => t === "key" ? n : t === "both" ? `${n}: ${a}` : a).join(`
`);
}
function _O() {
  return {
    info: (e, t) => {
      fo.info("FYI", {
        description: e,
        ...t
      });
    },
    success: (e, t) => {
      fo.success("Success", {
        description: e,
        ...t
      });
    },
    warning: (e, t) => {
      fo.warning("Warning", {
        description: e,
        ...t
      });
    },
    error: (e, t = "value", n) => {
      fo.error("Oh snap! Some errors were encountered.", {
        description: bO(e, t),
        ...n
      });
    },
    flash: (e, t) => {
      fo(e, t);
    }
  };
}
const PH = /* @__PURE__ */ b({
  __name: "Flasher",
  props: {
    class: {},
    info: {},
    success: {},
    warning: {},
    errors: {},
    objectFormat: { default: "value" }
  },
  setup(e) {
    const t = e, {
      info: n,
      success: a,
      warning: r,
      error: o
    } = _O();
    return me(
      () => t.info,
      (s) => {
        s && n(t.info);
      },
      {
        immediate: !0
      }
    ), me(
      () => t.success,
      (s) => {
        s && a(t.success);
      },
      { immediate: !0 }
    ), me(
      () => t.warning,
      (s) => {
        s && r(t.warning);
      },
      { immediate: !0 }
    ), me(
      () => t.errors,
      () => {
        t.errors !== void 0 && Object.keys(t.errors).length > 0 && o(t.errors, t.objectFormat);
      }
    ), (s, i) => (h(), w(l(Wy), {
      class: ae(l(R)("toaster group", t.class)),
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          success: "group-[.toaster]:border-success",
          error: "group-[.toaster]:border-destructive",
          warning: "group-[.toaster]:border-warning",
          info: "group-[.toaster]:border-primary",
          description: "group-[.toast]:text-muted-foreground group-[.toast]:whitespace-pre-line",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, {
      "success-icon": g(() => [
        N(l(Ry), { class: "size-4 text-success" })
      ]),
      "info-icon": g(() => [
        N(l(Fy), { class: "size-4 text-primary" })
      ]),
      "warning-icon": g(() => [
        N(l(zy), { class: "size-4 text-warning" })
      ]),
      "error-icon": g(() => [
        N(l(Ny), { class: "size-4 text-destructive" })
      ]),
      "loading-icon": g(() => [
        we("div", null, [
          N(l(df), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": g(() => [
        N(l(no), { class: "size-4" })
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), wO = { class: "flex items-center justify-between space-y-2" }, xO = { class: "flex items-center space-x-2" }, MH = /* @__PURE__ */ b({
  __name: "Heading",
  props: {
    as: { default: "h2" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", wO, [
      (h(), w(Pt(e.as), {
        class: ae(l(R)("text-3xl font-bold tracking-tight", t.class))
      }, {
        default: g(() => [
          _(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])),
      we("div", xO, [
        _(n.$slots, "actions")
      ])
    ]));
  }
}), CO = /* @__PURE__ */ b({
  __name: "Accordion",
  props: {
    collapsible: { type: Boolean },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(q1), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), DH = /* @__PURE__ */ b({
  __name: "Accord",
  props: {
    content: {},
    collapsible: { type: Boolean, default: !0 },
    disabled: { type: Boolean },
    dir: {},
    orientation: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    type: { default: "single" },
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(CO, oe(le(l(r))), {
      default: g(() => [
        (h(!0), G(Ge, null, Et(e.content, (i, u) => (h(), w(l($O), {
          key: u,
          value: "item-" + u
        }, {
          default: g(() => [
            N(l(BO), null, {
              default: g(() => [
                _(o.$slots, u + ".title", { item: i }, () => [
                  Re(Fe(i.title), 1)
                ])
              ]),
              _: 2
            }, 1024),
            N(l(SO), null, {
              default: g(() => [
                _(o.$slots, u + ".content", { item: i }, () => [
                  Re(Fe(i.content), 1)
                ])
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1032, ["value"]))), 128))
      ]),
      _: 3
    }, 16));
  }
}), SO = /* @__PURE__ */ b({
  __name: "AccordionContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(O1), T(l(n), { class: "overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down" }), {
      default: g(() => [
        we("div", {
          class: ae(l(R)("pt-0 pb-4", t.class))
        }, [
          _(a.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16));
  }
}), $O = /* @__PURE__ */ b({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(T1), T(l(a), {
      class: l(R)("border-b", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), BO = /* @__PURE__ */ b({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(V1), { class: "flex" }, {
      default: g(() => [
        N(l(N1), T(l(n), {
          class: l(R)(
            "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
            t.class
          )
        }), {
          default: g(() => [
            _(a.$slots, "default"),
            _(a.$slots, "icon", {}, () => [
              N(l(Li), { class: "h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" })
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), qH = /* @__PURE__ */ b({
  __name: "Alert",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)(l(kO)({ variant: e.variant }), t.class)),
      role: "alert"
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), AH = /* @__PURE__ */ b({
  __name: "AlertDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("text-sm [&_p]:leading-relaxed", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), EH = /* @__PURE__ */ b({
  __name: "AlertTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("h5", {
      class: ae(l(R)("mb-1 leading-none font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), kO = an(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), TH = /* @__PURE__ */ b({
  __name: "AspectRatio",
  props: {
    ratio: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ux), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), IH = /* @__PURE__ */ b({
  __name: "Avatar",
  props: {
    class: {},
    size: { default: "sm" },
    shape: { default: "circle" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Gx), {
      class: ae(l(R)(l(PO)({ size: e.size, shape: e.shape }), t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), OH = /* @__PURE__ */ b({
  __name: "AvatarFallback",
  props: {
    delayMs: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Yx), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), RH = /* @__PURE__ */ b({
  __name: "AvatarImage",
  props: {
    src: {},
    referrerPolicy: {},
    crossOrigin: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Zx), T(t, { class: "h-full w-full object-cover" }), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), PO = an(
  "inline-flex items-center justify-center font-normal text-foreground select-none shrink-0 bg-secondary overflow-hidden",
  {
    variants: {
      size: {
        sm: "h-10 w-10 text-xs",
        base: "h-16 w-16 text-2xl",
        lg: "h-32 w-32 text-5xl"
      },
      shape: {
        circle: "rounded-full",
        square: "rounded-md"
      }
    }
  }
), VH = /* @__PURE__ */ b({
  __name: "Badge",
  props: {
    variant: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)(l(MO)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), MO = an(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        success: "border-transparent bg-success text-success-foreground shadow hover:bg-success/80",
        warning: "border-transparent bg-warning text-warning-foreground shadow hover:bg-warning/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), FH = /* @__PURE__ */ b({
  __name: "Breadcrumb",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("nav", {
      "aria-label": "breadcrumb",
      class: ae(t.class)
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), NH = /* @__PURE__ */ b({
  __name: "BreadcrumbEllipsis",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(R)("flex h-9 w-9 items-center justify-center", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(Vy), { class: "h-4 w-4" })
      ]),
      a[0] || (a[0] = we("span", { class: "sr-only" }, "More", -1))
    ], 2));
  }
}), LH = /* @__PURE__ */ b({
  __name: "BreadcrumbItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("li", {
      class: ae(l(R)("inline-flex items-center gap-1.5", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), zH = /* @__PURE__ */ b({
  __name: "BreadcrumbLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(R)("transition-colors hover:text-foreground", t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), HH = /* @__PURE__ */ b({
  __name: "BreadcrumbList",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("ol", {
      class: ae(
        l(R)(
          "flex flex-wrap items-center gap-1.5 text-sm break-words text-muted-foreground sm:gap-2.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), UH = /* @__PURE__ */ b({
  __name: "BreadcrumbPage",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      role: "link",
      "aria-disabled": "true",
      "aria-current": "page",
      class: ae(l(R)("font-normal text-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), jH = /* @__PURE__ */ b({
  __name: "BreadcrumbSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("li", {
      role: "presentation",
      "aria-hidden": "true",
      class: ae(l(R)("[&>svg]:size-3.5", t.class))
    }, [
      _(n.$slots, "default", {}, () => [
        N(l(Fa))
      ])
    ], 2));
  }
}), DO = ["data-orientation"], WH = /* @__PURE__ */ b({
  __name: "ButtonGroup",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      class: ae(l(R)(l(qO)({ orientation: t.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, DO));
  }
}), Hi = /* @__PURE__ */ b({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Xc), T({ "data-slot": "separator" }, l(n), {
      class: l(R)(
        "shrink-0 bg-border data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), GH = /* @__PURE__ */ b({
  __name: "ButtonGroupSeparator",
  props: {
    orientation: { default: "vertical" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Hi), T({ "data-slot": "button-group-separator" }, l(n), {
      orientation: t.orientation,
      class: l(R)("relative !m-0 self-stretch bg-input data-[orientation=vertical]:h-auto", t.class)
    }), null, 16, ["orientation", "class"]));
  }
}), KH = /* @__PURE__ */ b({
  __name: "ButtonGroupText",
  props: {
    class: {},
    orientation: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      role: "group",
      "data-slot": "button-group",
      "data-orientation": t.orientation,
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(R)(
          "flex items-center gap-2 rounded-md border bg-muted px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as", "as-child", "class"]));
  }
}), qO = an(
  "flex w-fit items-stretch has-[>[data-slot=button-group]]:gap-2 [&>*:focus-visible]:relative [&>*:focus-visible]:z-10 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1",
  {
    variants: {
      orientation: {
        horizontal: "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
        vertical: "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
      }
    },
    defaultVariants: {
      orientation: "horizontal"
    }
  }
), AO = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, YH = /* @__PURE__ */ b({
  __name: "Calendar",
  props: {
    defaultValue: {},
    defaultPlaceholder: {},
    placeholder: {},
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    modelValue: {},
    multiple: { type: Boolean },
    disableDaysOutsideCurrentView: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(iC), T({
      class: l(R)("p-3", n.class)
    }, l(o)), {
      default: g(({ grid: u, weekDays: d }) => [
        N(l(FO), null, {
          default: g(() => [
            N(l(zO)),
            N(l(NO)),
            N(l(LO))
          ]),
          _: 1
        }),
        we("div", AO, [
          (h(!0), G(Ge, null, Et(u, (c) => (h(), w(l(IO), {
            key: c.value.toString()
          }, {
            default: g(() => [
              N(l(RO), null, {
                default: g(() => [
                  N(l(yv), null, {
                    default: g(() => [
                      (h(!0), G(Ge, null, Et(d, (f) => (h(), w(l(VO), { key: f }, {
                        default: g(() => [
                          Re(Fe(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(OO), null, {
                default: g(() => [
                  (h(!0), G(Ge, null, Et(c.rows, (f, p) => (h(), w(l(yv), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: g(() => [
                      (h(!0), G(Ge, null, Et(f, (v) => (h(), w(l(EO), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: g(() => [
                          N(l(TO), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), EO = /* @__PURE__ */ b({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(dC), T({
      class: l(R)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:rounded-md [&:has([data-selected])]:bg-accent [&:has([data-selected][data-outside-view])]:bg-accent/50",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), TO = /* @__PURE__ */ b({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(fC), T({
      class: l(R)(
        l(Kt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selected
        "data-[selected]:bg-primary data-[selected]:text-primary-foreground data-[selected]:opacity-100 data-[selected]:hover:bg-primary data-[selected]:hover:text-primary-foreground data-[selected]:focus:bg-primary data-[selected]:focus:text-primary-foreground",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:bg-accent/50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), IO = /* @__PURE__ */ b({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(vC), T({
      class: l(R)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), OO = /* @__PURE__ */ b({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(hC), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), RO = /* @__PURE__ */ b({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(yC), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yv = /* @__PURE__ */ b({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(_C), T({
      class: l(R)("flex", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), VO = /* @__PURE__ */ b({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(xC), T({
      class: l(R)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), FO = /* @__PURE__ */ b({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(SC), T({
      class: l(R)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), NO = /* @__PURE__ */ b({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(BC), T({
      class: l(R)("text-sm font-medium", t.class)
    }, l(a)), {
      default: g(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(Fe(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), LO = /* @__PURE__ */ b({
  __name: "CalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(PC), T({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Fa), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), zO = /* @__PURE__ */ b({
  __name: "CalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(DC), T({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), HO = /* @__PURE__ */ b({
  __name: "Card",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("rounded-xl border bg-card text-card-foreground shadow", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), UO = /* @__PURE__ */ b({
  __name: "CardContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), XH = /* @__PURE__ */ b({
  __name: "CardDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      class: ae(l(R)("text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), JH = /* @__PURE__ */ b({
  __name: "CardFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("flex items-center p-6 pt-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), jO = /* @__PURE__ */ b({
  __name: "CardHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("flex flex-col gap-y-1.5 p-6", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), WO = /* @__PURE__ */ b({
  __name: "CardTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("h3", {
      class: ae(l(R)("leading-none font-semibold tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
});
function GO(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function bv(e) {
  return GO(e) || Array.isArray(e);
}
function KO() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function mf(e, t) {
  const n = Object.keys(e), a = Object.keys(t);
  if (n.length !== a.length) return !1;
  const r = JSON.stringify(Object.keys(e.breakpoints || {})), o = JSON.stringify(Object.keys(t.breakpoints || {}));
  return r !== o ? !1 : n.every((s) => {
    const i = e[s], u = t[s];
    return typeof i == "function" ? `${i}` == `${u}` : !bv(i) || !bv(u) ? i === u : mf(i, u);
  });
}
function _v(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function YO(e, t) {
  if (e.length !== t.length) return !1;
  const n = _v(e), a = _v(t);
  return n.every((r, o) => {
    const s = a[o];
    return mf(r, s);
  });
}
function hf(e) {
  return typeof e == "number";
}
function Cd(e) {
  return typeof e == "string";
}
function Ui(e) {
  return typeof e == "boolean";
}
function wv(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function mt(e) {
  return Math.abs(e);
}
function gf(e) {
  return Math.sign(e);
}
function qo(e, t) {
  return mt(e - t);
}
function XO(e, t) {
  if (e === 0 || t === 0 || mt(e) <= mt(t)) return 0;
  const n = qo(mt(e), mt(t));
  return mt(n / e);
}
function JO(e) {
  return Math.round(e * 100) / 100;
}
function Ho(e) {
  return Uo(e).map(Number);
}
function Mn(e) {
  return e[xs(e)];
}
function xs(e) {
  return Math.max(0, e.length - 1);
}
function yf(e, t) {
  return t === xs(e);
}
function xv(e, t = 0) {
  return Array.from(Array(e), (n, a) => t + a);
}
function Uo(e) {
  return Object.keys(e);
}
function Gy(e, t) {
  return [e, t].reduce((n, a) => (Uo(a).forEach((r) => {
    const o = n[r], s = a[r], i = wv(o) && wv(s);
    n[r] = i ? Gy(o, s) : s;
  }), n), {});
}
function Sd(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function ZO(e, t) {
  const n = {
    start: a,
    center: r,
    end: o
  };
  function a() {
    return 0;
  }
  function r(u) {
    return o(u) / 2;
  }
  function o(u) {
    return t - u;
  }
  function s(u, d) {
    return Cd(e) ? n[e](u) : e(t, u, d);
  }
  return {
    measure: s
  };
}
function jo() {
  let e = [];
  function t(r, o, s, i = {
    passive: !0
  }) {
    let u;
    if ("addEventListener" in r)
      r.addEventListener(o, s, i), u = () => r.removeEventListener(o, s, i);
    else {
      const d = r;
      d.addListener(s), u = () => d.removeListener(s);
    }
    return e.push(u), a;
  }
  function n() {
    e = e.filter((r) => r());
  }
  const a = {
    add: t,
    clear: n
  };
  return a;
}
function QO(e, t, n, a) {
  const r = jo(), o = 1e3 / 60;
  let s = null, i = 0, u = 0;
  function d() {
    r.add(e, "visibilitychange", () => {
      e.hidden && m();
    });
  }
  function c() {
    v(), r.clear();
  }
  function f(x) {
    if (!u) return;
    s || (s = x, n(), n());
    const C = x - s;
    for (s = x, i += C; i >= o; )
      n(), i -= o;
    const S = i / o;
    a(S), u && (u = t.requestAnimationFrame(f));
  }
  function p() {
    u || (u = t.requestAnimationFrame(f));
  }
  function v() {
    t.cancelAnimationFrame(u), s = null, i = 0, u = 0;
  }
  function m() {
    s = null, i = 0;
  }
  return {
    init: d,
    destroy: c,
    start: p,
    stop: v,
    update: n,
    render: a
  };
}
function e3(e, t) {
  const n = t === "rtl", a = e === "y", r = a ? "y" : "x", o = a ? "x" : "y", s = !a && n ? -1 : 1, i = c(), u = f();
  function d(m) {
    const {
      height: y,
      width: x
    } = m;
    return a ? y : x;
  }
  function c() {
    return a ? "top" : n ? "right" : "left";
  }
  function f() {
    return a ? "bottom" : n ? "left" : "right";
  }
  function p(m) {
    return m * s;
  }
  return {
    scroll: r,
    cross: o,
    startEdge: i,
    endEdge: u,
    measureSize: d,
    direction: p
  };
}
function er(e = 0, t = 0) {
  const n = mt(e - t);
  function a(d) {
    return d < e;
  }
  function r(d) {
    return d > t;
  }
  function o(d) {
    return a(d) || r(d);
  }
  function s(d) {
    return o(d) ? a(d) ? e : t : d;
  }
  function i(d) {
    return n ? d - n * Math.ceil((d - t) / n) : d;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: s,
    reachedAny: o,
    reachedMax: r,
    reachedMin: a,
    removeOffset: i
  };
}
function Ky(e, t, n) {
  const {
    constrain: a
  } = er(0, e), r = e + 1;
  let o = s(t);
  function s(p) {
    return n ? mt((r + p) % r) : a(p);
  }
  function i() {
    return o;
  }
  function u(p) {
    return o = s(p), f;
  }
  function d(p) {
    return c().set(i() + p);
  }
  function c() {
    return Ky(e, i(), n);
  }
  const f = {
    get: i,
    set: u,
    add: d,
    clone: c
  };
  return f;
}
function t3(e, t, n, a, r, o, s, i, u, d, c, f, p, v, m, y, x, C, S) {
  const {
    cross: $,
    direction: k
  } = e, B = ["INPUT", "SELECT", "TEXTAREA"], P = {
    passive: !1
  }, M = jo(), q = jo(), E = er(50, 225).constrain(v.measure(20)), D = {
    mouse: 300,
    touch: 400
  }, O = {
    mouse: 500,
    touch: 600
  }, F = m ? 43 : 25;
  let J = !1, ne = 0, Q = 0, W = !1, H = !1, U = !1, se = !1;
  function ee(L) {
    if (!S) return;
    function be(Ne) {
      (Ui(S) || S(L, Ne)) && ce(Ne);
    }
    const xe = t;
    M.add(xe, "dragstart", (Ne) => Ne.preventDefault(), P).add(xe, "touchmove", () => {
    }, P).add(xe, "touchend", () => {
    }).add(xe, "touchstart", be).add(xe, "mousedown", be).add(xe, "touchcancel", te).add(xe, "contextmenu", te).add(xe, "click", z, !0);
  }
  function de() {
    M.clear(), q.clear();
  }
  function fe() {
    const L = se ? n : t;
    q.add(L, "touchmove", V, P).add(L, "touchend", te).add(L, "mousemove", V, P).add(L, "mouseup", te);
  }
  function _e(L) {
    const be = L.nodeName || "";
    return B.includes(be);
  }
  function ye() {
    return (m ? O : D)[se ? "mouse" : "touch"];
  }
  function Ee(L, be) {
    const xe = f.add(gf(L) * -1), Ne = c.byDistance(L, !m).distance;
    return m || mt(L) < E ? Ne : x && be ? Ne * 0.5 : c.byIndex(xe.get(), 0).distance;
  }
  function ce(L) {
    const be = Sd(L, a);
    se = be, U = m && be && !L.buttons && J, J = qo(r.get(), s.get()) >= 2, !(be && L.button !== 0) && (_e(L.target) || (W = !0, o.pointerDown(L), d.useFriction(0).useDuration(0), r.set(s), fe(), ne = o.readPoint(L), Q = o.readPoint(L, $), p.emit("pointerDown")));
  }
  function V(L) {
    if (!Sd(L, a) && L.touches.length >= 2) return te(L);
    const xe = o.readPoint(L), Ne = o.readPoint(L, $), Xe = qo(xe, ne), lt = qo(Ne, Q);
    if (!H && !se && (!L.cancelable || (H = Xe > lt, !H)))
      return te(L);
    const ke = o.pointerMove(L);
    Xe > y && (U = !0), d.useFriction(0.3).useDuration(0.75), i.start(), r.add(k(ke)), L.preventDefault();
  }
  function te(L) {
    const xe = c.byDistance(0, !1).index !== f.get(), Ne = o.pointerUp(L) * ye(), Xe = Ee(k(Ne), xe), lt = XO(Ne, Xe), ke = F - 10 * lt, Le = C + lt / 50;
    H = !1, W = !1, q.clear(), d.useDuration(ke).useFriction(Le), u.distance(Xe, !m), se = !1, p.emit("pointerUp");
  }
  function z(L) {
    U && (L.stopPropagation(), L.preventDefault(), U = !1);
  }
  function re() {
    return W;
  }
  return {
    init: ee,
    destroy: de,
    pointerDown: re
  };
}
function n3(e, t) {
  let a, r;
  function o(f) {
    return f.timeStamp;
  }
  function s(f, p) {
    const m = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (Sd(f, t) ? f : f.touches[0])[m];
  }
  function i(f) {
    return a = f, r = f, s(f);
  }
  function u(f) {
    const p = s(f) - s(r), v = o(f) - o(a) > 170;
    return r = f, v && (a = f), p;
  }
  function d(f) {
    if (!a || !r) return 0;
    const p = s(r) - s(a), v = o(f) - o(a), m = o(f) - o(r) > 170, y = p / v;
    return v && !m && mt(y) > 0.1 ? y : 0;
  }
  return {
    pointerDown: i,
    pointerMove: u,
    pointerUp: d,
    readPoint: s
  };
}
function a3() {
  function e(n) {
    const {
      offsetTop: a,
      offsetLeft: r,
      offsetWidth: o,
      offsetHeight: s
    } = n;
    return {
      top: a,
      right: r + o,
      bottom: a + s,
      left: r,
      width: o,
      height: s
    };
  }
  return {
    measure: e
  };
}
function r3(e) {
  function t(a) {
    return e * (a / 100);
  }
  return {
    measure: t
  };
}
function o3(e, t, n, a, r, o, s) {
  const i = [e].concat(a);
  let u, d, c = [], f = !1;
  function p(x) {
    return r.measureSize(s.measure(x));
  }
  function v(x) {
    if (!o) return;
    d = p(e), c = a.map(p);
    function C(S) {
      for (const $ of S) {
        if (f) return;
        const k = $.target === e, B = a.indexOf($.target), P = k ? d : c[B], M = p(k ? e : a[B]);
        if (mt(M - P) >= 0.5) {
          x.reInit(), t.emit("resize");
          break;
        }
      }
    }
    u = new ResizeObserver((S) => {
      (Ui(o) || o(x, S)) && C(S);
    }), n.requestAnimationFrame(() => {
      i.forEach((S) => u.observe(S));
    });
  }
  function m() {
    f = !0, u && u.disconnect();
  }
  return {
    init: v,
    destroy: m
  };
}
function s3(e, t, n, a, r, o) {
  let s = 0, i = 0, u = r, d = o, c = e.get(), f = 0;
  function p() {
    const P = a.get() - e.get(), M = !u;
    let q = 0;
    return M ? (s = 0, n.set(a), e.set(a), q = P) : (n.set(e), s += P / u, s *= d, c += s, e.add(s), q = c - f), i = gf(q), f = c, B;
  }
  function v() {
    const P = a.get() - t.get();
    return mt(P) < 1e-3;
  }
  function m() {
    return u;
  }
  function y() {
    return i;
  }
  function x() {
    return s;
  }
  function C() {
    return $(r);
  }
  function S() {
    return k(o);
  }
  function $(P) {
    return u = P, B;
  }
  function k(P) {
    return d = P, B;
  }
  const B = {
    direction: y,
    duration: m,
    velocity: x,
    seek: p,
    settled: v,
    useBaseFriction: S,
    useBaseDuration: C,
    useFriction: k,
    useDuration: $
  };
  return B;
}
function l3(e, t, n, a, r) {
  const o = r.measure(10), s = r.measure(50), i = er(0.1, 0.99);
  let u = !1;
  function d() {
    return !(u || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function c(v) {
    if (!d()) return;
    const m = e.reachedMin(t.get()) ? "min" : "max", y = mt(e[m] - t.get()), x = n.get() - t.get(), C = i.constrain(y / s);
    n.subtract(x * C), !v && mt(x) < o && (n.set(e.constrain(n.get())), a.useDuration(25).useBaseFriction());
  }
  function f(v) {
    u = !v;
  }
  return {
    shouldConstrain: d,
    constrain: c,
    toggleActive: f
  };
}
function i3(e, t, n, a, r) {
  const o = er(-t + e, 0), s = f(), i = c(), u = p();
  function d(m, y) {
    return qo(m, y) <= 1;
  }
  function c() {
    const m = s[0], y = Mn(s), x = s.lastIndexOf(m), C = s.indexOf(y) + 1;
    return er(x, C);
  }
  function f() {
    return n.map((m, y) => {
      const {
        min: x,
        max: C
      } = o, S = o.constrain(m), $ = !y, k = yf(n, y);
      return $ ? C : k || d(x, S) ? x : d(C, S) ? C : S;
    }).map((m) => parseFloat(m.toFixed(3)));
  }
  function p() {
    if (t <= e + r) return [o.max];
    if (a === "keepSnaps") return s;
    const {
      min: m,
      max: y
    } = i;
    return s.slice(m, y);
  }
  return {
    snapsContained: u,
    scrollContainLimit: i
  };
}
function u3(e, t, n) {
  const a = t[0], r = n ? a - e : Mn(t);
  return {
    limit: er(r, a)
  };
}
function d3(e, t, n, a) {
  const o = t.min + 0.1, s = t.max + 0.1, {
    reachedMin: i,
    reachedMax: u
  } = er(o, s);
  function d(p) {
    return p === 1 ? u(n.get()) : p === -1 ? i(n.get()) : !1;
  }
  function c(p) {
    if (!d(p)) return;
    const v = e * (p * -1);
    a.forEach((m) => m.add(v));
  }
  return {
    loop: c
  };
}
function c3(e) {
  const {
    max: t,
    length: n
  } = e;
  function a(o) {
    const s = o - t;
    return n ? s / -n : 0;
  }
  return {
    get: a
  };
}
function f3(e, t, n, a, r) {
  const {
    startEdge: o,
    endEdge: s
  } = e, {
    groupSlides: i
  } = r, u = f().map(t.measure), d = p(), c = v();
  function f() {
    return i(a).map((y) => Mn(y)[s] - y[0][o]).map(mt);
  }
  function p() {
    return a.map((y) => n[o] - y[o]).map((y) => -mt(y));
  }
  function v() {
    return i(d).map((y) => y[0]).map((y, x) => y + u[x]);
  }
  return {
    snaps: d,
    snapsAligned: c
  };
}
function p3(e, t, n, a, r, o) {
  const {
    groupSlides: s
  } = r, {
    min: i,
    max: u
  } = a, d = c();
  function c() {
    const p = s(o), v = !e || t === "keepSnaps";
    return n.length === 1 ? [o] : v ? p : p.slice(i, u).map((m, y, x) => {
      const C = !y, S = yf(x, y);
      if (C) {
        const $ = Mn(x[0]) + 1;
        return xv($);
      }
      if (S) {
        const $ = xs(o) - Mn(x)[0] + 1;
        return xv($, Mn(x)[0]);
      }
      return m;
    });
  }
  return {
    slideRegistry: d
  };
}
function v3(e, t, n, a, r) {
  const {
    reachedAny: o,
    removeOffset: s,
    constrain: i
  } = a;
  function u(m) {
    return m.concat().sort((y, x) => mt(y) - mt(x))[0];
  }
  function d(m) {
    const y = e ? s(m) : i(m), x = t.map((S, $) => ({
      diff: c(S - y, 0),
      index: $
    })).sort((S, $) => mt(S.diff) - mt($.diff)), {
      index: C
    } = x[0];
    return {
      index: C,
      distance: y
    };
  }
  function c(m, y) {
    const x = [m, m + n, m - n];
    if (!e) return m;
    if (!y) return u(x);
    const C = x.filter((S) => gf(S) === y);
    return C.length ? u(C) : Mn(x) - n;
  }
  function f(m, y) {
    const x = t[m] - r.get(), C = c(x, y);
    return {
      index: m,
      distance: C
    };
  }
  function p(m, y) {
    const x = r.get() + m, {
      index: C,
      distance: S
    } = d(x), $ = !e && o(x);
    if (!y || $) return {
      index: C,
      distance: m
    };
    const k = t[C] - S, B = m + c(k, 0);
    return {
      index: C,
      distance: B
    };
  }
  return {
    byDistance: p,
    byIndex: f,
    shortcut: c
  };
}
function m3(e, t, n, a, r, o, s) {
  function i(f) {
    const p = f.distance, v = f.index !== t.get();
    o.add(p), p && (a.duration() ? e.start() : (e.update(), e.render(1), e.update())), v && (n.set(t.get()), t.set(f.index), s.emit("select"));
  }
  function u(f, p) {
    const v = r.byDistance(f, p);
    i(v);
  }
  function d(f, p) {
    const v = t.clone().set(f), m = r.byIndex(v.get(), p);
    i(m);
  }
  return {
    distance: u,
    index: d
  };
}
function h3(e, t, n, a, r, o, s, i) {
  const u = {
    passive: !0,
    capture: !0
  };
  let d = 0;
  function c(v) {
    if (!i) return;
    function m(y) {
      if ((/* @__PURE__ */ new Date()).getTime() - d > 10) return;
      s.emit("slideFocusStart"), e.scrollLeft = 0;
      const S = n.findIndex(($) => $.includes(y));
      hf(S) && (r.useDuration(0), a.index(S, 0), s.emit("slideFocus"));
    }
    o.add(document, "keydown", f, !1), t.forEach((y, x) => {
      o.add(y, "focus", (C) => {
        (Ui(i) || i(v, C)) && m(x);
      }, u);
    });
  }
  function f(v) {
    v.code === "Tab" && (d = (/* @__PURE__ */ new Date()).getTime());
  }
  return {
    init: c
  };
}
function Co(e) {
  let t = e;
  function n() {
    return t;
  }
  function a(u) {
    t = s(u);
  }
  function r(u) {
    t += s(u);
  }
  function o(u) {
    t -= s(u);
  }
  function s(u) {
    return hf(u) ? u : u.get();
  }
  return {
    get: n,
    set: a,
    add: r,
    subtract: o
  };
}
function Yy(e, t) {
  const n = e.scroll === "x" ? s : i, a = t.style;
  let r = null, o = !1;
  function s(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function i(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function u(p) {
    if (o) return;
    const v = JO(e.direction(p));
    v !== r && (a.transform = n(v), r = v);
  }
  function d(p) {
    o = !p;
  }
  function c() {
    o || (a.transform = "", t.getAttribute("style") || t.removeAttribute("style"));
  }
  return {
    clear: c,
    to: u,
    toggleActive: d
  };
}
function g3(e, t, n, a, r, o, s, i, u) {
  const c = Ho(r), f = Ho(r).reverse(), p = C().concat(S());
  function v(M, q) {
    return M.reduce((E, D) => E - r[D], q);
  }
  function m(M, q) {
    return M.reduce((E, D) => v(E, q) > 0 ? E.concat([D]) : E, []);
  }
  function y(M) {
    return o.map((q, E) => ({
      start: q - a[E] + 0.5 + M,
      end: q + t - 0.5 + M
    }));
  }
  function x(M, q, E) {
    const D = y(q);
    return M.map((O) => {
      const F = E ? 0 : -n, J = E ? n : 0, ne = E ? "end" : "start", Q = D[O][ne];
      return {
        index: O,
        loopPoint: Q,
        slideLocation: Co(-1),
        translate: Yy(e, u[O]),
        target: () => i.get() > Q ? F : J
      };
    });
  }
  function C() {
    const M = s[0], q = m(f, M);
    return x(q, n, !1);
  }
  function S() {
    const M = t - s[0] - 1, q = m(c, M);
    return x(q, -n, !0);
  }
  function $() {
    return p.every(({
      index: M
    }) => {
      const q = c.filter((E) => E !== M);
      return v(q, t) <= 0.1;
    });
  }
  function k() {
    p.forEach((M) => {
      const {
        target: q,
        translate: E,
        slideLocation: D
      } = M, O = q();
      O !== D.get() && (E.to(O), D.set(O));
    });
  }
  function B() {
    p.forEach((M) => M.translate.clear());
  }
  return {
    canLoop: $,
    clear: B,
    loop: k,
    loopPoints: p
  };
}
function y3(e, t, n) {
  let a, r = !1;
  function o(u) {
    if (!n) return;
    function d(c) {
      for (const f of c)
        if (f.type === "childList") {
          u.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    a = new MutationObserver((c) => {
      r || (Ui(n) || n(u, c)) && d(c);
    }), a.observe(e, {
      childList: !0
    });
  }
  function s() {
    a && a.disconnect(), r = !0;
  }
  return {
    init: o,
    destroy: s
  };
}
function b3(e, t, n, a) {
  const r = {};
  let o = null, s = null, i, u = !1;
  function d() {
    i = new IntersectionObserver((m) => {
      u || (m.forEach((y) => {
        const x = t.indexOf(y.target);
        r[x] = y;
      }), o = null, s = null, n.emit("slidesInView"));
    }, {
      root: e.parentElement,
      threshold: a
    }), t.forEach((m) => i.observe(m));
  }
  function c() {
    i && i.disconnect(), u = !0;
  }
  function f(m) {
    return Uo(r).reduce((y, x) => {
      const C = parseInt(x), {
        isIntersecting: S
      } = r[C];
      return (m && S || !m && !S) && y.push(C), y;
    }, []);
  }
  function p(m = !0) {
    if (m && o) return o;
    if (!m && s) return s;
    const y = f(m);
    return m && (o = y), m || (s = y), y;
  }
  return {
    init: d,
    destroy: c,
    get: p
  };
}
function _3(e, t, n, a, r, o) {
  const {
    measureSize: s,
    startEdge: i,
    endEdge: u
  } = e, d = n[0] && r, c = m(), f = y(), p = n.map(s), v = x();
  function m() {
    if (!d) return 0;
    const S = n[0];
    return mt(t[i] - S[i]);
  }
  function y() {
    if (!d) return 0;
    const S = o.getComputedStyle(Mn(a));
    return parseFloat(S.getPropertyValue(`margin-${u}`));
  }
  function x() {
    return n.map((S, $, k) => {
      const B = !$, P = yf(k, $);
      return B ? p[$] + c : P ? p[$] + f : k[$ + 1][i] - S[i];
    }).map(mt);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: v,
    startGap: c,
    endGap: f
  };
}
function w3(e, t, n, a, r, o, s, i, u) {
  const {
    startEdge: d,
    endEdge: c,
    direction: f
  } = e, p = hf(n);
  function v(C, S) {
    return Ho(C).filter(($) => $ % S === 0).map(($) => C.slice($, $ + S));
  }
  function m(C) {
    return C.length ? Ho(C).reduce((S, $, k) => {
      const B = Mn(S) || 0, P = B === 0, M = $ === xs(C), q = r[d] - o[B][d], E = r[d] - o[$][c], D = !a && P ? f(s) : 0, O = !a && M ? f(i) : 0, F = mt(E - O - (q + D));
      return k && F > t + u && S.push($), M && S.push(C.length), S;
    }, []).map((S, $, k) => {
      const B = Math.max(k[$ - 1] || 0);
      return C.slice(B, S);
    }) : [];
  }
  function y(C) {
    return p ? v(C, n) : m(C);
  }
  return {
    groupSlides: y
  };
}
function x3(e, t, n, a, r, o, s) {
  const {
    align: i,
    axis: u,
    direction: d,
    startIndex: c,
    loop: f,
    duration: p,
    dragFree: v,
    dragThreshold: m,
    inViewThreshold: y,
    slidesToScroll: x,
    skipSnaps: C,
    containScroll: S,
    watchResize: $,
    watchSlides: k,
    watchDrag: B,
    watchFocus: P
  } = o, M = 2, q = a3(), E = q.measure(t), D = n.map(q.measure), O = e3(u, d), F = O.measureSize(E), J = r3(F), ne = ZO(i, F), Q = !f && !!S, W = f || !!S, {
    slideSizes: H,
    slideSizesWithGaps: U,
    startGap: se,
    endGap: ee
  } = _3(O, E, D, n, W, r), de = w3(O, F, x, f, E, D, se, ee, M), {
    snaps: fe,
    snapsAligned: _e
  } = f3(O, ne, E, D, de), ye = -Mn(fe) + Mn(U), {
    snapsContained: Ee,
    scrollContainLimit: ce
  } = i3(F, ye, _e, S, M), V = Q ? Ee : _e, {
    limit: te
  } = u3(ye, V, f), z = Ky(xs(V), c, f), re = z.clone(), ie = Ho(n), L = ({
    dragHandler: Ot,
    scrollBody: K,
    scrollBounds: Y,
    options: {
      loop: ue
    }
  }) => {
    ue || Y.constrain(Ot.pointerDown()), K.seek();
  }, be = ({
    scrollBody: Ot,
    translate: K,
    location: Y,
    offsetLocation: ue,
    previousLocation: ge,
    scrollLooper: Me,
    slideLooper: Oe,
    dragHandler: Ae,
    animation: ot,
    eventHandler: ft,
    scrollBounds: qt,
    options: {
      loop: at
    }
  }, Bt) => {
    const Rt = Ot.settled(), Yt = !qt.shouldConstrain(), ha = at ? Rt : Rt && Yt, mr = ha && !Ae.pointerDown();
    mr && ot.stop();
    const oo = Y.get() * Bt + ge.get() * (1 - Bt);
    ue.set(oo), at && (Me.loop(Ot.direction()), Oe.loop()), K.to(ue.get()), mr && ft.emit("settle"), ha || ft.emit("scroll");
  }, xe = QO(a, r, () => L(Wt), (Ot) => be(Wt, Ot)), Ne = 0.68, Xe = V[z.get()], lt = Co(Xe), ke = Co(Xe), Le = Co(Xe), Ue = Co(Xe), We = s3(lt, Le, ke, Ue, p, Ne), it = v3(f, V, ye, te, Ue), ut = m3(xe, z, re, We, it, Ue, s), $t = c3(te), on = jo(), hn = b3(t, n, s, y), {
    slideRegistry: Ve
  } = p3(Q, S, V, ce, de, ie), Dt = h3(e, n, Ve, ut, We, on, s, P), Wt = {
    ownerDocument: a,
    ownerWindow: r,
    eventHandler: s,
    containerRect: E,
    slideRects: D,
    animation: xe,
    axis: O,
    dragHandler: t3(O, e, a, r, Ue, n3(O, r), lt, xe, ut, We, it, z, s, J, v, m, C, Ne, B),
    eventStore: on,
    percentOfView: J,
    index: z,
    indexPrevious: re,
    limit: te,
    location: lt,
    offsetLocation: Le,
    previousLocation: ke,
    options: o,
    resizeHandler: o3(t, s, r, n, O, $, q),
    scrollBody: We,
    scrollBounds: l3(te, Le, Ue, We, J),
    scrollLooper: d3(ye, te, Le, [lt, Le, ke, Ue]),
    scrollProgress: $t,
    scrollSnapList: V.map($t.get),
    scrollSnaps: V,
    scrollTarget: it,
    scrollTo: ut,
    slideLooper: g3(O, F, ye, H, U, fe, V, Le, n),
    slideFocus: Dt,
    slidesHandler: y3(t, s, k),
    slidesInView: hn,
    slideIndexes: ie,
    slideRegistry: Ve,
    slidesToScroll: de,
    target: Ue,
    translate: Yy(O, t)
  };
  return Wt;
}
function C3() {
  let e = {}, t;
  function n(d) {
    t = d;
  }
  function a(d) {
    return e[d] || [];
  }
  function r(d) {
    return a(d).forEach((c) => c(t, d)), u;
  }
  function o(d, c) {
    return e[d] = a(d).concat([c]), u;
  }
  function s(d, c) {
    return e[d] = a(d).filter((f) => f !== c), u;
  }
  function i() {
    e = {};
  }
  const u = {
    init: n,
    emit: r,
    off: s,
    on: o,
    clear: i
  };
  return u;
}
const S3 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0,
  watchFocus: !0
};
function $3(e) {
  function t(o, s) {
    return Gy(o, s || {});
  }
  function n(o) {
    const s = o.breakpoints || {}, i = Uo(s).filter((u) => e.matchMedia(u).matches).map((u) => s[u]).reduce((u, d) => t(u, d), {});
    return t(o, i);
  }
  function a(o) {
    return o.map((s) => Uo(s.breakpoints || {})).reduce((s, i) => s.concat(i), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: a
  };
}
function B3(e) {
  let t = [];
  function n(o, s) {
    return t = s.filter(({
      options: i
    }) => e.optionsAtMedia(i).active !== !1), t.forEach((i) => i.init(o, e)), s.reduce((i, u) => Object.assign(i, {
      [u.name]: u
    }), {});
  }
  function a() {
    t = t.filter((o) => o.destroy());
  }
  return {
    init: n,
    destroy: a
  };
}
function Rl(e, t, n) {
  const a = e.ownerDocument, r = a.defaultView, o = $3(r), s = B3(o), i = jo(), u = C3(), {
    mergeOptions: d,
    optionsAtMedia: c,
    optionsMediaQueries: f
  } = o, {
    on: p,
    off: v,
    emit: m
  } = u, y = O;
  let x = !1, C, S = d(S3, Rl.globalOptions), $ = d(S), k = [], B, P, M;
  function q() {
    const {
      container: ie,
      slides: L
    } = $;
    P = (Cd(ie) ? e.querySelector(ie) : ie) || e.children[0];
    const xe = Cd(L) ? P.querySelectorAll(L) : L;
    M = [].slice.call(xe || P.children);
  }
  function E(ie) {
    const L = x3(e, P, M, a, r, ie, u);
    if (ie.loop && !L.slideLooper.canLoop()) {
      const be = Object.assign({}, ie, {
        loop: !1
      });
      return E(be);
    }
    return L;
  }
  function D(ie, L) {
    x || (S = d(S, ie), $ = c(S), k = L || k, q(), C = E($), f([S, ...k.map(({
      options: be
    }) => be)]).forEach((be) => i.add(be, "change", O)), $.active && (C.translate.to(C.location.get()), C.animation.init(), C.slidesInView.init(), C.slideFocus.init(re), C.eventHandler.init(re), C.resizeHandler.init(re), C.slidesHandler.init(re), C.options.loop && C.slideLooper.loop(), P.offsetParent && M.length && C.dragHandler.init(re), B = s.init(re, k)));
  }
  function O(ie, L) {
    const be = de();
    F(), D(d({
      startIndex: be
    }, ie), L), u.emit("reInit");
  }
  function F() {
    C.dragHandler.destroy(), C.eventStore.clear(), C.translate.clear(), C.slideLooper.clear(), C.resizeHandler.destroy(), C.slidesHandler.destroy(), C.slidesInView.destroy(), C.animation.destroy(), s.destroy(), i.clear();
  }
  function J() {
    x || (x = !0, i.clear(), F(), u.emit("destroy"), u.clear());
  }
  function ne(ie, L, be) {
    !$.active || x || (C.scrollBody.useBaseFriction().useDuration(L === !0 ? 0 : $.duration), C.scrollTo.index(ie, be || 0));
  }
  function Q(ie) {
    const L = C.index.add(1).get();
    ne(L, ie, -1);
  }
  function W(ie) {
    const L = C.index.add(-1).get();
    ne(L, ie, 1);
  }
  function H() {
    return C.index.add(1).get() !== de();
  }
  function U() {
    return C.index.add(-1).get() !== de();
  }
  function se() {
    return C.scrollSnapList;
  }
  function ee() {
    return C.scrollProgress.get(C.offsetLocation.get());
  }
  function de() {
    return C.index.get();
  }
  function fe() {
    return C.indexPrevious.get();
  }
  function _e() {
    return C.slidesInView.get();
  }
  function ye() {
    return C.slidesInView.get(!1);
  }
  function Ee() {
    return B;
  }
  function ce() {
    return C;
  }
  function V() {
    return e;
  }
  function te() {
    return P;
  }
  function z() {
    return M;
  }
  const re = {
    canScrollNext: H,
    canScrollPrev: U,
    containerNode: te,
    internalEngine: ce,
    destroy: J,
    off: v,
    on: p,
    emit: m,
    plugins: Ee,
    previousScrollSnap: fe,
    reInit: y,
    rootNode: V,
    scrollNext: Q,
    scrollPrev: W,
    scrollProgress: ee,
    scrollSnapList: se,
    scrollTo: ne,
    selectedScrollSnap: de,
    slideNodes: z,
    slidesInView: _e,
    slidesNotInView: ye
  };
  return D(t, n), setTimeout(() => u.emit("init"), 0), re;
}
Rl.globalOptions = void 0;
function bf(e = {}, t = []) {
  const n = Ct(e), a = Ct(t);
  let r = n ? e.value : e, o = a ? t.value : t;
  const s = ht(), i = ht();
  function u() {
    i.value && i.value.reInit(r, o);
  }
  return Ce(() => {
    !KO() || !s.value || (Rl.globalOptions = bf.globalOptions, i.value = Rl(s.value, r, o));
  }), Ea(() => {
    i.value && i.value.destroy();
  }), n && me(e, (d) => {
    mf(r, d) || (r = d, u());
  }), a && me(t, (d) => {
    YO(o, d) || (o = d, u());
  }), [s, i];
}
bf.globalOptions = void 0;
const [k3, P3] = /* @__PURE__ */ $0(
  ({ opts: e, orientation: t, plugins: n }, a) => {
    const [r, o] = bf(
      {
        ...e,
        axis: t === "horizontal" ? "x" : "y"
      },
      n
    );
    function s() {
      o.value?.scrollPrev();
    }
    function i() {
      o.value?.scrollNext();
    }
    const u = I(!1), d = I(!1);
    function c(f) {
      u.value = f?.canScrollNext() || !1, d.value = f?.canScrollPrev() || !1;
    }
    return Ce(() => {
      o.value && (o.value?.on("init", c), o.value?.on("reInit", c), o.value?.on("select", c), a("init-api", o.value));
    }), {
      carouselRef: r,
      carouselApi: o,
      canScrollPrev: d,
      canScrollNext: u,
      scrollPrev: s,
      scrollNext: i,
      orientation: t
    };
  }
);
function ji() {
  const e = P3();
  if (!e) throw new Error("useCarousel must be used within a <Carousel />");
  return e;
}
const ZH = /* @__PURE__ */ b({
  __name: "Carousel",
  props: {
    opts: {},
    plugins: {},
    orientation: { default: "horizontal" },
    class: {}
  },
  emits: ["init-api"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, {
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    } = k3(a, r);
    t({
      canScrollNext: o,
      canScrollPrev: s,
      carouselApi: i,
      carouselRef: u,
      orientation: d,
      scrollNext: c,
      scrollPrev: f
    });
    function p(v) {
      const m = a.orientation === "vertical" ? "ArrowUp" : "ArrowLeft", y = a.orientation === "vertical" ? "ArrowDown" : "ArrowRight";
      if (v.key === m) {
        v.preventDefault(), f();
        return;
      }
      v.key === y && (v.preventDefault(), c());
    }
    return (v, m) => (h(), G("div", {
      class: ae(l(R)("relative", a.class)),
      role: "region",
      "aria-roledescription": "carousel",
      tabindex: "0",
      onKeydown: p
    }, [
      _(v.$slots, "default", {
        canScrollNext: l(o),
        canScrollPrev: l(s),
        carouselApi: l(i),
        carouselRef: l(u),
        orientation: l(d),
        scrollNext: l(c),
        scrollPrev: l(f)
      })
    ], 34));
  }
}), QH = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CarouselContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { carouselRef: n, orientation: a } = ji();
    return (r, o) => (h(), G("div", {
      ref_key: "carouselRef",
      ref: n,
      class: "overflow-hidden"
    }, [
      we("div", T({
        class: l(R)("flex", l(a) === "horizontal" ? "-ml-4" : "-mt-4 flex-col", t.class)
      }, r.$attrs), [
        _(r.$slots, "default")
      ], 16)
    ], 512));
  }
}), e7 = /* @__PURE__ */ b({
  __name: "CarouselItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n } = ji();
    return (a, r) => (h(), G("div", {
      role: "group",
      "aria-roledescription": "slide",
      class: ae(
        l(R)(
          "min-w-0 shrink-0 grow-0 basis-full",
          l(n) === "horizontal" ? "pl-4" : "pt-4",
          t.class
        )
      )
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), t7 = /* @__PURE__ */ b({
  __name: "CarouselPrevious",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollPrev: a, scrollPrev: r } = ji();
    return (o, s) => (h(), w(l(bs), {
      disabled: !l(a),
      class: ae(
        l(R)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -left-12 -translate-y-1/2" : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: g(() => [
        _(o.$slots, "default", {}, () => [
          N(l(sI), { class: "size-4 text-current" }),
          s[0] || (s[0] = we("span", { class: "sr-only" }, "Previous Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
}), n7 = /* @__PURE__ */ b({
  __name: "CarouselNext",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { orientation: n, canScrollNext: a, scrollNext: r } = ji();
    return (o, s) => (h(), w(l(bs), {
      disabled: !l(a),
      class: ae(
        l(R)(
          "absolute size-8 touch-manipulation rounded-full p-0",
          l(n) === "horizontal" ? "top-1/2 -right-12 -translate-y-1/2" : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          t.class
        )
      ),
      variant: "outline",
      onClick: l(r)
    }, {
      default: g(() => [
        _(o.$slots, "default", {}, () => [
          N(l(lI), { class: "size-4 text-current" }),
          s[0] || (s[0] = we("span", { class: "sr-only" }, "Next Slide", -1))
        ])
      ]),
      _: 3
    }, 8, ["disabled", "class", "onClick"]));
  }
});
var $d = "http://www.w3.org/1999/xhtml";
const Cv = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: $d,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Wi(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Cv.hasOwnProperty(t) ? { space: Cv[t], local: e } : e;
}
function M3(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === $d && t.documentElement.namespaceURI === $d ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function D3(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function Xy(e) {
  var t = Wi(e);
  return (t.local ? D3 : M3)(t);
}
function q3() {
}
function _f(e) {
  return e == null ? q3 : function() {
    return this.querySelector(e);
  };
}
function A3(e) {
  typeof e != "function" && (e = _f(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = new Array(s), u, d, c = 0; c < s; ++c)
      (u = o[c]) && (d = e.call(u, u.__data__, c, o)) && ("__data__" in u && (d.__data__ = u.__data__), i[c] = d);
  return new vn(a, this._parents);
}
function E3(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function T3() {
  return [];
}
function Jy(e) {
  return e == null ? T3 : function() {
    return this.querySelectorAll(e);
  };
}
function I3(e) {
  return function() {
    return E3(e.apply(this, arguments));
  };
}
function O3(e) {
  typeof e == "function" ? e = I3(e) : e = Jy(e);
  for (var t = this._groups, n = t.length, a = [], r = [], o = 0; o < n; ++o)
    for (var s = t[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && (a.push(e.call(u, u.__data__, d, s)), r.push(u));
  return new vn(a, r);
}
function Zy(e) {
  return function() {
    return this.matches(e);
  };
}
function Qy(e) {
  return function(t) {
    return t.matches(e);
  };
}
var R3 = Array.prototype.find;
function V3(e) {
  return function() {
    return R3.call(this.children, e);
  };
}
function F3() {
  return this.firstElementChild;
}
function N3(e) {
  return this.select(e == null ? F3 : V3(typeof e == "function" ? e : Qy(e)));
}
var L3 = Array.prototype.filter;
function z3() {
  return Array.from(this.children);
}
function H3(e) {
  return function() {
    return L3.call(this.children, e);
  };
}
function U3(e) {
  return this.selectAll(e == null ? z3 : H3(typeof e == "function" ? e : Qy(e)));
}
function j3(e) {
  typeof e != "function" && (e = Zy(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new vn(a, this._parents);
}
function eb(e) {
  return new Array(e.length);
}
function W3() {
  return new vn(this._enter || this._groups.map(eb), this._parents);
}
function Vl(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Vl.prototype = {
  constructor: Vl,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function G3(e) {
  return function() {
    return e;
  };
}
function K3(e, t, n, a, r, o) {
  for (var s = 0, i, u = t.length, d = o.length; s < d; ++s)
    (i = t[s]) ? (i.__data__ = o[s], a[s] = i) : n[s] = new Vl(e, o[s]);
  for (; s < u; ++s)
    (i = t[s]) && (r[s] = i);
}
function Y3(e, t, n, a, r, o, s) {
  var i, u, d = /* @__PURE__ */ new Map(), c = t.length, f = o.length, p = new Array(c), v;
  for (i = 0; i < c; ++i)
    (u = t[i]) && (p[i] = v = s.call(u, u.__data__, i, t) + "", d.has(v) ? r[i] = u : d.set(v, u));
  for (i = 0; i < f; ++i)
    v = s.call(e, o[i], i, o) + "", (u = d.get(v)) ? (a[i] = u, u.__data__ = o[i], d.delete(v)) : n[i] = new Vl(e, o[i]);
  for (i = 0; i < c; ++i)
    (u = t[i]) && d.get(p[i]) === u && (r[i] = u);
}
function X3(e) {
  return e.__data__;
}
function J3(e, t) {
  if (!arguments.length) return Array.from(this, X3);
  var n = t ? Y3 : K3, a = this._parents, r = this._groups;
  typeof e != "function" && (e = G3(e));
  for (var o = r.length, s = new Array(o), i = new Array(o), u = new Array(o), d = 0; d < o; ++d) {
    var c = a[d], f = r[d], p = f.length, v = Z3(e.call(c, c && c.__data__, d, a)), m = v.length, y = i[d] = new Array(m), x = s[d] = new Array(m), C = u[d] = new Array(p);
    n(c, f, y, x, C, v, t);
    for (var S = 0, $ = 0, k, B; S < m; ++S)
      if (k = y[S]) {
        for (S >= $ && ($ = S + 1); !(B = x[$]) && ++$ < m; ) ;
        k._next = B || null;
      }
  }
  return s = new vn(s, a), s._enter = i, s._exit = u, s;
}
function Z3(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Q3() {
  return new vn(this._exit || this._groups.map(eb), this._parents);
}
function eR(e, t, n) {
  var a = this.enter(), r = this, o = this.exit();
  return typeof e == "function" ? (a = e(a), a && (a = a.selection())) : a = a.append(e + ""), t != null && (r = t(r), r && (r = r.selection())), n == null ? o.remove() : n(o), a && r ? a.merge(r).order() : r;
}
function tR(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, a = t._groups, r = n.length, o = a.length, s = Math.min(r, o), i = new Array(r), u = 0; u < s; ++u)
    for (var d = n[u], c = a[u], f = d.length, p = i[u] = new Array(f), v, m = 0; m < f; ++m)
      (v = d[m] || c[m]) && (p[m] = v);
  for (; u < r; ++u)
    i[u] = n[u];
  return new vn(i, this._parents);
}
function nR() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var a = e[t], r = a.length - 1, o = a[r], s; --r >= 0; )
      (s = a[r]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
  return this;
}
function aR(e) {
  e || (e = rR);
  function t(f, p) {
    return f && p ? e(f.__data__, p.__data__) : !f - !p;
  }
  for (var n = this._groups, a = n.length, r = new Array(a), o = 0; o < a; ++o) {
    for (var s = n[o], i = s.length, u = r[o] = new Array(i), d, c = 0; c < i; ++c)
      (d = s[c]) && (u[c] = d);
    u.sort(t);
  }
  return new vn(r, this._parents).order();
}
function rR(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function oR() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function sR() {
  return Array.from(this);
}
function lR() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length; r < o; ++r) {
      var s = a[r];
      if (s) return s;
    }
  return null;
}
function iR() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function uR() {
  return !this.node();
}
function dR(e) {
  for (var t = this._groups, n = 0, a = t.length; n < a; ++n)
    for (var r = t[n], o = 0, s = r.length, i; o < s; ++o)
      (i = r[o]) && e.call(i, i.__data__, o, r);
  return this;
}
function cR(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function fR(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function pR(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function vR(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function mR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function hR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function gR(e, t) {
  var n = Wi(e);
  if (arguments.length < 2) {
    var a = this.node();
    return n.local ? a.getAttributeNS(n.space, n.local) : a.getAttribute(n);
  }
  return this.each((t == null ? n.local ? fR : cR : typeof t == "function" ? n.local ? hR : mR : n.local ? vR : pR)(n, t));
}
function tb(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function yR(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function bR(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function _R(e, t, n) {
  return function() {
    var a = t.apply(this, arguments);
    a == null ? this.style.removeProperty(e) : this.style.setProperty(e, a, n);
  };
}
function wR(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? yR : typeof t == "function" ? _R : bR)(e, t, n ?? "")) : Vr(this.node(), e);
}
function Vr(e, t) {
  return e.style.getPropertyValue(t) || tb(e).getComputedStyle(e, null).getPropertyValue(t);
}
function xR(e) {
  return function() {
    delete this[e];
  };
}
function CR(e, t) {
  return function() {
    this[e] = t;
  };
}
function SR(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function $R(e, t) {
  return arguments.length > 1 ? this.each((t == null ? xR : typeof t == "function" ? SR : CR)(e, t)) : this.node()[e];
}
function nb(e) {
  return e.trim().split(/^|\s+/);
}
function wf(e) {
  return e.classList || new ab(e);
}
function ab(e) {
  this._node = e, this._names = nb(e.getAttribute("class") || "");
}
ab.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function rb(e, t) {
  for (var n = wf(e), a = -1, r = t.length; ++a < r; ) n.add(t[a]);
}
function ob(e, t) {
  for (var n = wf(e), a = -1, r = t.length; ++a < r; ) n.remove(t[a]);
}
function BR(e) {
  return function() {
    rb(this, e);
  };
}
function kR(e) {
  return function() {
    ob(this, e);
  };
}
function PR(e, t) {
  return function() {
    (t.apply(this, arguments) ? rb : ob)(this, e);
  };
}
function MR(e, t) {
  var n = nb(e + "");
  if (arguments.length < 2) {
    for (var a = wf(this.node()), r = -1, o = n.length; ++r < o; ) if (!a.contains(n[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? PR : t ? BR : kR)(n, t));
}
function DR() {
  this.textContent = "";
}
function qR(e) {
  return function() {
    this.textContent = e;
  };
}
function AR(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function ER(e) {
  return arguments.length ? this.each(e == null ? DR : (typeof e == "function" ? AR : qR)(e)) : this.node().textContent;
}
function TR() {
  this.innerHTML = "";
}
function IR(e) {
  return function() {
    this.innerHTML = e;
  };
}
function OR(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function RR(e) {
  return arguments.length ? this.each(e == null ? TR : (typeof e == "function" ? OR : IR)(e)) : this.node().innerHTML;
}
function VR() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function FR() {
  return this.each(VR);
}
function NR() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function LR() {
  return this.each(NR);
}
function zR(e) {
  var t = typeof e == "function" ? e : Xy(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function HR() {
  return null;
}
function UR(e, t) {
  var n = typeof e == "function" ? e : Xy(e), a = t == null ? HR : typeof t == "function" ? t : _f(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), a.apply(this, arguments) || null);
  });
}
function jR() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function WR() {
  return this.each(jR);
}
function GR() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function KR() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function YR(e) {
  return this.select(e ? KR : GR);
}
function XR(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function JR(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function ZR(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", a = t.indexOf(".");
    return a >= 0 && (n = t.slice(a + 1), t = t.slice(0, a)), { type: t, name: n };
  });
}
function QR(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, a = -1, r = t.length, o; n < r; ++n)
        o = t[n], (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++a] = o;
      ++a ? t.length = a : delete this.__on;
    }
  };
}
function eV(e, t, n) {
  return function() {
    var a = this.__on, r, o = JR(t);
    if (a) {
      for (var s = 0, i = a.length; s < i; ++s)
        if ((r = a[s]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = o, r.options = n), r.value = t;
          return;
        }
    }
    this.addEventListener(e.type, o, n), r = { type: e.type, name: e.name, value: t, listener: o, options: n }, a ? a.push(r) : this.__on = [r];
  };
}
function tV(e, t, n) {
  var a = ZR(e + ""), r, o = a.length, s;
  if (arguments.length < 2) {
    var i = this.node().__on;
    if (i) {
      for (var u = 0, d = i.length, c; u < d; ++u)
        for (r = 0, c = i[u]; r < o; ++r)
          if ((s = a[r]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (i = t ? eV : QR, r = 0; r < o; ++r) this.each(i(a[r], t, n));
  return this;
}
function sb(e, t, n) {
  var a = tb(e), r = a.CustomEvent;
  typeof r == "function" ? r = new r(t, n) : (r = a.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r);
}
function nV(e, t) {
  return function() {
    return sb(this, e, t);
  };
}
function aV(e, t) {
  return function() {
    return sb(this, e, t.apply(this, arguments));
  };
}
function rV(e, t) {
  return this.each((typeof t == "function" ? aV : nV)(e, t));
}
function* oV() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var a = e[t], r = 0, o = a.length, s; r < o; ++r)
      (s = a[r]) && (yield s);
}
var lb = [null];
function vn(e, t) {
  this._groups = e, this._parents = t;
}
function Cs() {
  return new vn([[document.documentElement]], lb);
}
function sV() {
  return this;
}
vn.prototype = Cs.prototype = {
  constructor: vn,
  select: A3,
  selectAll: O3,
  selectChild: N3,
  selectChildren: U3,
  filter: j3,
  data: J3,
  enter: W3,
  exit: Q3,
  join: eR,
  merge: tR,
  selection: sV,
  order: nR,
  sort: aR,
  call: oR,
  nodes: sR,
  node: lR,
  size: iR,
  empty: uR,
  each: dR,
  attr: gR,
  style: wR,
  property: $R,
  classed: MR,
  text: ER,
  html: RR,
  raise: FR,
  lower: LR,
  append: zR,
  insert: UR,
  remove: WR,
  clone: YR,
  datum: XR,
  on: tV,
  dispatch: rV,
  [Symbol.iterator]: oV
};
function Ma(e) {
  return typeof e == "string" ? new vn([[document.querySelector(e)]], [document.documentElement]) : new vn([[e]], lb);
}
function lV(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Fl(e, t) {
  if (e = lV(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var a = n.createSVGPoint();
      return a.x = e.clientX, a.y = e.clientY, a = a.matrixTransform(t.getScreenCTM().inverse()), [a.x, a.y];
    }
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect();
      return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
var Ao;
(function(e) {
  e[e.SVG = 0] = "SVG", e[e.HTML = 1] = "HTML";
})(Ao || (Ao = {}));
var Bd;
(function(e) {
  e.Fit = "fit", e.Extend = "extend", e.FitWidth = "fit_width";
})(Bd || (Bd = {}));
function Eo(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function iV(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function xf(e) {
  let t, n, a;
  e.length !== 2 ? (t = Eo, n = (i, u) => Eo(e(i), u), a = (i, u) => e(i) - u) : (t = e === Eo || e === iV ? e : uV, n = e, a = e);
  function r(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) < 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function o(i, u, d = 0, c = i.length) {
    if (d < c) {
      if (t(u, u) !== 0) return c;
      do {
        const f = d + c >>> 1;
        n(i[f], u) <= 0 ? d = f + 1 : c = f;
      } while (d < c);
    }
    return d;
  }
  function s(i, u, d = 0, c = i.length) {
    const f = r(i, u, d, c - 1);
    return f > d && a(i[f - 1], u) > -a(i[f], u) ? f - 1 : f;
  }
  return { left: r, center: s, right: o };
}
function uV() {
  return 0;
}
function ib(e) {
  return e === null ? NaN : +e;
}
const ub = xf(Eo), Ss = ub.right, dV = ub.left;
xf(ib).center;
class Sv extends Map {
  constructor(t, n = pV) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [a, r] of t) this.set(a, r);
  }
  get(t) {
    return super.get($v(this, t));
  }
  has(t) {
    return super.has($v(this, t));
  }
  set(t, n) {
    return super.set(cV(this, t), n);
  }
  delete(t) {
    return super.delete(fV(this, t));
  }
}
function $v({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : n;
}
function cV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) ? e.get(a) : (e.set(a, n), n);
}
function fV({ _intern: e, _key: t }, n) {
  const a = t(n);
  return e.has(a) && (n = e.get(a), e.delete(a)), n;
}
function pV(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const vV = Math.sqrt(50), mV = Math.sqrt(10), hV = Math.sqrt(2);
function Nl(e, t, n) {
  const a = (t - e) / Math.max(0, n), r = Math.floor(Math.log10(a)), o = a / Math.pow(10, r), s = o >= vV ? 10 : o >= mV ? 5 : o >= hV ? 2 : 1;
  let i, u, d;
  return r < 0 ? (d = Math.pow(10, -r) / s, i = Math.round(e * d), u = Math.round(t * d), i / d < e && ++i, u / d > t && --u, d = -d) : (d = Math.pow(10, r) * s, i = Math.round(e / d), u = Math.round(t / d), i * d < e && ++i, u * d > t && --u), u < i && 0.5 <= n && n < 2 ? Nl(e, t, n * 2) : [i, u, d];
}
function kd(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0)) return [];
  if (e === t) return [e];
  const a = t < e, [r, o, s] = a ? Nl(t, e, n) : Nl(e, t, n);
  if (!(o >= r)) return [];
  const i = o - r + 1, u = new Array(i);
  if (a)
    if (s < 0) for (let d = 0; d < i; ++d) u[d] = (o - d) / -s;
    else for (let d = 0; d < i; ++d) u[d] = (o - d) * s;
  else if (s < 0) for (let d = 0; d < i; ++d) u[d] = (r + d) / -s;
  else for (let d = 0; d < i; ++d) u[d] = (r + d) * s;
  return u;
}
function Pd(e, t, n) {
  return t = +t, e = +e, n = +n, Nl(e, t, n)[2];
}
function Md(e, t, n) {
  t = +t, e = +e, n = +n;
  const a = t < e, r = a ? Pd(t, e, n) : Pd(e, t, n);
  return (a ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function Bv(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n < a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function kv(e, t) {
  let n;
  if (t === void 0)
    for (const a of e)
      a != null && (n > a || n === void 0 && a >= a) && (n = a);
  else {
    let a = -1;
    for (let r of e)
      (r = t(r, ++a, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
  }
  return n;
}
function gV(e, t, n = ib) {
  if (!(!(a = e.length) || isNaN(t = +t))) {
    if (t <= 0 || a < 2) return +n(e[0], 0, e);
    if (t >= 1) return +n(e[a - 1], a - 1, e);
    var a, r = (a - 1) * t, o = Math.floor(r), s = +n(e[o], o, e), i = +n(e[o + 1], o + 1, e);
    return s + (i - s) * (r - o);
  }
}
function yV(e, t, n) {
  e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
  for (var a = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(r); ++a < r; )
    o[a] = e + a * n;
  return o;
}
function bV(e, t, n) {
  var a = {}, r = a.noTrailing, o = r === void 0 ? !1 : r, s = a.noLeading, i = s === void 0 ? !1 : s, u = a.debounceMode, d = u === void 0 ? void 0 : u, c, f = !1, p = 0;
  function v() {
    c && clearTimeout(c);
  }
  function m(x) {
    var C = x || {}, S = C.upcomingOnly, $ = S === void 0 ? !1 : S;
    v(), f = !$;
  }
  function y() {
    for (var x = arguments.length, C = new Array(x), S = 0; S < x; S++)
      C[S] = arguments[S];
    var $ = this, k = Date.now() - p;
    if (f)
      return;
    function B() {
      p = Date.now(), t.apply($, C);
    }
    function P() {
      c = void 0;
    }
    !i && d && !c && B(), v(), d === void 0 && k > e ? i ? (p = Date.now(), o || (c = setTimeout(d ? P : B, e))) : B() : o !== !0 && (c = setTimeout(d ? P : B, d === void 0 ? e - k : e));
  }
  return y.cancel = m, y;
}
var oa;
(function(e) {
  e.Left = "left", e.Right = "right", e.Auto = "auto";
})(oa || (oa = {}));
const To = (e) => typeof e == "number", Cf = (e) => typeof e == "function", Sf = (e) => Array.isArray(e), _V = (e) => e instanceof Object, Ll = (e) => e.constructor.name !== "Function" && e.constructor.name !== "Object", Pv = (e) => _V(e) && !Sf(e) && !Cf(e) && !Ll(e), Dd = (e, t, n = [], a = /* @__PURE__ */ new Set()) => {
  if (Array.isArray(e)) {
    if (!Array.isArray(t) || e.length !== t.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (let r = 0; r < e.length; r++)
      if (!Dd(e[r], t[r], n, a))
        return !1;
    return !0;
  }
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (typeof e == "object" && e !== null && t !== null) {
    if (typeof t != "object")
      return !1;
    if (e === t)
      return !0;
    const r = Object.keys(e).filter((s) => !n.includes(s)), o = Object.keys(t).filter((s) => !n.includes(s));
    if (r.length !== o.length)
      return !1;
    if (a.has(e))
      return !0;
    a.add(e);
    for (const s of r)
      if (!Dd(e[s], t[s], n, a))
        return !1;
    return !0;
  }
  return e === t;
}, zl = (e, t = /* @__PURE__ */ new Map()) => {
  if (typeof e != "object" || e === null)
    return e;
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof Array) {
    const n = [];
    t.set(e, n);
    for (const a of e)
      n.push(t.has(a) ? t.get(a) : zl(a, t));
    return n;
  }
  if (Ll(e))
    return e;
  if (e instanceof Object) {
    const n = {};
    t.set(e, n);
    const a = e;
    return Object.keys(e).reduce((r, o) => (r[o] = t.has(a[o]) ? t.get(a[o]) : zl(a[o], t), r), n), n;
  }
  return e;
}, Gi = (e, t, n = /* @__PURE__ */ new Map()) => {
  if (!e || !t || e === t)
    return e;
  const a = Ll(e) ? e : zl(e);
  return n.has(t) ? n.get(t) : (n.set(t, a), Object.keys(t).forEach((r) => {
    r === "__proto__" || r === "constructor" || (Pv(e[r]) && Pv(t[r]) ? a[r] = Gi(e[r], t[r], n) : Ll(t) ? a[r] = t : a[r] = zl(t[r]));
  }), a);
}, db = (e, t) => (e = Object.assign({}, e), t.forEach((n) => delete e[n]), e), Hl = (e, t, n) => bV(t, e);
function cb(e, t, n) {
  return Cf(t) ? t(e, n) : t;
}
function fb(e, t, n) {
  return cb(e, t, n);
}
function Jt(e, t, n) {
  return cb(e, t, n);
}
function Mv(e, t, n) {
  return Math.min(Math.max(e, t), n);
}
function wV(e, t, ...n) {
  const a = [];
  let r = 0, o = 0;
  for (const s of n) {
    const i = Jt(e, s, t) || 0;
    i >= 0 ? a.push(r += i) : a.push(o += i);
  }
  return a;
}
function xV(e, ...t) {
  return e ? kv(e, (a, r) => kv(t, (o) => Jt(a, o, r))) : void 0;
}
function CV(e, ...t) {
  return e ? Bv(e, (a, r) => Bv(t, (o) => Jt(a, o, r))) : void 0;
}
function Tu(e, ...t) {
  return [xV(e, ...t), CV(e, ...t)];
}
function Ul(e, t, n, a = oa.Auto) {
  if (e.length <= 1)
    return e[0];
  const o = e.map((u, d) => [u, d]).sort(([u, d], [c, f]) => Jt(u, n, d) - Jt(c, n, f)), s = o.map(([u, d]) => Jt(u, n, d)), i = a === oa.Right ? dV(s, t, 0, e.length - 1) : Ss(s, t, 1, e.length);
  return a === oa.Right ? o[i][0] : a === oa.Left ? o[i - 1][0] : t - s[i - 1] > s[i] - t ? o[i][0] : o[i - 1][0];
}
function SV(e, t, n, a = !1) {
  if (!n)
    return [];
  const r = e.filter((o, s) => {
    const i = Jt(o, n, s);
    return i >= t[0] && i <= t[1];
  });
  if (a) {
    if (r.length === 0) {
      const f = Ul(e, t[0], n, oa.Left), p = Ul(e, t[1], n, oa.Right);
      return [f, p].filter(Boolean);
    }
    const o = r[0], s = r[r.length - 1], i = e.findIndex((f) => f === o), u = e.findIndex((f) => f === s), d = Math.max(0, i - 1), c = Math.min(e.length - 1, u + 1);
    return e.slice(d, c + 1);
  }
  return r;
}
const $V = (e) => e == null ? [] : Array.isArray(e) ? e : [e];
function BV(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function kV(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var PV = /* @__PURE__ */ (function() {
  function e(n) {
    var a = this;
    this._insertTag = function(r) {
      var o;
      a.tags.length === 0 ? a.insertionPoint ? o = a.insertionPoint.nextSibling : a.prepend ? o = a.container.firstChild : o = a.before : o = a.tags[a.tags.length - 1].nextSibling, a.container.insertBefore(r, o), a.tags.push(r);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(a) {
    a.forEach(this._insertTag);
  }, t.insert = function(a) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(kV(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var o = BV(r);
      try {
        o.insertRule(a, o.cssRules.length);
      } catch {
      }
    } else
      r.appendChild(document.createTextNode(a));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(a) {
      var r;
      return (r = a.parentNode) == null ? void 0 : r.removeChild(a);
    }), this.tags = [], this.ctr = 0;
  }, e;
})(), Ht = "-ms-", jl = "-moz-", Qe = "-webkit-", pb = "comm", $f = "rule", Bf = "decl", MV = "@import", vb = "@keyframes", DV = "@layer", qV = Math.abs, Ki = String.fromCharCode, AV = Object.assign;
function EV(e, t) {
  return Ft(e, 0) ^ 45 ? (((t << 2 ^ Ft(e, 0)) << 2 ^ Ft(e, 1)) << 2 ^ Ft(e, 2)) << 2 ^ Ft(e, 3) : 0;
}
function mb(e) {
  return e.trim();
}
function TV(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function tt(e, t, n) {
  return e.replace(t, n);
}
function qd(e, t) {
  return e.indexOf(t);
}
function Ft(e, t) {
  return e.charCodeAt(t) | 0;
}
function Wo(e, t, n) {
  return e.slice(t, n);
}
function zn(e) {
  return e.length;
}
function kf(e) {
  return e.length;
}
function Ws(e, t) {
  return t.push(e), e;
}
function IV(e, t) {
  return e.map(t).join("");
}
var Yi = 1, Fr = 1, hb = 0, nn = 0, xt = 0, ao = "";
function Xi(e, t, n, a, r, o, s) {
  return { value: e, root: t, parent: n, type: a, props: r, children: o, line: Yi, column: Fr, length: s, return: "" };
}
function po(e, t) {
  return AV(Xi("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function OV() {
  return xt;
}
function RV() {
  return xt = nn > 0 ? Ft(ao, --nn) : 0, Fr--, xt === 10 && (Fr = 1, Yi--), xt;
}
function fn() {
  return xt = nn < hb ? Ft(ao, nn++) : 0, Fr++, xt === 10 && (Fr = 1, Yi++), xt;
}
function Wn() {
  return Ft(ao, nn);
}
function ul() {
  return nn;
}
function $s(e, t) {
  return Wo(ao, e, t);
}
function Go(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function gb(e) {
  return Yi = Fr = 1, hb = zn(ao = e), nn = 0, [];
}
function yb(e) {
  return ao = "", e;
}
function dl(e) {
  return mb($s(nn - 1, Ad(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function VV(e) {
  for (; (xt = Wn()) && xt < 33; )
    fn();
  return Go(e) > 2 || Go(xt) > 3 ? "" : " ";
}
function FV(e, t) {
  for (; --t && fn() && !(xt < 48 || xt > 102 || xt > 57 && xt < 65 || xt > 70 && xt < 97); )
    ;
  return $s(e, ul() + (t < 6 && Wn() == 32 && fn() == 32));
}
function Ad(e) {
  for (; fn(); )
    switch (xt) {
      // ] ) " '
      case e:
        return nn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Ad(xt);
        break;
      // (
      case 40:
        e === 41 && Ad(e);
        break;
      // \
      case 92:
        fn();
        break;
    }
  return nn;
}
function NV(e, t) {
  for (; fn() && e + xt !== 57; )
    if (e + xt === 84 && Wn() === 47)
      break;
  return "/*" + $s(t, nn - 1) + "*" + Ki(e === 47 ? e : fn());
}
function LV(e) {
  for (; !Go(Wn()); )
    fn();
  return $s(e, nn);
}
function zV(e) {
  return yb(cl("", null, null, null, [""], e = gb(e), 0, [0], e));
}
function cl(e, t, n, a, r, o, s, i, u) {
  for (var d = 0, c = 0, f = s, p = 0, v = 0, m = 0, y = 1, x = 1, C = 1, S = 0, $ = "", k = r, B = o, P = a, M = $; x; )
    switch (m = S, S = fn()) {
      // (
      case 40:
        if (m != 108 && Ft(M, f - 1) == 58) {
          qd(M += tt(dl(S), "&", "&\f"), "&\f") != -1 && (C = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        M += dl(S);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        M += VV(m);
        break;
      // \
      case 92:
        M += FV(ul() - 1, 7);
        continue;
      // /
      case 47:
        switch (Wn()) {
          case 42:
          case 47:
            Ws(HV(NV(fn(), ul()), t, n), u);
            break;
          default:
            M += "/";
        }
        break;
      // {
      case 123 * y:
        i[d++] = zn(M) * C;
      // } ; \0
      case 125 * y:
      case 59:
      case 0:
        switch (S) {
          // \0 }
          case 0:
          case 125:
            x = 0;
          // ;
          case 59 + c:
            C == -1 && (M = tt(M, /\f/g, "")), v > 0 && zn(M) - f && Ws(v > 32 ? qv(M + ";", a, n, f - 1) : qv(tt(M, " ", "") + ";", a, n, f - 2), u);
            break;
          // @ ;
          case 59:
            M += ";";
          // { rule/at-rule
          default:
            if (Ws(P = Dv(M, t, n, d, c, r, i, $, k = [], B = [], f), o), S === 123)
              if (c === 0)
                cl(M, t, P, P, k, o, f, i, B);
              else
                switch (p === 99 && Ft(M, 3) === 110 ? 100 : p) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    cl(e, P, P, a && Ws(Dv(e, P, P, 0, 0, r, i, $, r, k = [], f), B), r, B, f, i, a ? k : B);
                    break;
                  default:
                    cl(M, P, P, P, [""], B, 0, i, B);
                }
        }
        d = c = v = 0, y = C = 1, $ = M = "", f = s;
        break;
      // :
      case 58:
        f = 1 + zn(M), v = m;
      default:
        if (y < 1) {
          if (S == 123)
            --y;
          else if (S == 125 && y++ == 0 && RV() == 125)
            continue;
        }
        switch (M += Ki(S), S * y) {
          // &
          case 38:
            C = c > 0 ? 1 : (M += "\f", -1);
            break;
          // ,
          case 44:
            i[d++] = (zn(M) - 1) * C, C = 1;
            break;
          // @
          case 64:
            Wn() === 45 && (M += dl(fn())), p = Wn(), c = f = zn($ = M += LV(ul())), S++;
            break;
          // -
          case 45:
            m === 45 && zn(M) == 2 && (y = 0);
        }
    }
  return o;
}
function Dv(e, t, n, a, r, o, s, i, u, d, c) {
  for (var f = r - 1, p = r === 0 ? o : [""], v = kf(p), m = 0, y = 0, x = 0; m < a; ++m)
    for (var C = 0, S = Wo(e, f + 1, f = qV(y = s[m])), $ = e; C < v; ++C)
      ($ = mb(y > 0 ? p[C] + " " + S : tt(S, /&\f/g, p[C]))) && (u[x++] = $);
  return Xi(e, t, n, r === 0 ? $f : i, u, d, c);
}
function HV(e, t, n) {
  return Xi(e, t, n, pb, Ki(OV()), Wo(e, 2, -2), 0);
}
function qv(e, t, n, a) {
  return Xi(e, t, n, Bf, Wo(e, 0, a), Wo(e, a + 1, -1), a);
}
function Dr(e, t) {
  for (var n = "", a = kf(e), r = 0; r < a; r++)
    n += t(e[r], r, e, t) || "";
  return n;
}
function UV(e, t, n, a) {
  switch (e.type) {
    case DV:
      if (e.children.length) break;
    case MV:
    case Bf:
      return e.return = e.return || e.value;
    case pb:
      return "";
    case vb:
      return e.return = e.value + "{" + Dr(e.children, a) + "}";
    case $f:
      e.value = e.props.join(",");
  }
  return zn(n = Dr(e.children, a)) ? e.return = e.value + "{" + n + "}" : "";
}
function jV(e) {
  var t = kf(e);
  return function(n, a, r, o) {
    for (var s = "", i = 0; i < t; i++)
      s += e[i](n, a, r, o) || "";
    return s;
  };
}
function WV(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function GV(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var KV = function(t, n, a) {
  for (var r = 0, o = 0; r = o, o = Wn(), r === 38 && o === 12 && (n[a] = 1), !Go(o); )
    fn();
  return $s(t, nn);
}, YV = function(t, n) {
  var a = -1, r = 44;
  do
    switch (Go(r)) {
      case 0:
        r === 38 && Wn() === 12 && (n[a] = 1), t[a] += KV(nn - 1, n, a);
        break;
      case 2:
        t[a] += dl(r);
        break;
      case 4:
        if (r === 44) {
          t[++a] = Wn() === 58 ? "&\f" : "", n[a] = t[a].length;
          break;
        }
      // fallthrough
      default:
        t[a] += Ki(r);
    }
  while (r = fn());
  return t;
}, XV = function(t, n) {
  return yb(YV(gb(t), n));
}, Av = /* @__PURE__ */ new WeakMap(), JV = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, a = t.parent, r = t.column === a.column && t.line === a.line; a.type !== "rule"; )
      if (a = a.parent, !a) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Av.get(a)) && !r) {
      Av.set(t, !0);
      for (var o = [], s = XV(n, o), i = a.props, u = 0, d = 0; u < s.length; u++)
        for (var c = 0; c < i.length; c++, d++)
          t.props[d] = o[u] ? s[u].replace(/&\f/g, i[c]) : i[c] + " " + s[u];
    }
  }
}, ZV = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function bb(e, t) {
  switch (EV(e, t)) {
    // color-adjust
    case 5103:
      return Qe + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Qe + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Qe + e + jl + e + Ht + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return Qe + e + Ht + e + e;
    // order
    case 6165:
      return Qe + e + Ht + "flex-" + e + e;
    // align-items
    case 5187:
      return Qe + e + tt(e, /(\w+).+(:[^]+)/, Qe + "box-$1$2" + Ht + "flex-$1$2") + e;
    // align-self
    case 5443:
      return Qe + e + Ht + "flex-item-" + tt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return Qe + e + Ht + "flex-line-pack" + tt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return Qe + e + Ht + tt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return Qe + e + Ht + tt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return Qe + "box-" + tt(e, "-grow", "") + Qe + e + Ht + tt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return Qe + tt(e, /([^-])(transform)/g, "$1" + Qe + "$2") + e;
    // cursor
    case 6187:
      return tt(tt(tt(e, /(zoom-|grab)/, Qe + "$1"), /(image-set)/, Qe + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return tt(e, /(image-set\([^]*)/, Qe + "$1$`$1");
    // justify-content
    case 4968:
      return tt(tt(e, /(.+:)(flex-)?(.*)/, Qe + "box-pack:$3" + Ht + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Qe + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return tt(e, /(.+)-inline(.+)/, Qe + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (zn(e) - 1 - t > 6) switch (Ft(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (Ft(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return tt(e, /(.+:)(.+)-([^]+)/, "$1" + Qe + "$2-$3$1" + jl + (Ft(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~qd(e, "stretch") ? bb(tt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (Ft(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (Ft(e, zn(e) - 3 - (~qd(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return tt(e, ":", ":" + Qe) + e;
        // (inline-)?fl(e)x
        case 101:
          return tt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Qe + (Ft(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Qe + "$2$3$1" + Ht + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (Ft(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return Qe + e + Ht + tt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return Qe + e + Ht + tt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return Qe + e + Ht + tt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return Qe + e + Ht + e + e;
  }
  return e;
}
var QV = function(t, n, a, r) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Bf:
      t.return = bb(t.value, t.length);
      break;
    case vb:
      return Dr([po(t, {
        value: tt(t.value, "@", "@" + Qe)
      })], r);
    case $f:
      if (t.length) return IV(t.props, function(o) {
        switch (TV(o, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Dr([po(t, {
              props: [tt(o, /:(read-\w+)/, ":" + jl + "$1")]
            })], r);
          // :placeholder
          case "::placeholder":
            return Dr([po(t, {
              props: [tt(o, /:(plac\w+)/, ":" + Qe + "input-$1")]
            }), po(t, {
              props: [tt(o, /:(plac\w+)/, ":" + jl + "$1")]
            }), po(t, {
              props: [tt(o, /:(plac\w+)/, Ht + "input-$1")]
            })], r);
        }
        return "";
      });
  }
}, eF = [QV], tF = function(t) {
  var n = t.key;
  if (n === "css") {
    var a = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(a, function(y) {
      var x = y.getAttribute("data-emotion");
      x.indexOf(" ") !== -1 && (document.head.appendChild(y), y.setAttribute("data-s", ""));
    });
  }
  var r = t.stylisPlugins || eF, o = {}, s, i = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(y) {
      for (var x = y.getAttribute("data-emotion").split(" "), C = 1; C < x.length; C++)
        o[x[C]] = !0;
      i.push(y);
    }
  );
  var u, d = [JV, ZV];
  {
    var c, f = [UV, WV(function(y) {
      c.insert(y);
    })], p = jV(d.concat(r, f)), v = function(x) {
      return Dr(zV(x), p);
    };
    u = function(x, C, S, $) {
      c = S, v(x ? x + "{" + C.styles + "}" : C.styles), $ && (m.inserted[C.name] = !0);
    };
  }
  var m = {
    key: n,
    sheet: new PV({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return m.sheet.hydrate(i), m;
};
function nF(e) {
  for (var t = 0, n, a = 0, r = e.length; r >= 4; ++a, r -= 4)
    n = e.charCodeAt(a) & 255 | (e.charCodeAt(++a) & 255) << 8 | (e.charCodeAt(++a) & 255) << 16 | (e.charCodeAt(++a) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (r) {
    case 3:
      t ^= (e.charCodeAt(a + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(a + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(a) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var aF = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, rF = /[A-Z]|^ms/g, oF = /_EMO_([^_]+?)_([^]*?)_EMO_/g, _b = function(t) {
  return t.charCodeAt(1) === 45;
}, Ev = function(t) {
  return t != null && typeof t != "boolean";
}, Iu = /* @__PURE__ */ GV(function(e) {
  return _b(e) ? e : e.replace(rF, "-$&").toLowerCase();
}), Tv = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(oF, function(a, r, o) {
          return Pa = {
            name: r,
            styles: o,
            next: Pa
          }, r;
        });
  }
  return aF[t] !== 1 && !_b(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Wl(e, t, n) {
  if (n == null)
    return "";
  var a = n;
  if (a.__emotion_styles !== void 0)
    return a;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var r = n;
      if (r.anim === 1)
        return Pa = {
          name: r.name,
          styles: r.styles,
          next: Pa
        }, r.name;
      var o = n;
      if (o.styles !== void 0) {
        var s = o.next;
        if (s !== void 0)
          for (; s !== void 0; )
            Pa = {
              name: s.name,
              styles: s.styles,
              next: Pa
            }, s = s.next;
        var i = o.styles + ";";
        return i;
      }
      return sF(e, t, n);
    }
  }
  var u = n;
  if (t == null)
    return u;
  var d = t[u];
  return d !== void 0 ? d : u;
}
function sF(e, t, n) {
  var a = "";
  if (Array.isArray(n))
    for (var r = 0; r < n.length; r++)
      a += Wl(e, t, n[r]) + ";";
  else
    for (var o in n) {
      var s = n[o];
      if (typeof s != "object") {
        var i = s;
        t != null && t[i] !== void 0 ? a += o + "{" + t[i] + "}" : Ev(i) && (a += Iu(o) + ":" + Tv(o, i) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var u = 0; u < s.length; u++)
          Ev(s[u]) && (a += Iu(o) + ":" + Tv(o, s[u]) + ";");
      else {
        var d = Wl(e, t, s);
        switch (o) {
          case "animation":
          case "animationName": {
            a += Iu(o) + ":" + d + ";";
            break;
          }
          default:
            a += o + "{" + d + "}";
        }
      }
    }
  return a;
}
var Iv = /label:\s*([^\s;{]+)\s*(;|$)/g, Pa;
function Ou(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var a = !0, r = "";
  Pa = void 0;
  var o = e[0];
  if (o == null || o.raw === void 0)
    a = !1, r += Wl(n, t, o);
  else {
    var s = o;
    r += s[0];
  }
  for (var i = 1; i < e.length; i++)
    if (r += Wl(n, t, e[i]), a) {
      var u = o;
      r += u[i];
    }
  Iv.lastIndex = 0;
  for (var d = "", c; (c = Iv.exec(r)) !== null; )
    d += "-" + c[1];
  var f = nF(r) + d;
  return {
    name: f,
    styles: r,
    next: Pa
  };
}
function wb(e, t, n) {
  var a = "";
  return n.split(" ").forEach(function(r) {
    e[r] !== void 0 ? t.push(e[r] + ";") : r && (a += r + " ");
  }), a;
}
var lF = function(t, n, a) {
  var r = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[r] === void 0 && (t.registered[r] = n.styles);
}, iF = function(t, n, a) {
  lF(t, n);
  var r = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var o = n;
    do
      t.insert(n === o ? "." + r : "", o, t.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function Ov(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function Rv(e, t, n) {
  var a = [], r = wb(e, a, n);
  return a.length < 2 ? n : r + t(a);
}
var uF = function(t) {
  var n = tF(t);
  n.sheet.speedy = function(i) {
    this.isSpeedy = i;
  }, n.compat = !0;
  var a = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Ou(d, n.registered, void 0);
    return iF(n, f), n.key + "-" + f.name;
  }, r = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Ou(d, n.registered), p = "animation-" + f.name;
    return Ov(n, {
      name: f.name,
      styles: "@keyframes " + p + "{" + f.styles + "}"
    }), p;
  }, o = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    var f = Ou(d, n.registered);
    Ov(n, f);
  }, s = function() {
    for (var u = arguments.length, d = new Array(u), c = 0; c < u; c++)
      d[c] = arguments[c];
    return Rv(n.registered, a, dF(d));
  };
  return {
    css: a,
    cx: s,
    injectGlobal: o,
    keyframes: r,
    hydrate: function(u) {
      u.forEach(function(d) {
        n.inserted[d] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: wb.bind(null, n.registered),
    merge: Rv.bind(null, n.registered, a)
  };
}, dF = function e(t) {
  for (var n = "", a = 0; a < t.length; a++) {
    var r = t[a];
    if (r != null) {
      var o = void 0;
      switch (typeof r) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(r))
            o = e(r);
          else {
            o = "";
            for (var s in r)
              r[s] && s && (o && (o += " "), o += s);
          }
          break;
        }
        default:
          o = r;
      }
      o && (n && (n += " "), n += o);
    }
  }
  return n;
}, xb = uF({
  key: "css"
}), Pf = xb.injectGlobal, rn = xb.css;
function Ed(e) {
  var t;
  e = String(e);
  const n = parseFloat(e), a = ((t = e.match(/[\d.\-+]*\s*(.*)/)) === null || t === void 0 ? void 0 : t[1]) || "";
  return [n, a];
}
function Cb() {
  return typeof window < "u" && typeof document < "u";
}
function Td(e, t) {
  var n;
  const a = Ed(getComputedStyle(e).getPropertyValue(t));
  return a[0] * ((n = Bs(a[1], e)) !== null && n !== void 0 ? n : 1);
}
function Sb(e, t) {
  const n = document.createElement("div");
  n.style.height = `128${e}`, t.appendChild(n);
  const a = Td(n, "height") / 128;
  return t.removeChild(n), a;
}
let Ru = null;
function vo() {
  return Cb() ? (Ru === null && (Ru = Sb("in", document.body)), Ru) : 96;
}
function Bs(e, t) {
  var n;
  if (!e && e !== 0)
    return null;
  if (!Cb()) {
    const s = Ed(String(e));
    if (!isNaN(s[0])) {
      const i = ((n = s[1]) === null || n === void 0 ? void 0 : n.toLowerCase()) || "px";
      if (i === "px" || i === "")
        return s[0];
      if (i === "em" || i === "rem")
        return s[0] * 16;
      if (i === "in")
        return s[0] * 96;
      if (i === "cm")
        return s[0] * (96 / 2.54);
      if (i === "mm")
        return s[0] * (96 / 25.4);
      if (i === "pt")
        return s[0] * (96 / 72);
      if (i === "pc")
        return s[0] * (96 / 6);
    }
    return null;
  }
  let a = document.body;
  t && t !== window && t !== document && (a = t);
  const r = (String(e) || "px").trim().toLowerCase();
  switch (r) {
    case "%":
      return a.clientHeight / 100;
    case "ch":
    case "ex":
      return Sb(r, a);
    case "em":
      return Td(a, "font-size");
    case "rem":
      return Td(document.body, "font-size");
    case "vw":
      return window.innerWidth / 100;
    case "vh":
      return window.innerHeight / 100;
    case "vmin":
      return Math.min(window.innerWidth, window.innerHeight) / 100;
    case "vmax":
      return Math.max(window.innerWidth, window.innerHeight) / 100;
    case "in":
      return vo();
    case "cm":
      return vo() / 2.54;
    case "mm":
      return vo() / 25.4;
    case "pt":
      return vo() / 72;
    case "pc":
      return vo() / 6;
    case "px":
      return 1;
  }
  const o = Ed(r);
  if (!isNaN(o[0])) {
    if (o[1]) {
      const s = Bs(o[1], a);
      return typeof s == "number" ? o[0] * s : null;
    }
    return o[0];
  }
  return null;
}
function cF() {
  const e = () => Math.floor((1 + crypto.getRandomValues(new Uint32Array(1))[0]) * 65536).toString(16).substring(1);
  return `${e() + e()}-${e()}-${e()}-${e()}-${e()}${e()}${e()}`;
}
const Vv = /* @__PURE__ */ new WeakMap();
function fF(e, t) {
  const n = e.substr(4, e.length - 5);
  let a = Vv.get(t);
  if (a || (a = /* @__PURE__ */ new Map(), Vv.set(t, a)), a.has(n))
    return a.get(n);
  const r = getComputedStyle(t).getPropertyValue(n);
  return a.set(n, r), r;
}
function $b(e, t) {
  const n = fF(e, t);
  return Bs(n);
}
function Mf(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Bb(e, t) {
  var n = Object.create(e.prototype);
  for (var a in t) n[a] = t[a];
  return n;
}
function ks() {
}
var Ko = 0.7, Gl = 1 / Ko, qr = "\\s*([+-]?\\d+)\\s*", Yo = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Gn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", pF = /^#([0-9a-f]{3,8})$/, vF = new RegExp(`^rgb\\(${qr},${qr},${qr}\\)$`), mF = new RegExp(`^rgb\\(${Gn},${Gn},${Gn}\\)$`), hF = new RegExp(`^rgba\\(${qr},${qr},${qr},${Yo}\\)$`), gF = new RegExp(`^rgba\\(${Gn},${Gn},${Gn},${Yo}\\)$`), yF = new RegExp(`^hsl\\(${Yo},${Gn},${Gn}\\)$`), bF = new RegExp(`^hsla\\(${Yo},${Gn},${Gn},${Yo}\\)$`), Fv = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Mf(ks, tr, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Nv,
  // Deprecated! Use color.formatHex.
  formatHex: Nv,
  formatHex8: _F,
  formatHsl: wF,
  formatRgb: Lv,
  toString: Lv
});
function Nv() {
  return this.rgb().formatHex();
}
function _F() {
  return this.rgb().formatHex8();
}
function wF() {
  return kb(this).formatHsl();
}
function Lv() {
  return this.rgb().formatRgb();
}
function tr(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = pF.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? zv(t) : n === 3 ? new Qt(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Gs(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Gs(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = vF.exec(e)) ? new Qt(t[1], t[2], t[3], 1) : (t = mF.exec(e)) ? new Qt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = hF.exec(e)) ? Gs(t[1], t[2], t[3], t[4]) : (t = gF.exec(e)) ? Gs(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = yF.exec(e)) ? jv(t[1], t[2] / 100, t[3] / 100, 1) : (t = bF.exec(e)) ? jv(t[1], t[2] / 100, t[3] / 100, t[4]) : Fv.hasOwnProperty(e) ? zv(Fv[e]) : e === "transparent" ? new Qt(NaN, NaN, NaN, 0) : null;
}
function zv(e) {
  return new Qt(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Gs(e, t, n, a) {
  return a <= 0 && (e = t = n = NaN), new Qt(e, t, n, a);
}
function xF(e) {
  return e instanceof ks || (e = tr(e)), e ? (e = e.rgb(), new Qt(e.r, e.g, e.b, e.opacity)) : new Qt();
}
function Id(e, t, n, a) {
  return arguments.length === 1 ? xF(e) : new Qt(e, t, n, a ?? 1);
}
function Qt(e, t, n, a) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +a;
}
Mf(Qt, Id, Bb(ks, {
  brighter(e) {
    return e = e == null ? Gl : Math.pow(Gl, e), new Qt(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ko : Math.pow(Ko, e), new Qt(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Qt(Ja(this.r), Ja(this.g), Ja(this.b), Kl(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Hv,
  // Deprecated! Use color.formatHex.
  formatHex: Hv,
  formatHex8: CF,
  formatRgb: Uv,
  toString: Uv
}));
function Hv() {
  return `#${Ga(this.r)}${Ga(this.g)}${Ga(this.b)}`;
}
function CF() {
  return `#${Ga(this.r)}${Ga(this.g)}${Ga(this.b)}${Ga((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Uv() {
  const e = Kl(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Ja(this.r)}, ${Ja(this.g)}, ${Ja(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Kl(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Ja(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ga(e) {
  return e = Ja(e), (e < 16 ? "0" : "") + e.toString(16);
}
function jv(e, t, n, a) {
  return a <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Bn(e, t, n, a);
}
function kb(e) {
  if (e instanceof Bn) return new Bn(e.h, e.s, e.l, e.opacity);
  if (e instanceof ks || (e = tr(e)), !e) return new Bn();
  if (e instanceof Bn) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, a = e.b / 255, r = Math.min(t, n, a), o = Math.max(t, n, a), s = NaN, i = o - r, u = (o + r) / 2;
  return i ? (t === o ? s = (n - a) / i + (n < a) * 6 : n === o ? s = (a - t) / i + 2 : s = (t - n) / i + 4, i /= u < 0.5 ? o + r : 2 - o - r, s *= 60) : i = u > 0 && u < 1 ? 0 : s, new Bn(s, i, u, e.opacity);
}
function SF(e, t, n, a) {
  return arguments.length === 1 ? kb(e) : new Bn(e, t, n, a ?? 1);
}
function Bn(e, t, n, a) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +a;
}
Mf(Bn, SF, Bb(ks, {
  brighter(e) {
    return e = e == null ? Gl : Math.pow(Gl, e), new Bn(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ko : Math.pow(Ko, e), new Bn(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, a = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - a;
    return new Qt(
      Vu(e >= 240 ? e - 240 : e + 120, r, a),
      Vu(e, r, a),
      Vu(e < 120 ? e + 240 : e - 120, r, a),
      this.opacity
    );
  },
  clamp() {
    return new Bn(Wv(this.h), Ks(this.s), Ks(this.l), Kl(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Kl(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Wv(this.h)}, ${Ks(this.s) * 100}%, ${Ks(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Wv(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Ks(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Vu(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const $F = globalThis?.UNOVIS_COLORS || ["#4D8CFD", "#FF6B7E", "#F4B83E", "#A6CC74", "#00C19A", "#6859BE"], Pb = (e) => `--vis-${To(e) ? `color${e % $F.length}` : e}`, Xo = 10, BF = [
  { id: "stripes-diagonal", svg: '<path d="M-1,1 l2,-2 M0,10 l10,-10 M9,11 l2,-2" stroke="#000"/>' },
  { id: "dots", svg: '<path d="m0-1.5a1 1 0 010 3m10-3a1 1 0 000 3M5 3.5a1 1 0 010 3 1 1 0 010-3M0 8.5 a1 1 0 010 3m10-3a1 1 0 000 3" fill"#000"/>' },
  { id: "stripes-vertical", svg: '<path d="M 5,-1 L5,11" stroke="#000"/>' },
  { id: "crosshatch", svg: '<path d="M0 0L10 10ZM10 0L0 10Z" stroke="#000"/>' },
  { id: "waves", svg: '<path d="M0 4Q2.5 1 5 4 7.5 7 10 4v2Q7.5 9 5 6 2.5 3 0 6Z" fill="#000"/>' },
  { id: "circles", svg: '<circle cx="5" cy="5" r="3" stroke="#000" fill="#fff"/>' }
], kF = [
  { id: "circle", marker: '<circle cx="5" cy="5" r="5"/>', dashArray: [] },
  { id: "triangle", marker: '<path d="M5,0 L10,9 L0,9Z">', dashArray: [9, 1] },
  { id: "diamond", marker: '<path d="M 0 5 L5 0 L 10 5 L 5 10 L 0 5Z">', dashArray: [2] },
  { id: "arrow", marker: '<path d="M4 0 0 0 6 5 0 10 4 10 10 5Z">', dashArray: [2, 3, 8, 3] },
  { id: "square", marker: '<rect x="1" y="1" width="8" height="8"/>', dashArray: [6] },
  { id: "star", marker: '<path d="m2 9 3-9 3 9L0 3h10Z"/>', dashArray: [1, 6] }
];
function Mb(e) {
  return `vis-${`pattern-${e.svg ? "fill" : "marker"}`}-${e.id}`;
}
const PF = (e) => `<mask id="${Mb(e)}">
    <pattern id="${e.id}" viewBox="0 0 10 10" width="${Xo}" height="${Xo}" patternUnits="userSpaceOnUse">
      <rect width="100%" height="100%" fill="#fff"/>
      ${e.svg}
    </pattern>
    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#${e.id})"/>
  </mask>`, MF = (e, t) => `<marker id="${Mb(e)}"
    fill="var(${Pb(t)})"
    markerUnits="userSpaceOnUse"
    refX="5"
    refY="5"
    markerWidth="${Xo}"
    markerHeight="${Xo}">
    ${e.marker}
  </marker>`;
function DF() {
  const e = BF.map(PF).concat(kF.map(MF)).join(""), t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.style.position = "fixed", t.style.zIndex = "-99999999", t.innerHTML = `<defs>${e}</defs>`, document.body.appendChild(t);
}
typeof window < "u" && DF();
var qF = { value: () => {
} };
function Db() {
  for (var e = 0, t = arguments.length, n = {}, a; e < t; ++e) {
    if (!(a = arguments[e] + "") || a in n || /[\s.]/.test(a)) throw new Error("illegal type: " + a);
    n[a] = [];
  }
  return new fl(n);
}
function fl(e) {
  this._ = e;
}
function AF(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var a = "", r = n.indexOf(".");
    if (r >= 0 && (a = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: a };
  });
}
fl.prototype = Db.prototype = {
  constructor: fl,
  on: function(e, t) {
    var n = this._, a = AF(e + "", n), r, o = -1, s = a.length;
    if (arguments.length < 2) {
      for (; ++o < s; ) if ((r = (e = a[o]).type) && (r = EF(n[r], e.name))) return r;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++o < s; )
      if (r = (e = a[o]).type) n[r] = Gv(n[r], e.name, t);
      else if (t == null) for (r in n) n[r] = Gv(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new fl(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0) for (var n = new Array(r), a = 0, r, o; a < r; ++a) n[a] = arguments[a + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (o = this._[e], a = 0, r = o.length; a < r; ++a) o[a].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
  }
};
function EF(e, t) {
  for (var n = 0, a = e.length, r; n < a; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function Gv(e, t, n) {
  for (var a = 0, r = e.length; a < r; ++a)
    if (e[a].name === t) {
      e[a] = qF, e = e.slice(0, a).concat(e.slice(a + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Nr = 0, So = 0, mo = 0, qb = 1e3, Yl, $o, Xl = 0, nr = 0, Ji = 0, Jo = typeof performance == "object" && performance.now ? performance : Date, Ab = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Df() {
  return nr || (Ab(TF), nr = Jo.now() + Ji);
}
function TF() {
  nr = 0;
}
function Jl() {
  this._call = this._time = this._next = null;
}
Jl.prototype = Eb.prototype = {
  constructor: Jl,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Df() : +n) + (t == null ? 0 : +t), !this._next && $o !== this && ($o ? $o._next = this : Yl = this, $o = this), this._call = e, this._time = n, Od();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Od());
  }
};
function Eb(e, t, n) {
  var a = new Jl();
  return a.restart(e, t, n), a;
}
function IF() {
  Df(), ++Nr;
  for (var e = Yl, t; e; )
    (t = nr - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Nr;
}
function Kv() {
  nr = (Xl = Jo.now()) + Ji, Nr = So = 0;
  try {
    IF();
  } finally {
    Nr = 0, RF(), nr = 0;
  }
}
function OF() {
  var e = Jo.now(), t = e - Xl;
  t > qb && (Ji -= t, Xl = e);
}
function RF() {
  for (var e, t = Yl, n, a = 1 / 0; t; )
    t._call ? (a > t._time && (a = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Yl = n);
  $o = e, Od(a);
}
function Od(e) {
  if (!Nr) {
    So && (So = clearTimeout(So));
    var t = e - nr;
    t > 24 ? (e < 1 / 0 && (So = setTimeout(Kv, e - Jo.now() - Ji)), mo && (mo = clearInterval(mo))) : (mo || (Xl = Jo.now(), mo = setInterval(OF, qb)), Nr = 1, Ab(Kv));
  }
}
function Yv(e, t, n) {
  var a = new Jl();
  return t = t == null ? 0 : +t, a.restart((r) => {
    a.stop(), e(r + t);
  }, t, n), a;
}
var VF = Db("start", "end", "cancel", "interrupt"), FF = [], Tb = 0, Xv = 1, Rd = 2, pl = 3, Jv = 4, Vd = 5, vl = 6;
function Zi(e, t, n, a, r, o) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  NF(e, n, {
    name: t,
    index: a,
    // For context during callback.
    group: r,
    // For context during callback.
    on: VF,
    tween: FF,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: Tb
  });
}
function qf(e, t) {
  var n = Rn(e, t);
  if (n.state > Tb) throw new Error("too late; already scheduled");
  return n;
}
function Zn(e, t) {
  var n = Rn(e, t);
  if (n.state > pl) throw new Error("too late; already running");
  return n;
}
function Rn(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function NF(e, t, n) {
  var a = e.__transition, r;
  a[t] = n, n.timer = Eb(o, 0, n.time);
  function o(d) {
    n.state = Xv, n.timer.restart(s, n.delay, n.time), n.delay <= d && s(d - n.delay);
  }
  function s(d) {
    var c, f, p, v;
    if (n.state !== Xv) return u();
    for (c in a)
      if (v = a[c], v.name === n.name) {
        if (v.state === pl) return Yv(s);
        v.state === Jv ? (v.state = vl, v.timer.stop(), v.on.call("interrupt", e, e.__data__, v.index, v.group), delete a[c]) : +c < t && (v.state = vl, v.timer.stop(), v.on.call("cancel", e, e.__data__, v.index, v.group), delete a[c]);
      }
    if (Yv(function() {
      n.state === pl && (n.state = Jv, n.timer.restart(i, n.delay, n.time), i(d));
    }), n.state = Rd, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Rd) {
      for (n.state = pl, r = new Array(p = n.tween.length), c = 0, f = -1; c < p; ++c)
        (v = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (r[++f] = v);
      r.length = f + 1;
    }
  }
  function i(d) {
    for (var c = d < n.duration ? n.ease.call(null, d / n.duration) : (n.timer.restart(u), n.state = Vd, 1), f = -1, p = r.length; ++f < p; )
      r[f].call(e, c);
    n.state === Vd && (n.on.call("end", e, e.__data__, n.index, n.group), u());
  }
  function u() {
    n.state = vl, n.timer.stop(), delete a[t];
    for (var d in a) return;
    delete e.__transition;
  }
}
function Ib(e, t) {
  var n = e.__transition, a, r, o = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((a = n[s]).name !== t) {
        o = !1;
        continue;
      }
      r = a.state > Rd && a.state < Vd, a.state = vl, a.timer.stop(), a.on.call(r ? "interrupt" : "cancel", e, e.__data__, a.index, a.group), delete n[s];
    }
    o && delete e.__transition;
  }
}
function LF(e) {
  return this.each(function() {
    Ib(this, e);
  });
}
const Af = (e) => () => e;
function zF(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function HF(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(a) {
    return Math.pow(e + a * t, n);
  };
}
function UF(e) {
  return (e = +e) == 1 ? Ob : function(t, n) {
    return n - t ? HF(t, n, e) : Af(isNaN(t) ? n : t);
  };
}
function Ob(e, t) {
  var n = t - e;
  return n ? zF(e, n) : Af(isNaN(e) ? t : e);
}
const Zl = (function e(t) {
  var n = UF(t);
  function a(r, o) {
    var s = n((r = Id(r)).r, (o = Id(o)).r), i = n(r.g, o.g), u = n(r.b, o.b), d = Ob(r.opacity, o.opacity);
    return function(c) {
      return r.r = s(c), r.g = i(c), r.b = u(c), r.opacity = d(c), r + "";
    };
  }
  return a.gamma = e, a;
})(1);
function jF(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, a = t.slice(), r;
  return function(o) {
    for (r = 0; r < n; ++r) a[r] = e[r] * (1 - o) + t[r] * o;
    return a;
  };
}
function WF(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function GF(e, t) {
  var n = t ? t.length : 0, a = e ? Math.min(n, e.length) : 0, r = new Array(a), o = new Array(n), s;
  for (s = 0; s < a; ++s) r[s] = ro(e[s], t[s]);
  for (; s < n; ++s) o[s] = t[s];
  return function(i) {
    for (s = 0; s < a; ++s) o[s] = r[s](i);
    return o;
  };
}
function KF(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(a) {
    return n.setTime(e * (1 - a) + t * a), n;
  };
}
function Sn(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function YF(e, t) {
  var n = {}, a = {}, r;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (r in t)
    r in e ? n[r] = ro(e[r], t[r]) : a[r] = t[r];
  return function(o) {
    for (r in n) a[r] = n[r](o);
    return a;
  };
}
var Fd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Fu = new RegExp(Fd.source, "g");
function XF(e) {
  return function() {
    return e;
  };
}
function JF(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Rb(e, t) {
  var n = Fd.lastIndex = Fu.lastIndex = 0, a, r, o, s = -1, i = [], u = [];
  for (e = e + "", t = t + ""; (a = Fd.exec(e)) && (r = Fu.exec(t)); )
    (o = r.index) > n && (o = t.slice(n, o), i[s] ? i[s] += o : i[++s] = o), (a = a[0]) === (r = r[0]) ? i[s] ? i[s] += r : i[++s] = r : (i[++s] = null, u.push({ i: s, x: Sn(a, r) })), n = Fu.lastIndex;
  return n < t.length && (o = t.slice(n), i[s] ? i[s] += o : i[++s] = o), i.length < 2 ? u[0] ? JF(u[0].x) : XF(t) : (t = u.length, function(d) {
    for (var c = 0, f; c < t; ++c) i[(f = u[c]).i] = f.x(d);
    return i.join("");
  });
}
function ro(e, t) {
  var n = typeof t, a;
  return t == null || n === "boolean" ? Af(t) : (n === "number" ? Sn : n === "string" ? (a = tr(t)) ? (t = a, Zl) : Rb : t instanceof tr ? Zl : t instanceof Date ? KF : WF(t) ? jF : Array.isArray(t) ? GF : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? YF : Sn)(e, t);
}
function Ef(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var Zv = 180 / Math.PI, Nd = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Vb(e, t, n, a, r, o) {
  var s, i, u;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (u = e * n + t * a) && (n -= e * u, a -= t * u), (i = Math.sqrt(n * n + a * a)) && (n /= i, a /= i, u /= i), e * a < t * n && (e = -e, t = -t, u = -u, s = -s), {
    translateX: r,
    translateY: o,
    rotate: Math.atan2(t, e) * Zv,
    skewX: Math.atan(u) * Zv,
    scaleX: s,
    scaleY: i
  };
}
var Ys;
function ZF(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Nd : Vb(t.a, t.b, t.c, t.d, t.e, t.f);
}
function QF(e) {
  return e == null || (Ys || (Ys = document.createElementNS("http://www.w3.org/2000/svg", "g")), Ys.setAttribute("transform", e), !(e = Ys.transform.baseVal.consolidate())) ? Nd : (e = e.matrix, Vb(e.a, e.b, e.c, e.d, e.e, e.f));
}
function Fb(e, t, n, a) {
  function r(d) {
    return d.length ? d.pop() + " " : "";
  }
  function o(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var y = v.push("translate(", null, t, null, n);
      m.push({ i: y - 4, x: Sn(d, f) }, { i: y - 2, x: Sn(c, p) });
    } else (f || p) && v.push("translate(" + f + t + p + n);
  }
  function s(d, c, f, p) {
    d !== c ? (d - c > 180 ? c += 360 : c - d > 180 && (d += 360), p.push({ i: f.push(r(f) + "rotate(", null, a) - 2, x: Sn(d, c) })) : c && f.push(r(f) + "rotate(" + c + a);
  }
  function i(d, c, f, p) {
    d !== c ? p.push({ i: f.push(r(f) + "skewX(", null, a) - 2, x: Sn(d, c) }) : c && f.push(r(f) + "skewX(" + c + a);
  }
  function u(d, c, f, p, v, m) {
    if (d !== f || c !== p) {
      var y = v.push(r(v) + "scale(", null, ",", null, ")");
      m.push({ i: y - 4, x: Sn(d, f) }, { i: y - 2, x: Sn(c, p) });
    } else (f !== 1 || p !== 1) && v.push(r(v) + "scale(" + f + "," + p + ")");
  }
  return function(d, c) {
    var f = [], p = [];
    return d = e(d), c = e(c), o(d.translateX, d.translateY, c.translateX, c.translateY, f, p), s(d.rotate, c.rotate, f, p), i(d.skewX, c.skewX, f, p), u(d.scaleX, d.scaleY, c.scaleX, c.scaleY, f, p), d = c = null, function(v) {
      for (var m = -1, y = p.length, x; ++m < y; ) f[(x = p[m]).i] = x.x(v);
      return f.join("");
    };
  };
}
var eN = Fb(ZF, "px, ", "px)", "deg)"), tN = Fb(QF, ", ", ")", ")");
function nN(e, t) {
  t === void 0 && (t = e, e = ro);
  for (var n = 0, a = t.length - 1, r = t[0], o = new Array(a < 0 ? 0 : a); n < a; ) o[n] = e(r, r = t[++n]);
  return function(s) {
    var i = Math.max(0, Math.min(a - 1, Math.floor(s *= a)));
    return o[i](s - i);
  };
}
function aN(e, t) {
  var n, a;
  return function() {
    var r = Zn(this, e), o = r.tween;
    if (o !== n) {
      a = n = o;
      for (var s = 0, i = a.length; s < i; ++s)
        if (a[s].name === t) {
          a = a.slice(), a.splice(s, 1);
          break;
        }
    }
    r.tween = a;
  };
}
function rN(e, t, n) {
  var a, r;
  if (typeof n != "function") throw new Error();
  return function() {
    var o = Zn(this, e), s = o.tween;
    if (s !== a) {
      r = (a = s).slice();
      for (var i = { name: t, value: n }, u = 0, d = r.length; u < d; ++u)
        if (r[u].name === t) {
          r[u] = i;
          break;
        }
      u === d && r.push(i);
    }
    o.tween = r;
  };
}
function oN(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var a = Rn(this.node(), n).tween, r = 0, o = a.length, s; r < o; ++r)
      if ((s = a[r]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? aN : rN)(n, e, t));
}
function Tf(e, t, n) {
  var a = e._id;
  return e.each(function() {
    var r = Zn(this, a);
    (r.value || (r.value = {}))[t] = n.apply(this, arguments);
  }), function(r) {
    return Rn(r, a).value[t];
  };
}
function Nb(e, t) {
  var n;
  return (typeof t == "number" ? Sn : t instanceof tr ? Zl : (n = tr(t)) ? (t = n, Zl) : Rb)(e, t);
}
function sN(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function lN(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function iN(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttribute(e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function uN(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function dN(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function cN(e, t, n) {
  var a, r, o;
  return function() {
    var s, i = n(this), u;
    return i == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), u = i + "", s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i)));
  };
}
function fN(e, t) {
  var n = Wi(e), a = n === "transform" ? tN : Nb;
  return this.attrTween(e, typeof t == "function" ? (n.local ? cN : dN)(n, a, Tf(this, "attr." + e, t)) : t == null ? (n.local ? lN : sN)(n) : (n.local ? uN : iN)(n, a, t));
}
function pN(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function vN(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function mN(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && vN(e, o)), n;
  }
  return r._value = t, r;
}
function hN(e, t) {
  var n, a;
  function r() {
    var o = t.apply(this, arguments);
    return o !== a && (n = (a = o) && pN(e, o)), n;
  }
  return r._value = t, r;
}
function gN(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var a = Wi(e);
  return this.tween(n, (a.local ? mN : hN)(a, t));
}
function yN(e, t) {
  return function() {
    qf(this, e).delay = +t.apply(this, arguments);
  };
}
function bN(e, t) {
  return t = +t, function() {
    qf(this, e).delay = t;
  };
}
function _N(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? yN : bN)(t, e)) : Rn(this.node(), t).delay;
}
function wN(e, t) {
  return function() {
    Zn(this, e).duration = +t.apply(this, arguments);
  };
}
function xN(e, t) {
  return t = +t, function() {
    Zn(this, e).duration = t;
  };
}
function CN(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? wN : xN)(t, e)) : Rn(this.node(), t).duration;
}
function SN(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    Zn(this, e).ease = t;
  };
}
function $N(e) {
  var t = this._id;
  return arguments.length ? this.each(SN(t, e)) : Rn(this.node(), t).ease;
}
function BN(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    Zn(this, e).ease = n;
  };
}
function kN(e) {
  if (typeof e != "function") throw new Error();
  return this.each(BN(this._id, e));
}
function PN(e) {
  typeof e != "function" && (e = Zy(e));
  for (var t = this._groups, n = t.length, a = new Array(n), r = 0; r < n; ++r)
    for (var o = t[r], s = o.length, i = a[r] = [], u, d = 0; d < s; ++d)
      (u = o[d]) && e.call(u, u.__data__, d, o) && i.push(u);
  return new da(a, this._parents, this._name, this._id);
}
function MN(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, a = t.length, r = n.length, o = Math.min(a, r), s = new Array(a), i = 0; i < o; ++i)
    for (var u = t[i], d = n[i], c = u.length, f = s[i] = new Array(c), p, v = 0; v < c; ++v)
      (p = u[v] || d[v]) && (f[v] = p);
  for (; i < a; ++i)
    s[i] = t[i];
  return new da(s, this._parents, this._name, this._id);
}
function DN(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function qN(e, t, n) {
  var a, r, o = DN(t) ? qf : Zn;
  return function() {
    var s = o(this, e), i = s.on;
    i !== a && (r = (a = i).copy()).on(t, n), s.on = r;
  };
}
function AN(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Rn(this.node(), n).on.on(e) : this.each(qN(n, e, t));
}
function EN(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function TN() {
  return this.on("end.remove", EN(this._id));
}
function IN(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = _f(e));
  for (var a = this._groups, r = a.length, o = new Array(r), s = 0; s < r; ++s)
    for (var i = a[s], u = i.length, d = o[s] = new Array(u), c, f, p = 0; p < u; ++p)
      (c = i[p]) && (f = e.call(c, c.__data__, p, i)) && ("__data__" in c && (f.__data__ = c.__data__), d[p] = f, Zi(d[p], t, n, p, d, Rn(c, n)));
  return new da(o, this._parents, t, n);
}
function ON(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Jy(e));
  for (var a = this._groups, r = a.length, o = [], s = [], i = 0; i < r; ++i)
    for (var u = a[i], d = u.length, c, f = 0; f < d; ++f)
      if (c = u[f]) {
        for (var p = e.call(c, c.__data__, f, u), v, m = Rn(c, n), y = 0, x = p.length; y < x; ++y)
          (v = p[y]) && Zi(v, t, n, y, p, m);
        o.push(p), s.push(c);
      }
  return new da(o, s, t, n);
}
var RN = Cs.prototype.constructor;
function VN() {
  return new RN(this._groups, this._parents);
}
function FN(e, t) {
  var n, a, r;
  return function() {
    var o = Vr(this, e), s = (this.style.removeProperty(e), Vr(this, e));
    return o === s ? null : o === n && s === a ? r : r = t(n = o, a = s);
  };
}
function Lb(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function NN(e, t, n) {
  var a, r = n + "", o;
  return function() {
    var s = Vr(this, e);
    return s === r ? null : s === a ? o : o = t(a = s, n);
  };
}
function LN(e, t, n) {
  var a, r, o;
  return function() {
    var s = Vr(this, e), i = n(this), u = i + "";
    return i == null && (u = i = (this.style.removeProperty(e), Vr(this, e))), s === u ? null : s === a && u === r ? o : (r = u, o = t(a = s, i));
  };
}
function zN(e, t) {
  var n, a, r, o = "style." + t, s = "end." + o, i;
  return function() {
    var u = Zn(this, e), d = u.on, c = u.value[o] == null ? i || (i = Lb(t)) : void 0;
    (d !== n || r !== c) && (a = (n = d).copy()).on(s, r = c), u.on = a;
  };
}
function HN(e, t, n) {
  var a = (e += "") == "transform" ? eN : Nb;
  return t == null ? this.styleTween(e, FN(e, a)).on("end.style." + e, Lb(e)) : typeof t == "function" ? this.styleTween(e, LN(e, a, Tf(this, "style." + e, t))).each(zN(this._id, e)) : this.styleTween(e, NN(e, a, t), n).on("end.style." + e, null);
}
function UN(e, t, n) {
  return function(a) {
    this.style.setProperty(e, t.call(this, a), n);
  };
}
function jN(e, t, n) {
  var a, r;
  function o() {
    var s = t.apply(this, arguments);
    return s !== r && (a = (r = s) && UN(e, s, n)), a;
  }
  return o._value = t, o;
}
function WN(e, t, n) {
  var a = "style." + (e += "");
  if (arguments.length < 2) return (a = this.tween(a)) && a._value;
  if (t == null) return this.tween(a, null);
  if (typeof t != "function") throw new Error();
  return this.tween(a, jN(e, t, n ?? ""));
}
function GN(e) {
  return function() {
    this.textContent = e;
  };
}
function KN(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function YN(e) {
  return this.tween("text", typeof e == "function" ? KN(Tf(this, "text", e)) : GN(e == null ? "" : e + ""));
}
function XN(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function JN(e) {
  var t, n;
  function a() {
    var r = e.apply(this, arguments);
    return r !== n && (t = (n = r) && XN(r)), t;
  }
  return a._value = e, a;
}
function ZN(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, JN(e));
}
function QN() {
  for (var e = this._name, t = this._id, n = zb(), a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      if (u = s[d]) {
        var c = Rn(u, t);
        Zi(u, e, n, d, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new da(a, this._parents, e, n);
}
function e5() {
  var e, t, n = this, a = n._id, r = n.size();
  return new Promise(function(o, s) {
    var i = { value: s }, u = { value: function() {
      --r === 0 && o();
    } };
    n.each(function() {
      var d = Zn(this, a), c = d.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(i), t._.interrupt.push(i), t._.end.push(u)), d.on = t;
    }), r === 0 && o();
  });
}
var t5 = 0;
function da(e, t, n, a) {
  this._groups = e, this._parents = t, this._name = n, this._id = a;
}
function zb() {
  return ++t5;
}
var ea = Cs.prototype;
da.prototype = {
  constructor: da,
  select: IN,
  selectAll: ON,
  selectChild: ea.selectChild,
  selectChildren: ea.selectChildren,
  filter: PN,
  merge: MN,
  selection: VN,
  transition: QN,
  call: ea.call,
  nodes: ea.nodes,
  node: ea.node,
  size: ea.size,
  empty: ea.empty,
  each: ea.each,
  on: AN,
  attr: fN,
  attrTween: gN,
  style: HN,
  styleTween: WN,
  text: YN,
  textTween: ZN,
  remove: TN,
  tween: oN,
  delay: _N,
  duration: CN,
  ease: $N,
  easeVarying: kN,
  end: e5,
  [Symbol.iterator]: ea[Symbol.iterator]
};
const Qv = (e) => +e;
function n5(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var a5 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: n5
};
function r5(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function o5(e) {
  var t, n;
  e instanceof da ? (t = e._id, e = e._name) : (t = zb(), (n = a5).time = Df(), e = e == null ? null : e + "");
  for (var a = this._groups, r = a.length, o = 0; o < r; ++o)
    for (var s = a[o], i = s.length, u, d = 0; d < i; ++d)
      (u = s[d]) && Zi(u, e, t, d, s, n || r5(u, t));
  return new da(a, this._parents, e, t);
}
Cs.prototype.interrupt = LF;
Cs.prototype.transition = o5;
function Nu(e, t, n) {
  if (e.nodes().forEach((a) => Ib(a)), t) {
    const a = e.transition().duration(t);
    return n && a.ease(n), a;
  } else
    return e;
}
class Hb {
  constructor(t) {
    this.data = t;
  }
  get data() {
    return this._data;
  }
  set data(t) {
    this._data = t;
  }
}
function Vn(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function Ub(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const em = /* @__PURE__ */ Symbol("implicit");
function If() {
  var e = new Sv(), t = [], n = [], a = em;
  function r(o) {
    let s = e.get(o);
    if (s === void 0) {
      if (a !== em) return a;
      e.set(o, s = t.push(o) - 1);
    }
    return n[s % n.length];
  }
  return r.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [], e = new Sv();
    for (const s of o)
      e.has(s) || e.set(s, t.push(s) - 1);
    return r;
  }, r.range = function(o) {
    return arguments.length ? (n = Array.from(o), r) : n.slice();
  }, r.unknown = function(o) {
    return arguments.length ? (a = o, r) : a;
  }, r.copy = function() {
    return If(t, n).unknown(a);
  }, Vn.apply(r, arguments), r;
}
function Of() {
  var e = If().unknown(void 0), t = e.domain, n = e.range, a = 0, r = 1, o, s, i = !1, u = 0, d = 0, c = 0.5;
  delete e.unknown;
  function f() {
    var p = t().length, v = r < a, m = v ? r : a, y = v ? a : r;
    o = (y - m) / Math.max(1, p - u + d * 2), i && (o = Math.floor(o)), m += (y - m - o * (p - u)) * c, s = o * (1 - u), i && (m = Math.round(m), s = Math.round(s));
    var x = yV(p).map(function(C) {
      return m + o * C;
    });
    return n(v ? x.reverse() : x);
  }
  return e.domain = function(p) {
    return arguments.length ? (t(p), f()) : t();
  }, e.range = function(p) {
    return arguments.length ? ([a, r] = p, a = +a, r = +r, f()) : [a, r];
  }, e.rangeRound = function(p) {
    return [a, r] = p, a = +a, r = +r, i = !0, f();
  }, e.bandwidth = function() {
    return s;
  }, e.step = function() {
    return o;
  }, e.round = function(p) {
    return arguments.length ? (i = !!p, f()) : i;
  }, e.padding = function(p) {
    return arguments.length ? (u = Math.min(1, d = +p), f()) : u;
  }, e.paddingInner = function(p) {
    return arguments.length ? (u = Math.min(1, p), f()) : u;
  }, e.paddingOuter = function(p) {
    return arguments.length ? (d = +p, f()) : d;
  }, e.align = function(p) {
    return arguments.length ? (c = Math.max(0, Math.min(1, p)), f()) : c;
  }, e.copy = function() {
    return Of(t(), [a, r]).round(i).paddingInner(u).paddingOuter(d).align(c);
  }, Vn.apply(f(), arguments);
}
function jb(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return jb(t());
  }, e;
}
function s5() {
  return jb(Of.apply(null, arguments).paddingInner(1));
}
function l5(e) {
  return function() {
    return e;
  };
}
function Ld(e) {
  return +e;
}
var tm = [0, 1];
function en(e) {
  return e;
}
function zd(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : l5(isNaN(t) ? NaN : 0.5);
}
function i5(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(a) {
    return Math.max(e, Math.min(t, a));
  };
}
function u5(e, t, n) {
  var a = e[0], r = e[1], o = t[0], s = t[1];
  return r < a ? (a = zd(r, a), o = n(s, o)) : (a = zd(a, r), o = n(o, s)), function(i) {
    return o(a(i));
  };
}
function d5(e, t, n) {
  var a = Math.min(e.length, t.length) - 1, r = new Array(a), o = new Array(a), s = -1;
  for (e[a] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < a; )
    r[s] = zd(e[s], e[s + 1]), o[s] = n(t[s], t[s + 1]);
  return function(i) {
    var u = Ss(e, i, 1, a) - 1;
    return o[u](r[u](i));
  };
}
function Ps(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function Qi() {
  var e = tm, t = tm, n = ro, a, r, o, s = en, i, u, d;
  function c() {
    var p = Math.min(e.length, t.length);
    return s !== en && (s = i5(e[0], e[p - 1])), i = p > 2 ? d5 : u5, u = d = null, f;
  }
  function f(p) {
    return p == null || isNaN(p = +p) ? o : (u || (u = i(e.map(a), t, n)))(a(s(p)));
  }
  return f.invert = function(p) {
    return s(r((d || (d = i(t, e.map(a), Sn)))(p)));
  }, f.domain = function(p) {
    return arguments.length ? (e = Array.from(p, Ld), c()) : e.slice();
  }, f.range = function(p) {
    return arguments.length ? (t = Array.from(p), c()) : t.slice();
  }, f.rangeRound = function(p) {
    return t = Array.from(p), n = Ef, c();
  }, f.clamp = function(p) {
    return arguments.length ? (s = p ? !0 : en, c()) : s !== en;
  }, f.interpolate = function(p) {
    return arguments.length ? (n = p, c()) : n;
  }, f.unknown = function(p) {
    return arguments.length ? (o = p, f) : o;
  }, function(p, v) {
    return a = p, r = v, c();
  };
}
function Wb() {
  return Qi()(en, en);
}
function c5(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Ql(e, t) {
  if (!isFinite(e) || e === 0) return null;
  var n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e"), a = e.slice(0, n);
  return [
    a.length > 1 ? a[0] + a.slice(2) : a,
    +e.slice(n + 1)
  ];
}
function Lr(e) {
  return e = Ql(Math.abs(e)), e ? e[1] : NaN;
}
function f5(e, t) {
  return function(n, a) {
    for (var r = n.length, o = [], s = 0, i = e[0], u = 0; r > 0 && i > 0 && (u + i + 1 > a && (i = Math.max(1, a - u)), o.push(n.substring(r -= i, r + i)), !((u += i + 1) > a)); )
      i = e[s = (s + 1) % e.length];
    return o.reverse().join(t);
  };
}
function p5(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var v5 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Zo(e) {
  if (!(t = v5.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new Rf({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Zo.prototype = Rf.prototype;
function Rf(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
Rf.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function m5(e) {
  e: for (var t = e.length, n = 1, a = -1, r; n < t; ++n)
    switch (e[n]) {
      case ".":
        a = r = n;
        break;
      case "0":
        a === 0 && (a = n), r = n;
        break;
      default:
        if (!+e[n]) break e;
        a > 0 && (a = 0);
        break;
    }
  return a > 0 ? e.slice(0, a) + e.slice(r + 1) : e;
}
var ei;
function h5(e, t) {
  var n = Ql(e, t);
  if (!n) return ei = void 0, e.toPrecision(t);
  var a = n[0], r = n[1], o = r - (ei = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, s = a.length;
  return o === s ? a : o > s ? a + new Array(o - s + 1).join("0") : o > 0 ? a.slice(0, o) + "." + a.slice(o) : "0." + new Array(1 - o).join("0") + Ql(e, Math.max(0, t + o - 1))[0];
}
function nm(e, t) {
  var n = Ql(e, t);
  if (!n) return e + "";
  var a = n[0], r = n[1];
  return r < 0 ? "0." + new Array(-r).join("0") + a : a.length > r + 1 ? a.slice(0, r + 1) + "." + a.slice(r + 1) : a + new Array(r - a.length + 2).join("0");
}
const am = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: c5,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => nm(e * 100, t),
  r: nm,
  s: h5,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function rm(e) {
  return e;
}
var om = Array.prototype.map, sm = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function g5(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? rm : f5(om.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", a = e.currency === void 0 ? "" : e.currency[1] + "", r = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? rm : p5(om.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", i = e.minus === void 0 ? "" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function d(f, p) {
    f = Zo(f);
    var v = f.fill, m = f.align, y = f.sign, x = f.symbol, C = f.zero, S = f.width, $ = f.comma, k = f.precision, B = f.trim, P = f.type;
    P === "n" ? ($ = !0, P = "g") : am[P] || (k === void 0 && (k = 12), B = !0, P = "g"), (C || v === "0" && m === "=") && (C = !0, v = "0", m = "=");
    var M = (p && p.prefix !== void 0 ? p.prefix : "") + (x === "$" ? n : x === "#" && /[boxX]/.test(P) ? "0" + P.toLowerCase() : ""), q = (x === "$" ? a : /[%p]/.test(P) ? s : "") + (p && p.suffix !== void 0 ? p.suffix : ""), E = am[P], D = /[defgprs%]/.test(P);
    k = k === void 0 ? 6 : /[gprs]/.test(P) ? Math.max(1, Math.min(21, k)) : Math.max(0, Math.min(20, k));
    function O(F) {
      var J = M, ne = q, Q, W, H;
      if (P === "c")
        ne = E(F) + ne, F = "";
      else {
        F = +F;
        var U = F < 0 || 1 / F < 0;
        if (F = isNaN(F) ? u : E(Math.abs(F), k), B && (F = m5(F)), U && +F == 0 && y !== "+" && (U = !1), J = (U ? y === "(" ? y : i : y === "-" || y === "(" ? "" : y) + J, ne = (P === "s" && !isNaN(F) && ei !== void 0 ? sm[8 + ei / 3] : "") + ne + (U && y === "(" ? ")" : ""), D) {
          for (Q = -1, W = F.length; ++Q < W; )
            if (H = F.charCodeAt(Q), 48 > H || H > 57) {
              ne = (H === 46 ? r + F.slice(Q + 1) : F.slice(Q)) + ne, F = F.slice(0, Q);
              break;
            }
        }
      }
      $ && !C && (F = t(F, 1 / 0));
      var se = J.length + F.length + ne.length, ee = se < S ? new Array(S - se + 1).join(v) : "";
      switch ($ && C && (F = t(ee + F, ee.length ? S - ne.length : 1 / 0), ee = ""), m) {
        case "<":
          F = J + F + ne + ee;
          break;
        case "=":
          F = J + ee + F + ne;
          break;
        case "^":
          F = ee.slice(0, se = ee.length >> 1) + J + F + ne + ee.slice(se);
          break;
        default:
          F = ee + J + F + ne;
          break;
      }
      return o(F);
    }
    return O.toString = function() {
      return f + "";
    }, O;
  }
  function c(f, p) {
    var v = Math.max(-8, Math.min(8, Math.floor(Lr(p) / 3))) * 3, m = Math.pow(10, -v), y = d((f = Zo(f), f.type = "f", f), { suffix: sm[8 + v / 3] });
    return function(x) {
      return y(m * x);
    };
  }
  return {
    format: d,
    formatPrefix: c
  };
}
var Xs, Vf, Gb;
y5({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function y5(e) {
  return Xs = g5(e), Vf = Xs.format, Gb = Xs.formatPrefix, Xs;
}
function b5(e) {
  return Math.max(0, -Lr(Math.abs(e)));
}
function _5(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Lr(t) / 3))) * 3 - Lr(Math.abs(e)));
}
function w5(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Lr(t) - Lr(e)) + 1;
}
function x5(e, t, n, a) {
  var r = Md(e, t, n), o;
  switch (a = Zo(a ?? ",f"), a.type) {
    case "s": {
      var s = Math.max(Math.abs(e), Math.abs(t));
      return a.precision == null && !isNaN(o = _5(r, s)) && (a.precision = o), Gb(a, s);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      a.precision == null && !isNaN(o = w5(r, Math.max(Math.abs(e), Math.abs(t)))) && (a.precision = o - (a.type === "e"));
      break;
    }
    case "f":
    case "%": {
      a.precision == null && !isNaN(o = b5(r)) && (a.precision = o - (a.type === "%") * 2);
      break;
    }
  }
  return Vf(a);
}
function fr(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var a = t();
    return kd(a[0], a[a.length - 1], n ?? 10);
  }, e.tickFormat = function(n, a) {
    var r = t();
    return x5(r[0], r[r.length - 1], n ?? 10, a);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var a = t(), r = 0, o = a.length - 1, s = a[r], i = a[o], u, d, c = 10;
    for (i < s && (d = s, s = i, i = d, d = r, r = o, o = d); c-- > 0; ) {
      if (d = Pd(s, i, n), d === u)
        return a[r] = s, a[o] = i, t(a);
      if (d > 0)
        s = Math.floor(s / d) * d, i = Math.ceil(i / d) * d;
      else if (d < 0)
        s = Math.ceil(s * d) / d, i = Math.floor(i * d) / d;
      else
        break;
      u = d;
    }
    return e;
  }, e;
}
function Kb() {
  var e = Wb();
  return e.copy = function() {
    return Ps(e, Kb());
  }, Vn.apply(e, arguments), fr(e);
}
function Yb(e) {
  var t;
  function n(a) {
    return a == null || isNaN(a = +a) ? t : a;
  }
  return n.invert = n, n.domain = n.range = function(a) {
    return arguments.length ? (e = Array.from(a, Ld), n) : e.slice();
  }, n.unknown = function(a) {
    return arguments.length ? (t = a, n) : t;
  }, n.copy = function() {
    return Yb(e).unknown(t);
  }, e = arguments.length ? Array.from(e, Ld) : [0, 1], fr(n);
}
function Xb(e, t) {
  e = e.slice();
  var n = 0, a = e.length - 1, r = e[n], o = e[a], s;
  return o < r && (s = n, n = a, a = s, s = r, r = o, o = s), e[n] = t.floor(r), e[a] = t.ceil(o), e;
}
function lm(e) {
  return Math.log(e);
}
function im(e) {
  return Math.exp(e);
}
function C5(e) {
  return -Math.log(-e);
}
function S5(e) {
  return -Math.exp(-e);
}
function $5(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function B5(e) {
  return e === 10 ? $5 : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function k5(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function um(e) {
  return (t, n) => -e(-t, n);
}
function P5(e) {
  const t = e(lm, im), n = t.domain;
  let a = 10, r, o;
  function s() {
    return r = k5(a), o = B5(a), n()[0] < 0 ? (r = um(r), o = um(o), e(C5, S5)) : e(lm, im), t;
  }
  return t.base = function(i) {
    return arguments.length ? (a = +i, s()) : a;
  }, t.domain = function(i) {
    return arguments.length ? (n(i), s()) : n();
  }, t.ticks = (i) => {
    const u = n();
    let d = u[0], c = u[u.length - 1];
    const f = c < d;
    f && ([d, c] = [c, d]);
    let p = r(d), v = r(c), m, y;
    const x = i == null ? 10 : +i;
    let C = [];
    if (!(a % 1) && v - p < x) {
      if (p = Math.floor(p), v = Math.ceil(v), d > 0) {
        for (; p <= v; ++p)
          for (m = 1; m < a; ++m)
            if (y = p < 0 ? m / o(-p) : m * o(p), !(y < d)) {
              if (y > c) break;
              C.push(y);
            }
      } else for (; p <= v; ++p)
        for (m = a - 1; m >= 1; --m)
          if (y = p > 0 ? m / o(-p) : m * o(p), !(y < d)) {
            if (y > c) break;
            C.push(y);
          }
      C.length * 2 < x && (C = kd(d, c, x));
    } else
      C = kd(p, v, Math.min(v - p, x)).map(o);
    return f ? C.reverse() : C;
  }, t.tickFormat = (i, u) => {
    if (i == null && (i = 10), u == null && (u = a === 10 ? "s" : ","), typeof u != "function" && (!(a % 1) && (u = Zo(u)).precision == null && (u.trim = !0), u = Vf(u)), i === 1 / 0) return u;
    const d = Math.max(1, a * i / t.ticks().length);
    return (c) => {
      let f = c / o(Math.round(r(c)));
      return f * a < a - 0.5 && (f *= a), f <= d ? u(c) : "";
    };
  }, t.nice = () => n(Xb(n(), {
    floor: (i) => o(Math.floor(r(i))),
    ceil: (i) => o(Math.ceil(r(i)))
  })), t;
}
function Jb() {
  const e = P5(Qi()).domain([1, 10]);
  return e.copy = () => Ps(e, Jb()).base(e.base()), Vn.apply(e, arguments), e;
}
function dm(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function cm(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function M5(e) {
  var t = 1, n = e(dm(t), cm(t));
  return n.constant = function(a) {
    return arguments.length ? e(dm(t = +a), cm(t)) : t;
  }, fr(n);
}
function Zb() {
  var e = M5(Qi());
  return e.copy = function() {
    return Ps(e, Zb()).constant(e.constant());
  }, Vn.apply(e, arguments);
}
function fm(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function D5(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function q5(e) {
  return e < 0 ? -e * e : e * e;
}
function A5(e) {
  var t = e(en, en), n = 1;
  function a() {
    return n === 1 ? e(en, en) : n === 0.5 ? e(D5, q5) : e(fm(n), fm(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, a()) : n;
  }, fr(t);
}
function Ff() {
  var e = A5(Qi());
  return e.copy = function() {
    return Ps(e, Ff()).exponent(e.exponent());
  }, Vn.apply(e, arguments), e;
}
function E5() {
  return Ff.apply(null, arguments).exponent(0.5);
}
function Qb() {
  var e = [], t = [], n = [], a;
  function r() {
    var s = 0, i = Math.max(1, t.length);
    for (n = new Array(i - 1); ++s < i; ) n[s - 1] = gV(e, s / i);
    return o;
  }
  function o(s) {
    return s == null || isNaN(s = +s) ? a : t[Ss(n, s)];
  }
  return o.invertExtent = function(s) {
    var i = t.indexOf(s);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? n[i - 1] : e[0],
      i < n.length ? n[i] : e[e.length - 1]
    ];
  }, o.domain = function(s) {
    if (!arguments.length) return e.slice();
    e = [];
    for (let i of s) i != null && !isNaN(i = +i) && e.push(i);
    return e.sort(Eo), r();
  }, o.range = function(s) {
    return arguments.length ? (t = Array.from(s), r()) : t.slice();
  }, o.unknown = function(s) {
    return arguments.length ? (a = s, o) : a;
  }, o.quantiles = function() {
    return n.slice();
  }, o.copy = function() {
    return Qb().domain(e).range(t).unknown(a);
  }, Vn.apply(o, arguments);
}
function e_() {
  var e = 0, t = 1, n = 1, a = [0.5], r = [0, 1], o;
  function s(u) {
    return u != null && u <= u ? r[Ss(a, u, 0, n)] : o;
  }
  function i() {
    var u = -1;
    for (a = new Array(n); ++u < n; ) a[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return s;
  }
  return s.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, i()) : [e, t];
  }, s.range = function(u) {
    return arguments.length ? (n = (r = Array.from(u)).length - 1, i()) : r.slice();
  }, s.invertExtent = function(u) {
    var d = r.indexOf(u);
    return d < 0 ? [NaN, NaN] : d < 1 ? [e, a[0]] : d >= n ? [a[n - 1], t] : [a[d - 1], a[d]];
  }, s.unknown = function(u) {
    return arguments.length && (o = u), s;
  }, s.thresholds = function() {
    return a.slice();
  }, s.copy = function() {
    return e_().domain([e, t]).range(r).unknown(o);
  }, Vn.apply(fr(s), arguments);
}
function t_() {
  var e = [0.5], t = [0, 1], n, a = 1;
  function r(o) {
    return o != null && o <= o ? t[Ss(e, o, 0, a)] : n;
  }
  return r.domain = function(o) {
    return arguments.length ? (e = Array.from(o), a = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(o) {
    return arguments.length ? (t = Array.from(o), a = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(o) {
    var s = t.indexOf(o);
    return [e[s - 1], e[s]];
  }, r.unknown = function(o) {
    return arguments.length ? (n = o, r) : n;
  }, r.copy = function() {
    return t_().domain(e).range(t).unknown(n);
  }, Vn.apply(r, arguments);
}
const Lu = /* @__PURE__ */ new Date(), zu = /* @__PURE__ */ new Date();
function Mt(e, t, n, a) {
  function r(o) {
    return e(o = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+o)), o;
  }
  return r.floor = (o) => (e(o = /* @__PURE__ */ new Date(+o)), o), r.ceil = (o) => (e(o = new Date(o - 1)), t(o, 1), e(o), o), r.round = (o) => {
    const s = r(o), i = r.ceil(o);
    return o - s < i - o ? s : i;
  }, r.offset = (o, s) => (t(o = /* @__PURE__ */ new Date(+o), s == null ? 1 : Math.floor(s)), o), r.range = (o, s, i) => {
    const u = [];
    if (o = r.ceil(o), i = i == null ? 1 : Math.floor(i), !(o < s) || !(i > 0)) return u;
    let d;
    do
      u.push(d = /* @__PURE__ */ new Date(+o)), t(o, i), e(o);
    while (d < o && o < s);
    return u;
  }, r.filter = (o) => Mt((s) => {
    if (s >= s) for (; e(s), !o(s); ) s.setTime(s - 1);
  }, (s, i) => {
    if (s >= s)
      if (i < 0) for (; ++i <= 0; )
        for (; t(s, -1), !o(s); )
          ;
      else for (; --i >= 0; )
        for (; t(s, 1), !o(s); )
          ;
  }), n && (r.count = (o, s) => (Lu.setTime(+o), zu.setTime(+s), e(Lu), e(zu), Math.floor(n(Lu, zu))), r.every = (o) => (o = Math.floor(o), !isFinite(o) || !(o > 0) ? null : o > 1 ? r.filter(a ? (s) => a(s) % o === 0 : (s) => r.count(0, s) % o === 0) : r)), r;
}
const ti = Mt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
ti.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Mt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : ti);
ti.range;
const sa = 1e3, wn = sa * 60, la = wn * 60, ca = la * 24, Nf = ca * 7, pm = ca * 30, Hu = ca * 365, Ka = Mt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * sa);
}, (e, t) => (t - e) / sa, (e) => e.getUTCSeconds());
Ka.range;
const Lf = Mt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * sa);
}, (e, t) => {
  e.setTime(+e + t * wn);
}, (e, t) => (t - e) / wn, (e) => e.getMinutes());
Lf.range;
const zf = Mt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * wn);
}, (e, t) => (t - e) / wn, (e) => e.getUTCMinutes());
zf.range;
const Hf = Mt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * sa - e.getMinutes() * wn);
}, (e, t) => {
  e.setTime(+e + t * la);
}, (e, t) => (t - e) / la, (e) => e.getHours());
Hf.range;
const Uf = Mt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * la);
}, (e, t) => (t - e) / la, (e) => e.getUTCHours());
Uf.range;
const Ms = Mt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * wn) / ca,
  (e) => e.getDate() - 1
);
Ms.range;
const eu = Mt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / ca, (e) => e.getUTCDate() - 1);
eu.range;
const n_ = Mt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / ca, (e) => Math.floor(e / ca));
n_.range;
function pr(e) {
  return Mt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * wn) / Nf);
}
const tu = pr(0), ni = pr(1), T5 = pr(2), I5 = pr(3), zr = pr(4), O5 = pr(5), R5 = pr(6);
tu.range;
ni.range;
T5.range;
I5.range;
zr.range;
O5.range;
R5.range;
function vr(e) {
  return Mt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / Nf);
}
const nu = vr(0), ai = vr(1), V5 = vr(2), F5 = vr(3), Hr = vr(4), N5 = vr(5), L5 = vr(6);
nu.range;
ai.range;
V5.range;
F5.range;
Hr.range;
N5.range;
L5.range;
const jf = Mt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
jf.range;
const Wf = Mt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
Wf.range;
const fa = Mt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
fa.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Mt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
fa.range;
const pa = Mt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
pa.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Mt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
pa.range;
function a_(e, t, n, a, r, o) {
  const s = [
    [Ka, 1, sa],
    [Ka, 5, 5 * sa],
    [Ka, 15, 15 * sa],
    [Ka, 30, 30 * sa],
    [o, 1, wn],
    [o, 5, 5 * wn],
    [o, 15, 15 * wn],
    [o, 30, 30 * wn],
    [r, 1, la],
    [r, 3, 3 * la],
    [r, 6, 6 * la],
    [r, 12, 12 * la],
    [a, 1, ca],
    [a, 2, 2 * ca],
    [n, 1, Nf],
    [t, 1, pm],
    [t, 3, 3 * pm],
    [e, 1, Hu]
  ];
  function i(d, c, f) {
    const p = c < d;
    p && ([d, c] = [c, d]);
    const v = f && typeof f.range == "function" ? f : u(d, c, f), m = v ? v.range(d, +c + 1) : [];
    return p ? m.reverse() : m;
  }
  function u(d, c, f) {
    const p = Math.abs(c - d) / f, v = xf(([, , x]) => x).right(s, p);
    if (v === s.length) return e.every(Md(d / Hu, c / Hu, f));
    if (v === 0) return ti.every(Math.max(Md(d, c, f), 1));
    const [m, y] = s[p / s[v - 1][2] < s[v][2] / p ? v - 1 : v];
    return m.every(y);
  }
  return [i, u];
}
const [z5, H5] = a_(pa, Wf, nu, n_, Uf, zf), [U5, j5] = a_(fa, jf, tu, Ms, Hf, Lf);
function Uu(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function ju(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function ho(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function W5(e) {
  var t = e.dateTime, n = e.date, a = e.time, r = e.periods, o = e.days, s = e.shortDays, i = e.months, u = e.shortMonths, d = go(r), c = yo(r), f = go(o), p = yo(o), v = go(s), m = yo(s), y = go(i), x = yo(i), C = go(u), S = yo(u), $ = {
    a: H,
    A: U,
    b: se,
    B: ee,
    c: null,
    d: bm,
    e: bm,
    f: m6,
    g: $6,
    G: k6,
    H: f6,
    I: p6,
    j: v6,
    L: r_,
    m: h6,
    M: g6,
    p: de,
    q: fe,
    Q: xm,
    s: Cm,
    S: y6,
    u: b6,
    U: _6,
    V: w6,
    w: x6,
    W: C6,
    x: null,
    X: null,
    y: S6,
    Y: B6,
    Z: P6,
    "%": wm
  }, k = {
    a: _e,
    A: ye,
    b: Ee,
    B: ce,
    c: null,
    d: _m,
    e: _m,
    f: A6,
    g: z6,
    G: U6,
    H: M6,
    I: D6,
    j: q6,
    L: s_,
    m: E6,
    M: T6,
    p: V,
    q: te,
    Q: xm,
    s: Cm,
    S: I6,
    u: O6,
    U: R6,
    V: V6,
    w: F6,
    W: N6,
    x: null,
    X: null,
    y: L6,
    Y: H6,
    Z: j6,
    "%": wm
  }, B = {
    a: D,
    A: O,
    b: F,
    B: J,
    c: ne,
    d: gm,
    e: gm,
    f: i6,
    g: hm,
    G: mm,
    H: ym,
    I: ym,
    j: r6,
    L: l6,
    m: a6,
    M: o6,
    p: E,
    q: n6,
    Q: d6,
    s: c6,
    S: s6,
    u: J5,
    U: Z5,
    V: Q5,
    w: X5,
    W: e6,
    x: Q,
    X: W,
    y: hm,
    Y: mm,
    Z: t6,
    "%": u6
  };
  $.x = P(n, $), $.X = P(a, $), $.c = P(t, $), k.x = P(n, k), k.X = P(a, k), k.c = P(t, k);
  function P(z, re) {
    return function(ie) {
      var L = [], be = -1, xe = 0, Ne = z.length, Xe, lt, ke;
      for (ie instanceof Date || (ie = /* @__PURE__ */ new Date(+ie)); ++be < Ne; )
        z.charCodeAt(be) === 37 && (L.push(z.slice(xe, be)), (lt = vm[Xe = z.charAt(++be)]) != null ? Xe = z.charAt(++be) : lt = Xe === "e" ? " " : "0", (ke = re[Xe]) && (Xe = ke(ie, lt)), L.push(Xe), xe = be + 1);
      return L.push(z.slice(xe, be)), L.join("");
    };
  }
  function M(z, re) {
    return function(ie) {
      var L = ho(1900, void 0, 1), be = q(L, z, ie += "", 0), xe, Ne;
      if (be != ie.length) return null;
      if ("Q" in L) return new Date(L.Q);
      if ("s" in L) return new Date(L.s * 1e3 + ("L" in L ? L.L : 0));
      if (re && !("Z" in L) && (L.Z = 0), "p" in L && (L.H = L.H % 12 + L.p * 12), L.m === void 0 && (L.m = "q" in L ? L.q : 0), "V" in L) {
        if (L.V < 1 || L.V > 53) return null;
        "w" in L || (L.w = 1), "Z" in L ? (xe = ju(ho(L.y, 0, 1)), Ne = xe.getUTCDay(), xe = Ne > 4 || Ne === 0 ? ai.ceil(xe) : ai(xe), xe = eu.offset(xe, (L.V - 1) * 7), L.y = xe.getUTCFullYear(), L.m = xe.getUTCMonth(), L.d = xe.getUTCDate() + (L.w + 6) % 7) : (xe = Uu(ho(L.y, 0, 1)), Ne = xe.getDay(), xe = Ne > 4 || Ne === 0 ? ni.ceil(xe) : ni(xe), xe = Ms.offset(xe, (L.V - 1) * 7), L.y = xe.getFullYear(), L.m = xe.getMonth(), L.d = xe.getDate() + (L.w + 6) % 7);
      } else ("W" in L || "U" in L) && ("w" in L || (L.w = "u" in L ? L.u % 7 : "W" in L ? 1 : 0), Ne = "Z" in L ? ju(ho(L.y, 0, 1)).getUTCDay() : Uu(ho(L.y, 0, 1)).getDay(), L.m = 0, L.d = "W" in L ? (L.w + 6) % 7 + L.W * 7 - (Ne + 5) % 7 : L.w + L.U * 7 - (Ne + 6) % 7);
      return "Z" in L ? (L.H += L.Z / 100 | 0, L.M += L.Z % 100, ju(L)) : Uu(L);
    };
  }
  function q(z, re, ie, L) {
    for (var be = 0, xe = re.length, Ne = ie.length, Xe, lt; be < xe; ) {
      if (L >= Ne) return -1;
      if (Xe = re.charCodeAt(be++), Xe === 37) {
        if (Xe = re.charAt(be++), lt = B[Xe in vm ? re.charAt(be++) : Xe], !lt || (L = lt(z, ie, L)) < 0) return -1;
      } else if (Xe != ie.charCodeAt(L++))
        return -1;
    }
    return L;
  }
  function E(z, re, ie) {
    var L = d.exec(re.slice(ie));
    return L ? (z.p = c.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function D(z, re, ie) {
    var L = v.exec(re.slice(ie));
    return L ? (z.w = m.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function O(z, re, ie) {
    var L = f.exec(re.slice(ie));
    return L ? (z.w = p.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function F(z, re, ie) {
    var L = C.exec(re.slice(ie));
    return L ? (z.m = S.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function J(z, re, ie) {
    var L = y.exec(re.slice(ie));
    return L ? (z.m = x.get(L[0].toLowerCase()), ie + L[0].length) : -1;
  }
  function ne(z, re, ie) {
    return q(z, t, re, ie);
  }
  function Q(z, re, ie) {
    return q(z, n, re, ie);
  }
  function W(z, re, ie) {
    return q(z, a, re, ie);
  }
  function H(z) {
    return s[z.getDay()];
  }
  function U(z) {
    return o[z.getDay()];
  }
  function se(z) {
    return u[z.getMonth()];
  }
  function ee(z) {
    return i[z.getMonth()];
  }
  function de(z) {
    return r[+(z.getHours() >= 12)];
  }
  function fe(z) {
    return 1 + ~~(z.getMonth() / 3);
  }
  function _e(z) {
    return s[z.getUTCDay()];
  }
  function ye(z) {
    return o[z.getUTCDay()];
  }
  function Ee(z) {
    return u[z.getUTCMonth()];
  }
  function ce(z) {
    return i[z.getUTCMonth()];
  }
  function V(z) {
    return r[+(z.getUTCHours() >= 12)];
  }
  function te(z) {
    return 1 + ~~(z.getUTCMonth() / 3);
  }
  return {
    format: function(z) {
      var re = P(z += "", $);
      return re.toString = function() {
        return z;
      }, re;
    },
    parse: function(z) {
      var re = M(z += "", !1);
      return re.toString = function() {
        return z;
      }, re;
    },
    utcFormat: function(z) {
      var re = P(z += "", k);
      return re.toString = function() {
        return z;
      }, re;
    },
    utcParse: function(z) {
      var re = M(z += "", !0);
      return re.toString = function() {
        return z;
      }, re;
    }
  };
}
var vm = { "-": "", _: " ", 0: "0" }, It = /^\s*\d+/, G5 = /^%/, K5 = /[\\^$*+?|[\]().{}]/g;
function Ze(e, t, n) {
  var a = e < 0 ? "-" : "", r = (a ? -e : e) + "", o = r.length;
  return a + (o < n ? new Array(n - o + 1).join(t) + r : r);
}
function Y5(e) {
  return e.replace(K5, "\\$&");
}
function go(e) {
  return new RegExp("^(?:" + e.map(Y5).join("|") + ")", "i");
}
function yo(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function X5(e, t, n) {
  var a = It.exec(t.slice(n, n + 1));
  return a ? (e.w = +a[0], n + a[0].length) : -1;
}
function J5(e, t, n) {
  var a = It.exec(t.slice(n, n + 1));
  return a ? (e.u = +a[0], n + a[0].length) : -1;
}
function Z5(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.U = +a[0], n + a[0].length) : -1;
}
function Q5(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.V = +a[0], n + a[0].length) : -1;
}
function e6(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.W = +a[0], n + a[0].length) : -1;
}
function mm(e, t, n) {
  var a = It.exec(t.slice(n, n + 4));
  return a ? (e.y = +a[0], n + a[0].length) : -1;
}
function hm(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.y = +a[0] + (+a[0] > 68 ? 1900 : 2e3), n + a[0].length) : -1;
}
function t6(e, t, n) {
  var a = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return a ? (e.Z = a[1] ? 0 : -(a[2] + (a[3] || "00")), n + a[0].length) : -1;
}
function n6(e, t, n) {
  var a = It.exec(t.slice(n, n + 1));
  return a ? (e.q = a[0] * 3 - 3, n + a[0].length) : -1;
}
function a6(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.m = a[0] - 1, n + a[0].length) : -1;
}
function gm(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.d = +a[0], n + a[0].length) : -1;
}
function r6(e, t, n) {
  var a = It.exec(t.slice(n, n + 3));
  return a ? (e.m = 0, e.d = +a[0], n + a[0].length) : -1;
}
function ym(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.H = +a[0], n + a[0].length) : -1;
}
function o6(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.M = +a[0], n + a[0].length) : -1;
}
function s6(e, t, n) {
  var a = It.exec(t.slice(n, n + 2));
  return a ? (e.S = +a[0], n + a[0].length) : -1;
}
function l6(e, t, n) {
  var a = It.exec(t.slice(n, n + 3));
  return a ? (e.L = +a[0], n + a[0].length) : -1;
}
function i6(e, t, n) {
  var a = It.exec(t.slice(n, n + 6));
  return a ? (e.L = Math.floor(a[0] / 1e3), n + a[0].length) : -1;
}
function u6(e, t, n) {
  var a = G5.exec(t.slice(n, n + 1));
  return a ? n + a[0].length : -1;
}
function d6(e, t, n) {
  var a = It.exec(t.slice(n));
  return a ? (e.Q = +a[0], n + a[0].length) : -1;
}
function c6(e, t, n) {
  var a = It.exec(t.slice(n));
  return a ? (e.s = +a[0], n + a[0].length) : -1;
}
function bm(e, t) {
  return Ze(e.getDate(), t, 2);
}
function f6(e, t) {
  return Ze(e.getHours(), t, 2);
}
function p6(e, t) {
  return Ze(e.getHours() % 12 || 12, t, 2);
}
function v6(e, t) {
  return Ze(1 + Ms.count(fa(e), e), t, 3);
}
function r_(e, t) {
  return Ze(e.getMilliseconds(), t, 3);
}
function m6(e, t) {
  return r_(e, t) + "000";
}
function h6(e, t) {
  return Ze(e.getMonth() + 1, t, 2);
}
function g6(e, t) {
  return Ze(e.getMinutes(), t, 2);
}
function y6(e, t) {
  return Ze(e.getSeconds(), t, 2);
}
function b6(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function _6(e, t) {
  return Ze(tu.count(fa(e) - 1, e), t, 2);
}
function o_(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? zr(e) : zr.ceil(e);
}
function w6(e, t) {
  return e = o_(e), Ze(zr.count(fa(e), e) + (fa(e).getDay() === 4), t, 2);
}
function x6(e) {
  return e.getDay();
}
function C6(e, t) {
  return Ze(ni.count(fa(e) - 1, e), t, 2);
}
function S6(e, t) {
  return Ze(e.getFullYear() % 100, t, 2);
}
function $6(e, t) {
  return e = o_(e), Ze(e.getFullYear() % 100, t, 2);
}
function B6(e, t) {
  return Ze(e.getFullYear() % 1e4, t, 4);
}
function k6(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? zr(e) : zr.ceil(e), Ze(e.getFullYear() % 1e4, t, 4);
}
function P6(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ze(t / 60 | 0, "0", 2) + Ze(t % 60, "0", 2);
}
function _m(e, t) {
  return Ze(e.getUTCDate(), t, 2);
}
function M6(e, t) {
  return Ze(e.getUTCHours(), t, 2);
}
function D6(e, t) {
  return Ze(e.getUTCHours() % 12 || 12, t, 2);
}
function q6(e, t) {
  return Ze(1 + eu.count(pa(e), e), t, 3);
}
function s_(e, t) {
  return Ze(e.getUTCMilliseconds(), t, 3);
}
function A6(e, t) {
  return s_(e, t) + "000";
}
function E6(e, t) {
  return Ze(e.getUTCMonth() + 1, t, 2);
}
function T6(e, t) {
  return Ze(e.getUTCMinutes(), t, 2);
}
function I6(e, t) {
  return Ze(e.getUTCSeconds(), t, 2);
}
function O6(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function R6(e, t) {
  return Ze(nu.count(pa(e) - 1, e), t, 2);
}
function l_(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Hr(e) : Hr.ceil(e);
}
function V6(e, t) {
  return e = l_(e), Ze(Hr.count(pa(e), e) + (pa(e).getUTCDay() === 4), t, 2);
}
function F6(e) {
  return e.getUTCDay();
}
function N6(e, t) {
  return Ze(ai.count(pa(e) - 1, e), t, 2);
}
function L6(e, t) {
  return Ze(e.getUTCFullYear() % 100, t, 2);
}
function z6(e, t) {
  return e = l_(e), Ze(e.getUTCFullYear() % 100, t, 2);
}
function H6(e, t) {
  return Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function U6(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Hr(e) : Hr.ceil(e), Ze(e.getUTCFullYear() % 1e4, t, 4);
}
function j6() {
  return "+0000";
}
function wm() {
  return "%";
}
function xm(e) {
  return +e;
}
function Cm(e) {
  return Math.floor(+e / 1e3);
}
var _r, i_, u_;
W6({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function W6(e) {
  return _r = W5(e), i_ = _r.format, _r.parse, u_ = _r.utcFormat, _r.utcParse, _r;
}
function G6(e) {
  return new Date(e);
}
function K6(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Gf(e, t, n, a, r, o, s, i, u, d) {
  var c = Wb(), f = c.invert, p = c.domain, v = d(".%L"), m = d(":%S"), y = d("%I:%M"), x = d("%I %p"), C = d("%a %d"), S = d("%b %d"), $ = d("%B"), k = d("%Y");
  function B(P) {
    return (u(P) < P ? v : i(P) < P ? m : s(P) < P ? y : o(P) < P ? x : a(P) < P ? r(P) < P ? C : S : n(P) < P ? $ : k)(P);
  }
  return c.invert = function(P) {
    return new Date(f(P));
  }, c.domain = function(P) {
    return arguments.length ? p(Array.from(P, K6)) : p().map(G6);
  }, c.ticks = function(P) {
    var M = p();
    return e(M[0], M[M.length - 1], P ?? 10);
  }, c.tickFormat = function(P, M) {
    return M == null ? B : d(M);
  }, c.nice = function(P) {
    var M = p();
    return (!P || typeof P.range != "function") && (P = t(M[0], M[M.length - 1], P ?? 10)), P ? p(Xb(M, P)) : c;
  }, c.copy = function() {
    return Ps(c, Gf(e, t, n, a, r, o, s, i, u, d));
  }, c;
}
function Y6() {
  return Vn.apply(Gf(U5, j5, fa, jf, tu, Ms, Hf, Lf, Ka, i_).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function X6() {
  return Vn.apply(Gf(z5, H5, pa, Wf, nu, eu, Uf, zf, Ka, u_).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function J6() {
  var e = 0, t = 1, n, a, r, o, s = en, i = !1, u;
  function d(f) {
    return f == null || isNaN(f = +f) ? u : s(r === 0 ? 0.5 : (f = (o(f) - n) * r, i ? Math.max(0, Math.min(1, f)) : f));
  }
  d.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = o(e = +e), a = o(t = +t), r = n === a ? 0 : 1 / (a - n), d) : [e, t];
  }, d.clamp = function(f) {
    return arguments.length ? (i = !!f, d) : i;
  }, d.interpolator = function(f) {
    return arguments.length ? (s = f, d) : s;
  };
  function c(f) {
    return function(p) {
      var v, m;
      return arguments.length ? ([v, m] = p, s = f(v, m), d) : [s(0), s(1)];
    };
  }
  return d.range = c(ro), d.rangeRound = c(Ef), d.unknown = function(f) {
    return arguments.length ? (u = f, d) : u;
  }, function(f) {
    return o = f, n = f(e), a = f(t), r = n === a ? 0 : 1 / (a - n), d;
  };
}
function d_(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function c_() {
  var e = fr(J6()(en));
  return e.copy = function() {
    return d_(e, c_());
  }, Ub.apply(e, arguments);
}
function Z6() {
  var e = 0, t = 0.5, n = 1, a = 1, r, o, s, i, u, d = en, c, f = !1, p;
  function v(y) {
    return isNaN(y = +y) ? p : (y = 0.5 + ((y = +c(y)) - o) * (a * y < a * o ? i : u), d(f ? Math.max(0, Math.min(1, y)) : y));
  }
  v.domain = function(y) {
    return arguments.length ? ([e, t, n] = y, r = c(e = +e), o = c(t = +t), s = c(n = +n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v) : [e, t, n];
  }, v.clamp = function(y) {
    return arguments.length ? (f = !!y, v) : f;
  }, v.interpolator = function(y) {
    return arguments.length ? (d = y, v) : d;
  };
  function m(y) {
    return function(x) {
      var C, S, $;
      return arguments.length ? ([C, S, $] = x, d = nN(y, [C, S, $]), v) : [d(0), d(0.5), d(1)];
    };
  }
  return v.range = m(ro), v.rangeRound = m(Ef), v.unknown = function(y) {
    return arguments.length ? (p = y, v) : p;
  }, function(y) {
    return c = y, r = y(e), o = y(t), s = y(n), i = r === o ? 0 : 0.5 / (o - r), u = o === s ? 0 : 0.5 / (s - o), a = o < r ? -1 : 1, v;
  };
}
function f_() {
  var e = fr(Z6()(en));
  return e.copy = function() {
    return d_(e, f_());
  }, Ub.apply(e, arguments);
}
const Sm = {
  scaleLinear: Kb,
  scalePow: Ff,
  scaleSqrt: E5,
  scaleLog: Jb,
  scaleSymlog: Zb,
  scaleIdentity: Yb,
  scaleTime: Y6,
  scaleUtc: X6,
  scaleSequential: c_,
  scaleDiverging: f_,
  scaleQuantize: e_,
  scaleQuantile: Qb,
  scaleThreshold: t_,
  scaleOrdinal: If,
  scaleBand: Of,
  scalePoint: s5
};
var Nn;
(function(e) {
  e.X = "x", e.Y = "y";
})(Nn || (Nn = {}));
const p_ = {
  duration: 600,
  events: {},
  attributes: {}
};
class Q6 {
  constructor(t = Ao.SVG) {
    var n, a;
    this.type = Ao.SVG, this.datamodel = new Hb(), this.sizing = Bd.Fit, this.events = {}, this._defaultConfig = p_, this._width = 400, this._height = 200, this._containerWidth = void 0, this._containerHeight = void 0, this._containerMargin = { top: 0, bottom: 0, left: 0, right: 0 }, this._setUpComponentEventsThrottled = Hl(this._setUpComponentEvents, 500), this._setCustomAttributesThrottled = Hl(this._setCustomAttributes, 500), t === Ao.SVG ? this.element = document.createElementNS("http://www.w3.org/2000/svg", "g") : this.element = document.createElement("div"), this.uid = cF(), this.g = Ma(this.element);
    const r = (a = (n = this.constructor) === null || n === void 0 ? void 0 : n.selectors) === null || a === void 0 ? void 0 : a.root;
    r && this.g.attr("class", r);
  }
  /** Set the container margin. Called automatically by containers. */
  setContainerMargin(t) {
    this._containerMargin = t;
  }
  setConfig(t) {
    this.prevConfig = this.config, this.config = Gi(this._defaultConfig, t);
  }
  setData(t) {
    this.datamodel.data = t;
  }
  setSize(t, n, a, r) {
    isFinite(t) && (this._width = t), isFinite(n) && (this._height = n), isFinite(a) && (this._containerWidth = a), isFinite(r) && (this._containerHeight = r);
  }
  render(t = this.config.duration) {
    this._render(t);
    const n = "animating";
    t && (this.g.attr(n, ""), this.g.transition(n).duration(t).on("end interrupt", () => {
      this.g.attr(n, null);
    })), this._setUpComponentEventsThrottled(), this._setCustomAttributesThrottled();
  }
  get bleed() {
    return { top: 0, bottom: 0, left: 0, right: 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  _render(t = this.config.duration) {
  }
  _setCustomAttributes() {
    const t = this.config.attributes;
    Object.keys(t).forEach((n) => {
      Object.keys(t[n]).forEach((a) => {
        this.g.selectAll(`.${n}`).attr(a, t[n][a]);
      });
    });
  }
  _setUpComponentEvents() {
    this._bindEvents(this.events), this._bindEvents(this.config.events, ".user");
  }
  _bindEvents(t = this.events, n = "") {
    Object.keys(t).forEach((a) => {
      Object.keys(t[a]).forEach((r) => {
        const o = this.g.selectAll(`.${a}`);
        o.on(r + n, (s, i) => {
          const u = o.nodes(), d = u.indexOf(s.currentTarget), c = t[a][r];
          return c?.(i, s, d, u);
        });
      });
    });
  }
  destroy() {
    var t;
    (t = this.g) === null || t === void 0 || t.remove(), this.element = void 0;
  }
  isDestroyed() {
    return !this.element;
  }
}
class eL extends Hb {
  constructor(t) {
    super(t);
  }
  get data() {
    var t;
    return (t = this._data) !== null && t !== void 0 ? t : [];
  }
  set data(t) {
    Array.isArray(t) && (this._data = t);
  }
}
const v_ = Object.assign(Object.assign({}, p_), { x: void 0, y: void 0, id: (e, t) => {
  var n;
  return (n = e.id) !== null && n !== void 0 ? n : `${t}`;
}, color: (e) => e.color, xScale: void 0, yScale: void 0, excludeFromDomainCalculation: !1 });
class tL extends Q6 {
  constructor() {
    super(...arguments), this.datamodel = new eL(), this.clippable = !0, this.stacked = !1, this._defaultConfig = v_, this._xScale = Sm.scaleLinear(), this._yScale = Sm.scaleLinear();
  }
  get xScale() {
    return this.config.xScale || this._xScale;
  }
  get yScale() {
    return this.config.yScale || this._yScale;
  }
  setConfig(t) {
    var n, a;
    !((n = this.config) === null || n === void 0) && n.xScale && (t.xScale = this.config.xScale), !((a = this.config) === null || a === void 0) && a.yScale && (t.yScale = this.config.yScale), super.setConfig(t);
  }
  setScaleDomain(t, n) {
    var a, r;
    t === Nn.X && ((a = this._xScale) === null || a === void 0 || a.domain(n)), t === Nn.Y && ((r = this._yScale) === null || r === void 0 || r.domain(n));
  }
  setScaleRange(t, n) {
    var a, r;
    t === Nn.X && ((a = this._xScale) === null || a === void 0 || a.range(n)), t === Nn.Y && ((r = this._yScale) === null || r === void 0 || r.range(n));
  }
  setScale(t, n) {
    n && t === Nn.X && (this._xScale = n), n && t === Nn.Y && (this._yScale = n);
  }
  getDataExtent(t, n) {
    const { config: a, datamodel: r } = this;
    switch (t) {
      case Nn.X:
        return this.getXDataExtent();
      case Nn.Y:
        return this.getYDataExtent(n);
      default:
        return Tu(r.data, a[t]);
    }
  }
  getXDataExtent() {
    const { config: t, datamodel: n } = this;
    return Tu(n.data, t.x);
  }
  /** Some components override this method to provide custom data extent calculation */
  getYDataExtent(t) {
    const { config: n, datamodel: a } = this, r = this.xScale.domain(), o = t ? SV(a.data, r, n.x, !0) : a.data, s = Sf(n.y) ? n.y : [n.y];
    return Tu(o, ...s);
  }
}
var et;
(function(e) {
  e.Top = "top", e.Bottom = "bottom", e.Left = "left", e.Right = "right", e.Center = "center", e.Auto = "auto";
})(et || (et = {}));
var $m;
(function(e) {
  e.Absolute = "absolute", e.Fixed = "fixed";
})($m || ($m = {}));
var Bm;
(function(e) {
  e.Inside = "inside", e.Outside = "outside", e.Center = "center";
})(Bm || (Bm = {}));
var km;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(km || (km = {}));
const nL = {
  components: [],
  container: void 0,
  followCursor: !0,
  allowHover: !1,
  horizontalPlacement: et.Auto,
  horizontalShift: 0,
  verticalPlacement: et.Top,
  verticalShift: 0,
  attributes: {},
  triggers: {},
  className: void 0,
  showDelay: void 0,
  hideDelay: void 0
}, au = rn`
  label: tooltip;
  display: inline-block;
  left: 0;
  bottom: 0;
  min-width: max-content;
  position: absolute;
  opacity: 0;
  transition: opacity;
  transition-duration: var(--vis-tooltip-transition-duration);
  z-index: 999999;
  padding: var(--vis-tooltip-padding);
  color: var(--vis-tooltip-text-color);
  border-radius: var(--vis-tooltip-border-radius);
  box-shadow: var(--vis-tooltip-box-shadow);
  border: solid 1px var(--vis-tooltip-border-color);
  background-color: var(--vis-tooltip-background-color);
  backdrop-filter: var(--vis-tooltip-backdrop-filter);
`, aL = au, rL = Pf`
  :root {
    --vis-tooltip-background-color: rgba(255, 255, 255, 0.95);
    --vis-tooltip-border-color: #e5e9f7;
    --vis-tooltip-text-color: #000;
    --vis-tooltip-shadow-color: rgba(172, 179, 184, 0.35);
    --vis-tooltip-backdrop-filter: none;
    --vis-tooltip-padding: 10px 15px;
    --vis-tooltip-border-radius: 5px;
    --vis-tooltip-transition-duration: 300ms;
    --vis-tooltip-box-shadow: none;

    --vis-dark-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-dark-tooltip-text-color: #e5e9f7;
    --vis-dark-tooltip-border-color: var(--vis-color-grey);
    --vis-dark-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }

  body.theme-dark ${`.${au}`} {
    --vis-tooltip-background-color: var(--vis-dark-tooltip-background-color);
    --vis-tooltip-text-color: var(--vis-dark-tooltip-text-color);
    --vis-tooltip-border-color: var(--vis-dark-tooltip-border-color);
    --vis-tooltip-shadow-color: var(--vis-dark-tooltip-shadow-color);
  }

  body.theme-dark {
    --vis-tooltip-background-color: rgba(30,30,30, 0.95);
    --vis-tooltip-text-color: #e5e9f7;
    --vis-tooltip-border-color: var(--vis-color-grey);
    --vis-tooltip-shadow-color: rgba(0,0,0, 0.95);
  }
`, m_ = rn`
  bottom: unset;
  position: fixed;
`, ml = rn`
  opacity: 1;
`, hl = rn`
  display: none;
`, h_ = rn`
  label: non-interactive;
  pointer-events: none;
  user-select: none;
`, oL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hidden: hl,
  nonInteractive: h_,
  positionFixed: m_,
  root: au,
  show: ml,
  tooltip: aL,
  variables: rL
}, Symbol.toStringTag, { value: "Module" }));
class g_ {
  constructor(t = {}) {
    this._defaultConfig = nL, this.config = this._defaultConfig, this._setUpEventsThrottled = Hl(this._setUpEvents, 500), this._setContainerPositionThrottled = Hl(this._setContainerPosition, 500), this._isShown = !1, this.element = document.createElement("div"), this.div = Ma(this.element).attr("class", au).classed(ml, !1).classed(hl, !0), this.setConfig(t), this.components = this.config.components, this._mutationObserver = new MutationObserver(() => {
      this._isShown && (!this.config.followCursor && this._hoveredElement ? this.placeByElement(this._hoveredElement) : this._position && this.place({ x: this._position[0], y: this._position[1] }));
    }), this._mutationObserver.observe(this.div.node(), { childList: !0, subtree: !0 });
  }
  setConfig(t) {
    var n;
    this.prevConfig = this.config, this.config = Gi(this._defaultConfig, t), this.prevConfig.horizontalPlacement !== this.config.horizontalPlacement && this.overrideHorizontalPlacement(void 0), this.config.container && this.config.container !== ((n = this.prevConfig) === null || n === void 0 ? void 0 : n.container) && this.setContainer(this.config.container), this._setUpAttributes();
  }
  setContainer(t) {
    var n;
    (n = this.element.parentNode) === null || n === void 0 || n.removeChild(this.element), this._container = t, this._container.appendChild(this.element), this._setContainerPositionThrottled();
  }
  getContainer() {
    return this._container;
  }
  hasContainer() {
    return !!this._container && this._container.isConnected;
  }
  setComponents(t) {
    this.components = t;
  }
  update() {
    this._container && this._setUpEventsThrottled();
  }
  /** Show the tooltip immediately by providing content and position */
  show(t, n) {
    this.render(t), this.place(n);
  }
  _hide() {
    this.div.classed(ml, !1).on("transitionend", () => {
      this.div.classed(hl, !this._isShown);
    }), this._isShown = !1;
  }
  /** Hides the tooltip after `hideDelay` */
  hide() {
    window.clearTimeout(this._showDelayTimeoutId), this.config.hideDelay ? (window.clearTimeout(this._hideDelayTimeoutId), this._hideDelayTimeoutId = setTimeout(() => this._hide(), this.config.hideDelay)) : this._hide();
  }
  _display() {
    window.clearTimeout(this._hideDelayTimeoutId), this.div.classed(hl, !1).classed(ml, !0), this._isShown = !0;
  }
  /** Simply display the tooltip with its previous content on position, taking into account `showDelay` */
  display() {
    this._isShown || (this.config.showDelay ? (window.clearTimeout(this._showDelayTimeoutId), this._showDelayTimeoutId = setTimeout(() => {
      this._display(), this.place({ x: this._position[0], y: this._position[1] });
    }, this.config.showDelay)) : this._display());
  }
  place(t) {
    if (this._position = [t.x, t.y], !this.hasContainer()) {
      console.warn("Unovis | Tooltip: Container was not set or is not initialized yet");
      return;
    }
    const { config: n } = this, a = this.element.offsetWidth, r = this.element.offsetHeight, o = this._overriddenHorizontalPlacement || (n.horizontalPlacement === et.Auto ? et.Center : n.horizontalPlacement), s = n.verticalPlacement === et.Auto ? t.y - r < 0 ? et.Bottom : et.Top : n.verticalPlacement, i = 5, u = o === et.Left ? -a - i - n.horizontalShift : o === et.Center ? -a / 2 : i + n.horizontalShift, d = s === et.Bottom ? i + n.verticalShift : s === et.Center ? -r / 2 : -i - n.verticalShift - r, [c, f] = this._constraintPosToContainer(t.x + u, t.y + d, a, r);
    this._applyPosition(c, f, r);
  }
  placeByElement(t) {
    const { config: n } = this;
    this._hoveredElement = t;
    const a = 5, r = this.element.offsetWidth, o = this.element.offsetHeight, s = this.isContainerBody(), i = s ? window.innerWidth : this._container.scrollWidth, u = t.getBoundingClientRect(), d = s ? [u.x, u.y] : Fl({
      clientX: u.x,
      clientY: u.y,
      pageX: u.x,
      pageY: u.y
    }, this._container), c = this._overriddenHorizontalPlacement || (n.horizontalPlacement === et.Auto ? d[0] - r < 0 ? et.Right : d[0] + r > i ? et.Left : et.Center : n.horizontalPlacement);
    let f = 0;
    switch (c) {
      case et.Left:
        f = -r - a - n.horizontalShift;
        break;
      case et.Right:
        f = u.width + a + n.horizontalShift;
        break;
      case et.Center:
      default:
        f = (-r + u.width) / 2;
        break;
    }
    const p = n.verticalPlacement === et.Auto ? c !== et.Center ? et.Center : d[1] - o < 0 ? et.Bottom : et.Top : n.verticalPlacement;
    let v = -o;
    switch (p) {
      case et.Center:
        v += (o + u.height) / 2;
        break;
      case et.Bottom:
        v += o + u.height + a + n.verticalShift;
        break;
      case et.Top:
      default:
        v += -a - n.verticalShift;
        break;
    }
    const [m, y] = this._constraintPosToContainer(d[0] + f, d[1] + v, r, o);
    this._applyPosition(m, y, o);
  }
  isContainerBody() {
    return this._container === document.body;
  }
  /** Allows to override the horizontal placement of the tooltip which is useful when you want to define custom positioning behavior.
   * This method has been added for Crosshair to allow it position tooltip left or right of the crosshair line
   * (see the `_showTooltip` method of the Crosshair component).
   */
  overrideHorizontalPlacement(t) {
    this._overriddenHorizontalPlacement = t;
  }
  render(t) {
    var n;
    const { config: a, prevConfig: r } = this;
    t instanceof HTMLElement ? this.div.select(":first-child").node() !== t && this.div.html("").append(() => t) : t !== null && this.div.html(t || ""), this.div.classed((n = a.className) !== null && n !== void 0 ? n : "", !!a.className).classed(h_, !a.allowHover), r?.className && r.className !== a.className && this.div.classed(r.className, !1), this.display();
  }
  _applyPosition(t, n, a) {
    const r = this.isContainerBody(), o = r ? window.innerHeight : this._container.scrollHeight;
    this.div.classed(m_, r).style("top", r ? `${n}px` : "unset").style("bottom", r ? "unset" : `${o - n - a}px`).style("left", `${t}px`);
  }
  _constraintPosToContainer(t, n, a, r) {
    const o = this.isContainerBody(), s = o ? window.innerHeight : this._container.scrollHeight, i = o ? window.innerWidth : this._container.scrollWidth, u = 10, d = t > i - a - u, c = t < u, f = d ? i - a - u : c ? u : t, p = 10, v = n > s - r - p, m = n < p, y = v ? s - r - p : m ? p : n;
    return [
      i < a ? 0 : f,
      s < r ? 0 : y
    ];
  }
  _setContainerPosition() {
    var t;
    this._container !== document.body && ((t = getComputedStyle(this._container)) === null || t === void 0 ? void 0 : t.position) === "static" && (this._container.style.position = "relative");
  }
  _setUpEvents() {
    const { config: t } = this;
    this.components.forEach((n) => {
      const a = Ma(n.element);
      a.on("mousemove.tooltip", (r) => {
        const { config: o } = this, s = r.composedPath && r.composedPath() || r.path || [r.target];
        for (const i of Object.keys(o.triggers)) {
          const u = o.triggers[i];
          if (!u)
            continue;
          const d = a.selectAll(`.${i}`).nodes();
          for (const c of s) {
            if (c === a.node())
              break;
            if (c.classList.contains(i)) {
              const f = d.indexOf(c), p = Ma(c).datum(), v = u(p, f, d), [m, y] = this.isContainerBody() ? [r.clientX, r.clientY] : Fl(r, this._container);
              v === null ? this.hide() : (this.render(v), o.followCursor ? this.place({ x: m, y }) : this.placeByElement(c)), r.stopPropagation();
              return;
            }
          }
        }
        this._isShown && this.hide();
      }).on("mouseleave.tooltip", (r) => {
        r.stopPropagation(), this.hide();
      });
    }), t.allowHover ? this.div.on("mouseenter.tooltip", this._display.bind(this)).on("mouseleave.tooltip", this.hide.bind(this)) : this.div.on("mouseenter.tooltip", null).on("mouseleave.tooltip", null);
  }
  _setUpAttributes() {
    const t = this.config.attributes;
    t && Object.keys(t).forEach((n) => {
      this.div.attr(n, t[n]);
    });
  }
  destroy() {
    var t;
    this._mutationObserver.disconnect(), window.clearTimeout(this._hideDelayTimeoutId), window.clearTimeout(this._showDelayTimeoutId), (t = this.div) === null || t === void 0 || t.remove();
  }
}
g_.selectors = oL;
function Js(e) {
  return function() {
    return e;
  };
}
const y_ = Math.cos, ri = Math.sin, Fn = Math.sqrt, oi = Math.PI, ru = 2 * oi, Hd = Math.PI, Ud = 2 * Hd, Ua = 1e-6, sL = Ud - Ua;
function b_(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function lL(e) {
  let t = Math.floor(e);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
  if (t > 15) return b_;
  const n = 10 ** t;
  return function(a) {
    this._ += a[0];
    for (let r = 1, o = a.length; r < o; ++r)
      this._ += Math.round(arguments[r] * n) / n + a[r];
  };
}
class iL {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? b_ : lL(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, a, r) {
    this._append`Q${+t},${+n},${this._x1 = +a},${this._y1 = +r}`;
  }
  bezierCurveTo(t, n, a, r, o, s) {
    this._append`C${+t},${+n},${+a},${+r},${this._x1 = +o},${this._y1 = +s}`;
  }
  arcTo(t, n, a, r, o) {
    if (t = +t, n = +n, a = +a, r = +r, o = +o, o < 0) throw new Error(`negative radius: ${o}`);
    let s = this._x1, i = this._y1, u = a - t, d = r - n, c = s - t, f = i - n, p = c * c + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (p > Ua) if (!(Math.abs(f * u - d * c) > Ua) || !o)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let v = a - s, m = r - i, y = u * u + d * d, x = v * v + m * m, C = Math.sqrt(y), S = Math.sqrt(p), $ = o * Math.tan((Hd - Math.acos((y + p - x) / (2 * C * S))) / 2), k = $ / S, B = $ / C;
      Math.abs(k - 1) > Ua && this._append`L${t + k * c},${n + k * f}`, this._append`A${o},${o},0,0,${+(f * v > c * m)},${this._x1 = t + B * u},${this._y1 = n + B * d}`;
    }
  }
  arc(t, n, a, r, o, s) {
    if (t = +t, n = +n, a = +a, s = !!s, a < 0) throw new Error(`negative radius: ${a}`);
    let i = a * Math.cos(r), u = a * Math.sin(r), d = t + i, c = n + u, f = 1 ^ s, p = s ? r - o : o - r;
    this._x1 === null ? this._append`M${d},${c}` : (Math.abs(this._x1 - d) > Ua || Math.abs(this._y1 - c) > Ua) && this._append`L${d},${c}`, a && (p < 0 && (p = p % Ud + Ud), p > sL ? this._append`A${a},${a},0,1,${f},${t - i},${n - u}A${a},${a},0,1,${f},${this._x1 = d},${this._y1 = c}` : p > Ua && this._append`A${a},${a},0,${+(p >= Hd)},${f},${this._x1 = t + a * Math.cos(o)},${this._y1 = n + a * Math.sin(o)}`);
  }
  rect(t, n, a, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${a = +a}v${+r}h${-a}Z`;
  }
  toString() {
    return this._;
  }
}
function uL(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const a = Math.floor(n);
      if (!(a >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = a;
    }
    return e;
  }, () => new iL(t);
}
const __ = {
  draw(e, t) {
    const n = Fn(t / oi);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, ru);
  }
}, dL = {
  draw(e, t) {
    const n = Fn(t / 5) / 2;
    e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
  }
}, w_ = Fn(1 / 3), cL = w_ * 2, fL = {
  draw(e, t) {
    const n = Fn(t / cL), a = n * w_;
    e.moveTo(0, -n), e.lineTo(a, 0), e.lineTo(0, n), e.lineTo(-a, 0), e.closePath();
  }
}, pL = {
  draw(e, t) {
    const n = Fn(t), a = -n / 2;
    e.rect(a, a, n, n);
  }
}, vL = 0.8908130915292852, x_ = ri(oi / 10) / ri(7 * oi / 10), mL = ri(ru / 10) * x_, hL = -y_(ru / 10) * x_, gL = {
  draw(e, t) {
    const n = Fn(t * vL), a = mL * n, r = hL * n;
    e.moveTo(0, -n), e.lineTo(a, r);
    for (let o = 1; o < 5; ++o) {
      const s = ru * o / 5, i = y_(s), u = ri(s);
      e.lineTo(u * n, -i * n), e.lineTo(i * a - u * r, u * a + i * r);
    }
    e.closePath();
  }
}, Wu = Fn(3), yL = {
  draw(e, t) {
    const n = -Fn(t / (Wu * 3));
    e.moveTo(0, n * 2), e.lineTo(-Wu * n, -n), e.lineTo(Wu * n, -n), e.closePath();
  }
}, yn = -0.5, bn = Fn(3) / 2, jd = 1 / Fn(12), bL = (jd / 2 + 1) * 3, _L = {
  draw(e, t) {
    const n = Fn(t / bL), a = n / 2, r = n * jd, o = a, s = n * jd + n, i = -o, u = s;
    e.moveTo(a, r), e.lineTo(o, s), e.lineTo(i, u), e.lineTo(yn * a - bn * r, bn * a + yn * r), e.lineTo(yn * o - bn * s, bn * o + yn * s), e.lineTo(yn * i - bn * u, bn * i + yn * u), e.lineTo(yn * a + bn * r, yn * r - bn * a), e.lineTo(yn * o + bn * s, yn * s - bn * o), e.lineTo(yn * i + bn * u, yn * u - bn * i), e.closePath();
  }
};
function wL(e, t) {
  let n = null, a = uL(r);
  e = typeof e == "function" ? e : Js(e || __), t = typeof t == "function" ? t : Js(t === void 0 ? 64 : +t);
  function r() {
    let o;
    if (n || (n = o = a()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), o) return n = null, o + "" || null;
  }
  return r.type = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Js(o), r) : e;
  }, r.size = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Js(+o), r) : t;
  }, r.context = function(o) {
    return arguments.length ? (n = o ?? null, r) : n;
  }, r;
}
function Bo(e, t, n, a) {
  return Array.isArray(t) && isFinite(n) ? t[n % t.length] : fb(e, t, n) || (To(n) ? `var(${Pb(n)})` : null);
}
var Ln;
(function(e) {
  e.Circle = "circle", e.Cross = "cross", e.Diamond = "diamond", e.Square = "square", e.Star = "star", e.Triangle = "triangle", e.Wye = "wye";
})(Ln || (Ln = {}));
const xL = {
  [Ln.Circle]: __,
  [Ln.Cross]: dL,
  [Ln.Diamond]: fL,
  [Ln.Square]: pL,
  [Ln.Star]: gL,
  [Ln.Triangle]: yL,
  [Ln.Wye]: _L
}, un = Object.assign(Object.assign({}, Ln), { Line: "line" });
var si;
(function(e) {
  e.Horizontal = "horizontal", e.Vertical = "vertical";
})(si || (si = {}));
const CL = {
  items: [],
  labelClassName: "",
  onLegendItemClick: void 0,
  labelFontSize: null,
  labelMaxWidth: null,
  bulletSize: null,
  bulletSpacing: 4,
  bulletShape: (e) => {
    var t;
    return (t = e.shape) !== null && t !== void 0 ? t : un.Circle;
  },
  orientation: si.Horizontal,
  renderIntoProvidedDomNode: !1
}, Zs = Xo * 3, SL = {
  [un.Circle]: Math.PI / 4,
  [un.Cross]: 5 / 9,
  [un.Diamond]: Math.sqrt(3) / 6,
  [un.Square]: 1,
  [un.Star]: 0.3,
  [un.Triangle]: Math.sqrt(3) / 4,
  [un.Wye]: 5 / 11
};
function C_(e, t, n) {
  return t < 1 ? 0 : e * t + n * (t - 1);
}
function $L(e) {
  e.each((t, n, a) => {
    Ma(a[n]).append("svg").attr("width", "100%").attr("height", "100%").append("path");
  });
}
function BL(e, t, n) {
  e.each((a, r, o) => {
    var s;
    const i = fb(a, t.bulletShape, r), u = $V((s = a.color) !== null && s !== void 0 ? s : Bo(a, n, r)), d = u.length, c = Zs, f = Bs(t.bulletSize) || $b("var(--vis-legend-bullet-size)", o[r]), p = t.bulletSpacing * (Zs / f), v = C_(c, d, p), m = i === un.Line ? Zs / 2.5 : Zs, y = Ma(o[r]).select("svg").attr("viewBox", `0 0 ${v} ${m}`);
    y.selectAll("path").remove();
    const x = a.inactive ? "var(--vis-legend-bullet-inactive-opacity)" : 1;
    u.forEach((C, S) => {
      const $ = y.append("path");
      if (i === un.Line) {
        const k = S * (c + p), B = k + c;
        $.attr("d", `M${k},${m / 2} L${B},${m / 2}`).attr("transform", null).style("opacity", x).style("stroke", C).style("stroke-width", "3px").style("fill", null).style("fill-opacity", null).style("marker-start", "none").style("marker-end", "none");
      } else {
        const k = wL().type(xL[i]).size(c * m * SL[i]), B = (c - 2) / c;
        let P = m / 2;
        switch (i) {
          case un.Triangle:
            P += m / 8;
            break;
          case un.Star:
            P += m / 16;
            break;
          case un.Wye:
            P -= m / 16;
            break;
        }
        const M = S * (c + p) + c / 2;
        $.attr("d", k).attr("transform", `translate(${M}, ${Math.round(P)}) scale(${B})`).style("stroke", C).style("stroke-width", "1px").style("opacity", null).style("fill", C).style("fill-opacity", x);
      }
    });
  });
}
const Kf = rn`
  label: bullet-legend-component;
`, kL = Pf`
  :root {
    // Undefined by default to allow proper fallback to var(--vis-font-family)
    /* --vis-legend-font-family: */

    --vis-legend-label-color: #6c778c;
    --vis-legend-label-max-width: 300px;
    --vis-legend-label-font-size: 12px;
    --vis-legend-bullet-size: 9px;
    --vis-legend-bullet-inactive-opacity: 0.15;
    --vis-legend-item-spacing: 20px;
    --vis-legend-vertical-item-spacing: 5px;
    --vis-legend-bullet-label-spacing: 8px;

    --vis-dark-legend-label-color: #eee;
  }

  body.theme-dark ${`.${Kf}`} {
    --vis-legend-label-color: var(--vis-dark-legend-label-color);
  }

  body.theme-patterns {
    --vis-legend-bullet-size: 14px;
  }
`, gl = rn`
  label: legendItem;
  display: inline-flex;
  align-items: center;
  font-family: var(--vis-legend-font-family, var(--vis-font-family));
  margin-right: var(--vis-legend-item-spacing);
  white-space: nowrap;
  cursor: default;
  user-select: none;
  max-width: min-content;
`, S_ = rn`
  label: legendItemVertical;
  display: flex;
  margin-top: var(--vis-legend-vertical-item-spacing);
`, $_ = rn`
  cursor: pointer;
`, Wd = rn`
  label: legendItemLabel;
  font-size: var(--vis-legend-label-font-size);
  display: inline-block;
  vertical-align: middle;
  color: var(--vis-legend-label-color);
  max-width: var(--vis-legend-label-max-width);
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`, Gd = rn`
  flex: 0 0 auto;
  label: legendItemBullet;
  margin-right: var(--vis-legend-bullet-label-spacing);
  height: var(--vis-legend-bullet-size);
  width: var(--vis-legend-bullet-size);

  svg {
    display: block;
  }
`, PL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bullet: Gd,
  clickable: $_,
  item: gl,
  itemVertical: S_,
  label: Wd,
  root: Kf,
  variables: kL
}, Symbol.toStringTag, { value: "Module" }));
class Yf {
  constructor(t, n) {
    this._defaultConfig = CL, this.config = this._defaultConfig, this._colorAccessor = (a) => a.color, this._container = t, this.div = n?.renderIntoProvidedDomNode ? Ma(this._container) : Ma(this._container).append("div"), this.div.classed(Kf, !0), this.element = this.div.node(), n && this.setConfig(n);
  }
  setConfig(t) {
    this.prevConfig = this.config, this.config = Gi(this._defaultConfig, t), this.render();
  }
  /** @deprecated Use setConfig instead */
  update(t) {
    this.setConfig(t);
  }
  render() {
    const { config: t } = this, n = this.div.selectAll(`.${gl}`).data(t.items), a = n.enter().append("div").on("click", this._onItemClick.bind(this)), r = a.merge(n);
    r.attr("class", (o) => {
      var s;
      return `${gl} ${(s = o.className) !== null && s !== void 0 ? s : ""}`;
    }).classed(S_, t.orientation === si.Vertical).classed($_, (o) => !!t.onLegendItemClick && this._isItemClickable(o)).attr("title", (o) => o.name).style("display", (o) => o.hidden ? "none" : null), a.append("span").attr("class", Gd).call($L), r.select(`.${Gd}`).style("width", function(o) {
      const i = (Array.isArray(o.color) ? o.color : [o.color]).length, u = t.bulletSize ? Bs(t.bulletSize) : $b("var(--vis-legend-bullet-size)", this) || 9, d = t.bulletSpacing;
      return `${C_(u, i, d)}px`;
    }).style("height", t.bulletSize).style("box-sizing", "content-box").call(BL, this.config, this._colorAccessor), a.append("span").attr("class", Wd).classed(t.labelClassName, !0).style("max-width", t.labelMaxWidth).style("font-size", t.labelFontSize), r.select(`.${Wd}`).text((o) => o.name), n.exit().remove();
  }
  _isItemClickable(t) {
    return t.pointer === void 0 ? !0 : t.pointer;
  }
  _onItemClick(t, n) {
    const { config: { onLegendItemClick: a } } = this, o = this.div.selectAll(`.${gl}`).nodes().indexOf(t.currentTarget);
    a && a(n, o);
  }
  destroy() {
    this.element !== this._container && this.div.remove();
  }
}
Yf.selectors = PL;
const ML = Object.assign(Object.assign({}, v_), { yStacked: void 0, baseline: null, duration: 100, tooltip: void 0, template: (e, t, n, a) => "", hideWhenFarFromPointer: !0, hideWhenFarFromPointerDistance: 100, snapToData: !0, getCircles: void 0, color: void 0, strokeColor: void 0, strokeWidth: void 0, onCrosshairMove: void 0, forceShowAt: void 0, skipRangeCheck: !1 }), DL = Pf`
  :root {
    --vis-crosshair-line-stroke-color: #888;
    --vis-crosshair-line-stroke-width: 1px;
    --vis-crosshair-line-stroke-opacity: 1;
    --vis-crosshair-circle-stroke-color: #fff;
    --vis-crosshair-circle-stroke-width: 1px;
    --vis-crosshair-circle-stroke-opacity: 0.75;
  }
`, qL = rn`
  label: crosshair-component;
`, B_ = rn`
  stroke: var(--vis-crosshair-line-stroke-color);
  stroke-width: var(--vis-crosshair-line-stroke-width);
  stroke-opacity: var(--vis-crosshair-line-stroke-opacity);
  pointer-events: none;
`, k_ = rn`
  stroke: var(--vis-crosshair-circle-stroke-color);
  stroke-width: var(--vis-crosshair-circle-stroke-width);
  stroke-opacity: var(--vis-crosshair-circle-stroke-opacity);
  pointer-events: none;
`, AL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  circle: k_,
  globalStyles: DL,
  line: B_,
  root: qL
}, Symbol.toStringTag, { value: "Module" }));
class P_ extends tL {
  constructor(t) {
    super(), this.clippable = !0, this._defaultConfig = ML, this.config = this._defaultConfig, this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, this._animFrameId = null, this._accessors = {
      x: void 0,
      y: void 0,
      yStacked: void 0,
      baseline: void 0
    }, t && this.setConfig(t), this.g.style("opacity", 0), this.line = this.g.append("line").attr("class", B_);
  }
  set accessors(t) {
    this._accessors = t;
  }
  get accessors() {
    var t;
    const { config: n } = this, a = !!(n.x || n.y || n.yStacked), r = a ? n.x : this._accessors.x, o = a ? n.y : this._accessors.y, s = o ? Sf(o) ? o : [o] : void 0, i = a ? n.yStacked : this._accessors.yStacked, u = (t = n.baseline) !== null && t !== void 0 ? t : this._accessors.baseline;
    return { x: r, y: s, yStacked: i, baseline: u };
  }
  _isContainerInViewport() {
    var t;
    if (!(!((t = this.container) === null || t === void 0) && t.node()))
      return !1;
    const n = this.container.node().getBoundingClientRect(), a = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight, o = Math.max(0, Math.min(n.right, a) - Math.max(n.left, 0)), s = Math.max(0, Math.min(n.bottom, r) - Math.max(n.top, 0)), i = n.width * n.height, u = o * s;
    return i > 0 && u / i >= 0.35;
  }
  setContainer(t) {
    this.container !== t && (this.container = t, this.container.on("mousemove.crosshair", this._onMouseMove.bind(this)), this.container.on("mouseout.crosshair", this._onMouseOut.bind(this)), this.container.on("wheel.crosshair", this._onWheel.bind(this)));
  }
  _render(t) {
    var n, a, r, o, s;
    const { config: i, datamodel: u } = this, d = To(t) ? t : i.duration, c = i.forceShowAt !== void 0, f = c ? this.xScale(i.forceShowAt) : this._xPx, p = this.xScale.invert(f), v = !((n = u.data) === null || n === void 0) && n.length && this.accessors.x ? u.data.indexOf(Ul(u.data, p, this.accessors.x, oa.Left)) : void 0;
    let m, y;
    i.snapToData && (!this.accessors.y && !this.accessors.yStacked && (!((a = u.data) === null || a === void 0) && a.length) && console.warn("Unovis | Crosshair: Y accessors have not been configured. Please check if they're present in the configuration object"), !(!((r = u.data) === null || r === void 0) && r.length) && this._mouseEvent && console.warn("Unovis | Crosshair: No data to snap to. Make sure the data has been passed to the container or to the crosshair itself"), m = Ul(u.data, p, this.accessors.x), y = u.data.indexOf(m));
    const x = this.xScale.range(), C = this.yScale.range(), S = i.snapToData && m ? Mv(Math.round(this.xScale(Jt(m, this.accessors.x, y))), 0, this._width) : Mv(f, x[0], x[1]), $ = f >= x[0] && f <= x[1], k = this._yPx >= Math.min(C[0], C[1]) && this._yPx <= Math.max(C[0], C[1]);
    let B = i.skipRangeCheck ? !!this._xPx : this._xPx ? $ && k : $;
    i.hideWhenFarFromPointer && Math.abs(S - +f) >= i.hideWhenFarFromPointerDistance && (B = !1);
    const P = (o = i.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (B && P && this._isContainerInViewport()) {
      const D = P.getContainer() || this.container.node(), O = P.isContainerBody(), F = this.accessors.x ? Jt(m, this.accessors.x, y) : void 0;
      if (c) {
        const J = this.container.node().getBoundingClientRect(), ne = (O ? f + J.left : f) + this._containerMargin.left, Q = this._height / 2 + (O ? J.top : 0), W = [ne, Q];
        this._showTooltip(m, F, W, v);
      } else if (this._mouseEvent) {
        const J = O ? [this._mouseEvent.clientX, this._mouseEvent.clientY] : Fl(this._mouseEvent, D);
        this._showTooltip(m, F, J, v);
      }
    } else
      this._hideTooltip();
    if (this._mouseEvent && ((s = i.onCrosshairMove) === null || s === void 0 || s.call(i, B ? this.xScale.invert(this._xPx) : void 0, m, y, this._mouseEvent), this._mouseEvent = void 0), Nu(this.g, d).style("opacity", B ? 1 : 0), !isFinite(f))
      return;
    this.line.attr("y1", 0).attr("y2", this._height), Nu(this.line, d, Qv).attr("x1", S).attr("x2", S);
    const M = Cf(i.getCircles) ? i.getCircles(p, u.data, this.yScale, v) : this.getCircleData(m, y), q = this.g.selectAll("circle").data(M, (D, O) => {
      var F;
      return (F = D.id) !== null && F !== void 0 ? F : O;
    }), E = q.enter().append("circle").attr("class", k_).attr("r", 0).attr("cx", S).attr("cy", (D) => D.y).style("fill", (D) => D.color).style("stroke", (D) => D.strokeColor).style("stroke-width", (D) => D.strokeWidth);
    Nu(E.merge(q), d, Qv).attr("cx", S).attr("cy", (D) => D.y).attr("r", 4).style("opacity", (D) => D.opacity).style("fill", (D) => D.color).style("stroke", (D) => D.strokeColor).style("stroke-width", (D) => D.strokeWidth), q.exit().remove();
  }
  hide(t) {
    window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      var n, a;
      this._xPx = void 0, this._yPx = void 0, this._mouseEvent = void 0, (a = (n = this.config).onCrosshairMove) === null || a === void 0 || a.call(n, void 0, void 0, void 0, t), this._render();
    });
  }
  _onMouseMove(t) {
    var n;
    const { datamodel: a, element: r } = this;
    !this.accessors.x && (!((n = a.data) === null || n === void 0) && n.length) && console.warn("Unovis | Crosshair: X accessor function has not been configured. Please check if it's present in the configuration object");
    const [o, s] = Fl(t, r);
    this._xPx = o, this._yPx = s, this._mouseEvent = t, window.cancelAnimationFrame(this._animFrameId), this._animFrameId = window.requestAnimationFrame(() => {
      this._render();
    });
  }
  _onMouseOut(t) {
    var n;
    (!t || !(!((n = this.container) === null || n === void 0) && n.node().contains(t.relatedTarget))) && this.hide(t);
  }
  _onWheel(t) {
    this.hide(t);
  }
  _showTooltip(t, n, a, r) {
    var o;
    const { config: s, datamodel: i } = this, u = (o = s.tooltip) !== null && o !== void 0 ? o : this.tooltip;
    if (!u || !a)
      return;
    const [d, c] = a, f = s.template(t, n, i.data, r);
    if (u.config.followCursor = !0, !u.config.horizontalPlacement || u.config.horizontalPlacement === et.Auto) {
      const p = u.isContainerBody() ? d - this.container.node().getBoundingClientRect().left : d;
      u.overrideHorizontalPlacement(p > this._containerWidth / 2 ? et.Left : et.Right);
    }
    f && u.show(f, { x: d, y: c });
  }
  _hideTooltip() {
    var t;
    const { config: n } = this, a = (t = n.tooltip) !== null && t !== void 0 ? t : this.tooltip;
    a?.hide();
  }
  // We don't want Crosshair to be be taken in to account in domain calculations
  getYDataExtent() {
    return [void 0, void 0];
  }
  getCircleData(t, n) {
    var a, r;
    const { config: o } = this;
    if (o.snapToData && t) {
      const s = (a = this.accessors.y) !== null && a !== void 0 ? a : [], i = (r = this.accessors.yStacked) !== null && r !== void 0 ? r : [], u = Jt(t, this.accessors.baseline, n) || 0, d = wV(t, n, ...i).map((f, p) => ({
        y: this.yScale(f + u),
        opacity: To(Jt(t, i[p], p)) ? 1 : 0,
        color: Bo(t, o.color, p),
        strokeColor: o.strokeColor ? Bo(t, o.strokeColor, p) : void 0,
        strokeWidth: o.strokeWidth ? Jt(t, o.strokeWidth, p) : void 0
      })), c = s.map((f, p) => {
        const v = Jt(t, f, n);
        return {
          y: this.yScale(v),
          opacity: To(v) ? 1 : 0,
          color: Bo(t, o.color, d.length + p),
          strokeColor: o.strokeColor ? Bo(t, o.strokeColor, p) : void 0,
          strokeWidth: o.strokeWidth ? Jt(t, o.strokeWidth, p) : void 0
        };
      });
      return d.concat(c);
    }
    return [];
  }
}
P_.selectors = AL;
const EL = /* @__PURE__ */ Symbol("tooltipAccessorKey"), TL = /* @__PURE__ */ Symbol("crosshairAccessorKey");
function Xf(e, t) {
  return Dd(e, t);
}
function Jf(e) {
  const t = zt(), n = t.attrs;
  return A(() => {
    const a = {}, r = t?.vnode.props ?? {};
    return Object.keys(r).forEach((o) => {
      a[yl(o)] = e[yl(o)];
    }), { ...a, ...n };
  });
}
const IL = { "data-vis-crosshair": "" }, OL = /* @__PURE__ */ b({
  __name: "index",
  props: {
    data: {}
  },
  setup(e, { expose: t }) {
    const n = xn(TL), a = e, r = A(() => n.data.value ?? a.data), o = Jf(a), s = I();
    return Ce(() => {
      Pe(() => {
        var i;
        s.value = new P_(o.value), (i = s.value) == null || i.setData(r.value), n.update(s.value);
      });
    }), nt(() => {
      var i;
      (i = s.value) == null || i.destroy(), n.destroy();
    }), me(o, (i, u) => {
      var d;
      Xf(i, u) || (d = s.value) == null || d.setConfig(o.value);
    }), me(r, () => {
      var i;
      (i = s.value) == null || i.setData(r.value);
    }), t({
      component: s
    }), (i, u) => (h(), G("div", IL));
  }
}), RL = { "data-vis-tooltip": "" }, M_ = /* @__PURE__ */ b({
  __name: "index",
  props: {
    components: {},
    container: {},
    followCursor: { type: Boolean },
    allowHover: { type: Boolean },
    horizontalPlacement: {},
    horizontalShift: {},
    verticalPlacement: {},
    verticalShift: {},
    triggers: {},
    attributes: {},
    className: {},
    hideDelay: {},
    showDelay: {},
    data: {}
  },
  setup(e, { expose: t }) {
    const n = xn(EL), a = Jf(e), r = I();
    return Ce(() => {
      Pe(() => {
        r.value = new g_(a.value), n.update(r.value);
      });
    }), nt(() => {
      var o;
      (o = r.value) == null || o.destroy(), n.destroy();
    }), me(a, (o, s) => {
      var i;
      Xf(o, s) || (i = r.value) == null || i.setConfig(a.value);
    }), t({
      component: r
    }), (o, s) => (h(), G("div", RL));
  }
}), VL = /* @__PURE__ */ b({
  __name: "index",
  props: {
    items: {},
    labelClassName: {},
    onLegendItemClick: { type: Function },
    labelFontSize: {},
    labelMaxWidth: {},
    bulletSize: {},
    bulletSpacing: {},
    bulletShape: { type: [Function, null] },
    orientation: {},
    renderIntoProvidedDomNode: { type: Boolean },
    data: {}
  },
  setup(e, { expose: t }) {
    const n = e;
    A(() => n.data);
    const a = Jf(n), r = I(), o = I();
    return Ce(() => {
      Pe(() => {
        o.value && (r.value = new Yf(o.value, { ...a.value, renderIntoProvidedDomNode: !0 }));
      });
    }), nt(() => {
      var s;
      (s = r.value) == null || s.destroy();
    }), me(a, (s, i) => {
      var u;
      Xf(s, i) || (u = r.value) == null || u.setConfig(a.value);
    }), t({
      component: r
    }), (s, i) => (h(), G("div", {
      "data-vis-bullet-legend": "",
      ref_key: "elRef",
      ref: o
    }, null, 512));
  }
});
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".unovis-xy-container,.unovis-single-container{display:block;position:relative;width:100%}[data-vis-leaflet-map],[data-vis-leaflet-flow-map]{display:block;position:relative}[data-vis-bullet-legend],[data-vis-flow-legend],[data-vis-rolling-pin-legend]{display:block}")), document.head.appendChild(e);
    }
  } catch (t) {
    console.error("vite-plugin-css-injected-by-js", t);
  }
})();
const a7 = /* @__PURE__ */ b({
  __name: "ChartCrosshair",
  props: {
    colors: { default: () => [] },
    index: {},
    items: {},
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(o) {
      if (n.has(o))
        return n.get(o);
      {
        const s = document.createElement("div"), i = Object.entries(db(o, [t.index])).map(([d, c]) => ({ ...t.items.find((p) => p.name === d), value: c })), u = t.customTooltip ?? Kd;
        return Ju(u, { title: o[t.index].toString(), data: i }).mount(
          s
        ), n.set(o, s.innerHTML), s.innerHTML;
      }
    }
    function r(o, s) {
      return t.colors[s] ?? "transparent";
    }
    return (o, s) => (h(), G(Ge, null, [
      N(l(M_), {
        "horizontal-shift": 20,
        "vertical-shift": 20
      }),
      N(l(OL), {
        template: a,
        color: r
      })
    ], 64));
  }
}), r7 = /* @__PURE__ */ b({
  __name: "ChartLegend",
  props: {
    items: { default: () => [] }
  },
  emits: ["legendItemClick", "update:items"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = I();
    function o() {
      const i = `.${Yf.selectors.item}`;
      Pe(() => {
        const u = r.value?.querySelectorAll(i), d = Kt({ variant: "ghost", size: "xs" }).split(" ");
        u?.forEach((c) => c.classList.add(...d, "!inline-flex", "!mr-2"));
      });
    }
    Ce(() => {
      o();
    });
    function s(i, u) {
      a("legendItemClick", i, u);
      const d = n.items[u], c = d ? !d.inactive : !0;
      n.items.some((p) => p.inactive) && c ? a(
        "update:items",
        n.items.map((p) => ({ ...p, inactive: !1 }))
      ) : a(
        "update:items",
        n.items.map(
          (p) => p.name === i.name ? { ...i, inactive: !1 } : { ...p, inactive: !0 }
        )
      ), o();
    }
    return (i, u) => (h(), G("div", {
      ref_key: "elRef",
      ref: r,
      class: "w-max",
      style: {
        "--vis-legend-bullet-size": "16px"
      }
    }, [
      N(l(VL), {
        items: e.items,
        "on-legend-item-click": s
      }, null, 8, ["items"])
    ], 512));
  }
}), o7 = /* @__PURE__ */ b({
  __name: "ChartSingleTooltip",
  props: {
    selector: {},
    index: {},
    items: {},
    valueFormatter: { type: Function },
    customTooltip: {}
  },
  setup(e) {
    const t = e, n = /* @__PURE__ */ new WeakMap();
    function a(r, o, s) {
      const i = t.valueFormatter ?? ((u) => `${u}`);
      if (t.index in r) {
        if (n.has(r))
          return n.get(r);
        {
          const u = document.createElement("div"), d = Object.entries(db(r, [t.index])).map(([f, p]) => ({ ...t.items?.find((m) => m.name === f), value: i(p) })), c = t.customTooltip ?? Kd;
          return Ju(c, { title: r[t.index], data: d }).mount(u), n.set(r, u.innerHTML), u.innerHTML;
        }
      } else {
        const u = r.data;
        if (n.has(u))
          return n.get(u);
        {
          const d = s[o];
          if (!d) return "";
          const c = getComputedStyle(d), f = [
            { name: u.name, value: i(u[t.index]), color: c.fill }
          ], p = document.createElement("div"), v = t.customTooltip ?? Kd;
          return Ju(v, { title: r[t.index], data: f }).mount(p), n.set(r, p.innerHTML), p.innerHTML;
        }
      }
    }
    return (r, o) => (h(), w(l(M_), {
      "horizontal-shift": 20,
      "vertical-shift": 20,
      triggers: {
        [e.selector]: a
      }
    }, null, 8, ["triggers"]));
  }
}), FL = { class: "flex items-center" }, NL = { class: "mr-2 h-2.5 w-2.5" }, LL = {
  width: "100%",
  height: "100%",
  viewBox: "0 0 30 30"
}, zL = ["stroke", "fill"], HL = { class: "ml-4 font-semibold" }, Kd = /* @__PURE__ */ b({
  __name: "ChartTooltip",
  props: {
    title: {},
    data: {}
  },
  setup(e) {
    return (t, n) => (h(), w(l(HO), { class: "text-sm" }, {
      default: g(() => [
        e.title ? (h(), w(l(jO), {
          key: 0,
          class: "border-b p-3"
        }, {
          default: g(() => [
            N(l(WO), null, {
              default: g(() => [
                Re(Fe(e.title), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })) : De("", !0),
        N(l(UO), { class: "flex min-w-[180px] flex-col gap-1 p-3" }, {
          default: g(() => [
            (h(!0), G(Ge, null, Et(e.data, (a, r) => (h(), G("div", {
              key: r,
              class: "flex justify-between"
            }, [
              we("div", FL, [
                we("span", NL, [
                  (h(), G("svg", LL, [
                    we("path", {
                      d: " M 15 15 m -14, 0 a 14,14 0 1,1 28,0 a 14,14 0 1,1 -28,0",
                      stroke: a.color,
                      fill: a.color,
                      "stroke-width": "1"
                    }, null, 8, zL)
                  ]))
                ]),
                we("span", null, Fe(a.name), 1)
              ]),
              we("span", HL, Fe(a.value), 1)
            ]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
});
function s7(e = 3) {
  const t = Math.floor(e / 2), n = e % 2, a = t + n, r = t;
  return [
    ...Array.from(new Array(a).keys()).map(
      (o) => `hsl(var(--vis-primary-color) / ${1 - 1 / a * o})`
    ),
    ...Array.from(new Array(r).keys()).map(
      (o) => `hsl(var(--vis-secondary-color) / ${1 - 1 / r * o})`
    )
  ];
}
const l7 = /* @__PURE__ */ b({
  __name: "Checkbox",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null] },
    disabled: { type: Boolean },
    value: {},
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = A(() => {
      const { class: s, ...i } = n;
      return i;
    }), o = ve(r, a);
    return (s, i) => (h(), w(l(GC), T(l(o), {
      class: l(R)(
        "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
        n.class
      )
    }), {
      default: g(() => [
        N(l(YC), { class: "flex h-full w-full items-center justify-center text-current" }, {
          default: g(() => [
            _(s.$slots, "default", {}, () => [
              N(l(to), { class: "h-4 w-4" })
            ])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), i7 = /* @__PURE__ */ b({
  __name: "Collapsible",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    disabled: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(Rh), oe(le(l(r))), {
      default: g(({ open: i }) => [
        _(o.$slots, "default", { open: i })
      ]),
      _: 3
    }, 16));
  }
}), u7 = /* @__PURE__ */ b({
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Vh), T(t, { class: "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down" }), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), d7 = /* @__PURE__ */ b({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Fh), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), c7 = /* @__PURE__ */ b({
  __name: "Combobox",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    resetSearchTermOnBlur: { type: Boolean },
    resetSearchTermOnSelect: { type: Boolean },
    openOnFocus: { type: Boolean },
    openOnClick: { type: Boolean },
    ignoreFilter: { type: Boolean },
    resetModelValueOnClear: { type: Boolean },
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    highlightOnHover: { type: Boolean },
    by: { type: [String, Function] },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(T$), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), f7 = /* @__PURE__ */ b({
  __name: "ComboboxAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(m$), T(l(a), {
      class: l(R)("w-[200px]", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), p7 = /* @__PURE__ */ b({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(z$), T(l(n), {
      class: l(R)("py-6 text-center text-sm", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), v7 = /* @__PURE__ */ b({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(j$), T(l(n), {
      class: l(R)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      )
    }), {
      default: g(() => [
        e.heading ? (h(), w(l(Z$), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: g(() => [
            Re(Fe(e.heading), 1)
          ]),
          _: 1
        })) : De("", !0),
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), m7 = /* @__PURE__ */ b({
  __name: "ComboboxInput",
  props: {
    displayValue: { type: Function },
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(G$), T(l(o), {
      class: l(R)(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), h7 = /* @__PURE__ */ b({
  __name: "ComboboxItem",
  props: {
    textValue: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(Y$), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center justify-between gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), g7 = /* @__PURE__ */ b({
  __name: "ComboboxList",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(eB), null, {
      default: g(() => [
        N(l(N$), T(l(o), {
          class: l(R)(
            "z-50 w-[200px] rounded-md border bg-popover text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: g(() => [
            N(l(oB), null, {
              default: g(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), y7 = /* @__PURE__ */ b({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(nB), T(l(n), {
      class: l(R)("-mx-1 h-px bg-border", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), UL = /* @__PURE__ */ b({
  __name: "Command",
  props: {
    modelValue: { default: "" },
    defaultValue: {},
    multiple: { type: Boolean },
    orientation: {},
    dir: {},
    disabled: { type: Boolean },
    selectionBehavior: {},
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "highlight", "entryFocus", "leave"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a), s = I(/* @__PURE__ */ new Map()), i = I(/* @__PURE__ */ new Map()), { contains: u } = Ah({ sensitivity: "base" }), d = pn({
      search: "",
      filtered: {
        /** The count of all visible items. */
        count: 0,
        /** Map from visible item id to its search score. */
        items: /* @__PURE__ */ new Map(),
        /** Set of groups with at least one visible item. */
        groups: /* @__PURE__ */ new Set()
      }
    });
    function c() {
      if (!d.search) {
        d.filtered.count = s.value.size;
        return;
      }
      d.filtered.groups = /* @__PURE__ */ new Set();
      let f = 0;
      for (const [p, v] of s.value) {
        const m = u(v, d.search);
        d.filtered.items.set(p, m ? 1 : 0), m && f++;
      }
      for (const [p, v] of i.value)
        for (const m of v)
          if (d.filtered.items.get(m) > 0) {
            d.filtered.groups.add(p);
            break;
          }
      d.filtered.count = f;
    }
    return me(
      () => d.search,
      () => {
        c();
      }
    ), YL({
      allItems: s,
      allGroups: i,
      filterState: d
    }), (f, p) => (h(), w(l(ig), T(l(o), {
      class: l(R)(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        n.class
      )
    }), {
      default: g(() => [
        _(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jL = /* @__PURE__ */ b({
  __name: "Dialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(yi), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), b7 = /* @__PURE__ */ b({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ia), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), WL = /* @__PURE__ */ b({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(_i), null, {
      default: g(() => [
        N(l(cs), { class: "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }),
        N(l(ds), T(l(o), {
          class: l(R)(
            "fixed top-1/2 left-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95 data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
            n.class
          )
        }), {
          default: g(() => [
            _(s.$slots, "default"),
            N(l(Ia), { class: "absolute top-4 right-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-none disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground" }, {
              default: g(() => [
                N(l(no), { class: "h-4 w-4" }),
                i[0] || (i[0] = we("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), _7 = /* @__PURE__ */ b({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(bi), T(l(a), {
      class: l(R)("text-sm text-muted-foreground", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), w7 = /* @__PURE__ */ b({
  __name: "DialogFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("flex flex-col-reverse sm:flex-row sm:justify-end sm:gap-x-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), x7 = /* @__PURE__ */ b({
  __name: "DialogHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(l(R)("flex flex-col gap-y-1.5 text-center sm:text-left", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), C7 = /* @__PURE__ */ b({
  __name: "DialogScrollContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(_i), null, {
      default: g(() => [
        N(l(cs), { class: "fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0" }, {
          default: g(() => [
            N(l(ds), T({
              class: l(R)(
                "relative z-50 my-8 grid w-full max-w-lg gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full",
                n.class
              )
            }, l(o), {
              onPointerDownOutside: i[0] || (i[0] = (u) => {
                const d = u.detail.originalEvent, c = d.target;
                (d.offsetX > c.clientWidth || d.offsetY > c.clientHeight) && u.preventDefault();
              })
            }), {
              default: g(() => [
                _(s.$slots, "default"),
                N(l(Ia), { class: "absolute top-4 right-4 rounded-md p-0.5 transition-colors hover:bg-secondary" }, {
                  default: g(() => [
                    N(l(no), { class: "h-4 w-4" }),
                    i[1] || (i[1] = we("span", { class: "sr-only" }, "Close", -1))
                  ]),
                  _: 1
                })
              ]),
              _: 3
            }, 16, ["class"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), S7 = /* @__PURE__ */ b({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(wi), T(l(a), {
      class: l(R)("text-lg leading-none font-semibold tracking-tight", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $7 = /* @__PURE__ */ b({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(xi), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), B7 = /* @__PURE__ */ b({
  __name: "CommandDialog",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(jL), oe(le(l(r))), {
      default: g(() => [
        N(l(WL), { class: "overflow-hidden p-0 shadow-lg" }, {
          default: g(() => [
            N(UL, { class: "[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5" }, {
              default: g(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16));
  }
}), k7 = /* @__PURE__ */ b({
  __name: "CommandEmpty",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { filterState: a } = ou(), r = A(() => !!a.search && a.filtered.count === 0);
    return (o, s) => r.value ? (h(), w(l(X), T({ key: 0 }, l(n), {
      class: l(R)("py-6 text-center text-sm", t.class)
    }), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"])) : De("", !0);
  }
}), P7 = /* @__PURE__ */ b({
  __name: "CommandGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    heading: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), { allGroups: a, filterState: r } = ou(), o = Ke(), s = A(() => r.search ? r.filtered.groups.has(o) : !0);
    return JL({ id: o }), Ce(() => {
      a.value.has(o) || a.value.set(o, /* @__PURE__ */ new Set());
    }), nt(() => {
      a.value.delete(o);
    }), (i, u) => (h(), w(l(cg), T(l(n), {
      id: l(o),
      class: l(R)(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        t.class
      ),
      hidden: s.value ? void 0 : !0
    }), {
      default: g(() => [
        e.heading ? (h(), w(l($$), {
          key: 0,
          class: "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }, {
          default: g(() => [
            Re(Fe(e.heading), 1)
          ]),
          _: 1
        })) : De("", !0),
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class", "hidden"]));
  }
}), GL = {
  class: "flex items-center border-b px-3",
  "cmdk-input-wrapper": ""
}, M7 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "CommandInput",
  props: {
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), { filterState: r } = ou();
    return (o, s) => (h(), G("div", GL, [
      N(l(fI), { class: "mr-2 h-4 w-4 shrink-0 opacity-50" }),
      N(l(dg), T({ ...l(a), ...o.$attrs }, {
        modelValue: l(r).search,
        "onUpdate:modelValue": s[0] || (s[0] = (i) => l(r).search = i),
        "auto-focus": "",
        class: l(R)(
          "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      }), null, 16, ["modelValue", "class"])
    ]));
  }
}), D7 = /* @__PURE__ */ b({
  __name: "CommandItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a), s = Ke(), { filterState: i, allItems: u, allGroups: d } = ou(), c = XL(), f = A(() => {
      if (i.search) {
        const m = i.filtered.items.get(s);
        return m === void 0 ? !0 : m > 0;
      } else
        return !0;
    }), p = I(), v = Y0(p);
    return Ce(() => {
      if (!(v.value instanceof HTMLElement)) return;
      u.value.set(s, v.value.textContent ?? n?.value.toString());
      const m = c?.id;
      m && (d.value.has(m) ? d.value.get(m)?.add(s) : d.value.set(m, /* @__PURE__ */ new Set([s])));
    }), nt(() => {
      u.value.delete(s);
    }), (m, y) => f.value ? (h(), w(l(fg), T({ key: 0 }, l(o), {
      id: l(s),
      ref_key: "itemRef",
      ref: p,
      class: l(R)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[highlighted]:bg-accent data-[highlighted]:text-accent-foreground [&_svg]:size-4 [&_svg]:shrink-0",
        n.class
      ),
      onSelect: y[0] || (y[0] = () => {
        l(i).search = "";
      })
    }), {
      default: g(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "class"])) : De("", !0);
  }
}), KL = { role: "presentation" }, q7 = /* @__PURE__ */ b({
  __name: "CommandList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(ug), T(l(a), {
      class: l(R)("max-h-[300px] overflow-x-hidden overflow-y-auto", t.class)
    }), {
      default: g(() => [
        we("div", KL, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), A7 = /* @__PURE__ */ b({
  __name: "CommandSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Xc), T(l(n), {
      class: l(R)("-mx-1 h-px bg-border", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), E7 = /* @__PURE__ */ b({
  __name: "CommandShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), [ou, YL] = Se("Command"), [XL, JL] = Se("CommandGroup"), T7 = /* @__PURE__ */ b({
  __name: "ContextMenu",
  props: {
    pressOpenDelay: {},
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(FB), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ZL = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, I7 = /* @__PURE__ */ b({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(OB), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: g(() => [
        we("span", ZL, [
          N(l(bg), null, {
            default: g(() => [
              N(l(to), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), O7 = /* @__PURE__ */ b({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(XB), null, {
      default: g(() => [
        N(l(LB), T(l(o), {
          class: l(R)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: g(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), R7 = /* @__PURE__ */ b({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(HB), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), V7 = /* @__PURE__ */ b({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(jB), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), F7 = /* @__PURE__ */ b({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(KB), T(l(n), {
      class: l(R)("px-2 py-1.5 text-sm font-semibold text-foreground", e.inset && "pl-8", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), N7 = /* @__PURE__ */ b({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(ZB), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), QL = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, L7 = /* @__PURE__ */ b({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(ek), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: g(() => [
        we("span", QL, [
          N(l(bg), null, {
            default: g(() => [
              N(l(uf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), z7 = /* @__PURE__ */ b({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(nk), T(l(n), {
      class: l(R)("-mx-1 my-1 h-px bg-border", t.class)
    }), null, 16, ["class"]));
  }
}), H7 = /* @__PURE__ */ b({
  __name: "ContextMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), U7 = /* @__PURE__ */ b({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(rk), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), j7 = /* @__PURE__ */ b({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(sk), T(l(o), {
      class: l(R)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), W7 = /* @__PURE__ */ b({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(ik), T(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default"),
        N(l(Fa), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), G7 = /* @__PURE__ */ b({
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), w(l(dk), oe(le(l(n))), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
(function() {
  var e;
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.nonce = (e = document.head.querySelector("meta[property=csp-nonce]")) == null ? void 0 : e.content, t.appendChild(document.createTextNode('[data-vaul-drawer]{touch-action:none;will-change:transform;transition:transform .5s cubic-bezier(.32,.72,0,1);animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=open]{animation-name:slideFromBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=bottom][data-state=closed]{animation-name:slideToBottom}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=open]{animation-name:slideFromTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=top][data-state=closed]{animation-name:slideToTop}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=open]{animation-name:slideFromLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=left][data-state=closed]{animation-name:slideToLeft}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=open]{animation-name:slideFromRight}[data-vaul-drawer][data-vaul-snap-points=false][data-vaul-drawer-direction=right][data-state=closed]{animation-name:slideToRight}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--initial-transform, 100%),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=top]{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=left]{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}[data-vaul-drawer][data-vaul-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--initial-transform, 100%),0,0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=top],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=bottom]{transform:translate3d(0,var(--snap-point-height, 0),0)}[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=left],[data-vaul-drawer][data-vaul-delayed-snap-points=true][data-vaul-drawer-direction=right]{transform:translate3d(var(--snap-point-height, 0),0,0)}[data-vaul-overlay][data-vaul-snap-points=false]{animation-duration:.5s;animation-timing-function:cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=false][data-state=open]{animation-name:fadeIn}[data-vaul-overlay][data-state=closed]{animation-name:fadeOut}[data-vaul-animate=false]{animation:none!important}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:0;transition:opacity .5s cubic-bezier(.32,.72,0,1)}[data-vaul-overlay][data-vaul-snap-points=true]{opacity:1}[data-vaul-drawer]:not([data-vaul-custom-container=true]):after{content:"";position:absolute;background:inherit;background-color:inherit}[data-vaul-drawer][data-vaul-drawer-direction=top]:after{top:initial;bottom:100%;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=bottom]:after{top:100%;bottom:initial;left:0;right:0;height:200%}[data-vaul-drawer][data-vaul-drawer-direction=left]:after{left:initial;right:100%;top:0;bottom:0;width:200%}[data-vaul-drawer][data-vaul-drawer-direction=right]:after{left:100%;right:initial;top:0;bottom:0;width:200%}[data-vaul-overlay][data-vaul-snap-points=true]:not([data-vaul-snap-points-overlay=true]):not([data-state=closed]){opacity:0}[data-vaul-overlay][data-vaul-snap-points-overlay=true]{opacity:1}[data-vaul-handle]{display:block;position:relative;opacity:.7;background:#e2e2e4;margin-left:auto;margin-right:auto;height:5px;width:32px;border-radius:1rem;touch-action:pan-y}[data-vaul-handle]:hover,[data-vaul-handle]:active{opacity:1}[data-vaul-handle-hitarea]{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:max(100%,2.75rem);height:max(100%,2.75rem);touch-action:inherit}@media (hover: hover) and (pointer: fine){[data-vaul-drawer]{-webkit-user-select:none;user-select:none}}@media (pointer: fine){[data-vaul-handle-hitarea]:{width:100%;height:100%}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{to{opacity:0}}@keyframes slideFromBottom{0%{transform:translate3d(0,var(--initial-transform, 100%),0)}to{transform:translateZ(0)}}@keyframes slideToBottom{to{transform:translate3d(0,var(--initial-transform, 100%),0)}}@keyframes slideFromTop{0%{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}to{transform:translateZ(0)}}@keyframes slideToTop{to{transform:translate3d(0,calc(var(--initial-transform, 100%) * -1),0)}}@keyframes slideFromLeft{0%{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}to{transform:translateZ(0)}}@keyframes slideToLeft{to{transform:translate3d(calc(var(--initial-transform, 100%) * -1),0,0)}}@keyframes slideFromRight{0%{transform:translate3d(var(--initial-transform, 100%),0,0)}to{transform:translateZ(0)}}@keyframes slideToRight{to{transform:translate3d(var(--initial-transform, 100%),0,0)}}')), document.head.appendChild(t);
    }
  } catch (n) {
    console.error("vite-plugin-css-injected-by-js", n);
  }
})();
const e4 = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const t4 = (e) => typeof e < "u";
function n4(e) {
  return JSON.parse(JSON.stringify(e));
}
function Pm(e, t, n, a = {}) {
  var r, o, s;
  const {
    clone: i = !1,
    passive: u = !1,
    eventName: d,
    deep: c = !1,
    defaultValue: f,
    shouldEmit: p
  } = a, v = zt(), m = n || v?.emit || ((r = v?.$emit) == null ? void 0 : r.bind(v)) || ((s = (o = v?.proxy) == null ? void 0 : o.$emit) == null ? void 0 : s.bind(v?.proxy));
  let y = d;
  t || (t = "modelValue"), y = y || `update:${t.toString()}`;
  const x = ($) => i ? typeof i == "function" ? i($) : n4($) : $, C = () => t4(e[t]) ? x(e[t]) : f, S = ($) => {
    p ? p($) && m(y, $) : m(y, $);
  };
  if (u) {
    const $ = C(), k = I($);
    let B = !1;
    return me(
      () => e[t],
      (P) => {
        B || (B = !0, k.value = x(P), Pe(() => B = !1));
      }
    ), me(
      k,
      (P) => {
        !B && (P !== e[t] || c) && S(P);
      },
      { deep: c }
    ), k;
  } else
    return A({
      get() {
        return C();
      },
      set($) {
        S($);
      }
    });
}
const [Zf, a4] = Se("DrawerRoot"), D_ = /* @__PURE__ */ new WeakMap();
function At(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement) || !t)
    return;
  const a = {};
  Object.entries(t).forEach(([r, o]) => {
    if (r.startsWith("--")) {
      e.style.setProperty(r, o);
      return;
    }
    a[r] = e.style[r], e.style[r] = o;
  }), !n && D_.set(e, a);
}
function r4(e, t) {
  if (!e || !(e instanceof HTMLElement))
    return;
  const n = D_.get(e);
  n && Object.entries(n).forEach(([a, r]) => {
    e.style[a] = r;
  });
}
function Qs(e, t) {
  const n = window.getComputedStyle(e), a = n.transform || n.webkitTransform || n.mozTransform;
  let r = a.match(/^matrix3d\((.+)\)$/);
  return r ? Number.parseFloat(r[1].split(", ")[_t(t) ? 13 : 12]) : (r = a.match(/^matrix\((.+)\)$/), r ? Number.parseFloat(r[1].split(", ")[_t(t) ? 5 : 4]) : null);
}
function o4(e) {
  return 8 * (Math.log(e + 1) - 2);
}
function _t(e) {
  switch (e) {
    case "top":
    case "bottom":
      return !0;
    case "left":
    case "right":
      return !1;
    default:
      return e;
  }
}
function Gu(e, t) {
  if (!e)
    return () => {
    };
  const n = e.style.cssText;
  return Object.assign(e.style, t), () => {
    e.style.cssText = n;
  };
}
function s4(...e) {
  return (...t) => {
    for (const n of e)
      typeof n == "function" && n(...t);
  };
}
const pt = {
  DURATION: 0.5,
  EASE: [0.32, 0.72, 0, 1]
}, q_ = 0.4, l4 = 0.25, i4 = 100, A_ = 8, el = 16, E_ = 26, Mm = "vaul-dragging";
function u4({
  activeSnapPoint: e,
  snapPoints: t,
  drawerRef: n,
  overlayRef: a,
  fadeFromIndex: r,
  onSnapPointChange: o,
  direction: s
}) {
  const i = I(typeof window < "u" ? {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight
  } : void 0);
  function u() {
    i.value = {
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight
    };
  }
  Ce(() => {
    typeof window < "u" && window.addEventListener("resize", u);
  }), Ea(() => {
    typeof window < "u" && window.removeEventListener("resize", u);
  });
  const d = A(
    () => (t.value && e.value === t.value[t.value.length - 1]) ?? null
  ), c = A(
    () => t.value && t.value.length > 0 && (r?.value || r?.value === 0) && !Number.isNaN(r?.value) && t.value[r?.value ?? -1] === e.value || !t.value
  ), f = A(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.findIndex(($) => $ === e.value)) ?? null;
    }
  ), p = A(
    () => {
      var S;
      return ((S = t.value) == null ? void 0 : S.map(($) => {
        const k = typeof $ == "string";
        let B = 0;
        if (k && (B = Number.parseInt($, 10)), _t(s.value)) {
          const M = k ? B : i.value ? $ * i.value.innerHeight : 0;
          return i.value ? s.value === "bottom" ? i.value.innerHeight - M : -i.value.innerHeight + M : M;
        }
        const P = k ? B : i.value ? $ * i.value.innerWidth : 0;
        return i.value ? s.value === "right" ? i.value.innerWidth - P : -i.value.innerWidth + P : P;
      })) ?? [];
    }
  ), v = A(
    () => {
      var S;
      return f.value !== null ? (S = p.value) == null ? void 0 : S[f.value] : null;
    }
  ), m = (S) => {
    var $, k, B, P;
    const M = (($ = p.value) == null ? void 0 : $.findIndex((q) => q === S)) ?? null;
    Pe(() => {
      var q;
      o(M, p.value), At((q = n.value) == null ? void 0 : q.$el, {
        transition: `transform ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`,
        transform: _t(s.value) ? `translate3d(0, ${S}px, 0)` : `translate3d(${S}px, 0, 0)`
      });
    }), p.value && M !== p.value.length - 1 && M !== r?.value ? At((k = a.value) == null ? void 0 : k.$el, {
      transition: `opacity ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`,
      opacity: "0"
    }) : At((B = a.value) == null ? void 0 : B.$el, {
      transition: `opacity ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`,
      opacity: "1"
    }), e.value = M !== null ? ((P = t.value) == null ? void 0 : P[M]) ?? null : null;
  };
  me(
    [e, p, t],
    () => {
      var S;
      if (e.value) {
        const $ = ((S = t.value) == null ? void 0 : S.findIndex((k) => k === e.value)) ?? -1;
        p.value && $ !== -1 && typeof p.value[$] == "number" && m(p.value[$]);
      }
    },
    {
      immediate: !0
      // if you want to run the effect immediately as well
    }
  );
  function y({
    draggedDistance: S,
    closeDrawer: $,
    velocity: k,
    dismissible: B
  }) {
    var P, M, q;
    if (r.value === void 0)
      return;
    const E = s.value === "bottom" || s.value === "right" ? (v.value ?? 0) - S : (v.value ?? 0) + S, D = f.value === r.value - 1, O = f.value === 0, F = S > 0;
    if (D && At((P = a.value) == null ? void 0 : P.$el, {
      transition: `opacity ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`
    }), k > 2 && !F) {
      B ? $() : m(p.value[0]);
      return;
    }
    if (k > 2 && F && p && t.value) {
      m(p.value[t.value.length - 1]);
      return;
    }
    const J = (M = p.value) == null ? void 0 : M.reduce((Q, W) => typeof Q != "number" || typeof W != "number" ? Q : Math.abs(W - E) < Math.abs(Q - E) ? W : Q), ne = _t(s.value) ? window.innerHeight : window.innerWidth;
    if (k > q_ && Math.abs(S) < ne * 0.4) {
      const Q = F ? 1 : -1;
      if (Q > 0 && d) {
        m(p.value[(((q = t.value) == null ? void 0 : q.length) ?? 0) - 1]);
        return;
      }
      if (O && Q < 0 && B && $(), f.value === null)
        return;
      m(p.value[f.value + Q]);
      return;
    }
    m(J);
  }
  function x({ draggedDistance: S }) {
    var $;
    if (v.value === null)
      return;
    const k = s.value === "bottom" || s.value === "right" ? v.value - S : v.value + S;
    (s.value === "bottom" || s.value === "right") && k < p.value[p.value.length - 1] || (s.value === "top" || s.value === "left") && k > p.value[p.value.length - 1] || At(($ = n.value) == null ? void 0 : $.$el, {
      transform: _t(s.value) ? `translate3d(0, ${k}px, 0)` : `translate3d(${k}px, 0, 0)`
    });
  }
  function C(S, $) {
    if (!t.value || typeof f.value != "number" || !p.value || r.value === void 0)
      return null;
    const k = f.value === r.value - 1;
    if (f.value >= r.value && $)
      return 0;
    if (k && !$)
      return 1;
    if (!c.value && !k)
      return null;
    const B = k ? f.value + 1 : f.value - 1, P = k ? p.value[B] - p.value[B - 1] : p.value[B + 1] - p.value[B], M = S / Math.abs(P);
    return k ? 1 - M : M;
  }
  return {
    isLastSnapPoint: d,
    shouldFade: c,
    getPercentageDragged: C,
    activeSnapPointIndex: f,
    onRelease: y,
    onDrag: x,
    snapPointsOffset: p
  };
}
function Dm() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
let bo = null;
function d4(e) {
  const { isOpen: t, modal: n, nested: a, hasBeenOpened: r, preventScrollRestoration: o, noBodyStyles: s } = e, i = I(typeof window < "u" ? window.location.href : ""), u = I(0);
  function d() {
    if (Dm() && bo === null && t.value && !s.value) {
      bo = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      };
      const { scrollX: f, innerHeight: p } = window;
      document.body.style.setProperty("position", "fixed", "important"), Object.assign(document.body.style, {
        top: `${-u.value}px`,
        left: `${-f}px`,
        right: "0px",
        height: "auto"
      }), setTimeout(() => {
        requestAnimationFrame(() => {
          const v = p - window.innerHeight;
          v && u.value >= p && (document.body.style.top = `-${u.value + v}px`);
        });
      }, 300);
    }
  }
  function c() {
    if (Dm() && bo !== null && !s.value) {
      const f = -Number.parseInt(document.body.style.top, 10), p = -Number.parseInt(document.body.style.left, 10);
      Object.assign(document.body.style, bo), window.requestAnimationFrame(() => {
        if (o.value && i.value !== window.location.href) {
          i.value = window.location.href;
          return;
        }
        window.scrollTo(p, f);
      }), bo = null;
    }
  }
  return Ce(() => {
    function f() {
      u.value = window.scrollY;
    }
    f(), window.addEventListener("scroll", f), nt(() => {
      window.removeEventListener("scroll", f);
    });
  }), me([t, r, i], () => {
    a.value || !r.value || (t.value ? (window.matchMedia("(display-mode: standalone)").matches || d(), n.value || setTimeout(() => {
      c();
    }, 500)) : c());
  }), { restorePositionSetting: c };
}
function c4(e, t) {
  return e && e.value ? e : t;
}
function f4(e) {
  const {
    emitDrag: t,
    emitRelease: n,
    emitClose: a,
    emitOpenChange: r,
    open: o,
    dismissible: s,
    nested: i,
    modal: u,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    scrollLockTimeout: f,
    closeThreshold: p,
    activeSnapPoint: v,
    fadeFromIndex: m,
    direction: y,
    noBodyStyles: x,
    handleOnly: C,
    preventScrollRestoration: S
  } = e, $ = I(o.value ?? !1), k = I(!1), B = I(!1), P = I(!1), M = I(null), q = I(null), E = I(null), D = I(null), O = I(null), F = I(!1), J = I(null), ne = I(0), Q = I(!1);
  I(0);
  const W = I(null);
  I(0);
  const H = A(() => {
    var ke;
    return ((ke = W.value) == null ? void 0 : ke.$el.getBoundingClientRect().height) || 0;
  }), U = c4(
    e.snapPoints,
    I(void 0)
  ), se = A(() => {
    var ke;
    return U && (((ke = U.value) == null ? void 0 : ke.length) ?? 0) > 0;
  }), ee = I(null), {
    activeSnapPointIndex: de,
    onRelease: fe,
    snapPointsOffset: _e,
    onDrag: ye,
    shouldFade: Ee,
    getPercentageDragged: ce
  } = u4({
    snapPoints: U,
    activeSnapPoint: v,
    drawerRef: W,
    fadeFromIndex: m,
    overlayRef: M,
    onSnapPointChange: V,
    direction: y
  });
  function V(ke, Le) {
    U.value && ke === Le.length - 1 && (q.value = /* @__PURE__ */ new Date());
  }
  d4({
    isOpen: $,
    modal: u,
    nested: i,
    hasBeenOpened: k,
    noBodyStyles: x,
    preventScrollRestoration: S
  });
  function te() {
    return (window.innerWidth - E_) / window.innerWidth;
  }
  function z(ke, Le) {
    var Ue;
    if (!ke)
      return !1;
    let We = ke;
    const it = (Ue = window.getSelection()) == null ? void 0 : Ue.toString(), ut = W.value ? Qs(W.value.$el, y.value) : null, $t = /* @__PURE__ */ new Date();
    if (We.hasAttribute("data-vaul-no-drag") || We.closest("[data-vaul-no-drag]"))
      return !1;
    if (y.value === "right" || y.value === "left")
      return !0;
    if (q.value && $t.getTime() - q.value.getTime() < 500)
      return !1;
    if (ut !== null && (y.value === "bottom" ? ut > 0 : ut < 0))
      return !0;
    if (it && it.length > 0)
      return !1;
    if (O.value && $t.getTime() - O.value.getTime() < f.value && ut === 0 || Le)
      return O.value = $t, !1;
    for (; We; ) {
      if (We.scrollHeight > We.clientHeight) {
        if (We.scrollTop !== 0)
          return O.value = /* @__PURE__ */ new Date(), !1;
        if (We.getAttribute("role") === "dialog")
          return !0;
      }
      We = We.parentNode;
    }
    return !0;
  }
  function re(ke) {
    !s.value && !U.value || W.value && !W.value.$el.contains(ke.target) || (B.value = !0, E.value = /* @__PURE__ */ new Date(), ke.target.setPointerCapture(ke.pointerId), ne.value = _t(y.value) ? ke.clientY : ke.clientX);
  }
  function ie(ke) {
    var Le, Ue, We, it, ut, $t;
    if (W.value && B.value) {
      const on = y.value === "bottom" || y.value === "right" ? 1 : -1, hn = (ne.value - (_t(y.value) ? ke.clientY : ke.clientX)) * on, Ve = hn > 0, Dt = U.value && !s.value && !Ve;
      if (Dt && de.value === 0)
        return;
      const Wt = Math.abs(hn), Ot = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      let K = Wt / H.value;
      const Y = ce(Wt, Ve);
      if (Y !== null && (K = Y), Dt && K >= 1 || !F.value && !z(ke.target, Ve))
        return;
      if ((Le = W?.value) == null || Le.$el.classList.add(Mm), F.value = !0, At((Ue = W.value) == null ? void 0 : Ue.$el, {
        transition: "none"
      }), At((We = M.value) == null ? void 0 : We.$el, {
        transition: "none"
      }), U.value && ye({ draggedDistance: hn }), Ve && !U.value) {
        const ge = o4(hn), Me = Math.min(ge * -1, 0) * on;
        At((it = W.value) == null ? void 0 : it.$el, {
          transform: _t(y.value) ? `translate3d(0, ${Me}px, 0)` : `translate3d(${Me}px, 0, 0)`
        });
        return;
      }
      const ue = 1 - K;
      if ((Ee.value || m.value && de.value === m.value - 1) && (t(K), At(
        (ut = M.value) == null ? void 0 : ut.$el,
        {
          opacity: `${ue}`,
          transition: "none"
        },
        !0
      )), Ot && M.value && d.value) {
        const ge = Math.min(te() + K * (1 - te()), 1), Me = 8 - K * 8, Oe = Math.max(0, 14 - K * 14);
        At(
          Ot,
          {
            borderRadius: `${Me}px`,
            transform: _t(y.value) ? `scale(${ge}) translate3d(0, ${Oe}px, 0)` : `scale(${ge}) translate3d(${Oe}px, 0, 0)`,
            transition: "none"
          },
          !0
        );
      }
      if (!U.value) {
        const ge = Wt * on;
        At(($t = W.value) == null ? void 0 : $t.$el, {
          transform: _t(y.value) ? `translate3d(0, ${ge}px, 0)` : `translate3d(${ge}px, 0, 0)`
        });
      }
    }
  }
  function L() {
    var ke;
    if (!W.value)
      return;
    const Le = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]"), Ue = Qs(W.value.$el, y.value);
    At(W.value.$el, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`
    }), At((ke = M.value) == null ? void 0 : ke.$el, {
      transition: `opacity ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`,
      opacity: "1"
    }), d.value && Ue && Ue > 0 && $.value && At(
      Le,
      {
        borderRadius: `${A_}px`,
        overflow: "hidden",
        ..._t(y.value) ? {
          transform: `scale(${te()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
          transformOrigin: "top"
        } : {
          transform: `scale(${te()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`,
          transformOrigin: "left"
        },
        transitionProperty: "transform, border-radius",
        transitionDuration: `${pt.DURATION}s`,
        transitionTimingFunction: `cubic-bezier(${pt.EASE.join(",")})`
      },
      !0
    );
  }
  function be(ke) {
    W.value && (a(), ke || ($.value = !1), window.setTimeout(() => {
      U.value && (v.value = U.value[0]);
    }, pt.DURATION * 1e3));
  }
  Te(() => {
    if (!$.value && d.value && e4) {
      const ke = setTimeout(() => {
        r4(document.body);
      }, 200);
      return () => clearTimeout(ke);
    }
  }), me(o, () => {
    $.value = o.value, o.value || be();
  });
  function xe(ke) {
    if (!B.value || !W.value)
      return;
    W.value.$el.classList.remove(Mm), F.value = !1, B.value = !1, D.value = /* @__PURE__ */ new Date();
    const Le = Qs(W.value.$el, y.value);
    if (!z(ke.target, !1) || !Le || Number.isNaN(Le) || E.value === null)
      return;
    const Ue = D.value.getTime() - E.value.getTime(), We = ne.value - (_t(y.value) ? ke.clientY : ke.clientX), it = Math.abs(We) / Ue;
    if (it > 0.05 && (P.value = !0, window.setTimeout(() => {
      P.value = !1;
    }, 200)), U.value) {
      const $t = y.value === "bottom" || y.value === "right" ? 1 : -1;
      fe({
        draggedDistance: We * $t,
        closeDrawer: be,
        velocity: it,
        dismissible: s.value
      }), n(!0);
      return;
    }
    if (y.value === "bottom" || y.value === "right" ? We > 0 : We < 0) {
      L(), n(!0);
      return;
    }
    if (it > q_) {
      be(), n(!1);
      return;
    }
    const ut = Math.min(
      W.value.$el.getBoundingClientRect().height ?? 0,
      window.innerHeight
    );
    if (Le >= ut * p.value) {
      be(), n(!1);
      return;
    }
    n(!0), L();
  }
  me($, (ke) => {
    ke && (q.value = /* @__PURE__ */ new Date()), r(ke);
  }, { immediate: !0 });
  function Ne(ke) {
    var Le, Ue;
    const We = ke ? (window.innerWidth - el) / window.innerWidth : 1, it = ke ? -16 : 0;
    J.value && window.clearTimeout(J.value), At((Le = W.value) == null ? void 0 : Le.$el, {
      transition: `transform ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`,
      transform: `scale(${We}) translate3d(0, ${it}px, 0)`
    }), !ke && (Ue = W.value) != null && Ue.$el && (J.value = window.setTimeout(() => {
      var ut, $t;
      const on = Qs((ut = W.value) == null ? void 0 : ut.$el, y.value);
      At(($t = W.value) == null ? void 0 : $t.$el, {
        transition: "none",
        transform: _t(y.value) ? `translate3d(0, ${on}px, 0)` : `translate3d(${on}px, 0, 0)`
      });
    }, 500));
  }
  function Xe(ke) {
    var Le;
    if (ke < 0)
      return;
    const Ue = _t(y.value) ? window.innerHeight : window.innerWidth, We = (Ue - el) / Ue, it = We + ke * (1 - We), ut = -16 + ke * el;
    At((Le = W.value) == null ? void 0 : Le.$el, {
      transform: _t(y.value) ? `scale(${it}) translate3d(0, ${ut}px, 0)` : `scale(${it}) translate3d(${ut}px, 0, 0)`,
      transition: "none"
    });
  }
  function lt(ke) {
    var Le;
    const Ue = _t(y.value) ? window.innerHeight : window.innerWidth, We = ke ? (Ue - el) / Ue : 1, it = ke ? -16 : 0;
    ke && At((Le = W.value) == null ? void 0 : Le.$el, {
      transition: `transform ${pt.DURATION}s cubic-bezier(${pt.EASE.join(",")})`,
      transform: _t(y.value) ? `scale(${We}) translate3d(0, ${it}px, 0)` : `scale(${We}) translate3d(${it}px, 0, 0)`
    });
  }
  return {
    open: o,
    isOpen: $,
    modal: u,
    keyboardIsOpen: Q,
    hasBeenOpened: k,
    drawerRef: W,
    drawerHeightRef: H,
    overlayRef: M,
    handleRef: ee,
    isDragging: B,
    dragStartTime: E,
    isAllowedToDrag: F,
    snapPoints: U,
    activeSnapPoint: v,
    hasSnapPoints: se,
    pointerStart: ne,
    dismissible: s,
    snapPointsOffset: _e,
    direction: y,
    shouldFade: Ee,
    fadeFromIndex: m,
    shouldScaleBackground: d,
    setBackgroundColorOnScale: c,
    onPress: re,
    onDrag: ie,
    onRelease: xe,
    closeDrawer: be,
    onNestedDrag: Xe,
    onNestedRelease: lt,
    onNestedOpenChange: Ne,
    emitClose: a,
    emitDrag: t,
    emitRelease: n,
    emitOpenChange: r,
    nested: i,
    handleOnly: C,
    noBodyStyles: x
  };
}
const p4 = /* @__PURE__ */ b({
  __name: "DrawerRoot",
  props: {
    activeSnapPoint: { default: void 0 },
    closeThreshold: { default: l4 },
    shouldScaleBackground: { type: Boolean, default: void 0 },
    setBackgroundColorOnScale: { type: Boolean, default: !0 },
    scrollLockTimeout: { default: i4 },
    fixed: { type: Boolean, default: void 0 },
    dismissible: { type: Boolean, default: !0 },
    modal: { type: Boolean, default: !0 },
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: void 0 },
    nested: { type: Boolean, default: !1 },
    direction: { default: "bottom" },
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean, default: !1 },
    preventScrollRestoration: { type: Boolean },
    snapPoints: { default: void 0 },
    fadeFromIndex: { default: void 0 }
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n;
    d0();
    const o = A(() => a.fadeFromIndex ?? (a.snapPoints && a.snapPoints.length - 1)), s = Pm(a, "open", r, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    }), i = Pm(a, "activeSnapPoint", r, {
      passive: a.activeSnapPoint === void 0
    }), u = {
      emitDrag: (m) => r("drag", m),
      emitRelease: (m) => r("release", m),
      emitClose: () => r("close"),
      emitOpenChange: (m) => {
        r("update:open", m), setTimeout(() => {
          r("animationEnd", m);
        }, pt.DURATION * 1e3);
      }
    }, { closeDrawer: d, hasBeenOpened: c, modal: f, isOpen: p } = a4(
      f4({
        ...u,
        ...qe(a),
        activeSnapPoint: i,
        fadeFromIndex: o,
        open: s
      })
    );
    function v(m) {
      if (s.value !== void 0) {
        u.emitOpenChange(m);
        return;
      }
      p.value = m, m ? c.value = !0 : d();
    }
    return t({
      open: p
    }), (m, y) => (h(), w(l(yi), {
      open: l(p),
      modal: l(f),
      "onUpdate:open": v
    }, {
      default: g(() => [
        _(m.$slots, "default", { open: l(p) })
      ]),
      _: 3
    }, 8, ["open", "modal"]));
  }
}), v4 = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  setup(e) {
    const { overlayRef: t, hasSnapPoints: n, isOpen: a, shouldFade: r } = Zf();
    return (o, s) => (h(), w(l(cs), {
      ref_key: "overlayRef",
      ref: t,
      "data-vaul-overlay": "",
      "data-vaul-snap-points": l(a) && l(n) ? "true" : "false",
      "data-vaul-snap-points-overlay": l(a) && l(r) ? "true" : "false"
    }, null, 8, ["data-vaul-snap-points", "data-vaul-snap-points-overlay"]));
  }
}), m4 = () => () => {
};
function h4() {
  const { direction: e, isOpen: t, shouldScaleBackground: n, setBackgroundColorOnScale: a, noBodyStyles: r } = Zf(), o = I(null), s = I(document.body.style.backgroundColor);
  function i() {
    return (window.innerWidth - E_) / window.innerWidth;
  }
  Te((u) => {
    if (t.value && n.value) {
      o.value && clearTimeout(o.value);
      const d = document.querySelector("[data-vaul-drawer-wrapper]") || document.querySelector("[vaul-drawer-wrapper]");
      if (!d)
        return;
      s4(
        a.value && !r.value ? Gu(document.body, { background: "black" }) : m4,
        Gu(d, {
          transformOrigin: _t(e.value) ? "top" : "left",
          transitionProperty: "transform, border-radius",
          transitionDuration: `${pt.DURATION}s`,
          transitionTimingFunction: `cubic-bezier(${pt.EASE.join(",")})`
        })
      );
      const c = Gu(d, {
        borderRadius: `${A_}px`,
        overflow: "hidden",
        ..._t(e.value) ? {
          transform: `scale(${i()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`
        } : {
          transform: `scale(${i()}) translate3d(calc(env(safe-area-inset-top) + 14px), 0, 0)`
        }
      });
      u(() => {
        c(), o.value = window.setTimeout(() => {
          s.value ? document.body.style.background = s.value : document.body.style.removeProperty("background");
        }, pt.DURATION * 1e3);
      });
    }
  }, { flush: "pre" });
}
const g4 = /* @__PURE__ */ b({
  __name: "DrawerContent",
  setup(e) {
    const {
      open: t,
      isOpen: n,
      snapPointsOffset: a,
      hasSnapPoints: r,
      drawerRef: o,
      onPress: s,
      onDrag: i,
      onRelease: u,
      modal: d,
      emitOpenChange: c,
      dismissible: f,
      keyboardIsOpen: p,
      closeDrawer: v,
      direction: m,
      handleOnly: y
    } = Zf();
    h4();
    const x = I(!1), C = A(() => a.value && a.value.length > 0 ? `${a.value[0]}px` : "0");
    function S(B) {
      if (!d.value || B.defaultPrevented) {
        B.preventDefault();
        return;
      }
      p.value && (p.value = !1), f.value ? c(!1) : B.preventDefault();
    }
    function $(B) {
      y.value || s(B);
    }
    function k(B) {
      y.value || i(B);
    }
    return Te(() => {
      r.value && window.requestAnimationFrame(() => {
        x.value = !0;
      });
    }), (B, P) => (h(), w(l(ds), {
      ref_key: "drawerRef",
      ref: o,
      "data-vaul-drawer": "",
      "data-vaul-drawer-direction": l(m),
      "data-vaul-delayed-snap-points": x.value ? "true" : "false",
      "data-vaul-snap-points": l(n) && l(r) ? "true" : "false",
      style: dt({ "--snap-point-height": C.value }),
      onPointerdown: $,
      onPointermove: k,
      onPointerup: l(u),
      onPointerDownOutside: S,
      onOpenAutoFocus: P[0] || (P[0] = Ye(() => {
      }, ["prevent"])),
      onEscapeKeyDown: P[1] || (P[1] = (M) => {
        l(f) || M.preventDefault();
      })
    }, {
      default: g(() => [
        _(B.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-vaul-drawer-direction", "data-vaul-delayed-snap-points", "data-vaul-snap-points", "style", "onPointerup"]));
  }
}), K7 = /* @__PURE__ */ b({
  __name: "Drawer",
  props: {
    activeSnapPoint: {},
    closeThreshold: {},
    shouldScaleBackground: { type: Boolean, default: !0 },
    setBackgroundColorOnScale: { type: Boolean },
    scrollLockTimeout: {},
    fixed: { type: Boolean },
    dismissible: { type: Boolean },
    modal: { type: Boolean },
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    nested: { type: Boolean },
    direction: {},
    noBodyStyles: { type: Boolean },
    handleOnly: { type: Boolean },
    preventScrollRestoration: { type: Boolean },
    snapPoints: {},
    fadeFromIndex: {}
  },
  emits: ["drag", "release", "close", "update:open", "update:activeSnapPoint", "animationEnd"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(p4), T({ "data-slot": "drawer" }, l(r)), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Y7 = /* @__PURE__ */ b({
  __name: "DrawerClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ia), T({ "data-slot": "drawer-close" }, t), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), y4 = /* @__PURE__ */ b({
  __name: "DrawerOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(v4), T({ "data-slot": "drawer-overlay" }, l(n), {
      class: l(R)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), X7 = /* @__PURE__ */ b({
  __name: "DrawerContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, r = ve(n, t);
    return (o, s) => (h(), w(l(_i), null, {
      default: g(() => [
        N(y4),
        N(l(g4), T({ "data-slot": "drawer-content" }, l(r), {
          class: l(R)(
            "group/drawer-content fixed z-50 flex h-auto flex-col bg-background",
            "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg",
            "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg",
            "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm",
            "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm",
            n.class
          )
        }), {
          default: g(() => [
            s[0] || (s[0] = we("div", { class: "mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full bg-muted group-data-[vaul-drawer-direction=bottom]/drawer-content:block" }, null, -1)),
            _(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), J7 = /* @__PURE__ */ b({
  __name: "DrawerDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(bi), T({ "data-slot": "drawer-description" }, l(n), {
      class: l(R)("text-sm text-muted-foreground", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Z7 = /* @__PURE__ */ b({
  __name: "DrawerFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "drawer-footer",
      class: ae(l(R)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Q7 = /* @__PURE__ */ b({
  __name: "DrawerHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "drawer-header",
      class: ae(l(R)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), e9 = /* @__PURE__ */ b({
  __name: "DrawerTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(wi), T({ "data-slot": "drawer-title" }, l(n), {
      class: l(R)("font-semibold text-foreground", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), t9 = /* @__PURE__ */ b({
  __name: "DrawerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(xi), T({ "data-slot": "drawer-trigger" }, t), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), n9 = /* @__PURE__ */ b({
  __name: "DropdownMenu",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    dir: {},
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(rP), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), b4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, a9 = /* @__PURE__ */ b({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(tP), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: g(() => [
        we("span", b4, [
          N(l(xg), null, {
            default: g(() => [
              N(l(to), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), r9 = /* @__PURE__ */ b({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(mP), null, {
      default: g(() => [
        N(l(sP), T(l(o), {
          class: l(R)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: g(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), o9 = /* @__PURE__ */ b({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(iP), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), s9 = /* @__PURE__ */ b({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(dP), T(l(a), {
      class: l(R)(
        "relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), l9 = /* @__PURE__ */ b({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(pP), T(l(a), {
      class: l(R)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), i9 = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(gP), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _4 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, u9 = /* @__PURE__ */ b({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(bP), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm transition-colors outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: g(() => [
        we("span", _4, [
          N(l(xg), null, {
            default: g(() => [
              N(l(uf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), d9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(wP), T(l(n), {
      class: l(R)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), c9 = /* @__PURE__ */ b({
  __name: "DropdownMenuShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest opacity-60", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), f9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(CP), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), p9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l($P), T(l(o), {
      class: l(R)(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), v9 = /* @__PURE__ */ b({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(kP), T(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent data-[state=open]:bg-accent",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default"),
        N(l(Fa), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), m9 = /* @__PURE__ */ b({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), w(l(MP), T({ class: "outline-none" }, l(n)), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), h9 = /* @__PURE__ */ b({
  __name: "Empty",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty",
      class: ae(
        l(R)(
          "flex min-w-0 flex-1 flex-col items-center justify-center gap-6 rounded-lg border-dashed p-6 text-center text-balance md:p-12",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), g9 = /* @__PURE__ */ b({
  __name: "EmptyContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-content",
      class: ae(
        l(R)(
          "flex w-full max-w-sm min-w-0 flex-col items-center gap-4 text-sm text-balance",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), y9 = /* @__PURE__ */ b({
  __name: "EmptyDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      "data-slot": "empty-description",
      class: ae(
        l(R)(
          "text-sm/relaxed text-muted-foreground [&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), b9 = /* @__PURE__ */ b({
  __name: "EmptyHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-header",
      class: ae(l(R)("flex max-w-sm flex-col items-center gap-2 text-center", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), w4 = ["data-variant"], _9 = /* @__PURE__ */ b({
  __name: "EmptyMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-icon",
      "data-variant": e.variant,
      class: ae(l(R)(l(x4)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, w4));
  }
}), w9 = /* @__PURE__ */ b({
  __name: "EmptyTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "empty-title",
      class: ae(l(R)("text-lg font-medium tracking-tight", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), x4 = an(
  "mb-2 flex shrink-0 items-center justify-center [&_svg]:pointer-events-none [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground [&_svg:not([class*='size-'])]:size-6"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), C4 = ["data-orientation"], x9 = /* @__PURE__ */ b({
  __name: "Field",
  props: {
    class: {},
    orientation: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      role: "group",
      "data-slot": "field",
      "data-orientation": e.orientation,
      class: ae(l(R)(l(P4)({ orientation: e.orientation }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, C4));
  }
}), C9 = /* @__PURE__ */ b({
  __name: "FieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-content",
      class: ae(l(R)("group/field-content flex flex-1 flex-col gap-1.5 leading-snug", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), S9 = /* @__PURE__ */ b({
  __name: "FieldDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      "data-slot": "field-description",
      class: ae(
        l(R)(
          "text-sm leading-normal font-normal text-muted-foreground group-has-[[data-orientation=horizontal]]/field:text-balance",
          "last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), S4 = {
  key: 2,
  class: "ml-4 flex list-disc flex-col gap-1"
}, $9 = /* @__PURE__ */ b({
  __name: "FieldError",
  props: {
    class: {},
    errors: {}
  },
  setup(e) {
    const t = e, n = A(() => !t.errors || t.errors.length === 0 ? null : t.errors.length === 1 && t.errors[0]?.message ? t.errors[0].message : t.errors.some((a) => a?.message) ? t.errors : null);
    return (a, r) => a.$slots.default || n.value ? (h(), G("div", {
      key: 0,
      role: "alert",
      "data-slot": "field-error",
      class: ae(l(R)("text-sm font-normal text-destructive", t.class))
    }, [
      a.$slots.default ? _(a.$slots, "default", { key: 0 }) : typeof n.value == "string" ? (h(), G(Ge, { key: 1 }, [
        Re(Fe(n.value), 1)
      ], 64)) : Array.isArray(n.value) ? (h(), G("ul", S4, [
        (h(!0), G(Ge, null, Et(n.value, (o, s) => (h(), G("li", { key: s }, Fe(o?.message), 1))), 128))
      ])) : De("", !0)
    ], 2)) : De("", !0);
  }
}), B9 = /* @__PURE__ */ b({
  __name: "FieldGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-group",
      class: ae(
        l(R)(
          "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), T_ = /* @__PURE__ */ b({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(HP), T(l(n), {
      class: l(R)(
        "text-sm leading-none font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        t.class
      )
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), k9 = /* @__PURE__ */ b({
  __name: "FieldLabel",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(T_), {
      "data-slot": "field-label",
      class: ae(
        l(R)(
          "group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50",
          "has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&_>[data-slot=field]]:p-3",
          "has-[[data-state=checked]]:border-primary has-[[data-state=checked]]:bg-primary/5 dark:has-[[data-state=checked]]:bg-primary/10",
          t.class
        )
      )
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), $4 = ["data-variant"], P9 = /* @__PURE__ */ b({
  __name: "FieldLegend",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("legend", {
      "data-slot": "field-legend",
      "data-variant": e.variant,
      class: ae(
        l(R)(
          "mb-3 font-medium",
          "data-[variant=legend]:text-base",
          "data-[variant=label]:text-sm",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 10, $4));
  }
}), B4 = ["data-content"], k4 = {
  key: 0,
  class: "relative mx-auto block w-fit bg-background px-2 text-muted-foreground",
  "data-slot": "field-separator-content"
}, M9 = /* @__PURE__ */ b({
  __name: "FieldSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-separator",
      "data-content": !!n.$slots.default,
      class: ae(
        l(R)("relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2", t.class)
      )
    }, [
      N(l(Hi), { class: "absolute inset-0 top-1/2" }),
      n.$slots.default ? (h(), G("span", k4, [
        _(n.$slots, "default")
      ])) : De("", !0)
    ], 10, B4));
  }
}), D9 = /* @__PURE__ */ b({
  __name: "FieldSet",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("fieldset", {
      "data-slot": "field-set",
      class: ae(
        l(R)(
          "flex flex-col gap-6",
          "has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), q9 = /* @__PURE__ */ b({
  __name: "FieldTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "field-label",
      class: ae(
        l(R)(
          "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), P4 = an(
  "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
  {
    variants: {
      orientation: {
        vertical: ["flex-col [&>*]:w-full [&>.sr-only]:w-auto"],
        horizontal: [
          "flex-row items-center",
          "[&>[data-slot=field-label]]:flex-auto",
          "has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px has-[>[data-slot=field-content]]:items-start"
        ],
        responsive: [
          "@md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto flex-col [&>*]:w-full [&>.sr-only]:w-auto",
          "@md/field-group:[&>[data-slot=field-label]]:flex-auto",
          "@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
        ]
      }
    },
    defaultVariants: {
      orientation: "vertical"
    }
  }
);
function Nt(e) {
  return typeof e == "function";
}
function Cr(e) {
  return e == null;
}
const ar = (e) => e !== null && !!e && typeof e == "object" && !Array.isArray(e);
function Qf(e) {
  return Number(e) >= 0;
}
function M4(e) {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}
function D4(e) {
  return typeof e == "object" && e !== null;
}
function q4(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
function qm(e) {
  if (!D4(e) || q4(e) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(e) === null)
    return !0;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function Qo(e, t) {
  return Object.keys(t).forEach((n) => {
    if (qm(t[n]) && qm(e[n])) {
      e[n] || (e[n] = {}), Qo(e[n], t[n]);
      return;
    }
    e[n] = t[n];
  }), e;
}
function ko(e) {
  const t = e.split(".");
  if (!t.length)
    return "";
  let n = String(t[0]);
  for (let a = 1; a < t.length; a++) {
    if (Qf(t[a])) {
      n += `[${t[a]}]`;
      continue;
    }
    n += `.${t[a]}`;
  }
  return n;
}
const A4 = {};
function E4(e) {
  return A4[e];
}
function Am(e, t, n) {
  typeof n.value == "object" && (n.value = je(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || t === "__proto__" ? Object.defineProperty(e, t, n) : e[t] = n.value;
}
function je(e) {
  if (typeof e != "object") return e;
  var t = 0, n, a, r, o = Object.prototype.toString.call(e);
  if (o === "[object Object]" ? r = Object.create(e.__proto__ || null) : o === "[object Array]" ? r = Array(e.length) : o === "[object Set]" ? (r = /* @__PURE__ */ new Set(), e.forEach(function(s) {
    r.add(je(s));
  })) : o === "[object Map]" ? (r = /* @__PURE__ */ new Map(), e.forEach(function(s, i) {
    r.set(je(i), je(s));
  })) : o === "[object Date]" ? r = /* @__PURE__ */ new Date(+e) : o === "[object RegExp]" ? r = new RegExp(e.source, e.flags) : o === "[object DataView]" ? r = new e.constructor(je(e.buffer)) : o === "[object ArrayBuffer]" ? r = e.slice(0) : o.slice(-6) === "Array]" && (r = new e.constructor(e)), r) {
    for (a = Object.getOwnPropertySymbols(e); t < a.length; t++)
      Am(r, a[t], Object.getOwnPropertyDescriptor(e, a[t]));
    for (t = 0, a = Object.getOwnPropertyNames(e); t < a.length; t++)
      Object.hasOwnProperty.call(r, n = a[t]) && r[n] === e[n] || Am(r, n, Object.getOwnPropertyDescriptor(e, n));
  }
  return r || e;
}
const Ds = /* @__PURE__ */ Symbol("vee-validate-form"), T4 = /* @__PURE__ */ Symbol("vee-validate-form-context"), I_ = /* @__PURE__ */ Symbol("vee-validate-field-instance"), li = /* @__PURE__ */ Symbol("Default empty value"), I4 = typeof window < "u";
function Yd(e) {
  return Nt(e) && !!e.__locatorRef;
}
function kn(e) {
  return !!e && Nt(e.parse) && e.__type === "VVTypedSchema";
}
function ii(e) {
  return !!e && Nt(e.validate);
}
function qs(e) {
  return e === "checkbox" || e === "radio";
}
function O4(e) {
  return ar(e) || Array.isArray(e);
}
function R4(e) {
  return Array.isArray(e) ? e.length === 0 : ar(e) && Object.keys(e).length === 0;
}
function su(e) {
  return /^\[.+\]$/i.test(e);
}
function V4(e) {
  return O_(e) && e.multiple;
}
function O_(e) {
  return e.tagName === "SELECT";
}
function F4(e, t) {
  const n = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
  return e === "select" && "multiple" in t && n;
}
function N4(e, t) {
  return !F4(e, t) && t.type !== "file" && !qs(t.type);
}
function R_(e) {
  return ep(e) && e.target && "submit" in e.target;
}
function ep(e) {
  return e ? !!(typeof Event < "u" && Nt(Event) && e instanceof Event || e && e.srcElement) : !1;
}
function Em(e, t) {
  return t in e && e[t] !== li;
}
function Tt(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    var n, a, r;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (!Tt(e[a], t[a]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      for (a of e.entries())
        if (!Tt(a[1], t.get(a[0])))
          return !1;
      return !0;
    }
    if (Im(e) && Im(t))
      return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (a of e.entries())
        if (!t.has(a[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (a = n; a-- !== 0; )
        if (e[a] !== t[a])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    if (e = Tm(e), t = Tm(t), r = Object.keys(e), n = r.length, n !== Object.keys(t).length)
      return !1;
    for (a = n; a-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, r[a]))
        return !1;
    for (a = n; a-- !== 0; ) {
      var o = r[a];
      if (!Tt(e[o], t[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Tm(e) {
  return Object.fromEntries(Object.entries(e).filter(([, t]) => t !== void 0));
}
function Im(e) {
  return I4 ? e instanceof File : !1;
}
function tp(e) {
  return su(e) ? e.replace(/\[|\]/gi, "") : e;
}
function vt(e, t, n) {
  return e ? su(t) ? e[tp(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((r, o) => O4(r) && o in r ? r[o] : n, e) : n;
}
function Vt(e, t, n) {
  if (su(t)) {
    e[tp(t)] = n;
    return;
  }
  const a = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let r = e;
  for (let o = 0; o < a.length; o++) {
    if (o === a.length - 1) {
      r[a[o]] = n;
      return;
    }
    (!(a[o] in r) || Cr(r[a[o]])) && (r[a[o]] = Qf(a[o + 1]) ? [] : {}), r = r[a[o]];
  }
}
function Ku(e, t) {
  if (Array.isArray(e) && Qf(t)) {
    e.splice(Number(t), 1);
    return;
  }
  ar(e) && delete e[t];
}
function Om(e, t) {
  if (su(t)) {
    delete e[tp(t)];
    return;
  }
  const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
  let a = e;
  for (let o = 0; o < n.length; o++) {
    if (o === n.length - 1) {
      Ku(a, n[o]);
      break;
    }
    if (!(n[o] in a) || Cr(a[n[o]]))
      break;
    a = a[n[o]];
  }
  const r = n.map((o, s) => vt(e, n.slice(0, s).join(".")));
  for (let o = r.length - 1; o >= 0; o--)
    if (R4(r[o])) {
      if (o === 0) {
        Ku(e, n[0]);
        continue;
      }
      Ku(r[o - 1], n[o - 1]);
    }
}
function ln(e) {
  return Object.keys(e);
}
function np(e, t = void 0) {
  const n = zt();
  return n?.provides[e] || xn(e, t);
}
function Rm(e, t, n) {
  if (Array.isArray(e)) {
    const a = [...e], r = a.findIndex((o) => Tt(o, t));
    return r >= 0 ? a.splice(r, 1) : a.push(t), a;
  }
  return Tt(e, t) ? n : t;
}
function Vm(e, t = 0) {
  let n = null, a = [];
  return function(...r) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const o = e(...r);
      a.forEach((s) => s(o)), a = [];
    }, t), new Promise((o) => a.push(o));
  };
}
function L4(e, t) {
  return ar(t) && t.number ? M4(e) : e;
}
function Xd(e, t) {
  let n;
  return async function(...r) {
    const o = e(...r);
    n = o;
    const s = await o;
    return o !== n ? s : (n = void 0, t(s, r));
  };
}
function z4({ get: e, set: t }) {
  const n = I(je(e()));
  return me(e, (a) => {
    Tt(a, n.value) || (n.value = je(a));
  }, {
    deep: !0
  }), me(n, (a) => {
    Tt(a, e()) || t(je(a));
  }, {
    deep: !0
  }), n;
}
function Jd(e) {
  return Array.isArray(e) ? e : e ? [e] : [];
}
function tl(e, t) {
  const n = {};
  for (const a in e)
    t.includes(a) || (n[a] = e[a]);
  return n;
}
function H4(e) {
  let t = null, n = [];
  return function(...a) {
    const r = Pe(() => {
      if (t !== r)
        return;
      const o = e(...a);
      n.forEach((s) => s(o)), n = [], t = null;
    });
    return t = r, new Promise((o) => n.push(o));
  };
}
function lu(e, t, n) {
  return t.slots.default ? typeof e == "string" || !e ? t.slots.default(n()) : {
    default: () => {
      var a, r;
      return (r = (a = t.slots).default) === null || r === void 0 ? void 0 : r.call(a, n());
    }
  } : t.slots.default;
}
function Yu(e) {
  if (V_(e))
    return e._value;
}
function V_(e) {
  return "_value" in e;
}
function U4(e) {
  return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value;
}
function ui(e) {
  if (!ep(e))
    return e;
  const t = e.target;
  if (qs(t.type) && V_(t))
    return Yu(t);
  if (t.type === "file" && t.files) {
    const n = Array.from(t.files);
    return t.multiple ? n : n[0];
  }
  if (V4(t))
    return Array.from(t.options).filter((n) => n.selected && !n.disabled).map(Yu);
  if (O_(t)) {
    const n = Array.from(t.options).find((a) => a.selected);
    return n ? Yu(n) : t.value;
  }
  return U4(t);
}
function F_(e) {
  const t = {};
  return Object.defineProperty(t, "_$$isNormalized", {
    value: !0,
    writable: !1,
    enumerable: !1,
    configurable: !1
  }), e ? ar(e) && e._$$isNormalized ? e : ar(e) ? Object.keys(e).reduce((n, a) => {
    const r = j4(e[a]);
    return e[a] !== !1 && (n[a] = Fm(r)), n;
  }, t) : typeof e != "string" ? t : e.split("|").reduce((n, a) => {
    const r = W4(a);
    return r.name && (n[r.name] = Fm(r.params)), n;
  }, t) : t;
}
function j4(e) {
  return e === !0 ? [] : Array.isArray(e) || ar(e) ? e : [e];
}
function Fm(e) {
  const t = (n) => typeof n == "string" && n[0] === "@" ? G4(n.slice(1)) : n;
  return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((n, a) => (n[a] = t(e[a]), n), {});
}
const W4 = (e) => {
  let t = [];
  const n = e.split(":")[0];
  return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), { name: n, params: t };
};
function G4(e) {
  const t = (n) => {
    var a;
    return (a = vt(n, e)) !== null && a !== void 0 ? a : n[e];
  };
  return t.__locatorRef = e, t;
}
function K4(e) {
  return Array.isArray(e) ? e.filter(Yd) : ln(e).filter((t) => Yd(e[t])).map((t) => e[t]);
}
const Y4 = {
  generateMessage: ({ field: e }) => `${e} is not valid.`,
  bails: !0,
  validateOnBlur: !0,
  validateOnChange: !0,
  validateOnInput: !1,
  validateOnModelUpdate: !0
};
let X4 = Object.assign({}, Y4);
const Ya = () => X4;
async function N_(e, t, n = {}) {
  const a = n?.bails, r = {
    name: n?.name || "{field}",
    rules: t,
    label: n?.label,
    bails: a ?? !0,
    formData: n?.values || {}
  }, o = await J4(r, e);
  return Object.assign(Object.assign({}, o), { valid: !o.errors.length });
}
async function J4(e, t) {
  const n = e.rules;
  if (kn(n) || ii(n))
    return Q4(t, Object.assign(Object.assign({}, e), { rules: n }));
  if (Nt(n) || Array.isArray(n)) {
    const i = {
      field: e.label || e.name,
      name: e.name,
      label: e.label,
      form: e.formData,
      value: t
    }, u = Array.isArray(n) ? n : [n], d = u.length, c = [];
    for (let f = 0; f < d; f++) {
      const p = u[f], v = await p(t, i);
      if (!(typeof v != "string" && !Array.isArray(v) && v)) {
        if (Array.isArray(v))
          c.push(...v);
        else {
          const y = typeof v == "string" ? v : z_(i);
          c.push(y);
        }
        if (e.bails)
          return {
            errors: c
          };
      }
    }
    return {
      errors: c
    };
  }
  const a = Object.assign(Object.assign({}, e), { rules: F_(n) }), r = [], o = Object.keys(a.rules), s = o.length;
  for (let i = 0; i < s; i++) {
    const u = o[i], d = await ez(a, t, {
      name: u,
      params: a.rules[u]
    });
    if (d.error && (r.push(d.error), e.bails))
      return {
        errors: r
      };
  }
  return {
    errors: r
  };
}
function Z4(e) {
  return !!e && e.name === "ValidationError";
}
function L_(e) {
  return {
    __type: "VVTypedSchema",
    async parse(n, a) {
      var r;
      try {
        return {
          output: await e.validate(n, { abortEarly: !1, context: a?.formData || {} }),
          errors: []
        };
      } catch (o) {
        if (!Z4(o))
          throw o;
        if (!(!((r = o.inner) === null || r === void 0) && r.length) && o.errors.length)
          return { errors: [{ path: o.path, errors: o.errors }] };
        const s = o.inner.reduce((i, u) => {
          const d = u.path || "";
          return i[d] || (i[d] = { errors: [], path: d }), i[d].errors.push(...u.errors), i;
        }, {});
        return { errors: Object.values(s) };
      }
    }
  };
}
async function Q4(e, t) {
  const a = await (kn(t.rules) ? t.rules : L_(t.rules)).parse(e, { formData: t.formData }), r = [];
  for (const o of a.errors)
    o.errors.length && r.push(...o.errors);
  return {
    value: a.value,
    errors: r
  };
}
async function ez(e, t, n) {
  const a = E4(n.name);
  if (!a)
    throw new Error(`No such validator '${n.name}' exists.`);
  const r = tz(n.params, e.formData), o = {
    field: e.label || e.name,
    name: e.name,
    label: e.label,
    value: t,
    form: e.formData,
    rule: Object.assign(Object.assign({}, n), { params: r })
  }, s = await a(t, r, o);
  return typeof s == "string" ? {
    error: s
  } : {
    error: s ? void 0 : z_(o)
  };
}
function z_(e) {
  const t = Ya().generateMessage;
  return t ? t(e) : "Field is invalid";
}
function tz(e, t) {
  const n = (a) => Yd(a) ? a(t) : a;
  return Array.isArray(e) ? e.map(n) : Object.keys(e).reduce((a, r) => (a[r] = n(e[r]), a), {});
}
async function nz(e, t) {
  const a = await (kn(e) ? e : L_(e)).parse(je(t), { formData: je(t) }), r = {}, o = {};
  for (const s of a.errors) {
    const i = s.errors, u = (s.path || "").replace(/\["(\d+)"\]/g, (d, c) => `[${c}]`);
    r[u] = { valid: !i.length, errors: i }, i.length && (o[u] = i[0]);
  }
  return {
    valid: !a.errors.length,
    results: r,
    errors: o,
    values: a.value,
    source: "schema"
  };
}
async function az(e, t, n) {
  const r = ln(e).map(async (d) => {
    var c, f, p;
    const v = (c = n?.names) === null || c === void 0 ? void 0 : c[d], m = await N_(vt(t, d), e[d], {
      name: v?.name || d,
      label: v?.label,
      values: t,
      bails: (p = (f = n?.bailsMap) === null || f === void 0 ? void 0 : f[d]) !== null && p !== void 0 ? p : !0
    });
    return Object.assign(Object.assign({}, m), { path: d });
  });
  let o = !0;
  const s = await Promise.all(r), i = {}, u = {};
  for (const d of s)
    i[d.path] = {
      valid: d.valid,
      errors: d.errors
    }, d.valid || (o = !1, u[d.path] = d.errors[0]);
  return {
    valid: o,
    results: i,
    errors: u,
    source: "schema"
  };
}
let Nm = 0;
function rz(e, t) {
  const { value: n, initialValue: a, setInitialValue: r } = oz(e, t.modelValue, t.form);
  if (!t.form) {
    let u = function(v) {
      var m;
      "value" in v && (n.value = v.value), "errors" in v && c(v.errors), "touched" in v && (p.touched = (m = v.touched) !== null && m !== void 0 ? m : p.touched), "initialValue" in v && r(v.initialValue);
    };
    const { errors: d, setErrors: c } = iz(), f = Nm >= Number.MAX_SAFE_INTEGER ? 0 : ++Nm, p = lz(n, a, d, t.schema);
    return {
      id: f,
      path: e,
      value: n,
      initialValue: a,
      meta: p,
      flags: { pendingUnmount: { [f]: !1 }, pendingReset: !1 },
      errors: d,
      setState: u
    };
  }
  const o = t.form.createPathState(e, {
    bails: t.bails,
    label: t.label,
    type: t.type,
    validate: t.validate,
    schema: t.schema
  }), s = A(() => o.errors);
  function i(u) {
    var d, c, f;
    "value" in u && (n.value = u.value), "errors" in u && ((d = t.form) === null || d === void 0 || d.setFieldError(l(e), u.errors)), "touched" in u && ((c = t.form) === null || c === void 0 || c.setFieldTouched(l(e), (f = u.touched) !== null && f !== void 0 ? f : !1)), "initialValue" in u && r(u.initialValue);
  }
  return {
    id: Array.isArray(o.id) ? o.id[o.id.length - 1] : o.id,
    path: e,
    value: n,
    errors: s,
    meta: o,
    initialValue: a,
    flags: o.__flags,
    setState: i
  };
}
function oz(e, t, n) {
  const a = I(l(t));
  function r() {
    return n ? vt(n.initialValues.value, l(e), l(a)) : l(a);
  }
  function o(d) {
    if (!n) {
      a.value = d;
      return;
    }
    n.setFieldInitialValue(l(e), d, !0);
  }
  const s = A(r);
  if (!n)
    return {
      value: I(r()),
      initialValue: s,
      setInitialValue: o
    };
  const i = sz(t, n, s, e);
  return n.stageInitialValue(l(e), i, !0), {
    value: A({
      get() {
        return vt(n.values, l(e));
      },
      set(d) {
        n.setFieldValue(l(e), d, !1);
      }
    }),
    initialValue: s,
    setInitialValue: o
  };
}
function sz(e, t, n, a) {
  return Ct(e) ? l(e) : e !== void 0 ? e : vt(t.values, l(a), l(n));
}
function lz(e, t, n, a) {
  const r = A(() => {
    var s, i, u;
    return (u = (i = (s = pe(a)) === null || s === void 0 ? void 0 : s.describe) === null || i === void 0 ? void 0 : i.call(s).required) !== null && u !== void 0 ? u : !1;
  }), o = pn({
    touched: !1,
    pending: !1,
    valid: !0,
    required: r,
    validated: !!l(n).length,
    initialValue: A(() => l(t)),
    dirty: A(() => !Tt(l(e), l(t)))
  });
  return me(n, (s) => {
    o.valid = !s.length;
  }, {
    immediate: !0,
    flush: "sync"
  }), o;
}
function iz() {
  const e = I([]);
  return {
    errors: e,
    setErrors: (t) => {
      e.value = Jd(t);
    }
  };
}
function uz(e, t, n) {
  return qs(n?.type) ? cz(e, t, n) : H_(e, t, n);
}
function H_(e, t, n) {
  const { initialValue: a, validateOnMount: r, bails: o, type: s, checkedValue: i, label: u, validateOnValueUpdate: d, uncheckedValue: c, controlled: f, keepValueOnUnmount: p, syncVModel: v, form: m } = dz(n), y = f ? np(Ds) : void 0, x = m || y, C = A(() => ko(pe(e))), S = A(() => {
    if (pe(x?.schema))
      return;
    const V = l(t);
    return ii(V) || kn(V) || Nt(V) || Array.isArray(V) ? V : F_(V);
  }), $ = !Nt(S.value) && kn(pe(t)), { id: k, value: B, initialValue: P, meta: M, setState: q, errors: E, flags: D } = rz(C, {
    modelValue: a,
    form: x,
    bails: o,
    label: u,
    type: s,
    validate: S.value ? W : void 0,
    schema: $ ? t : void 0
  }), O = A(() => E.value[0]);
  v && fz({
    value: B,
    prop: v,
    handleChange: H,
    shouldValidate: () => d && !D.pendingReset
  });
  const F = (ce, V = !1) => {
    M.touched = !0, V && ne();
  };
  async function J(ce) {
    var V, te;
    if (x?.validateSchema) {
      const { results: z } = await x.validateSchema(ce);
      return (V = z[pe(C)]) !== null && V !== void 0 ? V : { valid: !0, errors: [] };
    }
    return S.value ? N_(B.value, S.value, {
      name: pe(C),
      label: pe(u),
      values: (te = x?.values) !== null && te !== void 0 ? te : {},
      bails: o
    }) : { valid: !0, errors: [] };
  }
  const ne = Xd(async () => (M.pending = !0, M.validated = !0, J("validated-only")), (ce) => (D.pendingUnmount[ye.id] || (q({ errors: ce.errors }), M.pending = !1, M.valid = ce.valid), ce)), Q = Xd(async () => J("silent"), (ce) => (M.valid = ce.valid, ce));
  function W(ce) {
    return ce?.mode === "silent" ? Q() : ne();
  }
  function H(ce, V = !0) {
    const te = ui(ce);
    de(te, V);
  }
  Ce(() => {
    if (r)
      return ne();
    (!x || !x.validateSchema) && Q();
  });
  function U(ce) {
    M.touched = ce;
  }
  function se(ce) {
    var V;
    const te = ce && "value" in ce ? ce.value : P.value;
    q({
      value: je(te),
      initialValue: je(te),
      touched: (V = ce?.touched) !== null && V !== void 0 ? V : !1,
      errors: ce?.errors || []
    }), M.pending = !1, M.validated = !1, Q();
  }
  const ee = zt();
  function de(ce, V = !0) {
    B.value = ee && v ? L4(ce, ee.props.modelModifiers) : ce, (V ? ne : Q)();
  }
  function fe(ce) {
    q({ errors: Array.isArray(ce) ? ce : [ce] });
  }
  const _e = A({
    get() {
      return B.value;
    },
    set(ce) {
      de(ce, d);
    }
  }), ye = {
    id: k,
    name: C,
    label: u,
    value: _e,
    meta: M,
    errors: E,
    errorMessage: O,
    type: s,
    checkedValue: i,
    uncheckedValue: c,
    bails: o,
    keepValueOnUnmount: p,
    resetField: se,
    handleReset: () => se(),
    validate: W,
    handleChange: H,
    handleBlur: F,
    setState: q,
    setTouched: U,
    setErrors: fe,
    setValue: de
  };
  if (Kn(I_, ye), Ct(t) && typeof l(t) != "function" && me(t, (ce, V) => {
    Tt(ce, V) || (M.validated ? ne() : Q());
  }, {
    deep: !0
  }), !x)
    return ye;
  const Ee = A(() => {
    const ce = S.value;
    return !ce || Nt(ce) || ii(ce) || kn(ce) || Array.isArray(ce) ? {} : Object.keys(ce).reduce((V, te) => {
      const z = K4(ce[te]).map((re) => re.__locatorRef).reduce((re, ie) => {
        const L = vt(x.values, ie) || x.values[ie];
        return L !== void 0 && (re[ie] = L), re;
      }, {});
      return Object.assign(V, z), V;
    }, {});
  });
  return me(Ee, (ce, V) => {
    if (!Object.keys(ce).length)
      return;
    !Tt(ce, V) && (M.validated ? ne() : Q());
  }), Ea(() => {
    var ce;
    const V = (ce = pe(ye.keepValueOnUnmount)) !== null && ce !== void 0 ? ce : pe(x.keepValuesOnUnmount), te = pe(C);
    if (V || !x || D.pendingUnmount[ye.id]) {
      x?.removePathState(te, k);
      return;
    }
    D.pendingUnmount[ye.id] = !0;
    const z = x.getPathState(te);
    if (Array.isArray(z?.id) && z?.multiple ? z?.id.includes(ye.id) : z?.id === ye.id) {
      if (z?.multiple && Array.isArray(z.value)) {
        const ie = z.value.findIndex((L) => Tt(L, pe(ye.checkedValue)));
        if (ie > -1) {
          const L = [...z.value];
          L.splice(ie, 1), x.setFieldValue(te, L);
        }
        Array.isArray(z.id) && z.id.splice(z.id.indexOf(ye.id), 1);
      } else
        x.unsetPathValue(pe(C));
      x.removePathState(te, k);
    }
  }), ye;
}
function dz(e) {
  const t = () => ({
    initialValue: void 0,
    validateOnMount: !1,
    bails: !0,
    label: void 0,
    validateOnValueUpdate: !0,
    keepValueOnUnmount: void 0,
    syncVModel: !1,
    controlled: !0
  }), n = !!e?.syncVModel, a = typeof e?.syncVModel == "string" ? e.syncVModel : e?.modelPropName || "modelValue", r = n && !("initialValue" in (e || {})) ? Zd(zt(), a) : e?.initialValue;
  if (!e)
    return Object.assign(Object.assign({}, t()), { initialValue: r });
  const o = "valueProp" in e ? e.valueProp : e.checkedValue, s = "standalone" in e ? !e.standalone : e.controlled, i = e?.modelPropName || e?.syncVModel || !1;
  return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
    initialValue: r,
    controlled: s ?? !0,
    checkedValue: o,
    syncVModel: i
  });
}
function cz(e, t, n) {
  const a = n?.standalone ? void 0 : np(Ds), r = n?.checkedValue, o = n?.uncheckedValue;
  function s(i) {
    const u = i.handleChange, d = A(() => {
      const f = pe(i.value), p = pe(r);
      return Array.isArray(f) ? f.findIndex((v) => Tt(v, p)) >= 0 : Tt(p, f);
    });
    function c(f, p = !0) {
      var v, m;
      if (d.value === ((v = f?.target) === null || v === void 0 ? void 0 : v.checked)) {
        p && i.validate();
        return;
      }
      const y = pe(e), x = a?.getPathState(y), C = ui(f);
      let S = (m = pe(r)) !== null && m !== void 0 ? m : C;
      a && x?.multiple && x.type === "checkbox" ? S = Rm(vt(a.values, y) || [], S, void 0) : n?.type === "checkbox" && (S = Rm(pe(i.value), S, pe(o))), u(S, p);
    }
    return Object.assign(Object.assign({}, i), {
      checked: d,
      checkedValue: r,
      uncheckedValue: o,
      handleChange: c
    });
  }
  return s(H_(e, t, n));
}
function fz({ prop: e, value: t, handleChange: n, shouldValidate: a }) {
  const r = zt();
  if (!r || !e)
    return;
  const o = typeof e == "string" ? e : "modelValue", s = `update:${o}`;
  o in r.props && (me(t, (i) => {
    Tt(i, Zd(r, o)) || r.emit(s, i);
  }), me(() => Zd(r, o), (i) => {
    if (i === li && t.value === void 0)
      return;
    const u = i === li ? void 0 : i;
    Tt(u, t.value) || n(u, a());
  }));
}
function Zd(e, t) {
  if (e)
    return e.props[t];
}
const pz = /* @__PURE__ */ b({
  name: "Field",
  inheritAttrs: !1,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: !0
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => Ya().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: li
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: !1
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    const n = Hn(e, "rules"), a = Hn(e, "name"), r = Hn(e, "label"), o = Hn(e, "uncheckedValue"), s = Hn(e, "keepValue"), { errors: i, value: u, errorMessage: d, validate: c, handleChange: f, handleBlur: p, setTouched: v, resetField: m, handleReset: y, meta: x, checked: C, setErrors: S, setValue: $ } = uz(a, n, {
      validateOnMount: e.validateOnMount,
      bails: e.bails,
      standalone: e.standalone,
      type: t.attrs.type,
      initialValue: mz(e, t),
      // Only for checkboxes and radio buttons
      checkedValue: t.attrs.value,
      uncheckedValue: o,
      label: r,
      validateOnValueUpdate: e.validateOnModelUpdate,
      keepValueOnUnmount: s,
      syncVModel: !0
    }), k = function(D, O = !0) {
      f(D, O);
    }, B = A(() => {
      const { validateOnInput: E, validateOnChange: D, validateOnBlur: O, validateOnModelUpdate: F } = vz(e);
      function J(H) {
        p(H, O), Nt(t.attrs.onBlur) && t.attrs.onBlur(H);
      }
      function ne(H) {
        k(H, E), Nt(t.attrs.onInput) && t.attrs.onInput(H);
      }
      function Q(H) {
        k(H, D), Nt(t.attrs.onChange) && t.attrs.onChange(H);
      }
      const W = {
        name: e.name,
        onBlur: J,
        onInput: ne,
        onChange: Q
      };
      return W["onUpdate:modelValue"] = (H) => k(H, F), W;
    }), P = A(() => {
      const E = Object.assign({}, B.value);
      qs(t.attrs.type) && C && (E.checked = C.value);
      const D = Lm(e, t);
      return N4(D, t.attrs) && (E.value = u.value), E;
    }), M = A(() => Object.assign(Object.assign({}, B.value), { modelValue: u.value }));
    function q() {
      return {
        field: P.value,
        componentField: M.value,
        value: u.value,
        meta: x,
        errors: i.value,
        errorMessage: d.value,
        validate: c,
        resetField: m,
        handleChange: k,
        handleInput: (E) => k(E, !1),
        handleReset: y,
        handleBlur: B.value.onBlur,
        setTouched: v,
        setErrors: S,
        setValue: $
      };
    }
    return t.expose({
      value: u,
      meta: x,
      errors: i,
      errorMessage: d,
      setErrors: S,
      setTouched: v,
      setValue: $,
      reset: m,
      validate: c,
      handleChange: f
    }), () => {
      const E = Pt(Lm(e, t)), D = lu(E, t, q);
      return E ? tn(E, Object.assign(Object.assign({}, t.attrs), P.value), D) : D;
    };
  }
});
function Lm(e, t) {
  let n = e.as || "";
  return !e.as && !t.slots.default && (n = "input"), n;
}
function vz(e) {
  var t, n, a, r;
  const { validateOnInput: o, validateOnChange: s, validateOnBlur: i, validateOnModelUpdate: u } = Ya();
  return {
    validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : o,
    validateOnChange: (n = e.validateOnChange) !== null && n !== void 0 ? n : s,
    validateOnBlur: (a = e.validateOnBlur) !== null && a !== void 0 ? a : i,
    validateOnModelUpdate: (r = e.validateOnModelUpdate) !== null && r !== void 0 ? r : u
  };
}
function mz(e, t) {
  return qs(t.attrs.type) ? Em(e, "modelValue") ? e.modelValue : void 0 : Em(e, "modelValue") ? e.modelValue : t.attrs.value;
}
const A9 = pz;
let hz = 0;
const nl = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function U_(e) {
  const t = e?.initialValues || {}, n = Object.assign({}, pe(t)), a = l(e?.validationSchema);
  return a && kn(a) && Nt(a.cast) ? je(a.cast(n) || {}) : je(n);
}
function gz(e) {
  var t;
  const n = hz++, a = e?.name || "Form";
  let r = 0;
  const o = I(!1), s = I(!1), i = I(0), u = [], d = pn(U_(e)), c = I([]), f = I({}), p = I({}), v = H4(() => {
    p.value = c.value.reduce((K, Y) => (K[ko(pe(Y.path))] = Y, K), {});
  });
  function m(K, Y) {
    const ue = H(K);
    if (!ue) {
      typeof K == "string" && (f.value[ko(K)] = Jd(Y));
      return;
    }
    if (typeof K == "string") {
      const ge = ko(K);
      f.value[ge] && delete f.value[ge];
    }
    ue.errors = Jd(Y), ue.valid = !ue.errors.length;
  }
  function y(K) {
    ln(K).forEach((Y) => {
      m(Y, K[Y]);
    });
  }
  e?.initialErrors && y(e.initialErrors);
  const x = A(() => {
    const K = c.value.reduce((Y, ue) => (ue.errors.length && (Y[pe(ue.path)] = ue.errors), Y), {});
    return Object.assign(Object.assign({}, f.value), K);
  }), C = A(() => ln(x.value).reduce((K, Y) => {
    const ue = x.value[Y];
    return ue?.length && (K[Y] = ue[0]), K;
  }, {})), S = A(() => c.value.reduce((K, Y) => (K[pe(Y.path)] = { name: pe(Y.path) || "", label: Y.label || "" }, K), {})), $ = A(() => c.value.reduce((K, Y) => {
    var ue;
    return K[pe(Y.path)] = (ue = Y.bails) !== null && ue !== void 0 ? ue : !0, K;
  }, {})), k = Object.assign({}, e?.initialErrors || {}), B = (t = e?.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1, { initialValues: P, originalInitialValues: M, setInitialValues: q } = bz(c, d, e), E = yz(c, d, M, C), D = A(() => c.value.reduce((K, Y) => {
    const ue = vt(d, pe(Y.path));
    return Vt(K, pe(Y.path), ue), K;
  }, {})), O = e?.validationSchema;
  function F(K, Y) {
    var ue, ge;
    const Me = A(() => vt(P.value, pe(K))), Oe = p.value[pe(K)], Ae = Y?.type === "checkbox" || Y?.type === "radio";
    if (Oe && Ae) {
      Oe.multiple = !0;
      const Yt = r++;
      return Array.isArray(Oe.id) ? Oe.id.push(Yt) : Oe.id = [Oe.id, Yt], Oe.fieldsCount++, Oe.__flags.pendingUnmount[Yt] = !1, Oe;
    }
    const ot = A(() => vt(d, pe(K))), ft = pe(K), qt = se.findIndex((Yt) => Yt === ft);
    qt !== -1 && se.splice(qt, 1);
    const at = A(() => {
      var Yt, ha, mr, oo;
      const du = pe(O);
      if (kn(du))
        return (ha = (Yt = du.describe) === null || Yt === void 0 ? void 0 : Yt.call(du, pe(K)).required) !== null && ha !== void 0 ? ha : !1;
      const cu = pe(Y?.schema);
      return kn(cu) && (oo = (mr = cu.describe) === null || mr === void 0 ? void 0 : mr.call(cu).required) !== null && oo !== void 0 ? oo : !1;
    }), Bt = r++, Rt = pn({
      id: Bt,
      path: K,
      touched: !1,
      pending: !1,
      valid: !0,
      validated: !!(!((ue = k[ft]) === null || ue === void 0) && ue.length),
      required: at,
      initialValue: Me,
      errors: ht([]),
      bails: (ge = Y?.bails) !== null && ge !== void 0 ? ge : !1,
      label: Y?.label,
      type: Y?.type || "default",
      value: ot,
      multiple: !1,
      __flags: {
        pendingUnmount: { [Bt]: !1 },
        pendingReset: !1
      },
      fieldsCount: 1,
      validate: Y?.validate,
      dirty: A(() => !Tt(l(ot), l(Me)))
    });
    return c.value.push(Rt), p.value[ft] = Rt, v(), C.value[ft] && !k[ft] && Pe(() => {
      Ue(ft, { mode: "silent" });
    }), Ct(K) && me(K, (Yt) => {
      v();
      const ha = je(ot.value);
      p.value[Yt] = Rt, Pe(() => {
        Vt(d, Yt, ha);
      });
    }), Rt;
  }
  const J = Vm($t, 5), ne = Vm($t, 5), Q = Xd(async (K) => await (K === "silent" ? J() : ne()), (K, [Y]) => {
    const ue = ln(V.errorBag.value), Me = [
      .../* @__PURE__ */ new Set([...ln(K.results), ...c.value.map((Oe) => Oe.path), ...ue])
    ].sort().reduce((Oe, Ae) => {
      var ot;
      const ft = Ae, qt = H(ft) || U(ft), at = ((ot = K.results[ft]) === null || ot === void 0 ? void 0 : ot.errors) || [], Bt = pe(qt?.path) || ft, Rt = _z({ errors: at, valid: !at.length }, Oe.results[Bt]);
      return Oe.results[Bt] = Rt, Rt.valid || (Oe.errors[Bt] = Rt.errors[0]), qt && f.value[Bt] && delete f.value[Bt], qt ? (qt.valid = Rt.valid, Y === "silent" || Y === "validated-only" && !qt.validated || m(qt, Rt.errors), Oe) : (m(Bt, at), Oe);
    }, {
      valid: K.valid,
      results: {},
      errors: {},
      source: K.source
    });
    return K.values && (Me.values = K.values, Me.source = K.source), ln(Me.results).forEach((Oe) => {
      var Ae;
      const ot = H(Oe);
      ot && Y !== "silent" && (Y === "validated-only" && !ot.validated || m(ot, (Ae = Me.results[Oe]) === null || Ae === void 0 ? void 0 : Ae.errors));
    }), Me;
  });
  function W(K) {
    c.value.forEach(K);
  }
  function H(K) {
    const Y = typeof K == "string" ? ko(K) : K;
    return typeof Y == "string" ? p.value[Y] : Y;
  }
  function U(K) {
    return c.value.filter((ue) => K.startsWith(pe(ue.path))).reduce((ue, ge) => ue ? ge.path.length > ue.path.length ? ge : ue : ge, void 0);
  }
  let se = [], ee;
  function de(K) {
    return se.push(K), ee || (ee = Pe(() => {
      [...se].sort().reverse().forEach((ue) => {
        Om(d, ue);
      }), se = [], ee = null;
    })), ee;
  }
  function fe(K) {
    return function(ue, ge) {
      return function(Oe) {
        return Oe instanceof Event && (Oe.preventDefault(), Oe.stopPropagation()), W((Ae) => Ae.touched = !0), o.value = !0, i.value++, Le().then((Ae) => {
          const ot = je(d);
          if (Ae.valid && typeof ue == "function") {
            const ft = je(D.value);
            let qt = K ? ft : ot;
            return Ae.values && (qt = Ae.source === "schema" ? Ae.values : Object.assign({}, qt, Ae.values)), ue(qt, {
              evt: Oe,
              controlledValues: ft,
              setErrors: y,
              setFieldError: m,
              setTouched: Xe,
              setFieldTouched: L,
              setValues: re,
              setFieldValue: te,
              resetForm: ke,
              resetField: lt
            });
          }
          !Ae.valid && typeof ge == "function" && ge({
            values: ot,
            evt: Oe,
            errors: Ae.errors,
            results: Ae.results
          });
        }).then((Ae) => (o.value = !1, Ae), (Ae) => {
          throw o.value = !1, Ae;
        });
      };
    };
  }
  const ye = fe(!1);
  ye.withControlled = fe(!0);
  function Ee(K, Y) {
    const ue = c.value.findIndex((Me) => Me.path === K && (Array.isArray(Me.id) ? Me.id.includes(Y) : Me.id === Y)), ge = c.value[ue];
    if (!(ue === -1 || !ge)) {
      if (Pe(() => {
        Ue(K, { mode: "silent", warn: !1 });
      }), ge.multiple && ge.fieldsCount && ge.fieldsCount--, Array.isArray(ge.id)) {
        const Me = ge.id.indexOf(Y);
        Me >= 0 && ge.id.splice(Me, 1), delete ge.__flags.pendingUnmount[Y];
      }
      (!ge.multiple || ge.fieldsCount <= 0) && (c.value.splice(ue, 1), We(K), v(), delete p.value[K]);
    }
  }
  function ce(K) {
    ln(p.value).forEach((Y) => {
      Y.startsWith(K) && delete p.value[Y];
    }), c.value = c.value.filter((Y) => !Y.path.startsWith(K)), Pe(() => {
      v();
    });
  }
  const V = {
    name: a,
    formId: n,
    values: d,
    controlledValues: D,
    errorBag: x,
    errors: C,
    schema: O,
    submitCount: i,
    meta: E,
    isSubmitting: o,
    isValidating: s,
    fieldArrays: u,
    keepValuesOnUnmount: B,
    validateSchema: l(O) ? Q : void 0,
    validate: Le,
    setFieldError: m,
    validateField: Ue,
    setFieldValue: te,
    setValues: re,
    setErrors: y,
    setFieldTouched: L,
    setTouched: Xe,
    resetForm: ke,
    resetField: lt,
    handleSubmit: ye,
    useFieldModel: Ve,
    defineInputBinds: Dt,
    defineComponentBinds: Wt,
    defineField: hn,
    stageInitialValue: it,
    unsetInitialValue: We,
    setFieldInitialValue: ut,
    createPathState: F,
    getPathState: H,
    unsetPathValue: de,
    removePathState: Ee,
    initialValues: P,
    getAllPathStates: () => c.value,
    destroyPath: ce,
    isFieldTouched: be,
    isFieldDirty: xe,
    isFieldValid: Ne
  };
  function te(K, Y, ue = !0) {
    const ge = je(Y), Me = typeof K == "string" ? K : K.path;
    H(Me) || F(Me), Vt(d, Me, ge), ue && Ue(Me);
  }
  function z(K, Y = !0) {
    ln(d).forEach((ue) => {
      delete d[ue];
    }), ln(K).forEach((ue) => {
      te(ue, K[ue], !1);
    }), Y && Le();
  }
  function re(K, Y = !0) {
    Qo(d, K), u.forEach((ue) => ue && ue.reset()), Y && Le();
  }
  function ie(K, Y) {
    const ue = H(pe(K)) || F(K);
    return A({
      get() {
        return ue.value;
      },
      set(ge) {
        var Me;
        const Oe = pe(K);
        te(Oe, ge, (Me = pe(Y)) !== null && Me !== void 0 ? Me : !1);
      }
    });
  }
  function L(K, Y) {
    const ue = H(K);
    ue && (ue.touched = Y);
  }
  function be(K) {
    const Y = H(K);
    return Y ? Y.touched : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.touched);
  }
  function xe(K) {
    const Y = H(K);
    return Y ? Y.dirty : c.value.filter((ue) => ue.path.startsWith(K)).some((ue) => ue.dirty);
  }
  function Ne(K) {
    const Y = H(K);
    return Y ? Y.valid : c.value.filter((ue) => ue.path.startsWith(K)).every((ue) => ue.valid);
  }
  function Xe(K) {
    if (typeof K == "boolean") {
      W((Y) => {
        Y.touched = K;
      });
      return;
    }
    ln(K).forEach((Y) => {
      L(Y, !!K[Y]);
    });
  }
  function lt(K, Y) {
    var ue;
    const ge = Y && "value" in Y ? Y.value : vt(P.value, K), Me = H(K);
    Me && (Me.__flags.pendingReset = !0), ut(K, je(ge), !0), te(K, ge, !1), L(K, (ue = Y?.touched) !== null && ue !== void 0 ? ue : !1), m(K, Y?.errors || []), Pe(() => {
      Me && (Me.__flags.pendingReset = !1);
    });
  }
  function ke(K, Y) {
    let ue = je(K?.values ? K.values : M.value);
    ue = Y?.force ? ue : Qo(M.value, ue), ue = kn(O) && Nt(O.cast) ? O.cast(ue) : ue, q(ue, { force: Y?.force }), W((ge) => {
      var Me;
      ge.__flags.pendingReset = !0, ge.validated = !1, ge.touched = ((Me = K?.touched) === null || Me === void 0 ? void 0 : Me[pe(ge.path)]) || !1, te(pe(ge.path), vt(ue, pe(ge.path)), !1), m(pe(ge.path), void 0);
    }), Y?.force ? z(ue, !1) : re(ue, !1), y(K?.errors || {}), i.value = K?.submitCount || 0, Pe(() => {
      Le({ mode: "silent" }), W((ge) => {
        ge.__flags.pendingReset = !1;
      });
    });
  }
  async function Le(K) {
    const Y = K?.mode || "force";
    if (Y === "force" && W((Ae) => Ae.validated = !0), V.validateSchema)
      return V.validateSchema(Y);
    s.value = !0;
    const ue = await Promise.all(c.value.map((Ae) => Ae.validate ? Ae.validate(K).then((ot) => ({
      key: pe(Ae.path),
      valid: ot.valid,
      errors: ot.errors,
      value: ot.value
    })) : Promise.resolve({
      key: pe(Ae.path),
      valid: !0,
      errors: [],
      value: void 0
    })));
    s.value = !1;
    const ge = {}, Me = {}, Oe = {};
    for (const Ae of ue)
      ge[Ae.key] = {
        valid: Ae.valid,
        errors: Ae.errors
      }, Ae.value && Vt(Oe, Ae.key, Ae.value), Ae.errors.length && (Me[Ae.key] = Ae.errors[0]);
    return {
      valid: ue.every((Ae) => Ae.valid),
      results: ge,
      errors: Me,
      values: Oe,
      source: "fields"
    };
  }
  async function Ue(K, Y) {
    var ue;
    const ge = H(K);
    if (ge && Y?.mode !== "silent" && (ge.validated = !0), O) {
      const { results: Me } = await Q(Y?.mode || "validated-only");
      return Me[K] || { errors: [], valid: !0 };
    }
    return ge?.validate ? ge.validate(Y) : (!ge && (ue = Y?.warn), Promise.resolve({ errors: [], valid: !0 }));
  }
  function We(K) {
    Om(P.value, K);
  }
  function it(K, Y, ue = !1) {
    ut(K, Y), Vt(d, K, Y), ue && !e?.initialValues && Vt(M.value, K, je(Y));
  }
  function ut(K, Y, ue = !1) {
    Vt(P.value, K, je(Y)), ue && Vt(M.value, K, je(Y));
  }
  async function $t() {
    const K = l(O);
    if (!K)
      return { valid: !0, results: {}, errors: {}, source: "none" };
    s.value = !0;
    const Y = ii(K) || kn(K) ? await nz(K, d) : await az(K, d, {
      names: S.value,
      bailsMap: $.value
    });
    return s.value = !1, Y;
  }
  const on = ye((K, { evt: Y }) => {
    R_(Y) && Y.target.submit();
  });
  Ce(() => {
    if (e?.initialErrors && y(e.initialErrors), e?.initialTouched && Xe(e.initialTouched), e?.validateOnMount) {
      Le();
      return;
    }
    V.validateSchema && V.validateSchema("silent");
  }), Ct(O) && me(O, () => {
    var K;
    (K = V.validateSchema) === null || K === void 0 || K.call(V, "validated-only");
  }), Kn(Ds, V);
  function hn(K, Y) {
    const ue = Nt(Y) ? void 0 : Y?.label, ge = H(pe(K)) || F(K, { label: ue }), Me = () => Nt(Y) ? Y(tl(ge, nl)) : Y || {};
    function Oe() {
      var at;
      ge.touched = !0, ((at = Me().validateOnBlur) !== null && at !== void 0 ? at : Ya().validateOnBlur) && Ue(pe(ge.path));
    }
    function Ae() {
      var at;
      ((at = Me().validateOnInput) !== null && at !== void 0 ? at : Ya().validateOnInput) && Pe(() => {
        Ue(pe(ge.path));
      });
    }
    function ot() {
      var at;
      ((at = Me().validateOnChange) !== null && at !== void 0 ? at : Ya().validateOnChange) && Pe(() => {
        Ue(pe(ge.path));
      });
    }
    const ft = A(() => {
      const at = {
        onChange: ot,
        onInput: Ae,
        onBlur: Oe
      };
      return Nt(Y) ? Object.assign(Object.assign({}, at), Y(tl(ge, nl)).props || {}) : Y?.props ? Object.assign(Object.assign({}, at), Y.props(tl(ge, nl))) : at;
    });
    return [ie(K, () => {
      var at, Bt, Rt;
      return (Rt = (at = Me().validateOnModelUpdate) !== null && at !== void 0 ? at : (Bt = Ya()) === null || Bt === void 0 ? void 0 : Bt.validateOnModelUpdate) !== null && Rt !== void 0 ? Rt : !0;
    }), ft];
  }
  function Ve(K) {
    return Array.isArray(K) ? K.map((Y) => ie(Y, !0)) : ie(K);
  }
  function Dt(K, Y) {
    const [ue, ge] = hn(K, Y);
    function Me() {
      ge.value.onBlur();
    }
    function Oe(ot) {
      const ft = ui(ot);
      te(pe(K), ft, !1), ge.value.onInput();
    }
    function Ae(ot) {
      const ft = ui(ot);
      te(pe(K), ft, !1), ge.value.onChange();
    }
    return A(() => Object.assign(Object.assign({}, ge.value), {
      onBlur: Me,
      onInput: Oe,
      onChange: Ae,
      value: ue.value
    }));
  }
  function Wt(K, Y) {
    const [ue, ge] = hn(K, Y), Me = H(pe(K));
    function Oe(Ae) {
      ue.value = Ae;
    }
    return A(() => {
      const Ae = Nt(Y) ? Y(tl(Me, nl)) : Y || {};
      return Object.assign({ [Ae.model || "modelValue"]: ue.value, [`onUpdate:${Ae.model || "modelValue"}`]: Oe }, ge.value);
    });
  }
  const Ot = Object.assign(Object.assign({}, V), { values: Ur(d), handleReset: () => ke(), submitForm: on });
  return Kn(T4, Ot), Ot;
}
function yz(e, t, n, a) {
  const r = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, o = A(() => !Tt(t, l(n)));
  function s() {
    const u = e.value;
    return ln(r).reduce((d, c) => {
      const f = r[c];
      return d[c] = u[f]((p) => p[c]), d;
    }, {});
  }
  const i = pn(s());
  return Te(() => {
    const u = s();
    i.touched = u.touched, i.valid = u.valid, i.pending = u.pending;
  }), A(() => Object.assign(Object.assign({ initialValues: l(n) }, i), { valid: i.valid && !ln(a.value).length, dirty: o.value }));
}
function bz(e, t, n) {
  const a = U_(n), r = I(a), o = I(je(a));
  function s(i, u) {
    u?.force ? (r.value = je(i), o.value = je(i)) : (r.value = Qo(je(r.value) || {}, je(i)), o.value = Qo(je(o.value) || {}, je(i))), u?.updateFields && e.value.forEach((d) => {
      if (d.touched)
        return;
      const f = vt(r.value, pe(d.path));
      Vt(t, pe(d.path), je(f));
    });
  }
  return {
    initialValues: r,
    originalInitialValues: o,
    setInitialValues: s
  };
}
function _z(e, t) {
  return t ? {
    valid: e.valid && t.valid,
    errors: [...e.errors, ...t.errors]
  } : e;
}
const wz = /* @__PURE__ */ b({
  name: "Form",
  inheritAttrs: !1,
  props: {
    as: {
      type: null,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: !1
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: !1
    },
    name: {
      type: String,
      default: "Form"
    }
  },
  setup(e, t) {
    const n = Hn(e, "validationSchema"), a = Hn(e, "keepValues"), { errors: r, errorBag: o, values: s, meta: i, isSubmitting: u, isValidating: d, submitCount: c, controlledValues: f, validate: p, validateField: v, handleReset: m, resetForm: y, handleSubmit: x, setErrors: C, setFieldError: S, setFieldValue: $, setValues: k, setFieldTouched: B, setTouched: P, resetField: M } = gz({
      validationSchema: n.value ? n : void 0,
      initialValues: e.initialValues,
      initialErrors: e.initialErrors,
      initialTouched: e.initialTouched,
      validateOnMount: e.validateOnMount,
      keepValuesOnUnmount: a,
      name: e.name
    }), q = x((W, { evt: H }) => {
      R_(H) && H.target.submit();
    }, e.onInvalidSubmit), E = e.onSubmit ? x(e.onSubmit, e.onInvalidSubmit) : q;
    function D(W) {
      ep(W) && W.preventDefault(), m(), typeof t.attrs.onReset == "function" && t.attrs.onReset();
    }
    function O(W, H) {
      return x(typeof W == "function" && !H ? W : H, e.onInvalidSubmit)(W);
    }
    function F() {
      return je(s);
    }
    function J() {
      return je(i.value);
    }
    function ne() {
      return je(r.value);
    }
    function Q() {
      return {
        meta: i.value,
        errors: r.value,
        errorBag: o.value,
        values: s,
        isSubmitting: u.value,
        isValidating: d.value,
        submitCount: c.value,
        controlledValues: f.value,
        validate: p,
        validateField: v,
        handleSubmit: O,
        handleReset: m,
        submitForm: q,
        setErrors: C,
        setFieldError: S,
        setFieldValue: $,
        setValues: k,
        setFieldTouched: B,
        setTouched: P,
        resetForm: y,
        resetField: M,
        getValues: F,
        getMeta: J,
        getErrors: ne
      };
    }
    return t.expose({
      setFieldError: S,
      setErrors: C,
      setFieldValue: $,
      setValues: k,
      setFieldTouched: B,
      setTouched: P,
      resetForm: y,
      validate: p,
      validateField: v,
      resetField: M,
      getValues: F,
      getMeta: J,
      getErrors: ne,
      values: s,
      meta: i,
      errors: r
    }), function() {
      const H = e.as === "form" ? e.as : e.as ? Pt(e.as) : null, U = lu(H, t, Q);
      return H ? tn(H, Object.assign(Object.assign(Object.assign({}, H === "form" ? {
        // Disables native validation as vee-validate will handle it.
        novalidate: !0
      } : {}), t.attrs), { onSubmit: E, onReset: D }), U) : U;
    };
  }
}), E9 = wz;
function xz(e) {
  const t = np(Ds, void 0), n = I([]), a = () => {
  }, r = {
    fields: n,
    remove: a,
    push: a,
    swap: a,
    insert: a,
    update: a,
    replace: a,
    prepend: a,
    move: a
  };
  if (!t || !l(e))
    return r;
  const o = t.fieldArrays.find((B) => l(B.path) === l(e));
  if (o)
    return o;
  let s = 0;
  function i() {
    return vt(t?.values, pe(e), []) || [];
  }
  function u() {
    const B = i();
    Array.isArray(B) && (n.value = B.map((P, M) => c(P, M, n.value)), d());
  }
  u();
  function d() {
    const B = n.value.length;
    for (let P = 0; P < B; P++) {
      const M = n.value[P];
      M.isFirst = P === 0, M.isLast = P === B - 1;
    }
  }
  function c(B, P, M) {
    if (M && !Cr(P) && M[P])
      return M[P];
    const q = s++;
    return {
      key: q,
      value: z4({
        get() {
          const D = vt(t?.values, pe(e), []) || [], O = n.value.findIndex((F) => F.key === q);
          return O === -1 ? B : D[O];
        },
        set(D) {
          const O = n.value.findIndex((F) => F.key === q);
          O !== -1 && C(O, D);
        }
      }),
      // will be auto unwrapped
      isFirst: !1,
      isLast: !1
    };
  }
  function f() {
    d(), t?.validate({ mode: "silent" });
  }
  function p(B) {
    const P = pe(e), M = vt(t?.values, P);
    if (!M || !Array.isArray(M))
      return;
    const q = [...M];
    q.splice(B, 1);
    const E = P + `[${B}]`;
    t.destroyPath(E), t.unsetInitialValue(E), Vt(t.values, P, q), n.value.splice(B, 1), f();
  }
  function v(B) {
    const P = je(B), M = pe(e), q = vt(t?.values, M), E = Cr(q) ? [] : q;
    if (!Array.isArray(E))
      return;
    const D = [...E];
    D.push(P), t.stageInitialValue(M + `[${D.length - 1}]`, P), Vt(t.values, M, D), n.value.push(c(P)), f();
  }
  function m(B, P) {
    const M = pe(e), q = vt(t?.values, M);
    if (!Array.isArray(q) || !(B in q) || !(P in q))
      return;
    const E = [...q], D = [...n.value], O = E[B];
    E[B] = E[P], E[P] = O;
    const F = D[B];
    D[B] = D[P], D[P] = F, Vt(t.values, M, E), n.value = D, d();
  }
  function y(B, P) {
    const M = je(P), q = pe(e), E = vt(t?.values, q);
    if (!Array.isArray(E) || E.length < B)
      return;
    const D = [...E], O = [...n.value];
    D.splice(B, 0, M), O.splice(B, 0, c(M)), Vt(t.values, q, D), n.value = O, f();
  }
  function x(B) {
    const P = pe(e);
    t.stageInitialValue(P, B), Vt(t.values, P, B), u(), f();
  }
  function C(B, P) {
    const M = pe(e), q = vt(t?.values, M);
    !Array.isArray(q) || q.length - 1 < B || (Vt(t.values, `${M}[${B}]`, P), t?.validate({ mode: "validated-only" }));
  }
  function S(B) {
    const P = je(B), M = pe(e), q = vt(t?.values, M), E = Cr(q) ? [] : q;
    if (!Array.isArray(E))
      return;
    const D = [P, ...E];
    Vt(t.values, M, D), t.stageInitialValue(M + "[0]", P), n.value.unshift(c(P)), f();
  }
  function $(B, P) {
    const M = pe(e), q = vt(t?.values, M), E = Cr(q) ? [] : [...q];
    if (!Array.isArray(q) || !(B in q) || !(P in q))
      return;
    const D = [...n.value], O = D[B];
    D.splice(B, 1), D.splice(P, 0, O);
    const F = E[B];
    E.splice(B, 1), E.splice(P, 0, F), Vt(t.values, M, E), n.value = D, f();
  }
  const k = {
    fields: n,
    remove: p,
    push: v,
    swap: m,
    insert: y,
    update: C,
    replace: x,
    prepend: S,
    move: $
  };
  return t.fieldArrays.push(Object.assign({ path: e, reset: u }, k)), Ea(() => {
    const B = t.fieldArrays.findIndex((P) => pe(P.path) === pe(e));
    B >= 0 && t.fieldArrays.splice(B, 1);
  }), me(i, (B) => {
    const P = n.value.map((M) => M.value);
    Tt(B, P) || u();
  }), k;
}
const Cz = /* @__PURE__ */ b({
  name: "FieldArray",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const { push: n, remove: a, swap: r, insert: o, replace: s, update: i, prepend: u, move: d, fields: c } = xz(() => e.name);
    function f() {
      return {
        fields: c.value,
        push: n,
        remove: a,
        swap: r,
        insert: o,
        update: i,
        replace: s,
        prepend: u,
        move: d
      };
    }
    return t.expose({
      push: n,
      remove: a,
      swap: r,
      insert: o,
      update: i,
      replace: s,
      prepend: u,
      move: d
    }), () => lu(void 0, t, f);
  }
}), T9 = Cz, Sz = /* @__PURE__ */ b({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: !0
    }
  },
  setup(e, t) {
    const n = xn(Ds, void 0), a = A(() => n?.errors.value[e.name]);
    function r() {
      return {
        message: a.value
      };
    }
    return () => {
      if (!a.value)
        return;
      const o = e.as ? Pt(e.as) : e.as, s = lu(o, t, r), i = Object.assign({ role: "alert" }, t.attrs);
      return !o && (Array.isArray(s) || !s) && s?.length ? s : (Array.isArray(s) || !s) && !s?.length ? tn(o || "span", i, a.value) : tn(o, i, s);
    };
  }
}), $z = Sz, j_ = /* @__PURE__ */ Symbol();
function iu() {
  const e = xn(I_), t = xn(j_);
  if (!e) throw new Error("useFormField should be used within <FormField>");
  const { name: n, errorMessage: a, meta: r } = e, o = t, s = {
    valid: A(() => r.valid),
    isDirty: A(() => r.dirty),
    isTouched: A(() => r.touched),
    error: a
  };
  return {
    id: o,
    name: n,
    formItemId: `${o}-form-item`,
    formDescriptionId: `${o}-form-item-description`,
    formMessageId: `${o}-form-item-message`,
    ...s
  };
}
const I9 = /* @__PURE__ */ b({
  __name: "FormControl",
  setup(e) {
    const { error: t, formItemId: n, formDescriptionId: a, formMessageId: r } = iu();
    return (o, s) => (h(), w(l(kl), {
      id: l(n),
      "aria-describedby": l(t) ? `${l(a)} ${l(r)}` : `${l(a)}`,
      "aria-invalid": !!l(t)
    }, {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "aria-describedby", "aria-invalid"]));
  }
}), Bz = ["id"], O9 = /* @__PURE__ */ b({
  __name: "FormDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { formDescriptionId: n } = iu();
    return (a, r) => (h(), G("p", {
      id: l(n),
      class: ae(l(R)("text-sm text-muted-foreground", t.class))
    }, [
      _(a.$slots, "default")
    ], 10, Bz));
  }
}), R9 = /* @__PURE__ */ b({
  __name: "FormItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Ke();
    return Kn(j_, n), (a, r) => (h(), G("div", {
      class: ae(l(R)("space-y-2", t.class))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), V9 = /* @__PURE__ */ b({
  __name: "FormLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, { error: n, formItemId: a } = iu();
    return (r, o) => (h(), w(l(T_), {
      class: ae(l(R)(l(n) && "text-destructive", t.class)),
      for: l(a)
    }, {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "for"]));
  }
}), F9 = /* @__PURE__ */ b({
  __name: "FormMessage",
  setup(e) {
    const { name: t, formMessageId: n } = iu();
    return (a, r) => (h(), w(l($z), {
      id: l(n),
      as: "p",
      name: pe(l(t)),
      class: "text-[0.8rem] font-medium text-destructive"
    }, null, 8, ["id", "name"]));
  }
}), N9 = /* @__PURE__ */ b({
  __name: "HoverCard",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    openDelay: {},
    closeDelay: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(AP), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), L9 = /* @__PURE__ */ b({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(FP), null, {
      default: g(() => [
        N(l(RP), T(l(a), {
          class: l(R)(
            "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: g(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), z9 = /* @__PURE__ */ b({
  __name: "HoverCardTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(LP), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), W_ = /* @__PURE__ */ b({
  __name: "Input",
  props: {
    defaultValue: {},
    modelValue: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ie(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => ec((h(), G("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => Ct(r) ? r.value = i : null),
      "data-slot": "input",
      class: ae(
        l(R)(
          "h-9 w-full min-w-0 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none selection:bg-primary selection:text-primary-foreground file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-input/30",
          "focus-visible:border-ring focus-visible:ring-[1px] focus-visible:ring-ring/50",
          "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
          n.class
        )
      )
    }, null, 2)), [
      [Xm, l(r)]
    ]);
  }
}), H9 = /* @__PURE__ */ b({
  __name: "InputGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "input-group",
      role: "group",
      class: ae(
        l(R)(
          "group/input-group relative flex w-full items-center rounded-md border border-input outline-none dark:bg-input/30",
          "h-9 min-w-0 has-[>textarea]:h-auto",
          // Variants based on alignment.
          "has-[>[data-align=inline-start]]:[&>input]:pl-2",
          "has-[>[data-align=inline-end]]:[&>input]:pr-2",
          "has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3",
          "has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3",
          // Focus state.
          "has-[[data-slot=input-group-control]:focus-visible]:ring-1 has-[[data-slot=input-group-control]:focus-visible]:ring-ring",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), kz = ["data-align"], U9 = /* @__PURE__ */ b({
  __name: "InputGroupAddon",
  props: {
    align: { default: "inline-start" },
    class: {}
  },
  setup(e) {
    const t = e;
    function n(a) {
      const r = a.currentTarget, o = a.target;
      o && o.closest("button") || r && r?.parentElement && r.parentElement?.querySelector("input")?.focus();
    }
    return (a, r) => (h(), G("div", {
      role: "group",
      "data-slot": "input-group-addon",
      "data-align": t.align,
      class: ae(l(R)(l(Mz)({ align: t.align }), t.class)),
      onClick: n
    }, [
      _(a.$slots, "default")
    ], 10, kz));
  }
}), j9 = /* @__PURE__ */ b({
  __name: "InputGroupButton",
  props: {
    variant: { default: "ghost" },
    size: { default: "xs" },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(bs), {
      "data-size": t.size,
      variant: t.variant,
      class: ae(l(R)(l(Dz)({ size: t.size }), t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-size", "variant", "class"]));
  }
}), W9 = /* @__PURE__ */ b({
  __name: "InputGroupInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(W_), {
      "data-slot": "input-group-control",
      class: ae(
        l(R)(
          "flex-1 rounded-none border-0 bg-transparent ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), G9 = /* @__PURE__ */ b({
  __name: "InputGroupText",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: ae(
        l(R)(
          "flex items-center gap-2 text-sm text-muted-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Pz = /* @__PURE__ */ b({
  __name: "Textarea",
  props: {
    class: {},
    defaultValue: {},
    modelValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, r = /* @__PURE__ */ Ie(n, "modelValue", t, {
      passive: !0,
      defaultValue: n.defaultValue
    });
    return (o, s) => ec((h(), G("textarea", {
      "onUpdate:modelValue": s[0] || (s[0] = (i) => Ct(r) ? r.value = i : null),
      class: ae(
        l(R)(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          n.class
        )
      )
    }, null, 2)), [
      [Xm, l(r)]
    ]);
  }
}), K9 = /* @__PURE__ */ b({
  __name: "InputGroupTextarea",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Pz), {
      "data-slot": "input-group-control",
      class: ae(
        l(R)(
          "flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none ring-offset-transparent focus-visible:ring-0 focus-visible:ring-transparent dark:bg-transparent",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), Mz = an(
  "flex h-auto cursor-text select-none items-center justify-center gap-2 py-1.5 text-sm font-medium text-muted-foreground group-data-[disabled=true]/input-group:opacity-50 [&>kbd]:rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-4",
  {
    variants: {
      align: {
        "inline-start": "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
        "inline-end": "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
        "block-start": "[.border-b]:pb-3 order-first w-full justify-start px-3 pt-3 group-has-[>input]/input-group:pt-2.5",
        "block-end": "[.border-t]:pt-3 order-last w-full justify-start px-3 pb-3 group-has-[>input]/input-group:pb-2.5"
      }
    },
    defaultVariants: {
      align: "inline-start"
    }
  }
), Dz = an("flex items-center gap-2 text-sm shadow-none", {
  variants: {
    size: {
      xs: "h-6 gap-1 rounded-[calc(var(--radius)-5px)] px-2 has-[>svg]:px-2 [&>svg:not([class*='size-'])]:size-3.5",
      sm: "h-8 gap-1.5 rounded-md px-2.5 has-[>svg]:px-2.5",
      "icon-xs": "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
      "icon-sm": "size-8 p-0 has-[>svg]:p-0"
    }
  },
  defaultVariants: {
    size: "xs"
  }
});
function qz(e) {
  return es() ? (Qd(e), !0) : !1;
}
function Az(e) {
  if (!Ct(e))
    return pn(e);
  const t = new Proxy({}, {
    get(n, a, r) {
      return l(Reflect.get(e.value, a, r));
    },
    set(n, a, r) {
      return Ct(e.value[a]) && !Ct(r) ? e.value[a].value = r : e.value[a] = r, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return pn(t);
}
function Ez(e) {
  return Az(A(e));
}
function Tz(e, ...t) {
  const n = t.flat(), a = n[0];
  return Ez(() => Object.fromEntries(typeof a == "function" ? Object.entries(qe(e)).filter(([r, o]) => !a(pe(o), r)) : Object.entries(qe(e)).filter((r) => !n.includes(r[0]))));
}
const G_ = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Iz = Object.prototype.toString, Oz = (e) => Iz.call(e) === "[object Object]", Rz = () => {
};
function Xu(e) {
  return Array.isArray(e) ? e : [e];
}
function Vz(...e) {
  if (e.length !== 1)
    return Hn(...e);
  const t = e[0];
  return typeof t == "function" ? Ur(di(() => ({ get: t, set: Rz }))) : I(t);
}
function Fz(e, t, n) {
  return me(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
const K_ = G_ ? window : void 0, za = G_ ? window.document : void 0;
function Nz(e) {
  var t;
  const n = pe(e);
  return (t = n?.$el) != null ? t : n;
}
function Lz(...e) {
  const t = [], n = () => {
    t.forEach((i) => i()), t.length = 0;
  }, a = (i, u, d, c) => (i.addEventListener(u, d, c), () => i.removeEventListener(u, d, c)), r = A(() => {
    const i = Xu(pe(e[0])).filter((u) => u != null);
    return i.every((u) => typeof u != "string") ? i : void 0;
  }), o = Fz(
    () => {
      var i, u;
      return [
        (u = (i = r.value) == null ? void 0 : i.map((d) => Nz(d))) != null ? u : [K_].filter((d) => d != null),
        Xu(pe(r.value ? e[1] : e[0])),
        Xu(l(r.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        pe(r.value ? e[3] : e[2])
      ];
    },
    ([i, u, d, c]) => {
      if (n(), !i?.length || !u?.length || !d?.length)
        return;
      const f = Oz(c) ? { ...c } : c;
      t.push(
        ...i.flatMap(
          (p) => u.flatMap(
            (v) => d.map((m) => a(p, v, m, f))
          )
        )
      );
    },
    { flush: "post" }
  ), s = () => {
    o(), n();
  };
  return qz(n), s;
}
function zz(e, t) {
  const n = ht(t);
  return me(
    Vz(e),
    (a, r) => {
      n.value = r;
    },
    { flush: "sync" }
  ), Ur(n);
}
const Hz = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`, Uz = b({
  props: { fallback: {
    type: String,
    required: !0
  } },
  setup(e) {
    return () => tn("noscript", { innerHTML: `<style>${e.fallback}</style>` });
  }
}), Y_ = /* @__PURE__ */ Symbol("vue-otp-context");
function jz(e) {
  return [
    setTimeout(e, 0),
    setTimeout(e, 10),
    setTimeout(e, 50)
  ];
}
const Wz = 18, X_ = 40, Gz = `${X_}px`, Kz = [
  "[data-lastpass-icon-root]",
  "com-1password-button",
  "[data-dashlanecreated]",
  '[style$="2147483647 !important;"]'
].join(",");
function Yz({ containerRef: e, inputRef: t, pushPasswordManagerStrategy: n, isFocused: a }) {
  const r = I({
    done: !1,
    refocused: !1
  }), o = I(!1), s = I(!1), i = I(!1), u = A(() => n === "none" ? !1 : (n === "increase-width" || n === "experimental-no-flickering") && o.value && s.value), d = () => {
    const p = e.value, v = t.value;
    if (!p || !v || i.value || n === "none") return;
    const m = p, y = m.getBoundingClientRect().left + m.offsetWidth, x = m.getBoundingClientRect().top + m.offsetHeight / 2, C = y - Wz, S = x;
    if (!(document.querySelectorAll(Kz).length === 0 && document.elementFromPoint(C, S) === p) && (o.value = !0, i.value = !0, !r.value.refocused && document.activeElement === v)) {
      const $ = [v.selectionStart, v.selectionEnd];
      v.blur(), v.focus(), v.setSelectionRange($[0], $[1]), r.value.refocused = !0;
    }
  }, c = () => {
    const p = e.value;
    !p || n === "none" || (s.value = window.innerWidth - p.getBoundingClientRect().right >= X_);
  };
  let f;
  return Ce(() => {
    c(), f = setInterval(c, 1e3);
  }), nt(() => {
    clearInterval(f);
  }), me([a, t], (p, v, m) => {
    const [y, x] = p, C = y || document.activeElement === x;
    if (n === "none" || !C) return;
    const S = setTimeout(d, 0), $ = setTimeout(d, 2e3), k = setTimeout(d, 5e3), B = setTimeout(() => {
      i.value = !0;
    }, 6e3);
    m(() => {
      clearTimeout(S), clearTimeout($), clearTimeout(k), clearTimeout(B);
    });
  }), {
    hasPWMBadge: o,
    willPushPWMBadge: u,
    PWM_BADGE_SPACE_WIDTH: Gz
  };
}
const Xz = { style: {
  position: "absolute",
  inset: "0",
  "pointer-events": "none"
} }, Jz = [
  "value",
  "data-input-otp-placeholder-shown",
  "data-input-otp-mss",
  "data-input-otp-mse",
  "aria-placeholder",
  "pattern"
], Zz = /* @__PURE__ */ b({
  name: "OTPInput",
  inheritAttrs: !1,
  __name: "OTPInput",
  props: /* @__PURE__ */ Zu({
    maxlength: {},
    textAlign: { default: "left" },
    inputmode: { default: "numeric" },
    containerClass: {},
    pushPasswordManagerStrategy: { default: "increase-width" },
    noScriptCssFallback: { default: Hz },
    defaultValue: { default: "" },
    pasteTransformer: {},
    accept: {},
    alt: {},
    autocomplete: { default: "one-time-code" },
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [
      Boolean,
      Array,
      Set
    ] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {}
  }, {
    modelValue: { default(e) {
      return e.defaultValue;
    } },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Zu([
    "complete",
    "change",
    "select",
    "input",
    "focus",
    "blur",
    "mouseover",
    "mouseleave",
    "paste"
  ], ["update:modelValue"]),
  setup(e, { expose: t, emit: n }) {
    const a = e, r = n, [o] = Jm(e, "modelValue"), s = zz(o), i = A(() => a.pattern ? typeof a.pattern == "string" ? new RegExp(a.pattern) : a.pattern : null), u = ht(!1), d = ht(!1), c = ht(null), f = ht(null), p = ht(null), v = ht(null), m = K_?.CSS?.supports?.("-webkit-touch-callout", "none");
    let y = { prev: [
      p.value?.selectionStart,
      p.value?.selectionEnd,
      p.value?.selectionDirection
    ] };
    function x(D, O) {
      try {
        D.insertRule(O);
      } catch {
        console.error("input-otp could not insert CSS rule:", O);
      }
    }
    Ce(() => {
      const D = p.value, O = v.value;
      if (!D || !O) return;
      y.prev = [
        D.selectionStart,
        D.selectionEnd,
        D.selectionDirection ?? "none"
      ];
      const F = Lz(za, "selectionchange", J, { capture: !0 });
      function J() {
        if (!D) return;
        if (za?.activeElement !== D) {
          c.value = null, f.value = null;
          return;
        }
        const W = D.selectionStart, H = D.selectionEnd, U = D.selectionDirection, se = D.maxLength, ee = D.value, de = y.prev;
        let fe = -1, _e = -1, ye;
        if (ee.length !== 0 && W !== null && H !== null) {
          const te = W === H, z = W === ee.length && ee.length < se;
          if (te && !z) {
            const re = W;
            if (re === 0)
              fe = 0, _e = 1, ye = "forward";
            else if (re === se)
              fe = re - 1, _e = re, ye = "backward";
            else if (se > 1 && ee.length > 1) {
              let ie = 0;
              if (de[0] !== null && de[1] !== null) {
                ye = re < de[1] ? "backward" : "forward";
                const L = de[0] === de[1] && de[0] < se;
                ye === "backward" && !L && (ie = -1);
              }
              fe = ie + re, _e = ie + re + 1;
            }
          }
          fe !== -1 && _e !== -1 && fe !== _e && D.setSelectionRange(fe, _e, ye);
        }
        const Ee = fe !== -1 ? fe : W, ce = _e !== -1 ? _e : H, V = ye ?? U;
        c.value = Ee, f.value = ce, y.prev = [
          Ee,
          ce,
          V
        ];
      }
      if (J(), za?.activeElement === D && (d.value = !0), !za?.getElementById("input-otp-style")) {
        const W = za?.createElement("style");
        if (W.id = "input-otp-style", za?.head.appendChild(W), W.sheet) {
          const H = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
          x(W.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), x(W.sheet, `[data-input-otp]:autofill { ${H} }`), x(W.sheet, `[data-input-otp]:-webkit-autofill { ${H} }`), x(W.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), x(W.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
        }
      }
      const ne = () => {
        O && O.style.setProperty("--root-height", `${D.clientHeight}px`);
      };
      ne();
      const Q = new ResizeObserver(ne);
      Q.observe(D), nt(() => {
        F(), Q.disconnect();
      });
    }), me([o], () => {
      jz(() => {
        if (!p.value) return;
        p.value?.dispatchEvent(new Event("input"));
        const D = p.value?.selectionStart, O = p.value?.selectionEnd, F = p.value?.selectionDirection;
        D !== null && O !== null && (c.value = D ?? null, f.value = O ?? null, y.prev = [
          D,
          O,
          F
        ]);
      });
    }, { immediate: !0 }), Te(() => {
      s.value !== void 0 && o.value !== s.value && s.value.length < a.maxlength && o.value.length === a.maxlength && r("complete", o.value);
    });
    const C = Yz({
      containerRef: v,
      inputRef: p,
      pushPasswordManagerStrategy: a.pushPasswordManagerStrategy,
      isFocused: d
    });
    function S(D) {
      if (D.inputType === "insertText" && D.data !== null) {
        const O = D.currentTarget, F = O.selectionStart ?? 0, J = O.selectionEnd ?? 0, ne = O.value, Q = (F !== J ? ne.slice(0, F) + D.data + ne.slice(J) : ne.slice(0, F) + D.data + ne.slice(F)).slice(0, a.maxlength);
        Q.length > 0 && i.value && !i.value.test(Q) && D.preventDefault();
      }
    }
    function $(D) {
      const O = D.currentTarget.value.slice(0, a.maxlength);
      if (O.length > 0 && i.value && !i.value.test(O)) {
        D.preventDefault();
        return;
      }
      typeof s.value == "string" && O.length < s.value.length && za?.dispatchEvent(new Event("selectionchange")), o.value = O, r("input", O);
    }
    function k() {
      const D = p.value;
      if (D) {
        const O = Math.min(D.value.length, a.maxlength - 1), F = D.value.length;
        D.setSelectionRange(O, F), c.value = O, f.value = F;
      }
      d.value = !0;
    }
    function B(D) {
      const O = p.value;
      if (!O || !a.pasteTransformer && (!m || !D.clipboardData || !O)) return;
      const F = D?.clipboardData?.getData("text/plain"), J = a?.pasteTransformer ? a.pasteTransformer(F) : F;
      D.preventDefault();
      const ne = p.value?.selectionStart, Q = p.value?.selectionEnd, W = (ne !== Q ? o.value.slice(0, ne) + J + o.value.slice(Q) : o.value.slice(0, ne) + J + o.value.slice(ne)).slice(0, a.maxlength);
      if (W.length > 0 && i.value && !i.value.test(W)) return;
      o.value = W, r("input", W);
      const H = Math.min(W.length, a.maxlength - 1), U = W.length;
      O?.setSelectionRange(H, U), c.value = H, f.value = U;
    }
    const P = he(Tz(a, "containerClass", "value", "pattern", "defaultValue", "pushPasswordManagerStrategy", "noScriptCssFallback", "modelValue")), M = A(() => ({
      position: "relative",
      cursor: a.disabled ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })), q = A(() => ({
      position: "absolute",
      inset: 0,
      width: C.willPushPWMBadge.value ? `calc(100% + ${C.PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: C.willPushPWMBadge.value ? `inset(0 ${C.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: a.textAlign,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })), E = A(() => ({
      slots: Array.from({ length: Number(a.maxlength) }).map((D, O) => {
        const F = d.value && c.value !== null && f.value !== null && (c.value === f.value && O === c.value || O >= c.value && O < f.value), J = o.value[O] !== void 0 ? o.value[O] : null;
        return {
          char: J,
          placeholderChar: J ?? a?.placeholder?.[O] ?? null,
          isActive: F,
          hasFakeCaret: F && J === null
        };
      }),
      isFocused: d.value,
      isHovering: !a.disabled && u.value
    }));
    return Kn(Y_, E), t(Object.defineProperty({}, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => p
    })), (D, O) => (h(), G(Ge, null, [e.noScriptCssFallback !== null ? (h(), w(l(Uz), {
      key: 0,
      fallback: e.noScriptCssFallback
    }, null, 8, ["fallback"])) : De("v-if", !0), we("div", {
      ref_key: "containerRef",
      ref: v,
      "data-input-otp-container": "",
      style: dt(M.value),
      class: ae(e.containerClass)
    }, [_(D.$slots, "default", {
      slots: E.value.slots,
      isFocused: d.value,
      isHovering: !e.disabled && u.value
    }), we("div", Xz, [we("input", T({
      ref_key: "inputRef",
      ref: p,
      value: l(o),
      "data-input-otp": "",
      "data-input-otp-placeholder-shown": l(o).length === 0 || void 0,
      "data-input-otp-mss": c.value,
      "data-input-otp-mse": f.value,
      "aria-placeholder": e.placeholder,
      style: q.value,
      pattern: i.value?.source
    }, {
      ...D.$attrs,
      ...l(P)
    }, {
      onBeforeinput: S,
      onMouseover: O[0] || (O[0] = (F) => {
        u.value = !0, r("mouseover", F);
      }),
      onMouseleave: O[1] || (O[1] = (F) => {
        u.value = !1, r("mouseleave", F);
      }),
      onPaste: O[2] || (O[2] = (F) => {
        B(F), r("paste", F);
      }),
      onInput: $,
      onFocus: O[3] || (O[3] = (F) => {
        k(), r("focus", F);
      }),
      onBlur: O[4] || (O[4] = (F) => {
        d.value = !1, r("blur", F);
      })
    }), null, 16, Jz)])], 6)], 64));
  }
});
var Qz = Zz;
function e8() {
  return xn(Y_);
}
const Y9 = /* @__PURE__ */ b({
  __name: "InputOTP",
  props: {
    maxlength: {},
    textAlign: {},
    inputmode: {},
    containerClass: {},
    pushPasswordManagerStrategy: {},
    noScriptCssFallback: {},
    defaultValue: {},
    pasteTransformer: { type: Function },
    accept: {},
    alt: {},
    autocomplete: {},
    autofocus: { type: Boolean },
    capture: { type: [Boolean, String] },
    checked: { type: [Boolean, Array, Set] },
    crossorigin: {},
    disabled: { type: Boolean },
    enterKeyHint: {},
    form: {},
    formaction: {},
    formenctype: {},
    formmethod: {},
    formnovalidate: { type: Boolean },
    formtarget: {},
    height: {},
    indeterminate: { type: Boolean },
    list: {},
    max: {},
    min: {},
    minlength: {},
    multiple: { type: Boolean },
    name: {},
    pattern: {},
    placeholder: {},
    readonly: { type: Boolean },
    required: { type: Boolean },
    size: {},
    src: {},
    step: {},
    type: {},
    value: {},
    width: {},
    class: {}
  },
  emits: ["complete", "change", "select", "input", "focus", "blur", "mouseover", "mouseleave", "paste"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(Qz), T(l(o), {
      "container-class": l(R)("flex items-center gap-2 has-disabled:opacity-50", n.class),
      "data-slot": "input-otp",
      class: "disabled:cursor-not-allowed"
    }), {
      default: g((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["container-class"]));
  }
}), X9 = /* @__PURE__ */ b({
  __name: "InputOTPGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), G("div", T({ "data-slot": "input-otp-group" }, l(a), {
      class: l(R)("flex items-center", t.class)
    }), [
      _(r.$slots, "default")
    ], 16));
  }
}), J9 = /* @__PURE__ */ b({
  __name: "InputOTPSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), G("div", T({
      "data-slot": "input-otp-separator",
      role: "separator"
    }, l(n)), [
      _(a.$slots, "default", {}, () => [
        N(l(cf))
      ])
    ], 16));
  }
}), t8 = ["data-active"], n8 = {
  key: 0,
  class: "pointer-events-none absolute inset-0 flex items-center justify-center"
}, Z9 = /* @__PURE__ */ b({
  __name: "InputOTPSlot",
  props: {
    index: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n), r = e8(), o = A(() => r?.value.slots[t.index]);
    return (s, i) => (h(), G("div", T(l(a), {
      "data-slot": "input-otp-slot",
      "data-active": o.value?.isActive,
      class: l(R)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md aria-invalid:border-destructive data-[active=true]:z-10 data-[active=true]:border-ring data-[active=true]:ring-[3px] data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:border-destructive data-[active=true]:aria-invalid:ring-destructive/20 dark:bg-input/30 dark:data-[active=true]:aria-invalid:ring-destructive/40",
        t.class
      )
    }), [
      Re(Fe(o.value?.char) + " ", 1),
      o.value?.hasFakeCaret ? (h(), G("div", n8, [...i[0] || (i[0] = [
        we("div", { class: "h-4 w-px animate-caret-blink bg-foreground duration-1000" }, null, -1)
      ])])) : De("", !0)
    ], 16, t8));
  }
}), Q9 = /* @__PURE__ */ b({
  __name: "Item",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" },
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      "data-slot": "item",
      as: e.as,
      "as-child": e.asChild,
      class: ae(l(R)(l(r8)({ variant: e.variant, size: e.size }), t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), eU = /* @__PURE__ */ b({
  __name: "ItemActions",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-actions",
      class: ae(l(R)("flex items-center gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), tU = /* @__PURE__ */ b({
  __name: "ItemContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-content",
      class: ae(l(R)("flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), nU = /* @__PURE__ */ b({
  __name: "ItemDescription",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("p", {
      "data-slot": "item-description",
      class: ae(
        l(R)(
          "line-clamp-2 text-sm leading-normal font-normal text-balance text-muted-foreground",
          "[&>a]:underline [&>a]:underline-offset-4 [&>a:hover]:text-primary",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), aU = /* @__PURE__ */ b({
  __name: "ItemFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-footer",
      class: ae(l(R)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), rU = /* @__PURE__ */ b({
  __name: "ItemGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      role: "list",
      "data-slot": "item-group",
      class: ae(l(R)("group/item-group flex flex-col", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), oU = /* @__PURE__ */ b({
  __name: "ItemHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-header",
      class: ae(l(R)("flex basis-full items-center justify-between gap-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), a8 = ["data-variant"], sU = /* @__PURE__ */ b({
  __name: "ItemMedia",
  props: {
    class: {},
    variant: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-media",
      "data-variant": t.variant,
      class: ae(l(R)(l(o8)({ variant: e.variant }), t.class))
    }, [
      _(n.$slots, "default")
    ], 10, a8));
  }
}), lU = /* @__PURE__ */ b({
  __name: "ItemSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Hi), {
      "data-slot": "item-separator",
      orientation: "horizontal",
      class: ae(l(R)("my-0", t.class))
    }, null, 8, ["class"]));
  }
}), iU = /* @__PURE__ */ b({
  __name: "ItemTitle",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "item-title",
      class: ae(l(R)("flex w-fit items-center gap-2 text-sm leading-snug font-medium", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), r8 = an(
  "group/item [a]:hover:bg-accent/50 [a]:transition-colors flex flex-wrap items-center rounded-md border border-transparent text-sm outline-none transition-colors duration-100 focus-visible:border-ring focus-visible:ring-1 focus-visible:ring-ring",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border-border",
        muted: "bg-muted/50"
      },
      size: {
        default: "gap-4 p-4 ",
        sm: "gap-2.5 px-4 py-3"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), o8 = an(
  "flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:translate-y-0.5 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        icon: "size-8 rounded-sm border bg-muted [&_svg:not([class*='size-'])]:size-4",
        image: "size-10 overflow-hidden rounded-sm [&_img]:size-full [&_img]:object-cover"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), uU = /* @__PURE__ */ b({
  __name: "Kbd",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("kbd", {
      class: ae(
        l(R)(
          "pointer-events-none inline-flex h-5 w-fit min-w-5 items-center justify-center gap-1 rounded-sm bg-muted px-1 font-sans text-xs font-medium text-muted-foreground select-none",
          "[&_svg:not([class*='size-'])]:size-3",
          "[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), dU = /* @__PURE__ */ b({
  __name: "KbdGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("kbd", {
      "data-slot": "kbd-group",
      class: ae(l(R)("inline-flex items-center gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), cU = /* @__PURE__ */ b({
  __name: "Menubar",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(KP), T(l(o), {
      class: l(R)(
        "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), s8 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, fU = /* @__PURE__ */ b({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select", "update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(jP), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: g(() => [
        we("span", s8, [
          N(l(Cg), null, {
            default: g(() => [
              N(l(to), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pU = /* @__PURE__ */ b({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: { default: 8 },
    sideFlip: { type: Boolean },
    align: { default: "start" },
    alignOffset: { default: -4 },
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Sg), null, {
      default: g(() => [
        N(l(QP), T(l(a), {
          class: l(R)(
            "z-50 min-w-48 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            t.class
          )
        }), {
          default: g(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), vU = /* @__PURE__ */ b({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(tM), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mU = /* @__PURE__ */ b({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(aM), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        e.inset && "pl-8",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hU = /* @__PURE__ */ b({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(sM), {
      class: ae(l(R)("px-2 py-1.5 text-sm font-semibold", e.inset && "pl-8", t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), gU = /* @__PURE__ */ b({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(JP), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yU = /* @__PURE__ */ b({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(uM), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), l8 = { class: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center" }, bU = /* @__PURE__ */ b({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(cM), T(l(o), {
      class: l(R)(
        "relative flex cursor-default items-center rounded-sm py-1.5 pr-2 pl-8 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        n.class
      )
    }), {
      default: g(() => [
        we("span", l8, [
          N(l(Cg), null, {
            default: g(() => [
              N(l(uf), { class: "h-4 w-4 fill-current" })
            ]),
            _: 1
          })
        ]),
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _U = /* @__PURE__ */ b({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(pM), T({
      class: l(R)("-mx-1 my-1 h-px bg-muted", t.class)
    }, l(a)), null, 16, ["class"]));
  }
}), wU = /* @__PURE__ */ b({
  __name: "MenubarShortcut",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("span", {
      class: ae(l(R)("ml-auto text-xs tracking-widest text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), xU = /* @__PURE__ */ b({
  __name: "MenubarSub",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(mM), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), CU = /* @__PURE__ */ b({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    sideOffset: {},
    sideFlip: { type: Boolean },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(Sg), null, {
      default: g(() => [
        N(l(gM), T(l(o), {
          class: l(R)(
            "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: g(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), SU = /* @__PURE__ */ b({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    inset: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(bM), T(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        e.inset && "pl-8",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default"),
        N(l(Fa), { class: "ml-auto h-4 w-4" })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), $U = /* @__PURE__ */ b({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(wM), T(l(a), {
      class: l(R)(
        "flex cursor-default items-center rounded-sm px-3 py-1 text-sm font-medium outline-none select-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), i8 = { class: "absolute top-full left-0 flex justify-center" }, u8 = /* @__PURE__ */ b({
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    align: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), G("div", i8, [
      N(l(UM), T(l(a), {
        class: l(R)(
          "origin-top-center relative left-[var(--reka-navigation-menu-viewport-left)] mt-1.5 h-[--reka-navigation-menu-viewport-height] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:zoom-in-90 md:w-[--reka-navigation-menu-viewport-width]",
          t.class
        )
      }), null, 16, ["class"])
    ]));
  }
}), BU = /* @__PURE__ */ b({
  __name: "NavigationMenu",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    orientation: {},
    delayDuration: {},
    skipDelayDuration: {},
    disableClickTrigger: { type: Boolean },
    disableHoverTrigger: { type: Boolean },
    disablePointerLeaveClose: { type: Boolean },
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(BM), T(l(o), {
      class: l(R)("relative z-10 flex max-w-max flex-1 items-center justify-center", n.class)
    }), {
      default: g(() => [
        _(s.$slots, "default"),
        N(u8)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kU = /* @__PURE__ */ b({
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(EM), T(l(o), {
      class: l(R)(
        "top-0 left-0 w-full data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 data-[motion^=from-]:animate-in data-[motion^=from-]:fade-in data-[motion^=to-]:animate-out data-[motion^=to-]:fade-out md:absolute md:w-auto",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), PU = /* @__PURE__ */ b({
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(IM), T(l(a), {
      class: l(R)(
        "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:animate-in data-[state=visible]:fade-in",
        t.class
      )
    }), {
      default: g(() => [...o[0] || (o[0] = [
        we("div", { class: "relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" }, null, -1)
      ])]),
      _: 1
    }, 16, ["class"]));
  }
}), MU = /* @__PURE__ */ b({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(MM), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), DU = /* @__PURE__ */ b({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(RM), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qU = /* @__PURE__ */ b({
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(FM), T(l(a), {
      class: l(R)("group flex flex-1 list-none items-center justify-center gap-x-1", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), AU = /* @__PURE__ */ b({
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(zM), T(l(a), {
      class: l(R)(l(d8)(), "group", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default"),
        N(l(Li), {
          class: "relative top-px ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180",
          "aria-hidden": "true"
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), d8 = an(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
), EU = /* @__PURE__ */ b({
  __name: "NumberField",
  props: {
    defaultValue: {},
    modelValue: {},
    min: {},
    max: {},
    step: {},
    stepSnapping: { type: Boolean },
    focusOnChange: { type: Boolean },
    formatOptions: {},
    locale: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    disableWheelChange: { type: Boolean },
    invertWheelChange: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(tD), T(l(o), {
      class: l(R)("grid gap-1.5", n.class)
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), TU = /* @__PURE__ */ b({
  __name: "NumberFieldContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      class: ae(
        l(R)(
          "relative [&>[data-slot=input]]:has-[[data-slot=decrement]]:pl-5 [&>[data-slot=input]]:has-[[data-slot=increment]]:pr-5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), IU = /* @__PURE__ */ b({
  __name: "NumberFieldDecrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(aD), T({ "data-slot": "decrement" }, l(a), {
      class: l(R)(
        "absolute top-1/2 left-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(cf), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), OU = /* @__PURE__ */ b({
  __name: "NumberFieldIncrement",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(oD), T({ "data-slot": "increment" }, l(a), {
      class: l(R)(
        "absolute top-1/2 right-0 -translate-y-1/2 p-3 disabled:cursor-not-allowed disabled:opacity-20",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(cI), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), RU = /* @__PURE__ */ b({
  __name: "NumberFieldInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(lD), {
      "data-slot": "input",
      class: ae(
        l(R)(
          "flex h-9 w-full rounded-md border border-input bg-transparent py-1 text-center text-sm shadow-sm transition-colors placeholder:text-muted-foreground focus-visible:ring-1 focus-visible:ring-ring focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
          t.class
        )
      )
    }, null, 8, ["class"]));
  }
}), VU = /* @__PURE__ */ b({
  __name: "Pagination",
  props: {
    page: {},
    defaultPage: {},
    itemsPerPage: {},
    total: {},
    siblingCount: {},
    disabled: { type: Boolean },
    showEdges: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:page"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(fD), T({ "data-slot": "pagination" }, l(o), {
      class: l(R)("mx-auto flex w-full justify-center", n.class)
    }), {
      default: g((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), FU = /* @__PURE__ */ b({
  __name: "PaginationContent",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(_D), T({ "data-slot": "pagination-content" }, l(n), {
      class: l(R)("flex flex-row items-center gap-1", t.class)
    }), {
      default: g((o) => [
        _(a.$slots, "default", oe(le(o)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), NU = /* @__PURE__ */ b({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(uD), T({ "data-slot": "pagination-ellipsis" }, l(n), {
      class: l(R)("flex size-9 items-center justify-center", t.class)
    }), {
      default: g(() => [
        _(a.$slots, "default", {}, () => [
          N(l(Vy), { class: "size-4" }),
          r[0] || (r[0] = we("span", { class: "sr-only" }, "More pages", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), LU = /* @__PURE__ */ b({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), w(l(vD), T({
      "data-slot": "pagination-first",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi)),
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "First", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), zU = /* @__PURE__ */ b({
  __name: "PaginationItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: {},
    size: { default: "icon" },
    class: {},
    isActive: { type: Boolean }
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size", "isActive");
    return (a, r) => (h(), w(l(xD), T({ "data-slot": "pagination-item" }, l(n), {
      class: l(R)(
        l(Kt)({
          variant: e.isActive ? "outline" : "ghost",
          size: e.size
        }),
        t.class
      )
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), HU = /* @__PURE__ */ b({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), w(l(hD), T({
      "data-slot": "pagination-last",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Last", -1)),
          N(l(Fa))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), UU = /* @__PURE__ */ b({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), w(l(SD), T({
      "data-slot": "pagination-next",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Next", -1)),
          N(l(Fa))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jU = /* @__PURE__ */ b({
  __name: "PaginationPrevious",
  props: {
    asChild: { type: Boolean },
    as: {},
    size: { default: "default" },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class", "size"), a = he(n);
    return (r, o) => (h(), w(l(BD), T({
      "data-slot": "pagination-previous",
      class: l(R)(l(Kt)({ variant: "ghost", size: e.size }), "gap-1 px-2.5 sm:pr-2.5", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi)),
          o[0] || (o[0] = we("span", { class: "hidden sm:block" }, "Previous", -1))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), WU = /* @__PURE__ */ b({
  __name: "PinInput",
  props: {
    modelValue: { default: () => [] },
    defaultValue: {},
    placeholder: {},
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: {},
    dir: {},
    disabled: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(DD), T(l(o), {
      class: l(R)("flex items-center gap-2", n.class)
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), GU = /* @__PURE__ */ b({
  __name: "PinInputGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(X), T(l(a), {
      class: l(R)("flex items-center", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), KU = /* @__PURE__ */ b({
  __name: "PinInputSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const n = he(e);
    return (a, r) => (h(), w(l(X), oe(le(l(n))), {
      default: g(() => [
        _(a.$slots, "default", {}, () => [
          N(l(cf), { class: "w-2" })
        ])
      ]),
      _: 3
    }, 16));
  }
}), YU = /* @__PURE__ */ b({
  __name: "PinInputSlot",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(AD), T(l(a), {
      class: l(R)(
        "relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-center text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md focus:relative focus:z-10 focus:ring-2 focus:ring-ring focus:outline-none",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), XU = /* @__PURE__ */ b({
  __name: "Popover",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(pk), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), JU = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: { default: 4 },
    sideFlip: { type: Boolean },
    align: { default: "center" },
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(Ck), null, {
      default: g(() => [
        N(l(wk), T({ ...l(o), ...s.$attrs }, {
          class: l(R)(
            "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            n.class
          )
        }), {
          default: g(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), ZU = /* @__PURE__ */ b({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l($k), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), QU = /* @__PURE__ */ b({
  __name: "Progress",
  props: {
    modelValue: { default: 0 },
    max: {},
    getValueLabel: {},
    getValueText: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(VD), T(l(n), {
      class: l(R)("relative h-2 w-full overflow-hidden rounded-full bg-primary/20", t.class)
    }), {
      default: g(() => [
        N(l(ND), {
          class: "h-full w-full flex-1 bg-primary transition-all",
          style: dt(`transform: translateX(-${100 - (t.modelValue ?? 0)}%);`)
        }, null, 8, ["style"])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), ej = /* @__PURE__ */ b({
  __name: "RadioGroup",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(KD), T({
      class: l(R)("grid gap-2", n.class)
    }, l(o)), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), tj = /* @__PURE__ */ b({
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(ZD), T(l(a), {
      class: l(R)(
        "peer aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        t.class
      )
    }), {
      default: g(() => [
        N(l(eq), { class: "flex items-center justify-center" }, {
          default: g(() => [
            N(l(to), { class: "h-3.5 w-3.5 text-primary" })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), c8 = { class: "mt-4 flex flex-col gap-y-4 sm:flex-row sm:gap-x-4 sm:gap-y-0" }, nj = /* @__PURE__ */ b({
  __name: "RangeCalendar",
  props: {
    defaultPlaceholder: {},
    defaultValue: {},
    modelValue: {},
    placeholder: {},
    allowNonContiguousRanges: { type: Boolean },
    pagedNavigation: { type: Boolean },
    preventDeselect: { type: Boolean },
    maximumDays: {},
    weekStartsOn: {},
    weekdayFormat: {},
    calendarLabel: {},
    fixedWeeks: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: {},
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    initialFocus: { type: Boolean },
    isDateDisabled: { type: Function },
    isDateUnavailable: { type: Function },
    isDateHighlightable: { type: Function },
    dir: {},
    nextPage: { type: Function },
    prevPage: { type: Function },
    disableDaysOutsideCurrentView: { type: Boolean },
    fixedDate: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue", "update:validModelValue", "update:placeholder", "update:startValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(qk), T({
      class: l(R)("p-3", n.class)
    }, l(o)), {
      default: g(({ grid: u, weekDays: d }) => [
        N(l(y8), null, {
          default: g(() => [
            N(l(w8)),
            N(l(b8)),
            N(l(_8))
          ]),
          _: 1
        }),
        we("div", c8, [
          (h(!0), G(Ge, null, Et(u, (c) => (h(), w(l(v8), {
            key: c.value.toString()
          }, {
            default: g(() => [
              N(l(h8), null, {
                default: g(() => [
                  N(l(zm), null, {
                    default: g(() => [
                      (h(!0), G(Ge, null, Et(d, (f) => (h(), w(l(g8), { key: f }, {
                        default: g(() => [
                          Re(Fe(f), 1)
                        ]),
                        _: 2
                      }, 1024))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024),
              N(l(m8), null, {
                default: g(() => [
                  (h(!0), G(Ge, null, Et(c.rows, (f, p) => (h(), w(l(zm), {
                    key: `weekDate-${p}`,
                    class: "mt-2 w-full"
                  }, {
                    default: g(() => [
                      (h(!0), G(Ge, null, Et(f, (v) => (h(), w(l(f8), {
                        key: v.toString(),
                        date: v
                      }, {
                        default: g(() => [
                          N(l(p8), {
                            day: v,
                            month: c.value
                          }, null, 8, ["day", "month"])
                        ]),
                        _: 2
                      }, 1032, ["date"]))), 128))
                    ]),
                    _: 2
                  }, 1024))), 128))
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1024))), 128))
        ])
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), f8 = /* @__PURE__ */ b({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Ek), T({
      class: l(R)(
        "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([data-selected])]:bg-accent first:[&:has([data-selected])]:rounded-l-md last:[&:has([data-selected])]:rounded-r-md [&:has([data-selected][data-outside-view])]:bg-accent/50 [&:has([data-selected][data-selection-end])]:rounded-r-md [&:has([data-selected][data-selection-start])]:rounded-l-md",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), p8 = /* @__PURE__ */ b({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Ik), T({
      class: l(R)(
        l(Kt)({ variant: "ghost" }),
        "h-8 w-8 p-0 font-normal data-[selected]:opacity-100",
        "[&[data-today]:not([data-selected])]:bg-accent [&[data-today]:not([data-selected])]:text-accent-foreground",
        // Selection Start
        "data-[selection-start]:bg-primary data-[selection-start]:text-primary-foreground data-[selection-start]:hover:bg-primary data-[selection-start]:hover:text-primary-foreground data-[selection-start]:focus:bg-primary data-[selection-start]:focus:text-primary-foreground",
        // Selection End
        "data-[selection-end]:bg-primary data-[selection-end]:text-primary-foreground data-[selection-end]:hover:bg-primary data-[selection-end]:hover:text-primary-foreground data-[selection-end]:focus:bg-primary data-[selection-end]:focus:text-primary-foreground",
        // Outside months
        "data-[outside-view]:text-muted-foreground data-[outside-view]:opacity-50 [&[data-outside-view][data-selected]]:text-muted-foreground [&[data-outside-view][data-selected]]:opacity-30",
        // Disabled
        "data-[disabled]:text-muted-foreground data-[disabled]:opacity-50",
        // Unavailable
        "data-[unavailable]:text-destructive-foreground data-[unavailable]:line-through",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), v8 = /* @__PURE__ */ b({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Rk), T({
      class: l(R)("w-full border-collapse space-y-1", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), m8 = /* @__PURE__ */ b({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Fk), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), h8 = /* @__PURE__ */ b({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Lk), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zm = /* @__PURE__ */ b({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Hk), T({
      class: l(R)("flex", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), g8 = /* @__PURE__ */ b({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(jk), T({
      class: l(R)("w-8 rounded-md text-[0.8rem] font-normal text-muted-foreground", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), y8 = /* @__PURE__ */ b({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Gk), T({
      class: l(R)("relative flex w-full items-center justify-between pt-1", t.class)
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), b8 = /* @__PURE__ */ b({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Yk), T({
      class: l(R)("text-sm font-medium", t.class)
    }, l(a)), {
      default: g(({ headingValue: s }) => [
        _(r.$slots, "default", { headingValue: s }, () => [
          Re(Fe(s), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), _8 = /* @__PURE__ */ b({
  __name: "RangeCalendarNextButton",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Jk), T({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Fa), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), w8 = /* @__PURE__ */ b({
  __name: "RangeCalendarPrevButton",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(Qk), T({
      class: l(R)(
        l(Kt)({ variant: "outline" }),
        "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        t.class
      )
    }, l(a)), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(zi), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), x8 = {
  key: 0,
  class: "z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border"
}, aj = /* @__PURE__ */ b({
  __name: "ResizableHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: {},
    disabled: { type: Boolean },
    nonce: {},
    asChild: { type: Boolean },
    as: {},
    class: {},
    withHandle: { type: Boolean }
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(kE), T(l(o), {
      class: l(R)(
        "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 focus-visible:outline-none [&[data-orientation=vertical]]:h-px [&[data-orientation=vertical]]:w-full [&[data-orientation=vertical]]:after:left-0 [&[data-orientation=vertical]]:after:h-1 [&[data-orientation=vertical]]:after:w-full [&[data-orientation=vertical]]:after:translate-x-0 [&[data-orientation=vertical]]:after:-translate-y-1/2 [&[data-orientation=vertical]>div]:rotate-90",
        n.class
      )
    }), {
      default: g(() => [
        n.withHandle ? (h(), G("div", x8, [
          N(l(uI), { class: "h-2.5 w-2.5" })
        ])) : De("", !0)
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), rj = /* @__PURE__ */ b({
  __name: "ResizablePanelGroup",
  props: {
    id: {},
    autoSaveId: {},
    direction: {},
    keyboardResizeBy: {},
    storage: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(CE), T(l(o), {
      class: l(R)("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", n.class)
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), C8 = /* @__PURE__ */ b({
  __name: "ScrollBar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(Cq), T(l(n), {
      class: l(R)(
        "flex touch-none transition-colors select-none",
        e.orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-px",
        e.orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-px",
        t.class
      )
    }), {
      default: g(() => [
        N(l(Pq), { class: "relative flex-1 rounded-full bg-border" })
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), oj = /* @__PURE__ */ b({
  __name: "ScrollArea",
  props: {
    type: {},
    dir: {},
    scrollHideDelay: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(aq), T(l(n), {
      class: l(R)("relative overflow-hidden", t.class)
    }), {
      default: g(() => [
        N(l(Dq), { class: "h-full w-full rounded-[inherit]" }, {
          default: g(() => [
            _(a.$slots, "default")
          ]),
          _: 3
        }),
        N(C8),
        N(l(lq))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), S8 = /* @__PURE__ */ b({
  __name: "Select",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    defaultValue: {},
    modelValue: {},
    by: { type: [String, Function] },
    dir: {},
    multiple: { type: Boolean },
    autocomplete: {},
    disabled: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(Oq), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), $8 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "popper" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    sideFlip: { type: Boolean },
    align: {},
    alignOffset: {},
    alignFlip: { type: Boolean },
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    hideShiftedArrow: { type: Boolean },
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean },
    class: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(pA), null, {
      default: g(() => [
        N(l(Jq), T({ ...l(o), ...s.$attrs }, {
          class: l(R)(
            "relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
            e.position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
            n.class
          )
        }), {
          default: g(() => [
            N(l(M8)),
            N(l(BA), {
              class: ae(
                l(R)(
                  "p-1",
                  e.position === "popper" && "h-[--reka-select-trigger-height] w-full min-w-[--reka-select-trigger-width]"
                )
              )
            }, {
              default: g(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]),
            N(l(P8))
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), sj = /* @__PURE__ */ b({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(tA), T({
      class: l(R)("w-full p-1", t.class)
    }, l(n)), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), B8 = { class: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center" }, k8 = /* @__PURE__ */ b({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(sA), T(l(a), {
      class: l(R)(
        "relative flex w-full cursor-default items-center rounded-sm py-1.5 pr-8 pl-2 text-sm outline-none select-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        t.class
      )
    }), {
      default: g(() => [
        we("span", B8, [
          N(l(iA), null, {
            default: g(() => [
              N(l(to), { class: "h-4 w-4" })
            ]),
            _: 1
          })
        ]),
        N(l(Vg), null, {
          default: g(() => [
            _(r.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), lj = /* @__PURE__ */ b({
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Vg), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ij = /* @__PURE__ */ b({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(cA), {
      class: ae(l(R)("px-2 py-1.5 text-sm font-semibold", t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), P8 = /* @__PURE__ */ b({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(hA), T(l(a), {
      class: l(R)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(Li))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), M8 = /* @__PURE__ */ b({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(yA), T(l(a), {
      class: l(R)("flex cursor-default items-center justify-center py-1", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(iI))
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uj = /* @__PURE__ */ b({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(_A), T(l(n), {
      class: l(R)("-mx-1 my-1 h-px bg-muted", t.class)
    }), null, 16, ["class"]));
  }
}), D8 = /* @__PURE__ */ b({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(xA), T(l(a), {
      class: l(R)(
        "flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-start text-sm whitespace-nowrap shadow-sm ring-offset-background focus:ring-1 focus:ring-ring focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[placeholder]:text-muted-foreground [&>span]:truncate",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default"),
        N(l(aA), { "as-child": "" }, {
          default: g(() => [
            N(l(Li), { class: "h-4 w-4 shrink-0 opacity-50" })
          ]),
          _: 1
        })
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), q8 = /* @__PURE__ */ b({
  __name: "SelectValue",
  props: {
    placeholder: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(SA), oe(le(t)), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SimpleSelect",
  props: /* @__PURE__ */ Zu({
    options: {},
    placeholder: { default: "Select an option" },
    disabled: { type: Boolean },
    class: {}
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(e) {
    const t = e, n = Jm(e, "modelValue");
    return (a, r) => (h(), w(l(S8), {
      modelValue: n.value,
      "onUpdate:modelValue": r[0] || (r[0] = (o) => n.value = o),
      disabled: e.disabled
    }, {
      default: g(() => [
        N(l(D8), T(a.$attrs, {
          class: l(R)("w-full", t.class)
        }), {
          default: g(() => [
            N(l(q8), { placeholder: e.placeholder }, null, 8, ["placeholder"])
          ]),
          _: 1
        }, 16, ["class"]),
        N(l($8), null, {
          default: g(() => [
            (h(!0), G(Ge, null, Et(e.options, (o) => (h(), w(l(k8), {
              key: o.value,
              value: o.value,
              disabled: o.disabled
            }, {
              default: g(() => [
                Re(Fe(o.label), 1)
              ]),
              _: 2
            }, 1032, ["value", "disabled"]))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue", "disabled"]));
  }
}), A8 = /* @__PURE__ */ b({
  __name: "Sheet",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean },
    modal: { type: Boolean }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(yi), T({ "data-slot": "sheet" }, l(r)), {
      default: g((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16));
  }
}), cj = /* @__PURE__ */ b({
  __name: "SheetClose",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Ia), T({ "data-slot": "sheet-close" }, t), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), E8 = /* @__PURE__ */ b({
  __name: "SheetOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(cs), T({
      "data-slot": "sheet-overlay",
      class: l(R)(
        "fixed inset-0 z-50 bg-black/80 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:animate-in data-[state=open]:fade-in-0",
        t.class
      )
    }, l(n)), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), T8 = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SheetContent",
  props: {
    class: {},
    side: { default: "right" },
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "side"), o = ve(r, a);
    return (s, i) => (h(), w(l(_i), null, {
      default: g(() => [
        N(E8),
        N(l(ds), T({
          "data-slot": "sheet-content",
          class: l(R)(
            "fixed z-50 flex flex-col gap-4 bg-background shadow-lg transition ease-in-out data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:animate-in data-[state=open]:duration-500",
            e.side === "right" && "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
            e.side === "left" && "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
            e.side === "top" && "inset-x-0 top-0 h-auto border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
            e.side === "bottom" && "inset-x-0 bottom-0 h-auto border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
            n.class
          )
        }, { ...s.$attrs, ...l(o) }), {
          default: g(() => [
            _(s.$slots, "default"),
            N(l(Ia), { class: "absolute top-4 right-4 rounded-xs opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:ring-2 focus:ring-ring focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none data-[state=open]:bg-secondary" }, {
              default: g(() => [
                N(l(no), { class: "size-4" }),
                i[0] || (i[0] = we("span", { class: "sr-only" }, "Close", -1))
              ]),
              _: 1
            })
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), fj = /* @__PURE__ */ b({
  __name: "SheetDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(bi), T({
      "data-slot": "sheet-description",
      class: l(R)("text-sm text-muted-foreground", t.class)
    }, l(n)), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), pj = /* @__PURE__ */ b({
  __name: "SheetFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "sheet-footer",
      class: ae(l(R)("mt-auto flex flex-col gap-2 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), vj = /* @__PURE__ */ b({
  __name: "SheetHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "sheet-header",
      class: ae(l(R)("flex flex-col gap-1.5 p-4", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), mj = /* @__PURE__ */ b({
  __name: "SheetTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(wi), T({
      "data-slot": "sheet-title",
      class: l(R)("font-semibold text-foreground", t.class)
    }, l(n)), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), hj = /* @__PURE__ */ b({
  __name: "SheetTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(xi), T({ "data-slot": "sheet-trigger" }, t), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Hm = "sidebar_state", I8 = 3600 * 24 * 7, O8 = "16rem", R8 = "18rem", V8 = "3rem", F8 = "b", [uu, N8] = Se("Sidebar"), L8 = { class: "flex h-full w-full flex-col" }, z8 = ["data-state", "data-collapsible", "data-variant", "data-side"], H8 = {
  "data-sidebar": "sidebar",
  class: "flex h-full w-full flex-col bg-sidebar text-sidebar-foreground group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
}, gj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "Sidebar",
  props: {
    side: { default: "left" },
    variant: { default: "sidebar" },
    collapsible: { default: "offcanvas" },
    class: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a, openMobile: r, setOpenMobile: o } = uu();
    return (s, i) => e.collapsible === "none" ? (h(), G("div", T({
      key: 0,
      class: l(R)("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", t.class)
    }, s.$attrs), [
      _(s.$slots, "default")
    ], 16)) : l(n) ? (h(), w(l(A8), T({
      key: 1,
      open: l(r)
    }, s.$attrs, { "onUpdate:open": l(o) }), {
      default: g(() => [
        N(l(T8), {
          "data-sidebar": "sidebar",
          "data-mobile": "true",
          side: e.side,
          class: "w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden",
          style: dt({
            "--sidebar-width": l(R8)
          })
        }, {
          default: g(() => [
            we("div", L8, [
              _(s.$slots, "default")
            ])
          ]),
          _: 3
        }, 8, ["side", "style"])
      ]),
      _: 3
    }, 16, ["open", "onUpdate:open"])) : (h(), G("div", {
      key: 2,
      class: "group peer hidden md:block",
      "data-state": l(a),
      "data-collapsible": l(a) === "collapsed" ? e.collapsible : "",
      "data-variant": e.variant,
      "data-side": e.side
    }, [
      we("div", {
        class: ae(
          l(R)(
            "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            e.variant === "floating" || e.variant === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )
        )
      }, null, 2),
      we("div", T({
        class: l(R)(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          e.side === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          e.variant === "floating" || e.variant === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+_2px)]" : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          t.class
        )
      }, s.$attrs), [
        we("div", H8, [
          _(s.$slots, "default")
        ])
      ], 16)
    ], 8, z8));
  }
}), yj = /* @__PURE__ */ b({
  __name: "SidebarContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "content",
      class: ae(
        l(R)(
          "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), bj = /* @__PURE__ */ b({
  __name: "SidebarFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "footer",
      class: ae(l(R)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), _j = /* @__PURE__ */ b({
  __name: "SidebarGroup",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "group",
      class: ae(l(R)("relative flex w-full min-w-0 flex-col p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), wj = /* @__PURE__ */ b({
  __name: "SidebarGroupAction",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      "data-sidebar": "group-action",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(R)(
          "absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), xj = /* @__PURE__ */ b({
  __name: "SidebarGroupContent",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "group-content",
      class: ae(l(R)("w-full text-sm", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Cj = /* @__PURE__ */ b({
  __name: "SidebarGroupLabel",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      "data-sidebar": "group-label",
      as: e.as,
      "as-child": e.asChild,
      class: ae(
        l(R)(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear outline-none focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          t.class
        )
      )
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "class"]));
  }
}), Sj = /* @__PURE__ */ b({
  __name: "SidebarHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "header",
      class: ae(l(R)("flex flex-col gap-2 p-2", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), $j = /* @__PURE__ */ b({
  __name: "SidebarInput",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(W_), {
      "data-sidebar": "input",
      class: ae(
        l(R)(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          t.class
        )
      )
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Bj = /* @__PURE__ */ b({
  __name: "SidebarInset",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("main", {
      class: ae(
        l(R)(
          "relative flex min-h-svh flex-1 flex-col bg-background",
          "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), kj = /* @__PURE__ */ b({
  __name: "SidebarMenu",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("ul", {
      "data-sidebar": "menu",
      class: ae(l(R)("flex w-full min-w-0 flex-col gap-1", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Pj = /* @__PURE__ */ b({
  __name: "SidebarMenuAction",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" },
    showOnHover: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      "data-sidebar": "menu-action",
      class: ae(
        l(R)(
          "absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground ring-sidebar-ring transition-transform outline-none peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "after:absolute after:-inset-2 after:md:hidden",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          e.showOnHover && "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground data-[state=open]:opacity-100 md:opacity-0",
          t.class
        )
      ),
      as: e.as,
      "as-child": e.asChild
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "as", "as-child"]));
  }
}), Mj = /* @__PURE__ */ b({
  __name: "SidebarMenuBadge",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(R)(
          "pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium text-sidebar-foreground tabular-nums select-none",
          "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
          "peer-data-[size=sm]/menu-button:top-1",
          "peer-data-[size=default]/menu-button:top-1.5",
          "peer-data-[size=lg]/menu-button:top-2.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Um = /* @__PURE__ */ b({
  __name: "SidebarMenuButtonChild",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), T({
      "data-sidebar": "menu-button",
      "data-size": e.size,
      "data-active": e.isActive,
      class: l(R)(l(W8)({ variant: e.variant, size: e.size }), t.class),
      as: e.as,
      "as-child": e.asChild
    }, n.$attrs), {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-size", "data-active", "class", "as", "as-child"]));
  }
}), Dj = /* @__PURE__ */ b({
  inheritAttrs: !1,
  __name: "SidebarMenuButton",
  props: {
    variant: { default: "default" },
    size: { default: "default" },
    isActive: { type: Boolean },
    class: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    tooltip: {}
  },
  setup(e) {
    const t = e, { isMobile: n, state: a } = uu(), r = Z(t, "tooltip");
    return (o, s) => e.tooltip ? (h(), w(l(ff), { key: 1 }, {
      default: g(() => [
        N(l(vf), { "as-child": "" }, {
          default: g(() => [
            N(Um, oe(le({ ...l(r), ...o.$attrs })), {
              default: g(() => [
                _(o.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }),
        N(l(pf), {
          side: "right",
          align: "center",
          hidden: l(a) !== "collapsed" || l(n)
        }, {
          default: g(() => [
            typeof e.tooltip == "string" ? (h(), G(Ge, { key: 0 }, [
              Re(Fe(e.tooltip), 1)
            ], 64)) : (h(), w(Pt(e.tooltip), { key: 1 }))
          ]),
          _: 1
        }, 8, ["hidden"])
      ]),
      _: 3
    })) : (h(), w(Um, oe(T({ key: 0 }, { ...l(r), ...o.$attrs })), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qj = /* @__PURE__ */ b({
  __name: "SidebarMenuItem",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("li", {
      "data-sidebar": "menu-item",
      class: ae(l(R)("group/menu-item relative", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), jm = /* @__PURE__ */ b({
  __name: "Skeleton",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", {
      "data-slot": "skeleton",
      class: ae(l(R)("animate-pulse rounded-md bg-primary/10", t.class))
    }, null, 2));
  }
}), Aj = /* @__PURE__ */ b({
  __name: "SidebarMenuSkeleton",
  props: {
    showIcon: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e, n = A(() => `${Math.floor(Math.random() * 40) + 50}%`);
    return (a, r) => (h(), G("div", {
      "data-sidebar": "menu-skeleton",
      class: ae(l(R)("flex h-8 items-center gap-2 rounded-md px-2", t.class))
    }, [
      e.showIcon ? (h(), w(l(jm), {
        key: 0,
        class: "size-4 rounded-md",
        "data-sidebar": "menu-skeleton-icon"
      })) : De("", !0),
      N(l(jm), {
        class: "h-4 max-w-[--skeleton-width] flex-1",
        "data-sidebar": "menu-skeleton-text",
        style: dt({ "--skeleton-width": n.value })
      }, null, 8, ["style"])
    ], 2));
  }
}), Ej = /* @__PURE__ */ b({
  __name: "SidebarMenuSub",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("ul", {
      "data-sidebar": "menu-badge",
      class: ae(
        l(R)(
          "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Tj = /* @__PURE__ */ b({
  __name: "SidebarMenuSubButton",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" },
    size: { default: "md" },
    isActive: { type: Boolean },
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(X), {
      "data-sidebar": "menu-sub-button",
      as: e.as,
      "as-child": e.asChild,
      "data-size": e.size,
      "data-active": e.isActive,
      class: ae(
        l(R)(
          "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground ring-sidebar-ring outline-none hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
          "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
          e.size === "sm" && "text-xs",
          e.size === "md" && "text-sm",
          "group-data-[collapsible=icon]:hidden",
          t.class
        )
      )
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-size", "data-active", "class"]));
  }
}), U8 = {};
function j8(e, t) {
  return h(), G("li", null, [
    _(e.$slots, "default")
  ]);
}
const Ij = /* @__PURE__ */ cr(U8, [["render", j8]]), Oj = /* @__PURE__ */ b({
  __name: "SidebarProvider",
  props: {
    defaultOpen: { type: Boolean, default: !rh?.cookie.includes(`${Hm}=false`) },
    open: { type: Boolean, default: void 0 },
    class: {}
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = wl("(max-width: 768px)"), o = I(!1), s = /* @__PURE__ */ Ie(n, "open", a, {
      defaultValue: n.defaultOpen ?? !1,
      passive: n.open === void 0
    });
    function i(f) {
      s.value = f, document.cookie = `${Hm}=${s.value}; path=/; max-age=${I8}`;
    }
    function u(f) {
      o.value = f;
    }
    function d() {
      return r.value ? u(!o.value) : i(!s.value);
    }
    ct("keydown", (f) => {
      f.key === F8 && (f.metaKey || f.ctrlKey) && (f.preventDefault(), d());
    });
    const c = A(() => s.value ? "expanded" : "collapsed");
    return N8({
      state: c,
      open: s,
      setOpen: i,
      isMobile: r,
      openMobile: o,
      setOpenMobile: u,
      toggleSidebar: d
    }), (f, p) => (h(), w(l(of), { "delay-duration": 0 }, {
      default: g(() => [
        we("div", T({
          style: {
            "--sidebar-width": l(O8),
            "--sidebar-width-icon": l(V8)
          },
          class: l(R)(
            "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
            n.class
          )
        }, f.$attrs), [
          _(f.$slots, "default")
        ], 16)
      ]),
      _: 3
    }));
  }
}), Rj = /* @__PURE__ */ b({
  __name: "SidebarRail",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = uu();
    return (a, r) => (h(), G("button", {
      "data-sidebar": "rail",
      "aria-label": "Toggle Sidebar",
      tabindex: -1,
      title: "Toggle Sidebar",
      class: ae(
        l(R)(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          t.class
        )
      ),
      onClick: r[0] || (r[0] = //@ts-ignore
      (...o) => l(n) && l(n)(...o))
    }, [
      _(a.$slots, "default")
    ], 2));
  }
}), Vj = /* @__PURE__ */ b({
  __name: "SidebarSeparator",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(Hi), {
      "data-sidebar": "separator",
      class: ae(l(R)("mx-2 w-auto bg-sidebar-border", t.class))
    }, {
      default: g(() => [
        _(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Fj = /* @__PURE__ */ b({
  __name: "SidebarTrigger",
  props: {
    class: {}
  },
  setup(e) {
    const t = e, { toggleSidebar: n } = uu();
    return (a, r) => (h(), w(l(bs), {
      "data-sidebar": "trigger",
      variant: "ghost",
      size: "icon",
      class: ae(l(R)("h-7 w-7", t.class)),
      onClick: l(n)
    }, {
      default: g(() => [
        N(l(Ly)),
        r[0] || (r[0] = we("span", { class: "sr-only" }, "Toggle Sidebar", -1))
      ]),
      _: 1
    }, 8, ["class", "onClick"]));
  }
}), W8 = an(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Nj = /* @__PURE__ */ b({
  __name: "Slider",
  props: {
    defaultValue: {},
    modelValue: {},
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    inverted: { type: Boolean },
    min: {},
    max: {},
    step: {},
    minStepsBetweenThumbs: {},
    thumbAlignment: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(UA), T({
      class: l(R)(
        "relative flex w-full touch-none items-center select-none data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5 data-[orientation=vertical]:flex-col",
        n.class
      )
    }, l(o)), {
      default: g(() => [
        N(l(QA), { class: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20 data-[orientation=vertical]:w-1.5" }, {
          default: g(() => [
            N(l(GA), { class: "absolute h-full bg-primary data-[orientation=vertical]:w-full" })
          ]),
          _: 1
        }),
        (h(!0), G(Ge, null, Et(e.modelValue, (u, d) => (h(), w(l(JA), {
          key: d,
          class: "block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50"
        }))), 128))
      ]),
      _: 1
    }, 16, ["class"]));
  }
}), Lj = /* @__PURE__ */ b({
  __name: "Sonner",
  props: {
    id: {},
    invert: { type: Boolean },
    theme: {},
    position: {},
    closeButtonPosition: {},
    hotkey: {},
    richColors: { type: Boolean },
    expand: { type: Boolean },
    duration: {},
    gap: {},
    visibleToasts: {},
    closeButton: { type: Boolean },
    toastOptions: {},
    class: {},
    style: {},
    offset: {},
    mobileOffset: {},
    dir: {},
    swipeDirections: {},
    icons: {},
    containerAriaLabel: {}
  },
  setup(e) {
    const n = Z(e, "toastOptions");
    return (a, r) => (h(), w(l(Wy), T({
      class: "toaster group",
      "toast-options": {
        classes: {
          toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
        }
      }
    }, l(n)), {
      "success-icon": g(() => [
        N(l(Ry), { class: "size-4" })
      ]),
      "info-icon": g(() => [
        N(l(Fy), { class: "size-4" })
      ]),
      "warning-icon": g(() => [
        N(l(zy), { class: "size-4" })
      ]),
      "error-icon": g(() => [
        N(l(Ny), { class: "size-4" })
      ]),
      "loading-icon": g(() => [
        we("div", null, [
          N(l(df), { class: "size-4 animate-spin" })
        ])
      ]),
      "close-icon": g(() => [
        N(l(no), { class: "size-4" })
      ]),
      _: 1
    }, 16));
  }
}), zj = /* @__PURE__ */ b({
  __name: "Spinner",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), w(l(df), {
      role: "status",
      "aria-label": "Loading",
      class: ae(l(R)("size-4 animate-spin", t.class))
    }, null, 8, ["class"]));
  }
}), Hj = /* @__PURE__ */ b({
  __name: "Stepper",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    modelValue: {},
    linear: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(qE), T({
      class: l(R)("flex gap-2", n.class)
    }, l(o)), {
      default: g((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Uj = /* @__PURE__ */ b({
  __name: "StepperDescription",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(OE), T(l(a), {
      class: l(R)("text-xs text-muted-foreground", t.class)
    }), {
      default: g((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jj = /* @__PURE__ */ b({
  __name: "StepperIndicator",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(VE), T(l(a), {
      class: l(R)(
        "inline-flex h-8 w-8 items-center justify-center rounded-full text-muted-foreground/50",
        // Disabled
        "group-data-[disabled]:text-muted-foreground group-data-[disabled]:opacity-50",
        // Active
        "group-data-[state=active]:bg-primary group-data-[state=active]:text-primary-foreground",
        // Completed
        "group-data-[state=completed]:bg-accent group-data-[state=completed]:text-accent-foreground",
        t.class
      )
    }), {
      default: g((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Wj = /* @__PURE__ */ b({
  __name: "StepperItem",
  props: {
    step: {},
    disabled: { type: Boolean },
    completed: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(TE), T(l(a), {
      class: l(R)("group flex items-center gap-2 data-[disabled]:pointer-events-none", t.class)
    }), {
      default: g((s) => [
        _(r.$slots, "default", oe(le(s)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Gj = /* @__PURE__ */ b({
  __name: "StepperSeparator",
  props: {
    orientation: {},
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(NE), T(l(a), {
      class: l(R)(
        "bg-muted",
        // Disabled
        "group-data-[disabled]:bg-muted group-data-[disabled]:opacity-50",
        // Completed
        "group-data-[state=completed]:bg-accent-foreground",
        t.class
      )
    }), null, 16, ["class"]));
  }
}), Kj = /* @__PURE__ */ b({
  __name: "StepperTitle",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(zE), T(l(a), {
      class: l(R)("text-md font-semibold whitespace-nowrap", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Yj = /* @__PURE__ */ b({
  __name: "StepperTrigger",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(UE), T(l(a), {
      class: l(R)("flex flex-col items-center gap-1 rounded-md p-1 text-center", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Xj = /* @__PURE__ */ b({
  __name: "Switch",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean },
    id: {},
    value: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(KE), T(l(o), {
      class: l(R)(
        "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
        n.class
      )
    }), {
      default: g(() => [
        N(l(XE), {
          class: ae(
            l(R)(
              "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
            )
          )
        }, {
          default: g(() => [
            _(s.$slots, "thumb")
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), G8 = { class: "relative w-full overflow-auto" }, Jj = /* @__PURE__ */ b({
  __name: "Table",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("div", G8, [
      we("table", {
        class: ae(l(R)("w-full caption-bottom text-sm", t.class))
      }, [
        _(n.$slots, "default")
      ], 2)
    ]));
  }
}), Zj = /* @__PURE__ */ b({
  __name: "TableBody",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("tbody", {
      class: ae(l(R)("[&_tr:last-child]:border-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), K8 = /* @__PURE__ */ b({
  __name: "TableCell",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("td", {
      class: ae(
        l(R)(
          "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Qj = /* @__PURE__ */ b({
  __name: "TableHead",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("th", {
      class: ae(
        l(R)(
          "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-0.5",
          t.class
        )
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), eW = /* @__PURE__ */ b({
  __name: "TableHeader",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("thead", {
      class: ae(l(R)("[&_tr]:border-b", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), tW = /* @__PURE__ */ b({
  __name: "TableFooter",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("tfoot", {
      class: ae(l(R)("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), Y8 = /* @__PURE__ */ b({
  __name: "TableRow",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("tr", {
      class: ae(
        l(R)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", t.class)
      )
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), nW = /* @__PURE__ */ b({
  __name: "TableCaption",
  props: {
    class: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (h(), G("caption", {
      class: ae(l(R)("mt-4 text-sm text-muted-foreground", t.class))
    }, [
      _(n.$slots, "default")
    ], 2));
  }
}), X8 = { class: "flex items-center justify-center py-10" }, aW = /* @__PURE__ */ b({
  __name: "TableEmpty",
  props: {
    class: {},
    colspan: { default: 1 }
  },
  setup(e) {
    const t = e, n = A(() => {
      const { class: a, ...r } = t;
      return r;
    });
    return (a, r) => (h(), w(Y8, null, {
      default: g(() => [
        N(K8, T({
          class: l(R)("p-4 align-middle text-sm whitespace-nowrap text-foreground", t.class)
        }, n.value), {
          default: g(() => [
            we("div", X8, [
              _(a.$slots, "default")
            ])
          ]),
          _: 3
        }, 16, ["class"])
      ]),
      _: 3
    }));
  }
}), rW = /* @__PURE__ */ b({
  __name: "Tabs",
  props: {
    defaultValue: {},
    orientation: {},
    dir: {},
    activationMode: {},
    modelValue: {},
    unmountOnHide: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const r = ve(e, t);
    return (o, s) => (h(), w(l(QE), oe(le(l(r))), {
      default: g(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), oW = /* @__PURE__ */ b({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(tT), T({
      class: l(R)(
        "mt-2 ring-offset-background focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none",
        t.class
      )
    }, l(n)), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sW = /* @__PURE__ */ b({
  __name: "TabsList",
  props: {
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class");
    return (a, r) => (h(), w(l(aT), T(l(n), {
      class: l(R)(
        "inline-flex items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
        t.class
      )
    }), {
      default: g(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), J8 = { class: "truncate" }, lW = /* @__PURE__ */ b({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(oT), T(l(a), {
      class: l(R)(
        "inline-flex items-center justify-center rounded-md px-3 py-1 text-sm font-medium whitespace-nowrap ring-offset-background transition-all focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
        t.class
      )
    }), {
      default: g(() => [
        we("span", J8, [
          _(r.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), iW = /* @__PURE__ */ b({
  __name: "TagsInput",
  props: {
    modelValue: {},
    defaultValue: {},
    addOnPaste: { type: Boolean },
    addOnTab: { type: Boolean },
    addOnBlur: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: {},
    dir: {},
    max: {},
    id: {},
    convertValue: { type: Function },
    displayValue: { type: Function },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {}
  },
  emits: ["update:modelValue", "invalid", "addTag", "removeTag"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(iT), T(l(o), {
      class: l(R)(
        "flex flex-wrap items-center gap-2 rounded-md border border-input bg-background px-3 py-1.5 text-sm",
        n.class
      )
    }), {
      default: g(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), uW = /* @__PURE__ */ b({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(dT), T(l(a), {
      class: l(R)("min-h-5 flex-1 bg-transparent px-1 text-sm focus:outline-none", t.class)
    }), null, 16, ["class"]));
  }
}), dW = /* @__PURE__ */ b({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(pT), T(l(a), {
      class: l(R)(
        "flex h-5 items-center rounded-md bg-secondary ring-offset-background data-[state=active]:ring-2 data-[state=active]:ring-ring data-[state=active]:ring-offset-2",
        t.class
      )
    }), {
      default: g(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), cW = /* @__PURE__ */ b({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(mT), T(l(a), {
      class: l(R)("mr-1 flex rounded bg-transparent", t.class)
    }), {
      default: g(() => [
        _(r.$slots, "default", {}, () => [
          N(l(no), { class: "h-4 w-4" })
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), fW = /* @__PURE__ */ b({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: {},
    class: {}
  },
  setup(e) {
    const t = e, n = Z(t, "class"), a = he(n);
    return (r, o) => (h(), w(l(gT), T(l(a), {
      class: l(R)("rounded bg-transparent px-2 py-0.5 text-sm", t.class)
    }), null, 16, ["class"]));
  }
}), pW = /* @__PURE__ */ b({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null] },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    class: {},
    variant: { default: "default" },
    size: { default: "default" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, r = Z(n, "class", "size", "variant"), o = ve(r, a);
    return (s, i) => (h(), w(l(my), T(l(o), {
      class: l(R)(l(J_)({ variant: e.variant, size: e.size }), n.class)
    }), {
      default: g((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), J_ = an(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground"
      },
      size: {
        default: "h-9 min-w-9 px-2",
        sm: "h-8 min-w-8 px-1.5",
        lg: "h-10 min-w-10 px-2.5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), vW = /* @__PURE__ */ b({
  __name: "ToggleGroup",
  props: {
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {},
    class: {},
    variant: {},
    size: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    Kn("toggleGroup", {
      variant: n.variant,
      size: n.size
    });
    const r = Z(n, "class"), o = ve(r, a);
    return (s, i) => (h(), w(l(_T), T(l(o), {
      class: l(R)("flex items-center justify-center gap-1", n.class)
    }), {
      default: g((u) => [
        _(s.$slots, "default", oe(le(u)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), mW = /* @__PURE__ */ b({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    class: {},
    variant: {},
    size: {}
  },
  setup(e) {
    const t = e, n = xn("toggleGroup"), a = Z(t, "class", "size", "variant"), r = he(a);
    return (o, s) => (h(), w(l(CT), T(l(r), {
      class: l(R)(
        l(J_)({
          variant: l(n)?.variant || e.variant,
          size: l(n)?.size || e.size
        }),
        t.class
      )
    }), {
      default: g((i) => [
        _(o.$slots, "default", oe(le(i)))
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
export {
  DH as Accord,
  CO as Accordion,
  SO as AccordionContent,
  $O as AccordionItem,
  BO as AccordionTrigger,
  qH as Alert,
  AH as AlertDescription,
  P2 as AlertDialog,
  M2 as AlertDialogAction,
  D2 as AlertDialogCancel,
  q2 as AlertDialogContent,
  A2 as AlertDialogDescription,
  E2 as AlertDialogFooter,
  T2 as AlertDialogHeader,
  I2 as AlertDialogTitle,
  cH as AlertDialogTrigger,
  EH as AlertTitle,
  TH as AspectRatio,
  IH as Avatar,
  OH as AvatarFallback,
  RH as AvatarImage,
  VH as Badge,
  FH as Breadcrumb,
  NH as BreadcrumbEllipsis,
  LH as BreadcrumbItem,
  zH as BreadcrumbLink,
  HH as BreadcrumbList,
  UH as BreadcrumbPage,
  jH as BreadcrumbSeparator,
  bs as Button,
  WH as ButtonGroup,
  GH as ButtonGroupSeparator,
  KH as ButtonGroupText,
  mI as COLLAPSIBLE_SIDEBAR_WIDTH,
  hI as COLLAPSIBLE_SIDEBAR_WIDTH_ICON,
  _H as COLLAPSIBLE_SIDEBAR_WIDTH_MOBILE,
  YH as Calendar,
  EO as CalendarCell,
  TO as CalendarCellTrigger,
  IO as CalendarGrid,
  OO as CalendarGridBody,
  RO as CalendarGridHead,
  yv as CalendarGridRow,
  VO as CalendarHeadCell,
  FO as CalendarHeader,
  NO as CalendarHeading,
  LO as CalendarNextButton,
  zO as CalendarPrevButton,
  HO as Card,
  UO as CardContent,
  XH as CardDescription,
  JH as CardFooter,
  jO as CardHeader,
  WO as CardTitle,
  ZH as Carousel,
  QH as CarouselContent,
  e7 as CarouselItem,
  n7 as CarouselNext,
  t7 as CarouselPrevious,
  a7 as ChartCrosshair,
  r7 as ChartLegend,
  o7 as ChartSingleTooltip,
  Kd as ChartTooltip,
  l7 as Checkbox,
  i7 as Collapsible,
  u7 as CollapsibleContent,
  CH as CollapsibleMain,
  BH as CollapsibleMenuButton,
  kH as CollapsibleMenuGroup,
  xH as CollapsibleSidebarDesktop,
  SH as CollapsibleSidebarTrigger,
  d7 as CollapsibleTrigger,
  wH as CollapsibleTwoColumnLayout,
  c7 as Combobox,
  f7 as ComboboxAnchor,
  tH as ComboboxCancel,
  p7 as ComboboxEmpty,
  v7 as ComboboxGroup,
  m7 as ComboboxInput,
  h7 as ComboboxItem,
  nH as ComboboxItemIndicator,
  g7 as ComboboxList,
  y7 as ComboboxSeparator,
  aH as ComboboxTrigger,
  UL as Command,
  B7 as CommandDialog,
  k7 as CommandEmpty,
  P7 as CommandGroup,
  M7 as CommandInput,
  D7 as CommandItem,
  q7 as CommandList,
  A7 as CommandSeparator,
  E7 as CommandShortcut,
  fH as ConfirmDialog,
  T7 as ContextMenu,
  I7 as ContextMenuCheckboxItem,
  O7 as ContextMenuContent,
  R7 as ContextMenuGroup,
  V7 as ContextMenuItem,
  F7 as ContextMenuLabel,
  N7 as ContextMenuRadioGroup,
  L7 as ContextMenuRadioItem,
  z7 as ContextMenuSeparator,
  H7 as ContextMenuShortcut,
  U7 as ContextMenuSub,
  j7 as ContextMenuSubContent,
  W7 as ContextMenuSubTrigger,
  G7 as ContextMenuTrigger,
  jL as Dialog,
  b7 as DialogClose,
  WL as DialogContent,
  _7 as DialogDescription,
  w7 as DialogFooter,
  x7 as DialogHeader,
  C7 as DialogScrollContent,
  S7 as DialogTitle,
  $7 as DialogTrigger,
  K7 as Drawer,
  Y7 as DrawerClose,
  X7 as DrawerContent,
  J7 as DrawerDescription,
  Z7 as DrawerFooter,
  Q7 as DrawerHeader,
  y4 as DrawerOverlay,
  e9 as DrawerTitle,
  t9 as DrawerTrigger,
  n9 as DropdownMenu,
  a9 as DropdownMenuCheckboxItem,
  r9 as DropdownMenuContent,
  o9 as DropdownMenuGroup,
  s9 as DropdownMenuItem,
  l9 as DropdownMenuLabel,
  mP as DropdownMenuPortal,
  i9 as DropdownMenuRadioGroup,
  u9 as DropdownMenuRadioItem,
  d9 as DropdownMenuSeparator,
  c9 as DropdownMenuShortcut,
  f9 as DropdownMenuSub,
  p9 as DropdownMenuSubContent,
  v9 as DropdownMenuSubTrigger,
  m9 as DropdownMenuTrigger,
  h9 as Empty,
  g9 as EmptyContent,
  y9 as EmptyDescription,
  b9 as EmptyHeader,
  _9 as EmptyMedia,
  w9 as EmptyTitle,
  j_ as FORM_ITEM_INJECTION_KEY,
  x9 as Field,
  C9 as FieldContent,
  S9 as FieldDescription,
  $9 as FieldError,
  B9 as FieldGroup,
  k9 as FieldLabel,
  P9 as FieldLegend,
  M9 as FieldSeparator,
  D9 as FieldSet,
  q9 as FieldTitle,
  PH as Flasher,
  E9 as Form,
  I9 as FormControl,
  O9 as FormDescription,
  A9 as FormField,
  T9 as FormFieldArray,
  R9 as FormItem,
  V9 as FormLabel,
  F9 as FormMessage,
  vH as Header,
  MH as Heading,
  N9 as HoverCard,
  L9 as HoverCardContent,
  z9 as HoverCardTrigger,
  W_ as Input,
  H9 as InputGroup,
  U9 as InputGroupAddon,
  j9 as InputGroupButton,
  W9 as InputGroupInput,
  G9 as InputGroupText,
  K9 as InputGroupTextarea,
  Y9 as InputOTP,
  X9 as InputOTPGroup,
  J9 as InputOTPSeparator,
  Z9 as InputOTPSlot,
  Q9 as Item,
  eU as ItemActions,
  tU as ItemContent,
  nU as ItemDescription,
  aU as ItemFooter,
  rU as ItemGroup,
  oU as ItemHeader,
  sU as ItemMedia,
  lU as ItemSeparator,
  iU as ItemTitle,
  uU as Kbd,
  dU as KbdGroup,
  T_ as Label,
  mH as Main,
  cU as Menubar,
  fU as MenubarCheckboxItem,
  pU as MenubarContent,
  vU as MenubarGroup,
  mU as MenubarItem,
  hU as MenubarLabel,
  gU as MenubarMenu,
  yU as MenubarRadioGroup,
  bU as MenubarRadioItem,
  _U as MenubarSeparator,
  wU as MenubarShortcut,
  xU as MenubarSub,
  CU as MenubarSubContent,
  SU as MenubarSubTrigger,
  $U as MenubarTrigger,
  BU as NavigationMenu,
  kU as NavigationMenuContent,
  PU as NavigationMenuIndicator,
  MU as NavigationMenuItem,
  DU as NavigationMenuLink,
  qU as NavigationMenuList,
  AU as NavigationMenuTrigger,
  u8 as NavigationMenuViewport,
  EU as NumberField,
  TU as NumberFieldContent,
  IU as NumberFieldDecrement,
  OU as NumberFieldIncrement,
  RU as NumberFieldInput,
  VU as Pagination,
  FU as PaginationContent,
  NU as PaginationEllipsis,
  LU as PaginationFirst,
  zU as PaginationItem,
  HU as PaginationLast,
  UU as PaginationNext,
  jU as PaginationPrevious,
  WU as PinInput,
  GU as PinInputGroup,
  KU as PinInputSeparator,
  YU as PinInputSlot,
  XU as Popover,
  rH as PopoverAnchor,
  JU as PopoverContent,
  ZU as PopoverTrigger,
  QU as Progress,
  ej as RadioGroup,
  tj as RadioGroupItem,
  nj as RangeCalendar,
  f8 as RangeCalendarCell,
  p8 as RangeCalendarCellTrigger,
  v8 as RangeCalendarGrid,
  m8 as RangeCalendarGridBody,
  h8 as RangeCalendarGridHead,
  zm as RangeCalendarGridRow,
  g8 as RangeCalendarHeadCell,
  y8 as RangeCalendarHeader,
  b8 as RangeCalendarHeading,
  _8 as RangeCalendarNextButton,
  w8 as RangeCalendarPrevButton,
  aj as ResizableHandle,
  oH as ResizablePanel,
  rj as ResizablePanelGroup,
  oj as ScrollArea,
  C8 as ScrollBar,
  S8 as Select,
  $8 as SelectContent,
  sj as SelectGroup,
  k8 as SelectItem,
  lj as SelectItemText,
  ij as SelectLabel,
  P8 as SelectScrollDownButton,
  M8 as SelectScrollUpButton,
  uj as SelectSeparator,
  D8 as SelectTrigger,
  q8 as SelectValue,
  Hi as Separator,
  A8 as Sheet,
  cj as SheetClose,
  T8 as SheetContent,
  fj as SheetDescription,
  pj as SheetFooter,
  vj as SheetHeader,
  E8 as SheetOverlay,
  mj as SheetTitle,
  hj as SheetTrigger,
  gj as Sidebar,
  yj as SidebarContent,
  bj as SidebarFooter,
  _j as SidebarGroup,
  wj as SidebarGroupAction,
  xj as SidebarGroupContent,
  Cj as SidebarGroupLabel,
  Sj as SidebarHeader,
  $j as SidebarInput,
  Bj as SidebarInset,
  kj as SidebarMenu,
  Pj as SidebarMenuAction,
  Mj as SidebarMenuBadge,
  Dj as SidebarMenuButton,
  qj as SidebarMenuItem,
  Aj as SidebarMenuSkeleton,
  Ej as SidebarMenuSub,
  Tj as SidebarMenuSubButton,
  Ij as SidebarMenuSubItem,
  Oj as SidebarProvider,
  Rj as SidebarRail,
  Vj as SidebarSeparator,
  Fj as SidebarTrigger,
  dj as SimpleSelect,
  jm as Skeleton,
  Nj as Slider,
  zj as Spinner,
  Hj as Stepper,
  Uj as StepperDescription,
  jj as StepperIndicator,
  Wj as StepperItem,
  Gj as StepperSeparator,
  Kj as StepperTitle,
  Yj as StepperTrigger,
  Xj as Switch,
  Jj as Table,
  Zj as TableBody,
  nW as TableCaption,
  K8 as TableCell,
  aW as TableEmpty,
  tW as TableFooter,
  Qj as TableHead,
  eW as TableHeader,
  Y8 as TableRow,
  rW as Tabs,
  oW as TabsContent,
  sW as TabsList,
  lW as TabsTrigger,
  iW as TagsInput,
  uW as TagsInputInput,
  dW as TagsInputItem,
  cW as TagsInputItemDelete,
  fW as TagsInputItemText,
  Pz as Textarea,
  $H as Tip,
  Lj as Toaster,
  pW as Toggle,
  vW as ToggleGroup,
  mW as ToggleGroupItem,
  ff as Tooltip,
  pf as TooltipContent,
  CI as TooltipProvider,
  vf as TooltipTrigger,
  pH as TwoColumnLayout,
  hH as TwoColumnLayoutSidebar,
  gH as TwoColumnLayoutSidebarDesktop,
  yH as TwoColumnLayoutSidebarMobile,
  bH as TwoColumnLayoutSidebarTrigger,
  kO as alertVariants,
  PO as avatarVariant,
  MO as badgeVariants,
  qO as buttonGroupVariants,
  Kt as buttonVariants,
  R as cn,
  lH as createContext,
  s7 as defaultColors,
  x4 as emptyMediaVariants,
  P4 as fieldVariants,
  Mz as inputGroupAddonVariants,
  Dz as inputGroupButtonVariants,
  o8 as itemMediaVariants,
  r8 as itemVariants,
  d8 as navigationMenuTriggerStyle,
  Q8 as preset,
  YL as provideCommandContext,
  JL as provideCommandGroupContext,
  W8 as sidebarMenuButtonVariants,
  J_ as toggleVariants,
  ji as useCarousel,
  _s as useCollapsibleSidebar,
  ou as useCommand,
  XL as useCommandGroup,
  V2 as useConfirmDialog,
  _O as useFlasher,
  dH as useMobileBottomNav,
  iH as useMobileNavigation,
  uu as useSidebar,
  uH as useSwipeNavigation,
  sH as valueUpdater
};
